[PATCH]  private  final  char  escape;	[BUG]  [BUGGY]  private  final  String  escape;[CE]  incompatible  types  [CONTEXT]  private  final  boolean  isEncapsulating;  private  final  boolean  isEscaping;  private  final  boolean  isCommentEnabled;  private  final  char  delimiter;  [BUGGY]  private  final  String  escape;  [BUGGY]  private  final  char  encapsulator;  private  final  char  commmentStart;  final  boolean  surroundingSpacesIgnored;  final  boolean  emptyLinesIgnored;    [CLASS]  Lexer    [VARIABLES]  	[P8_Replace_Mix]
[PATCH]  this.format  =  format;	[BUG]  [BUGGY]  this.format  =  null;[FE]  null  testNextToken1  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  Lexer(CSVFormat  format,  ExtendedBufferedReader  in)  {  [BUGGY]  this.format  =  null;  [BUGGY]  this.in  =  in;  this.isEncapsulating  =  format.isEncapsulating();  this.isEscaping  =  format.isEscaping();  this.isCommentEnabled  =  format.isCommentingEnabled();  this.delimiter  =  format.getDelimiter();  this.escape  =  format.getEscape();  this.encapsulator  =  format.getEncapsulator();  this.commmentStart  =  format.getCommentStart();  this.surroundingSpacesIgnored  =  format.isSurroundingSpacesIgnored();  this.emptyLinesIgnored  =  format.isEmptyLinesIgnored();  }    [CLASS]  Lexer  [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)    CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char  commmentStart  delimiter  encapsulator  escape  ExtendedBufferedReader  in  CSVFormat  format  boolean  emptyLinesIgnored  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored    	[P8_Replace_Mix]
[PATCH]  this.in  =  in;	[BUG]  [BUGGY]  this.in  =  null;[FE]  null  testNextToken1  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  Lexer(CSVFormat  format,  ExtendedBufferedReader  in)  {  this.format  =  format;  [BUGGY]  this.in  =  null;  [BUGGY]  this.isEncapsulating  =  format.isEncapsulating();  this.isEscaping  =  format.isEscaping();  this.isCommentEnabled  =  format.isCommentingEnabled();  this.delimiter  =  format.getDelimiter();  this.escape  =  format.getEscape();  this.encapsulator  =  format.getEncapsulator();  this.commmentStart  =  format.getCommentStart();  this.surroundingSpacesIgnored  =  format.isSurroundingSpacesIgnored();  this.emptyLinesIgnored  =  format.isEmptyLinesIgnored();  }    [CLASS]  Lexer  [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)    CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char  commmentStart  delimiter  encapsulator  escape  ExtendedBufferedReader  in  CSVFormat  format  boolean  emptyLinesIgnored  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored    	[P8_Replace_Mix]
[PATCH]  this.isEncapsulating  =  format.isEncapsulating  (  )  ;	[BUG]  [BUGGY]  this.isEncapsulating  =  null.isEncapsulating(  )  ;[CE]  <null>  cannot  be  dereferenced  [CONTEXT]  Lexer(CSVFormat  format,  ExtendedBufferedReader  in)  {  this.format  =  format;  this.in  =  in;  [BUGGY]  this.isEncapsulating  =  null.isEncapsulating(  )  ;  [BUGGY]  this.isEscaping  =  format.isEscaping();  this.isCommentEnabled  =  format.isCommentingEnabled();  this.delimiter  =  format.getDelimiter();  this.escape  =  format.getEscape();  this.encapsulator  =  format.getEncapsulator();  this.commmentStart  =  format.getCommentStart();  this.surroundingSpacesIgnored  =  format.isSurroundingSpacesIgnored();  this.emptyLinesIgnored  =  format.isEmptyLinesIgnored();  }    [CLASS]  Lexer  [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)    CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char  commmentStart  delimiter  encapsulator  escape  ExtendedBufferedReader  in  CSVFormat  format  boolean  emptyLinesIgnored  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored    	[P8_Replace_Mix]
[PATCH]  this.isEncapsulating  =  format.isEncapsulating  (  )  ;	[BUG]  [BUGGY]  this.escape  =  format.getEscape(  )  ;this.isEncapsulating  =  format.isEncapsulating(  )  ;[CE]  variable  escape  might  already  have  been  assigned  [CONTEXT]  Lexer(CSVFormat  format,  ExtendedBufferedReader  in)  {  this.format  =  format;  this.in  =  in;  [BUGGY]  this.escape  =  format.getEscape(  )  ;this.isEncapsulating  =  format.isEncapsulating(  )  ;  [BUGGY]  this.isEscaping  =  format.isEscaping();  this.isCommentEnabled  =  format.isCommentingEnabled();  this.delimiter  =  format.getDelimiter();  this.escape  =  format.getEscape();  this.encapsulator  =  format.getEncapsulator();  this.commmentStart  =  format.getCommentStart();  this.surroundingSpacesIgnored  =  format.isSurroundingSpacesIgnored();  this.emptyLinesIgnored  =  format.isEmptyLinesIgnored();  }    [CLASS]  Lexer  [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)    CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char  commmentStart  delimiter  encapsulator  escape  ExtendedBufferedReader  in  CSVFormat  format  boolean  emptyLinesIgnored  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored    	[P11_Insert_Donor_Statement]
[PATCH]  this.isEncapsulating  =  format.isEncapsulating  (  )  ;	[BUG]  [BUGGY]  this.isCommentEnabled  =  format.isCommentingEnabled(  )  ;this.isEncapsulating  =  format.isEncapsulating(  )  ;[CE]  variable  isCommentEnabled  might  already  have  been  assigned  [CONTEXT]  Lexer(CSVFormat  format,  ExtendedBufferedReader  in)  {  this.format  =  format;  this.in  =  in;  [BUGGY]  this.isCommentEnabled  =  format.isCommentingEnabled(  )  ;this.isEncapsulating  =  format.isEncapsulating(  )  ;  [BUGGY]  this.isEscaping  =  format.isEscaping();  this.isCommentEnabled  =  format.isCommentingEnabled();  this.delimiter  =  format.getDelimiter();  this.escape  =  format.getEscape();  this.encapsulator  =  format.getEncapsulator();  this.commmentStart  =  format.getCommentStart();  this.surroundingSpacesIgnored  =  format.isSurroundingSpacesIgnored();  this.emptyLinesIgnored  =  format.isEmptyLinesIgnored();  }    [CLASS]  Lexer  [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)    CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char  commmentStart  delimiter  encapsulator  escape  ExtendedBufferedReader  in  CSVFormat  format  boolean  emptyLinesIgnored  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored    	[P11_Insert_Donor_Statement]
[PATCH]  this.isEncapsulating  =  format.isEncapsulating  (  )  ;	[BUG]  [BUGGY]  this.isEscaping  =  format.isEscaping(  )  ;this.isEncapsulating  =  format.isEncapsulating(  )  ;[CE]  variable  isEscaping  might  already  have  been  assigned  [CONTEXT]  Lexer(CSVFormat  format,  ExtendedBufferedReader  in)  {  this.format  =  format;  this.in  =  in;  [BUGGY]  this.isEscaping  =  format.isEscaping(  )  ;this.isEncapsulating  =  format.isEncapsulating(  )  ;  [BUGGY]  this.isEscaping  =  format.isEscaping();  this.isCommentEnabled  =  format.isCommentingEnabled();  this.delimiter  =  format.getDelimiter();  this.escape  =  format.getEscape();  this.encapsulator  =  format.getEncapsulator();  this.commmentStart  =  format.getCommentStart();  this.surroundingSpacesIgnored  =  format.isSurroundingSpacesIgnored();  this.emptyLinesIgnored  =  format.isEmptyLinesIgnored();  }    [CLASS]  Lexer  [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)    CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char  commmentStart  delimiter  encapsulator  escape  ExtendedBufferedReader  in  CSVFormat  format  boolean  emptyLinesIgnored  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored    	[P11_Insert_Donor_Statement]
[PATCH]  this.isEncapsulating  =  format.isEncapsulating  (  )  ;	[BUG]  [BUGGY]  this.encapsulator  =  format.getEncapsulator(  )  ;this.isEncapsulating  =  format.isEncapsulating(  )  ;[CE]  variable  encapsulator  might  already  have  been  assigned  [CONTEXT]  Lexer(CSVFormat  format,  ExtendedBufferedReader  in)  {  this.format  =  format;  this.in  =  in;  [BUGGY]  this.encapsulator  =  format.getEncapsulator(  )  ;this.isEncapsulating  =  format.isEncapsulating(  )  ;  [BUGGY]  this.isEscaping  =  format.isEscaping();  this.isCommentEnabled  =  format.isCommentingEnabled();  this.delimiter  =  format.getDelimiter();  this.escape  =  format.getEscape();  this.encapsulator  =  format.getEncapsulator();  this.commmentStart  =  format.getCommentStart();  this.surroundingSpacesIgnored  =  format.isSurroundingSpacesIgnored();  this.emptyLinesIgnored  =  format.isEmptyLinesIgnored();  }    [CLASS]  Lexer  [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)    CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char  commmentStart  delimiter  encapsulator  escape  ExtendedBufferedReader  in  CSVFormat  format  boolean  emptyLinesIgnored  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored    	[P11_Insert_Donor_Statement]
[PATCH]  this.isEncapsulating  =  format.isEncapsulating  (  )  ;	[BUG]  [BUGGY]  this.isEscaping(  )  =  format[CE]  ';'  expected  [CONTEXT]  Lexer(CSVFormat  format,  ExtendedBufferedReader  in)  {  this.format  =  format;  this.in  =  in;  [BUGGY]  this.isEscaping(  )  =  format  [BUGGY]  this.isEscaping  =  format.isEscaping();  this.isCommentEnabled  =  format.isCommentingEnabled();  this.delimiter  =  format.getDelimiter();  this.escape  =  format.getEscape();  this.encapsulator  =  format.getEncapsulator();  this.commmentStart  =  format.getCommentStart();  this.surroundingSpacesIgnored  =  format.isSurroundingSpacesIgnored();  this.emptyLinesIgnored  =  format.isEmptyLinesIgnored();  }    [CLASS]  Lexer  [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)    CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char  commmentStart  delimiter  encapsulator  escape  ExtendedBufferedReader  in  CSVFormat  format  boolean  emptyLinesIgnored  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored    	[P7_Replace_Invocation]
[PATCH]  this.isEscaping  =  format.isEscaping  (  )  ;	[BUG]  [BUGGY]  this.isEscaping  =  null.isEscaping(  )  ;[CE]  <null>  cannot  be  dereferenced  [CONTEXT]  Lexer(CSVFormat  format,  ExtendedBufferedReader  in)  {  this.format  =  format;  this.in  =  in;  this.isEncapsulating  =  format.isEncapsulating();  [BUGGY]  this.isEscaping  =  null.isEscaping(  )  ;  [BUGGY]  this.isCommentEnabled  =  format.isCommentingEnabled();  this.delimiter  =  format.getDelimiter();  this.escape  =  format.getEscape();  this.encapsulator  =  format.getEncapsulator();  this.commmentStart  =  format.getCommentStart();  this.surroundingSpacesIgnored  =  format.isSurroundingSpacesIgnored();  this.emptyLinesIgnored  =  format.isEmptyLinesIgnored();  }    [CLASS]  Lexer  [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)    CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char  commmentStart  delimiter  encapsulator  escape  ExtendedBufferedReader  in  CSVFormat  format  boolean  emptyLinesIgnored  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored    	[P8_Replace_Mix]
[PATCH]  this.isEscaping  =  format.isEscaping  (  )  ;	[BUG]  [BUGGY]  this.emptyLinesIgnored  =  format.isEmptyLinesIgnored(  )  ;this.isEscaping  =  format.isEscaping(  )  ;[CE]  variable  emptyLinesIgnored  might  already  have  been  assigned  [CONTEXT]  Lexer(CSVFormat  format,  ExtendedBufferedReader  in)  {  this.format  =  format;  this.in  =  in;  this.isEncapsulating  =  format.isEncapsulating();  [BUGGY]  this.emptyLinesIgnored  =  format.isEmptyLinesIgnored(  )  ;this.isEscaping  =  format.isEscaping(  )  ;  [BUGGY]  this.isCommentEnabled  =  format.isCommentingEnabled();  this.delimiter  =  format.getDelimiter();  this.escape  =  format.getEscape();  this.encapsulator  =  format.getEncapsulator();  this.commmentStart  =  format.getCommentStart();  this.surroundingSpacesIgnored  =  format.isSurroundingSpacesIgnored();  this.emptyLinesIgnored  =  format.isEmptyLinesIgnored();  }    [CLASS]  Lexer  [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)    CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char  commmentStart  delimiter  encapsulator  escape  ExtendedBufferedReader  in  CSVFormat  format  boolean  emptyLinesIgnored  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored    	[P11_Insert_Donor_Statement]
[PATCH]  this.isEscaping  =  format.isEscaping  (  )  ;	[BUG]  [BUGGY]  this.escape  =  format.getEscape(  )  ;this.isEscaping  =  format.isEscaping(  )  ;[CE]  variable  escape  might  already  have  been  assigned  [CONTEXT]  Lexer(CSVFormat  format,  ExtendedBufferedReader  in)  {  this.format  =  format;  this.in  =  in;  this.isEncapsulating  =  format.isEncapsulating();  [BUGGY]  this.escape  =  format.getEscape(  )  ;this.isEscaping  =  format.isEscaping(  )  ;  [BUGGY]  this.isCommentEnabled  =  format.isCommentingEnabled();  this.delimiter  =  format.getDelimiter();  this.escape  =  format.getEscape();  this.encapsulator  =  format.getEncapsulator();  this.commmentStart  =  format.getCommentStart();  this.surroundingSpacesIgnored  =  format.isSurroundingSpacesIgnored();  this.emptyLinesIgnored  =  format.isEmptyLinesIgnored();  }    [CLASS]  Lexer  [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)    CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char  commmentStart  delimiter  encapsulator  escape  ExtendedBufferedReader  in  CSVFormat  format  boolean  emptyLinesIgnored  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored    	[P11_Insert_Donor_Statement]
[PATCH]  this.isEscaping  =  format.isEscaping  (  )  ;	[BUG]  [BUGGY]  this.isEncapsulating  =  format.isEncapsulating(  )  ;this.isEscaping  =  format.isEscaping(  )  ;[CE]  variable  isEncapsulating  might  already  have  been  assigned  [CONTEXT]  Lexer(CSVFormat  format,  ExtendedBufferedReader  in)  {  this.format  =  format;  this.in  =  in;  this.isEncapsulating  =  format.isEncapsulating();  [BUGGY]  this.isEncapsulating  =  format.isEncapsulating(  )  ;this.isEscaping  =  format.isEscaping(  )  ;  [BUGGY]  this.isCommentEnabled  =  format.isCommentingEnabled();  this.delimiter  =  format.getDelimiter();  this.escape  =  format.getEscape();  this.encapsulator  =  format.getEncapsulator();  this.commmentStart  =  format.getCommentStart();  this.surroundingSpacesIgnored  =  format.isSurroundingSpacesIgnored();  this.emptyLinesIgnored  =  format.isEmptyLinesIgnored();  }    [CLASS]  Lexer  [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)    CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char  commmentStart  delimiter  encapsulator  escape  ExtendedBufferedReader  in  CSVFormat  format  boolean  emptyLinesIgnored  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored    	[P11_Insert_Donor_Statement]
[PATCH]  this.isEscaping  =  format.isEscaping  (  )  ;	[BUG]  [BUGGY]  this.isCommentEnabled  =  format.isCommentingEnabled(  )  ;this.isEscaping  =  format.isEscaping(  )  ;[CE]  variable  isCommentEnabled  might  already  have  been  assigned  [CONTEXT]  Lexer(CSVFormat  format,  ExtendedBufferedReader  in)  {  this.format  =  format;  this.in  =  in;  this.isEncapsulating  =  format.isEncapsulating();  [BUGGY]  this.isCommentEnabled  =  format.isCommentingEnabled(  )  ;this.isEscaping  =  format.isEscaping(  )  ;  [BUGGY]  this.isCommentEnabled  =  format.isCommentingEnabled();  this.delimiter  =  format.getDelimiter();  this.escape  =  format.getEscape();  this.encapsulator  =  format.getEncapsulator();  this.commmentStart  =  format.getCommentStart();  this.surroundingSpacesIgnored  =  format.isSurroundingSpacesIgnored();  this.emptyLinesIgnored  =  format.isEmptyLinesIgnored();  }    [CLASS]  Lexer  [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)    CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char  commmentStart  delimiter  encapsulator  escape  ExtendedBufferedReader  in  CSVFormat  format  boolean  emptyLinesIgnored  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored    	[P11_Insert_Donor_Statement]
[PATCH]  this.isEscaping  =  format.isEscaping  (  )  ;	[BUG]  [BUGGY]  this.encapsulator  =  format.getEncapsulator(  )  ;this.isEscaping  =  format.isEscaping(  )  ;[CE]  variable  encapsulator  might  already  have  been  assigned  [CONTEXT]  Lexer(CSVFormat  format,  ExtendedBufferedReader  in)  {  this.format  =  format;  this.in  =  in;  this.isEncapsulating  =  format.isEncapsulating();  [BUGGY]  this.encapsulator  =  format.getEncapsulator(  )  ;this.isEscaping  =  format.isEscaping(  )  ;  [BUGGY]  this.isCommentEnabled  =  format.isCommentingEnabled();  this.delimiter  =  format.getDelimiter();  this.escape  =  format.getEscape();  this.encapsulator  =  format.getEncapsulator();  this.commmentStart  =  format.getCommentStart();  this.surroundingSpacesIgnored  =  format.isSurroundingSpacesIgnored();  this.emptyLinesIgnored  =  format.isEmptyLinesIgnored();  }    [CLASS]  Lexer  [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)    CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char  commmentStart  delimiter  encapsulator  escape  ExtendedBufferedReader  in  CSVFormat  format  boolean  emptyLinesIgnored  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored    	[P11_Insert_Donor_Statement]
[PATCH]  this.isEscaping  =  format.isEscaping  (  )  ;	[BUG]  [BUGGY]  this.delimiter  =  format.getDelimiter(  )  ;this.isEscaping  =  format.isEscaping(  )  ;[CE]  variable  delimiter  might  already  have  been  assigned  [CONTEXT]  Lexer(CSVFormat  format,  ExtendedBufferedReader  in)  {  this.format  =  format;  this.in  =  in;  this.isEncapsulating  =  format.isEncapsulating();  [BUGGY]  this.delimiter  =  format.getDelimiter(  )  ;this.isEscaping  =  format.isEscaping(  )  ;  [BUGGY]  this.isCommentEnabled  =  format.isCommentingEnabled();  this.delimiter  =  format.getDelimiter();  this.escape  =  format.getEscape();  this.encapsulator  =  format.getEncapsulator();  this.commmentStart  =  format.getCommentStart();  this.surroundingSpacesIgnored  =  format.isSurroundingSpacesIgnored();  this.emptyLinesIgnored  =  format.isEmptyLinesIgnored();  }    [CLASS]  Lexer  [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)    CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char  commmentStart  delimiter  encapsulator  escape  ExtendedBufferedReader  in  CSVFormat  format  boolean  emptyLinesIgnored  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored    	[P11_Insert_Donor_Statement]
[PATCH]  this.isCommentEnabled  =  format.isCommentingEnabled  (  )  ;	[BUG]  [BUGGY]  this.isCommentEnabled  =  format.getCommentStart(  )  ;[CE]  incompatible  types  [CONTEXT]  Lexer(CSVFormat  format,  ExtendedBufferedReader  in)  {  this.format  =  format;  this.in  =  in;  this.isEncapsulating  =  format.isEncapsulating();  this.isEscaping  =  format.isEscaping();  [BUGGY]  this.isCommentEnabled  =  format.getCommentStart(  )  ;  [BUGGY]  this.delimiter  =  format.getDelimiter();  this.escape  =  format.getEscape();  this.encapsulator  =  format.getEncapsulator();  this.commmentStart  =  format.getCommentStart();  this.surroundingSpacesIgnored  =  format.isSurroundingSpacesIgnored();  this.emptyLinesIgnored  =  format.isEmptyLinesIgnored();  }    [CLASS]  Lexer  [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)    CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char  commmentStart  delimiter  encapsulator  escape  ExtendedBufferedReader  in  CSVFormat  format  boolean  emptyLinesIgnored  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored    	[P7_Replace_Invocation]
[PATCH]  this.isCommentEnabled  =  format.isCommentingEnabled  (  )  ;	[BUG]  [BUGGY]  this.isCommentEnabled  =  null.isCommentingEnabled(  )  ;[CE]  <null>  cannot  be  dereferenced  [CONTEXT]  Lexer(CSVFormat  format,  ExtendedBufferedReader  in)  {  this.format  =  format;  this.in  =  in;  this.isEncapsulating  =  format.isEncapsulating();  this.isEscaping  =  format.isEscaping();  [BUGGY]  this.isCommentEnabled  =  null.isCommentingEnabled(  )  ;  [BUGGY]  this.delimiter  =  format.getDelimiter();  this.escape  =  format.getEscape();  this.encapsulator  =  format.getEncapsulator();  this.commmentStart  =  format.getCommentStart();  this.surroundingSpacesIgnored  =  format.isSurroundingSpacesIgnored();  this.emptyLinesIgnored  =  format.isEmptyLinesIgnored();  }    [CLASS]  Lexer  [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)    CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char  commmentStart  delimiter  encapsulator  escape  ExtendedBufferedReader  in  CSVFormat  format  boolean  emptyLinesIgnored  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored    	[P8_Replace_Mix]
[PATCH]  this.isCommentEnabled  =  format.isCommentingEnabled  (  )  ;	[BUG]  [BUGGY]  this.emptyLinesIgnored  =  format.isEmptyLinesIgnored(  )  ;this.isCommentEnabled  =  format.isCommentingEnabled(  )  ;[CE]  variable  emptyLinesIgnored  might  already  have  been  assigned  [CONTEXT]  Lexer(CSVFormat  format,  ExtendedBufferedReader  in)  {  this.format  =  format;  this.in  =  in;  this.isEncapsulating  =  format.isEncapsulating();  this.isEscaping  =  format.isEscaping();  [BUGGY]  this.emptyLinesIgnored  =  format.isEmptyLinesIgnored(  )  ;this.isCommentEnabled  =  format.isCommentingEnabled(  )  ;  [BUGGY]  this.delimiter  =  format.getDelimiter();  this.escape  =  format.getEscape();  this.encapsulator  =  format.getEncapsulator();  this.commmentStart  =  format.getCommentStart();  this.surroundingSpacesIgnored  =  format.isSurroundingSpacesIgnored();  this.emptyLinesIgnored  =  format.isEmptyLinesIgnored();  }    [CLASS]  Lexer  [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)    CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char  commmentStart  delimiter  encapsulator  escape  ExtendedBufferedReader  in  CSVFormat  format  boolean  emptyLinesIgnored  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored    	[P11_Insert_Donor_Statement]
[PATCH]  this.isCommentEnabled  =  format.isCommentingEnabled  (  )  ;	[BUG]  [BUGGY]  this.escape  =  format.getEscape(  )  ;this.isCommentEnabled  =  format.isCommentingEnabled(  )  ;[CE]  variable  escape  might  already  have  been  assigned  [CONTEXT]  Lexer(CSVFormat  format,  ExtendedBufferedReader  in)  {  this.format  =  format;  this.in  =  in;  this.isEncapsulating  =  format.isEncapsulating();  this.isEscaping  =  format.isEscaping();  [BUGGY]  this.escape  =  format.getEscape(  )  ;this.isCommentEnabled  =  format.isCommentingEnabled(  )  ;  [BUGGY]  this.delimiter  =  format.getDelimiter();  this.escape  =  format.getEscape();  this.encapsulator  =  format.getEncapsulator();  this.commmentStart  =  format.getCommentStart();  this.surroundingSpacesIgnored  =  format.isSurroundingSpacesIgnored();  this.emptyLinesIgnored  =  format.isEmptyLinesIgnored();  }    [CLASS]  Lexer  [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)    CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char  commmentStart  delimiter  encapsulator  escape  ExtendedBufferedReader  in  CSVFormat  format  boolean  emptyLinesIgnored  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored    	[P11_Insert_Donor_Statement]
[PATCH]  this.isCommentEnabled  =  format.isCommentingEnabled  (  )  ;	[BUG]  [BUGGY]  this.isEncapsulating  =  format.isEncapsulating(  )  ;this.isCommentEnabled  =  format.isCommentingEnabled(  )  ;[CE]  variable  isEncapsulating  might  already  have  been  assigned  [CONTEXT]  Lexer(CSVFormat  format,  ExtendedBufferedReader  in)  {  this.format  =  format;  this.in  =  in;  this.isEncapsulating  =  format.isEncapsulating();  this.isEscaping  =  format.isEscaping();  [BUGGY]  this.isEncapsulating  =  format.isEncapsulating(  )  ;this.isCommentEnabled  =  format.isCommentingEnabled(  )  ;  [BUGGY]  this.delimiter  =  format.getDelimiter();  this.escape  =  format.getEscape();  this.encapsulator  =  format.getEncapsulator();  this.commmentStart  =  format.getCommentStart();  this.surroundingSpacesIgnored  =  format.isSurroundingSpacesIgnored();  this.emptyLinesIgnored  =  format.isEmptyLinesIgnored();  }    [CLASS]  Lexer  [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)    CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char  commmentStart  delimiter  encapsulator  escape  ExtendedBufferedReader  in  CSVFormat  format  boolean  emptyLinesIgnored  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored    	[P11_Insert_Donor_Statement]
[PATCH]  this.isCommentEnabled  =  format.isCommentingEnabled  (  )  ;	[BUG]  [BUGGY]  this.isEscaping  =  format.isEscaping(  )  ;this.isCommentEnabled  =  format.isCommentingEnabled(  )  ;[CE]  variable  isEscaping  might  already  have  been  assigned  [CONTEXT]  Lexer(CSVFormat  format,  ExtendedBufferedReader  in)  {  this.format  =  format;  this.in  =  in;  this.isEncapsulating  =  format.isEncapsulating();  this.isEscaping  =  format.isEscaping();  [BUGGY]  this.isEscaping  =  format.isEscaping(  )  ;this.isCommentEnabled  =  format.isCommentingEnabled(  )  ;  [BUGGY]  this.delimiter  =  format.getDelimiter();  this.escape  =  format.getEscape();  this.encapsulator  =  format.getEncapsulator();  this.commmentStart  =  format.getCommentStart();  this.surroundingSpacesIgnored  =  format.isSurroundingSpacesIgnored();  this.emptyLinesIgnored  =  format.isEmptyLinesIgnored();  }    [CLASS]  Lexer  [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)    CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char  commmentStart  delimiter  encapsulator  escape  ExtendedBufferedReader  in  CSVFormat  format  boolean  emptyLinesIgnored  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored    	[P11_Insert_Donor_Statement]
[PATCH]  this.isCommentEnabled  =  format.isCommentingEnabled  (  )  ;	[BUG]  [BUGGY]  this.commmentStart  =  format.getCommentStart(  )  ;this.isCommentEnabled  =  format.isCommentingEnabled(  )  ;[CE]  variable  commmentStart  might  already  have  been  assigned  [CONTEXT]  Lexer(CSVFormat  format,  ExtendedBufferedReader  in)  {  this.format  =  format;  this.in  =  in;  this.isEncapsulating  =  format.isEncapsulating();  this.isEscaping  =  format.isEscaping();  [BUGGY]  this.commmentStart  =  format.getCommentStart(  )  ;this.isCommentEnabled  =  format.isCommentingEnabled(  )  ;  [BUGGY]  this.delimiter  =  format.getDelimiter();  this.escape  =  format.getEscape();  this.encapsulator  =  format.getEncapsulator();  this.commmentStart  =  format.getCommentStart();  this.surroundingSpacesIgnored  =  format.isSurroundingSpacesIgnored();  this.emptyLinesIgnored  =  format.isEmptyLinesIgnored();  }    [CLASS]  Lexer  [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)    CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char  commmentStart  delimiter  encapsulator  escape  ExtendedBufferedReader  in  CSVFormat  format  boolean  emptyLinesIgnored  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored    	[P11_Insert_Donor_Statement]
[PATCH]  this.delimiter  =  format.getDelimiter  (  )  ;	[BUG]  [BUGGY]  this.delimiter  =  null.getDelimiter(  )  ;[CE]  <null>  cannot  be  dereferenced  [CONTEXT]  Lexer(CSVFormat  format,  ExtendedBufferedReader  in)  {  this.format  =  format;  this.in  =  in;  this.isEncapsulating  =  format.isEncapsulating();  this.isEscaping  =  format.isEscaping();  this.isCommentEnabled  =  format.isCommentingEnabled();  [BUGGY]  this.delimiter  =  null.getDelimiter(  )  ;  [BUGGY]  this.escape  =  format.getEscape();  this.encapsulator  =  format.getEncapsulator();  this.commmentStart  =  format.getCommentStart();  this.surroundingSpacesIgnored  =  format.isSurroundingSpacesIgnored();  this.emptyLinesIgnored  =  format.isEmptyLinesIgnored();  }    [CLASS]  Lexer  [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)    CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char  commmentStart  delimiter  encapsulator  escape  ExtendedBufferedReader  in  CSVFormat  format  boolean  emptyLinesIgnored  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored    	[P8_Replace_Mix]
[PATCH]  this.delimiter  =  format.getDelimiter  (  )  ;	[BUG]  [BUGGY]  this.emptyLinesIgnored  =  format.isEmptyLinesIgnored(  )  ;this.delimiter  =  format.getDelimiter(  )  ;[CE]  variable  emptyLinesIgnored  might  already  have  been  assigned  [CONTEXT]  Lexer(CSVFormat  format,  ExtendedBufferedReader  in)  {  this.format  =  format;  this.in  =  in;  this.isEncapsulating  =  format.isEncapsulating();  this.isEscaping  =  format.isEscaping();  this.isCommentEnabled  =  format.isCommentingEnabled();  [BUGGY]  this.emptyLinesIgnored  =  format.isEmptyLinesIgnored(  )  ;this.delimiter  =  format.getDelimiter(  )  ;  [BUGGY]  this.escape  =  format.getEscape();  this.encapsulator  =  format.getEncapsulator();  this.commmentStart  =  format.getCommentStart();  this.surroundingSpacesIgnored  =  format.isSurroundingSpacesIgnored();  this.emptyLinesIgnored  =  format.isEmptyLinesIgnored();  }    [CLASS]  Lexer  [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)    CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char  commmentStart  delimiter  encapsulator  escape  ExtendedBufferedReader  in  CSVFormat  format  boolean  emptyLinesIgnored  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored    	[P11_Insert_Donor_Statement]
[PATCH]  this.delimiter  =  format.getDelimiter  (  )  ;	[BUG]  [BUGGY]  this.escape  =  format.getEscape(  )  ;this.delimiter  =  format.getDelimiter(  )  ;[CE]  variable  escape  might  already  have  been  assigned  [CONTEXT]  Lexer(CSVFormat  format,  ExtendedBufferedReader  in)  {  this.format  =  format;  this.in  =  in;  this.isEncapsulating  =  format.isEncapsulating();  this.isEscaping  =  format.isEscaping();  this.isCommentEnabled  =  format.isCommentingEnabled();  [BUGGY]  this.escape  =  format.getEscape(  )  ;this.delimiter  =  format.getDelimiter(  )  ;  [BUGGY]  this.escape  =  format.getEscape();  this.encapsulator  =  format.getEncapsulator();  this.commmentStart  =  format.getCommentStart();  this.surroundingSpacesIgnored  =  format.isSurroundingSpacesIgnored();  this.emptyLinesIgnored  =  format.isEmptyLinesIgnored();  }    [CLASS]  Lexer  [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)    CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char  commmentStart  delimiter  encapsulator  escape  ExtendedBufferedReader  in  CSVFormat  format  boolean  emptyLinesIgnored  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored    	[P11_Insert_Donor_Statement]
[PATCH]  this.delimiter  =  format.getDelimiter  (  )  ;	[BUG]  [BUGGY]  this.isEscaping  =  format.isEscaping(  )  ;this.delimiter  =  format.getDelimiter(  )  ;[CE]  variable  isEscaping  might  already  have  been  assigned  [CONTEXT]  Lexer(CSVFormat  format,  ExtendedBufferedReader  in)  {  this.format  =  format;  this.in  =  in;  this.isEncapsulating  =  format.isEncapsulating();  this.isEscaping  =  format.isEscaping();  this.isCommentEnabled  =  format.isCommentingEnabled();  [BUGGY]  this.isEscaping  =  format.isEscaping(  )  ;this.delimiter  =  format.getDelimiter(  )  ;  [BUGGY]  this.escape  =  format.getEscape();  this.encapsulator  =  format.getEncapsulator();  this.commmentStart  =  format.getCommentStart();  this.surroundingSpacesIgnored  =  format.isSurroundingSpacesIgnored();  this.emptyLinesIgnored  =  format.isEmptyLinesIgnored();  }    [CLASS]  Lexer  [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)    CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char  commmentStart  delimiter  encapsulator  escape  ExtendedBufferedReader  in  CSVFormat  format  boolean  emptyLinesIgnored  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored    	[P11_Insert_Donor_Statement]
[PATCH]  this.delimiter  =  format.getDelimiter  (  )  ;	[BUG]  [BUGGY]  this.commmentStart  =  format.getCommentStart(  )  ;this.delimiter  =  format.getDelimiter(  )  ;[CE]  variable  commmentStart  might  already  have  been  assigned  [CONTEXT]  Lexer(CSVFormat  format,  ExtendedBufferedReader  in)  {  this.format  =  format;  this.in  =  in;  this.isEncapsulating  =  format.isEncapsulating();  this.isEscaping  =  format.isEscaping();  this.isCommentEnabled  =  format.isCommentingEnabled();  [BUGGY]  this.commmentStart  =  format.getCommentStart(  )  ;this.delimiter  =  format.getDelimiter(  )  ;  [BUGGY]  this.escape  =  format.getEscape();  this.encapsulator  =  format.getEncapsulator();  this.commmentStart  =  format.getCommentStart();  this.surroundingSpacesIgnored  =  format.isSurroundingSpacesIgnored();  this.emptyLinesIgnored  =  format.isEmptyLinesIgnored();  }    [CLASS]  Lexer  [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)    CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char  commmentStart  delimiter  encapsulator  escape  ExtendedBufferedReader  in  CSVFormat  format  boolean  emptyLinesIgnored  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored    	[P11_Insert_Donor_Statement]
[PATCH]  this.delimiter  =  format.getDelimiter  (  )  ;	[BUG]  [BUGGY]  this.encapsulator  =  format.getEncapsulator(  )  ;this.delimiter  =  format.getDelimiter(  )  ;[CE]  variable  encapsulator  might  already  have  been  assigned  [CONTEXT]  Lexer(CSVFormat  format,  ExtendedBufferedReader  in)  {  this.format  =  format;  this.in  =  in;  this.isEncapsulating  =  format.isEncapsulating();  this.isEscaping  =  format.isEscaping();  this.isCommentEnabled  =  format.isCommentingEnabled();  [BUGGY]  this.encapsulator  =  format.getEncapsulator(  )  ;this.delimiter  =  format.getDelimiter(  )  ;  [BUGGY]  this.escape  =  format.getEscape();  this.encapsulator  =  format.getEncapsulator();  this.commmentStart  =  format.getCommentStart();  this.surroundingSpacesIgnored  =  format.isSurroundingSpacesIgnored();  this.emptyLinesIgnored  =  format.isEmptyLinesIgnored();  }    [CLASS]  Lexer  [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)    CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char  commmentStart  delimiter  encapsulator  escape  ExtendedBufferedReader  in  CSVFormat  format  boolean  emptyLinesIgnored  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored    	[P11_Insert_Donor_Statement]
[PATCH]  this.delimiter  =  format.getDelimiter  (  )  ;	[BUG]  [BUGGY]  this.delimiter  =  format.getEscape(  )  ;[FE]  Token  type  expected:<TOKEN>  but  was:<EOF>  testNextToken1  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  Lexer(CSVFormat  format,  ExtendedBufferedReader  in)  {  this.format  =  format;  this.in  =  in;  this.isEncapsulating  =  format.isEncapsulating();  this.isEscaping  =  format.isEscaping();  this.isCommentEnabled  =  format.isCommentingEnabled();  [BUGGY]  this.delimiter  =  format.getEscape(  )  ;  [BUGGY]  this.escape  =  format.getEscape();  this.encapsulator  =  format.getEncapsulator();  this.commmentStart  =  format.getCommentStart();  this.surroundingSpacesIgnored  =  format.isSurroundingSpacesIgnored();  this.emptyLinesIgnored  =  format.isEmptyLinesIgnored();  }    [CLASS]  Lexer  [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)    CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char  commmentStart  delimiter  encapsulator  escape  ExtendedBufferedReader  in  CSVFormat  format  boolean  emptyLinesIgnored  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored    	[P7_Replace_Invocation]
[PATCH]  this.escape  =  format.getEscape  (  )  ;	[BUG]  [BUGGY]  this.escape  =  null.getEscape(  )  ;[CE]  <null>  cannot  be  dereferenced  [CONTEXT]  Lexer(CSVFormat  format,  ExtendedBufferedReader  in)  {  this.format  =  format;  this.in  =  in;  this.isEncapsulating  =  format.isEncapsulating();  this.isEscaping  =  format.isEscaping();  this.isCommentEnabled  =  format.isCommentingEnabled();  this.delimiter  =  format.getDelimiter();  [BUGGY]  this.escape  =  null.getEscape(  )  ;  [BUGGY]  this.encapsulator  =  format.getEncapsulator();  this.commmentStart  =  format.getCommentStart();  this.surroundingSpacesIgnored  =  format.isSurroundingSpacesIgnored();  this.emptyLinesIgnored  =  format.isEmptyLinesIgnored();  }    [CLASS]  Lexer  [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)    CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char  commmentStart  delimiter  encapsulator  escape  ExtendedBufferedReader  in  CSVFormat  format  boolean  emptyLinesIgnored  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored    	[P8_Replace_Mix]
[PATCH]  this.escape  =  format.getEscape  (  )  ;	[BUG]  [BUGGY]  this.emptyLinesIgnored  =  format.isEmptyLinesIgnored(  )  ;this.escape  =  format.getEscape(  )  ;[CE]  variable  emptyLinesIgnored  might  already  have  been  assigned  [CONTEXT]  Lexer(CSVFormat  format,  ExtendedBufferedReader  in)  {  this.format  =  format;  this.in  =  in;  this.isEncapsulating  =  format.isEncapsulating();  this.isEscaping  =  format.isEscaping();  this.isCommentEnabled  =  format.isCommentingEnabled();  this.delimiter  =  format.getDelimiter();  [BUGGY]  this.emptyLinesIgnored  =  format.isEmptyLinesIgnored(  )  ;this.escape  =  format.getEscape(  )  ;  [BUGGY]  this.encapsulator  =  format.getEncapsulator();  this.commmentStart  =  format.getCommentStart();  this.surroundingSpacesIgnored  =  format.isSurroundingSpacesIgnored();  this.emptyLinesIgnored  =  format.isEmptyLinesIgnored();  }    [CLASS]  Lexer  [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)    CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char  commmentStart  delimiter  encapsulator  escape  ExtendedBufferedReader  in  CSVFormat  format  boolean  emptyLinesIgnored  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored    	[P11_Insert_Donor_Statement]
[PATCH]  this.escape  =  format.getEscape  (  )  ;	[BUG]  [BUGGY]  this.isEncapsulating  =  format.isEncapsulating(  )  ;this.escape  =  format.getEscape(  )  ;[CE]  variable  isEncapsulating  might  already  have  been  assigned  [CONTEXT]  Lexer(CSVFormat  format,  ExtendedBufferedReader  in)  {  this.format  =  format;  this.in  =  in;  this.isEncapsulating  =  format.isEncapsulating();  this.isEscaping  =  format.isEscaping();  this.isCommentEnabled  =  format.isCommentingEnabled();  this.delimiter  =  format.getDelimiter();  [BUGGY]  this.isEncapsulating  =  format.isEncapsulating(  )  ;this.escape  =  format.getEscape(  )  ;  [BUGGY]  this.encapsulator  =  format.getEncapsulator();  this.commmentStart  =  format.getCommentStart();  this.surroundingSpacesIgnored  =  format.isSurroundingSpacesIgnored();  this.emptyLinesIgnored  =  format.isEmptyLinesIgnored();  }    [CLASS]  Lexer  [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)    CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char  commmentStart  delimiter  encapsulator  escape  ExtendedBufferedReader  in  CSVFormat  format  boolean  emptyLinesIgnored  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored    	[P11_Insert_Donor_Statement]
[PATCH]  this.escape  =  format.getEscape  (  )  ;	[BUG]  [BUGGY]  this.isCommentEnabled  =  format.isCommentingEnabled(  )  ;this.escape  =  format.getEscape(  )  ;[CE]  variable  isCommentEnabled  might  already  have  been  assigned  [CONTEXT]  Lexer(CSVFormat  format,  ExtendedBufferedReader  in)  {  this.format  =  format;  this.in  =  in;  this.isEncapsulating  =  format.isEncapsulating();  this.isEscaping  =  format.isEscaping();  this.isCommentEnabled  =  format.isCommentingEnabled();  this.delimiter  =  format.getDelimiter();  [BUGGY]  this.isCommentEnabled  =  format.isCommentingEnabled(  )  ;this.escape  =  format.getEscape(  )  ;  [BUGGY]  this.encapsulator  =  format.getEncapsulator();  this.commmentStart  =  format.getCommentStart();  this.surroundingSpacesIgnored  =  format.isSurroundingSpacesIgnored();  this.emptyLinesIgnored  =  format.isEmptyLinesIgnored();  }    [CLASS]  Lexer  [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)    CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char  commmentStart  delimiter  encapsulator  escape  ExtendedBufferedReader  in  CSVFormat  format  boolean  emptyLinesIgnored  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored    	[P11_Insert_Donor_Statement]
[PATCH]  this.escape  =  format.getEscape  (  )  ;	[BUG]  [BUGGY]  this.isEscaping  =  format.isEscaping(  )  ;this.escape  =  format.getEscape(  )  ;[CE]  variable  isEscaping  might  already  have  been  assigned  [CONTEXT]  Lexer(CSVFormat  format,  ExtendedBufferedReader  in)  {  this.format  =  format;  this.in  =  in;  this.isEncapsulating  =  format.isEncapsulating();  this.isEscaping  =  format.isEscaping();  this.isCommentEnabled  =  format.isCommentingEnabled();  this.delimiter  =  format.getDelimiter();  [BUGGY]  this.isEscaping  =  format.isEscaping(  )  ;this.escape  =  format.getEscape(  )  ;  [BUGGY]  this.encapsulator  =  format.getEncapsulator();  this.commmentStart  =  format.getCommentStart();  this.surroundingSpacesIgnored  =  format.isSurroundingSpacesIgnored();  this.emptyLinesIgnored  =  format.isEmptyLinesIgnored();  }    [CLASS]  Lexer  [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)    CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char  commmentStart  delimiter  encapsulator  escape  ExtendedBufferedReader  in  CSVFormat  format  boolean  emptyLinesIgnored  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored    	[P11_Insert_Donor_Statement]
[PATCH]  this.escape  =  format.getEscape  (  )  ;	[BUG]  [BUGGY]  this.commmentStart  =  format.getCommentStart(  )  ;this.escape  =  format.getEscape(  )  ;[CE]  variable  commmentStart  might  already  have  been  assigned  [CONTEXT]  Lexer(CSVFormat  format,  ExtendedBufferedReader  in)  {  this.format  =  format;  this.in  =  in;  this.isEncapsulating  =  format.isEncapsulating();  this.isEscaping  =  format.isEscaping();  this.isCommentEnabled  =  format.isCommentingEnabled();  this.delimiter  =  format.getDelimiter();  [BUGGY]  this.commmentStart  =  format.getCommentStart(  )  ;this.escape  =  format.getEscape(  )  ;  [BUGGY]  this.encapsulator  =  format.getEncapsulator();  this.commmentStart  =  format.getCommentStart();  this.surroundingSpacesIgnored  =  format.isSurroundingSpacesIgnored();  this.emptyLinesIgnored  =  format.isEmptyLinesIgnored();  }    [CLASS]  Lexer  [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)    CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char  commmentStart  delimiter  encapsulator  escape  ExtendedBufferedReader  in  CSVFormat  format  boolean  emptyLinesIgnored  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored    	[P11_Insert_Donor_Statement]
[PATCH]  this.escape  =  format.getEscape  (  )  ;	[BUG]  [BUGGY]  this.encapsulator  =  format.getEncapsulator(  )  ;this.escape  =  format.getEscape(  )  ;[CE]  variable  encapsulator  might  already  have  been  assigned  [CONTEXT]  Lexer(CSVFormat  format,  ExtendedBufferedReader  in)  {  this.format  =  format;  this.in  =  in;  this.isEncapsulating  =  format.isEncapsulating();  this.isEscaping  =  format.isEscaping();  this.isCommentEnabled  =  format.isCommentingEnabled();  this.delimiter  =  format.getDelimiter();  [BUGGY]  this.encapsulator  =  format.getEncapsulator(  )  ;this.escape  =  format.getEscape(  )  ;  [BUGGY]  this.encapsulator  =  format.getEncapsulator();  this.commmentStart  =  format.getCommentStart();  this.surroundingSpacesIgnored  =  format.isSurroundingSpacesIgnored();  this.emptyLinesIgnored  =  format.isEmptyLinesIgnored();  }    [CLASS]  Lexer  [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)    CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char  commmentStart  delimiter  encapsulator  escape  ExtendedBufferedReader  in  CSVFormat  format  boolean  emptyLinesIgnored  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored    	[P11_Insert_Donor_Statement]
[PATCH]  this.escape  =  format.getEscape  (  )  ;	[BUG]  [BUGGY]  this.delimiter  =  format.getDelimiter(  )  ;this.escape  =  format.getEscape(  )  ;[CE]  variable  delimiter  might  already  have  been  assigned  [CONTEXT]  Lexer(CSVFormat  format,  ExtendedBufferedReader  in)  {  this.format  =  format;  this.in  =  in;  this.isEncapsulating  =  format.isEncapsulating();  this.isEscaping  =  format.isEscaping();  this.isCommentEnabled  =  format.isCommentingEnabled();  this.delimiter  =  format.getDelimiter();  [BUGGY]  this.delimiter  =  format.getDelimiter(  )  ;this.escape  =  format.getEscape(  )  ;  [BUGGY]  this.encapsulator  =  format.getEncapsulator();  this.commmentStart  =  format.getCommentStart();  this.surroundingSpacesIgnored  =  format.isSurroundingSpacesIgnored();  this.emptyLinesIgnored  =  format.isEmptyLinesIgnored();  }    [CLASS]  Lexer  [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)    CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char  commmentStart  delimiter  encapsulator  escape  ExtendedBufferedReader  in  CSVFormat  format  boolean  emptyLinesIgnored  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored    	[P11_Insert_Donor_Statement]
[PATCH]  this.escape  =  format.getEscape  (  )  ;	[BUG]  [BUGGY]  this.escape  =  format.getEncapsulator(  )  ;[FE]  null  testBackslashEscaping2  assertTrue(CSVPrinterTest.equals(res,  records));  [CONTEXT]  Lexer(CSVFormat  format,  ExtendedBufferedReader  in)  {  this.format  =  format;  this.in  =  in;  this.isEncapsulating  =  format.isEncapsulating();  this.isEscaping  =  format.isEscaping();  this.isCommentEnabled  =  format.isCommentingEnabled();  this.delimiter  =  format.getDelimiter();  [BUGGY]  this.escape  =  format.getEncapsulator(  )  ;  [BUGGY]  this.encapsulator  =  format.getEncapsulator();  this.commmentStart  =  format.getCommentStart();  this.surroundingSpacesIgnored  =  format.isSurroundingSpacesIgnored();  this.emptyLinesIgnored  =  format.isEmptyLinesIgnored();  }    [CLASS]  Lexer  [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)    CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char  commmentStart  delimiter  encapsulator  escape  ExtendedBufferedReader  in  CSVFormat  format  boolean  emptyLinesIgnored  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored    	[P7_Replace_Invocation]
[PATCH]  this.escape  =  format.getEscape  (  )  ;  this.encapsulator  =  format.getEncapsulator  (  )  ;  this.commmentStart  =  format.getCommentStart  (  )  ;  this.surroundingSpacesIgnored  =  format.isSurroundingSpacesIgnored  (  )  ;  this.emptyLinesIgnored  =  format.isEmptyLinesIgnored  (  )  ;  }	[BUG]  [BUGGY]  [CE]  variable  encapsulator  might  not  have  been  initialized  [CONTEXT]  Lexer(CSVFormat  format,  ExtendedBufferedReader  in)  {  this.format  =  format;  this.in  =  in;  this.isEncapsulating  =  format.isEncapsulating();  this.isEscaping  =  format.isEscaping();  this.isCommentEnabled  =  format.isCommentingEnabled();  this.delimiter  =  format.getDelimiter();  [BUGGY]  [BUGGY]          [CLASS]  Lexer  [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)    CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char  commmentStart  delimiter  encapsulator  escape  ExtendedBufferedReader  in  CSVFormat  format  boolean  emptyLinesIgnored  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored    	[P14_Delete_Statement]
[PATCH]  this.encapsulator  =  format.getEncapsulator  (  )  ;	[BUG]  [BUGGY]  this.encapsulator  =  null.getEncapsulator(  )  ;[CE]  <null>  cannot  be  dereferenced  [CONTEXT]  Lexer(CSVFormat  format,  ExtendedBufferedReader  in)  {  this.format  =  format;  this.in  =  in;  this.isEncapsulating  =  format.isEncapsulating();  this.isEscaping  =  format.isEscaping();  this.isCommentEnabled  =  format.isCommentingEnabled();  this.delimiter  =  format.getDelimiter();  this.escape  =  format.getEscape();  [BUGGY]  this.encapsulator  =  null.getEncapsulator(  )  ;  [BUGGY]  this.commmentStart  =  format.getCommentStart();  this.surroundingSpacesIgnored  =  format.isSurroundingSpacesIgnored();  this.emptyLinesIgnored  =  format.isEmptyLinesIgnored();  }    [CLASS]  Lexer  [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)    CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char  commmentStart  delimiter  encapsulator  escape  ExtendedBufferedReader  in  CSVFormat  format  boolean  emptyLinesIgnored  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored    	[P8_Replace_Mix]
[PATCH]  this.encapsulator  =  format.getEncapsulator  (  )  ;	[BUG]  [BUGGY]  this.escape  =  format.getEscape(  )  ;this.encapsulator  =  format.getEncapsulator(  )  ;[CE]  variable  escape  might  already  have  been  assigned  [CONTEXT]  Lexer(CSVFormat  format,  ExtendedBufferedReader  in)  {  this.format  =  format;  this.in  =  in;  this.isEncapsulating  =  format.isEncapsulating();  this.isEscaping  =  format.isEscaping();  this.isCommentEnabled  =  format.isCommentingEnabled();  this.delimiter  =  format.getDelimiter();  this.escape  =  format.getEscape();  [BUGGY]  this.escape  =  format.getEscape(  )  ;this.encapsulator  =  format.getEncapsulator(  )  ;  [BUGGY]  this.commmentStart  =  format.getCommentStart();  this.surroundingSpacesIgnored  =  format.isSurroundingSpacesIgnored();  this.emptyLinesIgnored  =  format.isEmptyLinesIgnored();  }    [CLASS]  Lexer  [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)    CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char  commmentStart  delimiter  encapsulator  escape  ExtendedBufferedReader  in  CSVFormat  format  boolean  emptyLinesIgnored  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored    	[P11_Insert_Donor_Statement]
[PATCH]  this.encapsulator  =  format.getEncapsulator  (  )  ;	[BUG]  [BUGGY]  this.isEncapsulating  =  format.isEncapsulating(  )  ;this.encapsulator  =  format.getEncapsulator(  )  ;[CE]  variable  isEncapsulating  might  already  have  been  assigned  [CONTEXT]  Lexer(CSVFormat  format,  ExtendedBufferedReader  in)  {  this.format  =  format;  this.in  =  in;  this.isEncapsulating  =  format.isEncapsulating();  this.isEscaping  =  format.isEscaping();  this.isCommentEnabled  =  format.isCommentingEnabled();  this.delimiter  =  format.getDelimiter();  this.escape  =  format.getEscape();  [BUGGY]  this.isEncapsulating  =  format.isEncapsulating(  )  ;this.encapsulator  =  format.getEncapsulator(  )  ;  [BUGGY]  this.commmentStart  =  format.getCommentStart();  this.surroundingSpacesIgnored  =  format.isSurroundingSpacesIgnored();  this.emptyLinesIgnored  =  format.isEmptyLinesIgnored();  }    [CLASS]  Lexer  [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)    CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char  commmentStart  delimiter  encapsulator  escape  ExtendedBufferedReader  in  CSVFormat  format  boolean  emptyLinesIgnored  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored    	[P11_Insert_Donor_Statement]
[PATCH]  this.encapsulator  =  format.getEncapsulator  (  )  ;	[BUG]  [BUGGY]  this.isEscaping  =  format.isEscaping(  )  ;this.encapsulator  =  format.getEncapsulator(  )  ;[CE]  variable  isEscaping  might  already  have  been  assigned  [CONTEXT]  Lexer(CSVFormat  format,  ExtendedBufferedReader  in)  {  this.format  =  format;  this.in  =  in;  this.isEncapsulating  =  format.isEncapsulating();  this.isEscaping  =  format.isEscaping();  this.isCommentEnabled  =  format.isCommentingEnabled();  this.delimiter  =  format.getDelimiter();  this.escape  =  format.getEscape();  [BUGGY]  this.isEscaping  =  format.isEscaping(  )  ;this.encapsulator  =  format.getEncapsulator(  )  ;  [BUGGY]  this.commmentStart  =  format.getCommentStart();  this.surroundingSpacesIgnored  =  format.isSurroundingSpacesIgnored();  this.emptyLinesIgnored  =  format.isEmptyLinesIgnored();  }    [CLASS]  Lexer  [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)    CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char  commmentStart  delimiter  encapsulator  escape  ExtendedBufferedReader  in  CSVFormat  format  boolean  emptyLinesIgnored  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored    	[P11_Insert_Donor_Statement]
[PATCH]  this.encapsulator  =  format.getEncapsulator  (  )  ;	[BUG]  [BUGGY]  this.commmentStart  =  format.getCommentStart(  )  ;this.encapsulator  =  format.getEncapsulator(  )  ;[CE]  variable  commmentStart  might  already  have  been  assigned  [CONTEXT]  Lexer(CSVFormat  format,  ExtendedBufferedReader  in)  {  this.format  =  format;  this.in  =  in;  this.isEncapsulating  =  format.isEncapsulating();  this.isEscaping  =  format.isEscaping();  this.isCommentEnabled  =  format.isCommentingEnabled();  this.delimiter  =  format.getDelimiter();  this.escape  =  format.getEscape();  [BUGGY]  this.commmentStart  =  format.getCommentStart(  )  ;this.encapsulator  =  format.getEncapsulator(  )  ;  [BUGGY]  this.commmentStart  =  format.getCommentStart();  this.surroundingSpacesIgnored  =  format.isSurroundingSpacesIgnored();  this.emptyLinesIgnored  =  format.isEmptyLinesIgnored();  }    [CLASS]  Lexer  [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)    CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char  commmentStart  delimiter  encapsulator  escape  ExtendedBufferedReader  in  CSVFormat  format  boolean  emptyLinesIgnored  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored    	[P11_Insert_Donor_Statement]
[PATCH]  this.encapsulator  =  format.getEncapsulator  (  )  ;	[BUG]  [BUGGY]  this.delimiter  =  format.getDelimiter(  )  ;this.encapsulator  =  format.getEncapsulator(  )  ;[CE]  variable  delimiter  might  already  have  been  assigned  [CONTEXT]  Lexer(CSVFormat  format,  ExtendedBufferedReader  in)  {  this.format  =  format;  this.in  =  in;  this.isEncapsulating  =  format.isEncapsulating();  this.isEscaping  =  format.isEscaping();  this.isCommentEnabled  =  format.isCommentingEnabled();  this.delimiter  =  format.getDelimiter();  this.escape  =  format.getEscape();  [BUGGY]  this.delimiter  =  format.getDelimiter(  )  ;this.encapsulator  =  format.getEncapsulator(  )  ;  [BUGGY]  this.commmentStart  =  format.getCommentStart();  this.surroundingSpacesIgnored  =  format.isSurroundingSpacesIgnored();  this.emptyLinesIgnored  =  format.isEmptyLinesIgnored();  }    [CLASS]  Lexer  [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)    CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char  commmentStart  delimiter  encapsulator  escape  ExtendedBufferedReader  in  CSVFormat  format  boolean  emptyLinesIgnored  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored    	[P11_Insert_Donor_Statement]
[PATCH]  this.encapsulator  =  format.getEncapsulator  (  )  ;  this.commmentStart  =  format.getCommentStart  (  )  ;  this.surroundingSpacesIgnored  =  format.isSurroundingSpacesIgnored  (  )  ;  this.emptyLinesIgnored  =  format.isEmptyLinesIgnored  (  )  ;  }	[BUG]  [BUGGY]  [CE]  ';'  expected  [CONTEXT]  Lexer(CSVFormat  format,  ExtendedBufferedReader  in)  {  this.format  =  format;  this.in  =  in;  this.isEncapsulating  =  format.isEncapsulating();  this.isEscaping  =  format.isEscaping();  this.isCommentEnabled  =  format.isCommentingEnabled();  this.delimiter  =  format.getDelimiter();  this.escape  =  format.getEscape();  [BUGGY]  [BUGGY]          [CLASS]  Lexer  [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)    CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char  commmentStart  delimiter  encapsulator  escape  ExtendedBufferedReader  in  CSVFormat  format  boolean  emptyLinesIgnored  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored    	[P14_Delete_Statement]
[PATCH]  this.commmentStart  =  format.getCommentStart  (  )  ;	[BUG]  [BUGGY]  this.commmentStart  =  format.getEscape(  )  ;[FE]  Token  content  expected:<[]>  but  was:<[#foo]>  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  Lexer(CSVFormat  format,  ExtendedBufferedReader  in)  {  this.format  =  format;  this.in  =  in;  this.isEncapsulating  =  format.isEncapsulating();  this.isEscaping  =  format.isEscaping();  this.isCommentEnabled  =  format.isCommentingEnabled();  this.delimiter  =  format.getDelimiter();  this.escape  =  format.getEscape();  this.encapsulator  =  format.getEncapsulator();  [BUGGY]  this.commmentStart  =  format.getEscape(  )  ;  [BUGGY]  this.surroundingSpacesIgnored  =  format.isSurroundingSpacesIgnored();  this.emptyLinesIgnored  =  format.isEmptyLinesIgnored();  }    [CLASS]  Lexer  [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)    CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char  commmentStart  delimiter  encapsulator  escape  ExtendedBufferedReader  in  CSVFormat  format  boolean  emptyLinesIgnored  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored    	[P7_Replace_Invocation]
[PATCH]  this.commmentStart  =  format.getCommentStart  (  )  ;	[BUG]  [BUGGY]  this.commmentStart  =  null.getCommentStart(  )  ;[CE]  <null>  cannot  be  dereferenced  [CONTEXT]  Lexer(CSVFormat  format,  ExtendedBufferedReader  in)  {  this.format  =  format;  this.in  =  in;  this.isEncapsulating  =  format.isEncapsulating();  this.isEscaping  =  format.isEscaping();  this.isCommentEnabled  =  format.isCommentingEnabled();  this.delimiter  =  format.getDelimiter();  this.escape  =  format.getEscape();  this.encapsulator  =  format.getEncapsulator();  [BUGGY]  this.commmentStart  =  null.getCommentStart(  )  ;  [BUGGY]  this.surroundingSpacesIgnored  =  format.isSurroundingSpacesIgnored();  this.emptyLinesIgnored  =  format.isEmptyLinesIgnored();  }    [CLASS]  Lexer  [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)    CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char  commmentStart  delimiter  encapsulator  escape  ExtendedBufferedReader  in  CSVFormat  format  boolean  emptyLinesIgnored  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored    	[P8_Replace_Mix]
[PATCH]  this.commmentStart  =  format.getCommentStart  (  )  ;	[BUG]  [BUGGY]  this.escape  =  format.getEscape(  )  ;this.commmentStart  =  format.getCommentStart(  )  ;[CE]  variable  escape  might  already  have  been  assigned  [CONTEXT]  Lexer(CSVFormat  format,  ExtendedBufferedReader  in)  {  this.format  =  format;  this.in  =  in;  this.isEncapsulating  =  format.isEncapsulating();  this.isEscaping  =  format.isEscaping();  this.isCommentEnabled  =  format.isCommentingEnabled();  this.delimiter  =  format.getDelimiter();  this.escape  =  format.getEscape();  this.encapsulator  =  format.getEncapsulator();  [BUGGY]  this.escape  =  format.getEscape(  )  ;this.commmentStart  =  format.getCommentStart(  )  ;  [BUGGY]  this.surroundingSpacesIgnored  =  format.isSurroundingSpacesIgnored();  this.emptyLinesIgnored  =  format.isEmptyLinesIgnored();  }    [CLASS]  Lexer  [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)    CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char  commmentStart  delimiter  encapsulator  escape  ExtendedBufferedReader  in  CSVFormat  format  boolean  emptyLinesIgnored  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored    	[P11_Insert_Donor_Statement]
[PATCH]  this.commmentStart  =  format.getCommentStart  (  )  ;	[BUG]  [BUGGY]  this.isCommentEnabled  =  format.isCommentingEnabled(  )  ;this.commmentStart  =  format.getCommentStart(  )  ;[CE]  variable  isCommentEnabled  might  already  have  been  assigned  [CONTEXT]  Lexer(CSVFormat  format,  ExtendedBufferedReader  in)  {  this.format  =  format;  this.in  =  in;  this.isEncapsulating  =  format.isEncapsulating();  this.isEscaping  =  format.isEscaping();  this.isCommentEnabled  =  format.isCommentingEnabled();  this.delimiter  =  format.getDelimiter();  this.escape  =  format.getEscape();  this.encapsulator  =  format.getEncapsulator();  [BUGGY]  this.isCommentEnabled  =  format.isCommentingEnabled(  )  ;this.commmentStart  =  format.getCommentStart(  )  ;  [BUGGY]  this.surroundingSpacesIgnored  =  format.isSurroundingSpacesIgnored();  this.emptyLinesIgnored  =  format.isEmptyLinesIgnored();  }    [CLASS]  Lexer  [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)    CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char  commmentStart  delimiter  encapsulator  escape  ExtendedBufferedReader  in  CSVFormat  format  boolean  emptyLinesIgnored  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored    	[P11_Insert_Donor_Statement]
[PATCH]  this.commmentStart  =  format.getCommentStart  (  )  ;	[BUG]  [BUGGY]  this.encapsulator  =  format.getEncapsulator(  )  ;this.commmentStart  =  format.getCommentStart(  )  ;[CE]  variable  encapsulator  might  already  have  been  assigned  [CONTEXT]  Lexer(CSVFormat  format,  ExtendedBufferedReader  in)  {  this.format  =  format;  this.in  =  in;  this.isEncapsulating  =  format.isEncapsulating();  this.isEscaping  =  format.isEscaping();  this.isCommentEnabled  =  format.isCommentingEnabled();  this.delimiter  =  format.getDelimiter();  this.escape  =  format.getEscape();  this.encapsulator  =  format.getEncapsulator();  [BUGGY]  this.encapsulator  =  format.getEncapsulator(  )  ;this.commmentStart  =  format.getCommentStart(  )  ;  [BUGGY]  this.surroundingSpacesIgnored  =  format.isSurroundingSpacesIgnored();  this.emptyLinesIgnored  =  format.isEmptyLinesIgnored();  }    [CLASS]  Lexer  [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)    CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char  commmentStart  delimiter  encapsulator  escape  ExtendedBufferedReader  in  CSVFormat  format  boolean  emptyLinesIgnored  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored    	[P11_Insert_Donor_Statement]
[PATCH]  this.commmentStart  =  format.getCommentStart  (  )  ;	[BUG]  [BUGGY]  this.delimiter  =  format.getDelimiter(  )  ;this.commmentStart  =  format.getCommentStart(  )  ;[CE]  variable  delimiter  might  already  have  been  assigned  [CONTEXT]  Lexer(CSVFormat  format,  ExtendedBufferedReader  in)  {  this.format  =  format;  this.in  =  in;  this.isEncapsulating  =  format.isEncapsulating();  this.isEscaping  =  format.isEscaping();  this.isCommentEnabled  =  format.isCommentingEnabled();  this.delimiter  =  format.getDelimiter();  this.escape  =  format.getEscape();  this.encapsulator  =  format.getEncapsulator();  [BUGGY]  this.delimiter  =  format.getDelimiter(  )  ;this.commmentStart  =  format.getCommentStart(  )  ;  [BUGGY]  this.surroundingSpacesIgnored  =  format.isSurroundingSpacesIgnored();  this.emptyLinesIgnored  =  format.isEmptyLinesIgnored();  }    [CLASS]  Lexer  [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)    CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char  commmentStart  delimiter  encapsulator  escape  ExtendedBufferedReader  in  CSVFormat  format  boolean  emptyLinesIgnored  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored    	[P11_Insert_Donor_Statement]
[PATCH]  this.commmentStart  =  format.getCommentStart  (  )  ;  this.surroundingSpacesIgnored  =  format.isSurroundingSpacesIgnored  (  )  ;  this.emptyLinesIgnored  =  format.isEmptyLinesIgnored  (  )  ;  }	[BUG]  [BUGGY]  [CE]  ';'  expected  [CONTEXT]  Lexer(CSVFormat  format,  ExtendedBufferedReader  in)  {  this.format  =  format;  this.in  =  in;  this.isEncapsulating  =  format.isEncapsulating();  this.isEscaping  =  format.isEscaping();  this.isCommentEnabled  =  format.isCommentingEnabled();  this.delimiter  =  format.getDelimiter();  this.escape  =  format.getEscape();  this.encapsulator  =  format.getEncapsulator();  [BUGGY]  [BUGGY]        [CLASS]  Lexer  [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)    CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char  commmentStart  delimiter  encapsulator  escape  ExtendedBufferedReader  in  CSVFormat  format  boolean  emptyLinesIgnored  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored    	[P14_Delete_Statement]
[PATCH]  this.surroundingSpacesIgnored  =  format.isSurroundingSpacesIgnored  (  )  ;	[BUG]  [BUGGY]  this.surroundingSpacesIgnored  =  null.isSurroundingSpacesIgnored(  )  ;[CE]  <null>  cannot  be  dereferenced  [CONTEXT]  Lexer(CSVFormat  format,  ExtendedBufferedReader  in)  {  this.format  =  format;  this.in  =  in;  this.isEncapsulating  =  format.isEncapsulating();  this.isEscaping  =  format.isEscaping();  this.isCommentEnabled  =  format.isCommentingEnabled();  this.delimiter  =  format.getDelimiter();  this.escape  =  format.getEscape();  this.encapsulator  =  format.getEncapsulator();  this.commmentStart  =  format.getCommentStart();  [BUGGY]  this.surroundingSpacesIgnored  =  null.isSurroundingSpacesIgnored(  )  ;  [BUGGY]  this.emptyLinesIgnored  =  format.isEmptyLinesIgnored();  }    [CLASS]  Lexer  [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)    CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char  commmentStart  delimiter  encapsulator  escape  ExtendedBufferedReader  in  CSVFormat  format  boolean  emptyLinesIgnored  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored    	[P8_Replace_Mix]
[PATCH]  this.surroundingSpacesIgnored  =  format.isSurroundingSpacesIgnored  (  )  ;	[BUG]  [BUGGY]  this.emptyLinesIgnored  =  format.isEmptyLinesIgnored(  )  ;this.surroundingSpacesIgnored  =  format.isSurroundingSpacesIgnored(  )  ;[CE]  variable  emptyLinesIgnored  might  already  have  been  assigned  [CONTEXT]  Lexer(CSVFormat  format,  ExtendedBufferedReader  in)  {  this.format  =  format;  this.in  =  in;  this.isEncapsulating  =  format.isEncapsulating();  this.isEscaping  =  format.isEscaping();  this.isCommentEnabled  =  format.isCommentingEnabled();  this.delimiter  =  format.getDelimiter();  this.escape  =  format.getEscape();  this.encapsulator  =  format.getEncapsulator();  this.commmentStart  =  format.getCommentStart();  [BUGGY]  this.emptyLinesIgnored  =  format.isEmptyLinesIgnored(  )  ;this.surroundingSpacesIgnored  =  format.isSurroundingSpacesIgnored(  )  ;  [BUGGY]  this.emptyLinesIgnored  =  format.isEmptyLinesIgnored();  }    [CLASS]  Lexer  [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)    CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char  commmentStart  delimiter  encapsulator  escape  ExtendedBufferedReader  in  CSVFormat  format  boolean  emptyLinesIgnored  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored    	[P11_Insert_Donor_Statement]
[PATCH]  this.surroundingSpacesIgnored  =  format.isSurroundingSpacesIgnored  (  )  ;  this.emptyLinesIgnored  =  format.isEmptyLinesIgnored  (  )  ;  }	[BUG]  [BUGGY]  [CE]  ';'  expected  [CONTEXT]  Lexer(CSVFormat  format,  ExtendedBufferedReader  in)  {  this.format  =  format;  this.in  =  in;  this.isEncapsulating  =  format.isEncapsulating();  this.isEscaping  =  format.isEscaping();  this.isCommentEnabled  =  format.isCommentingEnabled();  this.delimiter  =  format.getDelimiter();  this.escape  =  format.getEscape();  this.encapsulator  =  format.getEncapsulator();  this.commmentStart  =  format.getCommentStart();  [BUGGY]  [BUGGY]        [CLASS]  Lexer  [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)    CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char  commmentStart  delimiter  encapsulator  escape  ExtendedBufferedReader  in  CSVFormat  format  boolean  emptyLinesIgnored  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored    	[P14_Delete_Statement]
[PATCH]  this.emptyLinesIgnored  =  format.isEmptyLinesIgnored  (  )  ;	[BUG]  [BUGGY]  this.emptyLinesIgnored  =  null.isEmptyLinesIgnored(  )  ;[CE]  <null>  cannot  be  dereferenced  [CONTEXT]  Lexer(CSVFormat  format,  ExtendedBufferedReader  in)  {  this.format  =  format;  this.in  =  in;  this.isEncapsulating  =  format.isEncapsulating();  this.isEscaping  =  format.isEscaping();  this.isCommentEnabled  =  format.isCommentingEnabled();  this.delimiter  =  format.getDelimiter();  this.escape  =  format.getEscape();  this.encapsulator  =  format.getEncapsulator();  this.commmentStart  =  format.getCommentStart();  this.surroundingSpacesIgnored  =  format.isSurroundingSpacesIgnored();  [BUGGY]  this.emptyLinesIgnored  =  null.isEmptyLinesIgnored(  )  ;  [BUGGY]  }    [CLASS]  Lexer  [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)    CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char  commmentStart  delimiter  encapsulator  escape  ExtendedBufferedReader  in  CSVFormat  format  boolean  emptyLinesIgnored  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored    	[P8_Replace_Mix]
[PATCH]  this.emptyLinesIgnored  =  format.isEmptyLinesIgnored  (  )  ;	[BUG]  [BUGGY]  this.escape  =  format.getEscape(  )  ;this.emptyLinesIgnored  =  format.isEmptyLinesIgnored(  )  ;[CE]  variable  escape  might  already  have  been  assigned  [CONTEXT]  Lexer(CSVFormat  format,  ExtendedBufferedReader  in)  {  this.format  =  format;  this.in  =  in;  this.isEncapsulating  =  format.isEncapsulating();  this.isEscaping  =  format.isEscaping();  this.isCommentEnabled  =  format.isCommentingEnabled();  this.delimiter  =  format.getDelimiter();  this.escape  =  format.getEscape();  this.encapsulator  =  format.getEncapsulator();  this.commmentStart  =  format.getCommentStart();  this.surroundingSpacesIgnored  =  format.isSurroundingSpacesIgnored();  [BUGGY]  this.escape  =  format.getEscape(  )  ;this.emptyLinesIgnored  =  format.isEmptyLinesIgnored(  )  ;  [BUGGY]  }    [CLASS]  Lexer  [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)    CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char  commmentStart  delimiter  encapsulator  escape  ExtendedBufferedReader  in  CSVFormat  format  boolean  emptyLinesIgnored  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored    	[P11_Insert_Donor_Statement]
[PATCH]  this.emptyLinesIgnored  =  format.isEmptyLinesIgnored  (  )  ;	[BUG]  [BUGGY]  this.surroundingSpacesIgnored  =  format.isSurroundingSpacesIgnored(  )  ;this.emptyLinesIgnored  =  format.isEmptyLinesIgnored(  )  ;[CE]  variable  surroundingSpacesIgnored  might  already  have  been  assigned  [CONTEXT]  Lexer(CSVFormat  format,  ExtendedBufferedReader  in)  {  this.format  =  format;  this.in  =  in;  this.isEncapsulating  =  format.isEncapsulating();  this.isEscaping  =  format.isEscaping();  this.isCommentEnabled  =  format.isCommentingEnabled();  this.delimiter  =  format.getDelimiter();  this.escape  =  format.getEscape();  this.encapsulator  =  format.getEncapsulator();  this.commmentStart  =  format.getCommentStart();  this.surroundingSpacesIgnored  =  format.isSurroundingSpacesIgnored();  [BUGGY]  this.surroundingSpacesIgnored  =  format.isSurroundingSpacesIgnored(  )  ;this.emptyLinesIgnored  =  format.isEmptyLinesIgnored(  )  ;  [BUGGY]  }    [CLASS]  Lexer  [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)    CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char  commmentStart  delimiter  encapsulator  escape  ExtendedBufferedReader  in  CSVFormat  format  boolean  emptyLinesIgnored  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored    	[P11_Insert_Donor_Statement]
[PATCH]  this.emptyLinesIgnored  =  format.isEmptyLinesIgnored  (  )  ;	[BUG]  [BUGGY]  this.isCommentEnabled  =  format.isCommentingEnabled(  )  ;this.emptyLinesIgnored  =  format.isEmptyLinesIgnored(  )  ;[CE]  variable  isCommentEnabled  might  already  have  been  assigned  [CONTEXT]  Lexer(CSVFormat  format,  ExtendedBufferedReader  in)  {  this.format  =  format;  this.in  =  in;  this.isEncapsulating  =  format.isEncapsulating();  this.isEscaping  =  format.isEscaping();  this.isCommentEnabled  =  format.isCommentingEnabled();  this.delimiter  =  format.getDelimiter();  this.escape  =  format.getEscape();  this.encapsulator  =  format.getEncapsulator();  this.commmentStart  =  format.getCommentStart();  this.surroundingSpacesIgnored  =  format.isSurroundingSpacesIgnored();  [BUGGY]  this.isCommentEnabled  =  format.isCommentingEnabled(  )  ;this.emptyLinesIgnored  =  format.isEmptyLinesIgnored(  )  ;  [BUGGY]  }    [CLASS]  Lexer  [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)    CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char  commmentStart  delimiter  encapsulator  escape  ExtendedBufferedReader  in  CSVFormat  format  boolean  emptyLinesIgnored  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored    	[P11_Insert_Donor_Statement]
[PATCH]  this.emptyLinesIgnored  =  format.isEmptyLinesIgnored  (  )  ;	[BUG]  [BUGGY]  this.isEscaping  =  format.isEscaping(  )  ;this.emptyLinesIgnored  =  format.isEmptyLinesIgnored(  )  ;[CE]  variable  isEscaping  might  already  have  been  assigned  [CONTEXT]  Lexer(CSVFormat  format,  ExtendedBufferedReader  in)  {  this.format  =  format;  this.in  =  in;  this.isEncapsulating  =  format.isEncapsulating();  this.isEscaping  =  format.isEscaping();  this.isCommentEnabled  =  format.isCommentingEnabled();  this.delimiter  =  format.getDelimiter();  this.escape  =  format.getEscape();  this.encapsulator  =  format.getEncapsulator();  this.commmentStart  =  format.getCommentStart();  this.surroundingSpacesIgnored  =  format.isSurroundingSpacesIgnored();  [BUGGY]  this.isEscaping  =  format.isEscaping(  )  ;this.emptyLinesIgnored  =  format.isEmptyLinesIgnored(  )  ;  [BUGGY]  }    [CLASS]  Lexer  [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)    CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char  commmentStart  delimiter  encapsulator  escape  ExtendedBufferedReader  in  CSVFormat  format  boolean  emptyLinesIgnored  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored    	[P11_Insert_Donor_Statement]
[PATCH]  this.emptyLinesIgnored  =  format.isEmptyLinesIgnored  (  )  ;	[BUG]  [BUGGY]  this.delimiter  =  format.getDelimiter(  )  ;this.emptyLinesIgnored  =  format.isEmptyLinesIgnored(  )  ;[CE]  variable  delimiter  might  already  have  been  assigned  [CONTEXT]  Lexer(CSVFormat  format,  ExtendedBufferedReader  in)  {  this.format  =  format;  this.in  =  in;  this.isEncapsulating  =  format.isEncapsulating();  this.isEscaping  =  format.isEscaping();  this.isCommentEnabled  =  format.isCommentingEnabled();  this.delimiter  =  format.getDelimiter();  this.escape  =  format.getEscape();  this.encapsulator  =  format.getEncapsulator();  this.commmentStart  =  format.getCommentStart();  this.surroundingSpacesIgnored  =  format.isSurroundingSpacesIgnored();  [BUGGY]  this.delimiter  =  format.getDelimiter(  )  ;this.emptyLinesIgnored  =  format.isEmptyLinesIgnored(  )  ;  [BUGGY]  }    [CLASS]  Lexer  [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)    CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char  commmentStart  delimiter  encapsulator  escape  ExtendedBufferedReader  in  CSVFormat  format  boolean  emptyLinesIgnored  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored    	[P11_Insert_Donor_Statement]
[PATCH]  this.emptyLinesIgnored  =  format.isEmptyLinesIgnored  (  )  ;	[BUG]  [BUGGY]  this.emptyLinesIgnored  =  format.isSurroundingSpacesIgnored(  )  ;[FE]  Token  type  expected:<EOF>  but  was:<EORECORD>  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  Lexer(CSVFormat  format,  ExtendedBufferedReader  in)  {  this.format  =  format;  this.in  =  in;  this.isEncapsulating  =  format.isEncapsulating();  this.isEscaping  =  format.isEscaping();  this.isCommentEnabled  =  format.isCommentingEnabled();  this.delimiter  =  format.getDelimiter();  this.escape  =  format.getEscape();  this.encapsulator  =  format.getEncapsulator();  this.commmentStart  =  format.getCommentStart();  this.surroundingSpacesIgnored  =  format.isSurroundingSpacesIgnored();  [BUGGY]  this.emptyLinesIgnored  =  format.isSurroundingSpacesIgnored(  )  ;  [BUGGY]  }    [CLASS]  Lexer  [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)    CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char  commmentStart  delimiter  encapsulator  escape  ExtendedBufferedReader  in  CSVFormat  format  boolean  emptyLinesIgnored  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored    	[P8_Replace_Mix]
[PATCH]  this.emptyLinesIgnored  =  format.isEmptyLinesIgnored  (  )  ;  }	[BUG]  [BUGGY]  [CE]  ';'  expected  [CONTEXT]  Lexer(CSVFormat  format,  ExtendedBufferedReader  in)  {  this.format  =  format;  this.in  =  in;  this.isEncapsulating  =  format.isEncapsulating();  this.isEscaping  =  format.isEscaping();  this.isCommentEnabled  =  format.isCommentingEnabled();  this.delimiter  =  format.getDelimiter();  this.escape  =  format.getEscape();  this.encapsulator  =  format.getEncapsulator();  this.commmentStart  =  format.getCommentStart();  this.surroundingSpacesIgnored  =  format.isSurroundingSpacesIgnored();  [BUGGY]  [BUGGY]      [CLASS]  Lexer  [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)    CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char  commmentStart  delimiter  encapsulator  escape  ExtendedBufferedReader  in  CSVFormat  format  boolean  emptyLinesIgnored  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored    	[P14_Delete_Statement]
[PATCH]  return  in.getLineNumber  (  )  ;	[BUG]  [BUGGY]  return  in.read(  )  ;[CE]  unreported  exception  IOException;  must  be  caught  or  declared  to  be  thrown  [CONTEXT]  int  getLineNumber()  {  [BUGGY]  return  in.read(  )  ;  [BUGGY]  }    [CLASS]  Lexer  [METHOD]  getLineNumber  [RETURN_TYPE]  int    [VARIABLES]  char  commmentStart  delimiter  encapsulator  escape  ExtendedBufferedReader  in  CSVFormat  format  boolean  emptyLinesIgnored  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored    	[P7_Replace_Invocation]
[PATCH]  c  =  in.read  (  )  ;	[BUG]  [BUGGY]  c  =  in.lookAhead(  )  ;[FE]  null  testBackslashEscaping2  assertTrue(CSVPrinterTest.equals(res,  records));  [CONTEXT]  int  readEscape(int  c)  throws  IOException  {    [BUGGY]  c  =  in.lookAhead(  )  ;  [BUGGY]  switch  (c)  {  case  'r':  return  '\r';  case  'n':  return  '\n';  case  't':  return  '\t';  case  'b':  return  '\b';  case  'f':  return  '\f';  default:  return  c;  }  }    [CLASS]  Lexer  [METHOD]  readEscape  [RETURN_TYPE]  int    int  c  [VARIABLES]  char  commmentStart  delimiter  encapsulator  escape  ExtendedBufferedReader  in  CSVFormat  format  boolean  emptyLinesIgnored  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored  int  c    	[P7_Replace_Invocation]
[PATCH]  c  =  in.read  (  )  ;	[BUG]  [BUGGY]  c  ;[CE]  not  a  statement  [CONTEXT]  int  readEscape(int  c)  throws  IOException  {    [BUGGY]  c  ;  [BUGGY]  switch  (c)  {  case  'r':  return  '\r';  case  'n':  return  '\n';  case  't':  return  '\t';  case  'b':  return  '\b';  case  'f':  return  '\f';  default:  return  c;  }  }    [CLASS]  Lexer  [METHOD]  readEscape  [RETURN_TYPE]  int    int  c  [VARIABLES]  char  commmentStart  delimiter  encapsulator  escape  ExtendedBufferedReader  in  CSVFormat  format  boolean  emptyLinesIgnored  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored  int  c    	[P8_Replace_Mix]
[PATCH]  int  length  =  buffer.length  (  )  ;	[BUG]  [BUGGY]  short  length  =  buffer.length(  )  ;[CE]  possible  loss  of  precision  [CONTEXT]  void  trimTrailingSpaces(StringBuilder  buffer)  {  [BUGGY]  short  length  =  buffer.length(  )  ;  [BUGGY]  while  (length  >  0  &&  Character.isWhitespace(buffer.charAt(length  -  1)))  {  length  =  length  -  1;  }  if  (length  !=  buffer.length())  {  buffer.setLength(length);  }  }    [CLASS]  Lexer  [METHOD]  trimTrailingSpaces  [RETURN_TYPE]  void    StringBuilder  buffer  [VARIABLES]  char  commmentStart  delimiter  encapsulator  escape  ExtendedBufferedReader  in  CSVFormat  format  boolean  emptyLinesIgnored  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored  StringBuilder  buffer  int  length    	[P1_Replace_Type]
[PATCH]  int  length  =  buffer.length  (  )  ;	[BUG]  [BUGGY]  int  length  =  buffer.length()  +  9  ;[FE]  String  index  out  of  range:  11  testNextToken1  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  void  trimTrailingSpaces(StringBuilder  buffer)  {  [BUGGY]  int  length  =  buffer.length()  +  9  ;  [BUGGY]  while  (length  >  0  &&  Character.isWhitespace(buffer.charAt(length  -  1)))  {  length  =  length  -  1;  }  if  (length  !=  buffer.length())  {  buffer.setLength(length);  }  }    [CLASS]  Lexer  [METHOD]  trimTrailingSpaces  [RETURN_TYPE]  void    StringBuilder  buffer  [VARIABLES]  char  commmentStart  delimiter  encapsulator  escape  ExtendedBufferedReader  in  CSVFormat  format  boolean  emptyLinesIgnored  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored  StringBuilder  buffer  int  length    	[P3_Replace_Literal]
[PATCH]  int  length  =  buffer.length  (  )  ;	[BUG]  [BUGGY]  int  length  =  buffer.setLength(  )  ;[CE]  method  setLength  in  class  AbstractStringBuilder  cannot  be  applied  to  given  types;  [CONTEXT]  void  trimTrailingSpaces(StringBuilder  buffer)  {  [BUGGY]  int  length  =  buffer.setLength(  )  ;  [BUGGY]  while  (length  >  0  &&  Character.isWhitespace(buffer.charAt(length  -  1)))  {  length  =  length  -  1;  }  if  (length  !=  buffer.length())  {  buffer.setLength(length);  }  }    [CLASS]  Lexer  [METHOD]  trimTrailingSpaces  [RETURN_TYPE]  void    StringBuilder  buffer  [VARIABLES]  char  commmentStart  delimiter  encapsulator  escape  ExtendedBufferedReader  in  CSVFormat  format  boolean  emptyLinesIgnored  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored  StringBuilder  buffer  int  length    	[P7_Replace_Invocation]
[PATCH]  int  length  =  buffer.length  (  )  ;	[BUG]  [BUGGY]  int  length  =  buffer.setLength(  length)  ;[CE]  incompatible  types  [CONTEXT]  void  trimTrailingSpaces(StringBuilder  buffer)  {  [BUGGY]  int  length  =  buffer.setLength(  length)  ;  [BUGGY]  while  (length  >  0  &&  Character.isWhitespace(buffer.charAt(length  -  1)))  {  length  =  length  -  1;  }  if  (length  !=  buffer.length())  {  buffer.setLength(length);  }  }    [CLASS]  Lexer  [METHOD]  trimTrailingSpaces  [RETURN_TYPE]  void    StringBuilder  buffer  [VARIABLES]  char  commmentStart  delimiter  encapsulator  escape  ExtendedBufferedReader  in  CSVFormat  format  boolean  emptyLinesIgnored  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored  StringBuilder  buffer  int  length    	[P7_Replace_Invocation]
[PATCH]  int  length  =  buffer.length  (  )  ;	[BUG]  [BUGGY]  if  (  length  !=  buffer.length(  )  )  {  int  length  =  buffer.length(  )  ;  }[CE]  cannot  find  symbol  length  [CONTEXT]  void  trimTrailingSpaces(StringBuilder  buffer)  {  [BUGGY]  if  (  length  !=  buffer.length(  )  )  {  int  length  =  buffer.length(  )  ;  }  [BUGGY]  while  (length  >  0  &&  Character.isWhitespace(buffer.charAt(length  -  1)))  {  length  =  length  -  1;  }  if  (length  !=  buffer.length())  {  buffer.setLength(length);  }  }    [CLASS]  Lexer  [METHOD]  trimTrailingSpaces  [RETURN_TYPE]  void    StringBuilder  buffer  [VARIABLES]  char  commmentStart  delimiter  encapsulator  escape  ExtendedBufferedReader  in  CSVFormat  format  boolean  emptyLinesIgnored  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored  StringBuilder  buffer  int  length    	[P12_Insert_Condition]
[PATCH]  int  length  =  buffer.length  (  )  ;	[BUG]  [BUGGY]  int  length  =  buffer.length()  +  8  ;[FE]  String  index  out  of  range:  10  testNextToken1  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  void  trimTrailingSpaces(StringBuilder  buffer)  {  [BUGGY]  int  length  =  buffer.length()  +  8  ;  [BUGGY]  while  (length  >  0  &&  Character.isWhitespace(buffer.charAt(length  -  1)))  {  length  =  length  -  1;  }  if  (length  !=  buffer.length())  {  buffer.setLength(length);  }  }    [CLASS]  Lexer  [METHOD]  trimTrailingSpaces  [RETURN_TYPE]  void    StringBuilder  buffer  [VARIABLES]  char  commmentStart  delimiter  encapsulator  escape  ExtendedBufferedReader  in  CSVFormat  format  boolean  emptyLinesIgnored  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored  StringBuilder  buffer  int  length    	[P3_Replace_Literal]
[PATCH]  while  (  length  >  0  &&  Character.isWhitespace  (  buffer.charAt  (  length  -  1  )  )  )  {	[BUG]  [BUGGY]  while  (  length  >  0  ||  Character.isWhitespace(  buffer.charAt(  length  -  1)  )  )  {[FE]  String  index  out  of  range:  -1  testNextToken1  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  void  trimTrailingSpaces(StringBuilder  buffer)  {  int  length  =  buffer.length();  [BUGGY]  while  (  length  >  0  ||  Character.isWhitespace(  buffer.charAt(  length  -  1)  )  )  {  [BUGGY]  length  =  length  -  1;  }  if  (length  !=  buffer.length())  {  buffer.setLength(length);  }  }    [CLASS]  Lexer  [METHOD]  trimTrailingSpaces  [RETURN_TYPE]  void    StringBuilder  buffer  [VARIABLES]  char  commmentStart  delimiter  encapsulator  escape  ExtendedBufferedReader  in  CSVFormat  format  boolean  emptyLinesIgnored  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored  StringBuilder  buffer  int  length    	[P2_Replace_Operator]
[PATCH]  while  (  length  >  0  &&  Character.isWhitespace  (  buffer.charAt  (  length  -  1  )  )  )  {	[BUG]  [BUGGY]  while  (  length  >  0  &&  Character.isWhitespace(  buffer.charAt(  length  &&  1)  )  )  {[CE]  bad  operand  types  for  binary  operator  '&&'  [CONTEXT]  void  trimTrailingSpaces(StringBuilder  buffer)  {  int  length  =  buffer.length();  [BUGGY]  while  (  length  >  0  &&  Character.isWhitespace(  buffer.charAt(  length  &&  1)  )  )  {  [BUGGY]  length  =  length  -  1;  }  if  (length  !=  buffer.length())  {  buffer.setLength(length);  }  }    [CLASS]  Lexer  [METHOD]  trimTrailingSpaces  [RETURN_TYPE]  void    StringBuilder  buffer  [VARIABLES]  char  commmentStart  delimiter  encapsulator  escape  ExtendedBufferedReader  in  CSVFormat  format  boolean  emptyLinesIgnored  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored  StringBuilder  buffer  int  length    	[P2_Replace_Operator]
[PATCH]  while  (  length  >  0  &&  Character.isWhitespace  (  buffer.charAt  (  length  -  1  )  )  )  {	[BUG]  [BUGGY]  while  (  length  >  0  &&  Character.isWhitespace(  buffer.charAt(  length  >>  1)  )  )  {[FE]  Token  content  expected:<uv[]>  but  was:<uv[  ]>  testNextToken1  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  void  trimTrailingSpaces(StringBuilder  buffer)  {  int  length  =  buffer.length();  [BUGGY]  while  (  length  >  0  &&  Character.isWhitespace(  buffer.charAt(  length  >>  1)  )  )  {  [BUGGY]  length  =  length  -  1;  }  if  (length  !=  buffer.length())  {  buffer.setLength(length);  }  }    [CLASS]  Lexer  [METHOD]  trimTrailingSpaces  [RETURN_TYPE]  void    StringBuilder  buffer  [VARIABLES]  char  commmentStart  delimiter  encapsulator  escape  ExtendedBufferedReader  in  CSVFormat  format  boolean  emptyLinesIgnored  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored  StringBuilder  buffer  int  length    	[P2_Replace_Operator]
[PATCH]  while  (  length  >  0  &&  Character.isWhitespace  (  buffer.charAt  (  length  -  1  )  )  )  {	[BUG]  [BUGGY]  while  (  length  >  6  &&  Character.isWhitespace(  buffer.charAt(  length  -  1)  )  )  {[FE]  Token  content  expected:<uv[]>  but  was:<uv[  ]>  testNextToken1  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  void  trimTrailingSpaces(StringBuilder  buffer)  {  int  length  =  buffer.length();  [BUGGY]  while  (  length  >  6  &&  Character.isWhitespace(  buffer.charAt(  length  -  1)  )  )  {  [BUGGY]  length  =  length  -  1;  }  if  (length  !=  buffer.length())  {  buffer.setLength(length);  }  }    [CLASS]  Lexer  [METHOD]  trimTrailingSpaces  [RETURN_TYPE]  void    StringBuilder  buffer  [VARIABLES]  char  commmentStart  delimiter  encapsulator  escape  ExtendedBufferedReader  in  CSVFormat  format  boolean  emptyLinesIgnored  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored  StringBuilder  buffer  int  length    	[P3_Replace_Literal]
[PATCH]  while  (  length  >  0  &&  Character.isWhitespace  (  buffer.charAt  (  length  -  1  )  )  )  {	[BUG]  [BUGGY]  while  (  length  >  0  &&  Character.isWhitespace(  buffer.charAt(  length  -  length)  )  )  {[FE]  Token  content  expected:<uv[]>  but  was:<uv[  ]>  testNextToken1  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  void  trimTrailingSpaces(StringBuilder  buffer)  {  int  length  =  buffer.length();  [BUGGY]  while  (  length  >  0  &&  Character.isWhitespace(  buffer.charAt(  length  -  length)  )  )  {  [BUGGY]  length  =  length  -  1;  }  if  (length  !=  buffer.length())  {  buffer.setLength(length);  }  }    [CLASS]  Lexer  [METHOD]  trimTrailingSpaces  [RETURN_TYPE]  void    StringBuilder  buffer  [VARIABLES]  char  commmentStart  delimiter  encapsulator  escape  ExtendedBufferedReader  in  CSVFormat  format  boolean  emptyLinesIgnored  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored  StringBuilder  buffer  int  length    	[P3_Replace_Literal]
[PATCH]  while  (  length  >  0  &&  Character.isWhitespace  (  buffer.charAt  (  length  -  1  )  )  )  {	[BUG]  [BUGGY]  while  (  length  >  0  &&  Character.isWhitespace(  buffer.charAt(  length  )  )  )  {[FE]  String  index  out  of  range:  3  testNextToken1  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  void  trimTrailingSpaces(StringBuilder  buffer)  {  int  length  =  buffer.length();  [BUGGY]  while  (  length  >  0  &&  Character.isWhitespace(  buffer.charAt(  length  )  )  )  {  [BUGGY]  length  =  length  -  1;  }  if  (length  !=  buffer.length())  {  buffer.setLength(length);  }  }    [CLASS]  Lexer  [METHOD]  trimTrailingSpaces  [RETURN_TYPE]  void    StringBuilder  buffer  [VARIABLES]  char  commmentStart  delimiter  encapsulator  escape  ExtendedBufferedReader  in  CSVFormat  format  boolean  emptyLinesIgnored  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored  StringBuilder  buffer  int  length    	[P3_Replace_Literal]
[PATCH]  while  (  length  >  0  &&  Character.isWhitespace  (  buffer.charAt  (  length  -  1  )  )  )  {	[BUG]  [BUGGY]  while  (  buffer  >  0  &&  Character.isWhitespace(  length.charAt(  length  -  1)  )  )  {[CE]  bad  operand  types  for  binary  operator  '>'  [CONTEXT]  void  trimTrailingSpaces(StringBuilder  buffer)  {  int  length  =  buffer.length();  [BUGGY]  while  (  buffer  >  0  &&  Character.isWhitespace(  length.charAt(  length  -  1)  )  )  {  [BUGGY]  length  =  length  -  1;  }  if  (length  !=  buffer.length())  {  buffer.setLength(length);  }  }    [CLASS]  Lexer  [METHOD]  trimTrailingSpaces  [RETURN_TYPE]  void    StringBuilder  buffer  [VARIABLES]  char  commmentStart  delimiter  encapsulator  escape  ExtendedBufferedReader  in  CSVFormat  format  boolean  emptyLinesIgnored  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored  StringBuilder  buffer  int  length    	[P5_Replace_Variable]
[PATCH]  length  =  length  -  1;	[BUG]  [BUGGY]  length  =  length  -  length;[FE]  Token  content  expected:<[uv]>  but  was:<[]>  testNextToken1  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  void  trimTrailingSpaces(StringBuilder  buffer)  {  int  length  =  buffer.length();  while  (length  >  0  &&  Character.isWhitespace(buffer.charAt(length  -  1)))  {  [BUGGY]  length  =  length  -  length;  [BUGGY]  }  if  (length  !=  buffer.length())  {  buffer.setLength(length);  }  }    [CLASS]  Lexer  [METHOD]  trimTrailingSpaces  [RETURN_TYPE]  void    StringBuilder  buffer  [VARIABLES]  char  commmentStart  delimiter  encapsulator  escape  ExtendedBufferedReader  in  CSVFormat  format  boolean  emptyLinesIgnored  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored  StringBuilder  buffer  int  length    	[P3_Replace_Literal]
[PATCH]  length  =  length  -  1;	[BUG]  [BUGGY]  length  =  length  -  0  ;[FE]  [CONTEXT]  void  trimTrailingSpaces(StringBuilder  buffer)  {  int  length  =  buffer.length();  while  (length  >  0  &&  Character.isWhitespace(buffer.charAt(length  -  1)))  {  [BUGGY]  length  =  length  -  0  ;  [BUGGY]  }  if  (length  !=  buffer.length())  {  buffer.setLength(length);  }  }    [CLASS]  Lexer  [METHOD]  trimTrailingSpaces  [RETURN_TYPE]  void    StringBuilder  buffer  [VARIABLES]  char  commmentStart  delimiter  encapsulator  escape  ExtendedBufferedReader  in  CSVFormat  format  boolean  emptyLinesIgnored  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored  StringBuilder  buffer  int  length    	[P8_Replace_Mix]
[PATCH]  length  =  length  -  1;	[BUG]  [BUGGY]  length  =  length  <  1;[CE]  incompatible  types  [CONTEXT]  void  trimTrailingSpaces(StringBuilder  buffer)  {  int  length  =  buffer.length();  while  (length  >  0  &&  Character.isWhitespace(buffer.charAt(length  -  1)))  {  [BUGGY]  length  =  length  <  1;  [BUGGY]  }  if  (length  !=  buffer.length())  {  buffer.setLength(length);  }  }    [CLASS]  Lexer  [METHOD]  trimTrailingSpaces  [RETURN_TYPE]  void    StringBuilder  buffer  [VARIABLES]  char  commmentStart  delimiter  encapsulator  escape  ExtendedBufferedReader  in  CSVFormat  format  boolean  emptyLinesIgnored  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored  StringBuilder  buffer  int  length    	[P2_Replace_Operator]
[PATCH]  length  =  length  -  1;	[BUG]  [BUGGY]  length  =  length  ;[FE]  [CONTEXT]  void  trimTrailingSpaces(StringBuilder  buffer)  {  int  length  =  buffer.length();  while  (length  >  0  &&  Character.isWhitespace(buffer.charAt(length  -  1)))  {  [BUGGY]  length  =  length  ;  [BUGGY]  }  if  (length  !=  buffer.length())  {  buffer.setLength(length);  }  }    [CLASS]  Lexer  [METHOD]  trimTrailingSpaces  [RETURN_TYPE]  void    StringBuilder  buffer  [VARIABLES]  char  commmentStart  delimiter  encapsulator  escape  ExtendedBufferedReader  in  CSVFormat  format  boolean  emptyLinesIgnored  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored  StringBuilder  buffer  int  length    	[P3_Replace_Literal]
[PATCH]  while  (  length  >  0  &&  Character.isWhitespace  (  buffer.charAt  (  length  -  1  )  )  )  {	[BUG]  [BUGGY]  while  (  length  >  0  &&  Character.isWhitespace(  buffer.setLength(  length)  )  )  {[CE]  'void'  type  not  allowed  here  [CONTEXT]  void  trimTrailingSpaces(StringBuilder  buffer)  {  int  length  =  buffer.length();  [BUGGY]  while  (  length  >  0  &&  Character.isWhitespace(  buffer.setLength(  length)  )  )  {  [BUGGY]  length  =  length  -  1;  }  if  (length  !=  buffer.length())  {  buffer.setLength(length);  }  }    [CLASS]  Lexer  [METHOD]  trimTrailingSpaces  [RETURN_TYPE]  void    StringBuilder  buffer  [VARIABLES]  char  commmentStart  delimiter  encapsulator  escape  ExtendedBufferedReader  in  CSVFormat  format  boolean  emptyLinesIgnored  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored  StringBuilder  buffer  int  length    	[P8_Replace_Mix]
[PATCH]  while  (  length  >  0  &&  Character.isWhitespace  (  buffer.charAt  (  length  -  1  )  )  )  {  length  =  length  -  1;	[BUG]  [BUGGY]  [FE]  [CONTEXT]  void  trimTrailingSpaces(StringBuilder  buffer)  {  int  length  =  buffer.length();  [BUGGY]  [BUGGY]    }  if  (length  !=  buffer.length())  {  buffer.setLength(length);  }    [CLASS]  Lexer  [METHOD]  trimTrailingSpaces  [RETURN_TYPE]  void    StringBuilder  buffer  [VARIABLES]  char  commmentStart  delimiter  encapsulator  escape  ExtendedBufferedReader  in  CSVFormat  format  boolean  emptyLinesIgnored  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored  StringBuilder  buffer  int  length    	[P14_Delete_Statement]
[PATCH]  while  (  length  >  0  &&  Character.isWhitespace  (  buffer.charAt  (  length  -  1  )  )  )  {	[BUG]  [BUGGY]  while  (  length  >  0  &&  Character.isWhitespace(  buffer.charAt(  length  ==  1)  )  )  {[CE]  method  charAt  in  class  AbstractStringBuilder  cannot  be  applied  to  given  types;  [CONTEXT]  void  trimTrailingSpaces(StringBuilder  buffer)  {  int  length  =  buffer.length();  [BUGGY]  while  (  length  >  0  &&  Character.isWhitespace(  buffer.charAt(  length  ==  1)  )  )  {  [BUGGY]  length  =  length  -  1;  }  if  (length  !=  buffer.length())  {  buffer.setLength(length);  }  }    [CLASS]  Lexer  [METHOD]  trimTrailingSpaces  [RETURN_TYPE]  void    StringBuilder  buffer  [VARIABLES]  char  commmentStart  delimiter  encapsulator  escape  ExtendedBufferedReader  in  CSVFormat  format  boolean  emptyLinesIgnored  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored  StringBuilder  buffer  int  length    	[P2_Replace_Operator]
[PATCH]  if  (  length  !=  buffer.length  (  )  )  {	[BUG]  [BUGGY]  if  (  length  >=  buffer.length(  )  )  {[FE]  Token  content  expected:<uv[]>  but  was:<uv[  ]>  testNextToken1  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  void  trimTrailingSpaces(StringBuilder  buffer)  {  int  length  =  buffer.length();  while  (length  >  0  &&  Character.isWhitespace(buffer.charAt(length  -  1)))  {  length  =  length  -  1;  }  [BUGGY]  if  (  length  >=  buffer.length(  )  )  {  [BUGGY]  buffer.setLength(length);  }  }    [CLASS]  Lexer  [METHOD]  trimTrailingSpaces  [RETURN_TYPE]  void    StringBuilder  buffer  [VARIABLES]  char  commmentStart  delimiter  encapsulator  escape  ExtendedBufferedReader  in  CSVFormat  format  boolean  emptyLinesIgnored  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored  StringBuilder  buffer  int  length    	[P2_Replace_Operator]
[PATCH]  if  (  length  !=  buffer.length  (  )  )  {	[BUG]  [BUGGY]  if  (  buffer  !=  length.length(  )  )  {[CE]  int  cannot  be  dereferenced  [CONTEXT]  void  trimTrailingSpaces(StringBuilder  buffer)  {  int  length  =  buffer.length();  while  (length  >  0  &&  Character.isWhitespace(buffer.charAt(length  -  1)))  {  length  =  length  -  1;  }  [BUGGY]  if  (  buffer  !=  length.length(  )  )  {  [BUGGY]  buffer.setLength(length);  }  }    [CLASS]  Lexer  [METHOD]  trimTrailingSpaces  [RETURN_TYPE]  void    StringBuilder  buffer  [VARIABLES]  char  commmentStart  delimiter  encapsulator  escape  ExtendedBufferedReader  in  CSVFormat  format  boolean  emptyLinesIgnored  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored  StringBuilder  buffer  int  length    	[P5_Replace_Variable]
[PATCH]  if  (  length  !=  buffer.length  (  )  )  {	[BUG]  [BUGGY]  if  (  length  !=  buffer.setLength(  )  )  {[CE]  method  setLength  in  class  AbstractStringBuilder  cannot  be  applied  to  given  types;  [CONTEXT]  void  trimTrailingSpaces(StringBuilder  buffer)  {  int  length  =  buffer.length();  while  (length  >  0  &&  Character.isWhitespace(buffer.charAt(length  -  1)))  {  length  =  length  -  1;  }  [BUGGY]  if  (  length  !=  buffer.setLength(  )  )  {  [BUGGY]  buffer.setLength(length);  }  }    [CLASS]  Lexer  [METHOD]  trimTrailingSpaces  [RETURN_TYPE]  void    StringBuilder  buffer  [VARIABLES]  char  commmentStart  delimiter  encapsulator  escape  ExtendedBufferedReader  in  CSVFormat  format  boolean  emptyLinesIgnored  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored  StringBuilder  buffer  int  length    	[P7_Replace_Invocation]
[PATCH]  if  (  length  !=  buffer.length  (  )  )  {  buffer.setLength  (  length  )  ;  }	[BUG]  [BUGGY]  buffer.setLength(length);[CE]  ';'  expected  [CONTEXT]  void  trimTrailingSpaces(StringBuilder  buffer)  {  int  length  =  buffer.length();  while  (length  >  0  &&  Character.isWhitespace(buffer.charAt(length  -  1)))  {  length  =  length  -  1;  }  [BUGGY]  buffer.setLength(length);  [BUGGY]    buffer.setLength(length);      [CLASS]  Lexer  [METHOD]  trimTrailingSpaces  [RETURN_TYPE]  void    StringBuilder  buffer  [VARIABLES]  char  commmentStart  delimiter  encapsulator  escape  ExtendedBufferedReader  in  CSVFormat  format  boolean  emptyLinesIgnored  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored  StringBuilder  buffer  int  length    	[P15_Unwrap_Block]
[PATCH]  if  (  length  !=  buffer.length  (  )  )  {  buffer.setLength  (  length  )  ;  }	[BUG]  [BUGGY]  [CE]  ';'  expected  [CONTEXT]  void  trimTrailingSpaces(StringBuilder  buffer)  {  int  length  =  buffer.length();  while  (length  >  0  &&  Character.isWhitespace(buffer.charAt(length  -  1)))  {  length  =  length  -  1;  }  [BUGGY]  [BUGGY]        [CLASS]  Lexer  [METHOD]  trimTrailingSpaces  [RETURN_TYPE]  void    StringBuilder  buffer  [VARIABLES]  char  commmentStart  delimiter  encapsulator  escape  ExtendedBufferedReader  in  CSVFormat  format  boolean  emptyLinesIgnored  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored  StringBuilder  buffer  int  length    	[P16_Remove_Block]
[PATCH]  buffer.setLength  (  length  )  ;	[BUG]  [BUGGY]  buffer.length(  )  ;[FE]  Token  content  expected:<uv[]>  but  was:<uv[  ]>  testNextToken1  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  void  trimTrailingSpaces(StringBuilder  buffer)  {  int  length  =  buffer.length();  while  (length  >  0  &&  Character.isWhitespace(buffer.charAt(length  -  1)))  {  length  =  length  -  1;  }  if  (length  !=  buffer.length())  {  [BUGGY]  buffer.length(  )  ;  [BUGGY]  }  }    [CLASS]  Lexer  [METHOD]  trimTrailingSpaces  [RETURN_TYPE]  void    StringBuilder  buffer  [VARIABLES]  char  commmentStart  delimiter  encapsulator  escape  ExtendedBufferedReader  in  CSVFormat  format  boolean  emptyLinesIgnored  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored  StringBuilder  buffer  int  length    	[P7_Replace_Invocation]
[PATCH]  if  (  length  !=  buffer.length  (  )  )  {	[BUG]  [BUGGY]  if  (  length  !=  buffer.setLength(  length)  )  {[CE]  'void'  type  not  allowed  here  [CONTEXT]  void  trimTrailingSpaces(StringBuilder  buffer)  {  int  length  =  buffer.length();  while  (length  >  0  &&  Character.isWhitespace(buffer.charAt(length  -  1)))  {  length  =  length  -  1;  }  [BUGGY]  if  (  length  !=  buffer.setLength(  length)  )  {  [BUGGY]  buffer.setLength(length);  }  }    [CLASS]  Lexer  [METHOD]  trimTrailingSpaces  [RETURN_TYPE]  void    StringBuilder  buffer  [VARIABLES]  char  commmentStart  delimiter  encapsulator  escape  ExtendedBufferedReader  in  CSVFormat  format  boolean  emptyLinesIgnored  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored  StringBuilder  buffer  int  length    	[P7_Replace_Invocation]
[PATCH]  return  (  c  !=  format.getDelimiter  (  )  )  &&  Character.isWhitespace  (  (  char  )  c  )  ;	[BUG]  [BUGGY]  return  (  c  !=  format.getDelimiter(  )  )  ||  Character.isWhitespace(  (  char)  c)  ;[FE]  [CONTEXT]  boolean  isWhitespace(int  c)  {  [BUGGY]  return  (  c  !=  format.getDelimiter(  )  )  ||  Character.isWhitespace(  (  char)  c)  ;  [BUGGY]  }    [CLASS]  Lexer  [METHOD]  isWhitespace  [RETURN_TYPE]  boolean    int  c  [VARIABLES]  char  commmentStart  delimiter  encapsulator  escape  ExtendedBufferedReader  in  CSVFormat  format  boolean  emptyLinesIgnored  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored  int  c    	[P2_Replace_Operator]
[PATCH]  return  (  c  !=  format.getDelimiter  (  )  )  &&  Character.isWhitespace  (  (  char  )  c  )  ;	[BUG]  [BUGGY]  return  (  c  ==  format.getDelimiter(  )  )  &&  Character.isWhitespace(  (  char)  c)  ;[FE]  Token  content  expected:<[]hijk>  but  was:<[  ]hijk>  testNextToken1  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  boolean  isWhitespace(int  c)  {  [BUGGY]  return  (  c  ==  format.getDelimiter(  )  )  &&  Character.isWhitespace(  (  char)  c)  ;  [BUGGY]  }    [CLASS]  Lexer  [METHOD]  isWhitespace  [RETURN_TYPE]  boolean    int  c  [VARIABLES]  char  commmentStart  delimiter  encapsulator  escape  ExtendedBufferedReader  in  CSVFormat  format  boolean  emptyLinesIgnored  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored  int  c    	[P2_Replace_Operator]
[PATCH]  return  (  c  !=  format.getDelimiter  (  )  )  &&  Character.isWhitespace  (  (  char  )  c  )  ;	[BUG]  [BUGGY]  return  (  format  !=  c.getDelimiter(  )  )  &&  Character.isWhitespace(  (  char)  c)  ;[CE]  int  cannot  be  dereferenced  [CONTEXT]  boolean  isWhitespace(int  c)  {  [BUGGY]  return  (  format  !=  c.getDelimiter(  )  )  &&  Character.isWhitespace(  (  char)  c)  ;  [BUGGY]  }    [CLASS]  Lexer  [METHOD]  isWhitespace  [RETURN_TYPE]  boolean    int  c  [VARIABLES]  char  commmentStart  delimiter  encapsulator  escape  ExtendedBufferedReader  in  CSVFormat  format  boolean  emptyLinesIgnored  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored  int  c    	[P5_Replace_Variable]
[PATCH]  return  (  c  !=  format.getDelimiter  (  )  )  &&  Character.isWhitespace  (  (  char  )  c  )  ;	[BUG]  [BUGGY]  return  (  c  !=  format.getEscape(  )  )  &&  Character.isWhitespace(  (  char)  c)  ;[FE]  Token  content  expected:<[]>  but  was:<[four]>  testDelimiterIsWhitespace  assertTokenEquals(EOF,   "six ",  parser.nextToken(new  Token()));  [CONTEXT]  boolean  isWhitespace(int  c)  {  [BUGGY]  return  (  c  !=  format.getEscape(  )  )  &&  Character.isWhitespace(  (  char)  c)  ;  [BUGGY]  }    [CLASS]  Lexer  [METHOD]  isWhitespace  [RETURN_TYPE]  boolean    int  c  [VARIABLES]  char  commmentStart  delimiter  encapsulator  escape  ExtendedBufferedReader  in  CSVFormat  format  boolean  emptyLinesIgnored  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored  int  c    	[P7_Replace_Invocation]
[PATCH]  return  (  c  !=  format.getDelimiter  (  )  )  &&  Character.isWhitespace  (  (  char  )  c  )  ;  }	[BUG]  [BUGGY]  [CE]  ';'  expected  [CONTEXT]  boolean  isWhitespace(int  c)  {  [BUGGY]  [BUGGY]      [CLASS]  Lexer  [METHOD]  isWhitespace  [RETURN_TYPE]  boolean    int  c  [VARIABLES]  char  commmentStart  delimiter  encapsulator  escape  ExtendedBufferedReader  in  CSVFormat  format  boolean  emptyLinesIgnored  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored  int  c    	[P14_Delete_Statement]
[PATCH]  if  (  c  ==  '\r'  &&  in.lookAhead  (  )  ==  '\n'  )  {	[BUG]  [BUGGY]  if  (  c  ==  '\r'  ||  in.lookAhead(  )  ==  '\n')  {[FE]  Token  type  expected:<TOKEN>  but  was:<EORECORD>  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  boolean  isEndOfLine(int  c)  throws  IOException  {    [BUGGY]  if  (  c  ==  '\r'  ||  in.lookAhead(  )  ==  '\n')  {  [BUGGY]    c  =  in.read();  }  return  (c  ==  '\n'  ||  c  ==  '\r');  }    [CLASS]  Lexer  [METHOD]  isEndOfLine  [RETURN_TYPE]  boolean    int  c  [VARIABLES]  char  commmentStart  delimiter  encapsulator  escape  ExtendedBufferedReader  in  CSVFormat  format  boolean  emptyLinesIgnored  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored  int  c    	[P2_Replace_Operator]
[PATCH]  if  (  c  ==  '\r'  &&  in.lookAhead  (  )  ==  '\n'  )  {	[BUG]  [BUGGY]  if  (  c  <=  '\r'  &&  in.lookAhead(  )  ==  '\n')  {[FE]  expected:<3>  but  was:<2>  testEmptyLineBehaviourExcel  assertArrayEquals(res[i],  records.get(i).values());  [CONTEXT]  boolean  isEndOfLine(int  c)  throws  IOException  {    [BUGGY]  if  (  c  <=  '\r'  &&  in.lookAhead(  )  ==  '\n')  {  [BUGGY]    c  =  in.read();  }  return  (c  ==  '\n'  ||  c  ==  '\r');  }    [CLASS]  Lexer  [METHOD]  isEndOfLine  [RETURN_TYPE]  boolean    int  c  [VARIABLES]  char  commmentStart  delimiter  encapsulator  escape  ExtendedBufferedReader  in  CSVFormat  format  boolean  emptyLinesIgnored  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored  int  c    	[P2_Replace_Operator]
[PATCH]  if  (  c  ==  '\r'  &&  in.lookAhead  (  )  ==  '\n'  )  {	[BUG]  [BUGGY]  if  (  c  ==  '\r'  &&  in.lookAhead(  )  >=  '\n')  {[FE]  expected:<1>  but  was:<2>  testGetLineNumberWithCR  assertNull(parser.getRecord());  [CONTEXT]  boolean  isEndOfLine(int  c)  throws  IOException  {    [BUGGY]  if  (  c  ==  '\r'  &&  in.lookAhead(  )  >=  '\n')  {  [BUGGY]    c  =  in.read();  }  return  (c  ==  '\n'  ||  c  ==  '\r');  }    [CLASS]  Lexer  [METHOD]  isEndOfLine  [RETURN_TYPE]  boolean    int  c  [VARIABLES]  char  commmentStart  delimiter  encapsulator  escape  ExtendedBufferedReader  in  CSVFormat  format  boolean  emptyLinesIgnored  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored  int  c    	[P2_Replace_Operator]
[PATCH]  if  (  c  ==  '\r'  &&  in.lookAhead  (  )  ==  '\n'  )  {	[BUG]  [BUGGY]  if  (  in  ==  '\r'  &&  c.lookAhead(  )  ==  '\n')  {[CE]  incomparable  types:  ExtendedBufferedReader  and  char  [CONTEXT]  boolean  isEndOfLine(int  c)  throws  IOException  {    [BUGGY]  if  (  in  ==  '\r'  &&  c.lookAhead(  )  ==  '\n')  {  [BUGGY]    c  =  in.read();  }  return  (c  ==  '\n'  ||  c  ==  '\r');  }    [CLASS]  Lexer  [METHOD]  isEndOfLine  [RETURN_TYPE]  boolean    int  c  [VARIABLES]  char  commmentStart  delimiter  encapsulator  escape  ExtendedBufferedReader  in  CSVFormat  format  boolean  emptyLinesIgnored  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored  int  c    	[P5_Replace_Variable]
[PATCH]  if  (  c  ==  '\r'  &&  in.lookAhead  (  )  ==  '\n'  )  {	[BUG]  [BUGGY]  if  (  c  ==  '\r')  {[FE]  expected:<1>  but  was:<2>  testGetLineNumberWithCR  assertNull(parser.getRecord());  [CONTEXT]  boolean  isEndOfLine(int  c)  throws  IOException  {    [BUGGY]  if  (  c  ==  '\r')  {  [BUGGY]    c  =  in.read();  }  return  (c  ==  '\n'  ||  c  ==  '\r');  }    [CLASS]  Lexer  [METHOD]  isEndOfLine  [RETURN_TYPE]  boolean    int  c  [VARIABLES]  char  commmentStart  delimiter  encapsulator  escape  ExtendedBufferedReader  in  CSVFormat  format  boolean  emptyLinesIgnored  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored  int  c    	[P6_Replace_Expression]
[PATCH]  if  (  c  ==  '\r'  &&  in.lookAhead  (  )  ==  '\n'  )  {	[BUG]  [BUGGY]  if  (  in.lookAhead(  )  ==  '\n')  {[FE]  Token  type  expected:<TOKEN>  but  was:<EORECORD>  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  boolean  isEndOfLine(int  c)  throws  IOException  {    [BUGGY]  if  (  in.lookAhead(  )  ==  '\n')  {  [BUGGY]    c  =  in.read();  }  return  (c  ==  '\n'  ||  c  ==  '\r');  }    [CLASS]  Lexer  [METHOD]  isEndOfLine  [RETURN_TYPE]  boolean    int  c  [VARIABLES]  char  commmentStart  delimiter  encapsulator  escape  ExtendedBufferedReader  in  CSVFormat  format  boolean  emptyLinesIgnored  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored  int  c    	[P6_Replace_Expression]
[PATCH]  if  (  c  ==  '\r'  &&  in.lookAhead  (  )  ==  '\n'  )  {	[BUG]  [BUGGY]  if  (  c  ==  '\r'  &&  in.read(  )  ==  '\n')  {[FE]  null  testGetLineNumberWithCR  assertNull(parser.getRecord());  [CONTEXT]  boolean  isEndOfLine(int  c)  throws  IOException  {    [BUGGY]  if  (  c  ==  '\r'  &&  in.read(  )  ==  '\n')  {  [BUGGY]    c  =  in.read();  }  return  (c  ==  '\n'  ||  c  ==  '\r');  }    [CLASS]  Lexer  [METHOD]  isEndOfLine  [RETURN_TYPE]  boolean    int  c  [VARIABLES]  char  commmentStart  delimiter  encapsulator  escape  ExtendedBufferedReader  in  CSVFormat  format  boolean  emptyLinesIgnored  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored  int  c    	[P7_Replace_Invocation]
[PATCH]  if  (  c  ==  '\r'  &&  in.lookAhead  (  )  ==  '\n'  )  {  c  =  in.read  (  )  ;  }	[BUG]  [BUGGY]  c  =  in.read();[CE]  ';'  expected  [CONTEXT]  boolean  isEndOfLine(int  c)  throws  IOException  {    [BUGGY]  c  =  in.read();  [BUGGY]    c  =  in.read();    return  (c  ==  '\n'  ||  c  ==  '\r');    [CLASS]  Lexer  [METHOD]  isEndOfLine  [RETURN_TYPE]  boolean    int  c  [VARIABLES]  char  commmentStart  delimiter  encapsulator  escape  ExtendedBufferedReader  in  CSVFormat  format  boolean  emptyLinesIgnored  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored  int  c    	[P15_Unwrap_Block]
[PATCH]  if  (  c  ==  '\r'  &&  in.lookAhead  (  )  ==  '\n'  )  {  c  =  in.read  (  )  ;  }	[BUG]  [BUGGY]  [CE]  ';'  expected  [CONTEXT]  boolean  isEndOfLine(int  c)  throws  IOException  {    [BUGGY]  [BUGGY]      return  (c  ==  '\n'  ||  c  ==  '\r');    [CLASS]  Lexer  [METHOD]  isEndOfLine  [RETURN_TYPE]  boolean    int  c  [VARIABLES]  char  commmentStart  delimiter  encapsulator  escape  ExtendedBufferedReader  in  CSVFormat  format  boolean  emptyLinesIgnored  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored  int  c    	[P16_Remove_Block]
[PATCH]  c  =  in.read  (  )  ;	[BUG]  [BUGGY]  c  =  in.lookAhead(  )  ;[FE]  expected:<5>  but  was:<10>  testExcelFormat1  assertArrayEquals(res[i],  records.get(i).values());  [CONTEXT]  boolean  isEndOfLine(int  c)  throws  IOException  {    if  (c  ==  '\r'  &&  in.lookAhead()  ==  '\n')  {    [BUGGY]  c  =  in.lookAhead(  )  ;  [BUGGY]  }  return  (c  ==  '\n'  ||  c  ==  '\r');  }    [CLASS]  Lexer  [METHOD]  isEndOfLine  [RETURN_TYPE]  boolean    int  c  [VARIABLES]  char  commmentStart  delimiter  encapsulator  escape  ExtendedBufferedReader  in  CSVFormat  format  boolean  emptyLinesIgnored  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored  int  c    	[P7_Replace_Invocation]
[PATCH]  c  =  in.read  (  )  ;	[BUG]  [BUGGY]  c  =  c  ;[FE]  expected:<5>  but  was:<10>  testExcelFormat1  assertArrayEquals(res[i],  records.get(i).values());  [CONTEXT]  boolean  isEndOfLine(int  c)  throws  IOException  {    if  (c  ==  '\r'  &&  in.lookAhead()  ==  '\n')  {    [BUGGY]  c  =  c  ;  [BUGGY]  }  return  (c  ==  '\n'  ||  c  ==  '\r');  }    [CLASS]  Lexer  [METHOD]  isEndOfLine  [RETURN_TYPE]  boolean    int  c  [VARIABLES]  char  commmentStart  delimiter  encapsulator  escape  ExtendedBufferedReader  in  CSVFormat  format  boolean  emptyLinesIgnored  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored  int  c    	[P8_Replace_Mix]
[PATCH]  return  (  c  ==  '\n'  ||  c  ==  '\r'  )  ;	[BUG]  [BUGGY]  return  (  c  ==  '\n'  &&  c  ==  '\r')  ;[FE]  Token  type  expected:<EORECORD>  but  was:<TOKEN>  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  boolean  isEndOfLine(int  c)  throws  IOException  {    if  (c  ==  '\r'  &&  in.lookAhead()  ==  '\n')  {    c  =  in.read();  }  [BUGGY]  return  (  c  ==  '\n'  &&  c  ==  '\r')  ;  [BUGGY]  }    [CLASS]  Lexer  [METHOD]  isEndOfLine  [RETURN_TYPE]  boolean    int  c  [VARIABLES]  char  commmentStart  delimiter  encapsulator  escape  ExtendedBufferedReader  in  CSVFormat  format  boolean  emptyLinesIgnored  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored  int  c    	[P2_Replace_Operator]
[PATCH]  return  (  c  ==  '\n'  ||  c  ==  '\r'  )  ;	[BUG]  [BUGGY]  return  (  c  !=  '\n'  ||  c  ==  '\r')  ;[FE]  Token  type  expected:<TOKEN>  but  was:<EORECORD>  testNextToken1  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  boolean  isEndOfLine(int  c)  throws  IOException  {    if  (c  ==  '\r'  &&  in.lookAhead()  ==  '\n')  {    c  =  in.read();  }  [BUGGY]  return  (  c  !=  '\n'  ||  c  ==  '\r')  ;  [BUGGY]  }    [CLASS]  Lexer  [METHOD]  isEndOfLine  [RETURN_TYPE]  boolean    int  c  [VARIABLES]  char  commmentStart  delimiter  encapsulator  escape  ExtendedBufferedReader  in  CSVFormat  format  boolean  emptyLinesIgnored  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored  int  c    	[P2_Replace_Operator]
[PATCH]  return  (  c  ==  '\n'  ||  c  ==  '\r'  )  ;	[BUG]  [BUGGY]  return  (  c  ==  '\n'  ||  c  !=  '\r')  ;[FE]  Token  type  expected:<TOKEN>  but  was:<EORECORD>  testNextToken1  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  boolean  isEndOfLine(int  c)  throws  IOException  {    if  (c  ==  '\r'  &&  in.lookAhead()  ==  '\n')  {    c  =  in.read();  }  [BUGGY]  return  (  c  ==  '\n'  ||  c  !=  '\r')  ;  [BUGGY]  }    [CLASS]  Lexer  [METHOD]  isEndOfLine  [RETURN_TYPE]  boolean    int  c  [VARIABLES]  char  commmentStart  delimiter  encapsulator  escape  ExtendedBufferedReader  in  CSVFormat  format  boolean  emptyLinesIgnored  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored  int  c    	[P2_Replace_Operator]
[PATCH]  return  (  c  ==  '\n'  ||  c  ==  '\r'  )  ;	[BUG]  [BUGGY]  return  (  c  ;[CE]  ')'  expected  [CONTEXT]  boolean  isEndOfLine(int  c)  throws  IOException  {    if  (c  ==  '\r'  &&  in.lookAhead()  ==  '\n')  {    c  =  in.read();  }  [BUGGY]  return  (  c  ;  [BUGGY]  }    [CLASS]  Lexer  [METHOD]  isEndOfLine  [RETURN_TYPE]  boolean    int  c  [VARIABLES]  char  commmentStart  delimiter  encapsulator  escape  ExtendedBufferedReader  in  CSVFormat  format  boolean  emptyLinesIgnored  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored  int  c    	[P8_Replace_Mix]
[PATCH]  return  c  ==  ExtendedBufferedReader.END_OF_STREAM;	[BUG]  [BUGGY]  return  c  >=  ExtendedBufferedReader.END_OF_STREAM;[FE]  Token  type  expected:<TOKEN>  but  was:<EOF>  testNextToken1  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  boolean  isEndOfFile(int  c)  {  [BUGGY]  return  c  >=  ExtendedBufferedReader.END_OF_STREAM;  [BUGGY]  }    [CLASS]  Lexer  [METHOD]  isEndOfFile  [RETURN_TYPE]  boolean    int  c  [VARIABLES]  char  commmentStart  delimiter  encapsulator  escape  ExtendedBufferedReader  in  CSVFormat  format  boolean  emptyLinesIgnored  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored  int  c    	[P2_Replace_Operator]
[PATCH]  return  c  ==  ExtendedBufferedReader.END_OF_STREAM;	[BUG]  [BUGGY]  return  c  ||  ExtendedBufferedReader.END_OF_STREAM;[CE]  bad  operand  types  for  binary  operator  '||'  [CONTEXT]  boolean  isEndOfFile(int  c)  {  [BUGGY]  return  c  ||  ExtendedBufferedReader.END_OF_STREAM;  [BUGGY]  }    [CLASS]  Lexer  [METHOD]  isEndOfFile  [RETURN_TYPE]  boolean    int  c  [VARIABLES]  char  commmentStart  delimiter  encapsulator  escape  ExtendedBufferedReader  in  CSVFormat  format  boolean  emptyLinesIgnored  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored  int  c    	[P8_Replace_Mix]
[PATCH]  return  c  ==  delimiter;	[BUG]  [BUGGY]  return  c  <  delimiter;[FE]  Token  content  expected:<abc[]>  but  was:<abc[,def,]>  testNextToken1  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  boolean  isDelimiter(int  c)  {  [BUGGY]  return  c  <  delimiter;  [BUGGY]  }    [CLASS]  Lexer  [METHOD]  isDelimiter  [RETURN_TYPE]  boolean    int  c  [VARIABLES]  char  commmentStart  delimiter  encapsulator  escape  ExtendedBufferedReader  in  CSVFormat  format  boolean  emptyLinesIgnored  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored  int  c    	[P2_Replace_Operator]
[PATCH]  return  c  ==  delimiter;	[BUG]  [BUGGY]  return  c  ==  escape;[FE]  Token  type  expected:<TOKEN>  but  was:<EOF>  testNextToken1  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  boolean  isDelimiter(int  c)  {  [BUGGY]  return  c  ==  escape;  [BUGGY]  }    [CLASS]  Lexer  [METHOD]  isDelimiter  [RETURN_TYPE]  boolean    int  c  [VARIABLES]  char  commmentStart  delimiter  encapsulator  escape  ExtendedBufferedReader  in  CSVFormat  format  boolean  emptyLinesIgnored  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored  int  c    	[P5_Replace_Variable]
[PATCH]  return  c  ==  delimiter;	[BUG]  [BUGGY]  return  c  ||  delimiter;[CE]  bad  operand  types  for  binary  operator  '||'  [CONTEXT]  boolean  isDelimiter(int  c)  {  [BUGGY]  return  c  ||  delimiter;  [BUGGY]  }    [CLASS]  Lexer  [METHOD]  isDelimiter  [RETURN_TYPE]  boolean    int  c  [VARIABLES]  char  commmentStart  delimiter  encapsulator  escape  ExtendedBufferedReader  in  CSVFormat  format  boolean  emptyLinesIgnored  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored  int  c    	[P8_Replace_Mix]
[PATCH]  return  isEscaping  &&  c  ==  escape;	[BUG]  [BUGGY]  return  isEscaping  ||  c  ==  escape;[FE]  null  testBackslashEscaping2  assertTrue(CSVPrinterTest.equals(res,  records));  [CONTEXT]  boolean  isEscape(int  c)  {  [BUGGY]  return  isEscaping  ||  c  ==  escape;  [BUGGY]  }    [CLASS]  Lexer  [METHOD]  isEscape  [RETURN_TYPE]  boolean    int  c  [VARIABLES]  char  commmentStart  delimiter  encapsulator  escape  ExtendedBufferedReader  in  CSVFormat  format  boolean  emptyLinesIgnored  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored  int  c    	[P2_Replace_Operator]
[PATCH]  return  isEscaping  &&  c  ==  escape;	[BUG]  [BUGGY]  return  isEscaping  &&  c  !=  escape;[FE]  null  testBackslashEscaping2  assertTrue(CSVPrinterTest.equals(res,  records));  [CONTEXT]  boolean  isEscape(int  c)  {  [BUGGY]  return  isEscaping  &&  c  !=  escape;  [BUGGY]  }    [CLASS]  Lexer  [METHOD]  isEscape  [RETURN_TYPE]  boolean    int  c  [VARIABLES]  char  commmentStart  delimiter  encapsulator  escape  ExtendedBufferedReader  in  CSVFormat  format  boolean  emptyLinesIgnored  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored  int  c    	[P2_Replace_Operator]
[PATCH]  return  isEscaping  &&  c  ==  escape;	[BUG]  [BUGGY]  return  surroundingSpacesIgnored  &&  c  ==  escape;[FE]  null  testBackslashEscaping2  assertTrue(CSVPrinterTest.equals(res,  records));  [CONTEXT]  boolean  isEscape(int  c)  {  [BUGGY]  return  surroundingSpacesIgnored  &&  c  ==  escape;  [BUGGY]  }    [CLASS]  Lexer  [METHOD]  isEscape  [RETURN_TYPE]  boolean    int  c  [VARIABLES]  char  commmentStart  delimiter  encapsulator  escape  ExtendedBufferedReader  in  CSVFormat  format  boolean  emptyLinesIgnored  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored  int  c    	[P5_Replace_Variable]
[PATCH]  return  isEscaping  &&  c  ==  escape;	[BUG]  [BUGGY]  return  isEscaping  &&  c  ==  encapsulator;[FE]  null  testBackslashEscaping2  assertTrue(CSVPrinterTest.equals(res,  records));  [CONTEXT]  boolean  isEscape(int  c)  {  [BUGGY]  return  isEscaping  &&  c  ==  encapsulator;  [BUGGY]  }    [CLASS]  Lexer  [METHOD]  isEscape  [RETURN_TYPE]  boolean    int  c  [VARIABLES]  char  commmentStart  delimiter  encapsulator  escape  ExtendedBufferedReader  in  CSVFormat  format  boolean  emptyLinesIgnored  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored  int  c    	[P5_Replace_Variable]
[PATCH]  return  isEscaping  &&  c  ==  escape;	[BUG]  [BUGGY]  return  c  &&  isEscaping  ==  escape;[CE]  incomparable  types:  boolean  and  char  [CONTEXT]  boolean  isEscape(int  c)  {  [BUGGY]  return  c  &&  isEscaping  ==  escape;  [BUGGY]  }    [CLASS]  Lexer  [METHOD]  isEscape  [RETURN_TYPE]  boolean    int  c  [VARIABLES]  char  commmentStart  delimiter  encapsulator  escape  ExtendedBufferedReader  in  CSVFormat  format  boolean  emptyLinesIgnored  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored  int  c    	[P5_Replace_Variable]
[PATCH]  return  isEscaping  &&  c  ==  escape;	[BUG]  [BUGGY]  return  escape  &&  c  ==  isEscaping;[CE]  incomparable  types:  int  and  boolean  [CONTEXT]  boolean  isEscape(int  c)  {  [BUGGY]  return  escape  &&  c  ==  isEscaping;  [BUGGY]  }    [CLASS]  Lexer  [METHOD]  isEscape  [RETURN_TYPE]  boolean    int  c  [VARIABLES]  char  commmentStart  delimiter  encapsulator  escape  ExtendedBufferedReader  in  CSVFormat  format  boolean  emptyLinesIgnored  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored  int  c    	[P5_Replace_Variable]
[PATCH]  return  isEscaping  &&  c  ==  escape;	[BUG]  [BUGGY]  return    c  ;[CE]  incompatible  types  [CONTEXT]  boolean  isEscape(int  c)  {  [BUGGY]  return    c  ;  [BUGGY]  }    [CLASS]  Lexer  [METHOD]  isEscape  [RETURN_TYPE]  boolean    int  c  [VARIABLES]  char  commmentStart  delimiter  encapsulator  escape  ExtendedBufferedReader  in  CSVFormat  format  boolean  emptyLinesIgnored  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored  int  c    	[P8_Replace_Mix]
[PATCH]  return  isEncapsulating  &&  c  ==  encapsulator;	[BUG]  [BUGGY]  return  isEncapsulating  ||  c  ==  encapsulator;[FE]  [CONTEXT]  boolean  isEncapsulator(int  c)  {  [BUGGY]  return  isEncapsulating  ||  c  ==  encapsulator;  [BUGGY]  }    [CLASS]  Lexer  [METHOD]  isEncapsulator  [RETURN_TYPE]  boolean    int  c  [VARIABLES]  char  commmentStart  delimiter  encapsulator  escape  ExtendedBufferedReader  in  CSVFormat  format  boolean  emptyLinesIgnored  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored  int  c    	[P2_Replace_Operator]
[PATCH]  return  isEncapsulating  &&  c  ==  encapsulator;	[BUG]  [BUGGY]  return  isEncapsulating  &&  c  <=  encapsulator;[FE]  [CONTEXT]  boolean  isEncapsulator(int  c)  {  [BUGGY]  return  isEncapsulating  &&  c  <=  encapsulator;  [BUGGY]  }    [CLASS]  Lexer  [METHOD]  isEncapsulator  [RETURN_TYPE]  boolean    int  c  [VARIABLES]  char  commmentStart  delimiter  encapsulator  escape  ExtendedBufferedReader  in  CSVFormat  format  boolean  emptyLinesIgnored  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored  int  c    	[P2_Replace_Operator]
[PATCH]  return  isEncapsulating  &&  c  ==  encapsulator;	[BUG]  [BUGGY]  return  surroundingSpacesIgnored  &&  c  ==  encapsulator;[FE]  Token  type  expected:<TOKEN>  but  was:<EORECORD>  testNextToken5  assertTokenEquals(EOF,   "\n\t  \n ",  parser.nextToken(new  Token()));  [CONTEXT]  boolean  isEncapsulator(int  c)  {  [BUGGY]  return  surroundingSpacesIgnored  &&  c  ==  encapsulator;  [BUGGY]  }    [CLASS]  Lexer  [METHOD]  isEncapsulator  [RETURN_TYPE]  boolean    int  c  [VARIABLES]  char  commmentStart  delimiter  encapsulator  escape  ExtendedBufferedReader  in  CSVFormat  format  boolean  emptyLinesIgnored  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored  int  c    	[P5_Replace_Variable]
[PATCH]  return  isEncapsulating  &&  c  ==  encapsulator;	[BUG]  [BUGGY]  return  isEncapsulating  &&  c  ==  escape;[FE]  Token  content  expected:<[foo]>  but  was:<[ "foo "]>  testNextToken4  assertTokenEquals(EOF,   "b ",  parser.nextToken(new  Token()));  [CONTEXT]  boolean  isEncapsulator(int  c)  {  [BUGGY]  return  isEncapsulating  &&  c  ==  escape;  [BUGGY]  }    [CLASS]  Lexer  [METHOD]  isEncapsulator  [RETURN_TYPE]  boolean    int  c  [VARIABLES]  char  commmentStart  delimiter  encapsulator  escape  ExtendedBufferedReader  in  CSVFormat  format  boolean  emptyLinesIgnored  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored  int  c    	[P5_Replace_Variable]
[PATCH]  return  isEncapsulating  &&  c  ==  encapsulator;	[BUG]  [BUGGY]  return  encapsulator  &&  c  ==  isEncapsulating;[CE]  incomparable  types:  int  and  boolean  [CONTEXT]  boolean  isEncapsulator(int  c)  {  [BUGGY]  return  encapsulator  &&  c  ==  isEncapsulating;  [BUGGY]  }    [CLASS]  Lexer  [METHOD]  isEncapsulator  [RETURN_TYPE]  boolean    int  c  [VARIABLES]  char  commmentStart  delimiter  encapsulator  escape  ExtendedBufferedReader  in  CSVFormat  format  boolean  emptyLinesIgnored  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored  int  c    	[P5_Replace_Variable]
[PATCH]  return  isEncapsulating  &&  c  ==  encapsulator;	[BUG]  [BUGGY]  return  isEncapsulating  ||  c  ;[CE]  bad  operand  types  for  binary  operator  '||'  [CONTEXT]  boolean  isEncapsulator(int  c)  {  [BUGGY]  return  isEncapsulating  ||  c  ;  [BUGGY]  }    [CLASS]  Lexer  [METHOD]  isEncapsulator  [RETURN_TYPE]  boolean    int  c  [VARIABLES]  char  commmentStart  delimiter  encapsulator  escape  ExtendedBufferedReader  in  CSVFormat  format  boolean  emptyLinesIgnored  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored  int  c    	[P8_Replace_Mix]
[PATCH]  return  isCommentEnabled  &&  c  ==  commmentStart;	[BUG]  [BUGGY]  return  isCommentEnabled  ||  c  ==  commmentStart;[FE]  Token  type  expected:<TOKEN>  but  was:<EOF>  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  boolean  isCommentStart(int  c)  {  [BUGGY]  return  isCommentEnabled  ||  c  ==  commmentStart;  [BUGGY]  }    [CLASS]  Lexer  [METHOD]  isCommentStart  [RETURN_TYPE]  boolean    int  c  [VARIABLES]  char  commmentStart  delimiter  encapsulator  escape  ExtendedBufferedReader  in  CSVFormat  format  boolean  emptyLinesIgnored  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored  int  c    	[P2_Replace_Operator]
[PATCH]  return  isCommentEnabled  &&  c  ==  commmentStart;	[BUG]  [BUGGY]  return  isCommentEnabled  &&  c  <  commmentStart;[FE]  Token  content  expected:<[]>  but  was:<[#foo]>  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  boolean  isCommentStart(int  c)  {  [BUGGY]  return  isCommentEnabled  &&  c  <  commmentStart;  [BUGGY]  }    [CLASS]  Lexer  [METHOD]  isCommentStart  [RETURN_TYPE]  boolean    int  c  [VARIABLES]  char  commmentStart  delimiter  encapsulator  escape  ExtendedBufferedReader  in  CSVFormat  format  boolean  emptyLinesIgnored  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored  int  c    	[P2_Replace_Operator]
[PATCH]  return  isCommentEnabled  &&  c  ==  commmentStart;	[BUG]  [BUGGY]  return  surroundingSpacesIgnored  &&  c  ==  commmentStart;[FE]  Token  content  expected:<[]>  but  was:<[#foo]>  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  boolean  isCommentStart(int  c)  {  [BUGGY]  return  surroundingSpacesIgnored  &&  c  ==  commmentStart;  [BUGGY]  }    [CLASS]  Lexer  [METHOD]  isCommentStart  [RETURN_TYPE]  boolean    int  c  [VARIABLES]  char  commmentStart  delimiter  encapsulator  escape  ExtendedBufferedReader  in  CSVFormat  format  boolean  emptyLinesIgnored  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored  int  c    	[P5_Replace_Variable]
[PATCH]  return  isCommentEnabled  &&  c  ==  commmentStart;	[BUG]  [BUGGY]  return  isCommentEnabled  &&  c  ==  escape;[FE]  Token  content  expected:<[]>  but  was:<[#foo]>  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  boolean  isCommentStart(int  c)  {  [BUGGY]  return  isCommentEnabled  &&  c  ==  escape;  [BUGGY]  }    [CLASS]  Lexer  [METHOD]  isCommentStart  [RETURN_TYPE]  boolean    int  c  [VARIABLES]  char  commmentStart  delimiter  encapsulator  escape  ExtendedBufferedReader  in  CSVFormat  format  boolean  emptyLinesIgnored  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored  int  c    	[P5_Replace_Variable]
[PATCH]  return  isCommentEnabled  &&  c  ==  commmentStart;	[BUG]  [BUGGY]  return  commmentStart  &&  c  ==  isCommentEnabled;[CE]  incomparable  types:  int  and  boolean  [CONTEXT]  boolean  isCommentStart(int  c)  {  [BUGGY]  return  commmentStart  &&  c  ==  isCommentEnabled;  [BUGGY]  }    [CLASS]  Lexer  [METHOD]  isCommentStart  [RETURN_TYPE]  boolean    int  c  [VARIABLES]  char  commmentStart  delimiter  encapsulator  escape  ExtendedBufferedReader  in  CSVFormat  format  boolean  emptyLinesIgnored  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored  int  c    	[P5_Replace_Variable]
[PATCH]  return  isCommentEnabled  &&  c  ==  commmentStart;	[BUG]  [BUGGY]  return  isCommentEnabled  ||  c  ;[CE]  bad  operand  types  for  binary  operator  '||'  [CONTEXT]  boolean  isCommentStart(int  c)  {  [BUGGY]  return  isCommentEnabled  ||  c  ;  [BUGGY]  }    [CLASS]  Lexer  [METHOD]  isCommentStart  [RETURN_TYPE]  boolean    int  c  [VARIABLES]  char  commmentStart  delimiter  encapsulator  escape  ExtendedBufferedReader  in  CSVFormat  format  boolean  emptyLinesIgnored  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored  int  c    	[P8_Replace_Mix]
[PATCH]  private  static  final  String  CRLF  =   "\r\n ";	[BUG]  [BUGGY]  private  static  final  char  CRLF  =   "\r\n ";[CE]  incompatible  types  [CONTEXT]      public  class  CSVFormat  implements  Serializable  {    [BUGGY]  private  static  final  char  CRLF  =   "\r\n ";  [BUGGY]    private  final  char  delimiter;  private  final  char  encapsulator;  private  final  char  commentStart;  private  final  char  escape;    [CLASS]  CSVFormat    [VARIABLES]  	[P1_Replace_Type]
[PATCH]  private  static  final  String  CRLF  =   "\r\n ";	[BUG]  [BUGGY]  private  static  final  String  CRLF  =   "\r\nr ";[FE]  expected:<[]>  but  was:<[r]>  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]      public  class  CSVFormat  implements  Serializable  {    [BUGGY]  private  static  final  String  CRLF  =   "\r\nr ";  [BUGGY]    private  final  char  delimiter;  private  final  char  encapsulator;  private  final  char  commentStart;  private  final  char  escape;    [CLASS]  CSVFormat    [VARIABLES]  	[P3_Replace_Literal]
[PATCH]  private  final  char  delimiter;	[BUG]  [BUGGY]  private  final  String  delimiter;[CE]  incompatible  types  [CONTEXT]  public  class  CSVFormat  implements  Serializable  {    private  static  final  String  CRLF  =   "\r\n ";  [BUGGY]  private  final  String  delimiter;  [BUGGY]  private  final  char  encapsulator;  private  final  char  commentStart;  private  final  char  escape;  private  final  boolean  surroundingSpacesIgnored;  //  Should  leading/trailing  spaces  be  ignored  around  values?  private  final  boolean  emptyLinesIgnored;    [CLASS]  CSVFormat    [VARIABLES]  	[P1_Replace_Type]
[PATCH]  private  final  char  delimiter;	[BUG]  [BUGGY]  private  final  int  delimiter;[CE]  possible  loss  of  precision  [CONTEXT]  public  class  CSVFormat  implements  Serializable  {    private  static  final  String  CRLF  =   "\r\n ";  [BUGGY]  private  final  int  delimiter;  [BUGGY]  private  final  char  encapsulator;  private  final  char  commentStart;  private  final  char  escape;  private  final  boolean  surroundingSpacesIgnored;  //  Should  leading/trailing  spaces  be  ignored  around  values?  private  final  boolean  emptyLinesIgnored;    [CLASS]  CSVFormat    [VARIABLES]  	[P8_Replace_Mix]
[PATCH]  private  final  char  encapsulator;	[BUG]  [BUGGY]  private  final  int  encapsulator;[CE]  constructor  CSVFormat  in  class  CSVFormat  cannot  be  applied  to  given  types;  [CONTEXT]    private  static  final  String  CRLF  =   "\r\n ";  private  final  char  delimiter;  [BUGGY]  private  final  int  encapsulator;  [BUGGY]  private  final  char  commentStart;  private  final  char  escape;  private  final  boolean  surroundingSpacesIgnored;  //  Should  leading/trailing  spaces  be  ignored  around  values?  private  final  boolean  emptyLinesIgnored;  private  final  String  lineSeparator;  //  for  outputs    [CLASS]  CSVFormat    [VARIABLES]  	[P1_Replace_Type]
[PATCH]  private  final  char  commentStart;	[BUG]  [BUGGY]  private  final  int  commentStart;[CE]  constructor  CSVFormat  in  class  CSVFormat  cannot  be  applied  to  given  types;  [CONTEXT]    private  static  final  String  CRLF  =   "\r\n ";  private  final  char  delimiter;  private  final  char  encapsulator;  [BUGGY]  private  final  int  commentStart;  [BUGGY]  private  final  char  escape;  private  final  boolean  surroundingSpacesIgnored;  //  Should  leading/trailing  spaces  be  ignored  around  values?  private  final  boolean  emptyLinesIgnored;  private  final  String  lineSeparator;  //  for  outputs  private  final  String[]  header;    [CLASS]  CSVFormat    [VARIABLES]  	[P1_Replace_Type]
[PATCH]  private  final  char  commentStart;	[BUG]  [BUGGY]  private  final  String  commentStart;[CE]  incompatible  types  [CONTEXT]    private  static  final  String  CRLF  =   "\r\n ";  private  final  char  delimiter;  private  final  char  encapsulator;  [BUGGY]  private  final  String  commentStart;  [BUGGY]  private  final  char  escape;  private  final  boolean  surroundingSpacesIgnored;  //  Should  leading/trailing  spaces  be  ignored  around  values?  private  final  boolean  emptyLinesIgnored;  private  final  String  lineSeparator;  //  for  outputs  private  final  String[]  header;    [CLASS]  CSVFormat    [VARIABLES]  	[P8_Replace_Mix]
[PATCH]  private  final  char  escape;	[BUG]  [BUGGY]  private  final  int  escape;[CE]  constructor  CSVFormat  in  class  CSVFormat  cannot  be  applied  to  given  types;  [CONTEXT]  private  static  final  String  CRLF  =   "\r\n ";  private  final  char  delimiter;  private  final  char  encapsulator;  private  final  char  commentStart;  [BUGGY]  private  final  int  escape;  [BUGGY]  private  final  boolean  surroundingSpacesIgnored;  //  Should  leading/trailing  spaces  be  ignored  around  values?  private  final  boolean  emptyLinesIgnored;  private  final  String  lineSeparator;  //  for  outputs  private  final  String[]  header;      [CLASS]  CSVFormat    [VARIABLES]  	[P1_Replace_Type]
[PATCH]  private  final  char  escape;	[BUG]  [BUGGY]  private  final  String  escape;[CE]  incompatible  types  [CONTEXT]  private  static  final  String  CRLF  =   "\r\n ";  private  final  char  delimiter;  private  final  char  encapsulator;  private  final  char  commentStart;  [BUGGY]  private  final  String  escape;  [BUGGY]  private  final  boolean  surroundingSpacesIgnored;  //  Should  leading/trailing  spaces  be  ignored  around  values?  private  final  boolean  emptyLinesIgnored;  private  final  String  lineSeparator;  //  for  outputs  private  final  String[]  header;      [CLASS]  CSVFormat    [VARIABLES]  	[P8_Replace_Mix]
[PATCH]  private  final  String  lineSeparator;	[BUG]  [BUGGY]  private  final  char  lineSeparator;[CE]  incompatible  types  [CONTEXT]  private  final  char  encapsulator;  private  final  char  commentStart;  private  final  char  escape;  private  final  boolean  surroundingSpacesIgnored;  //  Should  leading/trailing  spaces  be  ignored  around  values?  private  final  boolean  emptyLinesIgnored;  [BUGGY]  private  final  char  lineSeparator;  [BUGGY]  private  final  String[]  header;          [CLASS]  CSVFormat    [VARIABLES]  	[P1_Replace_Type]
[PATCH]  static  final  char  DISABLED  =  '\ufffe';	[BUG]  [BUGGY]  static  final  int  DISABLED  =  '\ufffe';[CE]  constructor  CSVFormat  in  class  CSVFormat  cannot  be  applied  to  given  types;  [CONTEXT]            [BUGGY]  static  final  int  DISABLED  =  '\ufffe';  [BUGGY]          private  static  CSVFormat  PRISTINE  =  new  CSVFormat(DISABLED,  DISABLED,  DISABLED,  DISABLED,  false,  false,  null,  null);    [CLASS]  CSVFormat    [VARIABLES]  	[P1_Replace_Type]
[PATCH]  private  static  CSVFormat  PRISTINE  =  new  CSVFormat  (  DISABLED,  DISABLED,  DISABLED,  DISABLED,  false,  false,  null,  null  )  ;	[BUG]  [BUGGY]  private  static  CSVFormat  PRISTINE  =  new  CSVFormat(  DISABLED,  DISABLED,  DISABLED,  DISABLED,  true,  true,  null,  null)  ;[FE]  expected:<5>  but  was:<4>  testExcelFormat1  assertArrayEquals(res[i],  records.get(i).values());  [CONTEXT]  static  final  char  DISABLED  =  '\ufffe';        [BUGGY]  private  static  CSVFormat  PRISTINE  =  new  CSVFormat(  DISABLED,  DISABLED,  DISABLED,  DISABLED,  true,  true,  null,  null)  ;  [BUGGY]              [CLASS]  CSVFormat    [VARIABLES]  	[P3_Replace_Literal]
[PATCH]  private  static  CSVFormat  PRISTINE  =  new  CSVFormat  (  DISABLED,  DISABLED,  DISABLED,  DISABLED,  false,  false,  null,  null  )  ;	[BUG]  [BUGGY]  private  static  CSVFormat  PRISTINE  ;[FE]  null  testSerialization  assertEquals( "empty  lines ",  CSVFormat.DEFAULT.isEmptyLinesIgnored(),  format.isEmptyLinesIgnored());  [CONTEXT]  static  final  char  DISABLED  =  '\ufffe';        [BUGGY]  private  static  CSVFormat  PRISTINE  ;  [BUGGY]              [CLASS]  CSVFormat    [VARIABLES]  	[P8_Replace_Mix]
[PATCH]  public  static  final  CSVFormat  DEFAULT  =  PRISTINE.  withDelimiter  (  ','  )  .withEncapsulator  (  ' "'  )	[BUG]  [BUGGY]  public  static  final  CSVFormat  DEFAULT  =  PRISTINE.  withEscape(  ',').withEncapsulator(  ' "')[FE]  The  encapsulator  character  and  the  delimiter  cannot  be  the  same  ( "  testValidation  [CONTEXT]  [BUGGY]  public  static  final  CSVFormat  DEFAULT  =  PRISTINE.  withEscape(  ',').withEncapsulator(  ' "')  [BUGGY]      .withEmptyLinesIgnored(true)  .withLineSeparator(CRLF);    [CLASS]  CSVFormat    [VARIABLES]  	[P7_Replace_Invocation]
[PATCH]  public  static  final  CSVFormat  RFC4180  =  PRISTINE.  withDelimiter  (  ','  )  .withEncapsulator  (  ' "'  )	[BUG]  [BUGGY]  public  final  CSVFormat  RFC4180  =  PRISTINE.  withDelimiter(  ',').withEncapsulator(  ' "')[FE]  null  testSerialization  assertEquals( "empty  lines ",  CSVFormat.DEFAULT.isEmptyLinesIgnored(),  format.isEmptyLinesIgnored());  [CONTEXT]  [BUGGY]  public  final  CSVFormat  RFC4180  =  PRISTINE.  withDelimiter(  ',').withEncapsulator(  ' "')  [BUGGY]      .withLineSeparator(CRLF);    [CLASS]  CSVFormat    [VARIABLES]  	[P8_Replace_Mix]
[PATCH]  public  static  final  CSVFormat  EXCEL  =  PRISTINE  .withDelimiter  (  ','  )  .withEncapsulator  (  ' "'  )	[BUG]  [BUGGY]  public  static  final  CSVFormat  EXCEL  =  PRISTINE.withEscape(  ',').withEncapsulator(  ' "')[FE]  The  comment  start  character  and  the  delimiter  cannot  be  the  same  ( "  testExcelFormat1  assertArrayEquals(res[i],  records.get(i).values());  [CONTEXT]  [BUGGY]  public  static  final  CSVFormat  EXCEL  =  PRISTINE.withEscape(  ',').withEncapsulator(  ' "')  [BUGGY]      .withLineSeparator(CRLF);    [CLASS]  CSVFormat    [VARIABLES]  	[P7_Replace_Invocation]
[PATCH]  public  static  final  CSVFormat  EXCEL  =  PRISTINE  .withDelimiter  (  ','  )  .withEncapsulator  (  ' "'  )	[BUG]  [BUGGY]  public  final  CSVFormat  EXCEL  =  PRISTINE.withDelimiter(  ',').withEncapsulator(  ' "')[FE]  null  testSerialization  assertEquals( "empty  lines ",  CSVFormat.DEFAULT.isEmptyLinesIgnored(),  format.isEmptyLinesIgnored());  [CONTEXT]  [BUGGY]  public  final  CSVFormat  EXCEL  =  PRISTINE.withDelimiter(  ',').withEncapsulator(  ' "')  [BUGGY]      .withLineSeparator(CRLF);    [CLASS]  CSVFormat    [VARIABLES]  	[P8_Replace_Mix]
[PATCH]  public  static  final  CSVFormat  TDF  =  PRISTINE  .withDelimiter  (  '\t'  )  .withEncapsulator  (  ' "'  )	[BUG]  [BUGGY]  public  static  final  CSVFormat  TDF  =  PRISTINE.withEscape(  '\t').withEncapsulator(  ' "')[FE]  Token  type  expected:<TOKEN>  but  was:<EOF>  testDelimiterIsWhitespace  assertTokenEquals(EOF,   "six ",  parser.nextToken(new  Token()));  [CONTEXT]  [BUGGY]  public  static  final  CSVFormat  TDF  =  PRISTINE.withEscape(  '\t').withEncapsulator(  ' "')  [BUGGY]      .withSurroundingSpacesIgnored(true)  .withEmptyLinesIgnored(true)  .withLineSeparator(CRLF);    [CLASS]  CSVFormat    [VARIABLES]  	[P7_Replace_Invocation]
[PATCH]  public  static  final  CSVFormat  TDF  =  PRISTINE  .withDelimiter  (  '\t'  )  .withEncapsulator  (  ' "'  )	[BUG]  [BUGGY]  public  static  final  CSVFormat  TDF  =  null  ;[CE]  illegal  start  of  type  [CONTEXT]  [BUGGY]  public  static  final  CSVFormat  TDF  =  null  ;  [BUGGY]      .withSurroundingSpacesIgnored(true)  .withEmptyLinesIgnored(true)  .withLineSeparator(CRLF);    [CLASS]  CSVFormat    [VARIABLES]  	[P8_Replace_Mix]
[PATCH]  public  static  final  CSVFormat  MYSQL  =  PRISTINE  .withDelimiter  (  '\t'  )  .withEscape  (  '\\'  )	[BUG]  [BUGGY]  public  static  final  CSVFormat  MYSQL  =  PRISTINE.withEscape(  '\t').withEscape(  '\\')[FE]  The  encapsulator  character  and  the  delimiter  cannot  be  the  same  ( "  testRandom  [CONTEXT]  [BUGGY]  public  static  final  CSVFormat  MYSQL  =  PRISTINE.withEscape(  '\t').withEscape(  '\\')  [BUGGY]      .withLineSeparator( "\n ");    [CLASS]  CSVFormat    [VARIABLES]  	[P7_Replace_Invocation]
[PATCH]  this.delimiter  =  delimiter;	[BUG]  [BUGGY]  this.delimiter  =  encapsulator;[FE]  The  encapsulator  character  and  the  delimiter  cannot  be  the  same  ( "  testValidation  [CONTEXT]  CSVFormat(  char  delimiter,  char  encapsulator,  char  commentStart,  char  escape,  boolean  surroundingSpacesIgnored,  boolean  emptyLinesIgnored,  String  lineSeparator,  String[]  header)  {  [BUGGY]  this.delimiter  =  encapsulator;  [BUGGY]  this.encapsulator  =  encapsulator;  this.commentStart  =  commentStart;  this.escape  =  escape;  this.surroundingSpacesIgnored  =  surroundingSpacesIgnored;  this.emptyLinesIgnored  =  emptyLinesIgnored;  this.lineSeparator  =  lineSeparator;  this.header  =  header;  }    [CLASS]  CSVFormat  [METHOD]  <init>  [RETURN_TYPE]  String[])    char  delimiter  char  encapsulator  char  commentStart  char  escape  boolean  surroundingSpacesIgnored  boolean  emptyLinesIgnored  String  lineSeparator  String[]  header  [VARIABLES]  char  DISABLED  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  this.delimiter  =  delimiter;	[BUG]  [BUGGY]  this.delimiter  =  escape;[FE]  The  encapsulator  character  and  the  delimiter  cannot  be  the  same  ( "  testValidation  [CONTEXT]  CSVFormat(  char  delimiter,  char  encapsulator,  char  commentStart,  char  escape,  boolean  surroundingSpacesIgnored,  boolean  emptyLinesIgnored,  String  lineSeparator,  String[]  header)  {  [BUGGY]  this.delimiter  =  escape;  [BUGGY]  this.encapsulator  =  encapsulator;  this.commentStart  =  commentStart;  this.escape  =  escape;  this.surroundingSpacesIgnored  =  surroundingSpacesIgnored;  this.emptyLinesIgnored  =  emptyLinesIgnored;  this.lineSeparator  =  lineSeparator;  this.header  =  header;  }    [CLASS]  CSVFormat  [METHOD]  <init>  [RETURN_TYPE]  String[])    char  delimiter  char  encapsulator  char  commentStart  char  escape  boolean  surroundingSpacesIgnored  boolean  emptyLinesIgnored  String  lineSeparator  String[]  header  [VARIABLES]  char  DISABLED  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P8_Replace_Mix]
[PATCH]  this.delimiter  =  delimiter;	[BUG]  [BUGGY]  this.header  =  header;this.delimiter  =  delimiter;[CE]  variable  header  might  already  have  been  assigned  [CONTEXT]  CSVFormat(  char  delimiter,  char  encapsulator,  char  commentStart,  char  escape,  boolean  surroundingSpacesIgnored,  boolean  emptyLinesIgnored,  String  lineSeparator,  String[]  header)  {  [BUGGY]  this.header  =  header;this.delimiter  =  delimiter;  [BUGGY]  this.encapsulator  =  encapsulator;  this.commentStart  =  commentStart;  this.escape  =  escape;  this.surroundingSpacesIgnored  =  surroundingSpacesIgnored;  this.emptyLinesIgnored  =  emptyLinesIgnored;  this.lineSeparator  =  lineSeparator;  this.header  =  header;  }    [CLASS]  CSVFormat  [METHOD]  <init>  [RETURN_TYPE]  String[])    char  delimiter  char  encapsulator  char  commentStart  char  escape  boolean  surroundingSpacesIgnored  boolean  emptyLinesIgnored  String  lineSeparator  String[]  header  [VARIABLES]  char  DISABLED  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P11_Insert_Donor_Statement]
[PATCH]  this.encapsulator  =  encapsulator;	[BUG]  [BUGGY]  this.encapsulator  =  escape;[FE]  null  testValidation  [CONTEXT]  CSVFormat(  char  delimiter,  char  encapsulator,  char  commentStart,  char  escape,  boolean  surroundingSpacesIgnored,  boolean  emptyLinesIgnored,  String  lineSeparator,  String[]  header)  {  this.delimiter  =  delimiter;  [BUGGY]  this.encapsulator  =  escape;  [BUGGY]  this.commentStart  =  commentStart;  this.escape  =  escape;  this.surroundingSpacesIgnored  =  surroundingSpacesIgnored;  this.emptyLinesIgnored  =  emptyLinesIgnored;  this.lineSeparator  =  lineSeparator;  this.header  =  header;  }    [CLASS]  CSVFormat  [METHOD]  <init>  [RETURN_TYPE]  String[])    char  delimiter  char  encapsulator  char  commentStart  char  escape  boolean  surroundingSpacesIgnored  boolean  emptyLinesIgnored  String  lineSeparator  String[]  header  [VARIABLES]  char  DISABLED  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  this.encapsulator  =  encapsulator;	[BUG]  [BUGGY]  this.escape  =  escape;this.encapsulator  =  encapsulator;[CE]  variable  escape  might  already  have  been  assigned  [CONTEXT]  CSVFormat(  char  delimiter,  char  encapsulator,  char  commentStart,  char  escape,  boolean  surroundingSpacesIgnored,  boolean  emptyLinesIgnored,  String  lineSeparator,  String[]  header)  {  this.delimiter  =  delimiter;  [BUGGY]  this.escape  =  escape;this.encapsulator  =  encapsulator;  [BUGGY]  this.commentStart  =  commentStart;  this.escape  =  escape;  this.surroundingSpacesIgnored  =  surroundingSpacesIgnored;  this.emptyLinesIgnored  =  emptyLinesIgnored;  this.lineSeparator  =  lineSeparator;  this.header  =  header;  }    [CLASS]  CSVFormat  [METHOD]  <init>  [RETURN_TYPE]  String[])    char  delimiter  char  encapsulator  char  commentStart  char  escape  boolean  surroundingSpacesIgnored  boolean  emptyLinesIgnored  String  lineSeparator  String[]  header  [VARIABLES]  char  DISABLED  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P11_Insert_Donor_Statement]
[PATCH]  this.encapsulator  =  encapsulator;	[BUG]  [BUGGY]  this.lineSeparator  =  lineSeparator;this.encapsulator  =  encapsulator;[CE]  variable  lineSeparator  might  already  have  been  assigned  [CONTEXT]  CSVFormat(  char  delimiter,  char  encapsulator,  char  commentStart,  char  escape,  boolean  surroundingSpacesIgnored,  boolean  emptyLinesIgnored,  String  lineSeparator,  String[]  header)  {  this.delimiter  =  delimiter;  [BUGGY]  this.lineSeparator  =  lineSeparator;this.encapsulator  =  encapsulator;  [BUGGY]  this.commentStart  =  commentStart;  this.escape  =  escape;  this.surroundingSpacesIgnored  =  surroundingSpacesIgnored;  this.emptyLinesIgnored  =  emptyLinesIgnored;  this.lineSeparator  =  lineSeparator;  this.header  =  header;  }    [CLASS]  CSVFormat  [METHOD]  <init>  [RETURN_TYPE]  String[])    char  delimiter  char  encapsulator  char  commentStart  char  escape  boolean  surroundingSpacesIgnored  boolean  emptyLinesIgnored  String  lineSeparator  String[]  header  [VARIABLES]  char  DISABLED  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P11_Insert_Donor_Statement]
[PATCH]  this.commentStart  =  commentStart;	[BUG]  [BUGGY]  this.commentStart  =  escape;[FE]  null  testValidation  [CONTEXT]  CSVFormat(  char  delimiter,  char  encapsulator,  char  commentStart,  char  escape,  boolean  surroundingSpacesIgnored,  boolean  emptyLinesIgnored,  String  lineSeparator,  String[]  header)  {  this.delimiter  =  delimiter;  this.encapsulator  =  encapsulator;  [BUGGY]  this.commentStart  =  escape;  [BUGGY]  this.escape  =  escape;  this.surroundingSpacesIgnored  =  surroundingSpacesIgnored;  this.emptyLinesIgnored  =  emptyLinesIgnored;  this.lineSeparator  =  lineSeparator;  this.header  =  header;  }    [CLASS]  CSVFormat  [METHOD]  <init>  [RETURN_TYPE]  String[])    char  delimiter  char  encapsulator  char  commentStart  char  escape  boolean  surroundingSpacesIgnored  boolean  emptyLinesIgnored  String  lineSeparator  String[]  header  [VARIABLES]  char  DISABLED  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  this.escape  =  escape;	[BUG]  [BUGGY]  this.escape  =  encapsulator;[FE]  null  testValidation  [CONTEXT]  CSVFormat(  char  delimiter,  char  encapsulator,  char  commentStart,  char  escape,  boolean  surroundingSpacesIgnored,  boolean  emptyLinesIgnored,  String  lineSeparator,  String[]  header)  {  this.delimiter  =  delimiter;  this.encapsulator  =  encapsulator;  this.commentStart  =  commentStart;  [BUGGY]  this.escape  =  encapsulator;  [BUGGY]  this.surroundingSpacesIgnored  =  surroundingSpacesIgnored;  this.emptyLinesIgnored  =  emptyLinesIgnored;  this.lineSeparator  =  lineSeparator;  this.header  =  header;  }    [CLASS]  CSVFormat  [METHOD]  <init>  [RETURN_TYPE]  String[])    char  delimiter  char  encapsulator  char  commentStart  char  escape  boolean  surroundingSpacesIgnored  boolean  emptyLinesIgnored  String  lineSeparator  String[]  header  [VARIABLES]  char  DISABLED  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  this.escape  =  escape;	[BUG]  [BUGGY]  this.encapsulator  =  encapsulator;this.escape  =  escape;[CE]  variable  encapsulator  might  already  have  been  assigned  [CONTEXT]  CSVFormat(  char  delimiter,  char  encapsulator,  char  commentStart,  char  escape,  boolean  surroundingSpacesIgnored,  boolean  emptyLinesIgnored,  String  lineSeparator,  String[]  header)  {  this.delimiter  =  delimiter;  this.encapsulator  =  encapsulator;  this.commentStart  =  commentStart;  [BUGGY]  this.encapsulator  =  encapsulator;this.escape  =  escape;  [BUGGY]  this.surroundingSpacesIgnored  =  surroundingSpacesIgnored;  this.emptyLinesIgnored  =  emptyLinesIgnored;  this.lineSeparator  =  lineSeparator;  this.header  =  header;  }    [CLASS]  CSVFormat  [METHOD]  <init>  [RETURN_TYPE]  String[])    char  delimiter  char  encapsulator  char  commentStart  char  escape  boolean  surroundingSpacesIgnored  boolean  emptyLinesIgnored  String  lineSeparator  String[]  header  [VARIABLES]  char  DISABLED  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P11_Insert_Donor_Statement]
[PATCH]  this.escape  =  escape;	[BUG]  [BUGGY]  this.header  =  header;this.escape  =  escape;[CE]  variable  header  might  already  have  been  assigned  [CONTEXT]  CSVFormat(  char  delimiter,  char  encapsulator,  char  commentStart,  char  escape,  boolean  surroundingSpacesIgnored,  boolean  emptyLinesIgnored,  String  lineSeparator,  String[]  header)  {  this.delimiter  =  delimiter;  this.encapsulator  =  encapsulator;  this.commentStart  =  commentStart;  [BUGGY]  this.header  =  header;this.escape  =  escape;  [BUGGY]  this.surroundingSpacesIgnored  =  surroundingSpacesIgnored;  this.emptyLinesIgnored  =  emptyLinesIgnored;  this.lineSeparator  =  lineSeparator;  this.header  =  header;  }    [CLASS]  CSVFormat  [METHOD]  <init>  [RETURN_TYPE]  String[])    char  delimiter  char  encapsulator  char  commentStart  char  escape  boolean  surroundingSpacesIgnored  boolean  emptyLinesIgnored  String  lineSeparator  String[]  header  [VARIABLES]  char  DISABLED  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P11_Insert_Donor_Statement]
[PATCH]  this.surroundingSpacesIgnored  =  surroundingSpacesIgnored;	[BUG]  [BUGGY]  this.surroundingSpacesIgnored  =  emptyLinesIgnored;[FE]  null  testMutators  assertFalse(format.withEmptyLinesIgnored(false).isEmptyLinesIgnored());  [CONTEXT]  CSVFormat(  char  delimiter,  char  encapsulator,  char  commentStart,  char  escape,  boolean  surroundingSpacesIgnored,  boolean  emptyLinesIgnored,  String  lineSeparator,  String[]  header)  {  this.delimiter  =  delimiter;  this.encapsulator  =  encapsulator;  this.commentStart  =  commentStart;  this.escape  =  escape;  [BUGGY]  this.surroundingSpacesIgnored  =  emptyLinesIgnored;  [BUGGY]  this.emptyLinesIgnored  =  emptyLinesIgnored;  this.lineSeparator  =  lineSeparator;  this.header  =  header;  }    [CLASS]  CSVFormat  [METHOD]  <init>  [RETURN_TYPE]  String[])    char  delimiter  char  encapsulator  char  commentStart  char  escape  boolean  surroundingSpacesIgnored  boolean  emptyLinesIgnored  String  lineSeparator  String[]  header  [VARIABLES]  char  DISABLED  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  this.surroundingSpacesIgnored  =  surroundingSpacesIgnored;	[BUG]  [BUGGY]  this.emptyLinesIgnored  =  emptyLinesIgnored;this.surroundingSpacesIgnored  =  surroundingSpacesIgnored;[CE]  variable  emptyLinesIgnored  might  already  have  been  assigned  [CONTEXT]  CSVFormat(  char  delimiter,  char  encapsulator,  char  commentStart,  char  escape,  boolean  surroundingSpacesIgnored,  boolean  emptyLinesIgnored,  String  lineSeparator,  String[]  header)  {  this.delimiter  =  delimiter;  this.encapsulator  =  encapsulator;  this.commentStart  =  commentStart;  this.escape  =  escape;  [BUGGY]  this.emptyLinesIgnored  =  emptyLinesIgnored;this.surroundingSpacesIgnored  =  surroundingSpacesIgnored;  [BUGGY]  this.emptyLinesIgnored  =  emptyLinesIgnored;  this.lineSeparator  =  lineSeparator;  this.header  =  header;  }    [CLASS]  CSVFormat  [METHOD]  <init>  [RETURN_TYPE]  String[])    char  delimiter  char  encapsulator  char  commentStart  char  escape  boolean  surroundingSpacesIgnored  boolean  emptyLinesIgnored  String  lineSeparator  String[]  header  [VARIABLES]  char  DISABLED  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P11_Insert_Donor_Statement]
[PATCH]  this.emptyLinesIgnored  =  emptyLinesIgnored;	[BUG]  [BUGGY]  this.emptyLinesIgnored  =  surroundingSpacesIgnored;[FE]  null  testMutators  assertFalse(format.withEmptyLinesIgnored(false).isEmptyLinesIgnored());  [CONTEXT]  CSVFormat(  char  delimiter,  char  encapsulator,  char  commentStart,  char  escape,  boolean  surroundingSpacesIgnored,  boolean  emptyLinesIgnored,  String  lineSeparator,  String[]  header)  {  this.delimiter  =  delimiter;  this.encapsulator  =  encapsulator;  this.commentStart  =  commentStart;  this.escape  =  escape;  this.surroundingSpacesIgnored  =  surroundingSpacesIgnored;  [BUGGY]  this.emptyLinesIgnored  =  surroundingSpacesIgnored;  [BUGGY]  this.lineSeparator  =  lineSeparator;  this.header  =  header;  }    [CLASS]  CSVFormat  [METHOD]  <init>  [RETURN_TYPE]  String[])    char  delimiter  char  encapsulator  char  commentStart  char  escape  boolean  surroundingSpacesIgnored  boolean  emptyLinesIgnored  String  lineSeparator  String[]  header  [VARIABLES]  char  DISABLED  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  this.emptyLinesIgnored  =  emptyLinesIgnored;	[BUG]  [BUGGY]  this.surroundingSpacesIgnored  =  surroundingSpacesIgnored;this.emptyLinesIgnored  =  emptyLinesIgnored;[CE]  variable  surroundingSpacesIgnored  might  already  have  been  assigned  [CONTEXT]  CSVFormat(  char  delimiter,  char  encapsulator,  char  commentStart,  char  escape,  boolean  surroundingSpacesIgnored,  boolean  emptyLinesIgnored,  String  lineSeparator,  String[]  header)  {  this.delimiter  =  delimiter;  this.encapsulator  =  encapsulator;  this.commentStart  =  commentStart;  this.escape  =  escape;  this.surroundingSpacesIgnored  =  surroundingSpacesIgnored;  [BUGGY]  this.surroundingSpacesIgnored  =  surroundingSpacesIgnored;this.emptyLinesIgnored  =  emptyLinesIgnored;  [BUGGY]  this.lineSeparator  =  lineSeparator;  this.header  =  header;  }    [CLASS]  CSVFormat  [METHOD]  <init>  [RETURN_TYPE]  String[])    char  delimiter  char  encapsulator  char  commentStart  char  escape  boolean  surroundingSpacesIgnored  boolean  emptyLinesIgnored  String  lineSeparator  String[]  header  [VARIABLES]  char  DISABLED  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P11_Insert_Donor_Statement]
[PATCH]  this.lineSeparator  =  lineSeparator;	[BUG]  [BUGGY]  this.lineSeparator  =  CRLF;[FE]  expected:<[?]>  but  was:<[  testMutators  assertFalse(format.withEmptyLinesIgnored(false).isEmptyLinesIgnored());  [CONTEXT]  CSVFormat(  char  delimiter,  char  encapsulator,  char  commentStart,  char  escape,  boolean  surroundingSpacesIgnored,  boolean  emptyLinesIgnored,  String  lineSeparator,  String[]  header)  {  this.delimiter  =  delimiter;  this.encapsulator  =  encapsulator;  this.commentStart  =  commentStart;  this.escape  =  escape;  this.surroundingSpacesIgnored  =  surroundingSpacesIgnored;  this.emptyLinesIgnored  =  emptyLinesIgnored;  [BUGGY]  this.lineSeparator  =  CRLF;  [BUGGY]  this.header  =  header;  }    [CLASS]  CSVFormat  [METHOD]  <init>  [RETURN_TYPE]  String[])    char  delimiter  char  encapsulator  char  commentStart  char  escape  boolean  surroundingSpacesIgnored  boolean  emptyLinesIgnored  String  lineSeparator  String[]  header  [VARIABLES]  char  DISABLED  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  this.lineSeparator  =  lineSeparator;	[BUG]  [BUGGY]  this.encapsulator  =  encapsulator;this.lineSeparator  =  lineSeparator;[CE]  variable  encapsulator  might  already  have  been  assigned  [CONTEXT]  CSVFormat(  char  delimiter,  char  encapsulator,  char  commentStart,  char  escape,  boolean  surroundingSpacesIgnored,  boolean  emptyLinesIgnored,  String  lineSeparator,  String[]  header)  {  this.delimiter  =  delimiter;  this.encapsulator  =  encapsulator;  this.commentStart  =  commentStart;  this.escape  =  escape;  this.surroundingSpacesIgnored  =  surroundingSpacesIgnored;  this.emptyLinesIgnored  =  emptyLinesIgnored;  [BUGGY]  this.encapsulator  =  encapsulator;this.lineSeparator  =  lineSeparator;  [BUGGY]  this.header  =  header;  }    [CLASS]  CSVFormat  [METHOD]  <init>  [RETURN_TYPE]  String[])    char  delimiter  char  encapsulator  char  commentStart  char  escape  boolean  surroundingSpacesIgnored  boolean  emptyLinesIgnored  String  lineSeparator  String[]  header  [VARIABLES]  char  DISABLED  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P11_Insert_Donor_Statement]
[PATCH]  this.header  =  header;	[BUG]  [BUGGY]  this.header  =  null;[FE]  No  header  was  specified,  the  record  values  can't  be  accessed  by  name  testProvidedHeader  assertFalse(records.hasNext());  [CONTEXT]  CSVFormat(  char  delimiter,  char  encapsulator,  char  commentStart,  char  escape,  boolean  surroundingSpacesIgnored,  boolean  emptyLinesIgnored,  String  lineSeparator,  String[]  header)  {  this.delimiter  =  delimiter;  this.encapsulator  =  encapsulator;  this.commentStart  =  commentStart;  this.escape  =  escape;  this.surroundingSpacesIgnored  =  surroundingSpacesIgnored;  this.emptyLinesIgnored  =  emptyLinesIgnored;  this.lineSeparator  =  lineSeparator;  [BUGGY]  this.header  =  null;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  <init>  [RETURN_TYPE]  String[])    char  delimiter  char  encapsulator  char  commentStart  char  escape  boolean  surroundingSpacesIgnored  boolean  emptyLinesIgnored  String  lineSeparator  String[]  header  [VARIABLES]  char  DISABLED  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P8_Replace_Mix]
[PATCH]  this.header  =  header;	[BUG]  [BUGGY]  this.escape  =  escape;this.header  =  header;[CE]  variable  escape  might  already  have  been  assigned  [CONTEXT]  CSVFormat(  char  delimiter,  char  encapsulator,  char  commentStart,  char  escape,  boolean  surroundingSpacesIgnored,  boolean  emptyLinesIgnored,  String  lineSeparator,  String[]  header)  {  this.delimiter  =  delimiter;  this.encapsulator  =  encapsulator;  this.commentStart  =  commentStart;  this.escape  =  escape;  this.surroundingSpacesIgnored  =  surroundingSpacesIgnored;  this.emptyLinesIgnored  =  emptyLinesIgnored;  this.lineSeparator  =  lineSeparator;  [BUGGY]  this.escape  =  escape;this.header  =  header;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  <init>  [RETURN_TYPE]  String[])    char  delimiter  char  encapsulator  char  commentStart  char  escape  boolean  surroundingSpacesIgnored  boolean  emptyLinesIgnored  String  lineSeparator  String[]  header  [VARIABLES]  char  DISABLED  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P11_Insert_Donor_Statement]
[PATCH]  this.header  =  header;	[BUG]  [BUGGY]  this.delimiter  =  delimiter;this.header  =  header;[CE]  variable  delimiter  might  already  have  been  assigned  [CONTEXT]  CSVFormat(  char  delimiter,  char  encapsulator,  char  commentStart,  char  escape,  boolean  surroundingSpacesIgnored,  boolean  emptyLinesIgnored,  String  lineSeparator,  String[]  header)  {  this.delimiter  =  delimiter;  this.encapsulator  =  encapsulator;  this.commentStart  =  commentStart;  this.escape  =  escape;  this.surroundingSpacesIgnored  =  surroundingSpacesIgnored;  this.emptyLinesIgnored  =  emptyLinesIgnored;  this.lineSeparator  =  lineSeparator;  [BUGGY]  this.delimiter  =  delimiter;this.header  =  header;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  <init>  [RETURN_TYPE]  String[])    char  delimiter  char  encapsulator  char  commentStart  char  escape  boolean  surroundingSpacesIgnored  boolean  emptyLinesIgnored  String  lineSeparator  String[]  header  [VARIABLES]  char  DISABLED  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P11_Insert_Donor_Statement]
[PATCH]  return  c  ==  '\n'  ||  c  ==  '\r';	[BUG]  [BUGGY]  return  c  ==  '\n'  &&  c  ==  '\r';[FE]  null  testValidation  [CONTEXT]  private  static  boolean  isLineBreak(char  c)  {  [BUGGY]  return  c  ==  '\n'  &&  c  ==  '\r';  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  isLineBreak  [RETURN_TYPE]  boolean    char  c  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P2_Replace_Operator]
[PATCH]  return  c  ==  '\n'  ||  c  ==  '\r';	[BUG]  [BUGGY]  return  c  !=  '\n'  ||  c  ==  '\r';[FE]  null  testSerialization  assertEquals( "empty  lines ",  CSVFormat.DEFAULT.isEmptyLinesIgnored(),  format.isEmptyLinesIgnored());  [CONTEXT]  private  static  boolean  isLineBreak(char  c)  {  [BUGGY]  return  c  !=  '\n'  ||  c  ==  '\r';  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  isLineBreak  [RETURN_TYPE]  boolean    char  c  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P2_Replace_Operator]
[PATCH]  return  c  ==  '\n'  ||  c  ==  '\r';	[BUG]  [BUGGY]  return  escape  ==  '\n'  ||  c  ==  '\r';[CE]  non-static  variable  escape  cannot  be  referenced  from  a  static  context  [CONTEXT]  private  static  boolean  isLineBreak(char  c)  {  [BUGGY]  return  escape  ==  '\n'  ||  c  ==  '\r';  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  isLineBreak  [RETURN_TYPE]  boolean    char  c  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  c  ==  '\n'  ||  c  ==  '\r';	[BUG]  [BUGGY]  return  c  ;[CE]  incompatible  types  [CONTEXT]  private  static  boolean  isLineBreak(char  c)  {  [BUGGY]  return  c  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  isLineBreak  [RETURN_TYPE]  boolean    char  c  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P8_Replace_Mix]
[PATCH]  if  (  delimiter  ==  encapsulator  )  {	[BUG]  [BUGGY]  if  (  delimiter  !=  encapsulator)  {[FE]  The  encapsulator  character  and  the  delimiter  cannot  be  the  same  ( "  testValidation  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  [BUGGY]  if  (  delimiter  !=  encapsulator)  {  [BUGGY]  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }  if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }  if  (delimiter  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  if  (encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  if  (escape  !=  DISABLED  &&  escape  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }    [CLASS]  CSVFormat  [METHOD]  validate  [RETURN_TYPE]  void    [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P2_Replace_Operator]
[PATCH]  if  (  delimiter  ==  encapsulator  )  {	[BUG]  [BUGGY]  if  (  escape  ==  encapsulator)  {[FE]  The  encapsulator  character  and  the  delimiter  cannot  be  the  same  ( "  testValidation  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  [BUGGY]  if  (  escape  ==  encapsulator)  {  [BUGGY]  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }  if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }  if  (delimiter  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  if  (encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  if  (escape  !=  DISABLED  &&  escape  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }    [CLASS]  CSVFormat  [METHOD]  validate  [RETURN_TYPE]  void    [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  if  (  delimiter  ==  encapsulator  )  {	[BUG]  [BUGGY]  if  (  delimiter  ==  escape)  {[FE]  null  testValidation  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  [BUGGY]  if  (  delimiter  ==  escape)  {  [BUGGY]  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }  if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }  if  (delimiter  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  if  (encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  if  (escape  !=  DISABLED  &&  escape  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }    [CLASS]  CSVFormat  [METHOD]  validate  [RETURN_TYPE]  void    [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  if  (  delimiter  ==  encapsulator  )  {	[BUG]  [BUGGY]  if  (   "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (  \ " "  +  (  encapsulator)  +   "\ ")   ")  {[CE]  incompatible  types  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  [BUGGY]  if  (   "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (  \ " "  +  (  encapsulator)  +   "\ ")   ")  {  [BUGGY]  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }  if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }  if  (delimiter  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  if  (encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  if  (escape  !=  DISABLED  &&  escape  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }    [CLASS]  CSVFormat  [METHOD]  validate  [RETURN_TYPE]  void    [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P6_Replace_Expression]
[PATCH]  if  (  delimiter  ==  encapsulator  )  {	[BUG]  [BUGGY]  if  (   "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (  \ " "  +  encapsulator)  {[CE]  incompatible  types  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  [BUGGY]  if  (   "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (  \ " "  +  encapsulator)  {  [BUGGY]  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }  if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }  if  (delimiter  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  if  (encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  if  (escape  !=  DISABLED  &&  escape  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }    [CLASS]  CSVFormat  [METHOD]  validate  [RETURN_TYPE]  void    [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P6_Replace_Expression]
[PATCH]  if  (  delimiter  ==  encapsulator  )  {	[BUG]  [BUGGY]  if  (  delimiter  ==  commentStart)  {[FE]  null  testValidation  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  [BUGGY]  if  (  delimiter  ==  commentStart)  {  [BUGGY]  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }  if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }  if  (delimiter  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  if  (encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  if  (escape  !=  DISABLED  &&  escape  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }    [CLASS]  CSVFormat  [METHOD]  validate  [RETURN_TYPE]  void    [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P9_Replace_Statement]
[PATCH]  if  (  delimiter  ==  encapsulator  )  {	[BUG]  [BUGGY]  if  (  isLineBreak(  encapsulator)  )  {[FE]  null  testValidation  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  [BUGGY]  if  (  isLineBreak(  encapsulator)  )  {  [BUGGY]  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }  if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }  if  (delimiter  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  if  (encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  if  (escape  !=  DISABLED  &&  escape  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }    [CLASS]  CSVFormat  [METHOD]  validate  [RETURN_TYPE]  void    [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P9_Replace_Statement]
[PATCH]  if  (  delimiter  ==  encapsulator  )  {  throw  new  IllegalArgumentException  ( "   ")  ;  }	[BUG]  [BUGGY]  throw  new  java.lang.IllegalArgumentException((( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same(\ " "  +(encapsulator))  +   "\ ") "));[CE]  illegal  start  of  expression  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  [BUGGY]  throw  new  java.lang.IllegalArgumentException((( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same(\ " "  +(encapsulator))  +   "\ ") "));  [BUGGY]    throw  new  java.lang.IllegalArgumentException((( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  (encapsulator))  +   "\ ") "));    if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }  if  (delimiter  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  if  (encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  if  (escape  !=  DISABLED  &&  escape  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    [CLASS]  CSVFormat  [METHOD]  validate  [RETURN_TYPE]  void    [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P15_Unwrap_Block]
[PATCH]  if  (  delimiter  ==  encapsulator  )  {  throw  new  IllegalArgumentException  ( "   ")  ;  }	[BUG]  [BUGGY]  [CE]  illegal  start  of  expression  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  [BUGGY]  [BUGGY]      if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }  if  (delimiter  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  if  (encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  if  (escape  !=  DISABLED  &&  escape  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    [CLASS]  CSVFormat  [METHOD]  validate  [RETURN_TYPE]  void    [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P16_Remove_Block]
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  (  delimiter)  ==  (  escape)  )  {      throw  new  IllegalArgumentException(  (  (   "The  escape  character  and  the  delimiter  cannot  be  the  same  (  \ " "  +  (  escape)  )  +   "\ ")   ")  )  ;  }[CE]  illegal  start  of  type  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  [BUGGY]  if  (  (  delimiter)  ==  (  escape)  )  {      throw  new  IllegalArgumentException(  (  (   "The  escape  character  and  the  delimiter  cannot  be  the  same  (  \ " "  +  (  escape)  )  +   "\ ")   ")  )  ;  }  [BUGGY]  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }  if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }  if  (delimiter  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  if  (encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  if  (escape  !=  DISABLED  &&  escape  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }    [CLASS]  CSVFormat  [METHOD]  validate  [RETURN_TYPE]  void    [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P13_Insert_Block]
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  (  delimiter)  ==  (  commentStart)  )  {      throw  new  IllegalArgumentException(  (  (   "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (  \ " "  +  (  commentStart)  )  +   "\ ")   ")  )  ;  }[CE]  illegal  start  of  type  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  [BUGGY]  if  (  (  delimiter)  ==  (  commentStart)  )  {      throw  new  IllegalArgumentException(  (  (   "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (  \ " "  +  (  commentStart)  )  +   "\ ")   ")  )  ;  }  [BUGGY]  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }  if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }  if  (delimiter  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  if  (encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  if  (escape  !=  DISABLED  &&  escape  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }    [CLASS]  CSVFormat  [METHOD]  validate  [RETURN_TYPE]  void    [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P13_Insert_Block]
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  (  (  escape)  !=  (  DISABLED)  )  &&  (  (  escape)  ==  (  commentStart)  )  )  {      throw  new  IllegalArgumentException(  (  (   "The  comment  start  and  the  escape  character  cannot  be  the  same  (  \ " "  +  (  commentStart)  )  +   "\ ")   ")  )  ;  }[CE]  illegal  start  of  type  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  [BUGGY]  if  (  (  (  escape)  !=  (  DISABLED)  )  &&  (  (  escape)  ==  (  commentStart)  )  )  {      throw  new  IllegalArgumentException(  (  (   "The  comment  start  and  the  escape  character  cannot  be  the  same  (  \ " "  +  (  commentStart)  )  +   "\ ")   ")  )  ;  }  [BUGGY]  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }  if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }  if  (delimiter  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  if  (encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  if  (escape  !=  DISABLED  &&  escape  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }    [CLASS]  CSVFormat  [METHOD]  validate  [RETURN_TYPE]  void    [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P13_Insert_Block]
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  (  (  encapsulator)  !=  (  DISABLED)  )  &&  (  (  encapsulator)  ==  (  commentStart)  )  )  {      throw  new  IllegalArgumentException(  (  (   "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (  \ " "  +  (  commentStart)  )  +   "\ ")   ")  )  ;  }[CE]  illegal  start  of  type  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  [BUGGY]  if  (  (  (  encapsulator)  !=  (  DISABLED)  )  &&  (  (  encapsulator)  ==  (  commentStart)  )  )  {      throw  new  IllegalArgumentException(  (  (   "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (  \ " "  +  (  commentStart)  )  +   "\ ")   ")  )  ;  }  [BUGGY]  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }  if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }  if  (delimiter  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  if  (encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  if  (escape  !=  DISABLED  &&  escape  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }    [CLASS]  CSVFormat  [METHOD]  validate  [RETURN_TYPE]  void    [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P13_Insert_Block]
[PATCH]  throw  new  IllegalArgumentException  ( "   ")  ;	[BUG]  [BUGGY]  throw  throw  new  IllegalArgumentException(  (  (   "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (  \ " "  +  (  commentStart)  )  +   "\ ")   ")  )    ;[CE]  illegal  start  of  expression  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  [BUGGY]  throw  throw  new  IllegalArgumentException(  (  (   "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (  \ " "  +  (  commentStart)  )  +   "\ ")   ")  )    ;  [BUGGY]  }  if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }  if  (delimiter  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  if  (encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  if  (escape  !=  DISABLED  &&  escape  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }    [CLASS]  CSVFormat  [METHOD]  validate  [RETURN_TYPE]  void    [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P4_Replace_Constructor]
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  (  delimiter)  ==  (  escape)  )  {      throw  new  IllegalArgumentException(  (  (   "The  escape  character  and  the  delimiter  cannot  be  the  same  (  \ " "  +  (  escape)  )  +   "\ ")   ")  )  ;  }[FE]  null  testValidation  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  [BUGGY]  if  (  (  delimiter)  ==  (  escape)  )  {      throw  new  IllegalArgumentException(  (  (   "The  escape  character  and  the  delimiter  cannot  be  the  same  (  \ " "  +  (  escape)  )  +   "\ ")   ")  )  ;  }  [BUGGY]  }  if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }  if  (delimiter  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  if  (encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  if  (escape  !=  DISABLED  &&  escape  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }    [CLASS]  CSVFormat  [METHOD]  validate  [RETURN_TYPE]  void    [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P13_Insert_Block]
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  (  delimiter)  ==  (  commentStart)  )  {      throw  new  IllegalArgumentException(  (  (   "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (  \ " "  +  (  commentStart)  )  +   "\ ")   ")  )  ;  }[FE]  null  testValidation  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  [BUGGY]  if  (  (  delimiter)  ==  (  commentStart)  )  {      throw  new  IllegalArgumentException(  (  (   "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (  \ " "  +  (  commentStart)  )  +   "\ ")   ")  )  ;  }  [BUGGY]  }  if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }  if  (delimiter  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  if  (encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  if  (escape  !=  DISABLED  &&  escape  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }    [CLASS]  CSVFormat  [METHOD]  validate  [RETURN_TYPE]  void    [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P13_Insert_Block]
[PATCH]  if  (  delimiter  ==  escape  )  {	[BUG]  [BUGGY]  if  (  delimiter  >  escape)  {[FE]  null  testValidation  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }  [BUGGY]  if  (  delimiter  >  escape)  {  [BUGGY]  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }  if  (delimiter  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  if  (encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  if  (escape  !=  DISABLED  &&  escape  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }    [CLASS]  CSVFormat  [METHOD]  validate  [RETURN_TYPE]  void    [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P2_Replace_Operator]
[PATCH]  if  (  delimiter  ==  escape  )  {	[BUG]  [BUGGY]  if  (  delimiter  ==  encapsulator)  {[FE]  null  testValidation  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }  [BUGGY]  if  (  delimiter  ==  encapsulator)  {  [BUGGY]  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }  if  (delimiter  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  if  (encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  if  (escape  !=  DISABLED  &&  escape  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }    [CLASS]  CSVFormat  [METHOD]  validate  [RETURN_TYPE]  void    [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  if  (  delimiter  ==  escape  )  {	[BUG]  [BUGGY]  if  (   "The  escape  character  and  the  delimiter  cannot  be  the  same  (  \ " "  +  (  escape)  +   "\ ")   ")  {[CE]  incompatible  types  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }  [BUGGY]  if  (   "The  escape  character  and  the  delimiter  cannot  be  the  same  (  \ " "  +  (  escape)  +   "\ ")   ")  {  [BUGGY]  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }  if  (delimiter  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  if  (encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  if  (escape  !=  DISABLED  &&  escape  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }    [CLASS]  CSVFormat  [METHOD]  validate  [RETURN_TYPE]  void    [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P6_Replace_Expression]
[PATCH]  if  (  delimiter  ==  escape  )  {	[BUG]  [BUGGY]  if  (   "The  escape  character  and  the  delimiter  cannot  be  the  same  (  \ " "  +  escape)  {[CE]  incompatible  types  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }  [BUGGY]  if  (   "The  escape  character  and  the  delimiter  cannot  be  the  same  (  \ " "  +  escape)  {  [BUGGY]  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }  if  (delimiter  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  if  (encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  if  (escape  !=  DISABLED  &&  escape  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }    [CLASS]  CSVFormat  [METHOD]  validate  [RETURN_TYPE]  void    [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P6_Replace_Expression]
[PATCH]  if  (  delimiter  ==  escape  )  {	[BUG]  [BUGGY]  if  (  delimiter  ==  commentStart)  {[FE]  null  testValidation  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }  [BUGGY]  if  (  delimiter  ==  commentStart)  {  [BUGGY]  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }  if  (delimiter  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  if  (encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  if  (escape  !=  DISABLED  &&  escape  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }    [CLASS]  CSVFormat  [METHOD]  validate  [RETURN_TYPE]  void    [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P9_Replace_Statement]
[PATCH]  if  (  delimiter  ==  escape  )  {  throw  new  IllegalArgumentException  ( "   ")  ;  }	[BUG]  [BUGGY]  throw  new  java.lang.IllegalArgumentException((( "The  escape  character  and  the  delimiter  cannot  be  the  same(\ " "  +(escape))  +   "\ ") "));[CE]  illegal  start  of  expression  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }  [BUGGY]  throw  new  java.lang.IllegalArgumentException((( "The  escape  character  and  the  delimiter  cannot  be  the  same(\ " "  +(escape))  +   "\ ") "));  [BUGGY]    throw  new  java.lang.IllegalArgumentException((( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  (escape))  +   "\ ") "));    if  (delimiter  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  if  (encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  if  (escape  !=  DISABLED  &&  escape  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    [CLASS]  CSVFormat  [METHOD]  validate  [RETURN_TYPE]  void    [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P15_Unwrap_Block]
[PATCH]  if  (  delimiter  ==  escape  )  {  throw  new  IllegalArgumentException  ( "   ")  ;  }	[BUG]  [BUGGY]  [CE]  illegal  start  of  expression  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }  [BUGGY]  [BUGGY]      if  (delimiter  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  if  (encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  if  (escape  !=  DISABLED  &&  escape  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    [CLASS]  CSVFormat  [METHOD]  validate  [RETURN_TYPE]  void    [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P16_Remove_Block]
[PATCH]  throw  new  IllegalArgumentException  ( "   ")  ;	[BUG]  [BUGGY]  throw  throw  new  IllegalArgumentException(  (  (   "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (  \ " "  +  (  commentStart)  )  +   "\ ")   ")  )    ;[CE]  illegal  start  of  expression  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }  if  (delimiter  ==  escape)  {  [BUGGY]  throw  throw  new  IllegalArgumentException(  (  (   "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (  \ " "  +  (  commentStart)  )  +   "\ ")   ")  )    ;  [BUGGY]  }  if  (delimiter  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  if  (encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  if  (escape  !=  DISABLED  &&  escape  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }    [CLASS]  CSVFormat  [METHOD]  validate  [RETURN_TYPE]  void    [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P4_Replace_Constructor]
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  (  delimiter)  ==  (  encapsulator)  )  {      throw  new  IllegalArgumentException(  (  (   "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (  \ " "  +  (  encapsulator)  )  +   "\ ")   ")  )  ;  }[FE]  null  testValidation  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }  if  (delimiter  ==  escape)  {  [BUGGY]  if  (  (  delimiter)  ==  (  encapsulator)  )  {      throw  new  IllegalArgumentException(  (  (   "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (  \ " "  +  (  encapsulator)  )  +   "\ ")   ")  )  ;  }  [BUGGY]  }  if  (delimiter  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  if  (encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  if  (escape  !=  DISABLED  &&  escape  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }    [CLASS]  CSVFormat  [METHOD]  validate  [RETURN_TYPE]  void    [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P13_Insert_Block]
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  (  delimiter)  ==  (  commentStart)  )  {      throw  new  IllegalArgumentException(  (  (   "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (  \ " "  +  (  commentStart)  )  +   "\ ")   ")  )  ;  }[FE]  null  testValidation  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }  if  (delimiter  ==  escape)  {  [BUGGY]  if  (  (  delimiter)  ==  (  commentStart)  )  {      throw  new  IllegalArgumentException(  (  (   "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (  \ " "  +  (  commentStart)  )  +   "\ ")   ")  )  ;  }  [BUGGY]  }  if  (delimiter  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  if  (encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  if  (escape  !=  DISABLED  &&  escape  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }    [CLASS]  CSVFormat  [METHOD]  validate  [RETURN_TYPE]  void    [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P13_Insert_Block]
[PATCH]  if  (  delimiter  ==  commentStart  )  {	[BUG]  [BUGGY]  if  (  delimiter  !=  commentStart)  {[FE]  null  testValidation  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }  if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }  [BUGGY]  if  (  delimiter  !=  commentStart)  {  [BUGGY]  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  if  (encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  if  (escape  !=  DISABLED  &&  escape  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }    [CLASS]  CSVFormat  [METHOD]  validate  [RETURN_TYPE]  void    [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P2_Replace_Operator]
[PATCH]  if  (  delimiter  ==  commentStart  )  {	[BUG]  [BUGGY]  if  (  escape  ==  commentStart)  {[FE]  null  testValidation  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }  if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }  [BUGGY]  if  (  escape  ==  commentStart)  {  [BUGGY]  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  if  (encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  if  (escape  !=  DISABLED  &&  escape  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }    [CLASS]  CSVFormat  [METHOD]  validate  [RETURN_TYPE]  void    [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  if  (  delimiter  ==  commentStart  )  {	[BUG]  [BUGGY]  if  (  delimiter  ==  escape)  {[FE]  null  testValidation  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }  if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }  [BUGGY]  if  (  delimiter  ==  escape)  {  [BUGGY]  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  if  (encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  if  (escape  !=  DISABLED  &&  escape  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }    [CLASS]  CSVFormat  [METHOD]  validate  [RETURN_TYPE]  void    [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  if  (  delimiter  ==  commentStart  )  {	[BUG]  [BUGGY]  if  (   "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (  \ " "  +  (  commentStart)  +   "\ ")   ")  {[CE]  incompatible  types  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }  if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }  [BUGGY]  if  (   "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (  \ " "  +  (  commentStart)  +   "\ ")   ")  {  [BUGGY]  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  if  (encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  if  (escape  !=  DISABLED  &&  escape  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }    [CLASS]  CSVFormat  [METHOD]  validate  [RETURN_TYPE]  void    [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P6_Replace_Expression]
[PATCH]  if  (  delimiter  ==  commentStart  )  {	[BUG]  [BUGGY]  if  (   "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (  \ " "  +  commentStart)  {[CE]  incompatible  types  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }  if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }  [BUGGY]  if  (   "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (  \ " "  +  commentStart)  {  [BUGGY]  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  if  (encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  if  (escape  !=  DISABLED  &&  escape  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }    [CLASS]  CSVFormat  [METHOD]  validate  [RETURN_TYPE]  void    [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P6_Replace_Expression]
[PATCH]  if  (  delimiter  ==  commentStart  )  {	[BUG]  [BUGGY]  if  (  delimiter  ==  encapsulator)  {[FE]  null  testValidation  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }  if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }  [BUGGY]  if  (  delimiter  ==  encapsulator)  {  [BUGGY]  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  if  (encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  if  (escape  !=  DISABLED  &&  escape  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }    [CLASS]  CSVFormat  [METHOD]  validate  [RETURN_TYPE]  void    [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P9_Replace_Statement]
[PATCH]  if  (  delimiter  ==  commentStart  )  {	[BUG]  [BUGGY]  if  (  isLineBreak(  commentStart)  )  {[FE]  null  testValidation  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }  if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }  [BUGGY]  if  (  isLineBreak(  commentStart)  )  {  [BUGGY]  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  if  (encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  if  (escape  !=  DISABLED  &&  escape  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }    [CLASS]  CSVFormat  [METHOD]  validate  [RETURN_TYPE]  void    [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P9_Replace_Statement]
[PATCH]  if  (  delimiter  ==  commentStart  )  {  throw  new  IllegalArgumentException  ( "   ")  ;  }	[BUG]  [BUGGY]  throw  new  java.lang.IllegalArgumentException((( "The  comment  start  character  and  the  delimiter  cannot  be  the  same(\ " "  +(commentStart))  +   "\ ") "));[CE]  illegal  start  of  expression  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }  if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }  [BUGGY]  throw  new  java.lang.IllegalArgumentException((( "The  comment  start  character  and  the  delimiter  cannot  be  the  same(\ " "  +(commentStart))  +   "\ ") "));  [BUGGY]    throw  new  java.lang.IllegalArgumentException((( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  (commentStart))  +   "\ ") "));    if  (encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  if  (escape  !=  DISABLED  &&  escape  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    [CLASS]  CSVFormat  [METHOD]  validate  [RETURN_TYPE]  void    [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P15_Unwrap_Block]
[PATCH]  if  (  delimiter  ==  commentStart  )  {  throw  new  IllegalArgumentException  ( "   ")  ;  }	[BUG]  [BUGGY]  [CE]  illegal  start  of  expression  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }  if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }  [BUGGY]  [BUGGY]      if  (encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  if  (escape  !=  DISABLED  &&  escape  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    [CLASS]  CSVFormat  [METHOD]  validate  [RETURN_TYPE]  void    [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P16_Remove_Block]
[PATCH]  throw  new  IllegalArgumentException  ( "   ")  ;	[BUG]  [BUGGY]  throw  throw  new  IllegalArgumentException(  (  (   "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (  \ " "  +  (  commentStart)  )  +   "\ ")   ")  )    ;[CE]  illegal  start  of  expression  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }  if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }  if  (delimiter  ==  commentStart)  {  [BUGGY]  throw  throw  new  IllegalArgumentException(  (  (   "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (  \ " "  +  (  commentStart)  )  +   "\ ")   ")  )    ;  [BUGGY]  }  if  (encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  if  (escape  !=  DISABLED  &&  escape  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }    [CLASS]  CSVFormat  [METHOD]  validate  [RETURN_TYPE]  void    [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P4_Replace_Constructor]
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  (  delimiter)  ==  (  escape)  )  {      throw  new  IllegalArgumentException(  (  (   "The  escape  character  and  the  delimiter  cannot  be  the  same  (  \ " "  +  (  escape)  )  +   "\ ")   ")  )  ;  }[FE]  null  testValidation  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }  if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }  if  (delimiter  ==  commentStart)  {  [BUGGY]  if  (  (  delimiter)  ==  (  escape)  )  {      throw  new  IllegalArgumentException(  (  (   "The  escape  character  and  the  delimiter  cannot  be  the  same  (  \ " "  +  (  escape)  )  +   "\ ")   ")  )  ;  }  [BUGGY]  }  if  (encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  if  (escape  !=  DISABLED  &&  escape  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }    [CLASS]  CSVFormat  [METHOD]  validate  [RETURN_TYPE]  void    [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P13_Insert_Block]
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  (  delimiter)  ==  (  encapsulator)  )  {      throw  new  IllegalArgumentException(  (  (   "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (  \ " "  +  (  encapsulator)  )  +   "\ ")   ")  )  ;  }[FE]  null  testValidation  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }  if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }  if  (delimiter  ==  commentStart)  {  [BUGGY]  if  (  (  delimiter)  ==  (  encapsulator)  )  {      throw  new  IllegalArgumentException(  (  (   "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (  \ " "  +  (  encapsulator)  )  +   "\ ")   ")  )  ;  }  [BUGGY]  }  if  (encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  if  (escape  !=  DISABLED  &&  escape  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }    [CLASS]  CSVFormat  [METHOD]  validate  [RETURN_TYPE]  void    [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P13_Insert_Block]
[PATCH]  throw  new  IllegalArgumentException  ( "   ")  ;	[BUG]  [BUGGY]  return  ;[FE]  null  testValidation  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }  if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }  if  (delimiter  ==  commentStart)  {  [BUGGY]  return  ;  [BUGGY]  }  if  (encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  if  (escape  !=  DISABLED  &&  escape  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }    [CLASS]  CSVFormat  [METHOD]  validate  [RETURN_TYPE]  void    [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P8_Replace_Mix]
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  (  (  encapsulator)  !=  (  DISABLED)  )  &&  (  (  encapsulator)  ==  (  commentStart)  )  )  {      throw  new  IllegalArgumentException(  (  (   "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (  \ " "  +  (  commentStart)  )  +   "\ ")   ")  )  ;  }[FE]  null  testValidation  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }  if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }  if  (delimiter  ==  commentStart)  {  [BUGGY]  if  (  (  (  encapsulator)  !=  (  DISABLED)  )  &&  (  (  encapsulator)  ==  (  commentStart)  )  )  {      throw  new  IllegalArgumentException(  (  (   "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (  \ " "  +  (  commentStart)  )  +   "\ ")   ")  )  ;  }  [BUGGY]  }  if  (encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  if  (escape  !=  DISABLED  &&  escape  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }    [CLASS]  CSVFormat  [METHOD]  validate  [RETURN_TYPE]  void    [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P13_Insert_Block]
[PATCH]  if  (  encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart  )  {	[BUG]  [BUGGY]  if  (  encapsulator  !=  DISABLED  ||  encapsulator  ==  commentStart)  {[FE]  The  comment  start  character  and  the  encapsulator  cannot  be  the  same  ( "  testValidation  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }  if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }  if  (delimiter  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  [BUGGY]  if  (  encapsulator  !=  DISABLED  ||  encapsulator  ==  commentStart)  {  [BUGGY]  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  if  (escape  !=  DISABLED  &&  escape  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }    [CLASS]  CSVFormat  [METHOD]  validate  [RETURN_TYPE]  void    [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P2_Replace_Operator]
[PATCH]  if  (  encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart  )  {	[BUG]  [BUGGY]  if  (  encapsulator  ==  DISABLED  &&  encapsulator  ==  commentStart)  {[FE]  null  testValidation  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }  if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }  if  (delimiter  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  [BUGGY]  if  (  encapsulator  ==  DISABLED  &&  encapsulator  ==  commentStart)  {  [BUGGY]  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  if  (escape  !=  DISABLED  &&  escape  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }    [CLASS]  CSVFormat  [METHOD]  validate  [RETURN_TYPE]  void    [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P2_Replace_Operator]
[PATCH]  if  (  encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart  )  {	[BUG]  [BUGGY]  if  (  escape  !=  DISABLED  &&  encapsulator  ==  commentStart)  {[FE]  null  testValidation  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }  if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }  if  (delimiter  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  [BUGGY]  if  (  escape  !=  DISABLED  &&  encapsulator  ==  commentStart)  {  [BUGGY]  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  if  (escape  !=  DISABLED  &&  escape  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }    [CLASS]  CSVFormat  [METHOD]  validate  [RETURN_TYPE]  void    [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  if  (  encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart  )  {	[BUG]  [BUGGY]  if  (  encapsulator  !=  escape  &&  encapsulator  ==  commentStart)  {[FE]  The  comment  start  character  and  the  encapsulator  cannot  be  the  same  ( "  testBackslashEscaping2  assertTrue(CSVPrinterTest.equals(res,  records));  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }  if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }  if  (delimiter  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  [BUGGY]  if  (  encapsulator  !=  escape  &&  encapsulator  ==  commentStart)  {  [BUGGY]  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  if  (escape  !=  DISABLED  &&  escape  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }    [CLASS]  CSVFormat  [METHOD]  validate  [RETURN_TYPE]  void    [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  if  (  encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart  )  {	[BUG]  [BUGGY]  if  (  commentStart  !=  DISABLED  &&  encapsulator  ==  encapsulator)  {[FE]  The  comment  start  character  and  the  encapsulator  cannot  be  the  same  ( "# ")  testDefaultFormat  assertTrue(CSVPrinterTest.equals(res_comments,  records));  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }  if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }  if  (delimiter  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  [BUGGY]  if  (  commentStart  !=  DISABLED  &&  encapsulator  ==  encapsulator)  {  [BUGGY]  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  if  (escape  !=  DISABLED  &&  escape  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }    [CLASS]  CSVFormat  [METHOD]  validate  [RETURN_TYPE]  void    [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  if  (  encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart  )  {	[BUG]  [BUGGY]  if  (  encapsulator  !=  commentStart  &&  encapsulator  ==  DISABLED)  {[FE]  null  testValidation  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }  if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }  if  (delimiter  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  [BUGGY]  if  (  encapsulator  !=  commentStart  &&  encapsulator  ==  DISABLED)  {  [BUGGY]  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  if  (escape  !=  DISABLED  &&  escape  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }    [CLASS]  CSVFormat  [METHOD]  validate  [RETURN_TYPE]  void    [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  if  (  encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart  )  {	[BUG]  [BUGGY]  if  (  encapsulator  !=  DISABLED)  {[FE]  The  comment  start  character  and  the  encapsulator  cannot  be  the  same  ( "  testValidation  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }  if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }  if  (delimiter  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  [BUGGY]  if  (  encapsulator  !=  DISABLED)  {  [BUGGY]  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  if  (escape  !=  DISABLED  &&  escape  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }    [CLASS]  CSVFormat  [METHOD]  validate  [RETURN_TYPE]  void    [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P6_Replace_Expression]
[PATCH]  if  (  encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart  )  {	[BUG]  [BUGGY]  if  (  encapsulator  ==  commentStart)  {[FE]  The  comment  start  character  and  the  encapsulator  cannot  be  the  same  ( "  testValidation  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }  if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }  if  (delimiter  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  [BUGGY]  if  (  encapsulator  ==  commentStart)  {  [BUGGY]  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  if  (escape  !=  DISABLED  &&  escape  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }    [CLASS]  CSVFormat  [METHOD]  validate  [RETURN_TYPE]  void    [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P6_Replace_Expression]
[PATCH]  if  (  encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart  )  {	[BUG]  [BUGGY]  if  (   "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (  \ " "  +  (  commentStart)  +   "\ ")   ")  {[CE]  incompatible  types  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }  if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }  if  (delimiter  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  [BUGGY]  if  (   "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (  \ " "  +  (  commentStart)  +   "\ ")   ")  {  [BUGGY]  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  if  (escape  !=  DISABLED  &&  escape  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }    [CLASS]  CSVFormat  [METHOD]  validate  [RETURN_TYPE]  void    [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P6_Replace_Expression]
[PATCH]  if  (  encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart  )  {	[BUG]  [BUGGY]  if  (   "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (  \ " "  +  commentStart)  {[CE]  incompatible  types  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }  if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }  if  (delimiter  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  [BUGGY]  if  (   "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (  \ " "  +  commentStart)  {  [BUGGY]  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  if  (escape  !=  DISABLED  &&  escape  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }    [CLASS]  CSVFormat  [METHOD]  validate  [RETURN_TYPE]  void    [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P6_Replace_Expression]
[PATCH]  if  (  encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart  )  {	[BUG]  [BUGGY]  if  (  escape  !=  DISABLED  &&  escape  ==  commentStart)  {[FE]  null  testValidation  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }  if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }  if  (delimiter  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  [BUGGY]  if  (  escape  !=  DISABLED  &&  escape  ==  commentStart)  {  [BUGGY]  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  if  (escape  !=  DISABLED  &&  escape  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }    [CLASS]  CSVFormat  [METHOD]  validate  [RETURN_TYPE]  void    [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P9_Replace_Statement]
[PATCH]  if  (  encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart  )  {  throw  new  IllegalArgumentException  ( "   ")  ;  }	[BUG]  [BUGGY]  throw  new  java.lang.IllegalArgumentException((( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same(\ " "  +(commentStart))  +   "\ ") "));[CE]  illegal  start  of  expression  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }  if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }  if  (delimiter  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  [BUGGY]  throw  new  java.lang.IllegalArgumentException((( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same(\ " "  +(commentStart))  +   "\ ") "));  [BUGGY]    throw  new  java.lang.IllegalArgumentException((( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  (commentStart))  +   "\ ") "));    if  (escape  !=  DISABLED  &&  escape  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    [CLASS]  CSVFormat  [METHOD]  validate  [RETURN_TYPE]  void    [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P15_Unwrap_Block]
[PATCH]  if  (  encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart  )  {  throw  new  IllegalArgumentException  ( "   ")  ;  }	[BUG]  [BUGGY]  [CE]  illegal  start  of  expression  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }  if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }  if  (delimiter  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  [BUGGY]  [BUGGY]      if  (escape  !=  DISABLED  &&  escape  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    [CLASS]  CSVFormat  [METHOD]  validate  [RETURN_TYPE]  void    [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P16_Remove_Block]
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  (  delimiter)  ==  (  escape)  )  {      throw  new  IllegalArgumentException(  (  (   "The  escape  character  and  the  delimiter  cannot  be  the  same  (  \ " "  +  (  escape)  )  +   "\ ")   ")  )  ;  }[CE]  illegal  start  of  type  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }  if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }  if  (delimiter  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  [BUGGY]  if  (  (  delimiter)  ==  (  escape)  )  {      throw  new  IllegalArgumentException(  (  (   "The  escape  character  and  the  delimiter  cannot  be  the  same  (  \ " "  +  (  escape)  )  +   "\ ")   ")  )  ;  }  [BUGGY]  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  if  (escape  !=  DISABLED  &&  escape  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }    [CLASS]  CSVFormat  [METHOD]  validate  [RETURN_TYPE]  void    [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P13_Insert_Block]
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  isLineBreak(  commentStart)  )  {      throw  new  IllegalArgumentException(   "The  comment  start  character  cannot  be  a  line  break ")  ;  }[CE]  illegal  start  of  type  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }  if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }  if  (delimiter  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  [BUGGY]  if  (  isLineBreak(  commentStart)  )  {      throw  new  IllegalArgumentException(   "The  comment  start  character  cannot  be  a  line  break ")  ;  }  [BUGGY]  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  if  (escape  !=  DISABLED  &&  escape  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }    [CLASS]  CSVFormat  [METHOD]  validate  [RETURN_TYPE]  void    [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P13_Insert_Block]
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  isLineBreak(  encapsulator)  )  {      throw  new  IllegalArgumentException(   "The  encapsulator  cannot  be  a  line  break ")  ;  }[CE]  illegal  start  of  type  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }  if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }  if  (delimiter  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  [BUGGY]  if  (  isLineBreak(  encapsulator)  )  {      throw  new  IllegalArgumentException(   "The  encapsulator  cannot  be  a  line  break ")  ;  }  [BUGGY]  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  if  (escape  !=  DISABLED  &&  escape  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }    [CLASS]  CSVFormat  [METHOD]  validate  [RETURN_TYPE]  void    [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P13_Insert_Block]
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  (  delimiter)  ==  (  encapsulator)  )  {      throw  new  IllegalArgumentException(  (  (   "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (  \ " "  +  (  encapsulator)  )  +   "\ ")   ")  )  ;  }[CE]  illegal  start  of  type  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }  if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }  if  (delimiter  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  [BUGGY]  if  (  (  delimiter)  ==  (  encapsulator)  )  {      throw  new  IllegalArgumentException(  (  (   "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (  \ " "  +  (  encapsulator)  )  +   "\ ")   ")  )  ;  }  [BUGGY]  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  if  (escape  !=  DISABLED  &&  escape  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }    [CLASS]  CSVFormat  [METHOD]  validate  [RETURN_TYPE]  void    [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P13_Insert_Block]
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  (  delimiter)  ==  (  commentStart)  )  {      throw  new  IllegalArgumentException(  (  (   "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (  \ " "  +  (  commentStart)  )  +   "\ ")   ")  )  ;  }[CE]  illegal  start  of  type  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }  if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }  if  (delimiter  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  [BUGGY]  if  (  (  delimiter)  ==  (  commentStart)  )  {      throw  new  IllegalArgumentException(  (  (   "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (  \ " "  +  (  commentStart)  )  +   "\ ")   ")  )  ;  }  [BUGGY]  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  if  (escape  !=  DISABLED  &&  escape  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }    [CLASS]  CSVFormat  [METHOD]  validate  [RETURN_TYPE]  void    [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P13_Insert_Block]
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  (  (  escape)  !=  (  DISABLED)  )  &&  (  (  escape)  ==  (  commentStart)  )  )  {      throw  new  IllegalArgumentException(  (  (   "The  comment  start  and  the  escape  character  cannot  be  the  same  (  \ " "  +  (  commentStart)  )  +   "\ ")   ")  )  ;  }[CE]  illegal  start  of  type  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }  if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }  if  (delimiter  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  [BUGGY]  if  (  (  (  escape)  !=  (  DISABLED)  )  &&  (  (  escape)  ==  (  commentStart)  )  )  {      throw  new  IllegalArgumentException(  (  (   "The  comment  start  and  the  escape  character  cannot  be  the  same  (  \ " "  +  (  commentStart)  )  +   "\ ")   ")  )  ;  }  [BUGGY]  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  if  (escape  !=  DISABLED  &&  escape  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }    [CLASS]  CSVFormat  [METHOD]  validate  [RETURN_TYPE]  void    [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P13_Insert_Block]
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  isLineBreak(  escape)  )  {      throw  new  IllegalArgumentException(   "The  escape  character  cannot  be  a  line  break ")  ;  }[CE]  illegal  start  of  type  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }  if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }  if  (delimiter  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  [BUGGY]  if  (  isLineBreak(  escape)  )  {      throw  new  IllegalArgumentException(   "The  escape  character  cannot  be  a  line  break ")  ;  }  [BUGGY]  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  if  (escape  !=  DISABLED  &&  escape  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }    [CLASS]  CSVFormat  [METHOD]  validate  [RETURN_TYPE]  void    [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P13_Insert_Block]
[PATCH]  throw  new  IllegalArgumentException  ( "   ")  ;	[BUG]  [BUGGY]  throw  throw  new  IllegalArgumentException(  (  (   "The  escape  character  and  the  delimiter  cannot  be  the  same  (  \ " "  +  (  escape)  )  +   "\ ")   ")  )    ;[CE]  illegal  start  of  expression  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }  if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }  if  (delimiter  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  if  (encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart)  {  [BUGGY]  throw  throw  new  IllegalArgumentException(  (  (   "The  escape  character  and  the  delimiter  cannot  be  the  same  (  \ " "  +  (  escape)  )  +   "\ ")   ")  )    ;  [BUGGY]  }  if  (escape  !=  DISABLED  &&  escape  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }    [CLASS]  CSVFormat  [METHOD]  validate  [RETURN_TYPE]  void    [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P4_Replace_Constructor]
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  (  delimiter)  ==  (  escape)  )  {      throw  new  IllegalArgumentException(  (  (   "The  escape  character  and  the  delimiter  cannot  be  the  same  (  \ " "  +  (  escape)  )  +   "\ ")   ")  )  ;  }[FE]  null  testValidation  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }  if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }  if  (delimiter  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  if  (encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart)  {  [BUGGY]  if  (  (  delimiter)  ==  (  escape)  )  {      throw  new  IllegalArgumentException(  (  (   "The  escape  character  and  the  delimiter  cannot  be  the  same  (  \ " "  +  (  escape)  )  +   "\ ")   ")  )  ;  }  [BUGGY]  }  if  (escape  !=  DISABLED  &&  escape  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }    [CLASS]  CSVFormat  [METHOD]  validate  [RETURN_TYPE]  void    [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P13_Insert_Block]
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  (  delimiter)  ==  (  encapsulator)  )  {      throw  new  IllegalArgumentException(  (  (   "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (  \ " "  +  (  encapsulator)  )  +   "\ ")   ")  )  ;  }[FE]  null  testValidation  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }  if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }  if  (delimiter  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  if  (encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart)  {  [BUGGY]  if  (  (  delimiter)  ==  (  encapsulator)  )  {      throw  new  IllegalArgumentException(  (  (   "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (  \ " "  +  (  encapsulator)  )  +   "\ ")   ")  )  ;  }  [BUGGY]  }  if  (escape  !=  DISABLED  &&  escape  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }    [CLASS]  CSVFormat  [METHOD]  validate  [RETURN_TYPE]  void    [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P13_Insert_Block]
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  (  delimiter)  ==  (  commentStart)  )  {      throw  new  IllegalArgumentException(  (  (   "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (  \ " "  +  (  commentStart)  )  +   "\ ")   ")  )  ;  }[FE]  null  testValidation  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }  if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }  if  (delimiter  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  if  (encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart)  {  [BUGGY]  if  (  (  delimiter)  ==  (  commentStart)  )  {      throw  new  IllegalArgumentException(  (  (   "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (  \ " "  +  (  commentStart)  )  +   "\ ")   ")  )  ;  }  [BUGGY]  }  if  (escape  !=  DISABLED  &&  escape  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }    [CLASS]  CSVFormat  [METHOD]  validate  [RETURN_TYPE]  void    [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P13_Insert_Block]
[PATCH]  throw  new  IllegalArgumentException  ( "   ")  ;	[BUG]  [BUGGY]  return  ;[FE]  null  testValidation  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }  if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }  if  (delimiter  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  if  (encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart)  {  [BUGGY]  return  ;  [BUGGY]  }  if  (escape  !=  DISABLED  &&  escape  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }    [CLASS]  CSVFormat  [METHOD]  validate  [RETURN_TYPE]  void    [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P8_Replace_Mix]
[PATCH]  if  (  escape  !=  DISABLED  &&  escape  ==  commentStart  )  {	[BUG]  [BUGGY]  if  (  escape  !=  DISABLED  ||  escape  ==  commentStart)  {[FE]  The  comment  start  and  the  escape  character  cannot  be  the  same  ( "  testValidation  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }  if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }  if  (delimiter  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  if  (encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  [BUGGY]  if  (  escape  !=  DISABLED  ||  escape  ==  commentStart)  {  [BUGGY]  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }    [CLASS]  CSVFormat  [METHOD]  validate  [RETURN_TYPE]  void    [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P2_Replace_Operator]
[PATCH]  if  (  escape  !=  DISABLED  &&  escape  ==  commentStart  )  {	[BUG]  [BUGGY]  if  (  escape  <=  DISABLED  &&  escape  ==  commentStart)  {[FE]  The  comment  start  and  the  escape  character  cannot  be  the  same  ( "  testValidation  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }  if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }  if  (delimiter  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  if  (encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  [BUGGY]  if  (  escape  <=  DISABLED  &&  escape  ==  commentStart)  {  [BUGGY]  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }    [CLASS]  CSVFormat  [METHOD]  validate  [RETURN_TYPE]  void    [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P2_Replace_Operator]
[PATCH]  if  (  escape  !=  DISABLED  &&  escape  ==  commentStart  )  {	[BUG]  [BUGGY]  if  (  escape  !=  DISABLED  &&  escape  <=  commentStart)  {[FE]  The  comment  start  and  the  escape  character  cannot  be  the  same  ( "  testBackslashEscaping2  assertTrue(CSVPrinterTest.equals(res,  records));  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }  if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }  if  (delimiter  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  if  (encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  [BUGGY]  if  (  escape  !=  DISABLED  &&  escape  <=  commentStart)  {  [BUGGY]  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }    [CLASS]  CSVFormat  [METHOD]  validate  [RETURN_TYPE]  void    [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P2_Replace_Operator]
[PATCH]  if  (  escape  !=  DISABLED  &&  escape  ==  commentStart  )  {	[BUG]  [BUGGY]  if  (  encapsulator  !=  DISABLED  &&  escape  ==  commentStart)  {[FE]  The  comment  start  and  the  escape  character  cannot  be  the  same  ( "  testValidation  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }  if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }  if  (delimiter  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  if  (encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  [BUGGY]  if  (  encapsulator  !=  DISABLED  &&  escape  ==  commentStart)  {  [BUGGY]  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }    [CLASS]  CSVFormat  [METHOD]  validate  [RETURN_TYPE]  void    [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  if  (  escape  !=  DISABLED  &&  escape  ==  commentStart  )  {	[BUG]  [BUGGY]  if  (  escape  !=  DISABLED  &&  escape  ==  escape)  {[FE]  The  comment  start  and  the  escape  character  cannot  be  the  same  ( "  testBackslashEscaping2  assertTrue(CSVPrinterTest.equals(res,  records));  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }  if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }  if  (delimiter  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  if  (encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  [BUGGY]  if  (  escape  !=  DISABLED  &&  escape  ==  escape)  {  [BUGGY]  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }    [CLASS]  CSVFormat  [METHOD]  validate  [RETURN_TYPE]  void    [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  if  (  escape  !=  DISABLED  &&  escape  ==  commentStart  )  {	[BUG]  [BUGGY]  if  (  escape  !=  commentStart  &&  escape  ==  DISABLED)  {[FE]  null  testValidation  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }  if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }  if  (delimiter  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  if  (encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  [BUGGY]  if  (  escape  !=  commentStart  &&  escape  ==  DISABLED)  {  [BUGGY]  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }    [CLASS]  CSVFormat  [METHOD]  validate  [RETURN_TYPE]  void    [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  if  (  escape  !=  DISABLED  &&  escape  ==  commentStart  )  {	[BUG]  [BUGGY]  if  (  commentStart  !=  DISABLED  &&  escape  ==  escape)  {[FE]  The  comment  start  and  the  escape  character  cannot  be  the  same  ( "# ")  testDefaultFormat  assertTrue(CSVPrinterTest.equals(res_comments,  records));  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }  if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }  if  (delimiter  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  if  (encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  [BUGGY]  if  (  commentStart  !=  DISABLED  &&  escape  ==  escape)  {  [BUGGY]  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }    [CLASS]  CSVFormat  [METHOD]  validate  [RETURN_TYPE]  void    [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  if  (  escape  !=  DISABLED  &&  escape  ==  commentStart  )  {	[BUG]  [BUGGY]  if  (  escape  !=  DISABLED)  {[FE]  The  comment  start  and  the  escape  character  cannot  be  the  same  ( "  testBackslashEscaping2  assertTrue(CSVPrinterTest.equals(res,  records));  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }  if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }  if  (delimiter  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  if  (encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  [BUGGY]  if  (  escape  !=  DISABLED)  {  [BUGGY]  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }    [CLASS]  CSVFormat  [METHOD]  validate  [RETURN_TYPE]  void    [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P6_Replace_Expression]
[PATCH]  if  (  escape  !=  DISABLED  &&  escape  ==  commentStart  )  {	[BUG]  [BUGGY]  if  (  escape  ==  commentStart)  {[FE]  The  comment  start  and  the  escape  character  cannot  be  the  same  ( "  testValidation  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }  if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }  if  (delimiter  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  if  (encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  [BUGGY]  if  (  escape  ==  commentStart)  {  [BUGGY]  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }    [CLASS]  CSVFormat  [METHOD]  validate  [RETURN_TYPE]  void    [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P6_Replace_Expression]
[PATCH]  if  (  escape  !=  DISABLED  &&  escape  ==  commentStart  )  {	[BUG]  [BUGGY]  if  (   "The  comment  start  and  the  escape  character  cannot  be  the  same  (  \ " "  +  (  commentStart)  +   "\ ")   ")  {[CE]  incompatible  types  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }  if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }  if  (delimiter  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  if  (encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  [BUGGY]  if  (   "The  comment  start  and  the  escape  character  cannot  be  the  same  (  \ " "  +  (  commentStart)  +   "\ ")   ")  {  [BUGGY]  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }    [CLASS]  CSVFormat  [METHOD]  validate  [RETURN_TYPE]  void    [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P6_Replace_Expression]
[PATCH]  if  (  escape  !=  DISABLED  &&  escape  ==  commentStart  )  {	[BUG]  [BUGGY]  if  (   "The  comment  start  and  the  escape  character  cannot  be  the  same  (  \ " "  +  commentStart)  {[CE]  incompatible  types  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }  if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }  if  (delimiter  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  if  (encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  [BUGGY]  if  (   "The  comment  start  and  the  escape  character  cannot  be  the  same  (  \ " "  +  commentStart)  {  [BUGGY]  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }    [CLASS]  CSVFormat  [METHOD]  validate  [RETURN_TYPE]  void    [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P6_Replace_Expression]
[PATCH]  if  (  escape  !=  DISABLED  &&  escape  ==  commentStart  )  {	[BUG]  [BUGGY]  if  (  escape  ==  encapsulator)  {[FE]  The  comment  start  and  the  escape  character  cannot  be  the  same  ( "  testValidation  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }  if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }  if  (delimiter  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  if  (encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  [BUGGY]  if  (  escape  ==  encapsulator)  {  [BUGGY]  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }    [CLASS]  CSVFormat  [METHOD]  validate  [RETURN_TYPE]  void    [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P8_Replace_Mix]
[PATCH]  if  (  escape  !=  DISABLED  &&  escape  ==  commentStart  )  {	[BUG]  [BUGGY]  if  (  encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart)  {[FE]  null  testValidation  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }  if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }  if  (delimiter  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  if  (encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  [BUGGY]  if  (  encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart)  {  [BUGGY]  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }    [CLASS]  CSVFormat  [METHOD]  validate  [RETURN_TYPE]  void    [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P9_Replace_Statement]
[PATCH]  if  (  escape  !=  DISABLED  &&  escape  ==  commentStart  )  {  throw  new  IllegalArgumentException  ( "   ")  ;  }	[BUG]  [BUGGY]  throw  new  java.lang.IllegalArgumentException((( "The  comment  start  and  the  escape  character  cannot  be  the  same(\ " "  +(commentStart))  +   "\ ") "));[CE]  illegal  start  of  expression  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }  if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }  if  (delimiter  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  if  (encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  [BUGGY]  throw  new  java.lang.IllegalArgumentException((( "The  comment  start  and  the  escape  character  cannot  be  the  same(\ " "  +(commentStart))  +   "\ ") "));  [BUGGY]    throw  new  java.lang.IllegalArgumentException((( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  (commentStart))  +   "\ ") "));      [CLASS]  CSVFormat  [METHOD]  validate  [RETURN_TYPE]  void    [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P15_Unwrap_Block]
[PATCH]  if  (  escape  !=  DISABLED  &&  escape  ==  commentStart  )  {  throw  new  IllegalArgumentException  ( "   ")  ;  }	[BUG]  [BUGGY]  [CE]  illegal  start  of  expression  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }  if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }  if  (delimiter  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  if  (encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  [BUGGY]  [BUGGY]        [CLASS]  CSVFormat  [METHOD]  validate  [RETURN_TYPE]  void    [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P16_Remove_Block]
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  (  delimiter)  ==  (  escape)  )  {      throw  new  IllegalArgumentException(  (  (   "The  escape  character  and  the  delimiter  cannot  be  the  same  (  \ " "  +  (  escape)  )  +   "\ ")   ")  )  ;  }[CE]  class,  interface,  or  enum  expected  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }  if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }  if  (delimiter  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  if  (encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  [BUGGY]  if  (  (  delimiter)  ==  (  escape)  )  {      throw  new  IllegalArgumentException(  (  (   "The  escape  character  and  the  delimiter  cannot  be  the  same  (  \ " "  +  (  escape)  )  +   "\ ")   ")  )  ;  }  [BUGGY]  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }    [CLASS]  CSVFormat  [METHOD]  validate  [RETURN_TYPE]  void    [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P13_Insert_Block]
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  isLineBreak(  commentStart)  )  {      throw  new  IllegalArgumentException(   "The  comment  start  character  cannot  be  a  line  break ")  ;  }[CE]  class,  interface,  or  enum  expected  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }  if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }  if  (delimiter  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  if  (encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  [BUGGY]  if  (  isLineBreak(  commentStart)  )  {      throw  new  IllegalArgumentException(   "The  comment  start  character  cannot  be  a  line  break ")  ;  }  [BUGGY]  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }    [CLASS]  CSVFormat  [METHOD]  validate  [RETURN_TYPE]  void    [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P13_Insert_Block]
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  isLineBreak(  encapsulator)  )  {      throw  new  IllegalArgumentException(   "The  encapsulator  cannot  be  a  line  break ")  ;  }[CE]  class,  interface,  or  enum  expected  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }  if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }  if  (delimiter  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  if  (encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  [BUGGY]  if  (  isLineBreak(  encapsulator)  )  {      throw  new  IllegalArgumentException(   "The  encapsulator  cannot  be  a  line  break ")  ;  }  [BUGGY]  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }    [CLASS]  CSVFormat  [METHOD]  validate  [RETURN_TYPE]  void    [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P13_Insert_Block]
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  (  delimiter)  ==  (  encapsulator)  )  {      throw  new  IllegalArgumentException(  (  (   "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (  \ " "  +  (  encapsulator)  )  +   "\ ")   ")  )  ;  }[CE]  class,  interface,  or  enum  expected  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }  if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }  if  (delimiter  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  if  (encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  [BUGGY]  if  (  (  delimiter)  ==  (  encapsulator)  )  {      throw  new  IllegalArgumentException(  (  (   "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (  \ " "  +  (  encapsulator)  )  +   "\ ")   ")  )  ;  }  [BUGGY]  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }    [CLASS]  CSVFormat  [METHOD]  validate  [RETURN_TYPE]  void    [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P13_Insert_Block]
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  (  delimiter)  ==  (  commentStart)  )  {      throw  new  IllegalArgumentException(  (  (   "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (  \ " "  +  (  commentStart)  )  +   "\ ")   ")  )  ;  }[CE]  class,  interface,  or  enum  expected  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }  if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }  if  (delimiter  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  if  (encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  [BUGGY]  if  (  (  delimiter)  ==  (  commentStart)  )  {      throw  new  IllegalArgumentException(  (  (   "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (  \ " "  +  (  commentStart)  )  +   "\ ")   ")  )  ;  }  [BUGGY]  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }    [CLASS]  CSVFormat  [METHOD]  validate  [RETURN_TYPE]  void    [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P13_Insert_Block]
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  isLineBreak(  delimiter)  )  {      throw  new  IllegalArgumentException(   "The  delimiter  cannot  be  a  line  break ")  ;  }[CE]  class,  interface,  or  enum  expected  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }  if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }  if  (delimiter  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  if  (encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  [BUGGY]  if  (  isLineBreak(  delimiter)  )  {      throw  new  IllegalArgumentException(   "The  delimiter  cannot  be  a  line  break ")  ;  }  [BUGGY]  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }    [CLASS]  CSVFormat  [METHOD]  validate  [RETURN_TYPE]  void    [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P13_Insert_Block]
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  isLineBreak(  escape)  )  {      throw  new  IllegalArgumentException(   "The  escape  character  cannot  be  a  line  break ")  ;  }[CE]  class,  interface,  or  enum  expected  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }  if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }  if  (delimiter  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  if  (encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  [BUGGY]  if  (  isLineBreak(  escape)  )  {      throw  new  IllegalArgumentException(   "The  escape  character  cannot  be  a  line  break ")  ;  }  [BUGGY]  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }    [CLASS]  CSVFormat  [METHOD]  validate  [RETURN_TYPE]  void    [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P13_Insert_Block]
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  (  (  encapsulator)  !=  (  DISABLED)  )  &&  (  (  encapsulator)  ==  (  commentStart)  )  )  {      throw  new  IllegalArgumentException(  (  (   "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (  \ " "  +  (  commentStart)  )  +   "\ ")   ")  )  ;  }[CE]  class,  interface,  or  enum  expected  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }  if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }  if  (delimiter  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  if  (encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  [BUGGY]  if  (  (  (  encapsulator)  !=  (  DISABLED)  )  &&  (  (  encapsulator)  ==  (  commentStart)  )  )  {      throw  new  IllegalArgumentException(  (  (   "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (  \ " "  +  (  commentStart)  )  +   "\ ")   ")  )  ;  }  [BUGGY]  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }    [CLASS]  CSVFormat  [METHOD]  validate  [RETURN_TYPE]  void    [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P13_Insert_Block]
[PATCH]  throw  new  IllegalArgumentException  ( "   ")  ;	[BUG]  [BUGGY]  throw  throw  new  IllegalArgumentException(  (  (   "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (  \ " "  +  (  commentStart)  )  +   "\ ")   ")  )    ;[CE]  illegal  start  of  expression  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }  if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }  if  (delimiter  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  if  (encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  if  (escape  !=  DISABLED  &&  escape  ==  commentStart)  {  [BUGGY]  throw  throw  new  IllegalArgumentException(  (  (   "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (  \ " "  +  (  commentStart)  )  +   "\ ")   ")  )    ;  [BUGGY]  }  }    [CLASS]  CSVFormat  [METHOD]  validate  [RETURN_TYPE]  void    [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P4_Replace_Constructor]
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  (  delimiter)  ==  (  escape)  )  {      throw  new  IllegalArgumentException(  (  (   "The  escape  character  and  the  delimiter  cannot  be  the  same  (  \ " "  +  (  escape)  )  +   "\ ")   ")  )  ;  }[FE]  null  testValidation  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }  if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }  if  (delimiter  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  if  (encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  if  (escape  !=  DISABLED  &&  escape  ==  commentStart)  {  [BUGGY]  if  (  (  delimiter)  ==  (  escape)  )  {      throw  new  IllegalArgumentException(  (  (   "The  escape  character  and  the  delimiter  cannot  be  the  same  (  \ " "  +  (  escape)  )  +   "\ ")   ")  )  ;  }  [BUGGY]  }  }    [CLASS]  CSVFormat  [METHOD]  validate  [RETURN_TYPE]  void    [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P13_Insert_Block]
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  (  delimiter)  ==  (  encapsulator)  )  {      throw  new  IllegalArgumentException(  (  (   "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (  \ " "  +  (  encapsulator)  )  +   "\ ")   ")  )  ;  }[FE]  null  testValidation  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }  if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }  if  (delimiter  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  if  (encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  if  (escape  !=  DISABLED  &&  escape  ==  commentStart)  {  [BUGGY]  if  (  (  delimiter)  ==  (  encapsulator)  )  {      throw  new  IllegalArgumentException(  (  (   "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (  \ " "  +  (  encapsulator)  )  +   "\ ")   ")  )  ;  }  [BUGGY]  }  }    [CLASS]  CSVFormat  [METHOD]  validate  [RETURN_TYPE]  void    [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P13_Insert_Block]
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  (  delimiter)  ==  (  commentStart)  )  {      throw  new  IllegalArgumentException(  (  (   "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (  \ " "  +  (  commentStart)  )  +   "\ ")   ")  )  ;  }[FE]  null  testValidation  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }  if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }  if  (delimiter  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  if  (encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  if  (escape  !=  DISABLED  &&  escape  ==  commentStart)  {  [BUGGY]  if  (  (  delimiter)  ==  (  commentStart)  )  {      throw  new  IllegalArgumentException(  (  (   "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (  \ " "  +  (  commentStart)  )  +   "\ ")   ")  )  ;  }  [BUGGY]  }  }    [CLASS]  CSVFormat  [METHOD]  validate  [RETURN_TYPE]  void    [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P13_Insert_Block]
[PATCH]  return  delimiter;	[BUG]  [BUGGY]  return  escape;[FE]  expected:<a[,b,]c>  but  was:<a[  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]  public  char  getDelimiter()  {  [BUGGY]  return  escape;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  getDelimiter  [RETURN_TYPE]  char    [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  if  (  isLineBreak  (  delimiter  )  )  {	[BUG]  [BUGGY]  if  (  isLineBreak(  encapsulator)  )  {[FE]  null  testValidation  [CONTEXT]  public  CSVFormat  withDelimiter(char  delimiter)  {  [BUGGY]  if  (  isLineBreak(  encapsulator)  )  {  [BUGGY]  throw  new  IllegalArgumentException( "The  delimiter  cannot  be  a  line  break ");  }  return  new  CSVFormat(delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  }    [CLASS]  CSVFormat  [METHOD]  withDelimiter  [RETURN_TYPE]  CSVFormat    char  delimiter  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  if  (  isLineBreak  (  delimiter  )  )  {	[BUG]  [BUGGY]  if  (  withEscape(  delimiter)  )  {[CE]  incompatible  types  [CONTEXT]  public  CSVFormat  withDelimiter(char  delimiter)  {  [BUGGY]  if  (  withEscape(  delimiter)  )  {  [BUGGY]  throw  new  IllegalArgumentException( "The  delimiter  cannot  be  a  line  break ");  }  return  new  CSVFormat(delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  }    [CLASS]  CSVFormat  [METHOD]  withDelimiter  [RETURN_TYPE]  CSVFormat    char  delimiter  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P7_Replace_Invocation]
[PATCH]  if  (  isLineBreak  (  delimiter  )  )  {	[BUG]  [BUGGY]  if  (  isLineBreak(  escape)  )  {[FE]  null  testValidation  [CONTEXT]  public  CSVFormat  withDelimiter(char  delimiter)  {  [BUGGY]  if  (  isLineBreak(  escape)  )  {  [BUGGY]  throw  new  IllegalArgumentException( "The  delimiter  cannot  be  a  line  break ");  }  return  new  CSVFormat(delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  }    [CLASS]  CSVFormat  [METHOD]  withDelimiter  [RETURN_TYPE]  CSVFormat    char  delimiter  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P8_Replace_Mix]
[PATCH]  if  (  isLineBreak  (  delimiter  )  )  {	[BUG]  [BUGGY]  if  (  isLineBreak(  commentStart)  )  {[FE]  null  testValidation  [CONTEXT]  public  CSVFormat  withDelimiter(char  delimiter)  {  [BUGGY]  if  (  isLineBreak(  commentStart)  )  {  [BUGGY]  throw  new  IllegalArgumentException( "The  delimiter  cannot  be  a  line  break ");  }  return  new  CSVFormat(delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  }    [CLASS]  CSVFormat  [METHOD]  withDelimiter  [RETURN_TYPE]  CSVFormat    char  delimiter  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P9_Replace_Statement]
[PATCH]  if  (  isLineBreak  (  delimiter  )  )  {  throw  new  IllegalArgumentException  ( "   ")  ;  }	[BUG]  [BUGGY]  throw  new  java.lang.IllegalArgumentException( "The  delimiter  cannot  be  a  line  break ");[CE]  illegal  start  of  expression  [CONTEXT]  public  CSVFormat  withDelimiter(char  delimiter)  {  [BUGGY]  throw  new  java.lang.IllegalArgumentException( "The  delimiter  cannot  be  a  line  break ");  [BUGGY]    throw  new  java.lang.IllegalArgumentException( "The  delimiter  cannot  be  a  line  break ");    return  new  CSVFormat(delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);    [CLASS]  CSVFormat  [METHOD]  withDelimiter  [RETURN_TYPE]  CSVFormat    char  delimiter  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P15_Unwrap_Block]
[PATCH]  if  (  isLineBreak  (  delimiter  )  )  {  throw  new  IllegalArgumentException  ( "   ")  ;  }	[BUG]  [BUGGY]  [CE]  illegal  start  of  expression  [CONTEXT]  public  CSVFormat  withDelimiter(char  delimiter)  {  [BUGGY]  [BUGGY]      return  new  CSVFormat(delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);    [CLASS]  CSVFormat  [METHOD]  withDelimiter  [RETURN_TYPE]  CSVFormat    char  delimiter  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P16_Remove_Block]
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  isLineBreak(  commentStart)  )  {      throw  new  IllegalArgumentException(   "The  comment  start  character  cannot  be  a  line  break ")  ;  }[CE]  illegal  start  of  type  [CONTEXT]  public  CSVFormat  withDelimiter(char  delimiter)  {  [BUGGY]  if  (  isLineBreak(  commentStart)  )  {      throw  new  IllegalArgumentException(   "The  comment  start  character  cannot  be  a  line  break ")  ;  }  [BUGGY]  throw  new  IllegalArgumentException( "The  delimiter  cannot  be  a  line  break ");  }  return  new  CSVFormat(delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  }    [CLASS]  CSVFormat  [METHOD]  withDelimiter  [RETURN_TYPE]  CSVFormat    char  delimiter  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P13_Insert_Block]
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  isLineBreak(  encapsulator)  )  {      throw  new  IllegalArgumentException(   "The  encapsulator  cannot  be  a  line  break ")  ;  }[CE]  illegal  start  of  type  [CONTEXT]  public  CSVFormat  withDelimiter(char  delimiter)  {  [BUGGY]  if  (  isLineBreak(  encapsulator)  )  {      throw  new  IllegalArgumentException(   "The  encapsulator  cannot  be  a  line  break ")  ;  }  [BUGGY]  throw  new  IllegalArgumentException( "The  delimiter  cannot  be  a  line  break ");  }  return  new  CSVFormat(delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  }    [CLASS]  CSVFormat  [METHOD]  withDelimiter  [RETURN_TYPE]  CSVFormat    char  delimiter  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P13_Insert_Block]
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  (  (  escape)  !=  (  DISABLED)  )  &&  (  (  escape)  ==  (  commentStart)  )  )  {      throw  new  IllegalArgumentException(  (  (   "The  comment  start  and  the  escape  character  cannot  be  the  same  (  \ " "  +  (  commentStart)  )  +   "\ ")   ")  )  ;  }[CE]  illegal  start  of  type  [CONTEXT]  public  CSVFormat  withDelimiter(char  delimiter)  {  [BUGGY]  if  (  (  (  escape)  !=  (  DISABLED)  )  &&  (  (  escape)  ==  (  commentStart)  )  )  {      throw  new  IllegalArgumentException(  (  (   "The  comment  start  and  the  escape  character  cannot  be  the  same  (  \ " "  +  (  commentStart)  )  +   "\ ")   ")  )  ;  }  [BUGGY]  throw  new  IllegalArgumentException( "The  delimiter  cannot  be  a  line  break ");  }  return  new  CSVFormat(delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  }    [CLASS]  CSVFormat  [METHOD]  withDelimiter  [RETURN_TYPE]  CSVFormat    char  delimiter  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P13_Insert_Block]
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  isLineBreak(  escape)  )  {      throw  new  IllegalArgumentException(   "The  escape  character  cannot  be  a  line  break ")  ;  }[CE]  illegal  start  of  type  [CONTEXT]  public  CSVFormat  withDelimiter(char  delimiter)  {  [BUGGY]  if  (  isLineBreak(  escape)  )  {      throw  new  IllegalArgumentException(   "The  escape  character  cannot  be  a  line  break ")  ;  }  [BUGGY]  throw  new  IllegalArgumentException( "The  delimiter  cannot  be  a  line  break ");  }  return  new  CSVFormat(delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  }    [CLASS]  CSVFormat  [METHOD]  withDelimiter  [RETURN_TYPE]  CSVFormat    char  delimiter  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P13_Insert_Block]
[PATCH]  throw  new  IllegalArgumentException  ( "   ")  ;	[BUG]  [BUGGY]  throw  throw  new  IllegalArgumentException(   "The  escape  character  cannot  be  a  line  break ")    ;[CE]  illegal  start  of  expression  [CONTEXT]  public  CSVFormat  withDelimiter(char  delimiter)  {  if  (isLineBreak(delimiter))  {  [BUGGY]  throw  throw  new  IllegalArgumentException(   "The  escape  character  cannot  be  a  line  break ")    ;  [BUGGY]  }  return  new  CSVFormat(delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  }    [CLASS]  CSVFormat  [METHOD]  withDelimiter  [RETURN_TYPE]  CSVFormat    char  delimiter  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P4_Replace_Constructor]
[PATCH]  throw  new  IllegalArgumentException  ( "   ")  ;	[BUG]  [BUGGY]  return  ;[CE]  missing  return  value  [CONTEXT]  public  CSVFormat  withDelimiter(char  delimiter)  {  if  (isLineBreak(delimiter))  {  [BUGGY]  return  ;  [BUGGY]  }  return  new  CSVFormat(delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  }    [CLASS]  CSVFormat  [METHOD]  withDelimiter  [RETURN_TYPE]  CSVFormat    char  delimiter  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P8_Replace_Mix]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  escape,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;[FE]  The  encapsulator  character  and  the  delimiter  cannot  be  the  same  ( "  testValidation  [CONTEXT]  public  CSVFormat  withDelimiter(char  delimiter)  {  if  (isLineBreak(delimiter))  {  throw  new  IllegalArgumentException( "The  delimiter  cannot  be  a  line  break ");  }  [BUGGY]  return  new  CSVFormat(  escape,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withDelimiter  [RETURN_TYPE]  CSVFormat    char  delimiter  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  escape,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;[FE]  null  testValidation  [CONTEXT]  public  CSVFormat  withDelimiter(char  delimiter)  {  if  (isLineBreak(delimiter))  {  throw  new  IllegalArgumentException( "The  delimiter  cannot  be  a  line  break ");  }  [BUGGY]  return  new  CSVFormat(  delimiter,  escape,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withDelimiter  [RETURN_TYPE]  CSVFormat    char  delimiter  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;[CE]  constructor  CSVFormat  in  class  CSVFormat  cannot  be  applied  to  given  types;  [CONTEXT]  public  CSVFormat  withDelimiter(char  delimiter)  {  if  (isLineBreak(delimiter))  {  throw  new  IllegalArgumentException( "The  delimiter  cannot  be  a  line  break ");  }  [BUGGY]  return  new  CSVFormat(  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withDelimiter  [RETURN_TYPE]  CSVFormat    char  delimiter  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;[CE]  constructor  CSVFormat  in  class  CSVFormat  cannot  be  applied  to  given  types;  [CONTEXT]  public  CSVFormat  withDelimiter(char  delimiter)  {  if  (isLineBreak(delimiter))  {  throw  new  IllegalArgumentException( "The  delimiter  cannot  be  a  line  break ");  }  [BUGGY]  return  new  CSVFormat(  delimiter,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withDelimiter  [RETURN_TYPE]  CSVFormat    char  delimiter  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;[CE]  constructor  CSVFormat  in  class  CSVFormat  cannot  be  applied  to  given  types;  [CONTEXT]  public  CSVFormat  withDelimiter(char  delimiter)  {  if  (isLineBreak(delimiter))  {  throw  new  IllegalArgumentException( "The  delimiter  cannot  be  a  line  break ");  }  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withDelimiter  [RETURN_TYPE]  CSVFormat    char  delimiter  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;[CE]  constructor  CSVFormat  in  class  CSVFormat  cannot  be  applied  to  given  types;  [CONTEXT]  public  CSVFormat  withDelimiter(char  delimiter)  {  if  (isLineBreak(delimiter))  {  throw  new  IllegalArgumentException( "The  delimiter  cannot  be  a  line  break ");  }  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withDelimiter  [RETURN_TYPE]  CSVFormat    char  delimiter  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  emptyLinesIgnored,  lineSeparator,  header)  ;[CE]  constructor  CSVFormat  in  class  CSVFormat  cannot  be  applied  to  given  types;  [CONTEXT]  public  CSVFormat  withDelimiter(char  delimiter)  {  if  (isLineBreak(delimiter))  {  throw  new  IllegalArgumentException( "The  delimiter  cannot  be  a  line  break ");  }  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  emptyLinesIgnored,  lineSeparator,  header)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withDelimiter  [RETURN_TYPE]  CSVFormat    char  delimiter  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  lineSeparator,  header)  ;[CE]  constructor  CSVFormat  in  class  CSVFormat  cannot  be  applied  to  given  types;  [CONTEXT]  public  CSVFormat  withDelimiter(char  delimiter)  {  if  (isLineBreak(delimiter))  {  throw  new  IllegalArgumentException( "The  delimiter  cannot  be  a  line  break ");  }  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  lineSeparator,  header)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withDelimiter  [RETURN_TYPE]  CSVFormat    char  delimiter  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  header)  ;[CE]  constructor  CSVFormat  in  class  CSVFormat  cannot  be  applied  to  given  types;  [CONTEXT]  public  CSVFormat  withDelimiter(char  delimiter)  {  if  (isLineBreak(delimiter))  {  throw  new  IllegalArgumentException( "The  delimiter  cannot  be  a  line  break ");  }  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  header)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withDelimiter  [RETURN_TYPE]  CSVFormat    char  delimiter  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator)  ;[CE]  constructor  CSVFormat  in  class  CSVFormat  cannot  be  applied  to  given  types;  [CONTEXT]  public  CSVFormat  withDelimiter(char  delimiter)  {  if  (isLineBreak(delimiter))  {  throw  new  IllegalArgumentException( "The  delimiter  cannot  be  a  line  break ");  }  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withDelimiter  [RETURN_TYPE]  CSVFormat    char  delimiter  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  escape,  encapsulator,  commentStart,  delimiter,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;[FE]  null  testValidation  [CONTEXT]  public  CSVFormat  withDelimiter(char  delimiter)  {  if  (isLineBreak(delimiter))  {  throw  new  IllegalArgumentException( "The  delimiter  cannot  be  a  line  break ");  }  [BUGGY]  return  new  CSVFormat(  escape,  encapsulator,  commentStart,  delimiter,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withDelimiter  [RETURN_TYPE]  CSVFormat    char  delimiter  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  surroundingSpacesIgnored,  escape,  emptyLinesIgnored,  lineSeparator,  header)  ;[CE]  constructor  CSVFormat  in  class  CSVFormat  cannot  be  applied  to  given  types;  [CONTEXT]  public  CSVFormat  withDelimiter(char  delimiter)  {  if  (isLineBreak(delimiter))  {  throw  new  IllegalArgumentException( "The  delimiter  cannot  be  a  line  break ");  }  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  surroundingSpacesIgnored,  escape,  emptyLinesIgnored,  lineSeparator,  header)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withDelimiter  [RETURN_TYPE]  CSVFormat    char  delimiter  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  lineSeparator,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  delimiter,  header)  ;[CE]  constructor  CSVFormat  in  class  CSVFormat  cannot  be  applied  to  given  types;  [CONTEXT]  public  CSVFormat  withDelimiter(char  delimiter)  {  if  (isLineBreak(delimiter))  {  throw  new  IllegalArgumentException( "The  delimiter  cannot  be  a  line  break ");  }  [BUGGY]  return  new  CSVFormat(  lineSeparator,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  delimiter,  header)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withDelimiter  [RETURN_TYPE]  CSVFormat    char  delimiter  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  header,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  commentStart)  ;[CE]  constructor  CSVFormat  in  class  CSVFormat  cannot  be  applied  to  given  types;  [CONTEXT]  public  CSVFormat  withDelimiter(char  delimiter)  {  if  (isLineBreak(delimiter))  {  throw  new  IllegalArgumentException( "The  delimiter  cannot  be  a  line  break ");  }  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  header,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  commentStart)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withDelimiter  [RETURN_TYPE]  CSVFormat    char  delimiter  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  surroundingSpacesIgnored,  escape,  commentStart,  emptyLinesIgnored,  lineSeparator,  header)  ;[CE]  constructor  CSVFormat  in  class  CSVFormat  cannot  be  applied  to  given  types;  [CONTEXT]  public  CSVFormat  withDelimiter(char  delimiter)  {  if  (isLineBreak(delimiter))  {  throw  new  IllegalArgumentException( "The  delimiter  cannot  be  a  line  break ");  }  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  surroundingSpacesIgnored,  escape,  commentStart,  emptyLinesIgnored,  lineSeparator,  header)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withDelimiter  [RETURN_TYPE]  CSVFormat    char  delimiter  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  header,  lineSeparator,  emptyLinesIgnored)  ;[CE]  constructor  CSVFormat  in  class  CSVFormat  cannot  be  applied  to  given  types;  [CONTEXT]  public  CSVFormat  withDelimiter(char  delimiter)  {  if  (isLineBreak(delimiter))  {  throw  new  IllegalArgumentException( "The  delimiter  cannot  be  a  line  break ");  }  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  header,  lineSeparator,  emptyLinesIgnored)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withDelimiter  [RETURN_TYPE]  CSVFormat    char  delimiter  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  encapsulator;	[BUG]  [BUGGY]  return  escape;[FE]  expected:<[ "x,y "],z>  but  was:<[  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]  public  char  getEncapsulator()  {  [BUGGY]  return  escape;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  getEncapsulator  [RETURN_TYPE]  char    [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  encapsulator;	[BUG]  [BUGGY]  return  delimiter;[FE]  expected:<[ "x,y "],z>  but  was:<[,x,,y,],z>  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]  public  char  getEncapsulator()  {  [BUGGY]  return  delimiter;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  getEncapsulator  [RETURN_TYPE]  char    [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P8_Replace_Mix]
[PATCH]  if  (  isLineBreak  (  encapsulator  )  )  {	[BUG]  [BUGGY]  if  (  isLineBreak(  delimiter)  )  {[FE]  null  testValidation  [CONTEXT]  public  CSVFormat  withEncapsulator(char  encapsulator)  {  [BUGGY]  if  (  isLineBreak(  delimiter)  )  {  [BUGGY]  throw  new  IllegalArgumentException( "The  encapsulator  cannot  be  a  line  break ");  }  return  new  CSVFormat(delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  }    [CLASS]  CSVFormat  [METHOD]  withEncapsulator  [RETURN_TYPE]  CSVFormat    char  encapsulator  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  if  (  isLineBreak  (  encapsulator  )  )  {	[BUG]  [BUGGY]  if  (  withEscape(  encapsulator)  )  {[CE]  incompatible  types  [CONTEXT]  public  CSVFormat  withEncapsulator(char  encapsulator)  {  [BUGGY]  if  (  withEscape(  encapsulator)  )  {  [BUGGY]  throw  new  IllegalArgumentException( "The  encapsulator  cannot  be  a  line  break ");  }  return  new  CSVFormat(delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  }    [CLASS]  CSVFormat  [METHOD]  withEncapsulator  [RETURN_TYPE]  CSVFormat    char  encapsulator  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P7_Replace_Invocation]
[PATCH]  if  (  isLineBreak  (  encapsulator  )  )  {	[BUG]  [BUGGY]  if  (  isLineBreak(  escape)  )  {[FE]  null  testValidation  [CONTEXT]  public  CSVFormat  withEncapsulator(char  encapsulator)  {  [BUGGY]  if  (  isLineBreak(  escape)  )  {  [BUGGY]  throw  new  IllegalArgumentException( "The  encapsulator  cannot  be  a  line  break ");  }  return  new  CSVFormat(delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  }    [CLASS]  CSVFormat  [METHOD]  withEncapsulator  [RETURN_TYPE]  CSVFormat    char  encapsulator  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P8_Replace_Mix]
[PATCH]  if  (  isLineBreak  (  encapsulator  )  )  {	[BUG]  [BUGGY]  if  (  delimiter  ==  encapsulator)  {[FE]  null  testValidation  [CONTEXT]  public  CSVFormat  withEncapsulator(char  encapsulator)  {  [BUGGY]  if  (  delimiter  ==  encapsulator)  {  [BUGGY]  throw  new  IllegalArgumentException( "The  encapsulator  cannot  be  a  line  break ");  }  return  new  CSVFormat(delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  }    [CLASS]  CSVFormat  [METHOD]  withEncapsulator  [RETURN_TYPE]  CSVFormat    char  encapsulator  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P9_Replace_Statement]
[PATCH]  if  (  isLineBreak  (  encapsulator  )  )  {	[BUG]  [BUGGY]  if  (  isLineBreak(  commentStart)  )  {[FE]  null  testValidation  [CONTEXT]  public  CSVFormat  withEncapsulator(char  encapsulator)  {  [BUGGY]  if  (  isLineBreak(  commentStart)  )  {  [BUGGY]  throw  new  IllegalArgumentException( "The  encapsulator  cannot  be  a  line  break ");  }  return  new  CSVFormat(delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  }    [CLASS]  CSVFormat  [METHOD]  withEncapsulator  [RETURN_TYPE]  CSVFormat    char  encapsulator  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P9_Replace_Statement]
[PATCH]  if  (  isLineBreak  (  encapsulator  )  )  {  throw  new  IllegalArgumentException  ( "   ")  ;  }	[BUG]  [BUGGY]  throw  new  java.lang.IllegalArgumentException( "The  encapsulator  cannot  be  a  line  break ");[CE]  ';'  expected  [CONTEXT]  public  CSVFormat  withEncapsulator(char  encapsulator)  {  [BUGGY]  throw  new  java.lang.IllegalArgumentException( "The  encapsulator  cannot  be  a  line  break ");  [BUGGY]    throw  new  java.lang.IllegalArgumentException( "The  encapsulator  cannot  be  a  line  break ");    return  new  CSVFormat(delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);    [CLASS]  CSVFormat  [METHOD]  withEncapsulator  [RETURN_TYPE]  CSVFormat    char  encapsulator  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P15_Unwrap_Block]
[PATCH]  if  (  isLineBreak  (  encapsulator  )  )  {  throw  new  IllegalArgumentException  ( "   ")  ;  }	[BUG]  [BUGGY]  [CE]  ';'  expected  [CONTEXT]  public  CSVFormat  withEncapsulator(char  encapsulator)  {  [BUGGY]  [BUGGY]      return  new  CSVFormat(delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);    [CLASS]  CSVFormat  [METHOD]  withEncapsulator  [RETURN_TYPE]  CSVFormat    char  encapsulator  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P16_Remove_Block]
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  isLineBreak(  commentStart)  )  {      throw  new  IllegalArgumentException(   "The  comment  start  character  cannot  be  a  line  break ")  ;  }[CE]  illegal  start  of  type  [CONTEXT]  public  CSVFormat  withEncapsulator(char  encapsulator)  {  [BUGGY]  if  (  isLineBreak(  commentStart)  )  {      throw  new  IllegalArgumentException(   "The  comment  start  character  cannot  be  a  line  break ")  ;  }  [BUGGY]  throw  new  IllegalArgumentException( "The  encapsulator  cannot  be  a  line  break ");  }  return  new  CSVFormat(delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  }    [CLASS]  CSVFormat  [METHOD]  withEncapsulator  [RETURN_TYPE]  CSVFormat    char  encapsulator  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P13_Insert_Block]
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  (  (  escape)  !=  (  DISABLED)  )  &&  (  (  escape)  ==  (  commentStart)  )  )  {      throw  new  IllegalArgumentException(  (  (   "The  comment  start  and  the  escape  character  cannot  be  the  same  (  \ " "  +  (  commentStart)  )  +   "\ ")   ")  )  ;  }[CE]  illegal  start  of  type  [CONTEXT]  public  CSVFormat  withEncapsulator(char  encapsulator)  {  [BUGGY]  if  (  (  (  escape)  !=  (  DISABLED)  )  &&  (  (  escape)  ==  (  commentStart)  )  )  {      throw  new  IllegalArgumentException(  (  (   "The  comment  start  and  the  escape  character  cannot  be  the  same  (  \ " "  +  (  commentStart)  )  +   "\ ")   ")  )  ;  }  [BUGGY]  throw  new  IllegalArgumentException( "The  encapsulator  cannot  be  a  line  break ");  }  return  new  CSVFormat(delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  }    [CLASS]  CSVFormat  [METHOD]  withEncapsulator  [RETURN_TYPE]  CSVFormat    char  encapsulator  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P13_Insert_Block]
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  isLineBreak(  delimiter)  )  {      throw  new  IllegalArgumentException(   "The  delimiter  cannot  be  a  line  break ")  ;  }[CE]  illegal  start  of  type  [CONTEXT]  public  CSVFormat  withEncapsulator(char  encapsulator)  {  [BUGGY]  if  (  isLineBreak(  delimiter)  )  {      throw  new  IllegalArgumentException(   "The  delimiter  cannot  be  a  line  break ")  ;  }  [BUGGY]  throw  new  IllegalArgumentException( "The  encapsulator  cannot  be  a  line  break ");  }  return  new  CSVFormat(delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  }    [CLASS]  CSVFormat  [METHOD]  withEncapsulator  [RETURN_TYPE]  CSVFormat    char  encapsulator  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P13_Insert_Block]
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  isLineBreak(  escape)  )  {      throw  new  IllegalArgumentException(   "The  escape  character  cannot  be  a  line  break ")  ;  }[CE]  illegal  start  of  type  [CONTEXT]  public  CSVFormat  withEncapsulator(char  encapsulator)  {  [BUGGY]  if  (  isLineBreak(  escape)  )  {      throw  new  IllegalArgumentException(   "The  escape  character  cannot  be  a  line  break ")  ;  }  [BUGGY]  throw  new  IllegalArgumentException( "The  encapsulator  cannot  be  a  line  break ");  }  return  new  CSVFormat(delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  }    [CLASS]  CSVFormat  [METHOD]  withEncapsulator  [RETURN_TYPE]  CSVFormat    char  encapsulator  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P13_Insert_Block]
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  (  (  encapsulator)  !=  (  DISABLED)  )  &&  (  (  encapsulator)  ==  (  commentStart)  )  )  {      throw  new  IllegalArgumentException(  (  (   "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (  \ " "  +  (  commentStart)  )  +   "\ ")   ")  )  ;  }[CE]  illegal  start  of  type  [CONTEXT]  public  CSVFormat  withEncapsulator(char  encapsulator)  {  [BUGGY]  if  (  (  (  encapsulator)  !=  (  DISABLED)  )  &&  (  (  encapsulator)  ==  (  commentStart)  )  )  {      throw  new  IllegalArgumentException(  (  (   "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (  \ " "  +  (  commentStart)  )  +   "\ ")   ")  )  ;  }  [BUGGY]  throw  new  IllegalArgumentException( "The  encapsulator  cannot  be  a  line  break ");  }  return  new  CSVFormat(delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  }    [CLASS]  CSVFormat  [METHOD]  withEncapsulator  [RETURN_TYPE]  CSVFormat    char  encapsulator  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P13_Insert_Block]
[PATCH]  throw  new  IllegalArgumentException  ( "   ")  ;	[BUG]  [BUGGY]  throw  throw  new  IllegalArgumentException(   "The  escape  character  cannot  be  a  line  break ")    ;[CE]  illegal  start  of  expression  [CONTEXT]  public  CSVFormat  withEncapsulator(char  encapsulator)  {  if  (isLineBreak(encapsulator))  {  [BUGGY]  throw  throw  new  IllegalArgumentException(   "The  escape  character  cannot  be  a  line  break ")    ;  [BUGGY]  }  return  new  CSVFormat(delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  }    [CLASS]  CSVFormat  [METHOD]  withEncapsulator  [RETURN_TYPE]  CSVFormat    char  encapsulator  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P4_Replace_Constructor]
[PATCH]  throw  new  IllegalArgumentException  ( "   ")  ;	[BUG]  [BUGGY]  return  0;[CE]  incompatible  types  [CONTEXT]  public  CSVFormat  withEncapsulator(char  encapsulator)  {  if  (isLineBreak(encapsulator))  {  [BUGGY]  return  0;  [BUGGY]  }  return  new  CSVFormat(delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  }    [CLASS]  CSVFormat  [METHOD]  withEncapsulator  [RETURN_TYPE]  CSVFormat    char  encapsulator  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P8_Replace_Mix]
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  isLineBreak(  escape)  )  {      throw  new  IllegalArgumentException(   "The  escape  character  cannot  be  a  line  break ")  ;  }[FE]  null  testValidation  [CONTEXT]  public  CSVFormat  withEncapsulator(char  encapsulator)  {  if  (isLineBreak(encapsulator))  {  [BUGGY]  if  (  isLineBreak(  escape)  )  {      throw  new  IllegalArgumentException(   "The  escape  character  cannot  be  a  line  break ")  ;  }  [BUGGY]  }  return  new  CSVFormat(delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  }    [CLASS]  CSVFormat  [METHOD]  withEncapsulator  [RETURN_TYPE]  CSVFormat    char  encapsulator  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P13_Insert_Block]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  escape,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;[FE]  null  testValidation  [CONTEXT]  public  CSVFormat  withEncapsulator(char  encapsulator)  {  if  (isLineBreak(encapsulator))  {  throw  new  IllegalArgumentException( "The  encapsulator  cannot  be  a  line  break ");  }  [BUGGY]  return  new  CSVFormat(  delimiter,  escape,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withEncapsulator  [RETURN_TYPE]  CSVFormat    char  encapsulator  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  encapsulator,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;[FE]  The  encapsulator  character  and  the  delimiter  cannot  be  the  same  ( "  testValidation  [CONTEXT]  public  CSVFormat  withEncapsulator(char  encapsulator)  {  if  (isLineBreak(encapsulator))  {  throw  new  IllegalArgumentException( "The  encapsulator  cannot  be  a  line  break ");  }  [BUGGY]  return  new  CSVFormat(  encapsulator,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withEncapsulator  [RETURN_TYPE]  CSVFormat    char  encapsulator  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  delimiter,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;[FE]  The  escape  character  and  the  delimiter  cannot  be  the  same  ( ", ")  testValidation  [CONTEXT]  public  CSVFormat  withEncapsulator(char  encapsulator)  {  if  (isLineBreak(encapsulator))  {  throw  new  IllegalArgumentException( "The  encapsulator  cannot  be  a  line  break ");  }  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  delimiter,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withEncapsulator  [RETURN_TYPE]  CSVFormat    char  encapsulator  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;[CE]  constructor  CSVFormat  in  class  CSVFormat  cannot  be  applied  to  given  types;  [CONTEXT]  public  CSVFormat  withEncapsulator(char  encapsulator)  {  if  (isLineBreak(encapsulator))  {  throw  new  IllegalArgumentException( "The  encapsulator  cannot  be  a  line  break ");  }  [BUGGY]  return  new  CSVFormat(  delimiter,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withEncapsulator  [RETURN_TYPE]  CSVFormat    char  encapsulator  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;[CE]  constructor  CSVFormat  in  class  CSVFormat  cannot  be  applied  to  given  types;  [CONTEXT]  public  CSVFormat  withEncapsulator(char  encapsulator)  {  if  (isLineBreak(encapsulator))  {  throw  new  IllegalArgumentException( "The  encapsulator  cannot  be  a  line  break ");  }  [BUGGY]  return  new  CSVFormat(  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withEncapsulator  [RETURN_TYPE]  CSVFormat    char  encapsulator  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;[CE]  constructor  CSVFormat  in  class  CSVFormat  cannot  be  applied  to  given  types;  [CONTEXT]  public  CSVFormat  withEncapsulator(char  encapsulator)  {  if  (isLineBreak(encapsulator))  {  throw  new  IllegalArgumentException( "The  encapsulator  cannot  be  a  line  break ");  }  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withEncapsulator  [RETURN_TYPE]  CSVFormat    char  encapsulator  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;[CE]  constructor  CSVFormat  in  class  CSVFormat  cannot  be  applied  to  given  types;  [CONTEXT]  public  CSVFormat  withEncapsulator(char  encapsulator)  {  if  (isLineBreak(encapsulator))  {  throw  new  IllegalArgumentException( "The  encapsulator  cannot  be  a  line  break ");  }  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withEncapsulator  [RETURN_TYPE]  CSVFormat    char  encapsulator  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  emptyLinesIgnored,  lineSeparator,  header)  ;[CE]  constructor  CSVFormat  in  class  CSVFormat  cannot  be  applied  to  given  types;  [CONTEXT]  public  CSVFormat  withEncapsulator(char  encapsulator)  {  if  (isLineBreak(encapsulator))  {  throw  new  IllegalArgumentException( "The  encapsulator  cannot  be  a  line  break ");  }  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  emptyLinesIgnored,  lineSeparator,  header)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withEncapsulator  [RETURN_TYPE]  CSVFormat    char  encapsulator  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  lineSeparator,  header)  ;[CE]  constructor  CSVFormat  in  class  CSVFormat  cannot  be  applied  to  given  types;  [CONTEXT]  public  CSVFormat  withEncapsulator(char  encapsulator)  {  if  (isLineBreak(encapsulator))  {  throw  new  IllegalArgumentException( "The  encapsulator  cannot  be  a  line  break ");  }  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  lineSeparator,  header)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withEncapsulator  [RETURN_TYPE]  CSVFormat    char  encapsulator  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  header)  ;[CE]  constructor  CSVFormat  in  class  CSVFormat  cannot  be  applied  to  given  types;  [CONTEXT]  public  CSVFormat  withEncapsulator(char  encapsulator)  {  if  (isLineBreak(encapsulator))  {  throw  new  IllegalArgumentException( "The  encapsulator  cannot  be  a  line  break ");  }  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  header)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withEncapsulator  [RETURN_TYPE]  CSVFormat    char  encapsulator  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator)  ;[CE]  constructor  CSVFormat  in  class  CSVFormat  cannot  be  applied  to  given  types;  [CONTEXT]  public  CSVFormat  withEncapsulator(char  encapsulator)  {  if  (isLineBreak(encapsulator))  {  throw  new  IllegalArgumentException( "The  encapsulator  cannot  be  a  line  break ");  }  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withEncapsulator  [RETURN_TYPE]  CSVFormat    char  encapsulator  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  commentStart,  encapsulator,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;[FE]  null  testValidation  [CONTEXT]  public  CSVFormat  withEncapsulator(char  encapsulator)  {  if  (isLineBreak(encapsulator))  {  throw  new  IllegalArgumentException( "The  encapsulator  cannot  be  a  line  break ");  }  [BUGGY]  return  new  CSVFormat(  delimiter,  commentStart,  encapsulator,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withEncapsulator  [RETURN_TYPE]  CSVFormat    char  encapsulator  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  encapsulator,  delimiter,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;[FE]  The  escape  character  and  the  delimiter  cannot  be  the  same  ( "  testValidation  [CONTEXT]  public  CSVFormat  withEncapsulator(char  encapsulator)  {  if  (isLineBreak(encapsulator))  {  throw  new  IllegalArgumentException( "The  encapsulator  cannot  be  a  line  break ");  }  [BUGGY]  return  new  CSVFormat(  encapsulator,  delimiter,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withEncapsulator  [RETURN_TYPE]  CSVFormat    char  encapsulator  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  emptyLinesIgnored,  escape,  surroundingSpacesIgnored,  commentStart,  lineSeparator,  header)  ;[CE]  constructor  CSVFormat  in  class  CSVFormat  cannot  be  applied  to  given  types;  [CONTEXT]  public  CSVFormat  withEncapsulator(char  encapsulator)  {  if  (isLineBreak(encapsulator))  {  throw  new  IllegalArgumentException( "The  encapsulator  cannot  be  a  line  break ");  }  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  emptyLinesIgnored,  escape,  surroundingSpacesIgnored,  commentStart,  lineSeparator,  header)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withEncapsulator  [RETURN_TYPE]  CSVFormat    char  encapsulator  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  escape,  commentStart,  encapsulator,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;[FE]  expected:<[ "x,y "],z>  but  was:<[x ",y],z>  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]  public  CSVFormat  withEncapsulator(char  encapsulator)  {  if  (isLineBreak(encapsulator))  {  throw  new  IllegalArgumentException( "The  encapsulator  cannot  be  a  line  break ");  }  [BUGGY]  return  new  CSVFormat(  delimiter,  escape,  commentStart,  encapsulator,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withEncapsulator  [RETURN_TYPE]  CSVFormat    char  encapsulator  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  surroundingSpacesIgnored,  encapsulator,  commentStart,  escape,  delimiter,  emptyLinesIgnored,  lineSeparator,  header)  ;[CE]  constructor  CSVFormat  in  class  CSVFormat  cannot  be  applied  to  given  types;  [CONTEXT]  public  CSVFormat  withEncapsulator(char  encapsulator)  {  if  (isLineBreak(encapsulator))  {  throw  new  IllegalArgumentException( "The  encapsulator  cannot  be  a  line  break ");  }  [BUGGY]  return  new  CSVFormat(  surroundingSpacesIgnored,  encapsulator,  commentStart,  escape,  delimiter,  emptyLinesIgnored,  lineSeparator,  header)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withEncapsulator  [RETURN_TYPE]  CSVFormat    char  encapsulator  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  lineSeparator,  emptyLinesIgnored,  header)  ;[CE]  constructor  CSVFormat  in  class  CSVFormat  cannot  be  applied  to  given  types;  [CONTEXT]  public  CSVFormat  withEncapsulator(char  encapsulator)  {  if  (isLineBreak(encapsulator))  {  throw  new  IllegalArgumentException( "The  encapsulator  cannot  be  a  line  break ");  }  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  lineSeparator,  emptyLinesIgnored,  header)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withEncapsulator  [RETURN_TYPE]  CSVFormat    char  encapsulator  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  header,  emptyLinesIgnored,  lineSeparator,  surroundingSpacesIgnored)  ;[CE]  constructor  CSVFormat  in  class  CSVFormat  cannot  be  applied  to  given  types;  [CONTEXT]  public  CSVFormat  withEncapsulator(char  encapsulator)  {  if  (isLineBreak(encapsulator))  {  throw  new  IllegalArgumentException( "The  encapsulator  cannot  be  a  line  break ");  }  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  header,  emptyLinesIgnored,  lineSeparator,  surroundingSpacesIgnored)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withEncapsulator  [RETURN_TYPE]  CSVFormat    char  encapsulator  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  escape,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;[FE]  The  encapsulator  character  and  the  delimiter  cannot  be  the  same  ( "  testValidation  [CONTEXT]  public  CSVFormat  withEncapsulator(char  encapsulator)  {  if  (isLineBreak(encapsulator))  {  throw  new  IllegalArgumentException( "The  encapsulator  cannot  be  a  line  break ");  }  [BUGGY]  return  new  CSVFormat(  escape,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withEncapsulator  [RETURN_TYPE]  CSVFormat    char  encapsulator  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P8_Replace_Mix]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  encapsulator,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;[FE]  (startline  0)  EOF  reached  before  encapsulated  token  finished  testNextToken4  assertTokenEquals(EOF,   "b ",  parser.nextToken(new  Token()));  [CONTEXT]  public  CSVFormat  withEncapsulator(char  encapsulator)  {  if  (isLineBreak(encapsulator))  {  throw  new  IllegalArgumentException( "The  encapsulator  cannot  be  a  line  break ");  }  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  encapsulator,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withEncapsulator  [RETURN_TYPE]  CSVFormat    char  encapsulator  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  header,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  commentStart)  ;[CE]  constructor  CSVFormat  in  class  CSVFormat  cannot  be  applied  to  given  types;  [CONTEXT]  public  CSVFormat  withEncapsulator(char  encapsulator)  {  if  (isLineBreak(encapsulator))  {  throw  new  IllegalArgumentException( "The  encapsulator  cannot  be  a  line  break ");  }  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  header,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  commentStart)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withEncapsulator  [RETURN_TYPE]  CSVFormat    char  encapsulator  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  lineSeparator,  emptyLinesIgnored,  surroundingSpacesIgnored,  header)  ;[CE]  constructor  CSVFormat  in  class  CSVFormat  cannot  be  applied  to  given  types;  [CONTEXT]  public  CSVFormat  withEncapsulator(char  encapsulator)  {  if  (isLineBreak(encapsulator))  {  throw  new  IllegalArgumentException( "The  encapsulator  cannot  be  a  line  break ");  }  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  lineSeparator,  emptyLinesIgnored,  surroundingSpacesIgnored,  header)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withEncapsulator  [RETURN_TYPE]  CSVFormat    char  encapsulator  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  emptyLinesIgnored,  surroundingSpacesIgnored,  escape,  lineSeparator,  header)  ;[CE]  constructor  CSVFormat  in  class  CSVFormat  cannot  be  applied  to  given  types;  [CONTEXT]  public  CSVFormat  withEncapsulator(char  encapsulator)  {  if  (isLineBreak(encapsulator))  {  throw  new  IllegalArgumentException( "The  encapsulator  cannot  be  a  line  break ");  }  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  emptyLinesIgnored,  surroundingSpacesIgnored,  escape,  lineSeparator,  header)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withEncapsulator  [RETURN_TYPE]  CSVFormat    char  encapsulator  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  lineSeparator,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  commentStart,  header)  ;[CE]  constructor  CSVFormat  in  class  CSVFormat  cannot  be  applied  to  given  types;  [CONTEXT]  public  CSVFormat  withEncapsulator(char  encapsulator)  {  if  (isLineBreak(encapsulator))  {  throw  new  IllegalArgumentException( "The  encapsulator  cannot  be  a  line  break ");  }  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  lineSeparator,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  commentStart,  header)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withEncapsulator  [RETURN_TYPE]  CSVFormat    char  encapsulator  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  header,  lineSeparator,  emptyLinesIgnored)  ;[CE]  constructor  CSVFormat  in  class  CSVFormat  cannot  be  applied  to  given  types;  [CONTEXT]  public  CSVFormat  withEncapsulator(char  encapsulator)  {  if  (isLineBreak(encapsulator))  {  throw  new  IllegalArgumentException( "The  encapsulator  cannot  be  a  line  break ");  }  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  header,  lineSeparator,  emptyLinesIgnored)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withEncapsulator  [RETURN_TYPE]  CSVFormat    char  encapsulator  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  this.encapsulator  !=  DISABLED;	[BUG]  [BUGGY]  return  this.encapsulator  >=  DISABLED;[FE]  expected:<[ "x,y "],z>  but  was:<[x,y],z>  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]  boolean  isEncapsulating()  {  [BUGGY]  return  this.encapsulator  >=  DISABLED;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  isEncapsulating  [RETURN_TYPE]  boolean    [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P2_Replace_Operator]
[PATCH]  return  this.encapsulator  !=  DISABLED;	[BUG]  [BUGGY]  return  escape  !=  DISABLED;[FE]  expected:<[ "x,y "],z>  but  was:<[x,y],z>  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]  boolean  isEncapsulating()  {  [BUGGY]  return  escape  !=  DISABLED;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  isEncapsulating  [RETURN_TYPE]  boolean    [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  this.encapsulator  !=  DISABLED;	[BUG]  [BUGGY]  return  this.encapsulator  !=  encapsulator;[FE]  expected:<[ "x,y "],z>  but  was:<[x,y],z>  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]  boolean  isEncapsulating()  {  [BUGGY]  return  this.encapsulator  !=  encapsulator;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  isEncapsulating  [RETURN_TYPE]  boolean    [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  this.encapsulator  !=  DISABLED;	[BUG]  [BUGGY]  return  this.encapsulator  ;[CE]  incompatible  types  [CONTEXT]  boolean  isEncapsulating()  {  [BUGGY]  return  this.encapsulator  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  isEncapsulating  [RETURN_TYPE]  boolean    [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P8_Replace_Mix]
[PATCH]  return  commentStart;	[BUG]  [BUGGY]  return  escape;[FE]  expected:<63>  but  was:<33>  testMutators  assertFalse(format.withEmptyLinesIgnored(false).isEmptyLinesIgnored());  [CONTEXT]  public  char  getCommentStart()  {  [BUGGY]  return  escape;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  getCommentStart  [RETURN_TYPE]  char    [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  if  (  isLineBreak  (  commentStart  )  )  {	[BUG]  [BUGGY]  if  (  isLineBreak(  escape)  )  {[FE]  null  testValidation  [CONTEXT]  public  CSVFormat  withCommentStart(char  commentStart)  {  [BUGGY]  if  (  isLineBreak(  escape)  )  {  [BUGGY]  throw  new  IllegalArgumentException( "The  comment  start  character  cannot  be  a  line  break ");  }  return  new  CSVFormat(delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  }    [CLASS]  CSVFormat  [METHOD]  withCommentStart  [RETURN_TYPE]  CSVFormat    char  commentStart  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  if  (  isLineBreak  (  commentStart  )  )  {	[BUG]  [BUGGY]  if  (  withEscape(  commentStart)  )  {[CE]  incompatible  types  [CONTEXT]  public  CSVFormat  withCommentStart(char  commentStart)  {  [BUGGY]  if  (  withEscape(  commentStart)  )  {  [BUGGY]  throw  new  IllegalArgumentException( "The  comment  start  character  cannot  be  a  line  break ");  }  return  new  CSVFormat(delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  }    [CLASS]  CSVFormat  [METHOD]  withCommentStart  [RETURN_TYPE]  CSVFormat    char  commentStart  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P7_Replace_Invocation]
[PATCH]  if  (  isLineBreak  (  commentStart  )  )  {	[BUG]  [BUGGY]  if  (  isLineBreak(  encapsulator)  )  {[FE]  null  testValidation  [CONTEXT]  public  CSVFormat  withCommentStart(char  commentStart)  {  [BUGGY]  if  (  isLineBreak(  encapsulator)  )  {  [BUGGY]  throw  new  IllegalArgumentException( "The  comment  start  character  cannot  be  a  line  break ");  }  return  new  CSVFormat(delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  }    [CLASS]  CSVFormat  [METHOD]  withCommentStart  [RETURN_TYPE]  CSVFormat    char  commentStart  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P8_Replace_Mix]
[PATCH]  if  (  isLineBreak  (  commentStart  )  )  {	[BUG]  [BUGGY]  if  (  delimiter  ==  commentStart)  {[FE]  null  testValidation  [CONTEXT]  public  CSVFormat  withCommentStart(char  commentStart)  {  [BUGGY]  if  (  delimiter  ==  commentStart)  {  [BUGGY]  throw  new  IllegalArgumentException( "The  comment  start  character  cannot  be  a  line  break ");  }  return  new  CSVFormat(delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  }    [CLASS]  CSVFormat  [METHOD]  withCommentStart  [RETURN_TYPE]  CSVFormat    char  commentStart  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P9_Replace_Statement]
[PATCH]  if  (  isLineBreak  (  commentStart  )  )  {	[BUG]  [BUGGY]  if  (  isLineBreak(  delimiter)  )  {[FE]  null  testValidation  [CONTEXT]  public  CSVFormat  withCommentStart(char  commentStart)  {  [BUGGY]  if  (  isLineBreak(  delimiter)  )  {  [BUGGY]  throw  new  IllegalArgumentException( "The  comment  start  character  cannot  be  a  line  break ");  }  return  new  CSVFormat(delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  }    [CLASS]  CSVFormat  [METHOD]  withCommentStart  [RETURN_TYPE]  CSVFormat    char  commentStart  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P9_Replace_Statement]
[PATCH]  if  (  isLineBreak  (  commentStart  )  )  {  throw  new  IllegalArgumentException  ( "   ")  ;  }	[BUG]  [BUGGY]  throw  new  java.lang.IllegalArgumentException( "The  comment  start  character  cannot  be  a  line  break ");[CE]  illegal  start  of  expression  [CONTEXT]  public  CSVFormat  withCommentStart(char  commentStart)  {  [BUGGY]  throw  new  java.lang.IllegalArgumentException( "The  comment  start  character  cannot  be  a  line  break ");  [BUGGY]    throw  new  java.lang.IllegalArgumentException( "The  comment  start  character  cannot  be  a  line  break ");    return  new  CSVFormat(delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);    [CLASS]  CSVFormat  [METHOD]  withCommentStart  [RETURN_TYPE]  CSVFormat    char  commentStart  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P15_Unwrap_Block]
[PATCH]  if  (  isLineBreak  (  commentStart  )  )  {  throw  new  IllegalArgumentException  ( "   ")  ;  }	[BUG]  [BUGGY]  [CE]  illegal  start  of  expression  [CONTEXT]  public  CSVFormat  withCommentStart(char  commentStart)  {  [BUGGY]  [BUGGY]      return  new  CSVFormat(delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);    [CLASS]  CSVFormat  [METHOD]  withCommentStart  [RETURN_TYPE]  CSVFormat    char  commentStart  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P16_Remove_Block]
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  isLineBreak(  encapsulator)  )  {      throw  new  IllegalArgumentException(   "The  encapsulator  cannot  be  a  line  break ")  ;  }[CE]  illegal  start  of  type  [CONTEXT]  public  CSVFormat  withCommentStart(char  commentStart)  {  [BUGGY]  if  (  isLineBreak(  encapsulator)  )  {      throw  new  IllegalArgumentException(   "The  encapsulator  cannot  be  a  line  break ")  ;  }  [BUGGY]  throw  new  IllegalArgumentException( "The  comment  start  character  cannot  be  a  line  break ");  }  return  new  CSVFormat(delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  }    [CLASS]  CSVFormat  [METHOD]  withCommentStart  [RETURN_TYPE]  CSVFormat    char  commentStart  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P13_Insert_Block]
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  (  (  escape)  !=  (  DISABLED)  )  &&  (  (  escape)  ==  (  commentStart)  )  )  {      throw  new  IllegalArgumentException(  (  (   "The  comment  start  and  the  escape  character  cannot  be  the  same  (  \ " "  +  (  commentStart)  )  +   "\ ")   ")  )  ;  }[CE]  illegal  start  of  type  [CONTEXT]  public  CSVFormat  withCommentStart(char  commentStart)  {  [BUGGY]  if  (  (  (  escape)  !=  (  DISABLED)  )  &&  (  (  escape)  ==  (  commentStart)  )  )  {      throw  new  IllegalArgumentException(  (  (   "The  comment  start  and  the  escape  character  cannot  be  the  same  (  \ " "  +  (  commentStart)  )  +   "\ ")   ")  )  ;  }  [BUGGY]  throw  new  IllegalArgumentException( "The  comment  start  character  cannot  be  a  line  break ");  }  return  new  CSVFormat(delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  }    [CLASS]  CSVFormat  [METHOD]  withCommentStart  [RETURN_TYPE]  CSVFormat    char  commentStart  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P13_Insert_Block]
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  isLineBreak(  delimiter)  )  {      throw  new  IllegalArgumentException(   "The  delimiter  cannot  be  a  line  break ")  ;  }[CE]  illegal  start  of  type  [CONTEXT]  public  CSVFormat  withCommentStart(char  commentStart)  {  [BUGGY]  if  (  isLineBreak(  delimiter)  )  {      throw  new  IllegalArgumentException(   "The  delimiter  cannot  be  a  line  break ")  ;  }  [BUGGY]  throw  new  IllegalArgumentException( "The  comment  start  character  cannot  be  a  line  break ");  }  return  new  CSVFormat(delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  }    [CLASS]  CSVFormat  [METHOD]  withCommentStart  [RETURN_TYPE]  CSVFormat    char  commentStart  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P13_Insert_Block]
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  isLineBreak(  escape)  )  {      throw  new  IllegalArgumentException(   "The  escape  character  cannot  be  a  line  break ")  ;  }[CE]  illegal  start  of  type  [CONTEXT]  public  CSVFormat  withCommentStart(char  commentStart)  {  [BUGGY]  if  (  isLineBreak(  escape)  )  {      throw  new  IllegalArgumentException(   "The  escape  character  cannot  be  a  line  break ")  ;  }  [BUGGY]  throw  new  IllegalArgumentException( "The  comment  start  character  cannot  be  a  line  break ");  }  return  new  CSVFormat(delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  }    [CLASS]  CSVFormat  [METHOD]  withCommentStart  [RETURN_TYPE]  CSVFormat    char  commentStart  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P13_Insert_Block]
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  (  (  encapsulator)  !=  (  DISABLED)  )  &&  (  (  encapsulator)  ==  (  commentStart)  )  )  {      throw  new  IllegalArgumentException(  (  (   "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (  \ " "  +  (  commentStart)  )  +   "\ ")   ")  )  ;  }[CE]  illegal  start  of  type  [CONTEXT]  public  CSVFormat  withCommentStart(char  commentStart)  {  [BUGGY]  if  (  (  (  encapsulator)  !=  (  DISABLED)  )  &&  (  (  encapsulator)  ==  (  commentStart)  )  )  {      throw  new  IllegalArgumentException(  (  (   "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (  \ " "  +  (  commentStart)  )  +   "\ ")   ")  )  ;  }  [BUGGY]  throw  new  IllegalArgumentException( "The  comment  start  character  cannot  be  a  line  break ");  }  return  new  CSVFormat(delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  }    [CLASS]  CSVFormat  [METHOD]  withCommentStart  [RETURN_TYPE]  CSVFormat    char  commentStart  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P13_Insert_Block]
[PATCH]  throw  new  IllegalArgumentException  ( "   ")  ;	[BUG]  [BUGGY]  throw  throw  new  IllegalArgumentException(   "The  escape  character  cannot  be  a  line  break ")    ;[CE]  illegal  start  of  expression  [CONTEXT]  public  CSVFormat  withCommentStart(char  commentStart)  {  if  (isLineBreak(commentStart))  {  [BUGGY]  throw  throw  new  IllegalArgumentException(   "The  escape  character  cannot  be  a  line  break ")    ;  [BUGGY]  }  return  new  CSVFormat(delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  }    [CLASS]  CSVFormat  [METHOD]  withCommentStart  [RETURN_TYPE]  CSVFormat    char  commentStart  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P4_Replace_Constructor]
[PATCH]  throw  new  IllegalArgumentException  ( "   ")  ;	[BUG]  [BUGGY]  return  ;[CE]  missing  return  value  [CONTEXT]  public  CSVFormat  withCommentStart(char  commentStart)  {  if  (isLineBreak(commentStart))  {  [BUGGY]  return  ;  [BUGGY]  }  return  new  CSVFormat(delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  }    [CLASS]  CSVFormat  [METHOD]  withCommentStart  [RETURN_TYPE]  CSVFormat    char  commentStart  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P8_Replace_Mix]
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  isLineBreak(  escape)  )  {      throw  new  IllegalArgumentException(   "The  escape  character  cannot  be  a  line  break ")  ;  }[FE]  null  testValidation  [CONTEXT]  public  CSVFormat  withCommentStart(char  commentStart)  {  if  (isLineBreak(commentStart))  {  [BUGGY]  if  (  isLineBreak(  escape)  )  {      throw  new  IllegalArgumentException(   "The  escape  character  cannot  be  a  line  break ")  ;  }  [BUGGY]  }  return  new  CSVFormat(delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  }    [CLASS]  CSVFormat  [METHOD]  withCommentStart  [RETURN_TYPE]  CSVFormat    char  commentStart  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P13_Insert_Block]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  encapsulator,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;[FE]  The  comment  start  character  and  the  encapsulator  cannot  be  the  same  ( " " ")  testValidation  [CONTEXT]  public  CSVFormat  withCommentStart(char  commentStart)  {  if  (isLineBreak(commentStart))  {  throw  new  IllegalArgumentException( "The  comment  start  character  cannot  be  a  line  break ");  }  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  encapsulator,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withCommentStart  [RETURN_TYPE]  CSVFormat    char  commentStart  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  escape,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;[FE]  The  encapsulator  character  and  the  delimiter  cannot  be  the  same  ( "  testValidation  [CONTEXT]  public  CSVFormat  withCommentStart(char  commentStart)  {  if  (isLineBreak(commentStart))  {  throw  new  IllegalArgumentException( "The  comment  start  character  cannot  be  a  line  break ");  }  [BUGGY]  return  new  CSVFormat(  escape,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withCommentStart  [RETURN_TYPE]  CSVFormat    char  commentStart  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  escape,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;[FE]  null  testValidation  [CONTEXT]  public  CSVFormat  withCommentStart(char  commentStart)  {  if  (isLineBreak(commentStart))  {  throw  new  IllegalArgumentException( "The  comment  start  character  cannot  be  a  line  break ");  }  [BUGGY]  return  new  CSVFormat(  delimiter,  escape,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withCommentStart  [RETURN_TYPE]  CSVFormat    char  commentStart  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  delimiter,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;[FE]  The  escape  character  and  the  delimiter  cannot  be  the  same  ( ", ")  testValidation  [CONTEXT]  public  CSVFormat  withCommentStart(char  commentStart)  {  if  (isLineBreak(commentStart))  {  throw  new  IllegalArgumentException( "The  comment  start  character  cannot  be  a  line  break ");  }  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  delimiter,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withCommentStart  [RETURN_TYPE]  CSVFormat    char  commentStart  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;[CE]  constructor  CSVFormat  in  class  CSVFormat  cannot  be  applied  to  given  types;  [CONTEXT]  public  CSVFormat  withCommentStart(char  commentStart)  {  if  (isLineBreak(commentStart))  {  throw  new  IllegalArgumentException( "The  comment  start  character  cannot  be  a  line  break ");  }  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withCommentStart  [RETURN_TYPE]  CSVFormat    char  commentStart  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;[CE]  constructor  CSVFormat  in  class  CSVFormat  cannot  be  applied  to  given  types;  [CONTEXT]  public  CSVFormat  withCommentStart(char  commentStart)  {  if  (isLineBreak(commentStart))  {  throw  new  IllegalArgumentException( "The  comment  start  character  cannot  be  a  line  break ");  }  [BUGGY]  return  new  CSVFormat(  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withCommentStart  [RETURN_TYPE]  CSVFormat    char  commentStart  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;[CE]  constructor  CSVFormat  in  class  CSVFormat  cannot  be  applied  to  given  types;  [CONTEXT]  public  CSVFormat  withCommentStart(char  commentStart)  {  if  (isLineBreak(commentStart))  {  throw  new  IllegalArgumentException( "The  comment  start  character  cannot  be  a  line  break ");  }  [BUGGY]  return  new  CSVFormat(  delimiter,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withCommentStart  [RETURN_TYPE]  CSVFormat    char  commentStart  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;[CE]  constructor  CSVFormat  in  class  CSVFormat  cannot  be  applied  to  given  types;  [CONTEXT]  public  CSVFormat  withCommentStart(char  commentStart)  {  if  (isLineBreak(commentStart))  {  throw  new  IllegalArgumentException( "The  comment  start  character  cannot  be  a  line  break ");  }  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withCommentStart  [RETURN_TYPE]  CSVFormat    char  commentStart  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  emptyLinesIgnored,  lineSeparator,  header)  ;[CE]  constructor  CSVFormat  in  class  CSVFormat  cannot  be  applied  to  given  types;  [CONTEXT]  public  CSVFormat  withCommentStart(char  commentStart)  {  if  (isLineBreak(commentStart))  {  throw  new  IllegalArgumentException( "The  comment  start  character  cannot  be  a  line  break ");  }  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  emptyLinesIgnored,  lineSeparator,  header)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withCommentStart  [RETURN_TYPE]  CSVFormat    char  commentStart  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  lineSeparator,  header)  ;[CE]  constructor  CSVFormat  in  class  CSVFormat  cannot  be  applied  to  given  types;  [CONTEXT]  public  CSVFormat  withCommentStart(char  commentStart)  {  if  (isLineBreak(commentStart))  {  throw  new  IllegalArgumentException( "The  comment  start  character  cannot  be  a  line  break ");  }  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  lineSeparator,  header)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withCommentStart  [RETURN_TYPE]  CSVFormat    char  commentStart  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  header)  ;[CE]  constructor  CSVFormat  in  class  CSVFormat  cannot  be  applied  to  given  types;  [CONTEXT]  public  CSVFormat  withCommentStart(char  commentStart)  {  if  (isLineBreak(commentStart))  {  throw  new  IllegalArgumentException( "The  comment  start  character  cannot  be  a  line  break ");  }  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  header)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withCommentStart  [RETURN_TYPE]  CSVFormat    char  commentStart  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator)  ;[CE]  constructor  CSVFormat  in  class  CSVFormat  cannot  be  applied  to  given  types;  [CONTEXT]  public  CSVFormat  withCommentStart(char  commentStart)  {  if  (isLineBreak(commentStart))  {  throw  new  IllegalArgumentException( "The  comment  start  character  cannot  be  a  line  break ");  }  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withCommentStart  [RETURN_TYPE]  CSVFormat    char  commentStart  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  lineSeparator,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  commentStart,  header)  ;[CE]  constructor  CSVFormat  in  class  CSVFormat  cannot  be  applied  to  given  types;  [CONTEXT]  public  CSVFormat  withCommentStart(char  commentStart)  {  if  (isLineBreak(commentStart))  {  throw  new  IllegalArgumentException( "The  comment  start  character  cannot  be  a  line  break ");  }  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  lineSeparator,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  commentStart,  header)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withCommentStart  [RETURN_TYPE]  CSVFormat    char  commentStart  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  encapsulator,  delimiter,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;[FE]  The  escape  character  and  the  delimiter  cannot  be  the  same  ( "  testValidation  [CONTEXT]  public  CSVFormat  withCommentStart(char  commentStart)  {  if  (isLineBreak(commentStart))  {  throw  new  IllegalArgumentException( "The  comment  start  character  cannot  be  a  line  break ");  }  [BUGGY]  return  new  CSVFormat(  encapsulator,  delimiter,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withCommentStart  [RETURN_TYPE]  CSVFormat    char  commentStart  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  header,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  encapsulator)  ;[CE]  constructor  CSVFormat  in  class  CSVFormat  cannot  be  applied  to  given  types;  [CONTEXT]  public  CSVFormat  withCommentStart(char  commentStart)  {  if  (isLineBreak(commentStart))  {  throw  new  IllegalArgumentException( "The  comment  start  character  cannot  be  a  line  break ");  }  [BUGGY]  return  new  CSVFormat(  delimiter,  header,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  encapsulator)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withCommentStart  [RETURN_TYPE]  CSVFormat    char  commentStart  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  escape,  commentStart,  encapsulator,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;[FE]  Token  content  expected:<[b  and  '  more  testNextToken6  assertTokenEquals(EORECORD,   "b  and  '  more\n ",  parser.nextToken(new  Token()));  [CONTEXT]  public  CSVFormat  withCommentStart(char  commentStart)  {  if  (isLineBreak(commentStart))  {  throw  new  IllegalArgumentException( "The  comment  start  character  cannot  be  a  line  break ");  }  [BUGGY]  return  new  CSVFormat(  delimiter,  escape,  commentStart,  encapsulator,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withCommentStart  [RETURN_TYPE]  CSVFormat    char  commentStart  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  emptyLinesIgnored,  surroundingSpacesIgnored,  lineSeparator,  header)  ;[FE]  Token  type  expected:<EOF>  but  was:<EORECORD>  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  CSVFormat  withCommentStart(char  commentStart)  {  if  (isLineBreak(commentStart))  {  throw  new  IllegalArgumentException( "The  comment  start  character  cannot  be  a  line  break ");  }  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  emptyLinesIgnored,  surroundingSpacesIgnored,  lineSeparator,  header)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withCommentStart  [RETURN_TYPE]  CSVFormat    char  commentStart  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  header,  lineSeparator)  ;[CE]  constructor  CSVFormat  in  class  CSVFormat  cannot  be  applied  to  given  types;  [CONTEXT]  public  CSVFormat  withCommentStart(char  commentStart)  {  if  (isLineBreak(commentStart))  {  throw  new  IllegalArgumentException( "The  comment  start  character  cannot  be  a  line  break ");  }  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  header,  lineSeparator)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withCommentStart  [RETURN_TYPE]  CSVFormat    char  commentStart  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  header,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  delimiter)  ;[CE]  constructor  CSVFormat  in  class  CSVFormat  cannot  be  applied  to  given  types;  [CONTEXT]  public  CSVFormat  withCommentStart(char  commentStart)  {  if  (isLineBreak(commentStart))  {  throw  new  IllegalArgumentException( "The  comment  start  character  cannot  be  a  line  break ");  }  [BUGGY]  return  new  CSVFormat(  header,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  delimiter)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withCommentStart  [RETURN_TYPE]  CSVFormat    char  commentStart  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  encapsulator,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;[FE]  null  testValidation  [CONTEXT]  public  CSVFormat  withCommentStart(char  commentStart)  {  if  (isLineBreak(commentStart))  {  throw  new  IllegalArgumentException( "The  comment  start  character  cannot  be  a  line  break ");  }  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  encapsulator,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withCommentStart  [RETURN_TYPE]  CSVFormat    char  commentStart  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P8_Replace_Mix]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  encapsulator,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;[FE]  The  encapsulator  character  and  the  delimiter  cannot  be  the  same  ( "  testValidation  [CONTEXT]  public  CSVFormat  withCommentStart(char  commentStart)  {  if  (isLineBreak(commentStart))  {  throw  new  IllegalArgumentException( "The  comment  start  character  cannot  be  a  line  break ");  }  [BUGGY]  return  new  CSVFormat(  encapsulator,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withCommentStart  [RETURN_TYPE]  CSVFormat    char  commentStart  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  surroundingSpacesIgnored,  lineSeparator,  header)  ;[FE]  Token  type  expected:<EOF>  but  was:<EORECORD>  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  CSVFormat  withCommentStart(char  commentStart)  {  if  (isLineBreak(commentStart))  {  throw  new  IllegalArgumentException( "The  comment  start  character  cannot  be  a  line  break ");  }  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  surroundingSpacesIgnored,  lineSeparator,  header)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withCommentStart  [RETURN_TYPE]  CSVFormat    char  commentStart  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  commentStart,  encapsulator,  delimiter,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;[FE]  The  encapsulator  character  and  the  delimiter  cannot  be  the  same  ( "  testValidation  [CONTEXT]  public  CSVFormat  withCommentStart(char  commentStart)  {  if  (isLineBreak(commentStart))  {  throw  new  IllegalArgumentException( "The  comment  start  character  cannot  be  a  line  break ");  }  [BUGGY]  return  new  CSVFormat(  commentStart,  encapsulator,  delimiter,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withCommentStart  [RETURN_TYPE]  CSVFormat    char  commentStart  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  escape,  commentStart,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;[FE]  null  testValidation  [CONTEXT]  public  CSVFormat  withCommentStart(char  commentStart)  {  if  (isLineBreak(commentStart))  {  throw  new  IllegalArgumentException( "The  comment  start  character  cannot  be  a  line  break ");  }  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  escape,  commentStart,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withCommentStart  [RETURN_TYPE]  CSVFormat    char  commentStart  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  emptyLinesIgnored,  surroundingSpacesIgnored,  escape,  lineSeparator,  header)  ;[CE]  constructor  CSVFormat  in  class  CSVFormat  cannot  be  applied  to  given  types;  [CONTEXT]  public  CSVFormat  withCommentStart(char  commentStart)  {  if  (isLineBreak(commentStart))  {  throw  new  IllegalArgumentException( "The  comment  start  character  cannot  be  a  line  break ");  }  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  emptyLinesIgnored,  surroundingSpacesIgnored,  escape,  lineSeparator,  header)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withCommentStart  [RETURN_TYPE]  CSVFormat    char  commentStart  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  lineSeparator,  emptyLinesIgnored,  surroundingSpacesIgnored,  header)  ;[CE]  constructor  CSVFormat  in  class  CSVFormat  cannot  be  applied  to  given  types;  [CONTEXT]  public  CSVFormat  withCommentStart(char  commentStart)  {  if  (isLineBreak(commentStart))  {  throw  new  IllegalArgumentException( "The  comment  start  character  cannot  be  a  line  break ");  }  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  lineSeparator,  emptyLinesIgnored,  surroundingSpacesIgnored,  header)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withCommentStart  [RETURN_TYPE]  CSVFormat    char  commentStart  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  escape,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;[FE]  null  testValidation  [CONTEXT]  public  CSVFormat  withCommentStart(char  commentStart)  {  if  (isLineBreak(commentStart))  {  throw  new  IllegalArgumentException( "The  comment  start  character  cannot  be  a  line  break ");  }  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  escape,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withCommentStart  [RETURN_TYPE]  CSVFormat    char  commentStart  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P8_Replace_Mix]
[PATCH]  return  this.commentStart  !=  DISABLED;	[BUG]  [BUGGY]  return  this.commentStart  >=  DISABLED;[FE]  Token  content  expected:<[]>  but  was:<[#foo]>  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  boolean  isCommentingEnabled()  {  [BUGGY]  return  this.commentStart  >=  DISABLED;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  isCommentingEnabled  [RETURN_TYPE]  boolean    [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P2_Replace_Operator]
[PATCH]  return  this.commentStart  !=  DISABLED;	[BUG]  [BUGGY]  return  this.commentStart  !=  encapsulator;[FE]  expected:<[]>  but  was:<[  testDisabledComment  assertEquals( " ",  sw.toString());  [CONTEXT]  public  boolean  isCommentingEnabled()  {  [BUGGY]  return  this.commentStart  !=  encapsulator;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  isCommentingEnabled  [RETURN_TYPE]  boolean    [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  this.commentStart  !=  DISABLED;	[BUG]  [BUGGY]  returnescape  ;[CE]  not  a  statement  [CONTEXT]  public  boolean  isCommentingEnabled()  {  [BUGGY]  returnescape  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  isCommentingEnabled  [RETURN_TYPE]  boolean    [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P8_Replace_Mix]
[PATCH]  return  escape;	[BUG]  [BUGGY]  return  delimiter;[FE]  expected:<63>  but  was:<33>  testMutators  assertFalse(format.withEmptyLinesIgnored(false).isEmptyLinesIgnored());  [CONTEXT]  public  char  getEscape()  {  [BUGGY]  return  delimiter;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  getEscape  [RETURN_TYPE]  char    [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  escape;	[BUG]  [BUGGY]  return  encapsulator;[FE]  expected:<63>  but  was:<33>  testMutators  assertFalse(format.withEmptyLinesIgnored(false).isEmptyLinesIgnored());  [CONTEXT]  public  char  getEscape()  {  [BUGGY]  return  encapsulator;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  getEscape  [RETURN_TYPE]  char    [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P8_Replace_Mix]
[PATCH]  if  (  isLineBreak  (  escape  )  )  {	[BUG]  [BUGGY]  if  (  isLineBreak(  encapsulator)  )  {[FE]  null  testValidation  [CONTEXT]  public  CSVFormat  withEscape(char  escape)  {  [BUGGY]  if  (  isLineBreak(  encapsulator)  )  {  [BUGGY]  throw  new  IllegalArgumentException( "The  escape  character  cannot  be  a  line  break ");  }  return  new  CSVFormat(delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  }    [CLASS]  CSVFormat  [METHOD]  withEscape  [RETURN_TYPE]  CSVFormat    char  escape  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  if  (  isLineBreak  (  escape  )  )  {	[BUG]  [BUGGY]  if  (  withEscape(  escape)  )  {[CE]  incompatible  types  [CONTEXT]  public  CSVFormat  withEscape(char  escape)  {  [BUGGY]  if  (  withEscape(  escape)  )  {  [BUGGY]  throw  new  IllegalArgumentException( "The  escape  character  cannot  be  a  line  break ");  }  return  new  CSVFormat(delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  }    [CLASS]  CSVFormat  [METHOD]  withEscape  [RETURN_TYPE]  CSVFormat    char  escape  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P7_Replace_Invocation]
[PATCH]  if  (  isLineBreak  (  escape  )  )  {	[BUG]  [BUGGY]  if  (  isLineBreak(  delimiter)  )  {[FE]  null  testValidation  [CONTEXT]  public  CSVFormat  withEscape(char  escape)  {  [BUGGY]  if  (  isLineBreak(  delimiter)  )  {  [BUGGY]  throw  new  IllegalArgumentException( "The  escape  character  cannot  be  a  line  break ");  }  return  new  CSVFormat(delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  }    [CLASS]  CSVFormat  [METHOD]  withEscape  [RETURN_TYPE]  CSVFormat    char  escape  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P9_Replace_Statement]
[PATCH]  if  (  isLineBreak  (  escape  )  )  {	[BUG]  [BUGGY]  if  (  isLineBreak(  commentStart)  )  {[FE]  null  testValidation  [CONTEXT]  public  CSVFormat  withEscape(char  escape)  {  [BUGGY]  if  (  isLineBreak(  commentStart)  )  {  [BUGGY]  throw  new  IllegalArgumentException( "The  escape  character  cannot  be  a  line  break ");  }  return  new  CSVFormat(delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  }    [CLASS]  CSVFormat  [METHOD]  withEscape  [RETURN_TYPE]  CSVFormat    char  escape  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P9_Replace_Statement]
[PATCH]  if  (  isLineBreak  (  escape  )  )  {  throw  new  IllegalArgumentException  ( "   ")  ;  }	[BUG]  [BUGGY]  throw  new  java.lang.IllegalArgumentException( "The  escape  character  cannot  be  a  line  break ");[CE]  ';'  expected  [CONTEXT]  public  CSVFormat  withEscape(char  escape)  {  [BUGGY]  throw  new  java.lang.IllegalArgumentException( "The  escape  character  cannot  be  a  line  break ");  [BUGGY]    throw  new  java.lang.IllegalArgumentException( "The  escape  character  cannot  be  a  line  break ");    return  new  CSVFormat(delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);    [CLASS]  CSVFormat  [METHOD]  withEscape  [RETURN_TYPE]  CSVFormat    char  escape  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P15_Unwrap_Block]
[PATCH]  if  (  isLineBreak  (  escape  )  )  {  throw  new  IllegalArgumentException  ( "   ")  ;  }	[BUG]  [BUGGY]  [CE]  ';'  expected  [CONTEXT]  public  CSVFormat  withEscape(char  escape)  {  [BUGGY]  [BUGGY]      return  new  CSVFormat(delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);    [CLASS]  CSVFormat  [METHOD]  withEscape  [RETURN_TYPE]  CSVFormat    char  escape  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P16_Remove_Block]
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  isLineBreak(  commentStart)  )  {      throw  new  IllegalArgumentException(   "The  comment  start  character  cannot  be  a  line  break ")  ;  }[CE]  illegal  start  of  type  [CONTEXT]  public  CSVFormat  withEscape(char  escape)  {  [BUGGY]  if  (  isLineBreak(  commentStart)  )  {      throw  new  IllegalArgumentException(   "The  comment  start  character  cannot  be  a  line  break ")  ;  }  [BUGGY]  throw  new  IllegalArgumentException( "The  escape  character  cannot  be  a  line  break ");  }  return  new  CSVFormat(delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  }    [CLASS]  CSVFormat  [METHOD]  withEscape  [RETURN_TYPE]  CSVFormat    char  escape  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P13_Insert_Block]
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  isLineBreak(  encapsulator)  )  {      throw  new  IllegalArgumentException(   "The  encapsulator  cannot  be  a  line  break ")  ;  }[CE]  illegal  start  of  type  [CONTEXT]  public  CSVFormat  withEscape(char  escape)  {  [BUGGY]  if  (  isLineBreak(  encapsulator)  )  {      throw  new  IllegalArgumentException(   "The  encapsulator  cannot  be  a  line  break ")  ;  }  [BUGGY]  throw  new  IllegalArgumentException( "The  escape  character  cannot  be  a  line  break ");  }  return  new  CSVFormat(delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  }    [CLASS]  CSVFormat  [METHOD]  withEscape  [RETURN_TYPE]  CSVFormat    char  escape  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P13_Insert_Block]
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  (  (  escape)  !=  (  DISABLED)  )  &&  (  (  escape)  ==  (  commentStart)  )  )  {      throw  new  IllegalArgumentException(  (  (   "The  comment  start  and  the  escape  character  cannot  be  the  same  (  \ " "  +  (  commentStart)  )  +   "\ ")   ")  )  ;  }[CE]  illegal  start  of  type  [CONTEXT]  public  CSVFormat  withEscape(char  escape)  {  [BUGGY]  if  (  (  (  escape)  !=  (  DISABLED)  )  &&  (  (  escape)  ==  (  commentStart)  )  )  {      throw  new  IllegalArgumentException(  (  (   "The  comment  start  and  the  escape  character  cannot  be  the  same  (  \ " "  +  (  commentStart)  )  +   "\ ")   ")  )  ;  }  [BUGGY]  throw  new  IllegalArgumentException( "The  escape  character  cannot  be  a  line  break ");  }  return  new  CSVFormat(delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  }    [CLASS]  CSVFormat  [METHOD]  withEscape  [RETURN_TYPE]  CSVFormat    char  escape  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P13_Insert_Block]
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  isLineBreak(  delimiter)  )  {      throw  new  IllegalArgumentException(   "The  delimiter  cannot  be  a  line  break ")  ;  }[CE]  illegal  start  of  type  [CONTEXT]  public  CSVFormat  withEscape(char  escape)  {  [BUGGY]  if  (  isLineBreak(  delimiter)  )  {      throw  new  IllegalArgumentException(   "The  delimiter  cannot  be  a  line  break ")  ;  }  [BUGGY]  throw  new  IllegalArgumentException( "The  escape  character  cannot  be  a  line  break ");  }  return  new  CSVFormat(delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  }    [CLASS]  CSVFormat  [METHOD]  withEscape  [RETURN_TYPE]  CSVFormat    char  escape  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P13_Insert_Block]
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  (  (  encapsulator)  !=  (  DISABLED)  )  &&  (  (  encapsulator)  ==  (  commentStart)  )  )  {      throw  new  IllegalArgumentException(  (  (   "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (  \ " "  +  (  commentStart)  )  +   "\ ")   ")  )  ;  }[CE]  illegal  start  of  type  [CONTEXT]  public  CSVFormat  withEscape(char  escape)  {  [BUGGY]  if  (  (  (  encapsulator)  !=  (  DISABLED)  )  &&  (  (  encapsulator)  ==  (  commentStart)  )  )  {      throw  new  IllegalArgumentException(  (  (   "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (  \ " "  +  (  commentStart)  )  +   "\ ")   ")  )  ;  }  [BUGGY]  throw  new  IllegalArgumentException( "The  escape  character  cannot  be  a  line  break ");  }  return  new  CSVFormat(delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  }    [CLASS]  CSVFormat  [METHOD]  withEscape  [RETURN_TYPE]  CSVFormat    char  escape  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P13_Insert_Block]
[PATCH]  throw  new  IllegalArgumentException  ( "   ")  ;	[BUG]  [BUGGY]  throw  throw  new  IllegalArgumentException(   "The  comment  start  character  cannot  be  a  line  break ")    ;[CE]  illegal  start  of  expression  [CONTEXT]  public  CSVFormat  withEscape(char  escape)  {  if  (isLineBreak(escape))  {  [BUGGY]  throw  throw  new  IllegalArgumentException(   "The  comment  start  character  cannot  be  a  line  break ")    ;  [BUGGY]  }  return  new  CSVFormat(delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  }    [CLASS]  CSVFormat  [METHOD]  withEscape  [RETURN_TYPE]  CSVFormat    char  escape  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P4_Replace_Constructor]
[PATCH]  throw  new  IllegalArgumentException  ( "   ")  ;	[BUG]  [BUGGY]  return  ;[CE]  missing  return  value  [CONTEXT]  public  CSVFormat  withEscape(char  escape)  {  if  (isLineBreak(escape))  {  [BUGGY]  return  ;  [BUGGY]  }  return  new  CSVFormat(delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  }    [CLASS]  CSVFormat  [METHOD]  withEscape  [RETURN_TYPE]  CSVFormat    char  escape  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P8_Replace_Mix]
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  isLineBreak(  commentStart)  )  {      throw  new  IllegalArgumentException(   "The  comment  start  character  cannot  be  a  line  break ")  ;  }[FE]  null  testValidation  [CONTEXT]  public  CSVFormat  withEscape(char  escape)  {  if  (isLineBreak(escape))  {  [BUGGY]  if  (  isLineBreak(  commentStart)  )  {      throw  new  IllegalArgumentException(   "The  comment  start  character  cannot  be  a  line  break ")  ;  }  [BUGGY]  }  return  new  CSVFormat(delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  }    [CLASS]  CSVFormat  [METHOD]  withEscape  [RETURN_TYPE]  CSVFormat    char  escape  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P13_Insert_Block]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  delimiter,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;[FE]  The  escape  character  and  the  delimiter  cannot  be  the  same  ( ", ")  testValidation  [CONTEXT]  public  CSVFormat  withEscape(char  escape)  {  if  (isLineBreak(escape))  {  throw  new  IllegalArgumentException( "The  escape  character  cannot  be  a  line  break ");  }  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  delimiter,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withEscape  [RETURN_TYPE]  CSVFormat    char  escape  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  escape,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;[FE]  The  escape  character  and  the  delimiter  cannot  be  the  same  ( "  testValidation  [CONTEXT]  public  CSVFormat  withEscape(char  escape)  {  if  (isLineBreak(escape))  {  throw  new  IllegalArgumentException( "The  escape  character  cannot  be  a  line  break ");  }  [BUGGY]  return  new  CSVFormat(  escape,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withEscape  [RETURN_TYPE]  CSVFormat    char  escape  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  escape,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;[FE]  The  comment  start  and  the  escape  character  cannot  be  the  same  ( "  testRandom  [CONTEXT]  public  CSVFormat  withEscape(char  escape)  {  if  (isLineBreak(escape))  {  throw  new  IllegalArgumentException( "The  escape  character  cannot  be  a  line  break ");  }  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  escape,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withEscape  [RETURN_TYPE]  CSVFormat    char  escape  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;[CE]  constructor  CSVFormat  in  class  CSVFormat  cannot  be  applied  to  given  types;  [CONTEXT]  public  CSVFormat  withEscape(char  escape)  {  if  (isLineBreak(escape))  {  throw  new  IllegalArgumentException( "The  escape  character  cannot  be  a  line  break ");  }  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withEscape  [RETURN_TYPE]  CSVFormat    char  escape  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;[CE]  constructor  CSVFormat  in  class  CSVFormat  cannot  be  applied  to  given  types;  [CONTEXT]  public  CSVFormat  withEscape(char  escape)  {  if  (isLineBreak(escape))  {  throw  new  IllegalArgumentException( "The  escape  character  cannot  be  a  line  break ");  }  [BUGGY]  return  new  CSVFormat(  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withEscape  [RETURN_TYPE]  CSVFormat    char  escape  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;[CE]  constructor  CSVFormat  in  class  CSVFormat  cannot  be  applied  to  given  types;  [CONTEXT]  public  CSVFormat  withEscape(char  escape)  {  if  (isLineBreak(escape))  {  throw  new  IllegalArgumentException( "The  escape  character  cannot  be  a  line  break ");  }  [BUGGY]  return  new  CSVFormat(  delimiter,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withEscape  [RETURN_TYPE]  CSVFormat    char  escape  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;[CE]  constructor  CSVFormat  in  class  CSVFormat  cannot  be  applied  to  given  types;  [CONTEXT]  public  CSVFormat  withEscape(char  escape)  {  if  (isLineBreak(escape))  {  throw  new  IllegalArgumentException( "The  escape  character  cannot  be  a  line  break ");  }  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withEscape  [RETURN_TYPE]  CSVFormat    char  escape  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  emptyLinesIgnored,  lineSeparator,  header)  ;[CE]  constructor  CSVFormat  in  class  CSVFormat  cannot  be  applied  to  given  types;  [CONTEXT]  public  CSVFormat  withEscape(char  escape)  {  if  (isLineBreak(escape))  {  throw  new  IllegalArgumentException( "The  escape  character  cannot  be  a  line  break ");  }  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  emptyLinesIgnored,  lineSeparator,  header)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withEscape  [RETURN_TYPE]  CSVFormat    char  escape  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  lineSeparator,  header)  ;[CE]  constructor  CSVFormat  in  class  CSVFormat  cannot  be  applied  to  given  types;  [CONTEXT]  public  CSVFormat  withEscape(char  escape)  {  if  (isLineBreak(escape))  {  throw  new  IllegalArgumentException( "The  escape  character  cannot  be  a  line  break ");  }  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  lineSeparator,  header)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withEscape  [RETURN_TYPE]  CSVFormat    char  escape  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  header)  ;[CE]  constructor  CSVFormat  in  class  CSVFormat  cannot  be  applied  to  given  types;  [CONTEXT]  public  CSVFormat  withEscape(char  escape)  {  if  (isLineBreak(escape))  {  throw  new  IllegalArgumentException( "The  escape  character  cannot  be  a  line  break ");  }  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  header)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withEscape  [RETURN_TYPE]  CSVFormat    char  escape  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator)  ;[CE]  constructor  CSVFormat  in  class  CSVFormat  cannot  be  applied  to  given  types;  [CONTEXT]  public  CSVFormat  withEscape(char  escape)  {  if  (isLineBreak(escape))  {  throw  new  IllegalArgumentException( "The  escape  character  cannot  be  a  line  break ");  }  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withEscape  [RETURN_TYPE]  CSVFormat    char  escape  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  escape,  commentStart,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;[FE]  null  testValidation  [CONTEXT]  public  CSVFormat  withEscape(char  escape)  {  if  (isLineBreak(escape))  {  throw  new  IllegalArgumentException( "The  escape  character  cannot  be  a  line  break ");  }  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  escape,  commentStart,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withEscape  [RETURN_TYPE]  CSVFormat    char  escape  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  commentStart,  encapsulator,  delimiter,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;[FE]  The  escape  character  and  the  delimiter  cannot  be  the  same  ( "  testValidation  [CONTEXT]  public  CSVFormat  withEscape(char  escape)  {  if  (isLineBreak(escape))  {  throw  new  IllegalArgumentException( "The  escape  character  cannot  be  a  line  break ");  }  [BUGGY]  return  new  CSVFormat(  commentStart,  encapsulator,  delimiter,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withEscape  [RETURN_TYPE]  CSVFormat    char  escape  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  emptyLinesIgnored,  escape,  surroundingSpacesIgnored,  commentStart,  lineSeparator,  header)  ;[CE]  constructor  CSVFormat  in  class  CSVFormat  cannot  be  applied  to  given  types;  [CONTEXT]  public  CSVFormat  withEscape(char  escape)  {  if  (isLineBreak(escape))  {  throw  new  IllegalArgumentException( "The  escape  character  cannot  be  a  line  break ");  }  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  emptyLinesIgnored,  escape,  surroundingSpacesIgnored,  commentStart,  lineSeparator,  header)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withEscape  [RETURN_TYPE]  CSVFormat    char  escape  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  lineSeparator,  emptyLinesIgnored,  surroundingSpacesIgnored,  header)  ;[CE]  constructor  CSVFormat  in  class  CSVFormat  cannot  be  applied  to  given  types;  [CONTEXT]  public  CSVFormat  withEscape(char  escape)  {  if  (isLineBreak(escape))  {  throw  new  IllegalArgumentException( "The  escape  character  cannot  be  a  line  break ");  }  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  lineSeparator,  emptyLinesIgnored,  surroundingSpacesIgnored,  header)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withEscape  [RETURN_TYPE]  CSVFormat    char  escape  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  header,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  encapsulator)  ;[CE]  constructor  CSVFormat  in  class  CSVFormat  cannot  be  applied  to  given  types;  [CONTEXT]  public  CSVFormat  withEscape(char  escape)  {  if  (isLineBreak(escape))  {  throw  new  IllegalArgumentException( "The  escape  character  cannot  be  a  line  break ");  }  [BUGGY]  return  new  CSVFormat(  delimiter,  header,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  encapsulator)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withEscape  [RETURN_TYPE]  CSVFormat    char  escape  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  delimiter,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;[FE]  The  encapsulator  character  and  the  delimiter  cannot  be  the  same  ( ", ")  testValidation  [CONTEXT]  public  CSVFormat  withEscape(char  escape)  {  if  (isLineBreak(escape))  {  throw  new  IllegalArgumentException( "The  escape  character  cannot  be  a  line  break ");  }  [BUGGY]  return  new  CSVFormat(  delimiter,  delimiter,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withEscape  [RETURN_TYPE]  CSVFormat    char  escape  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  emptyLinesIgnored,  surroundingSpacesIgnored,  escape,  lineSeparator,  header)  ;[CE]  constructor  CSVFormat  in  class  CSVFormat  cannot  be  applied  to  given  types;  [CONTEXT]  public  CSVFormat  withEscape(char  escape)  {  if  (isLineBreak(escape))  {  throw  new  IllegalArgumentException( "The  escape  character  cannot  be  a  line  break ");  }  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  emptyLinesIgnored,  surroundingSpacesIgnored,  escape,  lineSeparator,  header)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withEscape  [RETURN_TYPE]  CSVFormat    char  escape  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  encapsulator,  delimiter,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;[FE]  null  testValidation  [CONTEXT]  public  CSVFormat  withEscape(char  escape)  {  if  (isLineBreak(escape))  {  throw  new  IllegalArgumentException( "The  escape  character  cannot  be  a  line  break ");  }  [BUGGY]  return  new  CSVFormat(  encapsulator,  delimiter,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withEscape  [RETURN_TYPE]  CSVFormat    char  escape  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  lineSeparator,  emptyLinesIgnored,  header)  ;[CE]  constructor  CSVFormat  in  class  CSVFormat  cannot  be  applied  to  given  types;  [CONTEXT]  public  CSVFormat  withEscape(char  escape)  {  if  (isLineBreak(escape))  {  throw  new  IllegalArgumentException( "The  escape  character  cannot  be  a  line  break ");  }  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  lineSeparator,  emptyLinesIgnored,  header)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withEscape  [RETURN_TYPE]  CSVFormat    char  escape  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  header,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  commentStart)  ;[CE]  constructor  CSVFormat  in  class  CSVFormat  cannot  be  applied  to  given  types;  [CONTEXT]  public  CSVFormat  withEscape(char  escape)  {  if  (isLineBreak(escape))  {  throw  new  IllegalArgumentException( "The  escape  character  cannot  be  a  line  break ");  }  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  header,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  commentStart)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withEscape  [RETURN_TYPE]  CSVFormat    char  escape  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  this.escape  !=  DISABLED;	[BUG]  [BUGGY]  return  this.escape  ==  DISABLED;[FE]  null  testBackslashEscaping2  assertTrue(CSVPrinterTest.equals(res,  records));  [CONTEXT]  boolean  isEscaping()  {  [BUGGY]  return  this.escape  ==  DISABLED;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  isEscaping  [RETURN_TYPE]  boolean    [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P2_Replace_Operator]
[PATCH]  return  this.escape  !=  DISABLED;	[BUG]  [BUGGY]  return  this.escape  !=  escape;[FE]  null  testBackslashEscaping2  assertTrue(CSVPrinterTest.equals(res,  records));  [CONTEXT]  boolean  isEscaping()  {  [BUGGY]  return  this.escape  !=  escape;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  isEscaping  [RETURN_TYPE]  boolean    [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  this.escape  !=  DISABLED;	[BUG]  [BUGGY]  return  this.escape  ;[CE]  incompatible  types  [CONTEXT]  boolean  isEscaping()  {  [BUGGY]  return  this.escape  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  isEscaping  [RETURN_TYPE]  boolean    [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P8_Replace_Mix]
[PATCH]  return  surroundingSpacesIgnored;	[BUG]  [BUGGY]  return  emptyLinesIgnored;[FE]  null  testMutators  assertFalse(format.withEmptyLinesIgnored(false).isEmptyLinesIgnored());  [CONTEXT]  public  boolean  isSurroundingSpacesIgnored()  {  [BUGGY]  return  emptyLinesIgnored;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  isSurroundingSpacesIgnored  [RETURN_TYPE]  boolean    [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  surroundingSpacesIgnored;	[BUG]  [BUGGY]  if  (  isSurroundingSpacesIgnored(  )  )  {  return  surroundingSpacesIgnored;  }[CE]  missing  return  statement  [CONTEXT]  public  boolean  isSurroundingSpacesIgnored()  {  [BUGGY]  if  (  isSurroundingSpacesIgnored(  )  )  {  return  surroundingSpacesIgnored;  }  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  isSurroundingSpacesIgnored  [RETURN_TYPE]  boolean    [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P12_Insert_Condition]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  escape,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;[FE]  Token  type  expected:<TOKEN>  but  was:<EOF>  testNextToken1  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  CSVFormat  withSurroundingSpacesIgnored(boolean  surroundingSpacesIgnored)  {  [BUGGY]  return  new  CSVFormat(  escape,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withSurroundingSpacesIgnored  [RETURN_TYPE]  CSVFormat    boolean  surroundingSpacesIgnored  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  encapsulator,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;[FE]  (startline  0)  EOF  reached  before  encapsulated  token  finished  testNextToken4  assertTokenEquals(EOF,   "b ",  parser.nextToken(new  Token()));  [CONTEXT]  public  CSVFormat  withSurroundingSpacesIgnored(boolean  surroundingSpacesIgnored)  {  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  encapsulator,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withSurroundingSpacesIgnored  [RETURN_TYPE]  CSVFormat    boolean  surroundingSpacesIgnored  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  emptyLinesIgnored,  lineSeparator,  header)  ;[CE]  constructor  CSVFormat  in  class  CSVFormat  cannot  be  applied  to  given  types;  [CONTEXT]  public  CSVFormat  withSurroundingSpacesIgnored(boolean  surroundingSpacesIgnored)  {  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  emptyLinesIgnored,  lineSeparator,  header)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withSurroundingSpacesIgnored  [RETURN_TYPE]  CSVFormat    boolean  surroundingSpacesIgnored  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;[CE]  constructor  CSVFormat  in  class  CSVFormat  cannot  be  applied  to  given  types;  [CONTEXT]  public  CSVFormat  withSurroundingSpacesIgnored(boolean  surroundingSpacesIgnored)  {  [BUGGY]  return  new  CSVFormat(  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withSurroundingSpacesIgnored  [RETURN_TYPE]  CSVFormat    boolean  surroundingSpacesIgnored  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;[CE]  constructor  CSVFormat  in  class  CSVFormat  cannot  be  applied  to  given  types;  [CONTEXT]  public  CSVFormat  withSurroundingSpacesIgnored(boolean  surroundingSpacesIgnored)  {  [BUGGY]  return  new  CSVFormat(  delimiter,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withSurroundingSpacesIgnored  [RETURN_TYPE]  CSVFormat    boolean  surroundingSpacesIgnored  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;[CE]  constructor  CSVFormat  in  class  CSVFormat  cannot  be  applied  to  given  types;  [CONTEXT]  public  CSVFormat  withSurroundingSpacesIgnored(boolean  surroundingSpacesIgnored)  {  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withSurroundingSpacesIgnored  [RETURN_TYPE]  CSVFormat    boolean  surroundingSpacesIgnored  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;[CE]  constructor  CSVFormat  in  class  CSVFormat  cannot  be  applied  to  given  types;  [CONTEXT]  public  CSVFormat  withSurroundingSpacesIgnored(boolean  surroundingSpacesIgnored)  {  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withSurroundingSpacesIgnored  [RETURN_TYPE]  CSVFormat    boolean  surroundingSpacesIgnored  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  lineSeparator,  header)  ;[CE]  constructor  CSVFormat  in  class  CSVFormat  cannot  be  applied  to  given  types;  [CONTEXT]  public  CSVFormat  withSurroundingSpacesIgnored(boolean  surroundingSpacesIgnored)  {  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  lineSeparator,  header)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withSurroundingSpacesIgnored  [RETURN_TYPE]  CSVFormat    boolean  surroundingSpacesIgnored  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  header)  ;[CE]  constructor  CSVFormat  in  class  CSVFormat  cannot  be  applied  to  given  types;  [CONTEXT]  public  CSVFormat  withSurroundingSpacesIgnored(boolean  surroundingSpacesIgnored)  {  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  header)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withSurroundingSpacesIgnored  [RETURN_TYPE]  CSVFormat    boolean  surroundingSpacesIgnored  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator)  ;[CE]  constructor  CSVFormat  in  class  CSVFormat  cannot  be  applied  to  given  types;  [CONTEXT]  public  CSVFormat  withSurroundingSpacesIgnored(boolean  surroundingSpacesIgnored)  {  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withSurroundingSpacesIgnored  [RETURN_TYPE]  CSVFormat    boolean  surroundingSpacesIgnored  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  surroundingSpacesIgnored,  escape,  commentStart,  emptyLinesIgnored,  lineSeparator,  header)  ;[CE]  constructor  CSVFormat  in  class  CSVFormat  cannot  be  applied  to  given  types;  [CONTEXT]  public  CSVFormat  withSurroundingSpacesIgnored(boolean  surroundingSpacesIgnored)  {  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  surroundingSpacesIgnored,  escape,  commentStart,  emptyLinesIgnored,  lineSeparator,  header)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withSurroundingSpacesIgnored  [RETURN_TYPE]  CSVFormat    boolean  surroundingSpacesIgnored  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  encapsulator,  delimiter,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;[FE]  Token  type  expected:<TOKEN>  but  was:<EOF>  testNextToken1  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  CSVFormat  withSurroundingSpacesIgnored(boolean  surroundingSpacesIgnored)  {  [BUGGY]  return  new  CSVFormat(  encapsulator,  delimiter,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withSurroundingSpacesIgnored  [RETURN_TYPE]  CSVFormat    boolean  surroundingSpacesIgnored  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  commentStart,  encapsulator,  delimiter,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;[FE]  Token  type  expected:<TOKEN>  but  was:<EOF>  testNextToken1  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  CSVFormat  withSurroundingSpacesIgnored(boolean  surroundingSpacesIgnored)  {  [BUGGY]  return  new  CSVFormat(  commentStart,  encapsulator,  delimiter,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withSurroundingSpacesIgnored  [RETURN_TYPE]  CSVFormat    boolean  surroundingSpacesIgnored  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  escape,  commentStart,  encapsulator,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;[FE]  Token  type  expected:<TOKEN>  but  was:<EORECORD>  testNextToken4  assertTokenEquals(EOF,   "b ",  parser.nextToken(new  Token()));  [CONTEXT]  public  CSVFormat  withSurroundingSpacesIgnored(boolean  surroundingSpacesIgnored)  {  [BUGGY]  return  new  CSVFormat(  delimiter,  escape,  commentStart,  encapsulator,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withSurroundingSpacesIgnored  [RETURN_TYPE]  CSVFormat    boolean  surroundingSpacesIgnored  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  header,  lineSeparator,  emptyLinesIgnored)  ;[CE]  constructor  CSVFormat  in  class  CSVFormat  cannot  be  applied  to  given  types;  [CONTEXT]  public  CSVFormat  withSurroundingSpacesIgnored(boolean  surroundingSpacesIgnored)  {  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  header,  lineSeparator,  emptyLinesIgnored)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withSurroundingSpacesIgnored  [RETURN_TYPE]  CSVFormat    boolean  surroundingSpacesIgnored  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  header,  lineSeparator)  ;[CE]  constructor  CSVFormat  in  class  CSVFormat  cannot  be  applied  to  given  types;  [CONTEXT]  public  CSVFormat  withSurroundingSpacesIgnored(boolean  surroundingSpacesIgnored)  {  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  header,  lineSeparator)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withSurroundingSpacesIgnored  [RETURN_TYPE]  CSVFormat    boolean  surroundingSpacesIgnored  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  header,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  delimiter)  ;[CE]  constructor  CSVFormat  in  class  CSVFormat  cannot  be  applied  to  given  types;  [CONTEXT]  public  CSVFormat  withSurroundingSpacesIgnored(boolean  surroundingSpacesIgnored)  {  [BUGGY]  return  new  CSVFormat(  header,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  delimiter)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withSurroundingSpacesIgnored  [RETURN_TYPE]  CSVFormat    boolean  surroundingSpacesIgnored  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  escape,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;[FE]  Token  content  expected:<[foo]>  but  was:<[ "foo "]>  testNextToken4  assertTokenEquals(EOF,   "b ",  parser.nextToken(new  Token()));  [CONTEXT]  public  CSVFormat  withSurroundingSpacesIgnored(boolean  surroundingSpacesIgnored)  {  [BUGGY]  return  new  CSVFormat(  delimiter,  escape,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withSurroundingSpacesIgnored  [RETURN_TYPE]  CSVFormat    boolean  surroundingSpacesIgnored  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P8_Replace_Mix]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  encapsulator,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;[FE]  Token  type  expected:<TOKEN>  but  was:<EOF>  testNextToken1  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  CSVFormat  withSurroundingSpacesIgnored(boolean  surroundingSpacesIgnored)  {  [BUGGY]  return  new  CSVFormat(  encapsulator,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withSurroundingSpacesIgnored  [RETURN_TYPE]  CSVFormat    boolean  surroundingSpacesIgnored  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  encapsulator,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;[FE]  Token  content  expected:<[foo]>  but  was:<[a]>  testNextToken4  assertTokenEquals(EOF,   "b ",  parser.nextToken(new  Token()));  [CONTEXT]  public  CSVFormat  withSurroundingSpacesIgnored(boolean  surroundingSpacesIgnored)  {  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  encapsulator,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withSurroundingSpacesIgnored  [RETURN_TYPE]  CSVFormat    boolean  surroundingSpacesIgnored  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  emptyLinesIgnored,  surroundingSpacesIgnored,  lineSeparator,  header)  ;[FE]  null  testMutators  assertFalse(format.withEmptyLinesIgnored(false).isEmptyLinesIgnored());  [CONTEXT]  public  CSVFormat  withSurroundingSpacesIgnored(boolean  surroundingSpacesIgnored)  {  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  emptyLinesIgnored,  surroundingSpacesIgnored,  lineSeparator,  header)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withSurroundingSpacesIgnored  [RETURN_TYPE]  CSVFormat    boolean  surroundingSpacesIgnored  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  emptyLinesIgnored,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  delimiter,  lineSeparator,  header)  ;[CE]  constructor  CSVFormat  in  class  CSVFormat  cannot  be  applied  to  given  types;  [CONTEXT]  public  CSVFormat  withSurroundingSpacesIgnored(boolean  surroundingSpacesIgnored)  {  [BUGGY]  return  new  CSVFormat(  emptyLinesIgnored,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  delimiter,  lineSeparator,  header)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withSurroundingSpacesIgnored  [RETURN_TYPE]  CSVFormat    boolean  surroundingSpacesIgnored  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  commentStart,  encapsulator,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;[FE]  Token  content  expected:<[foo]>  but  was:<[a]>  testNextToken4  assertTokenEquals(EOF,   "b ",  parser.nextToken(new  Token()));  [CONTEXT]  public  CSVFormat  withSurroundingSpacesIgnored(boolean  surroundingSpacesIgnored)  {  [BUGGY]  return  new  CSVFormat(  delimiter,  commentStart,  encapsulator,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withSurroundingSpacesIgnored  [RETURN_TYPE]  CSVFormat    boolean  surroundingSpacesIgnored  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  escape,  encapsulator,  commentStart,  delimiter,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;[FE]  Token  type  expected:<TOKEN>  but  was:<EOF>  testNextToken1  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  CSVFormat  withSurroundingSpacesIgnored(boolean  surroundingSpacesIgnored)  {  [BUGGY]  return  new  CSVFormat(  escape,  encapsulator,  commentStart,  delimiter,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withSurroundingSpacesIgnored  [RETURN_TYPE]  CSVFormat    boolean  surroundingSpacesIgnored  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  lineSeparator,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  commentStart,  header)  ;[CE]  constructor  CSVFormat  in  class  CSVFormat  cannot  be  applied  to  given  types;  [CONTEXT]  public  CSVFormat  withSurroundingSpacesIgnored(boolean  surroundingSpacesIgnored)  {  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  lineSeparator,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  commentStart,  header)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withSurroundingSpacesIgnored  [RETURN_TYPE]  CSVFormat    boolean  surroundingSpacesIgnored  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  header,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  commentStart)  ;[CE]  constructor  CSVFormat  in  class  CSVFormat  cannot  be  applied  to  given  types;  [CONTEXT]  public  CSVFormat  withSurroundingSpacesIgnored(boolean  surroundingSpacesIgnored)  {  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  header,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  commentStart)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withSurroundingSpacesIgnored  [RETURN_TYPE]  CSVFormat    boolean  surroundingSpacesIgnored  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  emptyLinesIgnored;	[BUG]  [BUGGY]  return  surroundingSpacesIgnored;[FE]  null  testMutators  assertFalse(format.withEmptyLinesIgnored(false).isEmptyLinesIgnored());  [CONTEXT]  public  boolean  isEmptyLinesIgnored()  {  [BUGGY]  return  surroundingSpacesIgnored;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  isEmptyLinesIgnored  [RETURN_TYPE]  boolean    [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  escape,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;[FE]  The  encapsulator  character  and  the  delimiter  cannot  be  the  same  ( "  testValidation  [CONTEXT]  public  CSVFormat  withEmptyLinesIgnored(boolean  emptyLinesIgnored)  {  [BUGGY]  return  new  CSVFormat(  escape,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withEmptyLinesIgnored  [RETURN_TYPE]  CSVFormat    boolean  emptyLinesIgnored  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  escape,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;[FE]  expected:<[ "x,y "],z>  but  was:<[x,y],z>  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]  public  CSVFormat  withEmptyLinesIgnored(boolean  emptyLinesIgnored)  {  [BUGGY]  return  new  CSVFormat(  delimiter,  escape,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withEmptyLinesIgnored  [RETURN_TYPE]  CSVFormat    boolean  emptyLinesIgnored  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  lineSeparator,  header)  ;[CE]  constructor  CSVFormat  in  class  CSVFormat  cannot  be  applied  to  given  types;  [CONTEXT]  public  CSVFormat  withEmptyLinesIgnored(boolean  emptyLinesIgnored)  {  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  lineSeparator,  header)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withEmptyLinesIgnored  [RETURN_TYPE]  CSVFormat    boolean  emptyLinesIgnored  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;[CE]  constructor  CSVFormat  in  class  CSVFormat  cannot  be  applied  to  given  types;  [CONTEXT]  public  CSVFormat  withEmptyLinesIgnored(boolean  emptyLinesIgnored)  {  [BUGGY]  return  new  CSVFormat(  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withEmptyLinesIgnored  [RETURN_TYPE]  CSVFormat    boolean  emptyLinesIgnored  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;[CE]  constructor  CSVFormat  in  class  CSVFormat  cannot  be  applied  to  given  types;  [CONTEXT]  public  CSVFormat  withEmptyLinesIgnored(boolean  emptyLinesIgnored)  {  [BUGGY]  return  new  CSVFormat(  delimiter,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withEmptyLinesIgnored  [RETURN_TYPE]  CSVFormat    boolean  emptyLinesIgnored  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;[CE]  constructor  CSVFormat  in  class  CSVFormat  cannot  be  applied  to  given  types;  [CONTEXT]  public  CSVFormat  withEmptyLinesIgnored(boolean  emptyLinesIgnored)  {  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withEmptyLinesIgnored  [RETURN_TYPE]  CSVFormat    boolean  emptyLinesIgnored  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;[CE]  constructor  CSVFormat  in  class  CSVFormat  cannot  be  applied  to  given  types;  [CONTEXT]  public  CSVFormat  withEmptyLinesIgnored(boolean  emptyLinesIgnored)  {  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withEmptyLinesIgnored  [RETURN_TYPE]  CSVFormat    boolean  emptyLinesIgnored  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  emptyLinesIgnored,  lineSeparator,  header)  ;[CE]  constructor  CSVFormat  in  class  CSVFormat  cannot  be  applied  to  given  types;  [CONTEXT]  public  CSVFormat  withEmptyLinesIgnored(boolean  emptyLinesIgnored)  {  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  emptyLinesIgnored,  lineSeparator,  header)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withEmptyLinesIgnored  [RETURN_TYPE]  CSVFormat    boolean  emptyLinesIgnored  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  header)  ;[CE]  constructor  CSVFormat  in  class  CSVFormat  cannot  be  applied  to  given  types;  [CONTEXT]  public  CSVFormat  withEmptyLinesIgnored(boolean  emptyLinesIgnored)  {  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  header)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withEmptyLinesIgnored  [RETURN_TYPE]  CSVFormat    boolean  emptyLinesIgnored  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator)  ;[CE]  constructor  CSVFormat  in  class  CSVFormat  cannot  be  applied  to  given  types;  [CONTEXT]  public  CSVFormat  withEmptyLinesIgnored(boolean  emptyLinesIgnored)  {  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withEmptyLinesIgnored  [RETURN_TYPE]  CSVFormat    boolean  emptyLinesIgnored  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  emptyLinesIgnored,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  delimiter,  lineSeparator,  header)  ;[CE]  constructor  CSVFormat  in  class  CSVFormat  cannot  be  applied  to  given  types;  [CONTEXT]  public  CSVFormat  withEmptyLinesIgnored(boolean  emptyLinesIgnored)  {  [BUGGY]  return  new  CSVFormat(  emptyLinesIgnored,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  delimiter,  lineSeparator,  header)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withEmptyLinesIgnored  [RETURN_TYPE]  CSVFormat    boolean  emptyLinesIgnored  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  encapsulator,  delimiter,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;[FE]  expected:<a[,b,]c>  but  was:<a[ "b "]c>  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]  public  CSVFormat  withEmptyLinesIgnored(boolean  emptyLinesIgnored)  {  [BUGGY]  return  new  CSVFormat(  encapsulator,  delimiter,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withEmptyLinesIgnored  [RETURN_TYPE]  CSVFormat    boolean  emptyLinesIgnored  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  surroundingSpacesIgnored,  commentStart,  escape,  encapsulator,  emptyLinesIgnored,  lineSeparator,  header)  ;[CE]  constructor  CSVFormat  in  class  CSVFormat  cannot  be  applied  to  given  types;  [CONTEXT]  public  CSVFormat  withEmptyLinesIgnored(boolean  emptyLinesIgnored)  {  [BUGGY]  return  new  CSVFormat(  delimiter,  surroundingSpacesIgnored,  commentStart,  escape,  encapsulator,  emptyLinesIgnored,  lineSeparator,  header)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withEmptyLinesIgnored  [RETURN_TYPE]  CSVFormat    boolean  emptyLinesIgnored  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  commentStart,  encapsulator,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;[FE]  expected:<[ "x,y "],z>  but  was:<[x,y],z>  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]  public  CSVFormat  withEmptyLinesIgnored(boolean  emptyLinesIgnored)  {  [BUGGY]  return  new  CSVFormat(  delimiter,  commentStart,  encapsulator,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withEmptyLinesIgnored  [RETURN_TYPE]  CSVFormat    boolean  emptyLinesIgnored  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  header,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  escape)  ;[CE]  constructor  CSVFormat  in  class  CSVFormat  cannot  be  applied  to  given  types;  [CONTEXT]  public  CSVFormat  withEmptyLinesIgnored(boolean  emptyLinesIgnored)  {  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  header,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  escape)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withEmptyLinesIgnored  [RETURN_TYPE]  CSVFormat    boolean  emptyLinesIgnored  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  surroundingSpacesIgnored,  escape,  emptyLinesIgnored,  lineSeparator,  header)  ;[CE]  constructor  CSVFormat  in  class  CSVFormat  cannot  be  applied  to  given  types;  [CONTEXT]  public  CSVFormat  withEmptyLinesIgnored(boolean  emptyLinesIgnored)  {  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  surroundingSpacesIgnored,  escape,  emptyLinesIgnored,  lineSeparator,  header)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withEmptyLinesIgnored  [RETURN_TYPE]  CSVFormat    boolean  emptyLinesIgnored  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  lineSeparator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  encapsulator,  header)  ;[CE]  constructor  CSVFormat  in  class  CSVFormat  cannot  be  applied  to  given  types;  [CONTEXT]  public  CSVFormat  withEmptyLinesIgnored(boolean  emptyLinesIgnored)  {  [BUGGY]  return  new  CSVFormat(  delimiter,  lineSeparator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  encapsulator,  header)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withEmptyLinesIgnored  [RETURN_TYPE]  CSVFormat    boolean  emptyLinesIgnored  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  header,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  delimiter)  ;[CE]  constructor  CSVFormat  in  class  CSVFormat  cannot  be  applied  to  given  types;  [CONTEXT]  public  CSVFormat  withEmptyLinesIgnored(boolean  emptyLinesIgnored)  {  [BUGGY]  return  new  CSVFormat(  header,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  delimiter)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withEmptyLinesIgnored  [RETURN_TYPE]  CSVFormat    boolean  emptyLinesIgnored  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  delimiter,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;[FE]  The  escape  character  and  the  delimiter  cannot  be  the  same  ( ", ")  testValidation  [CONTEXT]  public  CSVFormat  withEmptyLinesIgnored(boolean  emptyLinesIgnored)  {  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  delimiter,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withEmptyLinesIgnored  [RETURN_TYPE]  CSVFormat    boolean  emptyLinesIgnored  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  emptyLinesIgnored,  commentStart,  escape,  surroundingSpacesIgnored,  encapsulator,  lineSeparator,  header)  ;[CE]  constructor  CSVFormat  in  class  CSVFormat  cannot  be  applied  to  given  types;  [CONTEXT]  public  CSVFormat  withEmptyLinesIgnored(boolean  emptyLinesIgnored)  {  [BUGGY]  return  new  CSVFormat(  delimiter,  emptyLinesIgnored,  commentStart,  escape,  surroundingSpacesIgnored,  encapsulator,  lineSeparator,  header)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withEmptyLinesIgnored  [RETURN_TYPE]  CSVFormat    boolean  emptyLinesIgnored  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  commentStart,  encapsulator,  delimiter,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;[FE]  The  encapsulator  character  and  the  delimiter  cannot  be  the  same  ( "  testValidation  [CONTEXT]  public  CSVFormat  withEmptyLinesIgnored(boolean  emptyLinesIgnored)  {  [BUGGY]  return  new  CSVFormat(  commentStart,  encapsulator,  delimiter,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withEmptyLinesIgnored  [RETURN_TYPE]  CSVFormat    boolean  emptyLinesIgnored  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  escape,  encapsulator,  commentStart,  delimiter,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;[FE]  The  encapsulator  character  and  the  delimiter  cannot  be  the  same  ( "  testValidation  [CONTEXT]  public  CSVFormat  withEmptyLinesIgnored(boolean  emptyLinesIgnored)  {  [BUGGY]  return  new  CSVFormat(  escape,  encapsulator,  commentStart,  delimiter,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withEmptyLinesIgnored  [RETURN_TYPE]  CSVFormat    boolean  emptyLinesIgnored  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  emptyLinesIgnored,  surroundingSpacesIgnored,  lineSeparator,  header)  ;[FE]  null  testMutators  assertFalse(format.withEmptyLinesIgnored(false).isEmptyLinesIgnored());  [CONTEXT]  public  CSVFormat  withEmptyLinesIgnored(boolean  emptyLinesIgnored)  {  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  emptyLinesIgnored,  surroundingSpacesIgnored,  lineSeparator,  header)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withEmptyLinesIgnored  [RETURN_TYPE]  CSVFormat    boolean  emptyLinesIgnored  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  lineSeparator,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  commentStart,  header)  ;[CE]  constructor  CSVFormat  in  class  CSVFormat  cannot  be  applied  to  given  types;  [CONTEXT]  public  CSVFormat  withEmptyLinesIgnored(boolean  emptyLinesIgnored)  {  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  lineSeparator,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  commentStart,  header)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withEmptyLinesIgnored  [RETURN_TYPE]  CSVFormat    boolean  emptyLinesIgnored  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  lineSeparator;	[BUG]  [BUGGY]  return  CRLF;[FE]  expected:<[?]>  but  was:<[  testMutators  assertFalse(format.withEmptyLinesIgnored(false).isEmptyLinesIgnored());  [CONTEXT]  public  String  getLineSeparator()  {  [BUGGY]  return  CRLF;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  getLineSeparator  [RETURN_TYPE]  String    [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  CRLF,  header)  ;[FE]  expected:<[?]>  but  was:<[  testMutators  assertFalse(format.withEmptyLinesIgnored(false).isEmptyLinesIgnored());  [CONTEXT]  public  CSVFormat  withLineSeparator(String  lineSeparator)  {  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  CRLF,  header)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withLineSeparator  [RETURN_TYPE]  CSVFormat    String  lineSeparator  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  escape,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;[FE]  The  encapsulator  character  and  the  delimiter  cannot  be  the  same  ( "  testValidation  [CONTEXT]  public  CSVFormat  withLineSeparator(String  lineSeparator)  {  [BUGGY]  return  new  CSVFormat(  escape,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withLineSeparator  [RETURN_TYPE]  CSVFormat    String  lineSeparator  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  delimiter,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;[FE]  The  encapsulator  character  and  the  delimiter  cannot  be  the  same  ( ", ")  testValidation  [CONTEXT]  public  CSVFormat  withLineSeparator(String  lineSeparator)  {  [BUGGY]  return  new  CSVFormat(  delimiter,  delimiter,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withLineSeparator  [RETURN_TYPE]  CSVFormat    String  lineSeparator  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  encapsulator,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;[FE]  (startline  0)  EOF  reached  before  encapsulated  token  finished  testNextToken4  assertTokenEquals(EOF,   "b ",  parser.nextToken(new  Token()));  [CONTEXT]  public  CSVFormat  withLineSeparator(String  lineSeparator)  {  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  encapsulator,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withLineSeparator  [RETURN_TYPE]  CSVFormat    String  lineSeparator  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  header)  ;[CE]  constructor  CSVFormat  in  class  CSVFormat  cannot  be  applied  to  given  types;  [CONTEXT]  public  CSVFormat  withLineSeparator(String  lineSeparator)  {  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  header)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withLineSeparator  [RETURN_TYPE]  CSVFormat    String  lineSeparator  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;[CE]  constructor  CSVFormat  in  class  CSVFormat  cannot  be  applied  to  given  types;  [CONTEXT]  public  CSVFormat  withLineSeparator(String  lineSeparator)  {  [BUGGY]  return  new  CSVFormat(  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withLineSeparator  [RETURN_TYPE]  CSVFormat    String  lineSeparator  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;[CE]  constructor  CSVFormat  in  class  CSVFormat  cannot  be  applied  to  given  types;  [CONTEXT]  public  CSVFormat  withLineSeparator(String  lineSeparator)  {  [BUGGY]  return  new  CSVFormat(  delimiter,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withLineSeparator  [RETURN_TYPE]  CSVFormat    String  lineSeparator  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;[CE]  constructor  CSVFormat  in  class  CSVFormat  cannot  be  applied  to  given  types;  [CONTEXT]  public  CSVFormat  withLineSeparator(String  lineSeparator)  {  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withLineSeparator  [RETURN_TYPE]  CSVFormat    String  lineSeparator  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;[CE]  constructor  CSVFormat  in  class  CSVFormat  cannot  be  applied  to  given  types;  [CONTEXT]  public  CSVFormat  withLineSeparator(String  lineSeparator)  {  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withLineSeparator  [RETURN_TYPE]  CSVFormat    String  lineSeparator  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  emptyLinesIgnored,  lineSeparator,  header)  ;[CE]  constructor  CSVFormat  in  class  CSVFormat  cannot  be  applied  to  given  types;  [CONTEXT]  public  CSVFormat  withLineSeparator(String  lineSeparator)  {  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  emptyLinesIgnored,  lineSeparator,  header)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withLineSeparator  [RETURN_TYPE]  CSVFormat    String  lineSeparator  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  lineSeparator,  header)  ;[CE]  constructor  CSVFormat  in  class  CSVFormat  cannot  be  applied  to  given  types;  [CONTEXT]  public  CSVFormat  withLineSeparator(String  lineSeparator)  {  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  lineSeparator,  header)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withLineSeparator  [RETURN_TYPE]  CSVFormat    String  lineSeparator  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator)  ;[CE]  constructor  CSVFormat  in  class  CSVFormat  cannot  be  applied  to  given  types;  [CONTEXT]  public  CSVFormat  withLineSeparator(String  lineSeparator)  {  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withLineSeparator  [RETURN_TYPE]  CSVFormat    String  lineSeparator  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  lineSeparator,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  delimiter,  header)  ;[CE]  constructor  CSVFormat  in  class  CSVFormat  cannot  be  applied  to  given  types;  [CONTEXT]  public  CSVFormat  withLineSeparator(String  lineSeparator)  {  [BUGGY]  return  new  CSVFormat(  lineSeparator,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  delimiter,  header)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withLineSeparator  [RETURN_TYPE]  CSVFormat    String  lineSeparator  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  encapsulator,  delimiter,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;[FE]  expected:<a[,b,]c>  but  was:<a[ "b "]c>  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]  public  CSVFormat  withLineSeparator(String  lineSeparator)  {  [BUGGY]  return  new  CSVFormat(  encapsulator,  delimiter,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withLineSeparator  [RETURN_TYPE]  CSVFormat    String  lineSeparator  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  escape,  commentStart,  encapsulator,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;[FE]  expected:<[ "x,y "],z>  but  was:<[x ",y],z>  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]  public  CSVFormat  withLineSeparator(String  lineSeparator)  {  [BUGGY]  return  new  CSVFormat(  delimiter,  escape,  commentStart,  encapsulator,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withLineSeparator  [RETURN_TYPE]  CSVFormat    String  lineSeparator  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  escape,  commentStart,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;[FE]  null  testRandom  [CONTEXT]  public  CSVFormat  withLineSeparator(String  lineSeparator)  {  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  escape,  commentStart,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withLineSeparator  [RETURN_TYPE]  CSVFormat    String  lineSeparator  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  surroundingSpacesIgnored,  escape,  emptyLinesIgnored,  lineSeparator,  header)  ;[CE]  constructor  CSVFormat  in  class  CSVFormat  cannot  be  applied  to  given  types;  [CONTEXT]  public  CSVFormat  withLineSeparator(String  lineSeparator)  {  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  surroundingSpacesIgnored,  escape,  emptyLinesIgnored,  lineSeparator,  header)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withLineSeparator  [RETURN_TYPE]  CSVFormat    String  lineSeparator  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  emptyLinesIgnored,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  delimiter,  lineSeparator,  header)  ;[CE]  constructor  CSVFormat  in  class  CSVFormat  cannot  be  applied  to  given  types;  [CONTEXT]  public  CSVFormat  withLineSeparator(String  lineSeparator)  {  [BUGGY]  return  new  CSVFormat(  emptyLinesIgnored,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  delimiter,  lineSeparator,  header)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withLineSeparator  [RETURN_TYPE]  CSVFormat    String  lineSeparator  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  header,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  delimiter)  ;[CE]  constructor  CSVFormat  in  class  CSVFormat  cannot  be  applied  to  given  types;  [CONTEXT]  public  CSVFormat  withLineSeparator(String  lineSeparator)  {  [BUGGY]  return  new  CSVFormat(  header,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  delimiter)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withLineSeparator  [RETURN_TYPE]  CSVFormat    String  lineSeparator  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  encapsulator,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;[FE]  The  encapsulator  character  and  the  delimiter  cannot  be  the  same  ( " " ")  testValidation  [CONTEXT]  public  CSVFormat  withLineSeparator(String  lineSeparator)  {  [BUGGY]  return  new  CSVFormat(  encapsulator,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withLineSeparator  [RETURN_TYPE]  CSVFormat    String  lineSeparator  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  escape,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;[FE]  The  comment  start  and  the  escape  character  cannot  be  the  same  ( "  testRandom  [CONTEXT]  public  CSVFormat  withLineSeparator(String  lineSeparator)  {  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  escape,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withLineSeparator  [RETURN_TYPE]  CSVFormat    String  lineSeparator  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  lineSeparator,  surroundingSpacesIgnored,  emptyLinesIgnored,  escape,  header)  ;[CE]  constructor  CSVFormat  in  class  CSVFormat  cannot  be  applied  to  given  types;  [CONTEXT]  public  CSVFormat  withLineSeparator(String  lineSeparator)  {  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  lineSeparator,  surroundingSpacesIgnored,  emptyLinesIgnored,  escape,  header)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withLineSeparator  [RETURN_TYPE]  CSVFormat    String  lineSeparator  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  commentStart,  encapsulator,  delimiter,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;[FE]  The  encapsulator  character  and  the  delimiter  cannot  be  the  same  ( "  testValidation  [CONTEXT]  public  CSVFormat  withLineSeparator(String  lineSeparator)  {  [BUGGY]  return  new  CSVFormat(  commentStart,  encapsulator,  delimiter,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withLineSeparator  [RETURN_TYPE]  CSVFormat    String  lineSeparator  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  emptyLinesIgnored,  surroundingSpacesIgnored,  lineSeparator,  header)  ;[FE]  Token  type  expected:<EOF>  but  was:<EORECORD>  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  CSVFormat  withLineSeparator(String  lineSeparator)  {  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  emptyLinesIgnored,  surroundingSpacesIgnored,  lineSeparator,  header)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withLineSeparator  [RETURN_TYPE]  CSVFormat    String  lineSeparator  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  header,  lineSeparator,  emptyLinesIgnored)  ;[CE]  constructor  CSVFormat  in  class  CSVFormat  cannot  be  applied  to  given  types;  [CONTEXT]  public  CSVFormat  withLineSeparator(String  lineSeparator)  {  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  header,  lineSeparator,  emptyLinesIgnored)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withLineSeparator  [RETURN_TYPE]  CSVFormat    String  lineSeparator  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  encapsulator,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;[FE]  The  comment  start  character  and  the  encapsulator  cannot  be  the  same  ( " " ")  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]  public  CSVFormat  withLineSeparator(String  lineSeparator)  {  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  encapsulator,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withLineSeparator  [RETURN_TYPE]  CSVFormat    String  lineSeparator  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P8_Replace_Mix]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  escape,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;[FE]  The  escape  character  and  the  delimiter  cannot  be  the  same  ( "  testProvidedHeader  assertFalse(records.hasNext());  [CONTEXT]  public  CSVFormat  withHeader(String...  header)  {  [BUGGY]  return  new  CSVFormat(  escape,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withHeader  [RETURN_TYPE]  CSVFormat    header  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  encapsulator,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;[FE]  The  comment  start  character  and  the  encapsulator  cannot  be  the  same  ( " " ")  testProvidedHeader  assertFalse(records.hasNext());  [CONTEXT]  public  CSVFormat  withHeader(String...  header)  {  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  encapsulator,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withHeader  [RETURN_TYPE]  CSVFormat    header  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator)  ;[CE]  constructor  CSVFormat  in  class  CSVFormat  cannot  be  applied  to  given  types;  [CONTEXT]  public  CSVFormat  withHeader(String...  header)  {  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withHeader  [RETURN_TYPE]  CSVFormat    header  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;[CE]  constructor  CSVFormat  in  class  CSVFormat  cannot  be  applied  to  given  types;  [CONTEXT]  public  CSVFormat  withHeader(String...  header)  {  [BUGGY]  return  new  CSVFormat(  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withHeader  [RETURN_TYPE]  CSVFormat    header  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;[CE]  constructor  CSVFormat  in  class  CSVFormat  cannot  be  applied  to  given  types;  [CONTEXT]  public  CSVFormat  withHeader(String...  header)  {  [BUGGY]  return  new  CSVFormat(  delimiter,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withHeader  [RETURN_TYPE]  CSVFormat    header  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;[CE]  constructor  CSVFormat  in  class  CSVFormat  cannot  be  applied  to  given  types;  [CONTEXT]  public  CSVFormat  withHeader(String...  header)  {  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withHeader  [RETURN_TYPE]  CSVFormat    header  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;[CE]  constructor  CSVFormat  in  class  CSVFormat  cannot  be  applied  to  given  types;  [CONTEXT]  public  CSVFormat  withHeader(String...  header)  {  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withHeader  [RETURN_TYPE]  CSVFormat    header  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  emptyLinesIgnored,  lineSeparator,  header)  ;[CE]  constructor  CSVFormat  in  class  CSVFormat  cannot  be  applied  to  given  types;  [CONTEXT]  public  CSVFormat  withHeader(String...  header)  {  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  emptyLinesIgnored,  lineSeparator,  header)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withHeader  [RETURN_TYPE]  CSVFormat    header  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  lineSeparator,  header)  ;[CE]  constructor  CSVFormat  in  class  CSVFormat  cannot  be  applied  to  given  types;  [CONTEXT]  public  CSVFormat  withHeader(String...  header)  {  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  lineSeparator,  header)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withHeader  [RETURN_TYPE]  CSVFormat    header  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  header)  ;[CE]  constructor  CSVFormat  in  class  CSVFormat  cannot  be  applied  to  given  types;  [CONTEXT]  public  CSVFormat  withHeader(String...  header)  {  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  header)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withHeader  [RETURN_TYPE]  CSVFormat    header  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  header,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  delimiter)  ;[CE]  constructor  CSVFormat  in  class  CSVFormat  cannot  be  applied  to  given  types;  [CONTEXT]  public  CSVFormat  withHeader(String...  header)  {  [BUGGY]  return  new  CSVFormat(  header,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  delimiter)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withHeader  [RETURN_TYPE]  CSVFormat    header  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  commentStart,  encapsulator,  delimiter,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;[FE]  The  escape  character  and  the  delimiter  cannot  be  the  same  ( "  testProvidedHeader  assertFalse(records.hasNext());  [CONTEXT]  public  CSVFormat  withHeader(String...  header)  {  [BUGGY]  return  new  CSVFormat(  commentStart,  encapsulator,  delimiter,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withHeader  [RETURN_TYPE]  CSVFormat    header  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  header,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  encapsulator)  ;[CE]  constructor  CSVFormat  in  class  CSVFormat  cannot  be  applied  to  given  types;  [CONTEXT]  public  CSVFormat  withHeader(String...  header)  {  [BUGGY]  return  new  CSVFormat(  delimiter,  header,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  encapsulator)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withHeader  [RETURN_TYPE]  CSVFormat    header  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  surroundingSpacesIgnored,  encapsulator,  commentStart,  escape,  delimiter,  emptyLinesIgnored,  lineSeparator,  header)  ;[CE]  constructor  CSVFormat  in  class  CSVFormat  cannot  be  applied  to  given  types;  [CONTEXT]  public  CSVFormat  withHeader(String...  header)  {  [BUGGY]  return  new  CSVFormat(  surroundingSpacesIgnored,  encapsulator,  commentStart,  escape,  delimiter,  emptyLinesIgnored,  lineSeparator,  header)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withHeader  [RETURN_TYPE]  CSVFormat    header  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  emptyLinesIgnored,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  delimiter,  lineSeparator,  header)  ;[CE]  constructor  CSVFormat  in  class  CSVFormat  cannot  be  applied  to  given  types;  [CONTEXT]  public  CSVFormat  withHeader(String...  header)  {  [BUGGY]  return  new  CSVFormat(  emptyLinesIgnored,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  delimiter,  lineSeparator,  header)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withHeader  [RETURN_TYPE]  CSVFormat    header  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  lineSeparator,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  commentStart,  header)  ;[CE]  constructor  CSVFormat  in  class  CSVFormat  cannot  be  applied  to  given  types;  [CONTEXT]  public  CSVFormat  withHeader(String...  header)  {  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  lineSeparator,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  commentStart,  header)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withHeader  [RETURN_TYPE]  CSVFormat    header  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  delimiter,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;[FE]  The  escape  character  and  the  delimiter  cannot  be  the  same  ( ", ")  testProvidedHeader  assertFalse(records.hasNext());  [CONTEXT]  public  CSVFormat  withHeader(String...  header)  {  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  delimiter,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withHeader  [RETURN_TYPE]  CSVFormat    header  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P8_Replace_Mix]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  encapsulator,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;[FE]  The  encapsulator  character  and  the  delimiter  cannot  be  the  same  ( " " ")  testProvidedHeader  assertFalse(records.hasNext());  [CONTEXT]  public  CSVFormat  withHeader(String...  header)  {  [BUGGY]  return  new  CSVFormat(  encapsulator,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withHeader  [RETURN_TYPE]  CSVFormat    header  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  surroundingSpacesIgnored,  commentStart,  escape,  encapsulator,  emptyLinesIgnored,  lineSeparator,  header)  ;[CE]  constructor  CSVFormat  in  class  CSVFormat  cannot  be  applied  to  given  types;  [CONTEXT]  public  CSVFormat  withHeader(String...  header)  {  [BUGGY]  return  new  CSVFormat(  delimiter,  surroundingSpacesIgnored,  commentStart,  escape,  encapsulator,  emptyLinesIgnored,  lineSeparator,  header)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withHeader  [RETURN_TYPE]  CSVFormat    header  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  header,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  escape)  ;[CE]  constructor  CSVFormat  in  class  CSVFormat  cannot  be  applied  to  given  types;  [CONTEXT]  public  CSVFormat  withHeader(String...  header)  {  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  header,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  escape)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withHeader  [RETURN_TYPE]  CSVFormat    header  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  header,  emptyLinesIgnored,  lineSeparator,  surroundingSpacesIgnored)  ;[CE]  constructor  CSVFormat  in  class  CSVFormat  cannot  be  applied  to  given  types;  [CONTEXT]  public  CSVFormat  withHeader(String...  header)  {  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  header,  emptyLinesIgnored,  lineSeparator,  surroundingSpacesIgnored)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withHeader  [RETURN_TYPE]  CSVFormat    header  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  emptyLinesIgnored,  escape,  surroundingSpacesIgnored,  commentStart,  lineSeparator,  header)  ;[CE]  constructor  CSVFormat  in  class  CSVFormat  cannot  be  applied  to  given  types;  [CONTEXT]  public  CSVFormat  withHeader(String...  header)  {  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  emptyLinesIgnored,  escape,  surroundingSpacesIgnored,  commentStart,  lineSeparator,  header)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withHeader  [RETURN_TYPE]  CSVFormat    header  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  header,  lineSeparator)  ;[CE]  constructor  CSVFormat  in  class  CSVFormat  cannot  be  applied  to  given  types;  [CONTEXT]  public  CSVFormat  withHeader(String...  header)  {  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  header,  lineSeparator)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  withHeader  [RETURN_TYPE]  CSVFormat    header  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P5_Replace_Variable]
[PATCH]  return  new  CSVParser  (  in,  this  )  ;	[BUG]  [BUGGY]  return  return  new  CSVPrinter(  out,  this)  ;[CE]  illegal  start  of  expression  [CONTEXT]  public  Iterable<CSVRecord>  parse(Reader  in)  throws  IOException  {  [BUGGY]  return  return  new  CSVPrinter(  out,  this)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  parse  [RETURN_TYPE]  Iterable    Reader  in  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  Reader  in  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P4_Replace_Constructor]
[PATCH]  return  new  CSVParser  (  in,  this  )  ;	[BUG]  [BUGGY]  return  new  CSVPrinter(  out,  this)  ;[CE]  cannot  find  symbol  out  [CONTEXT]  public  Iterable<CSVRecord>  parse(Reader  in)  throws  IOException  {  [BUGGY]  return  new  CSVPrinter(  out,  this)  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  parse  [RETURN_TYPE]  Iterable    Reader  in  [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  Reader  in  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header    	[P8_Replace_Mix]
[PATCH]  StringWriter  out  =  new  StringWriter  (  )  ;	[BUG]  [BUGGY]  StringWriter  out  =  new  StringBuilder(  )  ;[CE]  incompatible  types  [CONTEXT]  public  String  format(String...  values)  {  [BUGGY]  StringWriter  out  =  new  StringBuilder(  )  ;  [BUGGY]  try  {  new  CSVPrinter(out,  this).println(values);  }  catch  (IOException  e)  {    }  return  out.toString().trim();  }    [CLASS]  CSVFormat  [METHOD]  format  [RETURN_TYPE]  String    values  [VARIABLES]  boolean  emptyLinesIgnored  surroundingSpacesIgnored  StringWriter  out  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  String  CRLF  lineSeparator  String[]  header  values  IOException  e    	[P4_Replace_Constructor]
[PATCH]  new  CSVPrinter  (  out,  this  )  .println  (  values  )  ;	[BUG]  [BUGGY]  new  CSVParser(  in,  this)  .println(  values)  ;[CE]  cannot  find  symbol  in  [CONTEXT]  public  String  format(String...  values)  {  StringWriter  out  =  new  StringWriter();  try  {  [BUGGY]  new  CSVParser(  in,  this)  .println(  values)  ;  [BUGGY]  }  catch  (IOException  e)  {    }  return  out.toString().trim();  }    [CLASS]  CSVFormat  [METHOD]  format  [RETURN_TYPE]  String    values  [VARIABLES]  boolean  emptyLinesIgnored  surroundingSpacesIgnored  StringWriter  out  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  String  CRLF  lineSeparator  String[]  header  values  IOException  e    	[P4_Replace_Constructor]
[PATCH]  new  CSVPrinter  (  out,  this  )  .println  (  values  )  ;	[BUG]  [BUGGY]  new  CSVPrinter(  this).println(  values)  ;[CE]  constructor  CSVPrinter  in  class  CSVPrinter  cannot  be  applied  to  given  types;  [CONTEXT]  public  String  format(String...  values)  {  StringWriter  out  =  new  StringWriter();  try  {  [BUGGY]  new  CSVPrinter(  this).println(  values)  ;  [BUGGY]  }  catch  (IOException  e)  {    }  return  out.toString().trim();  }    [CLASS]  CSVFormat  [METHOD]  format  [RETURN_TYPE]  String    values  [VARIABLES]  boolean  emptyLinesIgnored  surroundingSpacesIgnored  StringWriter  out  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  String  CRLF  lineSeparator  String[]  header  values  IOException  e    	[P4_Replace_Constructor]
[PATCH]  new  CSVPrinter  (  out,  this  )  .println  (  values  )  ;	[BUG]  [BUGGY]  new  CSVPrinter(  out,  this).println(  header)  ;[FE]  null  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]  public  String  format(String...  values)  {  StringWriter  out  =  new  StringWriter();  try  {  [BUGGY]  new  CSVPrinter(  out,  this).println(  header)  ;  [BUGGY]  }  catch  (IOException  e)  {    }  return  out.toString().trim();  }    [CLASS]  CSVFormat  [METHOD]  format  [RETURN_TYPE]  String    values  [VARIABLES]  boolean  emptyLinesIgnored  surroundingSpacesIgnored  StringWriter  out  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  String  CRLF  lineSeparator  String[]  header  values  IOException  e    	[P5_Replace_Variable]
[PATCH]  new  CSVPrinter  (  out,  this  )  .println  (  values  )  ;	[BUG]  [BUGGY]  new  CSVPrinter(  values,  this).println(  out)  ;[CE]  constructor  CSVPrinter  in  class  CSVPrinter  cannot  be  applied  to  given  types;  [CONTEXT]  public  String  format(String...  values)  {  StringWriter  out  =  new  StringWriter();  try  {  [BUGGY]  new  CSVPrinter(  values,  this).println(  out)  ;  [BUGGY]  }  catch  (IOException  e)  {    }  return  out.toString().trim();  }    [CLASS]  CSVFormat  [METHOD]  format  [RETURN_TYPE]  String    values  [VARIABLES]  boolean  emptyLinesIgnored  surroundingSpacesIgnored  StringWriter  out  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  String  CRLF  lineSeparator  String[]  header  values  IOException  e    	[P5_Replace_Variable]
[PATCH]  new  CSVPrinter  (  out,  this  )  .println  (  values  )  ;	[BUG]  [BUGGY]  new  CSVPrinter(  out,  this).CSVPrinter(  values)  ;[CE]  cannot  find  symbol  [CONTEXT]  public  String  format(String...  values)  {  StringWriter  out  =  new  StringWriter();  try  {  [BUGGY]  new  CSVPrinter(  out,  this).CSVPrinter(  values)  ;  [BUGGY]  }  catch  (IOException  e)  {    }  return  out.toString().trim();  }    [CLASS]  CSVFormat  [METHOD]  format  [RETURN_TYPE]  String    values  [VARIABLES]  boolean  emptyLinesIgnored  surroundingSpacesIgnored  StringWriter  out  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  String  CRLF  lineSeparator  String[]  header  values  IOException  e    	[P7_Replace_Invocation]
[PATCH]  new  CSVPrinter  (  out,  this  )  .println  (  values  )  ;	[BUG]  [BUGGY]  new  CSVPrinter(  out,  this)  .CSVPrinter(  out  ,  TDF)  ;[CE]  cannot  find  symbol  [CONTEXT]  public  String  format(String...  values)  {  StringWriter  out  =  new  StringWriter();  try  {  [BUGGY]  new  CSVPrinter(  out,  this)  .CSVPrinter(  out  ,  TDF)  ;  [BUGGY]  }  catch  (IOException  e)  {    }  return  out.toString().trim();  }    [CLASS]  CSVFormat  [METHOD]  format  [RETURN_TYPE]  String    values  [VARIABLES]  boolean  emptyLinesIgnored  surroundingSpacesIgnored  StringWriter  out  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  String  CRLF  lineSeparator  String[]  header  values  IOException  e    	[P7_Replace_Invocation]
[PATCH]  new  CSVPrinter  (  out,  this  )  .println  (  values  )  ;	[BUG]  [BUGGY]  new  CSVPrinter(  out,  this)  .CSVPrinter(  out  ,  EXCEL)  ;[CE]  cannot  find  symbol  [CONTEXT]  public  String  format(String...  values)  {  StringWriter  out  =  new  StringWriter();  try  {  [BUGGY]  new  CSVPrinter(  out,  this)  .CSVPrinter(  out  ,  EXCEL)  ;  [BUGGY]  }  catch  (IOException  e)  {    }  return  out.toString().trim();  }    [CLASS]  CSVFormat  [METHOD]  format  [RETURN_TYPE]  String    values  [VARIABLES]  boolean  emptyLinesIgnored  surroundingSpacesIgnored  StringWriter  out  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  String  CRLF  lineSeparator  String[]  header  values  IOException  e    	[P7_Replace_Invocation]
[PATCH]  StringBuilder  sb  =  new  StringBuilder  (  )  ;	[BUG]  [BUGGY]  StringBuilder  sb  =  new  StringWriter(  )  ;[CE]  incompatible  types  [CONTEXT]  public  String  toString()  {  [BUGGY]  StringBuilder  sb  =  new  StringWriter(  )  ;  [BUGGY]  sb.append( "Delimiter=< ").append(delimiter).append('>');  if  (isEscaping())  {  sb.append('  ');  sb.append( "Escape=< ").append(escape).append('>');  }  if  (isEncapsulating())  {  sb.append('  ');  sb.append( "Encapsulator=< ").append(encapsulator).append('>');  }  if  (isCommentingEnabled())  {  sb.append('  ');  sb.append( "CommentStart=< ").append(commentStart).append('>');  }  if  (isEmptyLinesIgnored())  {  sb.append( "  EmptyLines:ignored ");  }  if  (isSurroundingSpacesIgnored())  {  sb.append( "  SurroundingSpaces:ignored ");  }  return  sb.toString();  }    [CLASS]  CSVFormat  [METHOD]  toString  [RETURN_TYPE]  String    [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header  values  StringBuilder  sb    	[P4_Replace_Constructor]
[PATCH]  sb.append  (   "Delimiter=< "  )  .append  (  delimiter  )  .append  (  '>'  )  ;	[BUG]  [BUGGY]  sb.append(  CRLF)[CE]  ';'  expected  [CONTEXT]  public  String  toString()  {  StringBuilder  sb  =  new  StringBuilder();  [BUGGY]  sb.append(  CRLF)  [BUGGY]  if  (isEscaping())  {  sb.append('  ');  sb.append( "Escape=< ").append(escape).append('>');  }  if  (isEncapsulating())  {  sb.append('  ');  sb.append( "Encapsulator=< ").append(encapsulator).append('>');  }  if  (isCommentingEnabled())  {  sb.append('  ');  sb.append( "CommentStart=< ").append(commentStart).append('>');  }  if  (isEmptyLinesIgnored())  {  sb.append( "  EmptyLines:ignored ");  }  if  (isSurroundingSpacesIgnored())  {  sb.append( "  SurroundingSpaces:ignored ");  }  return  sb.toString();  }    [CLASS]  CSVFormat  [METHOD]  toString  [RETURN_TYPE]  String    [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header  values  StringBuilder  sb    	[P7_Replace_Invocation]
[PATCH]  sb.append  (   "Delimiter=< "  )  .append  (  delimiter  )  .append  (  '>'  )  ;	[BUG]  [BUGGY]  sb.append(  lineSeparator)[CE]  ';'  expected  [CONTEXT]  public  String  toString()  {  StringBuilder  sb  =  new  StringBuilder();  [BUGGY]  sb.append(  lineSeparator)  [BUGGY]  if  (isEscaping())  {  sb.append('  ');  sb.append( "Escape=< ").append(escape).append('>');  }  if  (isEncapsulating())  {  sb.append('  ');  sb.append( "Encapsulator=< ").append(encapsulator).append('>');  }  if  (isCommentingEnabled())  {  sb.append('  ');  sb.append( "CommentStart=< ").append(commentStart).append('>');  }  if  (isEmptyLinesIgnored())  {  sb.append( "  EmptyLines:ignored ");  }  if  (isSurroundingSpacesIgnored())  {  sb.append( "  SurroundingSpaces:ignored ");  }  return  sb.toString();  }    [CLASS]  CSVFormat  [METHOD]  toString  [RETURN_TYPE]  String    [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header  values  StringBuilder  sb    	[P8_Replace_Mix]
[PATCH]  if  (  isEscaping  (  )  )  {  sb.append  (  '  '  )  ;  sb.append  (   "Escape=< "  )  .append  (  escape  )  .append  (  '>'  )  ;  }	[BUG]  [BUGGY]  sb.append('  ');  sb.append( "Escape=< ").append(escape).append('>');[CE]  reached  end  of  file  while  parsing  [CONTEXT]  public  String  toString()  {  StringBuilder  sb  =  new  StringBuilder();  sb.append( "Delimiter=< ").append(delimiter).append('>');  [BUGGY]  sb.append('  ');  sb.append( "Escape=< ").append(escape).append('>');  [BUGGY]    sb.append('  ');  sb.append( "Escape=< ").append(escape).append('>');    if  (isEncapsulating())  {  sb.append('  ');  sb.append( "Encapsulator=< ").append(encapsulator).append('>');  }  if  (isCommentingEnabled())  {  sb.append('  ');  sb.append( "CommentStart=< ").append(commentStart).append('>');  }  if  (isEmptyLinesIgnored())  {  sb.append( "  EmptyLines:ignored ");  }  if  (isSurroundingSpacesIgnored())  {  sb.append( "  SurroundingSpaces:ignored ");  }  return  sb.toString();    [CLASS]  CSVFormat  [METHOD]  toString  [RETURN_TYPE]  String    [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header  values  StringBuilder  sb    	[P15_Unwrap_Block]
[PATCH]  if  (  isEscaping  (  )  )  {  sb.append  (  '  '  )  ;  sb.append  (   "Escape=< "  )  .append  (  escape  )  .append  (  '>'  )  ;  }	[BUG]  [BUGGY]  [CE]  reached  end  of  file  while  parsing  [CONTEXT]  public  String  toString()  {  StringBuilder  sb  =  new  StringBuilder();  sb.append( "Delimiter=< ").append(delimiter).append('>');  [BUGGY]  [BUGGY]      if  (isEncapsulating())  {  sb.append('  ');  sb.append( "Encapsulator=< ").append(encapsulator).append('>');  }  if  (isCommentingEnabled())  {  sb.append('  ');  sb.append( "CommentStart=< ").append(commentStart).append('>');  }  if  (isEmptyLinesIgnored())  {  sb.append( "  EmptyLines:ignored ");  }  if  (isSurroundingSpacesIgnored())  {  sb.append( "  SurroundingSpaces:ignored ");  }  return  sb.toString();    [CLASS]  CSVFormat  [METHOD]  toString  [RETURN_TYPE]  String    [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header  values  StringBuilder  sb    	[P16_Remove_Block]
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  isCommentingEnabled(  )  )  {      sb.append(  '  ')  ;      sb.append(   "CommentStart=< ").append(  commentStart).append(  '>')  ;  }[CE]  illegal  start  of  type  [CONTEXT]  public  String  toString()  {  StringBuilder  sb  =  new  StringBuilder();  sb.append( "Delimiter=< ").append(delimiter).append('>');  [BUGGY]  if  (  isCommentingEnabled(  )  )  {      sb.append(  '  ')  ;      sb.append(   "CommentStart=< ").append(  commentStart).append(  '>')  ;  }  [BUGGY]  sb.append('  ');  sb.append( "Escape=< ").append(escape).append('>');  }  if  (isEncapsulating())  {  sb.append('  ');  sb.append( "Encapsulator=< ").append(encapsulator).append('>');  }  if  (isCommentingEnabled())  {  sb.append('  ');  sb.append( "CommentStart=< ").append(commentStart).append('>');  }  if  (isEmptyLinesIgnored())  {  sb.append( "  EmptyLines:ignored ");  }  if  (isSurroundingSpacesIgnored())  {  sb.append( "  SurroundingSpaces:ignored ");  }  return  sb.toString();  }    [CLASS]  CSVFormat  [METHOD]  toString  [RETURN_TYPE]  String    [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header  values  StringBuilder  sb    	[P13_Insert_Block]
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  isEncapsulating(  )  )  {      sb.append(  '  ')  ;      sb.append(   "Encapsulator=< ").append(  encapsulator).append(  '>')  ;  }[CE]  illegal  start  of  type  [CONTEXT]  public  String  toString()  {  StringBuilder  sb  =  new  StringBuilder();  sb.append( "Delimiter=< ").append(delimiter).append('>');  [BUGGY]  if  (  isEncapsulating(  )  )  {      sb.append(  '  ')  ;      sb.append(   "Encapsulator=< ").append(  encapsulator).append(  '>')  ;  }  [BUGGY]  sb.append('  ');  sb.append( "Escape=< ").append(escape).append('>');  }  if  (isEncapsulating())  {  sb.append('  ');  sb.append( "Encapsulator=< ").append(encapsulator).append('>');  }  if  (isCommentingEnabled())  {  sb.append('  ');  sb.append( "CommentStart=< ").append(commentStart).append('>');  }  if  (isEmptyLinesIgnored())  {  sb.append( "  EmptyLines:ignored ");  }  if  (isSurroundingSpacesIgnored())  {  sb.append( "  SurroundingSpaces:ignored ");  }  return  sb.toString();  }    [CLASS]  CSVFormat  [METHOD]  toString  [RETURN_TYPE]  String    [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header  values  StringBuilder  sb    	[P13_Insert_Block]
[PATCH]  sb.append  (   "Escape=< "  )  .append  (  escape  )  .append  (  '>'  )  ;	[BUG]  [BUGGY]  sb.append(  lineSeparator)[CE]  ';'  expected  [CONTEXT]  public  String  toString()  {  StringBuilder  sb  =  new  StringBuilder();  sb.append( "Delimiter=< ").append(delimiter).append('>');  if  (isEscaping())  {  sb.append('  ');  [BUGGY]  sb.append(  lineSeparator)  [BUGGY]  }  if  (isEncapsulating())  {  sb.append('  ');  sb.append( "Encapsulator=< ").append(encapsulator).append('>');  }  if  (isCommentingEnabled())  {  sb.append('  ');  sb.append( "CommentStart=< ").append(commentStart).append('>');  }  if  (isEmptyLinesIgnored())  {  sb.append( "  EmptyLines:ignored ");  }  if  (isSurroundingSpacesIgnored())  {  sb.append( "  SurroundingSpaces:ignored ");  }  return  sb.toString();  }    [CLASS]  CSVFormat  [METHOD]  toString  [RETURN_TYPE]  String    [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header  values  StringBuilder  sb    	[P7_Replace_Invocation]
[PATCH]  sb.append  (   "Escape=< "  )  .append  (  escape  )  .append  (  '>'  )  ;	[BUG]  [BUGGY]  sb.append(  CRLF)[CE]  ';'  expected  [CONTEXT]  public  String  toString()  {  StringBuilder  sb  =  new  StringBuilder();  sb.append( "Delimiter=< ").append(delimiter).append('>');  if  (isEscaping())  {  sb.append('  ');  [BUGGY]  sb.append(  CRLF)  [BUGGY]  }  if  (isEncapsulating())  {  sb.append('  ');  sb.append( "Encapsulator=< ").append(encapsulator).append('>');  }  if  (isCommentingEnabled())  {  sb.append('  ');  sb.append( "CommentStart=< ").append(commentStart).append('>');  }  if  (isEmptyLinesIgnored())  {  sb.append( "  EmptyLines:ignored ");  }  if  (isSurroundingSpacesIgnored())  {  sb.append( "  SurroundingSpaces:ignored ");  }  return  sb.toString();  }    [CLASS]  CSVFormat  [METHOD]  toString  [RETURN_TYPE]  String    [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header  values  StringBuilder  sb    	[P8_Replace_Mix]
[PATCH]  if  (  isEncapsulating  (  )  )  {  sb.append  (  '  '  )  ;  sb.append  (   "Encapsulator=< "  )  .append  (  encapsulator  )  .append  (  '>'  )  ;  }	[BUG]  [BUGGY]  sb.append('  ');  sb.append( "Encapsulator=< ").append(encapsulator).append('>');[CE]  reached  end  of  file  while  parsing  [CONTEXT]  public  String  toString()  {  StringBuilder  sb  =  new  StringBuilder();  sb.append( "Delimiter=< ").append(delimiter).append('>');  if  (isEscaping())  {  sb.append('  ');  sb.append( "Escape=< ").append(escape).append('>');  }  [BUGGY]  sb.append('  ');  sb.append( "Encapsulator=< ").append(encapsulator).append('>');  [BUGGY]    sb.append('  ');  sb.append( "Encapsulator=< ").append(encapsulator).append('>');    if  (isCommentingEnabled())  {  sb.append('  ');  sb.append( "CommentStart=< ").append(commentStart).append('>');  }  if  (isEmptyLinesIgnored())  {  sb.append( "  EmptyLines:ignored ");  }  if  (isSurroundingSpacesIgnored())  {  sb.append( "  SurroundingSpaces:ignored ");  }  return  sb.toString();    [CLASS]  CSVFormat  [METHOD]  toString  [RETURN_TYPE]  String    [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header  values  StringBuilder  sb    	[P15_Unwrap_Block]
[PATCH]  if  (  isEncapsulating  (  )  )  {  sb.append  (  '  '  )  ;  sb.append  (   "Encapsulator=< "  )  .append  (  encapsulator  )  .append  (  '>'  )  ;  }	[BUG]  [BUGGY]  [CE]  reached  end  of  file  while  parsing  [CONTEXT]  public  String  toString()  {  StringBuilder  sb  =  new  StringBuilder();  sb.append( "Delimiter=< ").append(delimiter).append('>');  if  (isEscaping())  {  sb.append('  ');  sb.append( "Escape=< ").append(escape).append('>');  }  [BUGGY]  [BUGGY]      if  (isCommentingEnabled())  {  sb.append('  ');  sb.append( "CommentStart=< ").append(commentStart).append('>');  }  if  (isEmptyLinesIgnored())  {  sb.append( "  EmptyLines:ignored ");  }  if  (isSurroundingSpacesIgnored())  {  sb.append( "  SurroundingSpaces:ignored ");  }  return  sb.toString();    [CLASS]  CSVFormat  [METHOD]  toString  [RETURN_TYPE]  String    [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header  values  StringBuilder  sb    	[P16_Remove_Block]
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  isCommentingEnabled(  )  )  {      sb.append(  '  ')  ;      sb.append(   "CommentStart=< ").append(  commentStart).append(  '>')  ;  }[CE]  illegal  start  of  type  [CONTEXT]  public  String  toString()  {  StringBuilder  sb  =  new  StringBuilder();  sb.append( "Delimiter=< ").append(delimiter).append('>');  if  (isEscaping())  {  sb.append('  ');  sb.append( "Escape=< ").append(escape).append('>');  }  [BUGGY]  if  (  isCommentingEnabled(  )  )  {      sb.append(  '  ')  ;      sb.append(   "CommentStart=< ").append(  commentStart).append(  '>')  ;  }  [BUGGY]  sb.append('  ');  sb.append( "Encapsulator=< ").append(encapsulator).append('>');  }  if  (isCommentingEnabled())  {  sb.append('  ');  sb.append( "CommentStart=< ").append(commentStart).append('>');  }  if  (isEmptyLinesIgnored())  {  sb.append( "  EmptyLines:ignored ");  }  if  (isSurroundingSpacesIgnored())  {  sb.append( "  SurroundingSpaces:ignored ");  }  return  sb.toString();  }    [CLASS]  CSVFormat  [METHOD]  toString  [RETURN_TYPE]  String    [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header  values  StringBuilder  sb    	[P13_Insert_Block]
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  isEscaping(  )  )  {      sb.append(  '  ')  ;      sb.append(   "Escape=< ").append(  escape).append(  '>')  ;  }[CE]  illegal  start  of  type  [CONTEXT]  public  String  toString()  {  StringBuilder  sb  =  new  StringBuilder();  sb.append( "Delimiter=< ").append(delimiter).append('>');  if  (isEscaping())  {  sb.append('  ');  sb.append( "Escape=< ").append(escape).append('>');  }  [BUGGY]  if  (  isEscaping(  )  )  {      sb.append(  '  ')  ;      sb.append(   "Escape=< ").append(  escape).append(  '>')  ;  }  [BUGGY]  sb.append('  ');  sb.append( "Encapsulator=< ").append(encapsulator).append('>');  }  if  (isCommentingEnabled())  {  sb.append('  ');  sb.append( "CommentStart=< ").append(commentStart).append('>');  }  if  (isEmptyLinesIgnored())  {  sb.append( "  EmptyLines:ignored ");  }  if  (isSurroundingSpacesIgnored())  {  sb.append( "  SurroundingSpaces:ignored ");  }  return  sb.toString();  }    [CLASS]  CSVFormat  [METHOD]  toString  [RETURN_TYPE]  String    [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header  values  StringBuilder  sb    	[P13_Insert_Block]
[PATCH]  sb.append  (   "Encapsulator=< "  )  .append  (  encapsulator  )  .append  (  '>'  )  ;	[BUG]  [BUGGY]  sb.append(  CRLF)[CE]  ';'  expected  [CONTEXT]  public  String  toString()  {  StringBuilder  sb  =  new  StringBuilder();  sb.append( "Delimiter=< ").append(delimiter).append('>');  if  (isEscaping())  {  sb.append('  ');  sb.append( "Escape=< ").append(escape).append('>');  }  if  (isEncapsulating())  {  sb.append('  ');  [BUGGY]  sb.append(  CRLF)  [BUGGY]  }  if  (isCommentingEnabled())  {  sb.append('  ');  sb.append( "CommentStart=< ").append(commentStart).append('>');  }  if  (isEmptyLinesIgnored())  {  sb.append( "  EmptyLines:ignored ");  }  if  (isSurroundingSpacesIgnored())  {  sb.append( "  SurroundingSpaces:ignored ");  }  return  sb.toString();  }    [CLASS]  CSVFormat  [METHOD]  toString  [RETURN_TYPE]  String    [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header  values  StringBuilder  sb    	[P7_Replace_Invocation]
[PATCH]  sb.append  (   "Encapsulator=< "  )  .append  (  encapsulator  )  .append  (  '>'  )  ;	[BUG]  [BUGGY]  sb.append(  lineSeparator)[CE]  ';'  expected  [CONTEXT]  public  String  toString()  {  StringBuilder  sb  =  new  StringBuilder();  sb.append( "Delimiter=< ").append(delimiter).append('>');  if  (isEscaping())  {  sb.append('  ');  sb.append( "Escape=< ").append(escape).append('>');  }  if  (isEncapsulating())  {  sb.append('  ');  [BUGGY]  sb.append(  lineSeparator)  [BUGGY]  }  if  (isCommentingEnabled())  {  sb.append('  ');  sb.append( "CommentStart=< ").append(commentStart).append('>');  }  if  (isEmptyLinesIgnored())  {  sb.append( "  EmptyLines:ignored ");  }  if  (isSurroundingSpacesIgnored())  {  sb.append( "  SurroundingSpaces:ignored ");  }  return  sb.toString();  }    [CLASS]  CSVFormat  [METHOD]  toString  [RETURN_TYPE]  String    [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header  values  StringBuilder  sb    	[P7_Replace_Invocation]
[PATCH]  if  (  isCommentingEnabled  (  )  )  {  sb.append  (  '  '  )  ;  sb.append  (   "CommentStart=< "  )  .append  (  commentStart  )  .append  (  '>'  )  ;  }	[BUG]  [BUGGY]  sb.append('  ');  sb.append( "CommentStart=< ").append(commentStart).append('>');[CE]  reached  end  of  file  while  parsing  [CONTEXT]  public  String  toString()  {  StringBuilder  sb  =  new  StringBuilder();  sb.append( "Delimiter=< ").append(delimiter).append('>');  if  (isEscaping())  {  sb.append('  ');  sb.append( "Escape=< ").append(escape).append('>');  }  if  (isEncapsulating())  {  sb.append('  ');  sb.append( "Encapsulator=< ").append(encapsulator).append('>');  }  [BUGGY]  sb.append('  ');  sb.append( "CommentStart=< ").append(commentStart).append('>');  [BUGGY]    sb.append('  ');  sb.append( "CommentStart=< ").append(commentStart).append('>');    if  (isEmptyLinesIgnored())  {  sb.append( "  EmptyLines:ignored ");  }  if  (isSurroundingSpacesIgnored())  {  sb.append( "  SurroundingSpaces:ignored ");  }  return  sb.toString();    [CLASS]  CSVFormat  [METHOD]  toString  [RETURN_TYPE]  String    [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header  values  StringBuilder  sb    	[P15_Unwrap_Block]
[PATCH]  if  (  isCommentingEnabled  (  )  )  {  sb.append  (  '  '  )  ;  sb.append  (   "CommentStart=< "  )  .append  (  commentStart  )  .append  (  '>'  )  ;  }	[BUG]  [BUGGY]  [CE]  reached  end  of  file  while  parsing  [CONTEXT]  public  String  toString()  {  StringBuilder  sb  =  new  StringBuilder();  sb.append( "Delimiter=< ").append(delimiter).append('>');  if  (isEscaping())  {  sb.append('  ');  sb.append( "Escape=< ").append(escape).append('>');  }  if  (isEncapsulating())  {  sb.append('  ');  sb.append( "Encapsulator=< ").append(encapsulator).append('>');  }  [BUGGY]  [BUGGY]      if  (isEmptyLinesIgnored())  {  sb.append( "  EmptyLines:ignored ");  }  if  (isSurroundingSpacesIgnored())  {  sb.append( "  SurroundingSpaces:ignored ");  }  return  sb.toString();    [CLASS]  CSVFormat  [METHOD]  toString  [RETURN_TYPE]  String    [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header  values  StringBuilder  sb    	[P16_Remove_Block]
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  isEscaping(  )  )  {      sb.append(  '  ')  ;      sb.append(   "Escape=< ").append(  escape).append(  '>')  ;  }[CE]  illegal  start  of  type  [CONTEXT]  public  String  toString()  {  StringBuilder  sb  =  new  StringBuilder();  sb.append( "Delimiter=< ").append(delimiter).append('>');  if  (isEscaping())  {  sb.append('  ');  sb.append( "Escape=< ").append(escape).append('>');  }  if  (isEncapsulating())  {  sb.append('  ');  sb.append( "Encapsulator=< ").append(encapsulator).append('>');  }  [BUGGY]  if  (  isEscaping(  )  )  {      sb.append(  '  ')  ;      sb.append(   "Escape=< ").append(  escape).append(  '>')  ;  }  [BUGGY]  sb.append('  ');  sb.append( "CommentStart=< ").append(commentStart).append('>');  }  if  (isEmptyLinesIgnored())  {  sb.append( "  EmptyLines:ignored ");  }  if  (isSurroundingSpacesIgnored())  {  sb.append( "  SurroundingSpaces:ignored ");  }  return  sb.toString();  }    [CLASS]  CSVFormat  [METHOD]  toString  [RETURN_TYPE]  String    [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header  values  StringBuilder  sb    	[P13_Insert_Block]
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  isEncapsulating(  )  )  {      sb.append(  '  ')  ;      sb.append(   "Encapsulator=< ").append(  encapsulator).append(  '>')  ;  }[CE]  illegal  start  of  type  [CONTEXT]  public  String  toString()  {  StringBuilder  sb  =  new  StringBuilder();  sb.append( "Delimiter=< ").append(delimiter).append('>');  if  (isEscaping())  {  sb.append('  ');  sb.append( "Escape=< ").append(escape).append('>');  }  if  (isEncapsulating())  {  sb.append('  ');  sb.append( "Encapsulator=< ").append(encapsulator).append('>');  }  [BUGGY]  if  (  isEncapsulating(  )  )  {      sb.append(  '  ')  ;      sb.append(   "Encapsulator=< ").append(  encapsulator).append(  '>')  ;  }  [BUGGY]  sb.append('  ');  sb.append( "CommentStart=< ").append(commentStart).append('>');  }  if  (isEmptyLinesIgnored())  {  sb.append( "  EmptyLines:ignored ");  }  if  (isSurroundingSpacesIgnored())  {  sb.append( "  SurroundingSpaces:ignored ");  }  return  sb.toString();  }    [CLASS]  CSVFormat  [METHOD]  toString  [RETURN_TYPE]  String    [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header  values  StringBuilder  sb    	[P13_Insert_Block]
[PATCH]  sb.append  (   "CommentStart=< "  )  .append  (  commentStart  )  .append  (  '>'  )  ;	[BUG]  [BUGGY]  sb.append(  lineSeparator)[CE]  ';'  expected  [CONTEXT]  public  String  toString()  {  StringBuilder  sb  =  new  StringBuilder();  sb.append( "Delimiter=< ").append(delimiter).append('>');  if  (isEscaping())  {  sb.append('  ');  sb.append( "Escape=< ").append(escape).append('>');  }  if  (isEncapsulating())  {  sb.append('  ');  sb.append( "Encapsulator=< ").append(encapsulator).append('>');  }  if  (isCommentingEnabled())  {  sb.append('  ');  [BUGGY]  sb.append(  lineSeparator)  [BUGGY]  }  if  (isEmptyLinesIgnored())  {  sb.append( "  EmptyLines:ignored ");  }  if  (isSurroundingSpacesIgnored())  {  sb.append( "  SurroundingSpaces:ignored ");  }  return  sb.toString();  }    [CLASS]  CSVFormat  [METHOD]  toString  [RETURN_TYPE]  String    [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header  values  StringBuilder  sb    	[P7_Replace_Invocation]
[PATCH]  sb.append  (   "CommentStart=< "  )  .append  (  commentStart  )  .append  (  '>'  )  ;	[BUG]  [BUGGY]  sb.append(  CRLF)[CE]  ';'  expected  [CONTEXT]  public  String  toString()  {  StringBuilder  sb  =  new  StringBuilder();  sb.append( "Delimiter=< ").append(delimiter).append('>');  if  (isEscaping())  {  sb.append('  ');  sb.append( "Escape=< ").append(escape).append('>');  }  if  (isEncapsulating())  {  sb.append('  ');  sb.append( "Encapsulator=< ").append(encapsulator).append('>');  }  if  (isCommentingEnabled())  {  sb.append('  ');  [BUGGY]  sb.append(  CRLF)  [BUGGY]  }  if  (isEmptyLinesIgnored())  {  sb.append( "  EmptyLines:ignored ");  }  if  (isSurroundingSpacesIgnored())  {  sb.append( "  SurroundingSpaces:ignored ");  }  return  sb.toString();  }    [CLASS]  CSVFormat  [METHOD]  toString  [RETURN_TYPE]  String    [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header  values  StringBuilder  sb    	[P7_Replace_Invocation]
[PATCH]  if  (  isEmptyLinesIgnored  (  )  )  {  sb.append  (   "  EmptyLines:ignored "  )  ;  }	[BUG]  [BUGGY]  sb.append( "  EmptyLines:ignored ");[CE]  reached  end  of  file  while  parsing  [CONTEXT]  public  String  toString()  {  StringBuilder  sb  =  new  StringBuilder();  sb.append( "Delimiter=< ").append(delimiter).append('>');  if  (isEscaping())  {  sb.append('  ');  sb.append( "Escape=< ").append(escape).append('>');  }  if  (isEncapsulating())  {  sb.append('  ');  sb.append( "Encapsulator=< ").append(encapsulator).append('>');  }  if  (isCommentingEnabled())  {  sb.append('  ');  sb.append( "CommentStart=< ").append(commentStart).append('>');  }  [BUGGY]  sb.append( "  EmptyLines:ignored ");  [BUGGY]    sb.append( "  EmptyLines:ignored ");  if  (isSurroundingSpacesIgnored())  {  sb.append( "  SurroundingSpaces:ignored ");  }  return  sb.toString();    [CLASS]  CSVFormat  [METHOD]  toString  [RETURN_TYPE]  String    [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header  values  StringBuilder  sb    	[P15_Unwrap_Block]
[PATCH]  if  (  isEmptyLinesIgnored  (  )  )  {  sb.append  (   "  EmptyLines:ignored "  )  ;  }	[BUG]  [BUGGY]  [CE]  reached  end  of  file  while  parsing  [CONTEXT]  public  String  toString()  {  StringBuilder  sb  =  new  StringBuilder();  sb.append( "Delimiter=< ").append(delimiter).append('>');  if  (isEscaping())  {  sb.append('  ');  sb.append( "Escape=< ").append(escape).append('>');  }  if  (isEncapsulating())  {  sb.append('  ');  sb.append( "Encapsulator=< ").append(encapsulator).append('>');  }  if  (isCommentingEnabled())  {  sb.append('  ');  sb.append( "CommentStart=< ").append(commentStart).append('>');  }  [BUGGY]  [BUGGY]      if  (isSurroundingSpacesIgnored())  {  sb.append( "  SurroundingSpaces:ignored ");  }  return  sb.toString();    [CLASS]  CSVFormat  [METHOD]  toString  [RETURN_TYPE]  String    [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header  values  StringBuilder  sb    	[P16_Remove_Block]
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  isSurroundingSpacesIgnored(  )  )  {      sb.append(   "  SurroundingSpaces:ignored ")  ;  }[CE]  illegal  start  of  type  [CONTEXT]  public  String  toString()  {  StringBuilder  sb  =  new  StringBuilder();  sb.append( "Delimiter=< ").append(delimiter).append('>');  if  (isEscaping())  {  sb.append('  ');  sb.append( "Escape=< ").append(escape).append('>');  }  if  (isEncapsulating())  {  sb.append('  ');  sb.append( "Encapsulator=< ").append(encapsulator).append('>');  }  if  (isCommentingEnabled())  {  sb.append('  ');  sb.append( "CommentStart=< ").append(commentStart).append('>');  }  [BUGGY]  if  (  isSurroundingSpacesIgnored(  )  )  {      sb.append(   "  SurroundingSpaces:ignored ")  ;  }  [BUGGY]  sb.append( "  EmptyLines:ignored ");  }  if  (isSurroundingSpacesIgnored())  {  sb.append( "  SurroundingSpaces:ignored ");  }  return  sb.toString();  }    [CLASS]  CSVFormat  [METHOD]  toString  [RETURN_TYPE]  String    [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header  values  StringBuilder  sb    	[P13_Insert_Block]
[PATCH]  if  (  isSurroundingSpacesIgnored  (  )  )  {  sb.append  (   "  SurroundingSpaces:ignored "  )  ;  }	[BUG]  [BUGGY]  sb.append( "  SurroundingSpaces:ignored ");[CE]  reached  end  of  file  while  parsing  [CONTEXT]  public  String  toString()  {  StringBuilder  sb  =  new  StringBuilder();  sb.append( "Delimiter=< ").append(delimiter).append('>');  if  (isEscaping())  {  sb.append('  ');  sb.append( "Escape=< ").append(escape).append('>');  }  if  (isEncapsulating())  {  sb.append('  ');  sb.append( "Encapsulator=< ").append(encapsulator).append('>');  }  if  (isCommentingEnabled())  {  sb.append('  ');  sb.append( "CommentStart=< ").append(commentStart).append('>');  }  if  (isEmptyLinesIgnored())  {  sb.append( "  EmptyLines:ignored ");  }  [BUGGY]  sb.append( "  SurroundingSpaces:ignored ");  [BUGGY]    sb.append( "  SurroundingSpaces:ignored ");  return  sb.toString();    [CLASS]  CSVFormat  [METHOD]  toString  [RETURN_TYPE]  String    [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header  values  StringBuilder  sb    	[P15_Unwrap_Block]
[PATCH]  if  (  isSurroundingSpacesIgnored  (  )  )  {  sb.append  (   "  SurroundingSpaces:ignored "  )  ;  }	[BUG]  [BUGGY]  [CE]  reached  end  of  file  while  parsing  [CONTEXT]  public  String  toString()  {  StringBuilder  sb  =  new  StringBuilder();  sb.append( "Delimiter=< ").append(delimiter).append('>');  if  (isEscaping())  {  sb.append('  ');  sb.append( "Escape=< ").append(escape).append('>');  }  if  (isEncapsulating())  {  sb.append('  ');  sb.append( "Encapsulator=< ").append(encapsulator).append('>');  }  if  (isCommentingEnabled())  {  sb.append('  ');  sb.append( "CommentStart=< ").append(commentStart).append('>');  }  if  (isEmptyLinesIgnored())  {  sb.append( "  EmptyLines:ignored ");  }  [BUGGY]  [BUGGY]      return  sb.toString();    [CLASS]  CSVFormat  [METHOD]  toString  [RETURN_TYPE]  String    [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header  values  StringBuilder  sb    	[P16_Remove_Block]
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  isEmptyLinesIgnored(  )  )  {      sb.append(   "  EmptyLines:ignored ")  ;  }[CE]  illegal  start  of  type  [CONTEXT]  public  String  toString()  {  StringBuilder  sb  =  new  StringBuilder();  sb.append( "Delimiter=< ").append(delimiter).append('>');  if  (isEscaping())  {  sb.append('  ');  sb.append( "Escape=< ").append(escape).append('>');  }  if  (isEncapsulating())  {  sb.append('  ');  sb.append( "Encapsulator=< ").append(encapsulator).append('>');  }  if  (isCommentingEnabled())  {  sb.append('  ');  sb.append( "CommentStart=< ").append(commentStart).append('>');  }  if  (isEmptyLinesIgnored())  {  sb.append( "  EmptyLines:ignored ");  }  [BUGGY]  if  (  isEmptyLinesIgnored(  )  )  {      sb.append(   "  EmptyLines:ignored ")  ;  }  [BUGGY]  sb.append( "  SurroundingSpaces:ignored ");  }  return  sb.toString();  }    [CLASS]  CSVFormat  [METHOD]  toString  [RETURN_TYPE]  String    [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header  values  StringBuilder  sb    	[P13_Insert_Block]
[PATCH]  return  sb.toString  (  )  ;	[BUG]  [BUGGY]  return  sb.append(  )  ;[CE]  no  suitable  method  found  for  append()  [CONTEXT]  public  String  toString()  {  StringBuilder  sb  =  new  StringBuilder();  sb.append( "Delimiter=< ").append(delimiter).append('>');  if  (isEscaping())  {  sb.append('  ');  sb.append( "Escape=< ").append(escape).append('>');  }  if  (isEncapsulating())  {  sb.append('  ');  sb.append( "Encapsulator=< ").append(encapsulator).append('>');  }  if  (isCommentingEnabled())  {  sb.append('  ');  sb.append( "CommentStart=< ").append(commentStart).append('>');  }  if  (isEmptyLinesIgnored())  {  sb.append( "  EmptyLines:ignored ");  }  if  (isSurroundingSpacesIgnored())  {  sb.append( "  SurroundingSpaces:ignored ");  }  [BUGGY]  return  sb.append(  )  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  toString  [RETURN_TYPE]  String    [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header  values  StringBuilder  sb    	[P7_Replace_Invocation]
[PATCH]  return  sb.toString  (  )  ;	[BUG]  [BUGGY]  return  sb.StringWriter(  )  ;[CE]  cannot  find  symbol  [CONTEXT]  public  String  toString()  {  StringBuilder  sb  =  new  StringBuilder();  sb.append( "Delimiter=< ").append(delimiter).append('>');  if  (isEscaping())  {  sb.append('  ');  sb.append( "Escape=< ").append(escape).append('>');  }  if  (isEncapsulating())  {  sb.append('  ');  sb.append( "Encapsulator=< ").append(encapsulator).append('>');  }  if  (isCommentingEnabled())  {  sb.append('  ');  sb.append( "CommentStart=< ").append(commentStart).append('>');  }  if  (isEmptyLinesIgnored())  {  sb.append( "  EmptyLines:ignored ");  }  if  (isSurroundingSpacesIgnored())  {  sb.append( "  SurroundingSpaces:ignored ");  }  [BUGGY]  return  sb.StringWriter(  )  ;  [BUGGY]  }    [CLASS]  CSVFormat  [METHOD]  toString  [RETURN_TYPE]  String    [VARIABLES]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  boolean  emptyLinesIgnored  surroundingSpacesIgnored  String  CRLF  lineSeparator  String[]  header  values  StringBuilder  sb    	[P8_Replace_Mix]
[PATCH]  private  static  final  int  INITIAL_TOKEN_LENGTH  =  50;	[BUG]  [BUGGY]  private  static  final  int  INITIAL_TOKEN_LENGTH  =  50L;[CE]  possible  loss  of  precision  [CONTEXT]      class  Token  {    [BUGGY]  private  static  final  int  INITIAL_TOKEN_LENGTH  =  50L;  [BUGGY]    enum  Type  {    INVALID,      [CLASS]  Token  Type    [VARIABLES]  	[P8_Replace_Mix]
[PATCH]  Token.Type  type  =  INVALID;	[BUG]  [BUGGY]  Token.Type  type  ;[FE]  Token  type  expected:<TOKEN>  but  was:<null>  testNextToken1  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]    EORECORD  }    [BUGGY]  Token.Type  type  ;  [BUGGY]      StringBuilder  content  =  new  StringBuilder(INITIAL_TOKEN_LENGTH);        [CLASS]  Token  Type    [VARIABLES]  	[P8_Replace_Mix]
[PATCH]  content.setLength  (  0  )  ;	[BUG]  [BUGGY]  content.setLength(  INITIAL_TOKEN_LENGTH)  ;[FE]  Token  content  expected:<[]>  but  was:<[  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  Token  reset()  {  [BUGGY]  content.setLength(  INITIAL_TOKEN_LENGTH)  ;  [BUGGY]  type  =  INVALID;  isReady  =  false;  return  this;  }    [CLASS]  Token  Type  [METHOD]  reset  [RETURN_TYPE]  Token    [VARIABLES]  Type  EOF  EORECORD  INVALID  TOKEN  type  boolean  isReady  StringBuilder  content  int  INITIAL_TOKEN_LENGTH    	[P3_Replace_Literal]
[PATCH]  content.setLength  (  0  )  ;  type  =  INVALID;	[BUG]  [BUGGY]  [FE]  null  testDefaultFormat  assertTrue(CSVPrinterTest.equals(res_comments,  records));  [CONTEXT]  Token  reset()  {  [BUGGY]  [BUGGY]    isReady  =  false;  return  this;    [CLASS]  Token  Type  [METHOD]  reset  [RETURN_TYPE]  Token    [VARIABLES]  Type  EOF  EORECORD  INVALID  TOKEN  type  boolean  isReady  StringBuilder  content  int  INITIAL_TOKEN_LENGTH    	[P14_Delete_Statement]
[PATCH]  type  =  INVALID;	[BUG]  [BUGGY]  type  =  type;[FE]  null  testDefaultFormat  assertTrue(CSVPrinterTest.equals(res_comments,  records));  [CONTEXT]  Token  reset()  {  content.setLength(0);  [BUGGY]  type  =  type;  [BUGGY]  isReady  =  false;  return  this;  }    [CLASS]  Token  Type  [METHOD]  reset  [RETURN_TYPE]  Token    [VARIABLES]  Type  EOF  EORECORD  INVALID  TOKEN  type  boolean  isReady  StringBuilder  content  int  INITIAL_TOKEN_LENGTH    	[P5_Replace_Variable]
[PATCH]  type  =  INVALID;	[BUG]  [BUGGY]  type  =  null  ;[FE]  Token  type  expected:<EORECORD>  but  was:<null>  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  Token  reset()  {  content.setLength(0);  [BUGGY]  type  =  null  ;  [BUGGY]  isReady  =  false;  return  this;  }    [CLASS]  Token  Type  [METHOD]  reset  [RETURN_TYPE]  Token    [VARIABLES]  Type  EOF  EORECORD  INVALID  TOKEN  type  boolean  isReady  StringBuilder  content  int  INITIAL_TOKEN_LENGTH    	[P8_Replace_Mix]
[PATCH]  isReady  =  false;	[BUG]  [BUGGY]  isReady  =  true;[FE]  [CONTEXT]  Token  reset()  {  content.setLength(0);  type  =  INVALID;  [BUGGY]  isReady  =  true;  [BUGGY]  return  this;  }    [CLASS]  Token  Type  [METHOD]  reset  [RETURN_TYPE]  Token    [VARIABLES]  Type  EOF  EORECORD  INVALID  TOKEN  type  boolean  isReady  StringBuilder  content  int  INITIAL_TOKEN_LENGTH    	[P3_Replace_Literal]
[PATCH]  return  this;	[BUG]  [BUGGY]  return  null;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  Token  reset()  {  content.setLength(0);  type  =  INVALID;  isReady  =  false;  [BUGGY]  return  null;  [BUGGY]  }    [CLASS]  Token  Type  [METHOD]  reset  [RETURN_TYPE]  Token    [VARIABLES]  Type  EOF  EORECORD  INVALID  TOKEN  type  boolean  isReady  StringBuilder  content  int  INITIAL_TOKEN_LENGTH    	[P8_Replace_Mix]
[PATCH]  static  final  int  END_OF_STREAM  =  -1;	[BUG]  [BUGGY]  static  final  long  END_OF_STREAM  =  -1;[CE]  possible  loss  of  precision  [CONTEXT]      class  ExtendedBufferedReader  extends  BufferedReader  {    [BUGGY]  static  final  long  END_OF_STREAM  =  -1;  [BUGGY]      static  final  int  UNDEFINED  =  -2;        [CLASS]  ExtendedBufferedReader    [VARIABLES]  	[P1_Replace_Type]
[PATCH]  static  final  int  END_OF_STREAM  =  -1;	[BUG]  [BUGGY]  static  final  long  END_OF_STREAM  =  -3;[CE]  possible  loss  of  precision  [CONTEXT]      class  ExtendedBufferedReader  extends  BufferedReader  {    [BUGGY]  static  final  long  END_OF_STREAM  =  -3;  [BUGGY]      static  final  int  UNDEFINED  =  -2;        [CLASS]  ExtendedBufferedReader    [VARIABLES]  	[P8_Replace_Mix]
[PATCH]  static  final  int  UNDEFINED  =  -2;	[BUG]  [BUGGY]  static  final  short  UNDEFINED  =  -2;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]    static  final  int  END_OF_STREAM  =  -1;    [BUGGY]  static  final  short  UNDEFINED  =  -2;  [BUGGY]      private  int  lastChar  =  UNDEFINED;        [CLASS]  ExtendedBufferedReader    [VARIABLES]  	[P1_Replace_Type]
[PATCH]  static  final  int  UNDEFINED  =  -2;	[BUG]  [BUGGY]  static  final  int  UNDEFINED  =  -11;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]    static  final  int  END_OF_STREAM  =  -1;    [BUGGY]  static  final  int  UNDEFINED  =  -11;  [BUGGY]      private  int  lastChar  =  UNDEFINED;        [CLASS]  ExtendedBufferedReader    [VARIABLES]  	[P3_Replace_Literal]
[PATCH]  static  final  int  UNDEFINED  =  -2;	[BUG]  [BUGGY]  static  final  int  UNDEFINED  =  null  ;[CE]  incompatible  types  [CONTEXT]    static  final  int  END_OF_STREAM  =  -1;    [BUGGY]  static  final  int  UNDEFINED  =  null  ;  [BUGGY]      private  int  lastChar  =  UNDEFINED;        [CLASS]  ExtendedBufferedReader    [VARIABLES]  	[P8_Replace_Mix]
[PATCH]  private  int  lastChar  =  UNDEFINED;	[BUG]  [BUGGY]  private  short  lastChar  =  UNDEFINED;[CE]  possible  loss  of  precision  [CONTEXT]    static  final  int  UNDEFINED  =  -2;    [BUGGY]  private  short  lastChar  =  UNDEFINED;  [BUGGY]      private  int  lineCounter  =  0;        [CLASS]  ExtendedBufferedReader    [VARIABLES]  	[P1_Replace_Type]
[PATCH]  private  int  lastChar  =  UNDEFINED;	[BUG]  [BUGGY]  private  long  lastChar  =  UNDEFINED;[CE]  possible  loss  of  precision  [CONTEXT]    static  final  int  UNDEFINED  =  -2;    [BUGGY]  private  long  lastChar  =  UNDEFINED;  [BUGGY]      private  int  lineCounter  =  0;        [CLASS]  ExtendedBufferedReader    [VARIABLES]  	[P8_Replace_Mix]
[PATCH]  private  int  lineCounter  =  0;	[BUG]  [BUGGY]  private  short  lineCounter  =  0;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]    private  int  lastChar  =  UNDEFINED;    [BUGGY]  private  short  lineCounter  =  0;  [BUGGY]          ExtendedBufferedReader(Reader  r)  {    [CLASS]  ExtendedBufferedReader    [VARIABLES]  	[P1_Replace_Type]
[PATCH]  private  int  lineCounter  =  0;	[BUG]  [BUGGY]  private  int  lineCounter  =  0  +  2;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]    private  int  lastChar  =  UNDEFINED;    [BUGGY]  private  int  lineCounter  =  0  +  2;  [BUGGY]          ExtendedBufferedReader(Reader  r)  {    [CLASS]  ExtendedBufferedReader    [VARIABLES]  	[P8_Replace_Mix]
[PATCH]  super  (  r  )  ;	[BUG]  [BUGGY]  [FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  ExtendedBufferedReader(Reader  r)  {  [BUGGY]  [BUGGY]      [CLASS]  ExtendedBufferedReader  [METHOD]  <init>  [RETURN_TYPE]  Reader)    Reader  r  [VARIABLES]  Reader  r  int  END_OF_STREAM  UNDEFINED  lastChar  lineCounter  boolean    	[P14_Delete_Statement]
[PATCH]  super  (  r  )  ;	[BUG]  [BUGGY]  super.reset(  )  ;super(  r)  ;[CE]  no  suitable  constructor  found  for  BufferedReader()  [CONTEXT]  ExtendedBufferedReader(Reader  r)  {  [BUGGY]  super.reset(  )  ;super(  r)  ;  [BUGGY]  }    [CLASS]  ExtendedBufferedReader  [METHOD]  <init>  [RETURN_TYPE]  Reader)    Reader  r  [VARIABLES]  Reader  r  int  END_OF_STREAM  UNDEFINED  lastChar  lineCounter  boolean    	[P11_Insert_Donor_Statement]
[PATCH]  super  (  r  )  ;	[BUG]  [BUGGY]  super.mark(  1)  ;super(  r)  ;[CE]  no  suitable  constructor  found  for  BufferedReader()  [CONTEXT]  ExtendedBufferedReader(Reader  r)  {  [BUGGY]  super.mark(  1)  ;super(  r)  ;  [BUGGY]  }    [CLASS]  ExtendedBufferedReader  [METHOD]  <init>  [RETURN_TYPE]  Reader)    Reader  r  [VARIABLES]  Reader  r  int  END_OF_STREAM  UNDEFINED  lastChar  lineCounter  boolean    	[P11_Insert_Donor_Statement]
[PATCH]  int  current  =  super.read  (  )  ;	[BUG]  [BUGGY]  long  current  =  super.read(  )  ;[CE]  possible  loss  of  precision  [CONTEXT]  public  int  read()  throws  IOException  {  [BUGGY]  long  current  =  super.read(  )  ;  [BUGGY]  if  (current  ==  '\r'  ||  (current  ==  '\n'  &&  lastChar  !=  '\r'))  {  lineCounter++;  }  lastChar  =  current;  return  lastChar;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  read  [RETURN_TYPE]  int    [VARIABLES]  int  END_OF_STREAM  UNDEFINED  current  lastChar  lineCounter  boolean    	[P1_Replace_Type]
[PATCH]  int  current  =  super.read  (  )  ;	[BUG]  [BUGGY]  int  current  =  super.mark(  )  ;[CE]  no  suitable  method  found  for  mark()  [CONTEXT]  public  int  read()  throws  IOException  {  [BUGGY]  int  current  =  super.mark(  )  ;  [BUGGY]  if  (current  ==  '\r'  ||  (current  ==  '\n'  &&  lastChar  !=  '\r'))  {  lineCounter++;  }  lastChar  =  current;  return  lastChar;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  read  [RETURN_TYPE]  int    [VARIABLES]  int  END_OF_STREAM  UNDEFINED  current  lastChar  lineCounter  boolean    	[P7_Replace_Invocation]
[PATCH]  int  current  =  super.read  (  )  ;	[BUG]  [BUGGY]  String  line  =  super.readLine(  )  ;int  current  =  super.read(  )  ;[FE]  Token  type  expected:<TOKEN>  but  was:<EOF>  testNextToken1  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  int  read()  throws  IOException  {  [BUGGY]  String  line  =  super.readLine(  )  ;int  current  =  super.read(  )  ;  [BUGGY]  if  (current  ==  '\r'  ||  (current  ==  '\n'  &&  lastChar  !=  '\r'))  {  lineCounter++;  }  lastChar  =  current;  return  lastChar;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  read  [RETURN_TYPE]  int    [VARIABLES]  int  END_OF_STREAM  UNDEFINED  current  lastChar  lineCounter  boolean    	[P11_Insert_Donor_Statement]
[PATCH]  int  current  =  super.read  (  )  ;	[BUG]  [BUGGY]  int  c  =  super.read(  )  ;int  current  =  super.read(  )  ;[FE]  Token  content  expected:<[abc]>  but  was:<[b]>  testNextToken1  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  int  read()  throws  IOException  {  [BUGGY]  int  c  =  super.read(  )  ;int  current  =  super.read(  )  ;  [BUGGY]  if  (current  ==  '\r'  ||  (current  ==  '\n'  &&  lastChar  !=  '\r'))  {  lineCounter++;  }  lastChar  =  current;  return  lastChar;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  read  [RETURN_TYPE]  int    [VARIABLES]  int  END_OF_STREAM  UNDEFINED  current  lastChar  lineCounter  boolean    	[P11_Insert_Donor_Statement]
[PATCH]  int  current  =  super.read  (  )  ;	[BUG]  [BUGGY]  [FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  int  read()  throws  IOException  {  [BUGGY]  [BUGGY]    if  (current  ==  '\r'  ||  (current  ==  '\n'  &&  lastChar  !=  '\r'))  {  lineCounter++;  }  lastChar  =  current;  return  lastChar;    [CLASS]  ExtendedBufferedReader  [METHOD]  read  [RETURN_TYPE]  int    [VARIABLES]  int  END_OF_STREAM  UNDEFINED  current  lastChar  lineCounter  boolean    	[P14_Delete_Statement]
[PATCH]  if  (  current  ==  '\r'  ||  (  current  ==  '\n'  &&  lastChar  !=  '\r'  )  )  {	[BUG]  [BUGGY]  if  (  current  ==  '\r'  &&  (  current  ==  '\n'  &&  lastChar  !=  '\r')  )  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  int  read()  throws  IOException  {  int  current  =  super.read();  [BUGGY]  if  (  current  ==  '\r'  &&  (  current  ==  '\n'  &&  lastChar  !=  '\r')  )  {  [BUGGY]  lineCounter++;  }  lastChar  =  current;  return  lastChar;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  read  [RETURN_TYPE]  int    [VARIABLES]  int  END_OF_STREAM  UNDEFINED  current  lastChar  lineCounter  boolean    	[P2_Replace_Operator]
[PATCH]  if  (  current  ==  '\r'  ||  (  current  ==  '\n'  &&  lastChar  !=  '\r'  )  )  {	[BUG]  [BUGGY]  if  (  current  >=  '\r'  ||  (  current  ==  '\n'  &&  lastChar  !=  '\r')  )  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  int  read()  throws  IOException  {  int  current  =  super.read();  [BUGGY]  if  (  current  >=  '\r'  ||  (  current  ==  '\n'  &&  lastChar  !=  '\r')  )  {  [BUGGY]  lineCounter++;  }  lastChar  =  current;  return  lastChar;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  read  [RETURN_TYPE]  int    [VARIABLES]  int  END_OF_STREAM  UNDEFINED  current  lastChar  lineCounter  boolean    	[P2_Replace_Operator]
[PATCH]  if  (  current  ==  '\r'  ||  (  current  ==  '\n'  &&  lastChar  !=  '\r'  )  )  {	[BUG]  [BUGGY]  if  (  current  ==  '\r'  ||  (  current  ==  '\n'  ||  lastChar  !=  '\r')  )  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  int  read()  throws  IOException  {  int  current  =  super.read();  [BUGGY]  if  (  current  ==  '\r'  ||  (  current  ==  '\n'  ||  lastChar  !=  '\r')  )  {  [BUGGY]  lineCounter++;  }  lastChar  =  current;  return  lastChar;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  read  [RETURN_TYPE]  int    [VARIABLES]  int  END_OF_STREAM  UNDEFINED  current  lastChar  lineCounter  boolean    	[P2_Replace_Operator]
[PATCH]  if  (  current  ==  '\r'  ||  (  current  ==  '\n'  &&  lastChar  !=  '\r'  )  )  {	[BUG]  [BUGGY]  if  (  current  ==  '\r'  ||  (  current  <=  '\n'  &&  lastChar  !=  '\r')  )  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  int  read()  throws  IOException  {  int  current  =  super.read();  [BUGGY]  if  (  current  ==  '\r'  ||  (  current  <=  '\n'  &&  lastChar  !=  '\r')  )  {  [BUGGY]  lineCounter++;  }  lastChar  =  current;  return  lastChar;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  read  [RETURN_TYPE]  int    [VARIABLES]  int  END_OF_STREAM  UNDEFINED  current  lastChar  lineCounter  boolean    	[P2_Replace_Operator]
[PATCH]  if  (  current  ==  '\r'  ||  (  current  ==  '\n'  &&  lastChar  !=  '\r'  )  )  {	[BUG]  [BUGGY]  if  (  current  ==  '\r'  ||  (  current  ==  '\n'  &&  lastChar  ==  '\r')  )  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  int  read()  throws  IOException  {  int  current  =  super.read();  [BUGGY]  if  (  current  ==  '\r'  ||  (  current  ==  '\n'  &&  lastChar  ==  '\r')  )  {  [BUGGY]  lineCounter++;  }  lastChar  =  current;  return  lastChar;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  read  [RETURN_TYPE]  int    [VARIABLES]  int  END_OF_STREAM  UNDEFINED  current  lastChar  lineCounter  boolean    	[P2_Replace_Operator]
[PATCH]  if  (  current  ==  '\r'  ||  (  current  ==  '\n'  &&  lastChar  !=  '\r'  )  )  {	[BUG]  [BUGGY]  if  (  current  ==  '\r'  ||  (  current  ==  '\n'  &&  lineCounter  !=  '\r')  )  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  int  read()  throws  IOException  {  int  current  =  super.read();  [BUGGY]  if  (  current  ==  '\r'  ||  (  current  ==  '\n'  &&  lineCounter  !=  '\r')  )  {  [BUGGY]  lineCounter++;  }  lastChar  =  current;  return  lastChar;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  read  [RETURN_TYPE]  int    [VARIABLES]  int  END_OF_STREAM  UNDEFINED  current  lastChar  lineCounter  boolean    	[P5_Replace_Variable]
[PATCH]  if  (  current  ==  '\r'  ||  (  current  ==  '\n'  &&  lastChar  !=  '\r'  )  )  {	[BUG]  [BUGGY]  if  (  lastChar  ==  '\r'  ||  (  current  ==  '\n'  &&  current  !=  '\r')  )  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  int  read()  throws  IOException  {  int  current  =  super.read();  [BUGGY]  if  (  lastChar  ==  '\r'  ||  (  current  ==  '\n'  &&  current  !=  '\r')  )  {  [BUGGY]  lineCounter++;  }  lastChar  =  current;  return  lastChar;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  read  [RETURN_TYPE]  int    [VARIABLES]  int  END_OF_STREAM  UNDEFINED  current  lastChar  lineCounter  boolean    	[P5_Replace_Variable]
[PATCH]  if  (  current  ==  '\r'  ||  (  current  ==  '\n'  &&  lastChar  !=  '\r'  )  )  {	[BUG]  [BUGGY]  if  (  current  ==  '\r')  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  int  read()  throws  IOException  {  int  current  =  super.read();  [BUGGY]  if  (  current  ==  '\r')  {  [BUGGY]  lineCounter++;  }  lastChar  =  current;  return  lastChar;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  read  [RETURN_TYPE]  int    [VARIABLES]  int  END_OF_STREAM  UNDEFINED  current  lastChar  lineCounter  boolean    	[P6_Replace_Expression]
[PATCH]  if  (  current  ==  '\r'  ||  (  current  ==  '\n'  &&  lastChar  !=  '\r'  )  )  {	[BUG]  [BUGGY]  if  (  (  current  ==  '\n'  &&  lastChar  !=  '\r')  )  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  int  read()  throws  IOException  {  int  current  =  super.read();  [BUGGY]  if  (  (  current  ==  '\n'  &&  lastChar  !=  '\r')  )  {  [BUGGY]  lineCounter++;  }  lastChar  =  current;  return  lastChar;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  read  [RETURN_TYPE]  int    [VARIABLES]  int  END_OF_STREAM  UNDEFINED  current  lastChar  lineCounter  boolean    	[P6_Replace_Expression]
[PATCH]  if  (  current  ==  '\r'  ||  (  current  ==  '\n'  &&  lastChar  !=  '\r'  )  )  {	[BUG]  [BUGGY]  if  (  current  ==  '\n')  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  int  read()  throws  IOException  {  int  current  =  super.read();  [BUGGY]  if  (  current  ==  '\n')  {  [BUGGY]  lineCounter++;  }  lastChar  =  current;  return  lastChar;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  read  [RETURN_TYPE]  int    [VARIABLES]  int  END_OF_STREAM  UNDEFINED  current  lastChar  lineCounter  boolean    	[P6_Replace_Expression]
[PATCH]  if  (  current  ==  '\r'  ||  (  current  ==  '\n'  &&  lastChar  !=  '\r'  )  )  {	[BUG]  [BUGGY]  if  (  lastChar  !=  '\r')  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  int  read()  throws  IOException  {  int  current  =  super.read();  [BUGGY]  if  (  lastChar  !=  '\r')  {  [BUGGY]  lineCounter++;  }  lastChar  =  current;  return  lastChar;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  read  [RETURN_TYPE]  int    [VARIABLES]  int  END_OF_STREAM  UNDEFINED  current  lastChar  lineCounter  boolean    	[P6_Replace_Expression]
[PATCH]  if  (  current  ==  '\r'  ||  (  current  ==  '\n'  &&  lastChar  !=  '\r'  )  )  {	[BUG]  [BUGGY]  if  (  lineCounter  ==  '\r')  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  int  read()  throws  IOException  {  int  current  =  super.read();  [BUGGY]  if  (  lineCounter  ==  '\r')  {  [BUGGY]  lineCounter++;  }  lastChar  =  current;  return  lastChar;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  read  [RETURN_TYPE]  int    [VARIABLES]  int  END_OF_STREAM  UNDEFINED  current  lastChar  lineCounter  boolean    	[P8_Replace_Mix]
[PATCH]  if  (  current  ==  '\r'  ||  (  current  ==  '\n'  &&  lastChar  !=  '\r'  )  )  {  lineCounter++;  }	[BUG]  [BUGGY]  (lineCounter)++;[CE]  ';'  expected  [CONTEXT]  public  int  read()  throws  IOException  {  int  current  =  super.read();  [BUGGY]  (lineCounter)++;  [BUGGY]    (lineCounter)++;  lastChar  =  current;  return  lastChar;    [CLASS]  ExtendedBufferedReader  [METHOD]  read  [RETURN_TYPE]  int    [VARIABLES]  int  END_OF_STREAM  UNDEFINED  current  lastChar  lineCounter  boolean    	[P15_Unwrap_Block]
[PATCH]  if  (  current  ==  '\r'  ||  (  current  ==  '\n'  &&  lastChar  !=  '\r'  )  )  {  lineCounter++;  }	[BUG]  [BUGGY]  [CE]  ';'  expected  [CONTEXT]  public  int  read()  throws  IOException  {  int  current  =  super.read();  [BUGGY]  [BUGGY]      lastChar  =  current;  return  lastChar;    [CLASS]  ExtendedBufferedReader  [METHOD]  read  [RETURN_TYPE]  int    [VARIABLES]  int  END_OF_STREAM  UNDEFINED  current  lastChar  lineCounter  boolean    	[P16_Remove_Block]
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  '\r'  !=  (  i  >  0  ?  buf[(  i  -  1)  ]  :  lastChar)  )  {      (  lineCounter)  ++;  }[CE]  <identifier>  expected  [CONTEXT]  public  int  read()  throws  IOException  {  int  current  =  super.read();  [BUGGY]  if  (  '\r'  !=  (  i  >  0  ?  buf[(  i  -  1)  ]  :  lastChar)  )  {      (  lineCounter)  ++;  }  [BUGGY]  lineCounter++;  }  lastChar  =  current;  return  lastChar;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  read  [RETURN_TYPE]  int    [VARIABLES]  int  END_OF_STREAM  UNDEFINED  current  lastChar  lineCounter  boolean    	[P13_Insert_Block]
[PATCH]  lastChar  =  current;	[BUG]  [BUGGY]  lastChar  =  lastChar;[FE]  [CONTEXT]  public  int  read()  throws  IOException  {  int  current  =  super.read();  if  (current  ==  '\r'  ||  (current  ==  '\n'  &&  lastChar  !=  '\r'))  {  lineCounter++;  }  [BUGGY]  lastChar  =  lastChar;  [BUGGY]  return  lastChar;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  read  [RETURN_TYPE]  int    [VARIABLES]  int  END_OF_STREAM  UNDEFINED  current  lastChar  lineCounter  boolean    	[P5_Replace_Variable]
[PATCH]  lastChar  =  current;	[BUG]  [BUGGY]  lastChar  =  lineCounter;[FE]  [CONTEXT]  public  int  read()  throws  IOException  {  int  current  =  super.read();  if  (current  ==  '\r'  ||  (current  ==  '\n'  &&  lastChar  !=  '\r'))  {  lineCounter++;  }  [BUGGY]  lastChar  =  lineCounter;  [BUGGY]  return  lastChar;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  read  [RETURN_TYPE]  int    [VARIABLES]  int  END_OF_STREAM  UNDEFINED  current  lastChar  lineCounter  boolean    	[P8_Replace_Mix]
[PATCH]  lastChar  =  current;	[BUG]  [BUGGY]  lastChar  =  END_OF_STREAM;lastChar  =  current;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  int  read()  throws  IOException  {  int  current  =  super.read();  if  (current  ==  '\r'  ||  (current  ==  '\n'  &&  lastChar  !=  '\r'))  {  lineCounter++;  }  [BUGGY]  lastChar  =  END_OF_STREAM;lastChar  =  current;  [BUGGY]  return  lastChar;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  read  [RETURN_TYPE]  int    [VARIABLES]  int  END_OF_STREAM  UNDEFINED  current  lastChar  lineCounter  boolean    	[P11_Insert_Donor_Statement]
[PATCH]  return  lastChar;	[BUG]  [BUGGY]  return  current;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  int  read()  throws  IOException  {  int  current  =  super.read();  if  (current  ==  '\r'  ||  (current  ==  '\n'  &&  lastChar  !=  '\r'))  {  lineCounter++;  }  lastChar  =  current;  [BUGGY]  return  current;  [BUGGY]  }    [CLASS]  ExtendedBufferedReader  [METHOD]  read  [RETURN_TYPE]  int    [VARIABLES]  int  END_OF_STREAM  UNDEFINED  current  lastChar  lineCounter  boolean    	[P5_Replace_Variable]
[PATCH]  return  lastChar;	[BUG]  [BUGGY]  return  lineCounter;[FE]  [CONTEXT]  public  int  read()  throws  IOException  {  int  current  =  super.read();  if  (current  ==  '\r'  ||  (current  ==  '\n'  &&  lastChar  !=  '\r'))  {  lineCounter++;  }  lastChar  =  current;  [BUGGY]  return  lineCounter;  [BUGGY]  }    [CLASS]  ExtendedBufferedReader  [METHOD]  read  [RETURN_TYPE]  int    [VARIABLES]  int  END_OF_STREAM  UNDEFINED  current  lastChar  lineCounter  boolean    	[P8_Replace_Mix]
[PATCH]  return  lastChar;	[BUG]  [BUGGY]  return  lineCounter;[FE]  [CONTEXT]  int  readAgain()  {  [BUGGY]  return  lineCounter;  [BUGGY]  }    [CLASS]  ExtendedBufferedReader  [METHOD]  readAgain  [RETURN_TYPE]  int    [VARIABLES]  int  END_OF_STREAM  UNDEFINED  current  lastChar  lineCounter  boolean    	[P5_Replace_Variable]
[PATCH]  if  (  length  ==  0  )  {	[BUG]  [BUGGY]  if  (  length  <=  0)  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  [BUGGY]  if  (  length  <=  0)  {  [BUGGY]  return  0;  }  int  len  =  super.read(buf,  offset,  length);  if  (len  >  0)  {  for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }  lastChar  =  buf[offset  +  len  -  1];  }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }  return  len;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  read  [RETURN_TYPE]  int    char[]  buf  int  offset  int  length  [VARIABLES]  char  ch  boolean  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  char[]  buf    	[P2_Replace_Operator]
[PATCH]  if  (  length  ==  0  )  {	[BUG]  [BUGGY]  if  (  length  ==  -4)  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  [BUGGY]  if  (  length  ==  -4)  {  [BUGGY]  return  0;  }  int  len  =  super.read(buf,  offset,  length);  if  (len  >  0)  {  for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }  lastChar  =  buf[offset  +  len  -  1];  }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }  return  len;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  read  [RETURN_TYPE]  int    char[]  buf  int  offset  int  length  [VARIABLES]  char  ch  boolean  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  char[]  buf    	[P3_Replace_Literal]
[PATCH]  if  (  length  ==  0  )  {	[BUG]  [BUGGY]  if  (  length  ==  -8)  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  [BUGGY]  if  (  length  ==  -8)  {  [BUGGY]  return  0;  }  int  len  =  super.read(buf,  offset,  length);  if  (len  >  0)  {  for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }  lastChar  =  buf[offset  +  len  -  1];  }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }  return  len;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  read  [RETURN_TYPE]  int    char[]  buf  int  offset  int  length  [VARIABLES]  char  ch  boolean  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  char[]  buf    	[P3_Replace_Literal]
[PATCH]  if  (  length  ==  0  )  {	[BUG]  [BUGGY]  if  (  len  ==  0)  {[CE]  cannot  find  symbol  len  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  [BUGGY]  if  (  len  ==  0)  {  [BUGGY]  return  0;  }  int  len  =  super.read(buf,  offset,  length);  if  (len  >  0)  {  for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }  lastChar  =  buf[offset  +  len  -  1];  }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }  return  len;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  read  [RETURN_TYPE]  int    char[]  buf  int  offset  int  length  [VARIABLES]  char  ch  boolean  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  char[]  buf    	[P5_Replace_Variable]
[PATCH]  if  (  length  ==  0  )  {	[BUG]  [BUGGY]  if  (  length  ==  0  )  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  [BUGGY]  if  (  length  ==  0  )  {  [BUGGY]  return  0;  }  int  len  =  super.read(buf,  offset,  length);  if  (len  >  0)  {  for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }  lastChar  =  buf[offset  +  len  -  1];  }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }  return  len;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  read  [RETURN_TYPE]  int    char[]  buf  int  offset  int  length  [VARIABLES]  char  ch  boolean  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  char[]  buf    	[P8_Replace_Mix]
[PATCH]  if  (  length  ==  0  )  {	[BUG]  [BUGGY]  if  (  len  >  0)  {[CE]  cannot  find  symbol  len  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  [BUGGY]  if  (  len  >  0)  {  [BUGGY]  return  0;  }  int  len  =  super.read(buf,  offset,  length);  if  (len  >  0)  {  for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }  lastChar  =  buf[offset  +  len  -  1];  }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }  return  len;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  read  [RETURN_TYPE]  int    char[]  buf  int  offset  int  length  [VARIABLES]  char  ch  boolean  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  char[]  buf    	[P9_Replace_Statement]
[PATCH]  if  (  length  ==  0  )  {  return  0;  }	[BUG]  [BUGGY]  return  0;[CE]  ';'  expected  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  [BUGGY]  return  0;  [BUGGY]    return  0;    int  len  =  super.read(buf,  offset,  length);  if  (len  >  0)  {  for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }  lastChar  =  buf[offset  +  len  -  1];  }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }  return  len;    [CLASS]  ExtendedBufferedReader  [METHOD]  read  [RETURN_TYPE]  int    char[]  buf  int  offset  int  length  [VARIABLES]  char  ch  boolean  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  char[]  buf    	[P15_Unwrap_Block]
[PATCH]  if  (  length  ==  0  )  {  return  0;  }	[BUG]  [BUGGY]  [CE]  ';'  expected  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  [BUGGY]  [BUGGY]      int  len  =  super.read(buf,  offset,  length);  if  (len  >  0)  {  for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }  lastChar  =  buf[offset  +  len  -  1];  }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }  return  len;    [CLASS]  ExtendedBufferedReader  [METHOD]  read  [RETURN_TYPE]  int    char[]  buf  int  offset  int  length  [VARIABLES]  char  ch  boolean  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  char[]  buf    	[P16_Remove_Block]
[PATCH]  return  0;	[BUG]  [BUGGY]  return  -2;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  [BUGGY]  return  -2;  [BUGGY]  }  int  len  =  super.read(buf,  offset,  length);  if  (len  >  0)  {  for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }  lastChar  =  buf[offset  +  len  -  1];  }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }  return  len;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  read  [RETURN_TYPE]  int    char[]  buf  int  offset  int  length  [VARIABLES]  char  ch  boolean  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  char[]  buf    	[P3_Replace_Literal]
[PATCH]  return  0;	[BUG]  [BUGGY]  return  2;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  [BUGGY]  return  2;  [BUGGY]  }  int  len  =  super.read(buf,  offset,  length);  if  (len  >  0)  {  for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }  lastChar  =  buf[offset  +  len  -  1];  }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }  return  len;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  read  [RETURN_TYPE]  int    char[]  buf  int  offset  int  length  [VARIABLES]  char  ch  boolean  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  char[]  buf    	[P8_Replace_Mix]
[PATCH]  return  0;	[BUG]  [BUGGY]  return  8;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  [BUGGY]  return  8;  [BUGGY]  }  int  len  =  super.read(buf,  offset,  length);  if  (len  >  0)  {  for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }  lastChar  =  buf[offset  +  len  -  1];  }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }  return  len;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  read  [RETURN_TYPE]  int    char[]  buf  int  offset  int  length  [VARIABLES]  char  ch  boolean  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  char[]  buf    	[P3_Replace_Literal]
[PATCH]  return  0;	[BUG]  [BUGGY]  return  0L;[CE]  possible  loss  of  precision  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  [BUGGY]  return  0L;  [BUGGY]  }  int  len  =  super.read(buf,  offset,  length);  if  (len  >  0)  {  for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }  lastChar  =  buf[offset  +  len  -  1];  }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }  return  len;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  read  [RETURN_TYPE]  int    char[]  buf  int  offset  int  length  [VARIABLES]  char  ch  boolean  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  char[]  buf    	[P8_Replace_Mix]
[PATCH]  int  len  =  super.read  (  buf,  offset,  length  )  ;	[BUG]  [BUGGY]  short  len  =  super.read(  buf,  offset,  length)  ;[CE]  possible  loss  of  precision  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }  [BUGGY]  short  len  =  super.read(  buf,  offset,  length)  ;  [BUGGY]    if  (len  >  0)  {  for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }  lastChar  =  buf[offset  +  len  -  1];  }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }  return  len;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  read  [RETURN_TYPE]  int    char[]  buf  int  offset  int  length  [VARIABLES]  char  ch  boolean  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  char[]  buf    	[P1_Replace_Type]
[PATCH]  int  len  =  super.read  (  buf,  offset,  length  )  ;	[BUG]  [BUGGY]  int  len  =  super.read(  offset,  length)  ;[CE]  no  suitable  method  found  for  read(int,int)  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }  [BUGGY]  int  len  =  super.read(  offset,  length)  ;  [BUGGY]    if  (len  >  0)  {  for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }  lastChar  =  buf[offset  +  len  -  1];  }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }  return  len;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  read  [RETURN_TYPE]  int    char[]  buf  int  offset  int  length  [VARIABLES]  char  ch  boolean  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  char[]  buf    	[P5_Replace_Variable]
[PATCH]  int  len  =  super.read  (  buf,  offset,  length  )  ;	[BUG]  [BUGGY]  int  len  =  super.read(  buf,  length)  ;[CE]  no  suitable  method  found  for  read(char[],int)  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }  [BUGGY]  int  len  =  super.read(  buf,  length)  ;  [BUGGY]    if  (len  >  0)  {  for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }  lastChar  =  buf[offset  +  len  -  1];  }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }  return  len;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  read  [RETURN_TYPE]  int    char[]  buf  int  offset  int  length  [VARIABLES]  char  ch  boolean  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  char[]  buf    	[P5_Replace_Variable]
[PATCH]  int  len  =  super.read  (  buf,  offset,  length  )  ;	[BUG]  [BUGGY]  int  len  =  super.read(  buf,  offset)  ;[CE]  no  suitable  method  found  for  read(char[],int)  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }  [BUGGY]  int  len  =  super.read(  buf,  offset)  ;  [BUGGY]    if  (len  >  0)  {  for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }  lastChar  =  buf[offset  +  len  -  1];  }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }  return  len;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  read  [RETURN_TYPE]  int    char[]  buf  int  offset  int  length  [VARIABLES]  char  ch  boolean  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  char[]  buf    	[P5_Replace_Variable]
[PATCH]  int  len  =  super.read  (  buf,  offset,  length  )  ;	[BUG]  [BUGGY]  int  len  =  super.read(  )  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }  [BUGGY]  int  len  =  super.read(  )  ;  [BUGGY]    if  (len  >  0)  {  for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }  lastChar  =  buf[offset  +  len  -  1];  }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }  return  len;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  read  [RETURN_TYPE]  int    char[]  buf  int  offset  int  length  [VARIABLES]  char  ch  boolean  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  char[]  buf    	[P8_Replace_Mix]
[PATCH]  int  len  =  super.read  (  buf,  offset,  length  )  ;	[BUG]  [BUGGY]  int  c  =  super.read(  )  ;int  len  =  super.read(  buf,  offset,  length)  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }  [BUGGY]  int  c  =  super.read(  )  ;int  len  =  super.read(  buf,  offset,  length)  ;  [BUGGY]    if  (len  >  0)  {  for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }  lastChar  =  buf[offset  +  len  -  1];  }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }  return  len;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  read  [RETURN_TYPE]  int    char[]  buf  int  offset  int  length  [VARIABLES]  char  ch  boolean  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  char[]  buf    	[P11_Insert_Donor_Statement]
[PATCH]  int  len  =  super.read  (  buf,  offset,  length  )  ;	[BUG]  [BUGGY]  [FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }  [BUGGY]  [BUGGY]    if  (len  >  0)  {  for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }  lastChar  =  buf[offset  +  len  -  1];  }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }  return  len;    [CLASS]  ExtendedBufferedReader  [METHOD]  read  [RETURN_TYPE]  int    char[]  buf  int  offset  int  length  [VARIABLES]  char  ch  boolean  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  char[]  buf    	[P14_Delete_Statement]
[PATCH]  if  (  len  >  0  )  {	[BUG]  [BUGGY]  if  (  len  <  0)  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }  int  len  =  super.read(buf,  offset,  length);  [BUGGY]  if  (  len  <  0)  {  [BUGGY]    for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }  lastChar  =  buf[offset  +  len  -  1];  }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }  return  len;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  read  [RETURN_TYPE]  int    char[]  buf  int  offset  int  length  [VARIABLES]  char  ch  boolean  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  char[]  buf    	[P2_Replace_Operator]
[PATCH]  if  (  len  >  0  )  {	[BUG]  [BUGGY]  if  (  len  >=  0)  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }  int  len  =  super.read(buf,  offset,  length);  [BUGGY]  if  (  len  >=  0)  {  [BUGGY]    for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }  lastChar  =  buf[offset  +  len  -  1];  }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }  return  len;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  read  [RETURN_TYPE]  int    char[]  buf  int  offset  int  length  [VARIABLES]  char  ch  boolean  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  char[]  buf    	[P2_Replace_Operator]
[PATCH]  if  (  len  >  0  )  {	[BUG]  [BUGGY]  if  (  len  >  lastChar)  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }  int  len  =  super.read(buf,  offset,  length);  [BUGGY]  if  (  len  >  lastChar)  {  [BUGGY]    for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }  lastChar  =  buf[offset  +  len  -  1];  }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }  return  len;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  read  [RETURN_TYPE]  int    char[]  buf  int  offset  int  length  [VARIABLES]  char  ch  boolean  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  char[]  buf    	[P3_Replace_Literal]
[PATCH]  if  (  len  >  0  )  {	[BUG]  [BUGGY]  if  (  len  >  len)  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }  int  len  =  super.read(buf,  offset,  length);  [BUGGY]  if  (  len  >  len)  {  [BUGGY]    for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }  lastChar  =  buf[offset  +  len  -  1];  }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }  return  len;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  read  [RETURN_TYPE]  int    char[]  buf  int  offset  int  length  [VARIABLES]  char  ch  boolean  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  char[]  buf    	[P3_Replace_Literal]
[PATCH]  if  (  len  >  0  )  {	[BUG]  [BUGGY]  if  (  length  >  0)  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }  int  len  =  super.read(buf,  offset,  length);  [BUGGY]  if  (  length  >  0)  {  [BUGGY]    for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }  lastChar  =  buf[offset  +  len  -  1];  }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }  return  len;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  read  [RETURN_TYPE]  int    char[]  buf  int  offset  int  length  [VARIABLES]  char  ch  boolean  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  char[]  buf    	[P5_Replace_Variable]
[PATCH]  if  (  len  >  0  )  {	[BUG]  [BUGGY]  if  (  i  <  offset  +  len)  {[CE]  cannot  find  symbol  i  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }  int  len  =  super.read(buf,  offset,  length);  [BUGGY]  if  (  i  <  offset  +  len)  {  [BUGGY]    for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }  lastChar  =  buf[offset  +  len  -  1];  }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }  return  len;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  read  [RETURN_TYPE]  int    char[]  buf  int  offset  int  length  [VARIABLES]  char  ch  boolean  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  char[]  buf    	[P6_Replace_Expression]
[PATCH]  if  (  len  >  0  )  {	[BUG]  [BUGGY]  if  (  offset  +  len)  {[CE]  incompatible  types  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }  int  len  =  super.read(buf,  offset,  length);  [BUGGY]  if  (  offset  +  len)  {  [BUGGY]    for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }  lastChar  =  buf[offset  +  len  -  1];  }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }  return  len;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  read  [RETURN_TYPE]  int    char[]  buf  int  offset  int  length  [VARIABLES]  char  ch  boolean  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  char[]  buf    	[P6_Replace_Expression]
[PATCH]  if  (  len  >  0  )  {	[BUG]  [BUGGY]  if  (  ch  ==  '\n')  {[CE]  cannot  find  symbol  ch  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }  int  len  =  super.read(buf,  offset,  length);  [BUGGY]  if  (  ch  ==  '\n')  {  [BUGGY]    for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }  lastChar  =  buf[offset  +  len  -  1];  }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }  return  len;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  read  [RETURN_TYPE]  int    char[]  buf  int  offset  int  length  [VARIABLES]  char  ch  boolean  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  char[]  buf    	[P6_Replace_Expression]
[PATCH]  if  (  len  >  0  )  {	[BUG]  [BUGGY]  if  (  '\r'  !=  i  >  0  ?  buf[(i  -  1)]  :  lastChar)  {[CE]  cannot  find  symbol  i  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }  int  len  =  super.read(buf,  offset,  length);  [BUGGY]  if  (  '\r'  !=  i  >  0  ?  buf[(i  -  1)]  :  lastChar)  {  [BUGGY]    for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }  lastChar  =  buf[offset  +  len  -  1];  }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }  return  len;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  read  [RETURN_TYPE]  int    char[]  buf  int  offset  int  length  [VARIABLES]  char  ch  boolean  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  char[]  buf    	[P6_Replace_Expression]
[PATCH]  if  (  len  >  0  )  {	[BUG]  [BUGGY]  if  (  i  >  0)  {[CE]  cannot  find  symbol  i  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }  int  len  =  super.read(buf,  offset,  length);  [BUGGY]  if  (  i  >  0)  {  [BUGGY]    for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }  lastChar  =  buf[offset  +  len  -  1];  }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }  return  len;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  read  [RETURN_TYPE]  int    char[]  buf  int  offset  int  length  [VARIABLES]  char  ch  boolean  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  char[]  buf    	[P6_Replace_Expression]
[PATCH]  if  (  len  >  0  )  {	[BUG]  [BUGGY]  if  (  i  -  1)  {[CE]  cannot  find  symbol  i  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }  int  len  =  super.read(buf,  offset,  length);  [BUGGY]  if  (  i  -  1)  {  [BUGGY]    for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }  lastChar  =  buf[offset  +  len  -  1];  }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }  return  len;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  read  [RETURN_TYPE]  int    char[]  buf  int  offset  int  length  [VARIABLES]  char  ch  boolean  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  char[]  buf    	[P6_Replace_Expression]
[PATCH]  if  (  len  >  0  )  {	[BUG]  [BUGGY]  if  (  ch  ==  '\r')  {[CE]  cannot  find  symbol  ch  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }  int  len  =  super.read(buf,  offset,  length);  [BUGGY]  if  (  ch  ==  '\r')  {  [BUGGY]    for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }  lastChar  =  buf[offset  +  len  -  1];  }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }  return  len;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  read  [RETURN_TYPE]  int    char[]  buf  int  offset  int  length  [VARIABLES]  char  ch  boolean  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  char[]  buf    	[P6_Replace_Expression]
[PATCH]  if  (  len  >  0  )  {	[BUG]  [BUGGY]  if  (  offset  +  len  -  1)  {[CE]  incompatible  types  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }  int  len  =  super.read(buf,  offset,  length);  [BUGGY]  if  (  offset  +  len  -  1)  {  [BUGGY]    for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }  lastChar  =  buf[offset  +  len  -  1];  }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }  return  len;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  read  [RETURN_TYPE]  int    char[]  buf  int  offset  int  length  [VARIABLES]  char  ch  boolean  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  char[]  buf    	[P6_Replace_Expression]
[PATCH]  if  (  len  >  0  )  {	[BUG]  [BUGGY]  if  (  len  ==  -1)  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }  int  len  =  super.read(buf,  offset,  length);  [BUGGY]  if  (  len  ==  -1)  {  [BUGGY]    for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }  lastChar  =  buf[offset  +  len  -  1];  }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }  return  len;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  read  [RETURN_TYPE]  int    char[]  buf  int  offset  int  length  [VARIABLES]  char  ch  boolean  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  char[]  buf    	[P6_Replace_Expression]
[PATCH]  if  (  len  >  0  )  {	[BUG]  [BUGGY]  if  (  len  >  2)  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }  int  len  =  super.read(buf,  offset,  length);  [BUGGY]  if  (  len  >  2)  {  [BUGGY]    for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }  lastChar  =  buf[offset  +  len  -  1];  }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }  return  len;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  read  [RETURN_TYPE]  int    char[]  buf  int  offset  int  length  [VARIABLES]  char  ch  boolean  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  char[]  buf    	[P8_Replace_Mix]
[PATCH]  if  (  len  >  0  )  {	[BUG]  [BUGGY]  if  (  length  ==  0)  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }  int  len  =  super.read(buf,  offset,  length);  [BUGGY]  if  (  length  ==  0)  {  [BUGGY]    for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }  lastChar  =  buf[offset  +  len  -  1];  }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }  return  len;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  read  [RETURN_TYPE]  int    char[]  buf  int  offset  int  length  [VARIABLES]  char  ch  boolean  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  char[]  buf    	[P9_Replace_Statement]
[PATCH]  if  (  len  >  0  )  {	[BUG]  [BUGGY]  if  (  line  !=  null)  {[CE]  cannot  find  symbol  line  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }  int  len  =  super.read(buf,  offset,  length);  [BUGGY]  if  (  line  !=  null)  {  [BUGGY]    for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }  lastChar  =  buf[offset  +  len  -  1];  }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }  return  len;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  read  [RETURN_TYPE]  int    char[]  buf  int  offset  int  length  [VARIABLES]  char  ch  boolean  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  char[]  buf    	[P9_Replace_Statement]
[PATCH]  }  else  if  (  len  ==  -1  )  {	[BUG]  [BUGGY]  }  else  if  (  len  >  -1)  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }  int  len  =  super.read(buf,  offset,  length);  if  (len  >  0)  {  for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }  lastChar  =  buf[offset  +  len  -  1];  [BUGGY]  }  else  if  (  len  >  -1)  {  [BUGGY]  lastChar  =  END_OF_STREAM;  }  return  len;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  read  [RETURN_TYPE]  int    char[]  buf  int  offset  int  length  [VARIABLES]  char  ch  boolean  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  char[]  buf    	[P2_Replace_Operator]
[PATCH]  }  else  if  (  len  ==  -1  )  {	[BUG]  [BUGGY]  }  else  if  (  len  ==  -8)  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }  int  len  =  super.read(buf,  offset,  length);  if  (len  >  0)  {  for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }  lastChar  =  buf[offset  +  len  -  1];  [BUGGY]  }  else  if  (  len  ==  -8)  {  [BUGGY]  lastChar  =  END_OF_STREAM;  }  return  len;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  read  [RETURN_TYPE]  int    char[]  buf  int  offset  int  length  [VARIABLES]  char  ch  boolean  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  char[]  buf    	[P3_Replace_Literal]
[PATCH]  }  else  if  (  len  ==  -1  )  {	[BUG]  [BUGGY]  }  else  if  (  length  ==  -1)  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }  int  len  =  super.read(buf,  offset,  length);  if  (len  >  0)  {  for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }  lastChar  =  buf[offset  +  len  -  1];  [BUGGY]  }  else  if  (  length  ==  -1)  {  [BUGGY]  lastChar  =  END_OF_STREAM;  }  return  len;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  read  [RETURN_TYPE]  int    char[]  buf  int  offset  int  length  [VARIABLES]  char  ch  boolean  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  char[]  buf    	[P5_Replace_Variable]
[PATCH]  }  else  if  (  len  ==  -1  )  {	[BUG]  [BUGGY]  }  else  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }  int  len  =  super.read(buf,  offset,  length);  if  (len  >  0)  {  for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }  lastChar  =  buf[offset  +  len  -  1];  [BUGGY]  }  else  {  [BUGGY]  lastChar  =  END_OF_STREAM;  }  return  len;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  read  [RETURN_TYPE]  int    char[]  buf  int  offset  int  length  [VARIABLES]  char  ch  boolean  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  char[]  buf    	[P6_Replace_Expression]
[PATCH]  }  else  if  (  len  ==  -1  )  {	[BUG]  [BUGGY]  }  if  (  lineCounter  ==  -1L)  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }  int  len  =  super.read(buf,  offset,  length);  if  (len  >  0)  {  for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }  lastChar  =  buf[offset  +  len  -  1];  [BUGGY]  }  if  (  lineCounter  ==  -1L)  {  [BUGGY]  lastChar  =  END_OF_STREAM;  }  return  len;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  read  [RETURN_TYPE]  int    char[]  buf  int  offset  int  length  [VARIABLES]  char  ch  boolean  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  char[]  buf    	[P8_Replace_Mix]
[PATCH]  }  else  if  (  len  ==  -1  )  {	[BUG]  [BUGGY]  }  else  if  (  ch  ==  '\r')  {[CE]  cannot  find  symbol  ch  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }  int  len  =  super.read(buf,  offset,  length);  if  (len  >  0)  {  for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }  lastChar  =  buf[offset  +  len  -  1];  [BUGGY]  }  else  if  (  ch  ==  '\r')  {  [BUGGY]  lastChar  =  END_OF_STREAM;  }  return  len;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  read  [RETURN_TYPE]  int    char[]  buf  int  offset  int  length  [VARIABLES]  char  ch  boolean  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  char[]  buf    	[P9_Replace_Statement]
[PATCH]  }  else  if  (  len  ==  -1  )  {  lastChar  =  END_OF_STREAM;  }	[BUG]  [BUGGY]  lastChar  =  org.apache.commons.csv.ExtendedBufferedReader.END_OF_STREAM;[CE]  ';'  expected  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }  int  len  =  super.read(buf,  offset,  length);  if  (len  >  0)  {  for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }  lastChar  =  buf[offset  +  len  -  1];  [BUGGY]  lastChar  =  org.apache.commons.csv.ExtendedBufferedReader.END_OF_STREAM;  [BUGGY]    lastChar  =  org.apache.commons.csv.ExtendedBufferedReader.END_OF_STREAM;    return  len;    [CLASS]  ExtendedBufferedReader  [METHOD]  read  [RETURN_TYPE]  int    char[]  buf  int  offset  int  length  [VARIABLES]  char  ch  boolean  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  char[]  buf    	[P15_Unwrap_Block]
[PATCH]  }  else  if  (  len  ==  -1  )  {  lastChar  =  END_OF_STREAM;  }	[BUG]  [BUGGY]  [CE]  ';'  expected  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }  int  len  =  super.read(buf,  offset,  length);  if  (len  >  0)  {  for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }  lastChar  =  buf[offset  +  len  -  1];  [BUGGY]  [BUGGY]      return  len;    [CLASS]  ExtendedBufferedReader  [METHOD]  read  [RETURN_TYPE]  int    char[]  buf  int  offset  int  length  [VARIABLES]  char  ch  boolean  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  char[]  buf    	[P16_Remove_Block]
[PATCH]  lastChar  =  END_OF_STREAM;	[BUG]  [BUGGY]  lastChar  =  lineCounter;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }  int  len  =  super.read(buf,  offset,  length);  if  (len  >  0)  {  for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }  lastChar  =  buf[offset  +  len  -  1];  }  else  if  (len  ==  -1)  {  [BUGGY]  lastChar  =  lineCounter;  [BUGGY]  }  return  len;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  read  [RETURN_TYPE]  int    char[]  buf  int  offset  int  length  [VARIABLES]  char  ch  boolean  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  char[]  buf    	[P5_Replace_Variable]
[PATCH]  lastChar  =  END_OF_STREAM;	[BUG]  [BUGGY]  lastChar  =  lastChar  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }  int  len  =  super.read(buf,  offset,  length);  if  (len  >  0)  {  for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }  lastChar  =  buf[offset  +  len  -  1];  }  else  if  (len  ==  -1)  {  [BUGGY]  lastChar  =  lastChar  ;  [BUGGY]  }  return  len;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  read  [RETURN_TYPE]  int    char[]  buf  int  offset  int  length  [VARIABLES]  char  ch  boolean  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  char[]  buf    	[P8_Replace_Mix]
[PATCH]  lastChar  =  END_OF_STREAM;	[BUG]  [BUGGY]  lastChar  =  current;lastChar  =  END_OF_STREAM;[CE]  cannot  find  symbol  current  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }  int  len  =  super.read(buf,  offset,  length);  if  (len  >  0)  {  for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }  lastChar  =  buf[offset  +  len  -  1];  }  else  if  (len  ==  -1)  {  [BUGGY]  lastChar  =  current;lastChar  =  END_OF_STREAM;  [BUGGY]  }  return  len;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  read  [RETURN_TYPE]  int    char[]  buf  int  offset  int  length  [VARIABLES]  char  ch  boolean  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  char[]  buf    	[P11_Insert_Donor_Statement]
[PATCH]  lastChar  =  END_OF_STREAM;	[BUG]  [BUGGY]  lastChar  =  buf[offset  +  len  -  1];lastChar  =  END_OF_STREAM;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }  int  len  =  super.read(buf,  offset,  length);  if  (len  >  0)  {  for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }  lastChar  =  buf[offset  +  len  -  1];  }  else  if  (len  ==  -1)  {  [BUGGY]  lastChar  =  buf[offset  +  len  -  1];lastChar  =  END_OF_STREAM;  [BUGGY]  }  return  len;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  read  [RETURN_TYPE]  int    char[]  buf  int  offset  int  length  [VARIABLES]  char  ch  boolean  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  char[]  buf    	[P11_Insert_Donor_Statement]
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  len  ==  (  -1)  )  {      lastChar  =  END_OF_STREAM;  }[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }  int  len  =  super.read(buf,  offset,  length);  if  (len  >  0)  {  for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }  lastChar  =  buf[offset  +  len  -  1];  }  else  if  (len  ==  -1)  {  [BUGGY]  if  (  len  ==  (  -1)  )  {      lastChar  =  END_OF_STREAM;  }  [BUGGY]  }  return  len;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  read  [RETURN_TYPE]  int    char[]  buf  int  offset  int  length  [VARIABLES]  char  ch  boolean  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  char[]  buf    	[P13_Insert_Block]
[PATCH]  lastChar  =  END_OF_STREAM;	[BUG]  [BUGGY]  lastChar  =  offset;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }  int  len  =  super.read(buf,  offset,  length);  if  (len  >  0)  {  for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }  lastChar  =  buf[offset  +  len  -  1];  }  else  if  (len  ==  -1)  {  [BUGGY]  lastChar  =  offset;  [BUGGY]  }  return  len;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  read  [RETURN_TYPE]  int    char[]  buf  int  offset  int  length  [VARIABLES]  char  ch  boolean  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  char[]  buf    	[P5_Replace_Variable]
[PATCH]  if  (  ch  ==  '\n'  )  {	[BUG]  [BUGGY]  if  (  ch  <=  '\n')  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }  int  len  =  super.read(buf,  offset,  length);  if  (len  >  0)  {  for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  [BUGGY]  if  (  ch  <=  '\n')  {  [BUGGY]  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }  lastChar  =  buf[offset  +  len  -  1];  }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }  return  len;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  read  [RETURN_TYPE]  int    char[]  buf  int  offset  int  length  [VARIABLES]  char  ch  boolean  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  char[]  buf    	[P2_Replace_Operator]
[PATCH]  if  (  ch  ==  '\n'  )  {	[BUG]  [BUGGY]  if  (  ch  >=  '\n')  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }  int  len  =  super.read(buf,  offset,  length);  if  (len  >  0)  {  for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  [BUGGY]  if  (  ch  >=  '\n')  {  [BUGGY]  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }  lastChar  =  buf[offset  +  len  -  1];  }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }  return  len;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  read  [RETURN_TYPE]  int    char[]  buf  int  offset  int  length  [VARIABLES]  char  ch  boolean  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  char[]  buf    	[P2_Replace_Operator]
[PATCH]  if  (  ch  ==  '\n'  )  {	[BUG]  [BUGGY]  if  (  '\r'  !=  i  >  0  ?  buf[(i  -  1)]  :  lastChar)  {[CE]  incomparable  types:  char  and  boolean  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }  int  len  =  super.read(buf,  offset,  length);  if  (len  >  0)  {  for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  [BUGGY]  if  (  '\r'  !=  i  >  0  ?  buf[(i  -  1)]  :  lastChar)  {  [BUGGY]  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }  lastChar  =  buf[offset  +  len  -  1];  }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }  return  len;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  read  [RETURN_TYPE]  int    char[]  buf  int  offset  int  length  [VARIABLES]  char  ch  boolean  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  char[]  buf    	[P6_Replace_Expression]
[PATCH]  if  (  ch  ==  '\n'  )  {	[BUG]  [BUGGY]  if  (  i  >  0)  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }  int  len  =  super.read(buf,  offset,  length);  if  (len  >  0)  {  for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  [BUGGY]  if  (  i  >  0)  {  [BUGGY]  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }  lastChar  =  buf[offset  +  len  -  1];  }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }  return  len;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  read  [RETURN_TYPE]  int    char[]  buf  int  offset  int  length  [VARIABLES]  char  ch  boolean  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  char[]  buf    	[P6_Replace_Expression]
[PATCH]  if  (  ch  ==  '\n'  )  {	[BUG]  [BUGGY]  if  (  i  -  1)  {[CE]  incompatible  types  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }  int  len  =  super.read(buf,  offset,  length);  if  (len  >  0)  {  for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  [BUGGY]  if  (  i  -  1)  {  [BUGGY]  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }  lastChar  =  buf[offset  +  len  -  1];  }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }  return  len;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  read  [RETURN_TYPE]  int    char[]  buf  int  offset  int  length  [VARIABLES]  char  ch  boolean  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  char[]  buf    	[P6_Replace_Expression]
[PATCH]  if  (  ch  ==  '\n'  )  {	[BUG]  [BUGGY]  if  (  ch  ==  '\r')  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }  int  len  =  super.read(buf,  offset,  length);  if  (len  >  0)  {  for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  [BUGGY]  if  (  ch  ==  '\r')  {  [BUGGY]  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }  lastChar  =  buf[offset  +  len  -  1];  }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }  return  len;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  read  [RETURN_TYPE]  int    char[]  buf  int  offset  int  length  [VARIABLES]  char  ch  boolean  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  char[]  buf    	[P6_Replace_Expression]
[PATCH]  if  (  ch  ==  '\n'  )  {  if  (  '\r'  !=  (  i  >  0  ?  buf[i-1]:  lastChar  )  )  {  lineCounter++;  }	[BUG]  [BUGGY]  if('\r'  !=(i  >  0  ?  buf[(i  -  1)]  :  lastChar))  {    (lineCounter)++;};[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }  int  len  =  super.read(buf,  offset,  length);  if  (len  >  0)  {  for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  [BUGGY]  if('\r'  !=(i  >  0  ?  buf[(i  -  1)]  :  lastChar))  {    (lineCounter)++;};  [BUGGY]    if  ('\r'  !=  (i  >  0  ?  buf[(i  -  1)]  :  lastChar))  {(lineCounter)++;};    }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }  lastChar  =  buf[offset  +  len  -  1];  }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }  return  len;    [CLASS]  ExtendedBufferedReader  [METHOD]  read  [RETURN_TYPE]  int    char[]  buf  int  offset  int  length  [VARIABLES]  char  ch  boolean  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  char[]  buf    	[P15_Unwrap_Block]
[PATCH]  if  (  ch  ==  '\n'  )  {  if  (  '\r'  !=  (  i  >  0  ?  buf[i-1]:  lastChar  )  )  {  lineCounter++;  }	[BUG]  [BUGGY]  [FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }  int  len  =  super.read(buf,  offset,  length);  if  (len  >  0)  {  for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  [BUGGY]  [BUGGY]      }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }  lastChar  =  buf[offset  +  len  -  1];  }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }  return  len;    [CLASS]  ExtendedBufferedReader  [METHOD]  read  [RETURN_TYPE]  int    char[]  buf  int  offset  int  length  [VARIABLES]  char  ch  boolean  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  char[]  buf    	[P16_Remove_Block]
[PATCH]  }  else  if  (  ch  ==  '\r'  )  {	[BUG]  [BUGGY]  }  else  if  (  ch  !=  '\r')  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }  int  len  =  super.read(buf,  offset,  length);  if  (len  >  0)  {  for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  [BUGGY]  }  else  if  (  ch  !=  '\r')  {  [BUGGY]  lineCounter++;  }  }  lastChar  =  buf[offset  +  len  -  1];  }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }  return  len;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  read  [RETURN_TYPE]  int    char[]  buf  int  offset  int  length  [VARIABLES]  char  ch  boolean  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  char[]  buf    	[P2_Replace_Operator]
[PATCH]  }  else  if  (  ch  ==  '\r'  )  {	[BUG]  [BUGGY]  }  else  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }  int  len  =  super.read(buf,  offset,  length);  if  (len  >  0)  {  for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  [BUGGY]  }  else  {  [BUGGY]  lineCounter++;  }  }  lastChar  =  buf[offset  +  len  -  1];  }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }  return  len;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  read  [RETURN_TYPE]  int    char[]  buf  int  offset  int  length  [VARIABLES]  char  ch  boolean  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  char[]  buf    	[P6_Replace_Expression]
[PATCH]  }  else  if  (  ch  ==  '\r'  )  {	[BUG]  [BUGGY]  }  else  if  (  len  ==  -1)  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }  int  len  =  super.read(buf,  offset,  length);  if  (len  >  0)  {  for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  [BUGGY]  }  else  if  (  len  ==  -1)  {  [BUGGY]  lineCounter++;  }  }  lastChar  =  buf[offset  +  len  -  1];  }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }  return  len;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  read  [RETURN_TYPE]  int    char[]  buf  int  offset  int  length  [VARIABLES]  char  ch  boolean  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  char[]  buf    	[P9_Replace_Statement]
[PATCH]  }  else  if  (  ch  ==  '\r'  )  {  lineCounter++;  }	[BUG]  [BUGGY]  (lineCounter)++;[CE]  'else'  without  'if'  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }  int  len  =  super.read(buf,  offset,  length);  if  (len  >  0)  {  for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  [BUGGY]  (lineCounter)++;  [BUGGY]    (lineCounter)++;  }  lastChar  =  buf[offset  +  len  -  1];  }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }  return  len;    [CLASS]  ExtendedBufferedReader  [METHOD]  read  [RETURN_TYPE]  int    char[]  buf  int  offset  int  length  [VARIABLES]  char  ch  boolean  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  char[]  buf    	[P15_Unwrap_Block]
[PATCH]  }  else  if  (  ch  ==  '\r'  )  {  lineCounter++;  }	[BUG]  [BUGGY]  [CE]  'else'  without  'if'  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }  int  len  =  super.read(buf,  offset,  length);  if  (len  >  0)  {  for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  [BUGGY]  [BUGGY]      }  lastChar  =  buf[offset  +  len  -  1];  }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }  return  len;    [CLASS]  ExtendedBufferedReader  [METHOD]  read  [RETURN_TYPE]  int    char[]  buf  int  offset  int  length  [VARIABLES]  char  ch  boolean  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  char[]  buf    	[P16_Remove_Block]
[PATCH]  if  (  '\r'  !=  (  i  >  0  ?  buf[i-1]:  lastChar  )  )  {	[BUG]  [BUGGY]  if  (  '\r'  ==  (  i  >  0  ?  buf[i-1]:  lastChar)  )  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }  int  len  =  super.read(buf,  offset,  length);  if  (len  >  0)  {  for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  [BUGGY]  if  (  '\r'  ==  (  i  >  0  ?  buf[i-1]:  lastChar)  )  {  [BUGGY]  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }  lastChar  =  buf[offset  +  len  -  1];  }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }  return  len;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  read  [RETURN_TYPE]  int    char[]  buf  int  offset  int  length  [VARIABLES]  char  ch  boolean  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  char[]  buf    	[P2_Replace_Operator]
[PATCH]  if  (  '\r'  !=  (  i  >  0  ?  buf[i-1]:  lastChar  )  )  {	[BUG]  [BUGGY]  if  (  '\r'  !=  (  i  >=  0  ?  buf[i-1]:  lastChar)  )  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }  int  len  =  super.read(buf,  offset,  length);  if  (len  >  0)  {  for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  [BUGGY]  if  (  '\r'  !=  (  i  >=  0  ?  buf[i-1]:  lastChar)  )  {  [BUGGY]  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }  lastChar  =  buf[offset  +  len  -  1];  }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }  return  len;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  read  [RETURN_TYPE]  int    char[]  buf  int  offset  int  length  [VARIABLES]  char  ch  boolean  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  char[]  buf    	[P2_Replace_Operator]
[PATCH]  if  (  '\r'  !=  (  i  >  0  ?  buf[i-1]:  lastChar  )  )  {	[BUG]  [BUGGY]  if  (  '\r'  !=  (  i  >  i  ?  buf[i-1]:  lastChar)  )  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }  int  len  =  super.read(buf,  offset,  length);  if  (len  >  0)  {  for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  [BUGGY]  if  (  '\r'  !=  (  i  >  i  ?  buf[i-1]:  lastChar)  )  {  [BUGGY]  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }  lastChar  =  buf[offset  +  len  -  1];  }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }  return  len;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  read  [RETURN_TYPE]  int    char[]  buf  int  offset  int  length  [VARIABLES]  char  ch  boolean  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  char[]  buf    	[P3_Replace_Literal]
[PATCH]  if  (  '\r'  !=  (  i  >  0  ?  buf[i-1]:  lastChar  )  )  {	[BUG]  [BUGGY]  if  (  '\r'  !=  (  i  >  0  ?  buf[i--8]:  lastChar)  )  {[CE]  ']'  expected  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }  int  len  =  super.read(buf,  offset,  length);  if  (len  >  0)  {  for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  [BUGGY]  if  (  '\r'  !=  (  i  >  0  ?  buf[i--8]:  lastChar)  )  {  [BUGGY]  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }  lastChar  =  buf[offset  +  len  -  1];  }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }  return  len;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  read  [RETURN_TYPE]  int    char[]  buf  int  offset  int  length  [VARIABLES]  char  ch  boolean  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  char[]  buf    	[P3_Replace_Literal]
[PATCH]  if  (  '\r'  !=  (  i  >  0  ?  buf[i-1]:  lastChar  )  )  {	[BUG]  [BUGGY]  if  (  '\r'  !=  (  offset  >  0  ?  buf[i-1]:  lastChar)  )  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }  int  len  =  super.read(buf,  offset,  length);  if  (len  >  0)  {  for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  [BUGGY]  if  (  '\r'  !=  (  offset  >  0  ?  buf[i-1]:  lastChar)  )  {  [BUGGY]  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }  lastChar  =  buf[offset  +  len  -  1];  }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }  return  len;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  read  [RETURN_TYPE]  int    char[]  buf  int  offset  int  length  [VARIABLES]  char  ch  boolean  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  char[]  buf    	[P5_Replace_Variable]
[PATCH]  if  (  '\r'  !=  (  i  >  0  ?  buf[i-1]:  lastChar  )  )  {	[BUG]  [BUGGY]  if  (  '\r'  !=  (  i  >  0  ?  buf[i-1]:  offset)  )  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }  int  len  =  super.read(buf,  offset,  length);  if  (len  >  0)  {  for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  [BUGGY]  if  (  '\r'  !=  (  i  >  0  ?  buf[i-1]:  offset)  )  {  [BUGGY]  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }  lastChar  =  buf[offset  +  len  -  1];  }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }  return  len;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  read  [RETURN_TYPE]  int    char[]  buf  int  offset  int  length  [VARIABLES]  char  ch  boolean  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  char[]  buf    	[P5_Replace_Variable]
[PATCH]  if  (  '\r'  !=  (  i  >  0  ?  buf[i-1]:  lastChar  )  )  {	[BUG]  [BUGGY]  if  (  '\r'  !=  (  lastChar  >  0  ?  buf[i-1]:  i)  )  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }  int  len  =  super.read(buf,  offset,  length);  if  (len  >  0)  {  for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  [BUGGY]  if  (  '\r'  !=  (  lastChar  >  0  ?  buf[i-1]:  i)  )  {  [BUGGY]  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }  lastChar  =  buf[offset  +  len  -  1];  }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }  return  len;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  read  [RETURN_TYPE]  int    char[]  buf  int  offset  int  length  [VARIABLES]  char  ch  boolean  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  char[]  buf    	[P5_Replace_Variable]
[PATCH]  if  (  '\r'  !=  (  i  >  0  ?  buf[i-1]:  lastChar  )  )  {	[BUG]  [BUGGY]  if  (  '\r'  !=  (  i  >  0  ?  lastChar[i-1]:  buf)  )  {[CE]  array  required,  but  int  found  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }  int  len  =  super.read(buf,  offset,  length);  if  (len  >  0)  {  for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  [BUGGY]  if  (  '\r'  !=  (  i  >  0  ?  lastChar[i-1]:  buf)  )  {  [BUGGY]  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }  lastChar  =  buf[offset  +  len  -  1];  }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }  return  len;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  read  [RETURN_TYPE]  int    char[]  buf  int  offset  int  length  [VARIABLES]  char  ch  boolean  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  char[]  buf    	[P5_Replace_Variable]
[PATCH]  if  (  '\r'  !=  (  i  >  0  ?  buf[i-1]:  lastChar  )  )  {	[BUG]  [BUGGY]  if  (  i  >  0)  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }  int  len  =  super.read(buf,  offset,  length);  if  (len  >  0)  {  for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  [BUGGY]  if  (  i  >  0)  {  [BUGGY]  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }  lastChar  =  buf[offset  +  len  -  1];  }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }  return  len;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  read  [RETURN_TYPE]  int    char[]  buf  int  offset  int  length  [VARIABLES]  char  ch  boolean  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  char[]  buf    	[P6_Replace_Expression]
[PATCH]  if  (  '\r'  !=  (  i  >  0  ?  buf[i-1]:  lastChar  )  )  {	[BUG]  [BUGGY]  if  (  i  -  1)  {[CE]  incompatible  types  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }  int  len  =  super.read(buf,  offset,  length);  if  (len  >  0)  {  for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  [BUGGY]  if  (  i  -  1)  {  [BUGGY]  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }  lastChar  =  buf[offset  +  len  -  1];  }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }  return  len;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  read  [RETURN_TYPE]  int    char[]  buf  int  offset  int  length  [VARIABLES]  char  ch  boolean  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  char[]  buf    	[P6_Replace_Expression]
[PATCH]  if  (  '\r'  !=  (  i  >  0  ?  buf[i-1]:  lastChar  )  )  {	[BUG]  [BUGGY]  if  (  '\r'  !=  (  lineCounter  >  0  ?  buf[i-1]:  lastChar)  )  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }  int  len  =  super.read(buf,  offset,  length);  if  (len  >  0)  {  for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  [BUGGY]  if  (  '\r'  !=  (  lineCounter  >  0  ?  buf[i-1]:  lastChar)  )  {  [BUGGY]  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }  lastChar  =  buf[offset  +  len  -  1];  }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }  return  len;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  read  [RETURN_TYPE]  int    char[]  buf  int  offset  int  length  [VARIABLES]  char  ch  boolean  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  char[]  buf    	[P8_Replace_Mix]
[PATCH]  if  (  '\r'  !=  (  i  >  0  ?  buf[i-1]:  lastChar  )  )  {  lineCounter++;  }	[BUG]  [BUGGY]  (lineCounter)++;[CE]  'else'  without  'if'  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }  int  len  =  super.read(buf,  offset,  length);  if  (len  >  0)  {  for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  [BUGGY]  (lineCounter)++;  [BUGGY]    (lineCounter)++;  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }  lastChar  =  buf[offset  +  len  -  1];  }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }  return  len;    [CLASS]  ExtendedBufferedReader  [METHOD]  read  [RETURN_TYPE]  int    char[]  buf  int  offset  int  length  [VARIABLES]  char  ch  boolean  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  char[]  buf    	[P15_Unwrap_Block]
[PATCH]  if  (  '\r'  !=  (  i  >  0  ?  buf[i-1]:  lastChar  )  )  {  lineCounter++;  }	[BUG]  [BUGGY]  [CE]  'else'  without  'if'  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }  int  len  =  super.read(buf,  offset,  length);  if  (len  >  0)  {  for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  [BUGGY]  [BUGGY]      }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }  lastChar  =  buf[offset  +  len  -  1];  }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }  return  len;    [CLASS]  ExtendedBufferedReader  [METHOD]  read  [RETURN_TYPE]  int    char[]  buf  int  offset  int  length  [VARIABLES]  char  ch  boolean  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  char[]  buf    	[P16_Remove_Block]
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  (  current  ==  '\r')  ||  (  (  current  ==  '\n')  &&  (  (  lastChar)  !=  '\r')  )  )  {      (  lineCounter)  ++;  }[CE]  'else'  without  'if'  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }  int  len  =  super.read(buf,  offset,  length);  if  (len  >  0)  {  for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  [BUGGY]  if  (  (  current  ==  '\r')  ||  (  (  current  ==  '\n')  &&  (  (  lastChar)  !=  '\r')  )  )  {      (  lineCounter)  ++;  }  [BUGGY]  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }  lastChar  =  buf[offset  +  len  -  1];  }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }  return  len;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  read  [RETURN_TYPE]  int    char[]  buf  int  offset  int  length  [VARIABLES]  char  ch  boolean  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  char[]  buf    	[P13_Insert_Block]
[PATCH]  if  (  '\r'  !=  (  i  >  0  ?  buf[i-1]:  lastChar  )  )  {	[BUG]  [BUGGY]  if  (  '\r'  >=  (  i  >  0  ?  buf[i-1]:  lastChar)  )  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }  int  len  =  super.read(buf,  offset,  length);  if  (len  >  0)  {  for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  [BUGGY]  if  (  '\r'  >=  (  i  >  0  ?  buf[i-1]:  lastChar)  )  {  [BUGGY]  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }  lastChar  =  buf[offset  +  len  -  1];  }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }  return  len;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  read  [RETURN_TYPE]  int    char[]  buf  int  offset  int  length  [VARIABLES]  char  ch  boolean  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  char[]  buf    	[P2_Replace_Operator]
[PATCH]  if  (  '\r'  !=  (  i  >  0  ?  buf[i-1]:  lastChar  )  )  {	[BUG]  [BUGGY]  if  (  '\r'  !=  (  i  ==  0  ?  buf[i-1]:  lastChar)  )  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }  int  len  =  super.read(buf,  offset,  length);  if  (len  >  0)  {  for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  [BUGGY]  if  (  '\r'  !=  (  i  ==  0  ?  buf[i-1]:  lastChar)  )  {  [BUGGY]  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }  lastChar  =  buf[offset  +  len  -  1];  }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }  return  len;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  read  [RETURN_TYPE]  int    char[]  buf  int  offset  int  length  [VARIABLES]  char  ch  boolean  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  char[]  buf    	[P2_Replace_Operator]
[PATCH]  if  (  '\r'  !=  (  i  >  0  ?  buf[i-1]:  lastChar  )  )  {	[BUG]  [BUGGY]  if  (  '\r'  !=  (  i  >  current  ?  buf[i-1]:  lastChar)  )  {[CE]  cannot  find  symbol  current  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }  int  len  =  super.read(buf,  offset,  length);  if  (len  >  0)  {  for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  [BUGGY]  if  (  '\r'  !=  (  i  >  current  ?  buf[i-1]:  lastChar)  )  {  [BUGGY]  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }  lastChar  =  buf[offset  +  len  -  1];  }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }  return  len;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  read  [RETURN_TYPE]  int    char[]  buf  int  offset  int  length  [VARIABLES]  char  ch  boolean  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  char[]  buf    	[P3_Replace_Literal]
[PATCH]  if  (  '\r'  !=  (  i  >  0  ?  buf[i-1]:  lastChar  )  )  {	[BUG]  [BUGGY]  if  (  '\r'  !=  (  i  >  0  ?  buf[i-offset]:  lastChar)  )  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }  int  len  =  super.read(buf,  offset,  length);  if  (len  >  0)  {  for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  [BUGGY]  if  (  '\r'  !=  (  i  >  0  ?  buf[i-offset]:  lastChar)  )  {  [BUGGY]  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }  lastChar  =  buf[offset  +  len  -  1];  }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }  return  len;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  read  [RETURN_TYPE]  int    char[]  buf  int  offset  int  length  [VARIABLES]  char  ch  boolean  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  char[]  buf    	[P3_Replace_Literal]
[PATCH]  if  (  '\r'  !=  (  i  >  0  ?  buf[i-1]:  lastChar  )  )  {	[BUG]  [BUGGY]  if  (  '\r'  !=  (  i  >  0  ?  buf[i-1]:  length)  )  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }  int  len  =  super.read(buf,  offset,  length);  if  (len  >  0)  {  for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  [BUGGY]  if  (  '\r'  !=  (  i  >  0  ?  buf[i-1]:  length)  )  {  [BUGGY]  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }  lastChar  =  buf[offset  +  len  -  1];  }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }  return  len;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  read  [RETURN_TYPE]  int    char[]  buf  int  offset  int  length  [VARIABLES]  char  ch  boolean  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  char[]  buf    	[P5_Replace_Variable]
[PATCH]  for  (  int  i  =  offset;  i  <  offset  +  len;  i++  )  {	[BUG]  [BUGGY]  for  (  long  i  =  offset;  i  <  offset  +  len;  i++)  {[CE]  possible  loss  of  precision  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }  int  len  =  super.read(buf,  offset,  length);  if  (len  >  0)  {  [BUGGY]  for  (  long  i  =  offset;  i  <  offset  +  len;  i++)  {  [BUGGY]  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }  lastChar  =  buf[offset  +  len  -  1];  }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }  return  len;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  read  [RETURN_TYPE]  int    char[]  buf  int  offset  int  length  [VARIABLES]  char  ch  boolean  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  char[]  buf    	[P1_Replace_Type]
[PATCH]  for  (  int  i  =  offset;  i  <  offset  +  len;  i++  )  {	[BUG]  [BUGGY]  for  (  int  i  =  offset;  i  <=  offset  +  len;  i++)  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }  int  len  =  super.read(buf,  offset,  length);  if  (len  >  0)  {  [BUGGY]  for  (  int  i  =  offset;  i  <=  offset  +  len;  i++)  {  [BUGGY]  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }  lastChar  =  buf[offset  +  len  -  1];  }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }  return  len;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  read  [RETURN_TYPE]  int    char[]  buf  int  offset  int  length  [VARIABLES]  char  ch  boolean  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  char[]  buf    	[P2_Replace_Operator]
[PATCH]  for  (  int  i  =  offset;  i  <  offset  +  len;  i++  )  {	[BUG]  [BUGGY]  for  (  int  i  =  len;  i  <  offset  +  len;  i++)  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }  int  len  =  super.read(buf,  offset,  length);  if  (len  >  0)  {  [BUGGY]  for  (  int  i  =  len;  i  <  offset  +  len;  i++)  {  [BUGGY]  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }  lastChar  =  buf[offset  +  len  -  1];  }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }  return  len;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  read  [RETURN_TYPE]  int    char[]  buf  int  offset  int  length  [VARIABLES]  char  ch  boolean  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  char[]  buf    	[P5_Replace_Variable]
[PATCH]  for  (  int  i  =  offset;  i  <  offset  +  len;  i++  )  {	[BUG]  [BUGGY]  for  (  lennt  i  =  offset;  i  <  offset  +  len;  i++)  {[CE]  cannot  find  symbol  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }  int  len  =  super.read(buf,  offset,  length);  if  (len  >  0)  {  [BUGGY]  for  (  lennt  i  =  offset;  i  <  offset  +  len;  i++)  {  [BUGGY]  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }  lastChar  =  buf[offset  +  len  -  1];  }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }  return  len;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  read  [RETURN_TYPE]  int    char[]  buf  int  offset  int  length  [VARIABLES]  char  ch  boolean  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  char[]  buf    	[P5_Replace_Variable]
[PATCH]  for  (  int  i  =  offset;  i  <  offset  +  len;  i++  )  {	[BUG]  [BUGGY]  for  (  int  i  =  offset;  i  <  offset  +  offset;  i++)  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }  int  len  =  super.read(buf,  offset,  length);  if  (len  >  0)  {  [BUGGY]  for  (  int  i  =  offset;  i  <  offset  +  offset;  i++)  {  [BUGGY]  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }  lastChar  =  buf[offset  +  len  -  1];  }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }  return  len;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  read  [RETURN_TYPE]  int    char[]  buf  int  offset  int  length  [VARIABLES]  char  ch  boolean  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  char[]  buf    	[P5_Replace_Variable]
[PATCH]  for  (  int  i  =  offset;  i  <  offset  +  len;  i++  )  {	[BUG]  [BUGGY]  for  (  lengthnt  i  =  offset;  i  <  offset  +  len;  i++)  {[CE]  cannot  find  symbol  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }  int  len  =  super.read(buf,  offset,  length);  if  (len  >  0)  {  [BUGGY]  for  (  lengthnt  i  =  offset;  i  <  offset  +  len;  i++)  {  [BUGGY]  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }  lastChar  =  buf[offset  +  len  -  1];  }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }  return  len;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  read  [RETURN_TYPE]  int    char[]  buf  int  offset  int  length  [VARIABLES]  char  ch  boolean  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  char[]  buf    	[P8_Replace_Mix]
[PATCH]  if  (  ch  ==  '\n'  )  {	[BUG]  [BUGGY]  if  (  ch  >  '\n')  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }  int  len  =  super.read(buf,  offset,  length);  if  (len  >  0)  {  for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  [BUGGY]  if  (  ch  >  '\n')  {  [BUGGY]  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }  lastChar  =  buf[offset  +  len  -  1];  }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }  return  len;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  read  [RETURN_TYPE]  int    char[]  buf  int  offset  int  length  [VARIABLES]  char  ch  boolean  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  char[]  buf    	[P2_Replace_Operator]
[PATCH]  }  else  if  (  ch  ==  '\r'  )  {	[BUG]  [BUGGY]  }  else  if  (  ch  >=  '\r')  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }  int  len  =  super.read(buf,  offset,  length);  if  (len  >  0)  {  for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  [BUGGY]  }  else  if  (  ch  >=  '\r')  {  [BUGGY]  lineCounter++;  }  }  lastChar  =  buf[offset  +  len  -  1];  }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }  return  len;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  read  [RETURN_TYPE]  int    char[]  buf  int  offset  int  length  [VARIABLES]  char  ch  boolean  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  char[]  buf    	[P2_Replace_Operator]
[PATCH]  if  (  '\r'  !=  (  i  >  0  ?  buf[i-1]:  lastChar  )  )  {	[BUG]  [BUGGY]  if  (  '\r'  !=  (  i  >  2  ?  buf[i-1]:  lastChar)  )  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }  int  len  =  super.read(buf,  offset,  length);  if  (len  >  0)  {  for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  [BUGGY]  if  (  '\r'  !=  (  i  >  2  ?  buf[i-1]:  lastChar)  )  {  [BUGGY]  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }  lastChar  =  buf[offset  +  len  -  1];  }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }  return  len;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  read  [RETURN_TYPE]  int    char[]  buf  int  offset  int  length  [VARIABLES]  char  ch  boolean  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  char[]  buf    	[P3_Replace_Literal]
[PATCH]  if  (  '\r'  !=  (  i  >  0  ?  buf[i-1]:  lastChar  )  )  {	[BUG]  [BUGGY]  if  (  '\r'  !=  (  buf  >  0  ?  i[i-1]:  lastChar)  )  {[CE]  bad  operand  types  for  binary  operator  '>'  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }  int  len  =  super.read(buf,  offset,  length);  if  (len  >  0)  {  for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  [BUGGY]  if  (  '\r'  !=  (  buf  >  0  ?  i[i-1]:  lastChar)  )  {  [BUGGY]  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }  lastChar  =  buf[offset  +  len  -  1];  }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }  return  len;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  read  [RETURN_TYPE]  int    char[]  buf  int  offset  int  length  [VARIABLES]  char  ch  boolean  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  char[]  buf    	[P5_Replace_Variable]
[PATCH]  if  (  '\r'  !=  (  i  >  0  ?  buf[i-1]:  lastChar  )  )  {	[BUG]  [BUGGY]  if  (  '\r'  !=  (  i  >  lineCounter  ?  buf[i-1]:  lastChar)  )  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }  int  len  =  super.read(buf,  offset,  length);  if  (len  >  0)  {  for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  [BUGGY]  if  (  '\r'  !=  (  i  >  lineCounter  ?  buf[i-1]:  lastChar)  )  {  [BUGGY]  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }  lastChar  =  buf[offset  +  len  -  1];  }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }  return  len;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  read  [RETURN_TYPE]  int    char[]  buf  int  offset  int  length  [VARIABLES]  char  ch  boolean  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  char[]  buf    	[P3_Replace_Literal]
[PATCH]  if  (  '\r'  !=  (  i  >  0  ?  buf[i-1]:  lastChar  )  )  {	[BUG]  [BUGGY]  if  (  '\r'  !=  (  i  >  0  ?  buf[i--1]:  lastChar)  )  {[CE]  ']'  expected  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }  int  len  =  super.read(buf,  offset,  length);  if  (len  >  0)  {  for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  [BUGGY]  if  (  '\r'  !=  (  i  >  0  ?  buf[i--1]:  lastChar)  )  {  [BUGGY]  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }  lastChar  =  buf[offset  +  len  -  1];  }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }  return  len;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  read  [RETURN_TYPE]  int    char[]  buf  int  offset  int  length  [VARIABLES]  char  ch  boolean  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  char[]  buf    	[P3_Replace_Literal]
[PATCH]  }  else  if  (  ch  ==  '\r'  )  {	[BUG]  [BUGGY]  }  else  if  (  ch  <=  '\r')  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }  int  len  =  super.read(buf,  offset,  length);  if  (len  >  0)  {  for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  [BUGGY]  }  else  if  (  ch  <=  '\r')  {  [BUGGY]  lineCounter++;  }  }  lastChar  =  buf[offset  +  len  -  1];  }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }  return  len;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  read  [RETURN_TYPE]  int    char[]  buf  int  offset  int  length  [VARIABLES]  char  ch  boolean  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  char[]  buf    	[P2_Replace_Operator]
[PATCH]  char  ch  =  buf[i];	[BUG]  [BUGGY]  int  ch  =  buf[i];[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }  int  len  =  super.read(buf,  offset,  length);  if  (len  >  0)  {  for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  [BUGGY]  int  ch  =  buf[i];  [BUGGY]  if  (ch  ==  '\n')  {  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }  lastChar  =  buf[offset  +  len  -  1];  }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }  return  len;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  read  [RETURN_TYPE]  int    char[]  buf  int  offset  int  length  [VARIABLES]  char  ch  boolean  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  char[]  buf    	[P1_Replace_Type]
[PATCH]  lastChar  =  buf[offset  +  len  -  1];	[BUG]  [BUGGY]  lastChar  =  buf[offset  +  len  !=  1];[CE]  incompatible  types  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }  int  len  =  super.read(buf,  offset,  length);  if  (len  >  0)  {  for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }  [BUGGY]  lastChar  =  buf[offset  +  len  !=  1];  [BUGGY]    }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }  return  len;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  read  [RETURN_TYPE]  int    char[]  buf  int  offset  int  length  [VARIABLES]  char  ch  boolean  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  char[]  buf    	[P2_Replace_Operator]
[PATCH]  lastChar  =  buf[offset  +  len  -  1];	[BUG]  [BUGGY]  lastChar  =  buf[offset  <  len  -  1];[CE]  incompatible  types  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }  int  len  =  super.read(buf,  offset,  length);  if  (len  >  0)  {  for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }  [BUGGY]  lastChar  =  buf[offset  <  len  -  1];  [BUGGY]    }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }  return  len;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  read  [RETURN_TYPE]  int    char[]  buf  int  offset  int  length  [VARIABLES]  char  ch  boolean  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  char[]  buf    	[P2_Replace_Operator]
[PATCH]  lastChar  =  buf[offset  +  len  -  1];	[BUG]  [BUGGY]  lastChar  =  buf[offset  +  len  -  ];[CE]  illegal  start  of  expression  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }  int  len  =  super.read(buf,  offset,  length);  if  (len  >  0)  {  for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }  [BUGGY]  lastChar  =  buf[offset  +  len  -  ];  [BUGGY]    }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }  return  len;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  read  [RETURN_TYPE]  int    char[]  buf  int  offset  int  length  [VARIABLES]  char  ch  boolean  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  char[]  buf    	[P3_Replace_Literal]
[PATCH]  lastChar  =  buf[offset  +  len  -  1];	[BUG]  [BUGGY]  lastChar  =  buf[lineCounter  +  len  -  1];[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }  int  len  =  super.read(buf,  offset,  length);  if  (len  >  0)  {  for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }  [BUGGY]  lastChar  =  buf[lineCounter  +  len  -  1];  [BUGGY]    }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }  return  len;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  read  [RETURN_TYPE]  int    char[]  buf  int  offset  int  length  [VARIABLES]  char  ch  boolean  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  char[]  buf    	[P5_Replace_Variable]
[PATCH]  lastChar  =  buf[offset  +  len  -  1];	[BUG]  [BUGGY]  lastChar  =  buf[offset  +  lineCounter  -  1];[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }  int  len  =  super.read(buf,  offset,  length);  if  (len  >  0)  {  for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }  [BUGGY]  lastChar  =  buf[offset  +  lineCounter  -  1];  [BUGGY]    }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }  return  len;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  read  [RETURN_TYPE]  int    char[]  buf  int  offset  int  length  [VARIABLES]  char  ch  boolean  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  char[]  buf    	[P5_Replace_Variable]
[PATCH]  lastChar  =  buf[offset  +  len  -  1];	[BUG]  [BUGGY]  lastChar  =  len[offset  +  buf  -  1];[CE]  bad  operand  types  for  binary  operator  '+'  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }  int  len  =  super.read(buf,  offset,  length);  if  (len  >  0)  {  for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }  [BUGGY]  lastChar  =  len[offset  +  buf  -  1];  [BUGGY]    }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }  return  len;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  read  [RETURN_TYPE]  int    char[]  buf  int  offset  int  length  [VARIABLES]  char  ch  boolean  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  char[]  buf    	[P5_Replace_Variable]
[PATCH]  lastChar  =  buf[offset  +  len  -  1];	[BUG]  [BUGGY]  lastChar  =  buf[offset  +  len  -  0];[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }  int  len  =  super.read(buf,  offset,  length);  if  (len  >  0)  {  for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }  [BUGGY]  lastChar  =  buf[offset  +  len  -  0];  [BUGGY]    }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }  return  len;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  read  [RETURN_TYPE]  int    char[]  buf  int  offset  int  length  [VARIABLES]  char  ch  boolean  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  char[]  buf    	[P8_Replace_Mix]
[PATCH]  lastChar  =  buf[offset  +  len  -  1];	[BUG]  [BUGGY]  lastChar  =  END_OF_STREAM;lastChar  =  buf[offset  +  len  -  1];[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }  int  len  =  super.read(buf,  offset,  length);  if  (len  >  0)  {  for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }  [BUGGY]  lastChar  =  END_OF_STREAM;lastChar  =  buf[offset  +  len  -  1];  [BUGGY]    }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }  return  len;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  read  [RETURN_TYPE]  int    char[]  buf  int  offset  int  length  [VARIABLES]  char  ch  boolean  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  char[]  buf    	[P11_Insert_Donor_Statement]
[PATCH]  for  (  int  i  =  offset;  i  <  offset  +  len;  i++  )  {	[BUG]  [BUGGY]  for  (  int  i  =  lineCounter;  i  <  offset  +  len;  i++)  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }  int  len  =  super.read(buf,  offset,  length);  if  (len  >  0)  {  [BUGGY]  for  (  int  i  =  lineCounter;  i  <  offset  +  len;  i++)  {  [BUGGY]  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }  lastChar  =  buf[offset  +  len  -  1];  }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }  return  len;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  read  [RETURN_TYPE]  int    char[]  buf  int  offset  int  length  [VARIABLES]  char  ch  boolean  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  char[]  buf    	[P5_Replace_Variable]
[PATCH]  if  (  ch  ==  '\n'  )  {	[BUG]  [BUGGY]  if  (  ch  !=  '\n')  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }  int  len  =  super.read(buf,  offset,  length);  if  (len  >  0)  {  for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  [BUGGY]  if  (  ch  !=  '\n')  {  [BUGGY]  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }  lastChar  =  buf[offset  +  len  -  1];  }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }  return  len;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  read  [RETURN_TYPE]  int    char[]  buf  int  offset  int  length  [VARIABLES]  char  ch  boolean  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  char[]  buf    	[P2_Replace_Operator]
[PATCH]  if  (  '\r'  !=  (  i  >  0  ?  buf[i-1]:  lastChar  )  )  {	[BUG]  [BUGGY]  if  (  '\r'  !=  (  i  <  0  ?  buf[i-1]:  lastChar)  )  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }  int  len  =  super.read(buf,  offset,  length);  if  (len  >  0)  {  for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  [BUGGY]  if  (  '\r'  !=  (  i  <  0  ?  buf[i-1]:  lastChar)  )  {  [BUGGY]  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }  lastChar  =  buf[offset  +  len  -  1];  }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }  return  len;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  read  [RETURN_TYPE]  int    char[]  buf  int  offset  int  length  [VARIABLES]  char  ch  boolean  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  char[]  buf    	[P2_Replace_Operator]
[PATCH]  if  (  '\r'  !=  (  i  >  0  ?  buf[i-1]:  lastChar  )  )  {	[BUG]  [BUGGY]  if  (  '\r'  !=  (  i  >  -3  ?  buf[i-1]:  lastChar)  )  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }  int  len  =  super.read(buf,  offset,  length);  if  (len  >  0)  {  for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  [BUGGY]  if  (  '\r'  !=  (  i  >  -3  ?  buf[i-1]:  lastChar)  )  {  [BUGGY]  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }  lastChar  =  buf[offset  +  len  -  1];  }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }  return  len;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  read  [RETURN_TYPE]  int    char[]  buf  int  offset  int  length  [VARIABLES]  char  ch  boolean  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  char[]  buf    	[P3_Replace_Literal]
[PATCH]  if  (  '\r'  !=  (  i  >  0  ?  buf[i-1]:  lastChar  )  )  {	[BUG]  [BUGGY]  if  (  '\r'  !=  (  i  >  0  ?  buf[i-]:  lastChar)  )  {[CE]  illegal  start  of  expression  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }  int  len  =  super.read(buf,  offset,  length);  if  (len  >  0)  {  for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  [BUGGY]  if  (  '\r'  !=  (  i  >  0  ?  buf[i-]:  lastChar)  )  {  [BUGGY]  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }  lastChar  =  buf[offset  +  len  -  1];  }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }  return  len;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  read  [RETURN_TYPE]  int    char[]  buf  int  offset  int  length  [VARIABLES]  char  ch  boolean  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  char[]  buf    	[P3_Replace_Literal]
[PATCH]  if  (  '\r'  !=  (  i  >  0  ?  buf[i-1]:  lastChar  )  )  {	[BUG]  [BUGGY]  if  (  '\r'  !=  (  i  >  -7  ?  buf[i-1]:  lastChar)  )  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }  int  len  =  super.read(buf,  offset,  length);  if  (len  >  0)  {  for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  [BUGGY]  if  (  '\r'  !=  (  i  >  -7  ?  buf[i-1]:  lastChar)  )  {  [BUGGY]  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }  lastChar  =  buf[offset  +  len  -  1];  }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }  return  len;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  read  [RETURN_TYPE]  int    char[]  buf  int  offset  int  length  [VARIABLES]  char  ch  boolean  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  char[]  buf    	[P3_Replace_Literal]
[PATCH]  }  else  if  (  len  ==  -1  )  {	[BUG]  [BUGGY]  }  else  if  (  len  >=  -1)  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }  int  len  =  super.read(buf,  offset,  length);  if  (len  >  0)  {  for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }  lastChar  =  buf[offset  +  len  -  1];  [BUGGY]  }  else  if  (  len  >=  -1)  {  [BUGGY]  lastChar  =  END_OF_STREAM;  }  return  len;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  read  [RETURN_TYPE]  int    char[]  buf  int  offset  int  length  [VARIABLES]  char  ch  boolean  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  char[]  buf    	[P2_Replace_Operator]
[PATCH]  }  else  if  (  len  ==  -1  )  {	[BUG]  [BUGGY]  }  else  if  (  len  ==  -len)  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }  int  len  =  super.read(buf,  offset,  length);  if  (len  >  0)  {  for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }  lastChar  =  buf[offset  +  len  -  1];  [BUGGY]  }  else  if  (  len  ==  -len)  {  [BUGGY]  lastChar  =  END_OF_STREAM;  }  return  len;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  read  [RETURN_TYPE]  int    char[]  buf  int  offset  int  length  [VARIABLES]  char  ch  boolean  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  char[]  buf    	[P3_Replace_Literal]
[PATCH]  }  else  if  (  len  ==  -1  )  {	[BUG]  [BUGGY]  }  else  if  (  offset  ==  -1)  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }  int  len  =  super.read(buf,  offset,  length);  if  (len  >  0)  {  for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }  lastChar  =  buf[offset  +  len  -  1];  [BUGGY]  }  else  if  (  offset  ==  -1)  {  [BUGGY]  lastChar  =  END_OF_STREAM;  }  return  len;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  read  [RETURN_TYPE]  int    char[]  buf  int  offset  int  length  [VARIABLES]  char  ch  boolean  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  char[]  buf    	[P5_Replace_Variable]
[PATCH]  lastChar  =  END_OF_STREAM;	[BUG]  [BUGGY]  lastChar  =  length;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }  int  len  =  super.read(buf,  offset,  length);  if  (len  >  0)  {  for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }  lastChar  =  buf[offset  +  len  -  1];  }  else  if  (len  ==  -1)  {  [BUGGY]  lastChar  =  length;  [BUGGY]  }  return  len;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  read  [RETURN_TYPE]  int    char[]  buf  int  offset  int  length  [VARIABLES]  char  ch  boolean  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  char[]  buf    	[P5_Replace_Variable]
[PATCH]  lastChar  =  END_OF_STREAM;	[BUG]  [BUGGY]  lastChar  ;[CE]  not  a  statement  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }  int  len  =  super.read(buf,  offset,  length);  if  (len  >  0)  {  for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }  lastChar  =  buf[offset  +  len  -  1];  }  else  if  (len  ==  -1)  {  [BUGGY]  lastChar  ;  [BUGGY]  }  return  len;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  read  [RETURN_TYPE]  int    char[]  buf  int  offset  int  length  [VARIABLES]  char  ch  boolean  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  char[]  buf    	[P8_Replace_Mix]
[PATCH]  for  (  int  i  =  offset;  i  <  offset  +  len;  i++  )  {	[BUG]  [BUGGY]  for  >>  (  int  i  =  offset;  i  <  offset  +  len;  i++)  {[CE]  '('  expected  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }  int  len  =  super.read(buf,  offset,  length);  if  (len  >  0)  {  [BUGGY]  for  >>  (  int  i  =  offset;  i  <  offset  +  len;  i++)  {  [BUGGY]  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }  lastChar  =  buf[offset  +  len  -  1];  }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }  return  len;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  read  [RETURN_TYPE]  int    char[]  buf  int  offset  int  length  [VARIABLES]  char  ch  boolean  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  char[]  buf    	[P2_Replace_Operator]
[PATCH]  for  (  int  i  =  offset;  i  <  offset  +  len;  i++  )  {	[BUG]  [BUGGY]  for  (  offsetnt  i  =  offset;  i  <  offset  +  len;  i++)  {[CE]  cannot  find  symbol  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }  int  len  =  super.read(buf,  offset,  length);  if  (len  >  0)  {  [BUGGY]  for  (  offsetnt  i  =  offset;  i  <  offset  +  len;  i++)  {  [BUGGY]  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }  lastChar  =  buf[offset  +  len  -  1];  }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }  return  len;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  read  [RETURN_TYPE]  int    char[]  buf  int  offset  int  length  [VARIABLES]  char  ch  boolean  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  char[]  buf    	[P5_Replace_Variable]
[PATCH]  for  (  int  i  =  offset;  i  <  offset  +  len;  i++  )  {	[BUG]  [BUGGY]  for  (  offsetnt  i  =  i;  i  <  offset  +  len;  i++)  {[CE]  cannot  find  symbol  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }  int  len  =  super.read(buf,  offset,  length);  if  (len  >  0)  {  [BUGGY]  for  (  offsetnt  i  =  i;  i  <  offset  +  len;  i++)  {  [BUGGY]  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }  lastChar  =  buf[offset  +  len  -  1];  }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }  return  len;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  read  [RETURN_TYPE]  int    char[]  buf  int  offset  int  length  [VARIABLES]  char  ch  boolean  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  char[]  buf    	[P5_Replace_Variable]
[PATCH]  }  else  if  (  ch  ==  '\r'  )  {	[BUG]  [BUGGY]  }  else  if  (  ch  >  '\r')  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }  int  len  =  super.read(buf,  offset,  length);  if  (len  >  0)  {  for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  [BUGGY]  }  else  if  (  ch  >  '\r')  {  [BUGGY]  lineCounter++;  }  }  lastChar  =  buf[offset  +  len  -  1];  }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }  return  len;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  read  [RETURN_TYPE]  int    char[]  buf  int  offset  int  length  [VARIABLES]  char  ch  boolean  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  char[]  buf    	[P2_Replace_Operator]
[PATCH]  }  else  if  (  ch  ==  '\r'  )  {	[BUG]  [BUGGY]  }  if  (  ch  ==  '\r')  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }  int  len  =  super.read(buf,  offset,  length);  if  (len  >  0)  {  for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  [BUGGY]  }  if  (  ch  ==  '\r')  {  [BUGGY]  lineCounter++;  }  }  lastChar  =  buf[offset  +  len  -  1];  }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }  return  len;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  read  [RETURN_TYPE]  int    char[]  buf  int  offset  int  length  [VARIABLES]  char  ch  boolean  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  char[]  buf    	[P8_Replace_Mix]
[PATCH]  if  (  '\r'  !=  (  i  >  0  ?  buf[i-1]:  lastChar  )  )  {	[BUG]  [BUGGY]  if  (  '\r'  <=  (  i  >  0  ?  buf[i-1]:  lastChar)  )  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }  int  len  =  super.read(buf,  offset,  length);  if  (len  >  0)  {  for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  [BUGGY]  if  (  '\r'  <=  (  i  >  0  ?  buf[i-1]:  lastChar)  )  {  [BUGGY]  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }  lastChar  =  buf[offset  +  len  -  1];  }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }  return  len;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  read  [RETURN_TYPE]  int    char[]  buf  int  offset  int  length  [VARIABLES]  char  ch  boolean  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  char[]  buf    	[P2_Replace_Operator]
[PATCH]  if  (  '\r'  !=  (  i  >  0  ?  buf[i-1]:  lastChar  )  )  {	[BUG]  [BUGGY]  if  (  '\r'  !=  (  i  >  9  ?  buf[i-1]:  lastChar)  )  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }  int  len  =  super.read(buf,  offset,  length);  if  (len  >  0)  {  for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  [BUGGY]  if  (  '\r'  !=  (  i  >  9  ?  buf[i-1]:  lastChar)  )  {  [BUGGY]  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }  lastChar  =  buf[offset  +  len  -  1];  }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }  return  len;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  read  [RETURN_TYPE]  int    char[]  buf  int  offset  int  length  [VARIABLES]  char  ch  boolean  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  char[]  buf    	[P3_Replace_Literal]
[PATCH]  if  (  '\r'  !=  (  i  >  0  ?  buf[i-1]:  lastChar  )  )  {	[BUG]  [BUGGY]  if  (  '\r'  !=  (  i  >  len  ?  buf[i-1]:  lastChar)  )  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }  int  len  =  super.read(buf,  offset,  length);  if  (len  >  0)  {  for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  [BUGGY]  if  (  '\r'  !=  (  i  >  len  ?  buf[i-1]:  lastChar)  )  {  [BUGGY]  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }  lastChar  =  buf[offset  +  len  -  1];  }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }  return  len;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  read  [RETURN_TYPE]  int    char[]  buf  int  offset  int  length  [VARIABLES]  char  ch  boolean  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  char[]  buf    	[P3_Replace_Literal]
[PATCH]  if  (  '\r'  !=  (  i  >  0  ?  buf[i-1]:  lastChar  )  )  {	[BUG]  [BUGGY]  if  (  '\r'  !=  (  i  >  0  ?  buf[i-lineCounter]:  lastChar)  )  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }  int  len  =  super.read(buf,  offset,  length);  if  (len  >  0)  {  for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  [BUGGY]  if  (  '\r'  !=  (  i  >  0  ?  buf[i-lineCounter]:  lastChar)  )  {  [BUGGY]  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }  lastChar  =  buf[offset  +  len  -  1];  }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }  return  len;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  read  [RETURN_TYPE]  int    char[]  buf  int  offset  int  length  [VARIABLES]  char  ch  boolean  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  char[]  buf    	[P3_Replace_Literal]
[PATCH]  char  ch  =  buf[i];	[BUG]  [BUGGY]  String  ch  =  buf[i];[CE]  incompatible  types  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }  int  len  =  super.read(buf,  offset,  length);  if  (len  >  0)  {  for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  [BUGGY]  String  ch  =  buf[i];  [BUGGY]  if  (ch  ==  '\n')  {  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }  lastChar  =  buf[offset  +  len  -  1];  }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }  return  len;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  read  [RETURN_TYPE]  int    char[]  buf  int  offset  int  length  [VARIABLES]  char  ch  boolean  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  char[]  buf    	[P1_Replace_Type]
[PATCH]  lastChar  =  buf[offset  +  len  -  1];	[BUG]  [BUGGY]  lastChar  =  buf[offset  +  len  >=  1];[CE]  incompatible  types  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }  int  len  =  super.read(buf,  offset,  length);  if  (len  >  0)  {  for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }  [BUGGY]  lastChar  =  buf[offset  +  len  >=  1];  [BUGGY]    }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }  return  len;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  read  [RETURN_TYPE]  int    char[]  buf  int  offset  int  length  [VARIABLES]  char  ch  boolean  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  char[]  buf    	[P2_Replace_Operator]
[PATCH]  lastChar  =  buf[offset  +  len  -  1];	[BUG]  [BUGGY]  lastChar  =  buf[offset  +  len  ];[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }  int  len  =  super.read(buf,  offset,  length);  if  (len  >  0)  {  for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }  [BUGGY]  lastChar  =  buf[offset  +  len  ];  [BUGGY]    }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }  return  len;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  read  [RETURN_TYPE]  int    char[]  buf  int  offset  int  length  [VARIABLES]  char  ch  boolean  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  char[]  buf    	[P3_Replace_Literal]
[PATCH]  lastChar  =  buf[offset  +  len  -  1];	[BUG]  [BUGGY]  lastChar  =  buf[offset  +  lastChar  -  1];[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }  int  len  =  super.read(buf,  offset,  length);  if  (len  >  0)  {  for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }  [BUGGY]  lastChar  =  buf[offset  +  lastChar  -  1];  [BUGGY]    }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }  return  len;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  read  [RETURN_TYPE]  int    char[]  buf  int  offset  int  length  [VARIABLES]  char  ch  boolean  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  char[]  buf    	[P5_Replace_Variable]
[PATCH]  lastChar  =  buf[offset  +  len  -  1];	[BUG]  [BUGGY]  lastChar  =  buf[offset  +  len  -  1  >>>  1];[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }  int  len  =  super.read(buf,  offset,  length);  if  (len  >  0)  {  for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }  [BUGGY]  lastChar  =  buf[offset  +  len  -  1  >>>  1];  [BUGGY]    }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }  return  len;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  read  [RETURN_TYPE]  int    char[]  buf  int  offset  int  length  [VARIABLES]  char  ch  boolean  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  char[]  buf    	[P8_Replace_Mix]
[PATCH]  for  (  int  i  =  offset;  i  <  offset  +  len;  i++  )  {	[BUG]  [BUGGY]  for  (  int  i  =  length;  i  <  offset  +  len;  i++)  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }  int  len  =  super.read(buf,  offset,  length);  if  (len  >  0)  {  [BUGGY]  for  (  int  i  =  length;  i  <  offset  +  len;  i++)  {  [BUGGY]  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }  lastChar  =  buf[offset  +  len  -  1];  }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }  return  len;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  read  [RETURN_TYPE]  int    char[]  buf  int  offset  int  length  [VARIABLES]  char  ch  boolean  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  char[]  buf    	[P5_Replace_Variable]
[PATCH]  return  len;	[BUG]  [BUGGY]  return  lastChar;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }  int  len  =  super.read(buf,  offset,  length);  if  (len  >  0)  {  for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }  lastChar  =  buf[offset  +  len  -  1];  }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }  [BUGGY]  return  lastChar;  [BUGGY]  }    [CLASS]  ExtendedBufferedReader  [METHOD]  read  [RETURN_TYPE]  int    char[]  buf  int  offset  int  length  [VARIABLES]  char  ch  boolean  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  char[]  buf    	[P5_Replace_Variable]
[PATCH]  return  len;	[BUG]  [BUGGY]  return  offset;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }  int  len  =  super.read(buf,  offset,  length);  if  (len  >  0)  {  for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }  lastChar  =  buf[offset  +  len  -  1];  }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }  [BUGGY]  return  offset;  [BUGGY]  }    [CLASS]  ExtendedBufferedReader  [METHOD]  read  [RETURN_TYPE]  int    char[]  buf  int  offset  int  length  [VARIABLES]  char  ch  boolean  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  char[]  buf    	[P8_Replace_Mix]
[PATCH]  String  line  =  super.readLine  (  )  ;	[BUG]  [BUGGY]  char  line  =  super.readLine(  )  ;[CE]  incompatible  types  [CONTEXT]  public  String  readLine()  throws  IOException  {  [BUGGY]  char  line  =  super.readLine(  )  ;  [BUGGY]    if  (line  !=  null)  {  if  (line.length()  >  0)  {  lastChar  =  line.charAt(line.length()  -  1);  }  lineCounter++;  }  else  {  lastChar  =  END_OF_STREAM;  }  return  line;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  readLine  [RETURN_TYPE]  String    [VARIABLES]  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  String  line  boolean    	[P1_Replace_Type]
[PATCH]  String  line  =  super.readLine  (  )  ;	[BUG]  [BUGGY]  String  line  =  super.mark(  )  ;[CE]  no  suitable  method  found  for  mark()  [CONTEXT]  public  String  readLine()  throws  IOException  {  [BUGGY]  String  line  =  super.mark(  )  ;  [BUGGY]    if  (line  !=  null)  {  if  (line.length()  >  0)  {  lastChar  =  line.charAt(line.length()  -  1);  }  lineCounter++;  }  else  {  lastChar  =  END_OF_STREAM;  }  return  line;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  readLine  [RETURN_TYPE]  String    [VARIABLES]  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  String  line  boolean    	[P7_Replace_Invocation]
[PATCH]  String  line  =  super.readLine  (  )  ;	[BUG]  [BUGGY]  String  line  =  super.read(  )  ;[CE]  incompatible  types  [CONTEXT]  public  String  readLine()  throws  IOException  {  [BUGGY]  String  line  =  super.read(  )  ;  [BUGGY]    if  (line  !=  null)  {  if  (line.length()  >  0)  {  lastChar  =  line.charAt(line.length()  -  1);  }  lineCounter++;  }  else  {  lastChar  =  END_OF_STREAM;  }  return  line;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  readLine  [RETURN_TYPE]  String    [VARIABLES]  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  String  line  boolean    	[P7_Replace_Invocation]
[PATCH]  String  line  =  super.readLine  (  )  ;	[BUG]  [BUGGY]  int  current  =  super.read(  )  ;String  line  =  super.readLine(  )  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  String  readLine()  throws  IOException  {  [BUGGY]  int  current  =  super.read(  )  ;String  line  =  super.readLine(  )  ;  [BUGGY]    if  (line  !=  null)  {  if  (line.length()  >  0)  {  lastChar  =  line.charAt(line.length()  -  1);  }  lineCounter++;  }  else  {  lastChar  =  END_OF_STREAM;  }  return  line;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  readLine  [RETURN_TYPE]  String    [VARIABLES]  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  String  line  boolean    	[P11_Insert_Donor_Statement]
[PATCH]  String  line  =  super.readLine  (  )  ;	[BUG]  [BUGGY]  int  c  =  super.read(  )  ;String  line  =  super.readLine(  )  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  String  readLine()  throws  IOException  {  [BUGGY]  int  c  =  super.read(  )  ;String  line  =  super.readLine(  )  ;  [BUGGY]    if  (line  !=  null)  {  if  (line.length()  >  0)  {  lastChar  =  line.charAt(line.length()  -  1);  }  lineCounter++;  }  else  {  lastChar  =  END_OF_STREAM;  }  return  line;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  readLine  [RETURN_TYPE]  String    [VARIABLES]  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  String  line  boolean    	[P11_Insert_Donor_Statement]
[PATCH]  String  line  =  super.readLine  (  )  ;	[BUG]  [BUGGY]  [FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  String  readLine()  throws  IOException  {  [BUGGY]  [BUGGY]    if  (line  !=  null)  {  if  (line.length()  >  0)  {  lastChar  =  line.charAt(line.length()  -  1);  }  lineCounter++;  }  else  {  lastChar  =  END_OF_STREAM;  }  return  line;    [CLASS]  ExtendedBufferedReader  [METHOD]  readLine  [RETURN_TYPE]  String    [VARIABLES]  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  String  line  boolean    	[P14_Delete_Statement]
[PATCH]  if  (  line  !=  null  )  {	[BUG]  [BUGGY]  if  (  line  ==  null)  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  String  readLine()  throws  IOException  {  String  line  =  super.readLine();  [BUGGY]  if  (  line  ==  null)  {  [BUGGY]  if  (line.length()  >  0)  {  lastChar  =  line.charAt(line.length()  -  1);  }  lineCounter++;  }  else  {  lastChar  =  END_OF_STREAM;  }  return  line;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  readLine  [RETURN_TYPE]  String    [VARIABLES]  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  String  line  boolean    	[P2_Replace_Operator]
[PATCH]  if  (  line  !=  null  )  {	[BUG]  [BUGGY]  if  (  line.length()  >  0)  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  String  readLine()  throws  IOException  {  String  line  =  super.readLine();  [BUGGY]  if  (  line.length()  >  0)  {  [BUGGY]  if  (line.length()  >  0)  {  lastChar  =  line.charAt(line.length()  -  1);  }  lineCounter++;  }  else  {  lastChar  =  END_OF_STREAM;  }  return  line;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  readLine  [RETURN_TYPE]  String    [VARIABLES]  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  String  line  boolean    	[P6_Replace_Expression]
[PATCH]  if  (  line  !=  null  )  {	[BUG]  [BUGGY]  if  (  line.length(  )  -  1)  {[CE]  incompatible  types  [CONTEXT]  public  String  readLine()  throws  IOException  {  String  line  =  super.readLine();  [BUGGY]  if  (  line.length(  )  -  1)  {  [BUGGY]  if  (line.length()  >  0)  {  lastChar  =  line.charAt(line.length()  -  1);  }  lineCounter++;  }  else  {  lastChar  =  END_OF_STREAM;  }  return  line;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  readLine  [RETURN_TYPE]  String    [VARIABLES]  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  String  line  boolean    	[P6_Replace_Expression]
[PATCH]  if  (  line  !=  null  )  {	[BUG]  [BUGGY]  if  (  line  !=  false)  {[CE]  incomparable  types:  String  and  boolean  [CONTEXT]  public  String  readLine()  throws  IOException  {  String  line  =  super.readLine();  [BUGGY]  if  (  line  !=  false)  {  [BUGGY]  if  (line.length()  >  0)  {  lastChar  =  line.charAt(line.length()  -  1);  }  lineCounter++;  }  else  {  lastChar  =  END_OF_STREAM;  }  return  line;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  readLine  [RETURN_TYPE]  String    [VARIABLES]  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  String  line  boolean    	[P8_Replace_Mix]
[PATCH]  if  (  line  !=  null  )  {	[BUG]  [BUGGY]  if  (  len  >  0)  {[CE]  cannot  find  symbol  len  [CONTEXT]  public  String  readLine()  throws  IOException  {  String  line  =  super.readLine();  [BUGGY]  if  (  len  >  0)  {  [BUGGY]  if  (line.length()  >  0)  {  lastChar  =  line.charAt(line.length()  -  1);  }  lineCounter++;  }  else  {  lastChar  =  END_OF_STREAM;  }  return  line;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  readLine  [RETURN_TYPE]  String    [VARIABLES]  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  String  line  boolean    	[P9_Replace_Statement]
[PATCH]  if  (  line  !=  null  )  {  if  (  line.length  (  )  >  0  )  {  lastChar  =  line.charAt  (  line.length  (  )  -  1  )  ;  }	[BUG]  [BUGGY]  if((line.length())  >  0)  {    lastChar  =  line.charAt(((line.length())  -  1));};(lineCounter)++;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  String  readLine()  throws  IOException  {  String  line  =  super.readLine();  [BUGGY]  if((line.length())  >  0)  {    lastChar  =  line.charAt(((line.length())  -  1));};(lineCounter)++;  [BUGGY]    if  ((line.length())  >  0)  {lastChar  =  line.charAt(((line.length())  -  1));};  (lineCounter)++;    lineCounter++;  }  else  {  lastChar  =  END_OF_STREAM;  }  return  line;    [CLASS]  ExtendedBufferedReader  [METHOD]  readLine  [RETURN_TYPE]  String    [VARIABLES]  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  String  line  boolean    	[P15_Unwrap_Block]
[PATCH]  if  (  line  !=  null  )  {  if  (  line.length  (  )  >  0  )  {  lastChar  =  line.charAt  (  line.length  (  )  -  1  )  ;  }	[BUG]  [BUGGY]  [FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  String  readLine()  throws  IOException  {  String  line  =  super.readLine();  [BUGGY]  [BUGGY]      lineCounter++;  }  else  {  lastChar  =  END_OF_STREAM;  }  return  line;    [CLASS]  ExtendedBufferedReader  [METHOD]  readLine  [RETURN_TYPE]  String    [VARIABLES]  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  String  line  boolean    	[P16_Remove_Block]
[PATCH]  lastChar  =  END_OF_STREAM;	[BUG]  [BUGGY]  lastChar  =  lastChar  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  String  readLine()  throws  IOException  {  String  line  =  super.readLine();  if  (line  !=  null)  {  if  (line.length()  >  0)  {  lastChar  =  line.charAt(line.length()  -  1);  }  lineCounter++;  }  else  {  [BUGGY]  lastChar  =  lastChar  ;  [BUGGY]  }  return  line;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  readLine  [RETURN_TYPE]  String    [VARIABLES]  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  String  line  boolean    	[P8_Replace_Mix]
[PATCH]  lastChar  =  END_OF_STREAM;	[BUG]  [BUGGY]  lastChar  =  current;lastChar  =  END_OF_STREAM;[CE]  cannot  find  symbol  current  [CONTEXT]  public  String  readLine()  throws  IOException  {  String  line  =  super.readLine();  if  (line  !=  null)  {  if  (line.length()  >  0)  {  lastChar  =  line.charAt(line.length()  -  1);  }  lineCounter++;  }  else  {  [BUGGY]  lastChar  =  current;lastChar  =  END_OF_STREAM;  [BUGGY]  }  return  line;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  readLine  [RETURN_TYPE]  String    [VARIABLES]  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  String  line  boolean    	[P11_Insert_Donor_Statement]
[PATCH]  lastChar  =  END_OF_STREAM;	[BUG]  [BUGGY]  lastChar  =  buf[offset  +  len  -  1];lastChar  =  END_OF_STREAM;[CE]  cannot  find  symbol  buf  [CONTEXT]  public  String  readLine()  throws  IOException  {  String  line  =  super.readLine();  if  (line  !=  null)  {  if  (line.length()  >  0)  {  lastChar  =  line.charAt(line.length()  -  1);  }  lineCounter++;  }  else  {  [BUGGY]  lastChar  =  buf[offset  +  len  -  1];lastChar  =  END_OF_STREAM;  [BUGGY]  }  return  line;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  readLine  [RETURN_TYPE]  String    [VARIABLES]  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  String  line  boolean    	[P11_Insert_Donor_Statement]
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  len  ==  (  -1)  )  {      lastChar  =  END_OF_STREAM;  }[CE]  cannot  find  symbol  len  [CONTEXT]  public  String  readLine()  throws  IOException  {  String  line  =  super.readLine();  if  (line  !=  null)  {  if  (line.length()  >  0)  {  lastChar  =  line.charAt(line.length()  -  1);  }  lineCounter++;  }  else  {  [BUGGY]  if  (  len  ==  (  -1)  )  {      lastChar  =  END_OF_STREAM;  }  [BUGGY]  }  return  line;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  readLine  [RETURN_TYPE]  String    [VARIABLES]  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  String  line  boolean    	[P13_Insert_Block]
[PATCH]  if  (  line.length  (  )  >  0  )  {	[BUG]  [BUGGY]  if  (  line.length(  )  >=  0)  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  String  readLine()  throws  IOException  {  String  line  =  super.readLine();  if  (line  !=  null)  {  [BUGGY]  if  (  line.length(  )  >=  0)  {  [BUGGY]  lastChar  =  line.charAt(line.length()  -  1);  }  lineCounter++;  }  else  {  lastChar  =  END_OF_STREAM;  }  return  line;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  readLine  [RETURN_TYPE]  String    [VARIABLES]  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  String  line  boolean    	[P2_Replace_Operator]
[PATCH]  if  (  line.length  (  )  >  0  )  {	[BUG]  [BUGGY]  if  (  line.length(  )  >  offset)  {[CE]  cannot  find  symbol  offset  [CONTEXT]  public  String  readLine()  throws  IOException  {  String  line  =  super.readLine();  if  (line  !=  null)  {  [BUGGY]  if  (  line.length(  )  >  offset)  {  [BUGGY]  lastChar  =  line.charAt(line.length()  -  1);  }  lineCounter++;  }  else  {  lastChar  =  END_OF_STREAM;  }  return  line;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  readLine  [RETURN_TYPE]  String    [VARIABLES]  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  String  line  boolean    	[P3_Replace_Literal]
[PATCH]  if  (  line.length  (  )  >  0  )  {	[BUG]  [BUGGY]  if  (  line.length()  -  6  >  0)  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  String  readLine()  throws  IOException  {  String  line  =  super.readLine();  if  (line  !=  null)  {  [BUGGY]  if  (  line.length()  -  6  >  0)  {  [BUGGY]  lastChar  =  line.charAt(line.length()  -  1);  }  lineCounter++;  }  else  {  lastChar  =  END_OF_STREAM;  }  return  line;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  readLine  [RETURN_TYPE]  String    [VARIABLES]  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  String  line  boolean    	[P3_Replace_Literal]
[PATCH]  if  (  line.length  (  )  >  0  )  {	[BUG]  [BUGGY]  if  (  line.length(  )  -  1)  {[CE]  incompatible  types  [CONTEXT]  public  String  readLine()  throws  IOException  {  String  line  =  super.readLine();  if  (line  !=  null)  {  [BUGGY]  if  (  line.length(  )  -  1)  {  [BUGGY]  lastChar  =  line.charAt(line.length()  -  1);  }  lineCounter++;  }  else  {  lastChar  =  END_OF_STREAM;  }  return  line;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  readLine  [RETURN_TYPE]  String    [VARIABLES]  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  String  line  boolean    	[P6_Replace_Expression]
[PATCH]  if  (  line.length  (  )  >  0  )  {	[BUG]  [BUGGY]  if  (  line.charAt(  )  >  0)  {[CE]  method  charAt  in  class  String  cannot  be  applied  to  given  types;  [CONTEXT]  public  String  readLine()  throws  IOException  {  String  line  =  super.readLine();  if  (line  !=  null)  {  [BUGGY]  if  (  line.charAt(  )  >  0)  {  [BUGGY]  lastChar  =  line.charAt(line.length()  -  1);  }  lineCounter++;  }  else  {  lastChar  =  END_OF_STREAM;  }  return  line;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  readLine  [RETURN_TYPE]  String    [VARIABLES]  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  String  line  boolean    	[P7_Replace_Invocation]
[PATCH]  if  (  line.length  (  )  >  0  )  {  lastChar  =  line.charAt  (  line.length  (  )  -  1  )  ;  }	[BUG]  [BUGGY]  lastChar  =  line.charAt(((line.length())  -  1));[CE]  ';'  expected  [CONTEXT]  public  String  readLine()  throws  IOException  {  String  line  =  super.readLine();  if  (line  !=  null)  {  [BUGGY]  lastChar  =  line.charAt(((line.length())  -  1));  [BUGGY]    lastChar  =  line.charAt(((line.length())  -  1));  lineCounter++;  }  else  {  lastChar  =  END_OF_STREAM;  }  return  line;    [CLASS]  ExtendedBufferedReader  [METHOD]  readLine  [RETURN_TYPE]  String    [VARIABLES]  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  String  line  boolean    	[P15_Unwrap_Block]
[PATCH]  if  (  line.length  (  )  >  0  )  {  lastChar  =  line.charAt  (  line.length  (  )  -  1  )  ;  }	[BUG]  [BUGGY]  [CE]  ';'  expected  [CONTEXT]  public  String  readLine()  throws  IOException  {  String  line  =  super.readLine();  if  (line  !=  null)  {  [BUGGY]  [BUGGY]      lineCounter++;  }  else  {  lastChar  =  END_OF_STREAM;  }  return  line;    [CLASS]  ExtendedBufferedReader  [METHOD]  readLine  [RETURN_TYPE]  String    [VARIABLES]  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  String  line  boolean    	[P16_Remove_Block]
[PATCH]  lastChar  =  line.charAt  (  line.length  (  )  -  1  )  ;	[BUG]  [BUGGY]  lastChar  =  line.charAt(  line.length(  )    >=  1)  ;[CE]  method  charAt  in  class  String  cannot  be  applied  to  given  types;  [CONTEXT]  public  String  readLine()  throws  IOException  {  String  line  =  super.readLine();  if  (line  !=  null)  {  if  (line.length()  >  0)  {  [BUGGY]  lastChar  =  line.charAt(  line.length(  )    >=  1)  ;  [BUGGY]  }  lineCounter++;  }  else  {  lastChar  =  END_OF_STREAM;  }  return  line;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  readLine  [RETURN_TYPE]  String    [VARIABLES]  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  String  line  boolean    	[P2_Replace_Operator]
[PATCH]  lastChar  =  line.charAt  (  line.length  (  )  -  1  )  ;	[BUG]  [BUGGY]  lastChar  =  line.charAt(  line.length(  )  -  offset)  ;[CE]  cannot  find  symbol  offset  [CONTEXT]  public  String  readLine()  throws  IOException  {  String  line  =  super.readLine();  if  (line  !=  null)  {  if  (line.length()  >  0)  {  [BUGGY]  lastChar  =  line.charAt(  line.length(  )  -  offset)  ;  [BUGGY]  }  lineCounter++;  }  else  {  lastChar  =  END_OF_STREAM;  }  return  line;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  readLine  [RETURN_TYPE]  String    [VARIABLES]  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  String  line  boolean    	[P3_Replace_Literal]
[PATCH]  lastChar  =  line.charAt  (  line.length  (  )  -  1  )  ;	[BUG]  [BUGGY]  lastChar  =  line.charAt(  line.length()  -  5  -  1)  ;[FE]  String  index  out  of  range:  -3  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  String  readLine()  throws  IOException  {  String  line  =  super.readLine();  if  (line  !=  null)  {  if  (line.length()  >  0)  {  [BUGGY]  lastChar  =  line.charAt(  line.length()  -  5  -  1)  ;  [BUGGY]  }  lineCounter++;  }  else  {  lastChar  =  END_OF_STREAM;  }  return  line;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  readLine  [RETURN_TYPE]  String    [VARIABLES]  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  String  line  boolean    	[P3_Replace_Literal]
[PATCH]  lastChar  =  line.charAt  (  line.length  (  )  -  1  )  ;	[BUG]  [BUGGY]  lastChar  =  line.charAt(  line.charAt(  )  -  1)  ;[CE]  method  charAt  in  class  String  cannot  be  applied  to  given  types;  [CONTEXT]  public  String  readLine()  throws  IOException  {  String  line  =  super.readLine();  if  (line  !=  null)  {  if  (line.length()  >  0)  {  [BUGGY]  lastChar  =  line.charAt(  line.charAt(  )  -  1)  ;  [BUGGY]  }  lineCounter++;  }  else  {  lastChar  =  END_OF_STREAM;  }  return  line;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  readLine  [RETURN_TYPE]  String    [VARIABLES]  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  String  line  boolean    	[P7_Replace_Invocation]
[PATCH]  lastChar  =  line.charAt  (  line.length  (  )  -  1  )  ;	[BUG]  [BUGGY]  lastChar  =  line.charAt(  line.length(  )  -  0  )  ;[FE]  String  index  out  of  range:  3  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  String  readLine()  throws  IOException  {  String  line  =  super.readLine();  if  (line  !=  null)  {  if  (line.length()  >  0)  {  [BUGGY]  lastChar  =  line.charAt(  line.length(  )  -  0  )  ;  [BUGGY]  }  lineCounter++;  }  else  {  lastChar  =  END_OF_STREAM;  }  return  line;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  readLine  [RETURN_TYPE]  String    [VARIABLES]  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  String  line  boolean    	[P8_Replace_Mix]
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  (  line.length(  )  )  >  0)  {      lastChar  =  line.charAt(  (  (  line.length(  )  )  -  1)  )  ;  }[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  String  readLine()  throws  IOException  {  String  line  =  super.readLine();  if  (line  !=  null)  {  if  (line.length()  >  0)  {  [BUGGY]  if  (  (  line.length(  )  )  >  0)  {      lastChar  =  line.charAt(  (  (  line.length(  )  )  -  1)  )  ;  }  [BUGGY]  }  lineCounter++;  }  else  {  lastChar  =  END_OF_STREAM;  }  return  line;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  readLine  [RETURN_TYPE]  String    [VARIABLES]  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  String  line  boolean    	[P13_Insert_Block]
[PATCH]  lastChar  =  line.charAt  (  line.length  (  )  -  1  )  ;	[BUG]  [BUGGY]  lastChar  =  line.charAt(  line.length(  )    >>  1)  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  String  readLine()  throws  IOException  {  String  line  =  super.readLine();  if  (line  !=  null)  {  if  (line.length()  >  0)  {  [BUGGY]  lastChar  =  line.charAt(  line.length(  )    >>  1)  ;  [BUGGY]  }  lineCounter++;  }  else  {  lastChar  =  END_OF_STREAM;  }  return  line;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  readLine  [RETURN_TYPE]  String    [VARIABLES]  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  String  line  boolean    	[P2_Replace_Operator]
[PATCH]  lastChar  =  line.charAt  (  line.length  (  )  -  1  )  ;	[BUG]  [BUGGY]  lastChar  =  line.charAt(  line.length(  )  )  ;[FE]  String  index  out  of  range:  3  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  String  readLine()  throws  IOException  {  String  line  =  super.readLine();  if  (line  !=  null)  {  if  (line.length()  >  0)  {  [BUGGY]  lastChar  =  line.charAt(  line.length(  )  )  ;  [BUGGY]  }  lineCounter++;  }  else  {  lastChar  =  END_OF_STREAM;  }  return  line;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  readLine  [RETURN_TYPE]  String    [VARIABLES]  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  String  line  boolean    	[P3_Replace_Literal]
[PATCH]  lastChar  =  line.charAt  (  line.length  (  )  -  1  )  ;	[BUG]  [BUGGY]  lastChar  =  line.charAt(  line.length()  +  6  -  1)  ;[FE]  String  index  out  of  range:  8  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  String  readLine()  throws  IOException  {  String  line  =  super.readLine();  if  (line  !=  null)  {  if  (line.length()  >  0)  {  [BUGGY]  lastChar  =  line.charAt(  line.length()  +  6  -  1)  ;  [BUGGY]  }  lineCounter++;  }  else  {  lastChar  =  END_OF_STREAM;  }  return  line;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  readLine  [RETURN_TYPE]  String    [VARIABLES]  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  String  line  boolean    	[P3_Replace_Literal]
[PATCH]  lastChar  =  line.charAt  (  line.length  (  )  -  1  )  ;	[BUG]  [BUGGY]  [FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  String  readLine()  throws  IOException  {  String  line  =  super.readLine();  if  (line  !=  null)  {  if  (line.length()  >  0)  {  [BUGGY]  [BUGGY]    }  lineCounter++;  }  else  {  lastChar  =  END_OF_STREAM;  }  return  line;    [CLASS]  ExtendedBufferedReader  [METHOD]  readLine  [RETURN_TYPE]  String    [VARIABLES]  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  String  line  boolean    	[P14_Delete_Statement]
[PATCH]  lastChar  =  line.charAt  (  line.length  (  )  -  1  )  ;	[BUG]  [BUGGY]  lastChar  =  line.charAt(  line.length()  +  9  -  1)  ;[FE]  String  index  out  of  range:  11  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  String  readLine()  throws  IOException  {  String  line  =  super.readLine();  if  (line  !=  null)  {  if  (line.length()  >  0)  {  [BUGGY]  lastChar  =  line.charAt(  line.length()  +  9  -  1)  ;  [BUGGY]  }  lineCounter++;  }  else  {  lastChar  =  END_OF_STREAM;  }  return  line;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  readLine  [RETURN_TYPE]  String    [VARIABLES]  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  String  line  boolean    	[P3_Replace_Literal]
[PATCH]  lastChar  =  line.charAt  (  line.length  (  )  -  1  )  ;	[BUG]  [BUGGY]  lastChar  =  line.charAt(  line.length()  +  8  -  1)  ;[FE]  String  index  out  of  range:  10  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  String  readLine()  throws  IOException  {  String  line  =  super.readLine();  if  (line  !=  null)  {  if  (line.length()  >  0)  {  [BUGGY]  lastChar  =  line.charAt(  line.length()  +  8  -  1)  ;  [BUGGY]  }  lineCounter++;  }  else  {  lastChar  =  END_OF_STREAM;  }  return  line;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  readLine  [RETURN_TYPE]  String    [VARIABLES]  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  String  line  boolean    	[P3_Replace_Literal]
[PATCH]  if  (  line.length  (  )  >  0  )  {	[BUG]  [BUGGY]  if  (  line.length()  +  9  >  0)  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  String  readLine()  throws  IOException  {  String  line  =  super.readLine();  if  (line  !=  null)  {  [BUGGY]  if  (  line.length()  +  9  >  0)  {  [BUGGY]  lastChar  =  line.charAt(line.length()  -  1);  }  lineCounter++;  }  else  {  lastChar  =  END_OF_STREAM;  }  return  line;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  readLine  [RETURN_TYPE]  String    [VARIABLES]  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  String  line  boolean    	[P3_Replace_Literal]
[PATCH]  lastChar  =  line.charAt  (  line.length  (  )  -  1  )  ;	[BUG]  [BUGGY]  lastChar  =  line.charAt(  line.length(  )    &&  1)  ;[CE]  bad  operand  types  for  binary  operator  '&&'  [CONTEXT]  public  String  readLine()  throws  IOException  {  String  line  =  super.readLine();  if  (line  !=  null)  {  if  (line.length()  >  0)  {  [BUGGY]  lastChar  =  line.charAt(  line.length(  )    &&  1)  ;  [BUGGY]  }  lineCounter++;  }  else  {  lastChar  =  END_OF_STREAM;  }  return  line;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  readLine  [RETURN_TYPE]  String    [VARIABLES]  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  String  line  boolean    	[P2_Replace_Operator]
[PATCH]  lastChar  =  line.charAt  (  line.length  (  )  -  1  )  ;	[BUG]  [BUGGY]  lastChar  =  line.charAt(  line.length()  -  9  -  1)  ;[FE]  String  index  out  of  range:  -7  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  String  readLine()  throws  IOException  {  String  line  =  super.readLine();  if  (line  !=  null)  {  if  (line.length()  >  0)  {  [BUGGY]  lastChar  =  line.charAt(  line.length()  -  9  -  1)  ;  [BUGGY]  }  lineCounter++;  }  else  {  lastChar  =  END_OF_STREAM;  }  return  line;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  readLine  [RETURN_TYPE]  String    [VARIABLES]  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  String  line  boolean    	[P3_Replace_Literal]
[PATCH]  if  (  line.length  (  )  >  0  )  {	[BUG]  [BUGGY]  if  (  line.length(  )  >  len)  {[CE]  cannot  find  symbol  len  [CONTEXT]  public  String  readLine()  throws  IOException  {  String  line  =  super.readLine();  if  (line  !=  null)  {  [BUGGY]  if  (  line.length(  )  >  len)  {  [BUGGY]  lastChar  =  line.charAt(line.length()  -  1);  }  lineCounter++;  }  else  {  lastChar  =  END_OF_STREAM;  }  return  line;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  readLine  [RETURN_TYPE]  String    [VARIABLES]  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  String  line  boolean    	[P3_Replace_Literal]
[PATCH]  if  (  line.length  (  )  >  0  )  {	[BUG]  [BUGGY]  if  (  line.length()  -  3  >  0)  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  String  readLine()  throws  IOException  {  String  line  =  super.readLine();  if  (line  !=  null)  {  [BUGGY]  if  (  line.length()  -  3  >  0)  {  [BUGGY]  lastChar  =  line.charAt(line.length()  -  1);  }  lineCounter++;  }  else  {  lastChar  =  END_OF_STREAM;  }  return  line;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  readLine  [RETURN_TYPE]  String    [VARIABLES]  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  String  line  boolean    	[P3_Replace_Literal]
[PATCH]  lastChar  =  line.charAt  (  line.length  (  )  -  1  )  ;	[BUG]  [BUGGY]  lastChar  =  line.charAt(  line.length(  )    <<  1)  ;[FE]  String  index  out  of  range:  6  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  String  readLine()  throws  IOException  {  String  line  =  super.readLine();  if  (line  !=  null)  {  if  (line.length()  >  0)  {  [BUGGY]  lastChar  =  line.charAt(  line.length(  )    <<  1)  ;  [BUGGY]  }  lineCounter++;  }  else  {  lastChar  =  END_OF_STREAM;  }  return  line;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  readLine  [RETURN_TYPE]  String    [VARIABLES]  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  String  line  boolean    	[P2_Replace_Operator]
[PATCH]  lastChar  =  line.charAt  (  line.length  (  )  -  1  )  ;	[BUG]  [BUGGY]  lastChar  =  line.charAt(  line.length(  )  -  )  ;[CE]  illegal  start  of  expression  [CONTEXT]  public  String  readLine()  throws  IOException  {  String  line  =  super.readLine();  if  (line  !=  null)  {  if  (line.length()  >  0)  {  [BUGGY]  lastChar  =  line.charAt(  line.length(  )  -  )  ;  [BUGGY]  }  lineCounter++;  }  else  {  lastChar  =  END_OF_STREAM;  }  return  line;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  readLine  [RETURN_TYPE]  String    [VARIABLES]  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  String  line  boolean    	[P3_Replace_Literal]
[PATCH]  lastChar  =  line.charAt  (  line.length  (  )  -  1  )  ;	[BUG]  [BUGGY]  lastChar  =  line.charAt(  line.length()  +  0  -  1)  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  String  readLine()  throws  IOException  {  String  line  =  super.readLine();  if  (line  !=  null)  {  if  (line.length()  >  0)  {  [BUGGY]  lastChar  =  line.charAt(  line.length()  +  0  -  1)  ;  [BUGGY]  }  lineCounter++;  }  else  {  lastChar  =  END_OF_STREAM;  }  return  line;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  readLine  [RETURN_TYPE]  String    [VARIABLES]  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  String  line  boolean    	[P3_Replace_Literal]
[PATCH]  lastChar  =  line.charAt  (  line.length  (  )  -  1  )  ;	[BUG]  [BUGGY]  lastChar  =  line.charAt(  line.length()  +  1  -  1)  ;[FE]  String  index  out  of  range:  3  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  String  readLine()  throws  IOException  {  String  line  =  super.readLine();  if  (line  !=  null)  {  if  (line.length()  >  0)  {  [BUGGY]  lastChar  =  line.charAt(  line.length()  +  1  -  1)  ;  [BUGGY]  }  lineCounter++;  }  else  {  lastChar  =  END_OF_STREAM;  }  return  line;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  readLine  [RETURN_TYPE]  String    [VARIABLES]  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  String  line  boolean    	[P3_Replace_Literal]
[PATCH]  lastChar  =  line.charAt  (  line.length  (  )  -  1  )  ;	[BUG]  [BUGGY]  lastChar  =  line.charAt(  line.length()  +  7  -  1)  ;[FE]  String  index  out  of  range:  9  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  String  readLine()  throws  IOException  {  String  line  =  super.readLine();  if  (line  !=  null)  {  if  (line.length()  >  0)  {  [BUGGY]  lastChar  =  line.charAt(  line.length()  +  7  -  1)  ;  [BUGGY]  }  lineCounter++;  }  else  {  lastChar  =  END_OF_STREAM;  }  return  line;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  readLine  [RETURN_TYPE]  String    [VARIABLES]  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  String  line  boolean    	[P3_Replace_Literal]
[PATCH]  lastChar  =  line.charAt  (  line.length  (  )  -  1  )  ;	[BUG]  [BUGGY]  lastChar  =  line.charAt(  line.length(  )    <=  1)  ;[CE]  method  charAt  in  class  String  cannot  be  applied  to  given  types;  [CONTEXT]  public  String  readLine()  throws  IOException  {  String  line  =  super.readLine();  if  (line  !=  null)  {  if  (line.length()  >  0)  {  [BUGGY]  lastChar  =  line.charAt(  line.length(  )    <=  1)  ;  [BUGGY]  }  lineCounter++;  }  else  {  lastChar  =  END_OF_STREAM;  }  return  line;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  readLine  [RETURN_TYPE]  String    [VARIABLES]  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  String  line  boolean    	[P2_Replace_Operator]
[PATCH]  lastChar  =  line.charAt  (  line.length  (  )  -  1  )  ;	[BUG]  [BUGGY]  lastChar  =  line.charAt(  line.length()  -  1  -  1)  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  String  readLine()  throws  IOException  {  String  line  =  super.readLine();  if  (line  !=  null)  {  if  (line.length()  >  0)  {  [BUGGY]  lastChar  =  line.charAt(  line.length()  -  1  -  1)  ;  [BUGGY]  }  lineCounter++;  }  else  {  lastChar  =  END_OF_STREAM;  }  return  line;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  readLine  [RETURN_TYPE]  String    [VARIABLES]  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  String  line  boolean    	[P3_Replace_Literal]
[PATCH]  lastChar  =  END_OF_STREAM;	[BUG]  [BUGGY]  lastChar  =  len;[CE]  cannot  find  symbol  len  [CONTEXT]  public  String  readLine()  throws  IOException  {  String  line  =  super.readLine();  if  (line  !=  null)  {  if  (line.length()  >  0)  {  lastChar  =  line.charAt(line.length()  -  1);  }  lineCounter++;  }  else  {  [BUGGY]  lastChar  =  len;  [BUGGY]  }  return  line;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  readLine  [RETURN_TYPE]  String    [VARIABLES]  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  String  line  boolean    	[P5_Replace_Variable]
[PATCH]  if  (  line.length  (  )  >  0  )  {	[BUG]  [BUGGY]  if  (  line.length()  -  4  >  0)  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  String  readLine()  throws  IOException  {  String  line  =  super.readLine();  if  (line  !=  null)  {  [BUGGY]  if  (  line.length()  -  4  >  0)  {  [BUGGY]  lastChar  =  line.charAt(line.length()  -  1);  }  lineCounter++;  }  else  {  lastChar  =  END_OF_STREAM;  }  return  line;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  readLine  [RETURN_TYPE]  String    [VARIABLES]  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  String  line  boolean    	[P3_Replace_Literal]
[PATCH]  lastChar  =  line.charAt  (  line.length  (  )  -  1  )  ;	[BUG]  [BUGGY]  lastChar  =  line.charAt(  line.length(  )    &  1)  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  String  readLine()  throws  IOException  {  String  line  =  super.readLine();  if  (line  !=  null)  {  if  (line.length()  >  0)  {  [BUGGY]  lastChar  =  line.charAt(  line.length(  )    &  1)  ;  [BUGGY]  }  lineCounter++;  }  else  {  lastChar  =  END_OF_STREAM;  }  return  line;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  readLine  [RETURN_TYPE]  String    [VARIABLES]  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  String  line  boolean    	[P2_Replace_Operator]
[PATCH]  lastChar  =  line.charAt  (  line.length  (  )  -  1  )  ;	[BUG]  [BUGGY]  lastChar  =  line.charAt(  line.length()  -  2  -  1)  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  String  readLine()  throws  IOException  {  String  line  =  super.readLine();  if  (line  !=  null)  {  if  (line.length()  >  0)  {  [BUGGY]  lastChar  =  line.charAt(  line.length()  -  2  -  1)  ;  [BUGGY]  }  lineCounter++;  }  else  {  lastChar  =  END_OF_STREAM;  }  return  line;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  readLine  [RETURN_TYPE]  String    [VARIABLES]  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  String  line  boolean    	[P3_Replace_Literal]
[PATCH]  lastChar  =  line.charAt  (  line.length  (  )  -  1  )  ;	[BUG]  [BUGGY]  lastChar  =  line.charAt(  line.length()  +  4  -  1)  ;[FE]  String  index  out  of  range:  6  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  String  readLine()  throws  IOException  {  String  line  =  super.readLine();  if  (line  !=  null)  {  if  (line.length()  >  0)  {  [BUGGY]  lastChar  =  line.charAt(  line.length()  +  4  -  1)  ;  [BUGGY]  }  lineCounter++;  }  else  {  lastChar  =  END_OF_STREAM;  }  return  line;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  readLine  [RETURN_TYPE]  String    [VARIABLES]  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  String  line  boolean    	[P3_Replace_Literal]
[PATCH]  super.mark  (  1  )  ;	[BUG]  [BUGGY]  super.mark(  c)  ;[CE]  cannot  find  symbol  c  [CONTEXT]  int  lookAhead()  throws  IOException  {  [BUGGY]  super.mark(  c)  ;  [BUGGY]  int  c  =  super.read();  super.reset();  return  c;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  lookAhead  [RETURN_TYPE]  int    [VARIABLES]  int  END_OF_STREAM  UNDEFINED  c  current  i  lastChar  len  length  lineCounter  offset  boolean    	[P3_Replace_Literal]
[PATCH]  super.mark  (  1  )  ;	[BUG]  [BUGGY]  super.readLine(  )  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  int  lookAhead()  throws  IOException  {  [BUGGY]  super.readLine(  )  ;  [BUGGY]  int  c  =  super.read();  super.reset();  return  c;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  lookAhead  [RETURN_TYPE]  int    [VARIABLES]  int  END_OF_STREAM  UNDEFINED  c  current  i  lastChar  len  length  lineCounter  offset  boolean    	[P7_Replace_Invocation]
[PATCH]  super.mark  (  1  )  ;	[BUG]  [BUGGY]  [FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  int  lookAhead()  throws  IOException  {  [BUGGY]  [BUGGY]    int  c  =  super.read();  super.reset();  return  c;    [CLASS]  ExtendedBufferedReader  [METHOD]  lookAhead  [RETURN_TYPE]  int    [VARIABLES]  int  END_OF_STREAM  UNDEFINED  c  current  i  lastChar  len  length  lineCounter  offset  boolean    	[P14_Delete_Statement]
[PATCH]  super.mark  (  1  )  ;	[BUG]  [BUGGY]  super.reset(  )  ;super.mark(  1)  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  int  lookAhead()  throws  IOException  {  [BUGGY]  super.reset(  )  ;super.mark(  1)  ;  [BUGGY]  int  c  =  super.read();  super.reset();  return  c;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  lookAhead  [RETURN_TYPE]  int    [VARIABLES]  int  END_OF_STREAM  UNDEFINED  c  current  i  lastChar  len  length  lineCounter  offset  boolean    	[P11_Insert_Donor_Statement]
[PATCH]  super.mark  (  1  )  ;	[BUG]  [BUGGY]  super(  r)  ;super.mark(  1)  ;[CE]  call  to  super  must  be  first  statement  in  constructor  [CONTEXT]  int  lookAhead()  throws  IOException  {  [BUGGY]  super(  r)  ;super.mark(  1)  ;  [BUGGY]  int  c  =  super.read();  super.reset();  return  c;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  lookAhead  [RETURN_TYPE]  int    [VARIABLES]  int  END_OF_STREAM  UNDEFINED  c  current  i  lastChar  len  length  lineCounter  offset  boolean    	[P11_Insert_Donor_Statement]
[PATCH]  int  c  =  super.read  (  )  ;	[BUG]  [BUGGY]  short  c  =  super.read(  )  ;[CE]  possible  loss  of  precision  [CONTEXT]  int  lookAhead()  throws  IOException  {  super.mark(1);  [BUGGY]  short  c  =  super.read(  )  ;  [BUGGY]  super.reset();  return  c;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  lookAhead  [RETURN_TYPE]  int    [VARIABLES]  int  END_OF_STREAM  UNDEFINED  c  current  i  lastChar  len  length  lineCounter  offset  boolean    	[P1_Replace_Type]
[PATCH]  int  c  =  super.read  (  )  ;	[BUG]  [BUGGY]  int  c  =  super.mark(  )  ;[CE]  no  suitable  method  found  for  mark()  [CONTEXT]  int  lookAhead()  throws  IOException  {  super.mark(1);  [BUGGY]  int  c  =  super.mark(  )  ;  [BUGGY]  super.reset();  return  c;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  lookAhead  [RETURN_TYPE]  int    [VARIABLES]  int  END_OF_STREAM  UNDEFINED  c  current  i  lastChar  len  length  lineCounter  offset  boolean    	[P7_Replace_Invocation]
[PATCH]  int  c  =  super.read  (  )  ;	[BUG]  [BUGGY]  String  line  =  super.readLine(  )  ;int  c  =  super.read(  )  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  int  lookAhead()  throws  IOException  {  super.mark(1);  [BUGGY]  String  line  =  super.readLine(  )  ;int  c  =  super.read(  )  ;  [BUGGY]  super.reset();  return  c;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  lookAhead  [RETURN_TYPE]  int    [VARIABLES]  int  END_OF_STREAM  UNDEFINED  c  current  i  lastChar  len  length  lineCounter  offset  boolean    	[P11_Insert_Donor_Statement]
[PATCH]  int  c  =  super.read  (  )  ;	[BUG]  [BUGGY]  int  len  =  super.read(  buf,  offset,  length)  ;int  c  =  super.read(  )  ;[CE]  cannot  find  symbol  buf  [CONTEXT]  int  lookAhead()  throws  IOException  {  super.mark(1);  [BUGGY]  int  len  =  super.read(  buf,  offset,  length)  ;int  c  =  super.read(  )  ;  [BUGGY]  super.reset();  return  c;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  lookAhead  [RETURN_TYPE]  int    [VARIABLES]  int  END_OF_STREAM  UNDEFINED  c  current  i  lastChar  len  length  lineCounter  offset  boolean    	[P11_Insert_Donor_Statement]
[PATCH]  int  c  =  super.read  (  )  ;	[BUG]  [BUGGY]  int  current  =  super.read(  )  ;int  c  =  super.read(  )  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  int  lookAhead()  throws  IOException  {  super.mark(1);  [BUGGY]  int  current  =  super.read(  )  ;int  c  =  super.read(  )  ;  [BUGGY]  super.reset();  return  c;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  lookAhead  [RETURN_TYPE]  int    [VARIABLES]  int  END_OF_STREAM  UNDEFINED  c  current  i  lastChar  len  length  lineCounter  offset  boolean    	[P11_Insert_Donor_Statement]
[PATCH]  int  c  =  super.read  (  )  ;  super.reset  (  )  ;	[BUG]  [BUGGY]  [FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  int  lookAhead()  throws  IOException  {  super.mark(1);  [BUGGY]  [BUGGY]      return  c;    [CLASS]  ExtendedBufferedReader  [METHOD]  lookAhead  [RETURN_TYPE]  int    [VARIABLES]  int  END_OF_STREAM  UNDEFINED  c  current  i  lastChar  len  length  lineCounter  offset  boolean    	[P14_Delete_Statement]
[PATCH]  int  c  =  super.read  (  )  ;	[BUG]  [BUGGY]  super.reset(  )  ;int  c  =  super.read(  )  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  int  lookAhead()  throws  IOException  {  super.mark(1);  [BUGGY]  super.reset(  )  ;int  c  =  super.read(  )  ;  [BUGGY]  super.reset();  return  c;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  lookAhead  [RETURN_TYPE]  int    [VARIABLES]  int  END_OF_STREAM  UNDEFINED  c  current  i  lastChar  len  length  lineCounter  offset  boolean    	[P11_Insert_Donor_Statement]
[PATCH]  super.reset  (  )  ;	[BUG]  [BUGGY]  super.mark(  )  ;[CE]  no  suitable  method  found  for  mark()  [CONTEXT]  int  lookAhead()  throws  IOException  {  super.mark(1);  int  c  =  super.read();  [BUGGY]  super.mark(  )  ;  [BUGGY]    return  c;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  lookAhead  [RETURN_TYPE]  int    [VARIABLES]  int  END_OF_STREAM  UNDEFINED  c  current  i  lastChar  len  length  lineCounter  offset  boolean    	[P7_Replace_Invocation]
[PATCH]  super.reset  (  )  ;	[BUG]  [BUGGY]  super.read(  )  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  int  lookAhead()  throws  IOException  {  super.mark(1);  int  c  =  super.read();  [BUGGY]  super.read(  )  ;  [BUGGY]    return  c;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  lookAhead  [RETURN_TYPE]  int    [VARIABLES]  int  END_OF_STREAM  UNDEFINED  c  current  i  lastChar  len  length  lineCounter  offset  boolean    	[P8_Replace_Mix]
[PATCH]  super.reset  (  )  ;	[BUG]  [BUGGY]  [FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  int  lookAhead()  throws  IOException  {  super.mark(1);  int  c  =  super.read();  [BUGGY]  [BUGGY]    return  c;    [CLASS]  ExtendedBufferedReader  [METHOD]  lookAhead  [RETURN_TYPE]  int    [VARIABLES]  int  END_OF_STREAM  UNDEFINED  c  current  i  lastChar  len  length  lineCounter  offset  boolean    	[P14_Delete_Statement]
[PATCH]  super.reset  (  )  ;	[BUG]  [BUGGY]  super(  r)  ;super.reset(  )  ;[CE]  call  to  super  must  be  first  statement  in  constructor  [CONTEXT]  int  lookAhead()  throws  IOException  {  super.mark(1);  int  c  =  super.read();  [BUGGY]  super(  r)  ;super.reset(  )  ;  [BUGGY]    return  c;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  lookAhead  [RETURN_TYPE]  int    [VARIABLES]  int  END_OF_STREAM  UNDEFINED  c  current  i  lastChar  len  length  lineCounter  offset  boolean    	[P11_Insert_Donor_Statement]
[PATCH]  super.reset  (  )  ;	[BUG]  [BUGGY]  super.mark(  1)  ;super.reset(  )  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  int  lookAhead()  throws  IOException  {  super.mark(1);  int  c  =  super.read();  [BUGGY]  super.mark(  1)  ;super.reset(  )  ;  [BUGGY]    return  c;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  lookAhead  [RETURN_TYPE]  int    [VARIABLES]  int  END_OF_STREAM  UNDEFINED  c  current  i  lastChar  len  length  lineCounter  offset  boolean    	[P11_Insert_Donor_Statement]
[PATCH]  super.reset  (  )  ;	[BUG]  [BUGGY]  int  c  =  super.read(  )  ;super.reset(  )  ;[CE]  variable  c  is  already  defined  in  method  lookAhead()  [CONTEXT]  int  lookAhead()  throws  IOException  {  super.mark(1);  int  c  =  super.read();  [BUGGY]  int  c  =  super.read(  )  ;super.reset(  )  ;  [BUGGY]    return  c;  }    [CLASS]  ExtendedBufferedReader  [METHOD]  lookAhead  [RETURN_TYPE]  int    [VARIABLES]  int  END_OF_STREAM  UNDEFINED  c  current  i  lastChar  len  length  lineCounter  offset  boolean    	[P11_Insert_Donor_Statement]
[PATCH]  return  c;	[BUG]  [BUGGY]  return  lineCounter;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  int  lookAhead()  throws  IOException  {  super.mark(1);  int  c  =  super.read();  super.reset();  [BUGGY]  return  lineCounter;  [BUGGY]  }    [CLASS]  ExtendedBufferedReader  [METHOD]  lookAhead  [RETURN_TYPE]  int    [VARIABLES]  int  END_OF_STREAM  UNDEFINED  c  current  i  lastChar  len  length  lineCounter  offset  boolean    	[P5_Replace_Variable]
[PATCH]  return  c;	[BUG]  [BUGGY]  return  len;[CE]  cannot  find  symbol  len  [CONTEXT]  int  lookAhead()  throws  IOException  {  super.mark(1);  int  c  =  super.read();  super.reset();  [BUGGY]  return  len;  [BUGGY]  }    [CLASS]  ExtendedBufferedReader  [METHOD]  lookAhead  [RETURN_TYPE]  int    [VARIABLES]  int  END_OF_STREAM  UNDEFINED  c  current  i  lastChar  len  length  lineCounter  offset  boolean    	[P8_Replace_Mix]
[PATCH]  return  lineCounter;	[BUG]  [BUGGY]  return  offset;[CE]  cannot  find  symbol  offset  [CONTEXT]  int  getLineNumber()  {  [BUGGY]  return  offset;  [BUGGY]  }    [CLASS]  ExtendedBufferedReader  [METHOD]  getLineNumber  [RETURN_TYPE]  int    [VARIABLES]  int  END_OF_STREAM  UNDEFINED  c  current  i  lastChar  len  length  lineCounter  offset  boolean    	[P5_Replace_Variable]
[PATCH]  private  final  List<String>  record  =  new  ArrayList<String>  (  )  ;	[BUG]  [BUGGY]  private  List<String>  record  =  new  ArrayList<String>(  )  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  private  final  Map<String,  Integer>  headerMapping;        [BUGGY]  private  List<String>  record  =  new  ArrayList<String>(  )  ;  [BUGGY]  private  final  Token  reusableToken  =  new  Token();            [CLASS]  CSVParser  1    [VARIABLES]  	[P8_Replace_Mix]
[PATCH]  private  final  Token  reusableToken  =  new  Token  (  )  ;	[BUG]  [BUGGY]  private  Token  reusableToken  =  new  Token(  )  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]        private  final  List<String>  record  =  new  ArrayList<String>();  [BUGGY]  private  Token  reusableToken  =  new  Token(  )  ;  [BUGGY]              [CLASS]  CSVParser  1    [VARIABLES]  	[P8_Replace_Mix]
[PATCH]  this  (  input,  CSVFormat.DEFAULT  )  ;	[BUG]  [BUGGY]  [FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  CSVParser(Reader  input)  throws  IOException  {  [BUGGY]  [BUGGY]      [CLASS]  CSVParser  1  [METHOD]  <init>  [RETURN_TYPE]  Reader)    Reader  input  [VARIABLES]  Lexer  lexer  boolean  Reader  input  List  record  Token  reusableToken  CSVRecord  current  Map  headerMapping    	[P14_Delete_Statement]
[PATCH]  format.validate  (  )  ;	[BUG]  [BUGGY]  format.getHeader(  )  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  CSVParser(Reader  input,  CSVFormat  format)  throws  IOException  {  [BUGGY]  format.getHeader(  )  ;  [BUGGY]    this.lexer  =  new  CSVLexer(format,  new  ExtendedBufferedReader(input));  this.headerMapping  =  initializeHeader(format);  }    [CLASS]  CSVParser  1  [METHOD]  <init>  [RETURN_TYPE]  CSVFormat)    Reader  input  CSVFormat  format  [VARIABLES]  Lexer  lexer  boolean  Reader  input  List  record  Token  reusableToken  CSVRecord  current  CSVFormat  format  Map  headerMapping    	[P8_Replace_Mix]
[PATCH]  format.validate  (  )  ;  this.lexer  =  new  CSVLexer  (  format,  new  ExtendedBufferedReader  (  input  )  )  ;  this.headerMapping  =  initializeHeader  (  format  )  ;  }	[BUG]  [BUGGY]  [CE]  variable  lexer  might  not  have  been  initialized  [CONTEXT]  public  CSVParser(Reader  input,  CSVFormat  format)  throws  IOException  {  [BUGGY]  [BUGGY]          [CLASS]  CSVParser  1  [METHOD]  <init>  [RETURN_TYPE]  CSVFormat)    Reader  input  CSVFormat  format  [VARIABLES]  Lexer  lexer  boolean  Reader  input  List  record  Token  reusableToken  CSVRecord  current  CSVFormat  format  Map  headerMapping    	[P14_Delete_Statement]
[PATCH]  this.lexer  =  new  CSVLexer  (  format,  new  ExtendedBufferedReader  (  input  )  )  ;	[BUG]  [BUGGY]  this.lexer  =  new  CSVLexer(  new  ExtendedBufferedReader(  input)  )  ;[CE]  constructor  CSVLexer  in  class  CSVLexer  cannot  be  applied  to  given  types;  [CONTEXT]  public  CSVParser(Reader  input,  CSVFormat  format)  throws  IOException  {  format.validate();  [BUGGY]  this.lexer  =  new  CSVLexer(  new  ExtendedBufferedReader(  input)  )  ;  [BUGGY]    this.headerMapping  =  initializeHeader(format);  }    [CLASS]  CSVParser  1  [METHOD]  <init>  [RETURN_TYPE]  CSVFormat)    Reader  input  CSVFormat  format  [VARIABLES]  Lexer  lexer  boolean  Reader  input  List  record  Token  reusableToken  CSVRecord  current  CSVFormat  format  Map  headerMapping    	[P4_Replace_Constructor]
[PATCH]  this.lexer  =  new  CSVLexer  (  format,  new  ExtendedBufferedReader  (  input  )  )  ;	[BUG]  [BUGGY]  this.lexer  =  new  CSVLexer(  input,  new  ExtendedBufferedReader(  format)  )  ;[CE]  constructor  ExtendedBufferedReader  in  class  ExtendedBufferedReader  cannot  be  applied  to  given  types;  [CONTEXT]  public  CSVParser(Reader  input,  CSVFormat  format)  throws  IOException  {  format.validate();  [BUGGY]  this.lexer  =  new  CSVLexer(  input,  new  ExtendedBufferedReader(  format)  )  ;  [BUGGY]    this.headerMapping  =  initializeHeader(format);  }    [CLASS]  CSVParser  1  [METHOD]  <init>  [RETURN_TYPE]  CSVFormat)    Reader  input  CSVFormat  format  [VARIABLES]  Lexer  lexer  boolean  Reader  input  List  record  Token  reusableToken  CSVRecord  current  CSVFormat  format  Map  headerMapping    	[P5_Replace_Variable]
[PATCH]  this.lexer  =  new  CSVLexer  (  format,  new  ExtendedBufferedReader  (  input  )  )  ;	[BUG]  [BUGGY]  this.lexer  =  new  CSVLexer(  null,  new  ExtendedBufferedReader(  input)  )  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  CSVParser(Reader  input,  CSVFormat  format)  throws  IOException  {  format.validate();  [BUGGY]  this.lexer  =  new  CSVLexer(  null,  new  ExtendedBufferedReader(  input)  )  ;  [BUGGY]    this.headerMapping  =  initializeHeader(format);  }    [CLASS]  CSVParser  1  [METHOD]  <init>  [RETURN_TYPE]  CSVFormat)    Reader  input  CSVFormat  format  [VARIABLES]  Lexer  lexer  boolean  Reader  input  List  record  Token  reusableToken  CSVRecord  current  CSVFormat  format  Map  headerMapping    	[P8_Replace_Mix]
[PATCH]  this.headerMapping  =  initializeHeader  (  format  )  ;	[BUG]  [BUGGY]  this.headerMapping  =  initializeHeader(  null)  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  CSVParser(Reader  input,  CSVFormat  format)  throws  IOException  {  format.validate();  this.lexer  =  new  CSVLexer(format,  new  ExtendedBufferedReader(input));  [BUGGY]  this.headerMapping  =  initializeHeader(  null)  ;  [BUGGY]  }    [CLASS]  CSVParser  1  [METHOD]  <init>  [RETURN_TYPE]  CSVFormat)    Reader  input  CSVFormat  format  [VARIABLES]  Lexer  lexer  boolean  Reader  input  List  record  Token  reusableToken  CSVRecord  current  CSVFormat  format  Map  headerMapping    	[P8_Replace_Mix]
[PATCH]  this.headerMapping  =  initializeHeader  (  format  )  ;  }	[BUG]  [BUGGY]  [CE]  illegal  start  of  expression  [CONTEXT]  public  CSVParser(Reader  input,  CSVFormat  format)  throws  IOException  {  format.validate();  this.lexer  =  new  CSVLexer(format,  new  ExtendedBufferedReader(input));  [BUGGY]  [BUGGY]      [CLASS]  CSVParser  1  [METHOD]  <init>  [RETURN_TYPE]  CSVFormat)    Reader  input  CSVFormat  format  [VARIABLES]  Lexer  lexer  boolean  Reader  input  List  record  Token  reusableToken  CSVRecord  current  CSVFormat  format  Map  headerMapping    	[P14_Delete_Statement]
[PATCH]  this  (  new  StringReader  (  input  )  ,  format  )  ;	[BUG]  [BUGGY]  this(  new  StringReader(  input)  )  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  CSVParser(String  input,  CSVFormat  format)  throws  IOException{  [BUGGY]  this(  new  StringReader(  input)  )  ;  [BUGGY]  }    [CLASS]  CSVParser  1  [METHOD]  <init>  [RETURN_TYPE]  CSVFormat)    String  input  CSVFormat  format  [VARIABLES]  Lexer  lexer  boolean  List  record  Token  reusableToken  CSVRecord  current  CSVFormat  format  String  input  Map  headerMapping    	[P4_Replace_Constructor]
[PATCH]  this  (  new  StringReader  (  input  )  ,  format  )  ;	[BUG]  [BUGGY]  this(  new  StringReader(  format)  ,  input)  ;[CE]  constructor  StringReader  in  class  StringReader  cannot  be  applied  to  given  types;  [CONTEXT]  public  CSVParser(String  input,  CSVFormat  format)  throws  IOException{  [BUGGY]  this(  new  StringReader(  format)  ,  input)  ;  [BUGGY]  }    [CLASS]  CSVParser  1  [METHOD]  <init>  [RETURN_TYPE]  CSVFormat)    String  input  CSVFormat  format  [VARIABLES]  Lexer  lexer  boolean  List  record  Token  reusableToken  CSVRecord  current  CSVFormat  format  String  input  Map  headerMapping    	[P5_Replace_Variable]
[PATCH]  this  (  new  StringReader  (  input  )  ,  format  )  ;  }	[BUG]  [BUGGY]  [CE]  illegal  start  of  expression  [CONTEXT]  public  CSVParser(String  input,  CSVFormat  format)  throws  IOException{  [BUGGY]  [BUGGY]      [CLASS]  CSVParser  1  [METHOD]  <init>  [RETURN_TYPE]  CSVFormat)    String  input  CSVFormat  format  [VARIABLES]  Lexer  lexer  boolean  List  record  Token  reusableToken  CSVRecord  current  CSVFormat  format  String  input  Map  headerMapping    	[P14_Delete_Statement]
[PATCH]  List<CSVRecord>  records  =  new  ArrayList<CSVRecord>  (  )  ;	[BUG]  [BUGGY]  List<CSVRecord>  records  =  new  LinkedList  <CSVRecord>(  )  ;[CE]  cannot  find  symbol  [CONTEXT]  public  List<CSVRecord>  getRecords()  throws  IOException  {  [BUGGY]  List<CSVRecord>  records  =  new  LinkedList  <CSVRecord>(  )  ;  [BUGGY]  CSVRecord  rec;  while  ((rec  =  getRecord())  !=  null)  {  records.add(rec);  }  return  records;  }    [CLASS]  CSVParser  1  [METHOD]  getRecords  [RETURN_TYPE]  List    [VARIABLES]  Lexer  lexer  List  record  records  Token  reusableToken  CSVRecord  current  rec  boolean  Map  headerMapping    	[P1_Replace_Type]
[PATCH]  List<CSVRecord>  records  =  new  ArrayList<CSVRecord>  (  )  ;	[BUG]  [BUGGY]  CSVRecord  rec  =  getRecord(  )  ;List<CSVRecord>  records  =  new  ArrayList<CSVRecord>(  )  ;[CE]  variable  rec  is  already  defined  in  method  getRecords()  [CONTEXT]  public  List<CSVRecord>  getRecords()  throws  IOException  {  [BUGGY]  CSVRecord  rec  =  getRecord(  )  ;List<CSVRecord>  records  =  new  ArrayList<CSVRecord>(  )  ;  [BUGGY]  CSVRecord  rec;  while  ((rec  =  getRecord())  !=  null)  {  records.add(rec);  }  return  records;  }    [CLASS]  CSVParser  1  [METHOD]  getRecords  [RETURN_TYPE]  List    [VARIABLES]  Lexer  lexer  List  record  records  Token  reusableToken  CSVRecord  current  rec  boolean  Map  headerMapping    	[P11_Insert_Donor_Statement]
[PATCH]  CSVRecord  rec;	[BUG]  [BUGGY]  CSVRecord  next  =  current;CSVRecord  rec;[CE]  cannot  find  symbol  current  [CONTEXT]  public  List<CSVRecord>  getRecords()  throws  IOException  {  List<CSVRecord>  records  =  new  ArrayList<CSVRecord>();  [BUGGY]  CSVRecord  next  =  current;CSVRecord  rec;  [BUGGY]  while  ((rec  =  getRecord())  !=  null)  {  records.add(rec);  }  return  records;  }    [CLASS]  CSVParser  1  [METHOD]  getRecords  [RETURN_TYPE]  List    [VARIABLES]  Lexer  lexer  List  record  records  Token  reusableToken  CSVRecord  current  rec  boolean  Map  headerMapping    	[P11_Insert_Donor_Statement]
[PATCH]  while  (  (  rec  =  getRecord  (  )  )  !=  null  )  {	[BUG]  [BUGGY]  while  (  (  rec  =  getRecord(  )  )  ==  null)  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  List<CSVRecord>  getRecords()  throws  IOException  {  List<CSVRecord>  records  =  new  ArrayList<CSVRecord>();  CSVRecord  rec;  [BUGGY]  while  (  (  rec  =  getRecord(  )  )  ==  null)  {  [BUGGY]  records.add(rec);  }  return  records;  }    [CLASS]  CSVParser  1  [METHOD]  getRecords  [RETURN_TYPE]  List    [VARIABLES]  Lexer  lexer  List  record  records  Token  reusableToken  CSVRecord  current  rec  boolean  Map  headerMapping    	[P2_Replace_Operator]
[PATCH]  while  (  (  rec  =  getRecord  (  )  )  !=  null  )  {	[BUG]  [BUGGY]  while  (  (  current  =  getRecord(  )  )  !=  null)  {[CE]  cannot  find  symbol  current  [CONTEXT]  public  List<CSVRecord>  getRecords()  throws  IOException  {  List<CSVRecord>  records  =  new  ArrayList<CSVRecord>();  CSVRecord  rec;  [BUGGY]  while  (  (  current  =  getRecord(  )  )  !=  null)  {  [BUGGY]  records.add(rec);  }  return  records;  }    [CLASS]  CSVParser  1  [METHOD]  getRecords  [RETURN_TYPE]  List    [VARIABLES]  Lexer  lexer  List  record  records  Token  reusableToken  CSVRecord  current  rec  boolean  Map  headerMapping    	[P5_Replace_Variable]
[PATCH]  while  (  (  rec  =  getRecord  (  )  )  !=  null  )  {	[BUG]  [BUGGY]  while  (  (  rec  =  toString(  )  )  !=  null)  {[CE]  incompatible  types  [CONTEXT]  public  List<CSVRecord>  getRecords()  throws  IOException  {  List<CSVRecord>  records  =  new  ArrayList<CSVRecord>();  CSVRecord  rec;  [BUGGY]  while  (  (  rec  =  toString(  )  )  !=  null)  {  [BUGGY]  records.add(rec);  }  return  records;  }    [CLASS]  CSVParser  1  [METHOD]  getRecords  [RETURN_TYPE]  List    [VARIABLES]  Lexer  lexer  List  record  records  Token  reusableToken  CSVRecord  current  rec  boolean  Map  headerMapping    	[P7_Replace_Invocation]
[PATCH]  records.add  (  rec  )  ;	[BUG]  [BUGGY]  records.add(  current)  ;[CE]  cannot  find  symbol  current  [CONTEXT]  public  List<CSVRecord>  getRecords()  throws  IOException  {  List<CSVRecord>  records  =  new  ArrayList<CSVRecord>();  CSVRecord  rec;  while  ((rec  =  getRecord())  !=  null)  {  [BUGGY]  records.add(  current)  ;  [BUGGY]  }  return  records;  }    [CLASS]  CSVParser  1  [METHOD]  getRecords  [RETURN_TYPE]  List    [VARIABLES]  Lexer  lexer  List  record  records  Token  reusableToken  CSVRecord  current  rec  boolean  Map  headerMapping    	[P5_Replace_Variable]
[PATCH]  records.add  (  rec  )  ;	[BUG]  [BUGGY]  records.add(  rec)  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  List<CSVRecord>  getRecords()  throws  IOException  {  List<CSVRecord>  records  =  new  ArrayList<CSVRecord>();  CSVRecord  rec;  while  ((rec  =  getRecord())  !=  null)  {  [BUGGY]  records.add(  rec)  ;  [BUGGY]  }  return  records;  }    [CLASS]  CSVParser  1  [METHOD]  getRecords  [RETURN_TYPE]  List    [VARIABLES]  Lexer  lexer  List  record  records  Token  reusableToken  CSVRecord  current  rec  boolean  Map  headerMapping    	[P7_Replace_Invocation]
[PATCH]  records.add  (  rec  )  ;	[BUG]  [BUGGY]  [FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  List<CSVRecord>  getRecords()  throws  IOException  {  List<CSVRecord>  records  =  new  ArrayList<CSVRecord>();  CSVRecord  rec;  while  ((rec  =  getRecord())  !=  null)  {  [BUGGY]  [BUGGY]    }  return  records;    [CLASS]  CSVParser  1  [METHOD]  getRecords  [RETURN_TYPE]  List    [VARIABLES]  Lexer  lexer  List  record  records  Token  reusableToken  CSVRecord  current  rec  boolean  Map  headerMapping    	[P14_Delete_Statement]
[PATCH]  records.add  (  rec  )  ;	[BUG]  [BUGGY]  record.clear(  )  ;records.add(  rec)  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  List<CSVRecord>  getRecords()  throws  IOException  {  List<CSVRecord>  records  =  new  ArrayList<CSVRecord>();  CSVRecord  rec;  while  ((rec  =  getRecord())  !=  null)  {  [BUGGY]  record.clear(  )  ;records.add(  rec)  ;  [BUGGY]  }  return  records;  }    [CLASS]  CSVParser  1  [METHOD]  getRecords  [RETURN_TYPE]  List    [VARIABLES]  Lexer  lexer  List  record  records  Token  reusableToken  CSVRecord  current  rec  boolean  Map  headerMapping    	[P11_Insert_Donor_Statement]
[PATCH]  while  (  (  rec  =  getRecord  (  )  )  !=  null  )  {	[BUG]  [BUGGY]  while  (  (  rec  ;[CE]  ')'  expected  [CONTEXT]  public  List<CSVRecord>  getRecords()  throws  IOException  {  List<CSVRecord>  records  =  new  ArrayList<CSVRecord>();  CSVRecord  rec;  [BUGGY]  while  (  (  rec  ;  [BUGGY]  records.add(rec);  }  return  records;  }    [CLASS]  CSVParser  1  [METHOD]  getRecords  [RETURN_TYPE]  List    [VARIABLES]  Lexer  lexer  List  record  records  Token  reusableToken  CSVRecord  current  rec  boolean  Map  headerMapping    	[P8_Replace_Mix]
[PATCH]  while  (  (  rec  =  getRecord  (  )  )  !=  null  )  {  records.add  (  rec  )  ;	[BUG]  [BUGGY]  [FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  List<CSVRecord>  getRecords()  throws  IOException  {  List<CSVRecord>  records  =  new  ArrayList<CSVRecord>();  CSVRecord  rec;  [BUGGY]  [BUGGY]    }  return  records;    [CLASS]  CSVParser  1  [METHOD]  getRecords  [RETURN_TYPE]  List    [VARIABLES]  Lexer  lexer  List  record  records  Token  reusableToken  CSVRecord  current  rec  boolean  Map  headerMapping    	[P14_Delete_Statement]
[PATCH]  CSVRecord  result  =  new  CSVRecord  (  null,  headerMapping  )  ;	[BUG]  [BUGGY]  CSVRecord  result  =  new  CSVRecord(  null,  this)  ;[CE]  constructor  CSVRecord  in  class  CSVRecord  cannot  be  applied  to  given  types;  [CONTEXT]  CSVRecord  getRecord()  throws  IOException  {  [BUGGY]  CSVRecord  result  =  new  CSVRecord(  null,  this)  ;  [BUGGY]  record.clear();  do  {  reusableToken.reset();  lexer.nextToken(reusableToken);  switch  (reusableToken.type)  {  case  TOKEN:  record.add(reusableToken.content.toString());  break;  case  EORECORD:  record.add(reusableToken.content.toString());  break;  case  EOF:  if  (reusableToken.isReady)  {  record.add(reusableToken.content.toString());  }  else  {  result  =  null;  }  break;  case  INVALID:  throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  parse  sequence ");  }  }  while  (reusableToken.type  ==  TOKEN);  if  (!record.isEmpty())  {  result  =  new  CSVRecord(record.toArray(new  String[record.size()]),  headerMapping);  }  return  result;  }    [CLASS]  CSVParser  1  [METHOD]  getRecord  [RETURN_TYPE]  CSVRecord    [VARIABLES]  Lexer  lexer  List  record  records  Token  reusableToken  CSVRecord  current  rec  result  boolean  Map  headerMapping    	[P8_Replace_Mix]
[PATCH]  record.clear  (  )  ;	[BUG]  [BUGGY]  record.size(  )  ;[FE]  [CONTEXT]  CSVRecord  getRecord()  throws  IOException  {  CSVRecord  result  =  new  CSVRecord(null,  headerMapping);  [BUGGY]  record.size(  )  ;  [BUGGY]  do  {  reusableToken.reset();  lexer.nextToken(reusableToken);  switch  (reusableToken.type)  {  case  TOKEN:  record.add(reusableToken.content.toString());  break;  case  EORECORD:  record.add(reusableToken.content.toString());  break;  case  EOF:  if  (reusableToken.isReady)  {  record.add(reusableToken.content.toString());  }  else  {  result  =  null;  }  break;  case  INVALID:  throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  parse  sequence ");  }  }  while  (reusableToken.type  ==  TOKEN);  if  (!record.isEmpty())  {  result  =  new  CSVRecord(record.toArray(new  String[record.size()]),  headerMapping);  }  return  result;  }    [CLASS]  CSVParser  1  [METHOD]  getRecord  [RETURN_TYPE]  CSVRecord    [VARIABLES]  Lexer  lexer  List  record  records  Token  reusableToken  CSVRecord  current  rec  result  boolean  Map  headerMapping    	[P7_Replace_Invocation]
[PATCH]  record.clear  (  )  ;	[BUG]  [BUGGY]  [FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  CSVRecord  getRecord()  throws  IOException  {  CSVRecord  result  =  new  CSVRecord(null,  headerMapping);  [BUGGY]  [BUGGY]    do  {  reusableToken.reset();  lexer.nextToken(reusableToken);  switch  (reusableToken.type)  {  case  TOKEN:  record.add(reusableToken.content.toString());  break;  case  EORECORD:  record.add(reusableToken.content.toString());  break;  case  EOF:  if  (reusableToken.isReady)  {  record.add(reusableToken.content.toString());  }  else  {  result  =  null;  }  break;  case  INVALID:  throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  parse  sequence ");  }  }  while  (reusableToken.type  ==  TOKEN);  if  (!record.isEmpty())  {  result  =  new  CSVRecord(record.toArray(new  String[record.size()]),  headerMapping);  }  return  result;    [CLASS]  CSVParser  1  [METHOD]  getRecord  [RETURN_TYPE]  CSVRecord    [VARIABLES]  Lexer  lexer  List  record  records  Token  reusableToken  CSVRecord  current  rec  result  boolean  Map  headerMapping    	[P14_Delete_Statement]
[PATCH]  record.clear  (  )  ;	[BUG]  [BUGGY]  records.add(  rec)  ;record.clear(  )  ;[CE]  cannot  find  symbol  rec  [CONTEXT]  CSVRecord  getRecord()  throws  IOException  {  CSVRecord  result  =  new  CSVRecord(null,  headerMapping);  [BUGGY]  records.add(  rec)  ;record.clear(  )  ;  [BUGGY]  do  {  reusableToken.reset();  lexer.nextToken(reusableToken);  switch  (reusableToken.type)  {  case  TOKEN:  record.add(reusableToken.content.toString());  break;  case  EORECORD:  record.add(reusableToken.content.toString());  break;  case  EOF:  if  (reusableToken.isReady)  {  record.add(reusableToken.content.toString());  }  else  {  result  =  null;  }  break;  case  INVALID:  throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  parse  sequence ");  }  }  while  (reusableToken.type  ==  TOKEN);  if  (!record.isEmpty())  {  result  =  new  CSVRecord(record.toArray(new  String[record.size()]),  headerMapping);  }  return  result;  }    [CLASS]  CSVParser  1  [METHOD]  getRecord  [RETURN_TYPE]  CSVRecord    [VARIABLES]  Lexer  lexer  List  record  records  Token  reusableToken  CSVRecord  current  rec  result  boolean  Map  headerMapping    	[P11_Insert_Donor_Statement]
[PATCH]  record.clear  (  )  ;	[BUG]  [BUGGY]  return  getRecord(  )  ;record.clear(  )  ;[CE]  unreachable  statement  [CONTEXT]  CSVRecord  getRecord()  throws  IOException  {  CSVRecord  result  =  new  CSVRecord(null,  headerMapping);  [BUGGY]  return  getRecord(  )  ;record.clear(  )  ;  [BUGGY]  do  {  reusableToken.reset();  lexer.nextToken(reusableToken);  switch  (reusableToken.type)  {  case  TOKEN:  record.add(reusableToken.content.toString());  break;  case  EORECORD:  record.add(reusableToken.content.toString());  break;  case  EOF:  if  (reusableToken.isReady)  {  record.add(reusableToken.content.toString());  }  else  {  result  =  null;  }  break;  case  INVALID:  throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  parse  sequence ");  }  }  while  (reusableToken.type  ==  TOKEN);  if  (!record.isEmpty())  {  result  =  new  CSVRecord(record.toArray(new  String[record.size()]),  headerMapping);  }  return  result;  }    [CLASS]  CSVParser  1  [METHOD]  getRecord  [RETURN_TYPE]  CSVRecord    [VARIABLES]  Lexer  lexer  List  record  records  Token  reusableToken  CSVRecord  current  rec  result  boolean  Map  headerMapping    	[P11_Insert_Donor_Statement]
[PATCH]  if  (  reusableToken.isReady  )  {  record.add  (  reusableToken.content.toString  (  )  )  ;  }  else  {  result  =  null;  }	[BUG]  [BUGGY]  record.add(reusableToken.content.toString());[CE]  orphaned  case  [CONTEXT]  CSVRecord  getRecord()  throws  IOException  {  CSVRecord  result  =  new  CSVRecord(null,  headerMapping);  record.clear();  do  {  reusableToken.reset();  lexer.nextToken(reusableToken);  switch  (reusableToken.type)  {  case  TOKEN:  record.add(reusableToken.content.toString());  break;  case  EORECORD:  record.add(reusableToken.content.toString());  break;  case  EOF:  [BUGGY]  record.add(reusableToken.content.toString());  [BUGGY]    record.add(reusableToken.content.toString());    break;  case  INVALID:  throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  parse  sequence ");  }  }  while  (reusableToken.type  ==  TOKEN);  if  (!record.isEmpty())  {  result  =  new  CSVRecord(record.toArray(new  String[record.size()]),  headerMapping);  }  return  result;    [CLASS]  CSVParser  1  [METHOD]  getRecord  [RETURN_TYPE]  CSVRecord    [VARIABLES]  Lexer  lexer  List  record  records  Token  reusableToken  CSVRecord  current  rec  result  boolean  Map  headerMapping    	[P15_Unwrap_Block]
[PATCH]  if  (  reusableToken.isReady  )  {  record.add  (  reusableToken.content.toString  (  )  )  ;  }  else  {  result  =  null;  }	[BUG]  [BUGGY]  [CE]  orphaned  case  [CONTEXT]  CSVRecord  getRecord()  throws  IOException  {  CSVRecord  result  =  new  CSVRecord(null,  headerMapping);  record.clear();  do  {  reusableToken.reset();  lexer.nextToken(reusableToken);  switch  (reusableToken.type)  {  case  TOKEN:  record.add(reusableToken.content.toString());  break;  case  EORECORD:  record.add(reusableToken.content.toString());  break;  case  EOF:  [BUGGY]  [BUGGY]        break;  case  INVALID:  throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  parse  sequence ");  }  }  while  (reusableToken.type  ==  TOKEN);  if  (!record.isEmpty())  {  result  =  new  CSVRecord(record.toArray(new  String[record.size()]),  headerMapping);  }  return  result;    [CLASS]  CSVParser  1  [METHOD]  getRecord  [RETURN_TYPE]  CSVRecord    [VARIABLES]  Lexer  lexer  List  record  records  Token  reusableToken  CSVRecord  current  rec  result  boolean  Map  headerMapping    	[P16_Remove_Block]
[PATCH]  result  =  null;	[BUG]  [BUGGY]  result  =  this;[CE]  incompatible  types  [CONTEXT]  if  (reusableToken.isReady)  {  record.add(reusableToken.content.toString());  }  else  {  [BUGGY]  result  =  this;  [BUGGY]  }    [CLASS]  CSVParser  1  [METHOD]  getRecord  [RETURN_TYPE]  CSVRecord    [VARIABLES]  Lexer  lexer  List  record  records  Token  reusableToken  CSVRecord  current  rec  result  boolean  Map  headerMapping    	[P8_Replace_Mix]
[PATCH]  result  =  null;	[BUG]  [BUGGY]  current  =  null;result  =  null;[CE]  cannot  find  symbol  current  [CONTEXT]  if  (reusableToken.isReady)  {  record.add(reusableToken.content.toString());  }  else  {  [BUGGY]  current  =  null;result  =  null;  [BUGGY]  }    [CLASS]  CSVParser  1  [METHOD]  getRecord  [RETURN_TYPE]  CSVRecord    [VARIABLES]  Lexer  lexer  List  record  records  Token  reusableToken  CSVRecord  current  rec  result  boolean  Map  headerMapping    	[P11_Insert_Donor_Statement]
[PATCH]  record.add  (  reusableToken.content.toString  (  )  )  ;	[BUG]  [BUGGY]  record.size(  reusableToken.content.toString(  )  )  ;[CE]  no  suitable  method  found  for  size(String)  [CONTEXT]  CSVRecord  getRecord()  throws  IOException  {  CSVRecord  result  =  new  CSVRecord(null,  headerMapping);  record.clear();  do  {  reusableToken.reset();  lexer.nextToken(reusableToken);  switch  (reusableToken.type)  {  case  TOKEN:  record.add(reusableToken.content.toString());  break;  case  EORECORD:  record.add(reusableToken.content.toString());  break;  case  EOF:  if  (reusableToken.isReady)  {  [BUGGY]  record.size(  reusableToken.content.toString(  )  )  ;  [BUGGY]  }  else  {  result  =  null;  }  break;  case  INVALID:  throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  parse  sequence ");  }  }  while  (reusableToken.type  ==  TOKEN);  if  (!record.isEmpty())  {  result  =  new  CSVRecord(record.toArray(new  String[record.size()]),  headerMapping);  }  return  result;  }    [CLASS]  CSVParser  1  [METHOD]  getRecord  [RETURN_TYPE]  CSVRecord    [VARIABLES]  Lexer  lexer  List  record  records  Token  reusableToken  CSVRecord  current  rec  result  boolean  Map  headerMapping    	[P7_Replace_Invocation]
[PATCH]  record.add  (  reusableToken.content.toString  (  )  )  ;	[BUG]  [BUGGY]  record.add(  reusableToken.content.getRecord(  )  )  ;[CE]  cannot  find  symbol  [CONTEXT]  CSVRecord  getRecord()  throws  IOException  {  CSVRecord  result  =  new  CSVRecord(null,  headerMapping);  record.clear();  do  {  reusableToken.reset();  lexer.nextToken(reusableToken);  switch  (reusableToken.type)  {  case  TOKEN:  record.add(reusableToken.content.toString());  break;  case  EORECORD:  record.add(reusableToken.content.toString());  break;  case  EOF:  if  (reusableToken.isReady)  {  [BUGGY]  record.add(  reusableToken.content.getRecord(  )  )  ;  [BUGGY]  }  else  {  result  =  null;  }  break;  case  INVALID:  throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  parse  sequence ");  }  }  while  (reusableToken.type  ==  TOKEN);  if  (!record.isEmpty())  {  result  =  new  CSVRecord(record.toArray(new  String[record.size()]),  headerMapping);  }  return  result;  }    [CLASS]  CSVParser  1  [METHOD]  getRecord  [RETURN_TYPE]  CSVRecord    [VARIABLES]  Lexer  lexer  List  record  records  Token  reusableToken  CSVRecord  current  rec  result  boolean  Map  headerMapping    	[P7_Replace_Invocation]
[PATCH]  record.add  (  reusableToken.content.toString  (  )  )  ;	[BUG]  [BUGGY]  record.add(  reusableToken.content.getLineNumber(  )  )  ;[CE]  cannot  find  symbol  [CONTEXT]  CSVRecord  getRecord()  throws  IOException  {  CSVRecord  result  =  new  CSVRecord(null,  headerMapping);  record.clear();  do  {  reusableToken.reset();  lexer.nextToken(reusableToken);  switch  (reusableToken.type)  {  case  TOKEN:  record.add(reusableToken.content.toString());  break;  case  EORECORD:  record.add(reusableToken.content.toString());  break;  case  EOF:  if  (reusableToken.isReady)  {  [BUGGY]  record.add(  reusableToken.content.getLineNumber(  )  )  ;  [BUGGY]  }  else  {  result  =  null;  }  break;  case  INVALID:  throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  parse  sequence ");  }  }  while  (reusableToken.type  ==  TOKEN);  if  (!record.isEmpty())  {  result  =  new  CSVRecord(record.toArray(new  String[record.size()]),  headerMapping);  }  return  result;  }    [CLASS]  CSVParser  1  [METHOD]  getRecord  [RETURN_TYPE]  CSVRecord    [VARIABLES]  Lexer  lexer  List  record  records  Token  reusableToken  CSVRecord  current  rec  result  boolean  Map  headerMapping    	[P7_Replace_Invocation]
[PATCH]  record.add  (  reusableToken.content.toString  (  )  )  ;	[BUG]  [BUGGY]  [FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  CSVRecord  getRecord()  throws  IOException  {  CSVRecord  result  =  new  CSVRecord(null,  headerMapping);  record.clear();  do  {  reusableToken.reset();  lexer.nextToken(reusableToken);  switch  (reusableToken.type)  {  case  TOKEN:  record.add(reusableToken.content.toString());  break;  case  EORECORD:  record.add(reusableToken.content.toString());  break;  case  EOF:  if  (reusableToken.isReady)  {  [BUGGY]  [BUGGY]    }  else  {  result  =  null;  }  break;  case  INVALID:  throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  parse  sequence ");  }  }  while  (reusableToken.type  ==  TOKEN);  if  (!record.isEmpty())  {  result  =  new  CSVRecord(record.toArray(new  String[record.size()]),  headerMapping);  }  return  result;    [CLASS]  CSVParser  1  [METHOD]  getRecord  [RETURN_TYPE]  CSVRecord    [VARIABLES]  Lexer  lexer  List  record  records  Token  reusableToken  CSVRecord  current  rec  result  boolean  Map  headerMapping    	[P14_Delete_Statement]
[PATCH]  result  =  null;	[BUG]  [BUGGY]  result  =  false;[CE]  incompatible  types  [CONTEXT]  CSVRecord  getRecord()  throws  IOException  {  CSVRecord  result  =  new  CSVRecord(null,  headerMapping);  record.clear();  do  {  reusableToken.reset();  lexer.nextToken(reusableToken);  switch  (reusableToken.type)  {  case  TOKEN:  record.add(reusableToken.content.toString());  break;  case  EORECORD:  record.add(reusableToken.content.toString());  break;  case  EOF:  if  (reusableToken.isReady)  {  record.add(reusableToken.content.toString());  }  else  {  [BUGGY]  result  =  false;  [BUGGY]  }  break;  case  INVALID:  throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  parse  sequence ");  }  }  while  (reusableToken.type  ==  TOKEN);  if  (!record.isEmpty())  {  result  =  new  CSVRecord(record.toArray(new  String[record.size()]),  headerMapping);  }  return  result;  }    [CLASS]  CSVParser  1  [METHOD]  getRecord  [RETURN_TYPE]  CSVRecord    [VARIABLES]  Lexer  lexer  List  record  records  Token  reusableToken  CSVRecord  current  rec  result  boolean  Map  headerMapping    	[P8_Replace_Mix]
[PATCH]  result  =  null;	[BUG]  [BUGGY]  current  =  null;result  =  null;[CE]  cannot  find  symbol  current  [CONTEXT]  CSVRecord  getRecord()  throws  IOException  {  CSVRecord  result  =  new  CSVRecord(null,  headerMapping);  record.clear();  do  {  reusableToken.reset();  lexer.nextToken(reusableToken);  switch  (reusableToken.type)  {  case  TOKEN:  record.add(reusableToken.content.toString());  break;  case  EORECORD:  record.add(reusableToken.content.toString());  break;  case  EOF:  if  (reusableToken.isReady)  {  record.add(reusableToken.content.toString());  }  else  {  [BUGGY]  current  =  null;result  =  null;  [BUGGY]  }  break;  case  INVALID:  throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  parse  sequence ");  }  }  while  (reusableToken.type  ==  TOKEN);  if  (!record.isEmpty())  {  result  =  new  CSVRecord(record.toArray(new  String[record.size()]),  headerMapping);  }  return  result;  }    [CLASS]  CSVParser  1  [METHOD]  getRecord  [RETURN_TYPE]  CSVRecord    [VARIABLES]  Lexer  lexer  List  record  records  Token  reusableToken  CSVRecord  current  rec  result  boolean  Map  headerMapping    	[P11_Insert_Donor_Statement]
[PATCH]  throw  new  IOException  ( "   ")  ;	[BUG]  [BUGGY]  throw  new  UnsupportedOperationException  ( "   ")  ;  ;[CE]  unreachable  statement  [CONTEXT]  CSVRecord  getRecord()  throws  IOException  {  CSVRecord  result  =  new  CSVRecord(null,  headerMapping);  record.clear();  do  {  reusableToken.reset();  lexer.nextToken(reusableToken);  switch  (reusableToken.type)  {  case  TOKEN:  record.add(reusableToken.content.toString());  break;  case  EORECORD:  record.add(reusableToken.content.toString());  break;  case  EOF:  if  (reusableToken.isReady)  {  record.add(reusableToken.content.toString());  }  else  {  result  =  null;  }  break;  case  INVALID:  [BUGGY]  throw  new  UnsupportedOperationException  ( "   ")  ;  ;  [BUGGY]  }  }  while  (reusableToken.type  ==  TOKEN);  if  (!record.isEmpty())  {  result  =  new  CSVRecord(record.toArray(new  String[record.size()]),  headerMapping);  }  return  result;  }    [CLASS]  CSVParser  1  [METHOD]  getRecord  [RETURN_TYPE]  CSVRecord    [VARIABLES]  Lexer  lexer  List  record  records  Token  reusableToken  CSVRecord  current  rec  result  boolean  Map  headerMapping    	[P8_Replace_Mix]
[PATCH]  throw  new  IOException  ( "   ")  ;	[BUG]  [BUGGY]  throw  new  UnsupportedOperationException  ( "   ")  ;throw  new  IOException  ( "   ")  ;[CE]  unreachable  statement  [CONTEXT]  CSVRecord  getRecord()  throws  IOException  {  CSVRecord  result  =  new  CSVRecord(null,  headerMapping);  record.clear();  do  {  reusableToken.reset();  lexer.nextToken(reusableToken);  switch  (reusableToken.type)  {  case  TOKEN:  record.add(reusableToken.content.toString());  break;  case  EORECORD:  record.add(reusableToken.content.toString());  break;  case  EOF:  if  (reusableToken.isReady)  {  record.add(reusableToken.content.toString());  }  else  {  result  =  null;  }  break;  case  INVALID:  [BUGGY]  throw  new  UnsupportedOperationException  ( "   ")  ;throw  new  IOException  ( "   ")  ;  [BUGGY]  }  }  while  (reusableToken.type  ==  TOKEN);  if  (!record.isEmpty())  {  result  =  new  CSVRecord(record.toArray(new  String[record.size()]),  headerMapping);  }  return  result;  }    [CLASS]  CSVParser  1  [METHOD]  getRecord  [RETURN_TYPE]  CSVRecord    [VARIABLES]  Lexer  lexer  List  record  records  Token  reusableToken  CSVRecord  current  rec  result  boolean  Map  headerMapping    	[P11_Insert_Donor_Statement]
[PATCH]  throw  new  IOException  ( "   ")  ;	[BUG]  [BUGGY]  throw  new  RuntimeException  ( "   ")  ;throw  new  IOException  ( "   ")  ;[CE]  unreachable  statement  [CONTEXT]  CSVRecord  getRecord()  throws  IOException  {  CSVRecord  result  =  new  CSVRecord(null,  headerMapping);  record.clear();  do  {  reusableToken.reset();  lexer.nextToken(reusableToken);  switch  (reusableToken.type)  {  case  TOKEN:  record.add(reusableToken.content.toString());  break;  case  EORECORD:  record.add(reusableToken.content.toString());  break;  case  EOF:  if  (reusableToken.isReady)  {  record.add(reusableToken.content.toString());  }  else  {  result  =  null;  }  break;  case  INVALID:  [BUGGY]  throw  new  RuntimeException  ( "   ")  ;throw  new  IOException  ( "   ")  ;  [BUGGY]  }  }  while  (reusableToken.type  ==  TOKEN);  if  (!record.isEmpty())  {  result  =  new  CSVRecord(record.toArray(new  String[record.size()]),  headerMapping);  }  return  result;  }    [CLASS]  CSVParser  1  [METHOD]  getRecord  [RETURN_TYPE]  CSVRecord    [VARIABLES]  Lexer  lexer  List  record  records  Token  reusableToken  CSVRecord  current  rec  result  boolean  Map  headerMapping    	[P11_Insert_Donor_Statement]
[PATCH]  throw  new  IOException  ( "   ")  ;	[BUG]  [BUGGY]  throw  new  NoSuchElementException  ( "   ")  ;throw  new  IOException  ( "   ")  ;[CE]  unreachable  statement  [CONTEXT]  CSVRecord  getRecord()  throws  IOException  {  CSVRecord  result  =  new  CSVRecord(null,  headerMapping);  record.clear();  do  {  reusableToken.reset();  lexer.nextToken(reusableToken);  switch  (reusableToken.type)  {  case  TOKEN:  record.add(reusableToken.content.toString());  break;  case  EORECORD:  record.add(reusableToken.content.toString());  break;  case  EOF:  if  (reusableToken.isReady)  {  record.add(reusableToken.content.toString());  }  else  {  result  =  null;  }  break;  case  INVALID:  [BUGGY]  throw  new  NoSuchElementException  ( "   ")  ;throw  new  IOException  ( "   ")  ;  [BUGGY]  }  }  while  (reusableToken.type  ==  TOKEN);  if  (!record.isEmpty())  {  result  =  new  CSVRecord(record.toArray(new  String[record.size()]),  headerMapping);  }  return  result;  }    [CLASS]  CSVParser  1  [METHOD]  getRecord  [RETURN_TYPE]  CSVRecord    [VARIABLES]  Lexer  lexer  List  record  records  Token  reusableToken  CSVRecord  current  rec  result  boolean  Map  headerMapping    	[P11_Insert_Donor_Statement]
[PATCH]  reusableToken.reset  (  )  ;	[BUG]  [BUGGY]  reusableToken.Token(  )  ;[CE]  cannot  find  symbol  [CONTEXT]  CSVRecord  getRecord()  throws  IOException  {  CSVRecord  result  =  new  CSVRecord(null,  headerMapping);  record.clear();  do  {  [BUGGY]  reusableToken.Token(  )  ;  [BUGGY]  lexer.nextToken(reusableToken);  switch  (reusableToken.type)  {  case  TOKEN:  record.add(reusableToken.content.toString());  break;  case  EORECORD:  record.add(reusableToken.content.toString());  break;  case  EOF:  if  (reusableToken.isReady)  {  record.add(reusableToken.content.toString());  }  else  {  result  =  null;  }  break;  case  INVALID:  throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  parse  sequence ");  }  }  while  (reusableToken.type  ==  TOKEN);  if  (!record.isEmpty())  {  result  =  new  CSVRecord(record.toArray(new  String[record.size()]),  headerMapping);  }  return  result;  }    [CLASS]  CSVParser  1  [METHOD]  getRecord  [RETURN_TYPE]  CSVRecord    [VARIABLES]  Lexer  lexer  List  record  records  Token  reusableToken  CSVRecord  current  rec  result  boolean  Map  headerMapping    	[P7_Replace_Invocation]
[PATCH]  reusableToken.reset  (  )  ;	[BUG]  [BUGGY]  [FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  CSVRecord  getRecord()  throws  IOException  {  CSVRecord  result  =  new  CSVRecord(null,  headerMapping);  record.clear();  do  {  [BUGGY]  [BUGGY]    lexer.nextToken(reusableToken);  switch  (reusableToken.type)  {  case  TOKEN:  record.add(reusableToken.content.toString());  break;  case  EORECORD:  record.add(reusableToken.content.toString());  break;  case  EOF:  if  (reusableToken.isReady)  {  record.add(reusableToken.content.toString());  }  else  {  result  =  null;  }  break;  case  INVALID:  throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  parse  sequence ");  }  }  while  (reusableToken.type  ==  TOKEN);  if  (!record.isEmpty())  {  result  =  new  CSVRecord(record.toArray(new  String[record.size()]),  headerMapping);  }  return  result;    [CLASS]  CSVParser  1  [METHOD]  getRecord  [RETURN_TYPE]  CSVRecord    [VARIABLES]  Lexer  lexer  List  record  records  Token  reusableToken  CSVRecord  current  rec  result  boolean  Map  headerMapping    	[P14_Delete_Statement]
[PATCH]  reusableToken.reset  (  )  ;	[BUG]  [BUGGY]  if  (  reusableToken.isReady)  {  reusableToken.reset(  )  ;  }[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  CSVRecord  getRecord()  throws  IOException  {  CSVRecord  result  =  new  CSVRecord(null,  headerMapping);  record.clear();  do  {  [BUGGY]  if  (  reusableToken.isReady)  {  reusableToken.reset(  )  ;  }  [BUGGY]  lexer.nextToken(reusableToken);  switch  (reusableToken.type)  {  case  TOKEN:  record.add(reusableToken.content.toString());  break;  case  EORECORD:  record.add(reusableToken.content.toString());  break;  case  EOF:  if  (reusableToken.isReady)  {  record.add(reusableToken.content.toString());  }  else  {  result  =  null;  }  break;  case  INVALID:  throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  parse  sequence ");  }  }  while  (reusableToken.type  ==  TOKEN);  if  (!record.isEmpty())  {  result  =  new  CSVRecord(record.toArray(new  String[record.size()]),  headerMapping);  }  return  result;  }    [CLASS]  CSVParser  1  [METHOD]  getRecord  [RETURN_TYPE]  CSVRecord    [VARIABLES]  Lexer  lexer  List  record  records  Token  reusableToken  CSVRecord  current  rec  result  boolean  Map  headerMapping    	[P12_Insert_Condition]
[PATCH]  lexer.nextToken  (  reusableToken  )  ;	[BUG]  [BUGGY]  lexer.getLineNumber(  reusableToken)  ;[CE]  method  getLineNumber  in  class  Lexer  cannot  be  applied  to  given  types;  [CONTEXT]  CSVRecord  getRecord()  throws  IOException  {  CSVRecord  result  =  new  CSVRecord(null,  headerMapping);  record.clear();  do  {  reusableToken.reset();  [BUGGY]  lexer.getLineNumber(  reusableToken)  ;  [BUGGY]  switch  (reusableToken.type)  {  case  TOKEN:  record.add(reusableToken.content.toString());  break;  case  EORECORD:  record.add(reusableToken.content.toString());  break;  case  EOF:  if  (reusableToken.isReady)  {  record.add(reusableToken.content.toString());  }  else  {  result  =  null;  }  break;  case  INVALID:  throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  parse  sequence ");  }  }  while  (reusableToken.type  ==  TOKEN);  if  (!record.isEmpty())  {  result  =  new  CSVRecord(record.toArray(new  String[record.size()]),  headerMapping);  }  return  result;  }    [CLASS]  CSVParser  1  [METHOD]  getRecord  [RETURN_TYPE]  CSVRecord    [VARIABLES]  Lexer  lexer  List  record  records  Token  reusableToken  CSVRecord  current  rec  result  boolean  Map  headerMapping    	[P7_Replace_Invocation]
[PATCH]  lexer.nextToken  (  reusableToken  )  ;	[BUG]  [BUGGY]  lexer.getLineNumber(  )  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  CSVRecord  getRecord()  throws  IOException  {  CSVRecord  result  =  new  CSVRecord(null,  headerMapping);  record.clear();  do  {  reusableToken.reset();  [BUGGY]  lexer.getLineNumber(  )  ;  [BUGGY]  switch  (reusableToken.type)  {  case  TOKEN:  record.add(reusableToken.content.toString());  break;  case  EORECORD:  record.add(reusableToken.content.toString());  break;  case  EOF:  if  (reusableToken.isReady)  {  record.add(reusableToken.content.toString());  }  else  {  result  =  null;  }  break;  case  INVALID:  throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  parse  sequence ");  }  }  while  (reusableToken.type  ==  TOKEN);  if  (!record.isEmpty())  {  result  =  new  CSVRecord(record.toArray(new  String[record.size()]),  headerMapping);  }  return  result;  }    [CLASS]  CSVParser  1  [METHOD]  getRecord  [RETURN_TYPE]  CSVRecord    [VARIABLES]  Lexer  lexer  List  record  records  Token  reusableToken  CSVRecord  current  rec  result  boolean  Map  headerMapping    	[P7_Replace_Invocation]
[PATCH]  lexer.nextToken  (  reusableToken  )  ;	[BUG]  [BUGGY]  [FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  CSVRecord  getRecord()  throws  IOException  {  CSVRecord  result  =  new  CSVRecord(null,  headerMapping);  record.clear();  do  {  reusableToken.reset();  [BUGGY]  [BUGGY]    switch  (reusableToken.type)  {  case  TOKEN:  record.add(reusableToken.content.toString());  break;  case  EORECORD:  record.add(reusableToken.content.toString());  break;  case  EOF:  if  (reusableToken.isReady)  {  record.add(reusableToken.content.toString());  }  else  {  result  =  null;  }  break;  case  INVALID:  throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  parse  sequence ");  }  }  while  (reusableToken.type  ==  TOKEN);  if  (!record.isEmpty())  {  result  =  new  CSVRecord(record.toArray(new  String[record.size()]),  headerMapping);  }  return  result;    [CLASS]  CSVParser  1  [METHOD]  getRecord  [RETURN_TYPE]  CSVRecord    [VARIABLES]  Lexer  lexer  List  record  records  Token  reusableToken  CSVRecord  current  rec  result  boolean  Map  headerMapping    	[P14_Delete_Statement]
[PATCH]  record.add  (  reusableToken.content.toString  (  )  )  ;	[BUG]  [BUGGY]  record.size(  reusableToken.content.toString(  )  )  ;[CE]  no  suitable  method  found  for  size(String)  [CONTEXT]  CSVRecord  getRecord()  throws  IOException  {  CSVRecord  result  =  new  CSVRecord(null,  headerMapping);  record.clear();  do  {  reusableToken.reset();  lexer.nextToken(reusableToken);  switch  (reusableToken.type)  {  case  TOKEN:  [BUGGY]  record.size(  reusableToken.content.toString(  )  )  ;  [BUGGY]  break;  case  EORECORD:  record.add(reusableToken.content.toString());  break;  case  EOF:  if  (reusableToken.isReady)  {  record.add(reusableToken.content.toString());  }  else  {  result  =  null;  }  break;  case  INVALID:  throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  parse  sequence ");  }  }  while  (reusableToken.type  ==  TOKEN);  if  (!record.isEmpty())  {  result  =  new  CSVRecord(record.toArray(new  String[record.size()]),  headerMapping);  }  return  result;  }    [CLASS]  CSVParser  1  [METHOD]  getRecord  [RETURN_TYPE]  CSVRecord    [VARIABLES]  Lexer  lexer  List  record  records  Token  reusableToken  CSVRecord  current  rec  result  boolean  Map  headerMapping    	[P7_Replace_Invocation]
[PATCH]  record.add  (  reusableToken.content.toString  (  )  )  ;	[BUG]  [BUGGY]  record.add(  reusableToken.content.getRecord(  )  )  ;[CE]  cannot  find  symbol  [CONTEXT]  CSVRecord  getRecord()  throws  IOException  {  CSVRecord  result  =  new  CSVRecord(null,  headerMapping);  record.clear();  do  {  reusableToken.reset();  lexer.nextToken(reusableToken);  switch  (reusableToken.type)  {  case  TOKEN:  [BUGGY]  record.add(  reusableToken.content.getRecord(  )  )  ;  [BUGGY]  break;  case  EORECORD:  record.add(reusableToken.content.toString());  break;  case  EOF:  if  (reusableToken.isReady)  {  record.add(reusableToken.content.toString());  }  else  {  result  =  null;  }  break;  case  INVALID:  throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  parse  sequence ");  }  }  while  (reusableToken.type  ==  TOKEN);  if  (!record.isEmpty())  {  result  =  new  CSVRecord(record.toArray(new  String[record.size()]),  headerMapping);  }  return  result;  }    [CLASS]  CSVParser  1  [METHOD]  getRecord  [RETURN_TYPE]  CSVRecord    [VARIABLES]  Lexer  lexer  List  record  records  Token  reusableToken  CSVRecord  current  rec  result  boolean  Map  headerMapping    	[P7_Replace_Invocation]
[PATCH]  record.add  (  reusableToken.content.toString  (  )  )  ;	[BUG]  [BUGGY]  record.add(  reusableToken.content.getLineNumber(  )  )  ;[CE]  cannot  find  symbol  [CONTEXT]  CSVRecord  getRecord()  throws  IOException  {  CSVRecord  result  =  new  CSVRecord(null,  headerMapping);  record.clear();  do  {  reusableToken.reset();  lexer.nextToken(reusableToken);  switch  (reusableToken.type)  {  case  TOKEN:  [BUGGY]  record.add(  reusableToken.content.getLineNumber(  )  )  ;  [BUGGY]  break;  case  EORECORD:  record.add(reusableToken.content.toString());  break;  case  EOF:  if  (reusableToken.isReady)  {  record.add(reusableToken.content.toString());  }  else  {  result  =  null;  }  break;  case  INVALID:  throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  parse  sequence ");  }  }  while  (reusableToken.type  ==  TOKEN);  if  (!record.isEmpty())  {  result  =  new  CSVRecord(record.toArray(new  String[record.size()]),  headerMapping);  }  return  result;  }    [CLASS]  CSVParser  1  [METHOD]  getRecord  [RETURN_TYPE]  CSVRecord    [VARIABLES]  Lexer  lexer  List  record  records  Token  reusableToken  CSVRecord  current  rec  result  boolean  Map  headerMapping    	[P8_Replace_Mix]
[PATCH]  record.add  (  reusableToken.content.toString  (  )  )  ;	[BUG]  [BUGGY]  [FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  CSVRecord  getRecord()  throws  IOException  {  CSVRecord  result  =  new  CSVRecord(null,  headerMapping);  record.clear();  do  {  reusableToken.reset();  lexer.nextToken(reusableToken);  switch  (reusableToken.type)  {  case  TOKEN:  [BUGGY]  [BUGGY]    break;  case  EORECORD:  record.add(reusableToken.content.toString());  break;  case  EOF:  if  (reusableToken.isReady)  {  record.add(reusableToken.content.toString());  }  else  {  result  =  null;  }  break;  case  INVALID:  throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  parse  sequence ");  }  }  while  (reusableToken.type  ==  TOKEN);  if  (!record.isEmpty())  {  result  =  new  CSVRecord(record.toArray(new  String[record.size()]),  headerMapping);  }  return  result;    [CLASS]  CSVParser  1  [METHOD]  getRecord  [RETURN_TYPE]  CSVRecord    [VARIABLES]  Lexer  lexer  List  record  records  Token  reusableToken  CSVRecord  current  rec  result  boolean  Map  headerMapping    	[P14_Delete_Statement]
[PATCH]  record.add  (  reusableToken.content.toString  (  )  )  ;	[BUG]  [BUGGY]  record.size(  reusableToken.content.toString(  )  )  ;[CE]  no  suitable  method  found  for  size(String)  [CONTEXT]  CSVRecord  getRecord()  throws  IOException  {  CSVRecord  result  =  new  CSVRecord(null,  headerMapping);  record.clear();  do  {  reusableToken.reset();  lexer.nextToken(reusableToken);  switch  (reusableToken.type)  {  case  TOKEN:  record.add(reusableToken.content.toString());  break;  case  EORECORD:  [BUGGY]  record.size(  reusableToken.content.toString(  )  )  ;  [BUGGY]  break;  case  EOF:  if  (reusableToken.isReady)  {  record.add(reusableToken.content.toString());  }  else  {  result  =  null;  }  break;  case  INVALID:  throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  parse  sequence ");  }  }  while  (reusableToken.type  ==  TOKEN);  if  (!record.isEmpty())  {  result  =  new  CSVRecord(record.toArray(new  String[record.size()]),  headerMapping);  }  return  result;  }    [CLASS]  CSVParser  1  [METHOD]  getRecord  [RETURN_TYPE]  CSVRecord    [VARIABLES]  Lexer  lexer  List  record  records  Token  reusableToken  CSVRecord  current  rec  result  boolean  Map  headerMapping    	[P7_Replace_Invocation]
[PATCH]  record.add  (  reusableToken.content.toString  (  )  )  ;	[BUG]  [BUGGY]  record.add(  reusableToken.content.getRecord(  )  )  ;[CE]  cannot  find  symbol  [CONTEXT]  CSVRecord  getRecord()  throws  IOException  {  CSVRecord  result  =  new  CSVRecord(null,  headerMapping);  record.clear();  do  {  reusableToken.reset();  lexer.nextToken(reusableToken);  switch  (reusableToken.type)  {  case  TOKEN:  record.add(reusableToken.content.toString());  break;  case  EORECORD:  [BUGGY]  record.add(  reusableToken.content.getRecord(  )  )  ;  [BUGGY]  break;  case  EOF:  if  (reusableToken.isReady)  {  record.add(reusableToken.content.toString());  }  else  {  result  =  null;  }  break;  case  INVALID:  throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  parse  sequence ");  }  }  while  (reusableToken.type  ==  TOKEN);  if  (!record.isEmpty())  {  result  =  new  CSVRecord(record.toArray(new  String[record.size()]),  headerMapping);  }  return  result;  }    [CLASS]  CSVParser  1  [METHOD]  getRecord  [RETURN_TYPE]  CSVRecord    [VARIABLES]  Lexer  lexer  List  record  records  Token  reusableToken  CSVRecord  current  rec  result  boolean  Map  headerMapping    	[P7_Replace_Invocation]
[PATCH]  record.add  (  reusableToken.content.toString  (  )  )  ;  break;	[BUG]  [BUGGY]  [FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  CSVRecord  getRecord()  throws  IOException  {  CSVRecord  result  =  new  CSVRecord(null,  headerMapping);  record.clear();  do  {  reusableToken.reset();  lexer.nextToken(reusableToken);  switch  (reusableToken.type)  {  case  TOKEN:  record.add(reusableToken.content.toString());  break;  case  EORECORD:  [BUGGY]  [BUGGY]    case  EOF:  if  (reusableToken.isReady)  {  record.add(reusableToken.content.toString());  }  else  {  result  =  null;  }  break;  case  INVALID:  throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  parse  sequence ");  }  }  while  (reusableToken.type  ==  TOKEN);  if  (!record.isEmpty())  {  result  =  new  CSVRecord(record.toArray(new  String[record.size()]),  headerMapping);  }  return  result;    [CLASS]  CSVParser  1  [METHOD]  getRecord  [RETURN_TYPE]  CSVRecord    [VARIABLES]  Lexer  lexer  List  record  records  Token  reusableToken  CSVRecord  current  rec  result  boolean  Map  headerMapping    	[P14_Delete_Statement]
[PATCH]  throw  new  IOException  ( "   ")  ;	[BUG]  [BUGGY]  [FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  CSVRecord  getRecord()  throws  IOException  {  CSVRecord  result  =  new  CSVRecord(null,  headerMapping);  record.clear();  do  {  reusableToken.reset();  lexer.nextToken(reusableToken);  switch  (reusableToken.type)  {  case  TOKEN:  record.add(reusableToken.content.toString());  break;  case  EORECORD:  record.add(reusableToken.content.toString());  break;  case  EOF:  if  (reusableToken.isReady)  {  record.add(reusableToken.content.toString());  }  else  {  result  =  null;  }  break;  case  INVALID:  [BUGGY]  [BUGGY]    }  }  while  (reusableToken.type  ==  TOKEN);  if  (!record.isEmpty())  {  result  =  new  CSVRecord(record.toArray(new  String[record.size()]),  headerMapping);  }  return  result;    [CLASS]  CSVParser  1  [METHOD]  getRecord  [RETURN_TYPE]  CSVRecord    [VARIABLES]  Lexer  lexer  List  record  records  Token  reusableToken  CSVRecord  current  rec  result  boolean  Map  headerMapping    	[P14_Delete_Statement]
[PATCH]  if  (  !record.isEmpty  (  )  )  {	[BUG]  [BUGGY]  if  (  !record.clear(  )  )  {[CE]  'void'  type  not  allowed  here  [CONTEXT]  CSVRecord  getRecord()  throws  IOException  {  CSVRecord  result  =  new  CSVRecord(null,  headerMapping);  record.clear();  do  {  reusableToken.reset();  lexer.nextToken(reusableToken);  switch  (reusableToken.type)  {  case  TOKEN:  record.add(reusableToken.content.toString());  break;  case  EORECORD:  record.add(reusableToken.content.toString());  break;  case  EOF:  if  (reusableToken.isReady)  {  record.add(reusableToken.content.toString());  }  else  {  result  =  null;  }  break;  case  INVALID:  throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  parse  sequence ");  }  }  while  (reusableToken.type  ==  TOKEN);  [BUGGY]  if  (  !record.clear(  )  )  {  [BUGGY]  result  =  new  CSVRecord(record.toArray(new  String[record.size()]),  headerMapping);  }  return  result;  }    [CLASS]  CSVParser  1  [METHOD]  getRecord  [RETURN_TYPE]  CSVRecord    [VARIABLES]  Lexer  lexer  List  record  records  Token  reusableToken  CSVRecord  current  rec  result  boolean  Map  headerMapping    	[P7_Replace_Invocation]
[PATCH]  if  (  !record.isEmpty  (  )  )  {  result  =  new  CSVRecord  (  record.toArray  (  new  String[record.size  (  )  ]  )  ,  headerMapping  )  ;  }	[BUG]  [BUGGY]  result  =  new  org.apache.commons.csv.CSVRecord(record.toArray(new  java.lang.String[record.size()]),  headerMapping);[CE]  illegal  start  of  expression  [CONTEXT]  CSVRecord  getRecord()  throws  IOException  {  CSVRecord  result  =  new  CSVRecord(null,  headerMapping);  record.clear();  do  {  reusableToken.reset();  lexer.nextToken(reusableToken);  switch  (reusableToken.type)  {  case  TOKEN:  record.add(reusableToken.content.toString());  break;  case  EORECORD:  record.add(reusableToken.content.toString());  break;  case  EOF:  if  (reusableToken.isReady)  {  record.add(reusableToken.content.toString());  }  else  {  result  =  null;  }  break;  case  INVALID:  throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  parse  sequence ");  }  }  while  (reusableToken.type  ==  TOKEN);  [BUGGY]  result  =  new  org.apache.commons.csv.CSVRecord(record.toArray(new  java.lang.String[record.size()]),  headerMapping);  [BUGGY]    result  =  new  org.apache.commons.csv.CSVRecord(record.toArray(new  java.lang.String[record.size()]),  headerMapping);  return  result;    [CLASS]  CSVParser  1  [METHOD]  getRecord  [RETURN_TYPE]  CSVRecord    [VARIABLES]  Lexer  lexer  List  record  records  Token  reusableToken  CSVRecord  current  rec  result  boolean  Map  headerMapping    	[P15_Unwrap_Block]
[PATCH]  if  (  !record.isEmpty  (  )  )  {  result  =  new  CSVRecord  (  record.toArray  (  new  String[record.size  (  )  ]  )  ,  headerMapping  )  ;  }	[BUG]  [BUGGY]  [CE]  illegal  start  of  expression  [CONTEXT]  CSVRecord  getRecord()  throws  IOException  {  CSVRecord  result  =  new  CSVRecord(null,  headerMapping);  record.clear();  do  {  reusableToken.reset();  lexer.nextToken(reusableToken);  switch  (reusableToken.type)  {  case  TOKEN:  record.add(reusableToken.content.toString());  break;  case  EORECORD:  record.add(reusableToken.content.toString());  break;  case  EOF:  if  (reusableToken.isReady)  {  record.add(reusableToken.content.toString());  }  else  {  result  =  null;  }  break;  case  INVALID:  throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  parse  sequence ");  }  }  while  (reusableToken.type  ==  TOKEN);  [BUGGY]  [BUGGY]      return  result;    [CLASS]  CSVParser  1  [METHOD]  getRecord  [RETURN_TYPE]  CSVRecord    [VARIABLES]  Lexer  lexer  List  record  records  Token  reusableToken  CSVRecord  current  rec  result  boolean  Map  headerMapping    	[P16_Remove_Block]
[PATCH]  result  =  new  CSVRecord  (  record.toArray  (  new  String[record.size  (  )  ]  )  ,  headerMapping  )  ;	[BUG]  [BUGGY]  result  =  new  CSVRecord(  record.toArray(  new  String[record.size()  +  1  ])  ,  headerMapping)  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  CSVRecord  getRecord()  throws  IOException  {  CSVRecord  result  =  new  CSVRecord(null,  headerMapping);  record.clear();  do  {  reusableToken.reset();  lexer.nextToken(reusableToken);  switch  (reusableToken.type)  {  case  TOKEN:  record.add(reusableToken.content.toString());  break;  case  EORECORD:  record.add(reusableToken.content.toString());  break;  case  EOF:  if  (reusableToken.isReady)  {  record.add(reusableToken.content.toString());  }  else  {  result  =  null;  }  break;  case  INVALID:  throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  parse  sequence ");  }  }  while  (reusableToken.type  ==  TOKEN);  if  (!record.isEmpty())  {  [BUGGY]  result  =  new  CSVRecord(  record.toArray(  new  String[record.size()  +  1  ])  ,  headerMapping)  ;  [BUGGY]  }  return  result;  }    [CLASS]  CSVParser  1  [METHOD]  getRecord  [RETURN_TYPE]  CSVRecord    [VARIABLES]  Lexer  lexer  List  record  records  Token  reusableToken  CSVRecord  current  rec  result  boolean  Map  headerMapping    	[P3_Replace_Literal]
[PATCH]  result  =  new  CSVRecord  (  record.toArray  (  new  String[record.size  (  )  ]  )  ,  headerMapping  )  ;	[BUG]  [BUGGY]  result  =  new  CSVRecord(  record.toArray(  new  String[record.size(  )  ])  )  ;[CE]  constructor  CSVRecord  in  class  CSVRecord  cannot  be  applied  to  given  types;  [CONTEXT]  CSVRecord  getRecord()  throws  IOException  {  CSVRecord  result  =  new  CSVRecord(null,  headerMapping);  record.clear();  do  {  reusableToken.reset();  lexer.nextToken(reusableToken);  switch  (reusableToken.type)  {  case  TOKEN:  record.add(reusableToken.content.toString());  break;  case  EORECORD:  record.add(reusableToken.content.toString());  break;  case  EOF:  if  (reusableToken.isReady)  {  record.add(reusableToken.content.toString());  }  else  {  result  =  null;  }  break;  case  INVALID:  throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  parse  sequence ");  }  }  while  (reusableToken.type  ==  TOKEN);  if  (!record.isEmpty())  {  [BUGGY]  result  =  new  CSVRecord(  record.toArray(  new  String[record.size(  )  ])  )  ;  [BUGGY]  }  return  result;  }    [CLASS]  CSVParser  1  [METHOD]  getRecord  [RETURN_TYPE]  CSVRecord    [VARIABLES]  Lexer  lexer  List  record  records  Token  reusableToken  CSVRecord  current  rec  result  boolean  Map  headerMapping    	[P5_Replace_Variable]
[PATCH]  result  =  new  CSVRecord  (  record.toArray  (  new  String[record.size  (  )  ]  )  ,  headerMapping  )  ;	[BUG]  [BUGGY]  result  =  new  CSVRecord(  headerMapping.toArray(  new  String[record.size(  )  ])  ,  record)  ;[CE]  cannot  find  symbol  [CONTEXT]  CSVRecord  getRecord()  throws  IOException  {  CSVRecord  result  =  new  CSVRecord(null,  headerMapping);  record.clear();  do  {  reusableToken.reset();  lexer.nextToken(reusableToken);  switch  (reusableToken.type)  {  case  TOKEN:  record.add(reusableToken.content.toString());  break;  case  EORECORD:  record.add(reusableToken.content.toString());  break;  case  EOF:  if  (reusableToken.isReady)  {  record.add(reusableToken.content.toString());  }  else  {  result  =  null;  }  break;  case  INVALID:  throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  parse  sequence ");  }  }  while  (reusableToken.type  ==  TOKEN);  if  (!record.isEmpty())  {  [BUGGY]  result  =  new  CSVRecord(  headerMapping.toArray(  new  String[record.size(  )  ])  ,  record)  ;  [BUGGY]  }  return  result;  }    [CLASS]  CSVParser  1  [METHOD]  getRecord  [RETURN_TYPE]  CSVRecord    [VARIABLES]  Lexer  lexer  List  record  records  Token  reusableToken  CSVRecord  current  rec  result  boolean  Map  headerMapping    	[P5_Replace_Variable]
[PATCH]  result  =  new  CSVRecord  (  record.toArray  (  new  String[record.size  (  )  ]  )  ,  headerMapping  )  ;	[BUG]  [BUGGY]  result  =  new  CSVRecord(  record.clear(  new  String[record.size(  )  ])  ,  headerMapping)  ;[CE]  no  suitable  method  found  for  clear(String[])  [CONTEXT]  CSVRecord  getRecord()  throws  IOException  {  CSVRecord  result  =  new  CSVRecord(null,  headerMapping);  record.clear();  do  {  reusableToken.reset();  lexer.nextToken(reusableToken);  switch  (reusableToken.type)  {  case  TOKEN:  record.add(reusableToken.content.toString());  break;  case  EORECORD:  record.add(reusableToken.content.toString());  break;  case  EOF:  if  (reusableToken.isReady)  {  record.add(reusableToken.content.toString());  }  else  {  result  =  null;  }  break;  case  INVALID:  throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  parse  sequence ");  }  }  while  (reusableToken.type  ==  TOKEN);  if  (!record.isEmpty())  {  [BUGGY]  result  =  new  CSVRecord(  record.clear(  new  String[record.size(  )  ])  ,  headerMapping)  ;  [BUGGY]  }  return  result;  }    [CLASS]  CSVParser  1  [METHOD]  getRecord  [RETURN_TYPE]  CSVRecord    [VARIABLES]  Lexer  lexer  List  record  records  Token  reusableToken  CSVRecord  current  rec  result  boolean  Map  headerMapping    	[P7_Replace_Invocation]
[PATCH]  result  =  new  CSVRecord  (  record.toArray  (  new  String[record.size  (  )  ]  )  ,  headerMapping  )  ;	[BUG]  [BUGGY]  result  =  new  CSVRecord(  record.toArray(  new  String[record.clear(  )  ])  ,  headerMapping)  ;[CE]  incompatible  types  [CONTEXT]  CSVRecord  getRecord()  throws  IOException  {  CSVRecord  result  =  new  CSVRecord(null,  headerMapping);  record.clear();  do  {  reusableToken.reset();  lexer.nextToken(reusableToken);  switch  (reusableToken.type)  {  case  TOKEN:  record.add(reusableToken.content.toString());  break;  case  EORECORD:  record.add(reusableToken.content.toString());  break;  case  EOF:  if  (reusableToken.isReady)  {  record.add(reusableToken.content.toString());  }  else  {  result  =  null;  }  break;  case  INVALID:  throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  parse  sequence ");  }  }  while  (reusableToken.type  ==  TOKEN);  if  (!record.isEmpty())  {  [BUGGY]  result  =  new  CSVRecord(  record.toArray(  new  String[record.clear(  )  ])  ,  headerMapping)  ;  [BUGGY]  }  return  result;  }    [CLASS]  CSVParser  1  [METHOD]  getRecord  [RETURN_TYPE]  CSVRecord    [VARIABLES]  Lexer  lexer  List  record  records  Token  reusableToken  CSVRecord  current  rec  result  boolean  Map  headerMapping    	[P7_Replace_Invocation]
[PATCH]  result  =  new  CSVRecord  (  record.toArray  (  new  String[record.size  (  )  ]  )  ,  headerMapping  )  ;	[BUG]  [BUGGY]  result  ;[CE]  not  a  statement  [CONTEXT]  CSVRecord  getRecord()  throws  IOException  {  CSVRecord  result  =  new  CSVRecord(null,  headerMapping);  record.clear();  do  {  reusableToken.reset();  lexer.nextToken(reusableToken);  switch  (reusableToken.type)  {  case  TOKEN:  record.add(reusableToken.content.toString());  break;  case  EORECORD:  record.add(reusableToken.content.toString());  break;  case  EOF:  if  (reusableToken.isReady)  {  record.add(reusableToken.content.toString());  }  else  {  result  =  null;  }  break;  case  INVALID:  throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  parse  sequence ");  }  }  while  (reusableToken.type  ==  TOKEN);  if  (!record.isEmpty())  {  [BUGGY]  result  ;  [BUGGY]  }  return  result;  }    [CLASS]  CSVParser  1  [METHOD]  getRecord  [RETURN_TYPE]  CSVRecord    [VARIABLES]  Lexer  lexer  List  record  records  Token  reusableToken  CSVRecord  current  rec  result  boolean  Map  headerMapping    	[P8_Replace_Mix]
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  !(  record.isEmpty(  )  )  )  {      result  =  new  CSVRecord(  record.toArray(  new  size(  )  ])  ,  headerMapping)  ;  }[CE]  ')'  expected  [CONTEXT]  CSVRecord  getRecord()  throws  IOException  {  CSVRecord  result  =  new  CSVRecord(null,  headerMapping);  record.clear();  do  {  reusableToken.reset();  lexer.nextToken(reusableToken);  switch  (reusableToken.type)  {  case  TOKEN:  record.add(reusableToken.content.toString());  break;  case  EORECORD:  record.add(reusableToken.content.toString());  break;  case  EOF:  if  (reusableToken.isReady)  {  record.add(reusableToken.content.toString());  }  else  {  result  =  null;  }  break;  case  INVALID:  throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  parse  sequence ");  }  }  while  (reusableToken.type  ==  TOKEN);  if  (!record.isEmpty())  {  [BUGGY]  if  (  !(  record.isEmpty(  )  )  )  {      result  =  new  CSVRecord(  record.toArray(  new  size(  )  ])  ,  headerMapping)  ;  }  [BUGGY]  }  return  result;  }    [CLASS]  CSVParser  1  [METHOD]  getRecord  [RETURN_TYPE]  CSVRecord    [VARIABLES]  Lexer  lexer  List  record  records  Token  reusableToken  CSVRecord  current  rec  result  boolean  Map  headerMapping    	[P13_Insert_Block]
[PATCH]  result  =  new  CSVRecord  (  record.toArray  (  new  String[record.size  (  )  ]  )  ,  headerMapping  )  ;	[BUG]  [BUGGY]  result  =  new  CSVRecord(  record.toArray(  new  String[record.size()  +  6  ])  ,  headerMapping)  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  CSVRecord  getRecord()  throws  IOException  {  CSVRecord  result  =  new  CSVRecord(null,  headerMapping);  record.clear();  do  {  reusableToken.reset();  lexer.nextToken(reusableToken);  switch  (reusableToken.type)  {  case  TOKEN:  record.add(reusableToken.content.toString());  break;  case  EORECORD:  record.add(reusableToken.content.toString());  break;  case  EOF:  if  (reusableToken.isReady)  {  record.add(reusableToken.content.toString());  }  else  {  result  =  null;  }  break;  case  INVALID:  throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  parse  sequence ");  }  }  while  (reusableToken.type  ==  TOKEN);  if  (!record.isEmpty())  {  [BUGGY]  result  =  new  CSVRecord(  record.toArray(  new  String[record.size()  +  6  ])  ,  headerMapping)  ;  [BUGGY]  }  return  result;  }    [CLASS]  CSVParser  1  [METHOD]  getRecord  [RETURN_TYPE]  CSVRecord    [VARIABLES]  Lexer  lexer  List  record  records  Token  reusableToken  CSVRecord  current  rec  result  boolean  Map  headerMapping    	[P3_Replace_Literal]
[PATCH]  result  =  new  CSVRecord  (  record.toArray  (  new  String[record.size  (  )  ]  )  ,  headerMapping  )  ;	[BUG]  [BUGGY]  result  =  new  CSVRecord(  record.add(  current)  ,  headerMapping)  ;[CE]  cannot  find  symbol  current  [CONTEXT]  CSVRecord  getRecord()  throws  IOException  {  CSVRecord  result  =  new  CSVRecord(null,  headerMapping);  record.clear();  do  {  reusableToken.reset();  lexer.nextToken(reusableToken);  switch  (reusableToken.type)  {  case  TOKEN:  record.add(reusableToken.content.toString());  break;  case  EORECORD:  record.add(reusableToken.content.toString());  break;  case  EOF:  if  (reusableToken.isReady)  {  record.add(reusableToken.content.toString());  }  else  {  result  =  null;  }  break;  case  INVALID:  throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  parse  sequence ");  }  }  while  (reusableToken.type  ==  TOKEN);  if  (!record.isEmpty())  {  [BUGGY]  result  =  new  CSVRecord(  record.add(  current)  ,  headerMapping)  ;  [BUGGY]  }  return  result;  }    [CLASS]  CSVParser  1  [METHOD]  getRecord  [RETURN_TYPE]  CSVRecord    [VARIABLES]  Lexer  lexer  List  record  records  Token  reusableToken  CSVRecord  current  rec  result  boolean  Map  headerMapping    	[P7_Replace_Invocation]
[PATCH]  result  =  new  CSVRecord  (  record.toArray  (  new  String[record.size  (  )  ]  )  ,  headerMapping  )  ;	[BUG]  [BUGGY]  result  =  new  CSVRecord(  record.toArray(  new  String[record.isEmpty(  )  ])  ,  headerMapping)  ;[CE]  incompatible  types  [CONTEXT]  CSVRecord  getRecord()  throws  IOException  {  CSVRecord  result  =  new  CSVRecord(null,  headerMapping);  record.clear();  do  {  reusableToken.reset();  lexer.nextToken(reusableToken);  switch  (reusableToken.type)  {  case  TOKEN:  record.add(reusableToken.content.toString());  break;  case  EORECORD:  record.add(reusableToken.content.toString());  break;  case  EOF:  if  (reusableToken.isReady)  {  record.add(reusableToken.content.toString());  }  else  {  result  =  null;  }  break;  case  INVALID:  throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  parse  sequence ");  }  }  while  (reusableToken.type  ==  TOKEN);  if  (!record.isEmpty())  {  [BUGGY]  result  =  new  CSVRecord(  record.toArray(  new  String[record.isEmpty(  )  ])  ,  headerMapping)  ;  [BUGGY]  }  return  result;  }    [CLASS]  CSVParser  1  [METHOD]  getRecord  [RETURN_TYPE]  CSVRecord    [VARIABLES]  Lexer  lexer  List  record  records  Token  reusableToken  CSVRecord  current  rec  result  boolean  Map  headerMapping    	[P7_Replace_Invocation]
[PATCH]  result  =  new  CSVRecord  (  record.toArray  (  new  String[record.size  (  )  ]  )  ,  headerMapping  )  ;	[BUG]  [BUGGY]  result  =  new  CSVRecord(  record.toArray(  new  String[record.size()  +  9  ])  ,  headerMapping)  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  CSVRecord  getRecord()  throws  IOException  {  CSVRecord  result  =  new  CSVRecord(null,  headerMapping);  record.clear();  do  {  reusableToken.reset();  lexer.nextToken(reusableToken);  switch  (reusableToken.type)  {  case  TOKEN:  record.add(reusableToken.content.toString());  break;  case  EORECORD:  record.add(reusableToken.content.toString());  break;  case  EOF:  if  (reusableToken.isReady)  {  record.add(reusableToken.content.toString());  }  else  {  result  =  null;  }  break;  case  INVALID:  throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  parse  sequence ");  }  }  while  (reusableToken.type  ==  TOKEN);  if  (!record.isEmpty())  {  [BUGGY]  result  =  new  CSVRecord(  record.toArray(  new  String[record.size()  +  9  ])  ,  headerMapping)  ;  [BUGGY]  }  return  result;  }    [CLASS]  CSVParser  1  [METHOD]  getRecord  [RETURN_TYPE]  CSVRecord    [VARIABLES]  Lexer  lexer  List  record  records  Token  reusableToken  CSVRecord  current  rec  result  boolean  Map  headerMapping    	[P3_Replace_Literal]
[PATCH]  result  =  new  CSVRecord  (  record.toArray  (  new  String[record.size  (  )  ]  )  ,  headerMapping  )  ;	[BUG]  [BUGGY]  [FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  CSVRecord  getRecord()  throws  IOException  {  CSVRecord  result  =  new  CSVRecord(null,  headerMapping);  record.clear();  do  {  reusableToken.reset();  lexer.nextToken(reusableToken);  switch  (reusableToken.type)  {  case  TOKEN:  record.add(reusableToken.content.toString());  break;  case  EORECORD:  record.add(reusableToken.content.toString());  break;  case  EOF:  if  (reusableToken.isReady)  {  record.add(reusableToken.content.toString());  }  else  {  result  =  null;  }  break;  case  INVALID:  throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  parse  sequence ");  }  }  while  (reusableToken.type  ==  TOKEN);  if  (!record.isEmpty())  {  [BUGGY]  [BUGGY]    }  return  result;    [CLASS]  CSVParser  1  [METHOD]  getRecord  [RETURN_TYPE]  CSVRecord    [VARIABLES]  Lexer  lexer  List  record  records  Token  reusableToken  CSVRecord  current  rec  result  boolean  Map  headerMapping    	[P14_Delete_Statement]
[PATCH]  result  =  new  CSVRecord  (  record.toArray  (  new  String[record.size  (  )  ]  )  ,  headerMapping  )  ;	[BUG]  [BUGGY]  result  =  new  CSVRecord(  record.toArray(  new  String[record.size()  +  0  ])  ,  headerMapping)  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  CSVRecord  getRecord()  throws  IOException  {  CSVRecord  result  =  new  CSVRecord(null,  headerMapping);  record.clear();  do  {  reusableToken.reset();  lexer.nextToken(reusableToken);  switch  (reusableToken.type)  {  case  TOKEN:  record.add(reusableToken.content.toString());  break;  case  EORECORD:  record.add(reusableToken.content.toString());  break;  case  EOF:  if  (reusableToken.isReady)  {  record.add(reusableToken.content.toString());  }  else  {  result  =  null;  }  break;  case  INVALID:  throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  parse  sequence ");  }  }  while  (reusableToken.type  ==  TOKEN);  if  (!record.isEmpty())  {  [BUGGY]  result  =  new  CSVRecord(  record.toArray(  new  String[record.size()  +  0  ])  ,  headerMapping)  ;  [BUGGY]  }  return  result;  }    [CLASS]  CSVParser  1  [METHOD]  getRecord  [RETURN_TYPE]  CSVRecord    [VARIABLES]  Lexer  lexer  List  record  records  Token  reusableToken  CSVRecord  current  rec  result  boolean  Map  headerMapping    	[P3_Replace_Literal]
[PATCH]  result  =  new  CSVRecord  (  record.toArray  (  new  String[record.size  (  )  ]  )  ,  headerMapping  )  ;	[BUG]  [BUGGY]  result  =  new  CSVRecord(  record.toArray(  new  String[record.size()  +  7  ])  ,  headerMapping)  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  CSVRecord  getRecord()  throws  IOException  {  CSVRecord  result  =  new  CSVRecord(null,  headerMapping);  record.clear();  do  {  reusableToken.reset();  lexer.nextToken(reusableToken);  switch  (reusableToken.type)  {  case  TOKEN:  record.add(reusableToken.content.toString());  break;  case  EORECORD:  record.add(reusableToken.content.toString());  break;  case  EOF:  if  (reusableToken.isReady)  {  record.add(reusableToken.content.toString());  }  else  {  result  =  null;  }  break;  case  INVALID:  throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  parse  sequence ");  }  }  while  (reusableToken.type  ==  TOKEN);  if  (!record.isEmpty())  {  [BUGGY]  result  =  new  CSVRecord(  record.toArray(  new  String[record.size()  +  7  ])  ,  headerMapping)  ;  [BUGGY]  }  return  result;  }    [CLASS]  CSVParser  1  [METHOD]  getRecord  [RETURN_TYPE]  CSVRecord    [VARIABLES]  Lexer  lexer  List  record  records  Token  reusableToken  CSVRecord  current  rec  result  boolean  Map  headerMapping    	[P3_Replace_Literal]
[PATCH]  result  =  new  CSVRecord  (  record.toArray  (  new  String[record.size  (  )  ]  )  ,  headerMapping  )  ;	[BUG]  [BUGGY]  result  =  result  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  CSVRecord  getRecord()  throws  IOException  {  CSVRecord  result  =  new  CSVRecord(null,  headerMapping);  record.clear();  do  {  reusableToken.reset();  lexer.nextToken(reusableToken);  switch  (reusableToken.type)  {  case  TOKEN:  record.add(reusableToken.content.toString());  break;  case  EORECORD:  record.add(reusableToken.content.toString());  break;  case  EOF:  if  (reusableToken.isReady)  {  record.add(reusableToken.content.toString());  }  else  {  result  =  null;  }  break;  case  INVALID:  throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  parse  sequence ");  }  }  while  (reusableToken.type  ==  TOKEN);  if  (!record.isEmpty())  {  [BUGGY]  result  =  result  ;  [BUGGY]  }  return  result;  }    [CLASS]  CSVParser  1  [METHOD]  getRecord  [RETURN_TYPE]  CSVRecord    [VARIABLES]  Lexer  lexer  List  record  records  Token  reusableToken  CSVRecord  current  rec  result  boolean  Map  headerMapping    	[P8_Replace_Mix]
[PATCH]  result  =  new  CSVRecord  (  record.toArray  (  new  String[record.size  (  )  ]  )  ,  headerMapping  )  ;	[BUG]  [BUGGY]  result  =  new  CSVRecord(  record.toArray(  new  String[record.size()  -  6  ])  ,  headerMapping)  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  CSVRecord  getRecord()  throws  IOException  {  CSVRecord  result  =  new  CSVRecord(null,  headerMapping);  record.clear();  do  {  reusableToken.reset();  lexer.nextToken(reusableToken);  switch  (reusableToken.type)  {  case  TOKEN:  record.add(reusableToken.content.toString());  break;  case  EORECORD:  record.add(reusableToken.content.toString());  break;  case  EOF:  if  (reusableToken.isReady)  {  record.add(reusableToken.content.toString());  }  else  {  result  =  null;  }  break;  case  INVALID:  throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  parse  sequence ");  }  }  while  (reusableToken.type  ==  TOKEN);  if  (!record.isEmpty())  {  [BUGGY]  result  =  new  CSVRecord(  record.toArray(  new  String[record.size()  -  6  ])  ,  headerMapping)  ;  [BUGGY]  }  return  result;  }    [CLASS]  CSVParser  1  [METHOD]  getRecord  [RETURN_TYPE]  CSVRecord    [VARIABLES]  Lexer  lexer  List  record  records  Token  reusableToken  CSVRecord  current  rec  result  boolean  Map  headerMapping    	[P3_Replace_Literal]
[PATCH]  result  =  new  CSVRecord  (  record.toArray  (  new  String[record.size  (  )  ]  )  ,  headerMapping  )  ;	[BUG]  [BUGGY]  result  =  new  CSVRecord(  record.add(  rec)  ,  headerMapping)  ;[CE]  cannot  find  symbol  rec  [CONTEXT]  CSVRecord  getRecord()  throws  IOException  {  CSVRecord  result  =  new  CSVRecord(null,  headerMapping);  record.clear();  do  {  reusableToken.reset();  lexer.nextToken(reusableToken);  switch  (reusableToken.type)  {  case  TOKEN:  record.add(reusableToken.content.toString());  break;  case  EORECORD:  record.add(reusableToken.content.toString());  break;  case  EOF:  if  (reusableToken.isReady)  {  record.add(reusableToken.content.toString());  }  else  {  result  =  null;  }  break;  case  INVALID:  throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  parse  sequence ");  }  }  while  (reusableToken.type  ==  TOKEN);  if  (!record.isEmpty())  {  [BUGGY]  result  =  new  CSVRecord(  record.add(  rec)  ,  headerMapping)  ;  [BUGGY]  }  return  result;  }    [CLASS]  CSVParser  1  [METHOD]  getRecord  [RETURN_TYPE]  CSVRecord    [VARIABLES]  Lexer  lexer  List  record  records  Token  reusableToken  CSVRecord  current  rec  result  boolean  Map  headerMapping    	[P7_Replace_Invocation]
[PATCH]  result  =  new  CSVRecord  (  record.toArray  (  new  String[record.size  (  )  ]  )  ,  headerMapping  )  ;	[BUG]  [BUGGY]  result  =  new  CSVRecord(  record.toArray(  new  String[record.size()  +  8  ])  ,  headerMapping)  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  CSVRecord  getRecord()  throws  IOException  {  CSVRecord  result  =  new  CSVRecord(null,  headerMapping);  record.clear();  do  {  reusableToken.reset();  lexer.nextToken(reusableToken);  switch  (reusableToken.type)  {  case  TOKEN:  record.add(reusableToken.content.toString());  break;  case  EORECORD:  record.add(reusableToken.content.toString());  break;  case  EOF:  if  (reusableToken.isReady)  {  record.add(reusableToken.content.toString());  }  else  {  result  =  null;  }  break;  case  INVALID:  throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  parse  sequence ");  }  }  while  (reusableToken.type  ==  TOKEN);  if  (!record.isEmpty())  {  [BUGGY]  result  =  new  CSVRecord(  record.toArray(  new  String[record.size()  +  8  ])  ,  headerMapping)  ;  [BUGGY]  }  return  result;  }    [CLASS]  CSVParser  1  [METHOD]  getRecord  [RETURN_TYPE]  CSVRecord    [VARIABLES]  Lexer  lexer  List  record  records  Token  reusableToken  CSVRecord  current  rec  result  boolean  Map  headerMapping    	[P3_Replace_Literal]
[PATCH]  result  =  new  CSVRecord  (  record.toArray  (  new  String[record.size  (  )  ]  )  ,  headerMapping  )  ;	[BUG]  [BUGGY]  result  =  new  CSVRecord(  record.toArray(  new  String[record.size()  -  9  ])  ,  headerMapping)  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  CSVRecord  getRecord()  throws  IOException  {  CSVRecord  result  =  new  CSVRecord(null,  headerMapping);  record.clear();  do  {  reusableToken.reset();  lexer.nextToken(reusableToken);  switch  (reusableToken.type)  {  case  TOKEN:  record.add(reusableToken.content.toString());  break;  case  EORECORD:  record.add(reusableToken.content.toString());  break;  case  EOF:  if  (reusableToken.isReady)  {  record.add(reusableToken.content.toString());  }  else  {  result  =  null;  }  break;  case  INVALID:  throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  parse  sequence ");  }  }  while  (reusableToken.type  ==  TOKEN);  if  (!record.isEmpty())  {  [BUGGY]  result  =  new  CSVRecord(  record.toArray(  new  String[record.size()  -  9  ])  ,  headerMapping)  ;  [BUGGY]  }  return  result;  }    [CLASS]  CSVParser  1  [METHOD]  getRecord  [RETURN_TYPE]  CSVRecord    [VARIABLES]  Lexer  lexer  List  record  records  Token  reusableToken  CSVRecord  current  rec  result  boolean  Map  headerMapping    	[P3_Replace_Literal]
[PATCH]  result  =  new  CSVRecord  (  record.toArray  (  new  String[record.size  (  )  ]  )  ,  headerMapping  )  ;	[BUG]  [BUGGY]  result  =  new  CSVRecord(  4.toArray(  new  String[record.size(  )  ])  ,  headerMapping)  ;[CE]  ')'  expected  [CONTEXT]  CSVRecord  getRecord()  throws  IOException  {  CSVRecord  result  =  new  CSVRecord(null,  headerMapping);  record.clear();  do  {  reusableToken.reset();  lexer.nextToken(reusableToken);  switch  (reusableToken.type)  {  case  TOKEN:  record.add(reusableToken.content.toString());  break;  case  EORECORD:  record.add(reusableToken.content.toString());  break;  case  EOF:  if  (reusableToken.isReady)  {  record.add(reusableToken.content.toString());  }  else  {  result  =  null;  }  break;  case  INVALID:  throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  parse  sequence ");  }  }  while  (reusableToken.type  ==  TOKEN);  if  (!record.isEmpty())  {  [BUGGY]  result  =  new  CSVRecord(  4.toArray(  new  String[record.size(  )  ])  ,  headerMapping)  ;  [BUGGY]  }  return  result;  }    [CLASS]  CSVParser  1  [METHOD]  getRecord  [RETURN_TYPE]  CSVRecord    [VARIABLES]  Lexer  lexer  List  record  records  Token  reusableToken  CSVRecord  current  rec  result  boolean  Map  headerMapping    	[P5_Replace_Variable]
[PATCH]  return  result;	[BUG]  [BUGGY]  return  rec;[CE]  cannot  find  symbol  rec  [CONTEXT]  CSVRecord  getRecord()  throws  IOException  {  CSVRecord  result  =  new  CSVRecord(null,  headerMapping);  record.clear();  do  {  reusableToken.reset();  lexer.nextToken(reusableToken);  switch  (reusableToken.type)  {  case  TOKEN:  record.add(reusableToken.content.toString());  break;  case  EORECORD:  record.add(reusableToken.content.toString());  break;  case  EOF:  if  (reusableToken.isReady)  {  record.add(reusableToken.content.toString());  }  else  {  result  =  null;  }  break;  case  INVALID:  throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  parse  sequence ");  }  }  while  (reusableToken.type  ==  TOKEN);  if  (!record.isEmpty())  {  result  =  new  CSVRecord(record.toArray(new  String[record.size()]),  headerMapping);  }  [BUGGY]  return  rec;  [BUGGY]  }    [CLASS]  CSVParser  1  [METHOD]  getRecord  [RETURN_TYPE]  CSVRecord    [VARIABLES]  Lexer  lexer  List  record  records  Token  reusableToken  CSVRecord  current  rec  result  boolean  Map  headerMapping    	[P5_Replace_Variable]
[PATCH]  if  (  format.getHeader  (  )  !=  null  )  {	[BUG]  [BUGGY]  if  (  format.getHeader(  )  ==  null)  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  [BUGGY]  if  (  format.getHeader(  )  ==  null)  {  [BUGGY]  hdrMap  =  new  HashMap<String,  Integer>();  String[]  header  =  null;  if  (format.getHeader().length  ==  0)  {    CSVRecord  rec  =  getRecord();  if  (rec  !=  null)  {  header  =  rec.values();  }  }  else  {  header  =  format.getHeader();  }    if  (header  !=  null)  {  for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }    [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map    CSVFormat  format  [VARIABLES]  Lexer  lexer  boolean  List  record  records  Token  reusableToken  CSVRecord  current  rec  result  CSVFormat  format  String[]  header  Map  hdrMap  headerMapping  int  i    	[P2_Replace_Operator]
[PATCH]  if  (  format.getHeader  (  )  !=  null  )  {	[BUG]  [BUGGY]  if  (  length  ==  0)  {[CE]  cannot  find  symbol  length  [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  [BUGGY]  if  (  length  ==  0)  {  [BUGGY]  hdrMap  =  new  HashMap<String,  Integer>();  String[]  header  =  null;  if  (format.getHeader().length  ==  0)  {    CSVRecord  rec  =  getRecord();  if  (rec  !=  null)  {  header  =  rec.values();  }  }  else  {  header  =  format.getHeader();  }    if  (header  !=  null)  {  for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }    [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map    CSVFormat  format  [VARIABLES]  Lexer  lexer  boolean  List  record  records  Token  reusableToken  CSVRecord  current  rec  result  CSVFormat  format  String[]  header  Map  hdrMap  headerMapping  int  i    	[P6_Replace_Expression]
[PATCH]  if  (  format.getHeader  (  )  !=  null  )  {	[BUG]  [BUGGY]  if  (  rec  !=  null)  {[CE]  cannot  find  symbol  rec  [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  [BUGGY]  if  (  rec  !=  null)  {  [BUGGY]  hdrMap  =  new  HashMap<String,  Integer>();  String[]  header  =  null;  if  (format.getHeader().length  ==  0)  {    CSVRecord  rec  =  getRecord();  if  (rec  !=  null)  {  header  =  rec.values();  }  }  else  {  header  =  format.getHeader();  }    if  (header  !=  null)  {  for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }    [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map    CSVFormat  format  [VARIABLES]  Lexer  lexer  boolean  List  record  records  Token  reusableToken  CSVRecord  current  rec  result  CSVFormat  format  String[]  header  Map  hdrMap  headerMapping  int  i    	[P6_Replace_Expression]
[PATCH]  if  (  format.getHeader  (  )  !=  null  )  {	[BUG]  [BUGGY]  if  (  header  !=  null)  {[CE]  cannot  find  symbol  header  [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  [BUGGY]  if  (  header  !=  null)  {  [BUGGY]  hdrMap  =  new  HashMap<String,  Integer>();  String[]  header  =  null;  if  (format.getHeader().length  ==  0)  {    CSVRecord  rec  =  getRecord();  if  (rec  !=  null)  {  header  =  rec.values();  }  }  else  {  header  =  format.getHeader();  }    if  (header  !=  null)  {  for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }    [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map    CSVFormat  format  [VARIABLES]  Lexer  lexer  boolean  List  record  records  Token  reusableToken  CSVRecord  current  rec  result  CSVFormat  format  String[]  header  Map  hdrMap  headerMapping  int  i    	[P6_Replace_Expression]
[PATCH]  if  (  format.getHeader  (  )  !=  null  )  {	[BUG]  [BUGGY]  if  (  i  <  header.length)  {[CE]  cannot  find  symbol  i  [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  [BUGGY]  if  (  i  <  header.length)  {  [BUGGY]  hdrMap  =  new  HashMap<String,  Integer>();  String[]  header  =  null;  if  (format.getHeader().length  ==  0)  {    CSVRecord  rec  =  getRecord();  if  (rec  !=  null)  {  header  =  rec.values();  }  }  else  {  header  =  format.getHeader();  }    if  (header  !=  null)  {  for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }    [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map    CSVFormat  format  [VARIABLES]  Lexer  lexer  boolean  List  record  records  Token  reusableToken  CSVRecord  current  rec  result  CSVFormat  format  String[]  header  Map  hdrMap  headerMapping  int  i    	[P6_Replace_Expression]
[PATCH]  if  (  format.getHeader  (  )  !=  null  )  {	[BUG]  [BUGGY]  if  (  format.validate(  )    !=  null)  {[CE]  'void'  type  not  allowed  here  [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  [BUGGY]  if  (  format.validate(  )    !=  null)  {  [BUGGY]  hdrMap  =  new  HashMap<String,  Integer>();  String[]  header  =  null;  if  (format.getHeader().length  ==  0)  {    CSVRecord  rec  =  getRecord();  if  (rec  !=  null)  {  header  =  rec.values();  }  }  else  {  header  =  format.getHeader();  }    if  (header  !=  null)  {  for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }    [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map    CSVFormat  format  [VARIABLES]  Lexer  lexer  boolean  List  record  records  Token  reusableToken  CSVRecord  current  rec  result  CSVFormat  format  String[]  header  Map  hdrMap  headerMapping  int  i    	[P7_Replace_Invocation]
[PATCH]  if  (  format.getHeader  (  )  !=  null  )  {	[BUG]  [BUGGY]  if  (  format.getHeader(  )  !=  false)  {[CE]  incomparable  types:  String[]  and  boolean  [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  [BUGGY]  if  (  format.getHeader(  )  !=  false)  {  [BUGGY]  hdrMap  =  new  HashMap<String,  Integer>();  String[]  header  =  null;  if  (format.getHeader().length  ==  0)  {    CSVRecord  rec  =  getRecord();  if  (rec  !=  null)  {  header  =  rec.values();  }  }  else  {  header  =  format.getHeader();  }    if  (header  !=  null)  {  for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }    [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map    CSVFormat  format  [VARIABLES]  Lexer  lexer  boolean  List  record  records  Token  reusableToken  CSVRecord  current  rec  result  CSVFormat  format  String[]  header  Map  hdrMap  headerMapping  int  i    	[P8_Replace_Mix]
[PATCH]  if  (  format.getHeader  (  )  !=  null  )  {	[BUG]  [BUGGY]  if  (  format.getHeader(  ).length  ==  0)  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  [BUGGY]  if  (  format.getHeader(  ).length  ==  0)  {  [BUGGY]  hdrMap  =  new  HashMap<String,  Integer>();  String[]  header  =  null;  if  (format.getHeader().length  ==  0)  {    CSVRecord  rec  =  getRecord();  if  (rec  !=  null)  {  header  =  rec.values();  }  }  else  {  header  =  format.getHeader();  }    if  (header  !=  null)  {  for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }    [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map    CSVFormat  format  [VARIABLES]  Lexer  lexer  boolean  List  record  records  Token  reusableToken  CSVRecord  current  rec  result  CSVFormat  format  String[]  header  Map  hdrMap  headerMapping  int  i    	[P9_Replace_Statement]
[PATCH]  if  (  format.getHeader  (  )  .length  ==  0  )  {	[BUG]  [BUGGY]  if  (  format.getHeader(  ).length  >=  0)  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  if  (format.getHeader()  !=  null)  {  hdrMap  =  new  HashMap<String,  Integer>();  String[]  header  =  null;  [BUGGY]  if  (  format.getHeader(  ).length  >=  0)  {  [BUGGY]    CSVRecord  rec  =  getRecord();  if  (rec  !=  null)  {  header  =  rec.values();  }  }  else  {  header  =  format.getHeader();  }    if  (header  !=  null)  {  for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }    [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map    CSVFormat  format  [VARIABLES]  Lexer  lexer  boolean  List  record  records  Token  reusableToken  CSVRecord  current  rec  result  CSVFormat  format  String[]  header  Map  hdrMap  headerMapping  int  i    	[P2_Replace_Operator]
[PATCH]  if  (  format.getHeader  (  )  .length  ==  0  )  {	[BUG]  [BUGGY]  if  (  format.getHeader(  ).length  ==  i)  {[CE]  cannot  find  symbol  i  [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  if  (format.getHeader()  !=  null)  {  hdrMap  =  new  HashMap<String,  Integer>();  String[]  header  =  null;  [BUGGY]  if  (  format.getHeader(  ).length  ==  i)  {  [BUGGY]    CSVRecord  rec  =  getRecord();  if  (rec  !=  null)  {  header  =  rec.values();  }  }  else  {  header  =  format.getHeader();  }    if  (header  !=  null)  {  for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }    [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map    CSVFormat  format  [VARIABLES]  Lexer  lexer  boolean  List  record  records  Token  reusableToken  CSVRecord  current  rec  result  CSVFormat  format  String[]  header  Map  hdrMap  headerMapping  int  i    	[P3_Replace_Literal]
[PATCH]  if  (  format.getHeader  (  )  .length  ==  0  )  {	[BUG]  [BUGGY]  if  (  rec  !=  null)  {[CE]  cannot  find  symbol  rec  [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  if  (format.getHeader()  !=  null)  {  hdrMap  =  new  HashMap<String,  Integer>();  String[]  header  =  null;  [BUGGY]  if  (  rec  !=  null)  {  [BUGGY]    CSVRecord  rec  =  getRecord();  if  (rec  !=  null)  {  header  =  rec.values();  }  }  else  {  header  =  format.getHeader();  }    if  (header  !=  null)  {  for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }    [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map    CSVFormat  format  [VARIABLES]  Lexer  lexer  boolean  List  record  records  Token  reusableToken  CSVRecord  current  rec  result  CSVFormat  format  String[]  header  Map  hdrMap  headerMapping  int  i    	[P6_Replace_Expression]
[PATCH]  if  (  format.getHeader  (  )  .length  ==  0  )  {	[BUG]  [BUGGY]  if  (  format.validate(  )  .length  ==  0)  {[CE]  void  cannot  be  dereferenced  [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  if  (format.getHeader()  !=  null)  {  hdrMap  =  new  HashMap<String,  Integer>();  String[]  header  =  null;  [BUGGY]  if  (  format.validate(  )  .length  ==  0)  {  [BUGGY]    CSVRecord  rec  =  getRecord();  if  (rec  !=  null)  {  header  =  rec.values();  }  }  else  {  header  =  format.getHeader();  }    if  (header  !=  null)  {  for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }    [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map    CSVFormat  format  [VARIABLES]  Lexer  lexer  boolean  List  record  records  Token  reusableToken  CSVRecord  current  rec  result  CSVFormat  format  String[]  header  Map  hdrMap  headerMapping  int  i    	[P7_Replace_Invocation]
[PATCH]  if  (  format.getHeader  (  )  .length  ==  0  )  {	[BUG]  [BUGGY]  if  (  format.getHeader(  )  !=  null)  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  if  (format.getHeader()  !=  null)  {  hdrMap  =  new  HashMap<String,  Integer>();  String[]  header  =  null;  [BUGGY]  if  (  format.getHeader(  )  !=  null)  {  [BUGGY]    CSVRecord  rec  =  getRecord();  if  (rec  !=  null)  {  header  =  rec.values();  }  }  else  {  header  =  format.getHeader();  }    if  (header  !=  null)  {  for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }    [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map    CSVFormat  format  [VARIABLES]  Lexer  lexer  boolean  List  record  records  Token  reusableToken  CSVRecord  current  rec  result  CSVFormat  format  String[]  header  Map  hdrMap  headerMapping  int  i    	[P9_Replace_Statement]
[PATCH]  if  (  format.getHeader  (  )  .length  ==  0  )  {  CSVRecord  rec  =  getRecord  (  )  ;  if  (  rec  !=  null  )  {  header  =  rec.values  (  )  ;  }	[BUG]  [BUGGY]  org.apache.commons.csv.CSVRecord  rec  =  getRecord();  if(rec  !=  null)  {    header  =  rec.values();};[CE]  illegal  start  of  type  [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  if  (format.getHeader()  !=  null)  {  hdrMap  =  new  HashMap<String,  Integer>();  String[]  header  =  null;  [BUGGY]  org.apache.commons.csv.CSVRecord  rec  =  getRecord();  if(rec  !=  null)  {    header  =  rec.values();};  [BUGGY]    org.apache.commons.csv.CSVRecord  rec  =  getRecord();  if  (rec  !=  null)  {header  =  rec.values();};    }  }  else  {  header  =  format.getHeader();  }    if  (header  !=  null)  {  for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;    [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map    CSVFormat  format  [VARIABLES]  Lexer  lexer  boolean  List  record  records  Token  reusableToken  CSVRecord  current  rec  result  CSVFormat  format  String[]  header  Map  hdrMap  headerMapping  int  i    	[P15_Unwrap_Block]
[PATCH]  if  (  format.getHeader  (  )  .length  ==  0  )  {  CSVRecord  rec  =  getRecord  (  )  ;  if  (  rec  !=  null  )  {  header  =  rec.values  (  )  ;  }	[BUG]  [BUGGY]  [CE]  illegal  start  of  type  [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  if  (format.getHeader()  !=  null)  {  hdrMap  =  new  HashMap<String,  Integer>();  String[]  header  =  null;  [BUGGY]  [BUGGY]        }  }  else  {  header  =  format.getHeader();  }    if  (header  !=  null)  {  for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;    [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map    CSVFormat  format  [VARIABLES]  Lexer  lexer  boolean  List  record  records  Token  reusableToken  CSVRecord  current  rec  result  CSVFormat  format  String[]  header  Map  hdrMap  headerMapping  int  i    	[P16_Remove_Block]
[PATCH]  header  =  format.getHeader  (  )  ;	[BUG]  [BUGGY]  header  =  format.validate(  )  ;[CE]  incompatible  types  [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  if  (format.getHeader()  !=  null)  {  hdrMap  =  new  HashMap<String,  Integer>();  String[]  header  =  null;  if  (format.getHeader().length  ==  0)  {    CSVRecord  rec  =  getRecord();  if  (rec  !=  null)  {  header  =  rec.values();  }  }  else  {  [BUGGY]  header  =  format.validate(  )  ;  [BUGGY]  }    if  (header  !=  null)  {  for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }    [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map    CSVFormat  format  [VARIABLES]  Lexer  lexer  boolean  List  record  records  Token  reusableToken  CSVRecord  current  rec  result  CSVFormat  format  String[]  header  Map  hdrMap  headerMapping  int  i    	[P7_Replace_Invocation]
[PATCH]  header  =  format.getHeader  (  )  ;	[BUG]  [BUGGY]  header  =  null.getHeader(  )  ;[CE]  <null>  cannot  be  dereferenced  [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  if  (format.getHeader()  !=  null)  {  hdrMap  =  new  HashMap<String,  Integer>();  String[]  header  =  null;  if  (format.getHeader().length  ==  0)  {    CSVRecord  rec  =  getRecord();  if  (rec  !=  null)  {  header  =  rec.values();  }  }  else  {  [BUGGY]  header  =  null.getHeader(  )  ;  [BUGGY]  }    if  (header  !=  null)  {  for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }    [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map    CSVFormat  format  [VARIABLES]  Lexer  lexer  boolean  List  record  records  Token  reusableToken  CSVRecord  current  rec  result  CSVFormat  format  String[]  header  Map  hdrMap  headerMapping  int  i    	[P8_Replace_Mix]
[PATCH]  header  =  format.getHeader  (  )  ;	[BUG]  [BUGGY]  header  =  rec.values(  )  ;header  =  format.getHeader(  )  ;[CE]  cannot  find  symbol  rec  [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  if  (format.getHeader()  !=  null)  {  hdrMap  =  new  HashMap<String,  Integer>();  String[]  header  =  null;  if  (format.getHeader().length  ==  0)  {    CSVRecord  rec  =  getRecord();  if  (rec  !=  null)  {  header  =  rec.values();  }  }  else  {  [BUGGY]  header  =  rec.values(  )  ;header  =  format.getHeader(  )  ;  [BUGGY]  }    if  (header  !=  null)  {  for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }    [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map    CSVFormat  format  [VARIABLES]  Lexer  lexer  boolean  List  record  records  Token  reusableToken  CSVRecord  current  rec  result  CSVFormat  format  String[]  header  Map  hdrMap  headerMapping  int  i    	[P11_Insert_Donor_Statement]
[PATCH]  header  =  format.getHeader  (  )  ;	[BUG]  [BUGGY]  if  (  format.getHeader(  )  !=  null)  {  header  =  format.getHeader(  )  ;  }[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  if  (format.getHeader()  !=  null)  {  hdrMap  =  new  HashMap<String,  Integer>();  String[]  header  =  null;  if  (format.getHeader().length  ==  0)  {    CSVRecord  rec  =  getRecord();  if  (rec  !=  null)  {  header  =  rec.values();  }  }  else  {  [BUGGY]  if  (  format.getHeader(  )  !=  null)  {  header  =  format.getHeader(  )  ;  }  [BUGGY]  }    if  (header  !=  null)  {  for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }    [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map    CSVFormat  format  [VARIABLES]  Lexer  lexer  boolean  List  record  records  Token  reusableToken  CSVRecord  current  rec  result  CSVFormat  format  String[]  header  Map  hdrMap  headerMapping  int  i    	[P12_Insert_Condition]
[PATCH]  header  =  format.getHeader  (  )  ;  }	[BUG]  [BUGGY]  [CE]  illegal  start  of  expression  [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  if  (format.getHeader()  !=  null)  {  hdrMap  =  new  HashMap<String,  Integer>();  String[]  header  =  null;  if  (format.getHeader().length  ==  0)  {    CSVRecord  rec  =  getRecord();  if  (rec  !=  null)  {  header  =  rec.values();  }  }  else  {  [BUGGY]  [BUGGY]        if  (header  !=  null)  {  for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;    [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map    CSVFormat  format  [VARIABLES]  Lexer  lexer  boolean  List  record  records  Token  reusableToken  CSVRecord  current  rec  result  CSVFormat  format  String[]  header  Map  hdrMap  headerMapping  int  i    	[P14_Delete_Statement]
[PATCH]  if  (  rec  !=  null  )  {	[BUG]  [BUGGY]  if  (  rec  ==  null)  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  if  (format.getHeader()  !=  null)  {  hdrMap  =  new  HashMap<String,  Integer>();  String[]  header  =  null;  if  (format.getHeader().length  ==  0)  {    CSVRecord  rec  =  getRecord();  [BUGGY]  if  (  rec  ==  null)  {  [BUGGY]  header  =  rec.values();  }  }  else  {  header  =  format.getHeader();  }    if  (header  !=  null)  {  for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }    [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map    CSVFormat  format  [VARIABLES]  Lexer  lexer  boolean  List  record  records  Token  reusableToken  CSVRecord  current  rec  result  CSVFormat  format  String[]  header  Map  hdrMap  headerMapping  int  i    	[P2_Replace_Operator]
[PATCH]  if  (  rec  !=  null  )  {	[BUG]  [BUGGY]  if  (  result  !=  null)  {[CE]  cannot  find  symbol  result  [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  if  (format.getHeader()  !=  null)  {  hdrMap  =  new  HashMap<String,  Integer>();  String[]  header  =  null;  if  (format.getHeader().length  ==  0)  {    CSVRecord  rec  =  getRecord();  [BUGGY]  if  (  result  !=  null)  {  [BUGGY]  header  =  rec.values();  }  }  else  {  header  =  format.getHeader();  }    if  (header  !=  null)  {  for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }    [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map    CSVFormat  format  [VARIABLES]  Lexer  lexer  boolean  List  record  records  Token  reusableToken  CSVRecord  current  rec  result  CSVFormat  format  String[]  header  Map  hdrMap  headerMapping  int  i    	[P5_Replace_Variable]
[PATCH]  if  (  rec  !=  null  )  {	[BUG]  [BUGGY]  if  (  rec  !=  true)  {[CE]  incomparable  types:  CSVRecord  and  boolean  [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  if  (format.getHeader()  !=  null)  {  hdrMap  =  new  HashMap<String,  Integer>();  String[]  header  =  null;  if  (format.getHeader().length  ==  0)  {    CSVRecord  rec  =  getRecord();  [BUGGY]  if  (  rec  !=  true)  {  [BUGGY]  header  =  rec.values();  }  }  else  {  header  =  format.getHeader();  }    if  (header  !=  null)  {  for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }    [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map    CSVFormat  format  [VARIABLES]  Lexer  lexer  boolean  List  record  records  Token  reusableToken  CSVRecord  current  rec  result  CSVFormat  format  String[]  header  Map  hdrMap  headerMapping  int  i    	[P8_Replace_Mix]
[PATCH]  if  (  rec  !=  null  )  {	[BUG]  [BUGGY]  if  (  header  !=  null)  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  if  (format.getHeader()  !=  null)  {  hdrMap  =  new  HashMap<String,  Integer>();  String[]  header  =  null;  if  (format.getHeader().length  ==  0)  {    CSVRecord  rec  =  getRecord();  [BUGGY]  if  (  header  !=  null)  {  [BUGGY]  header  =  rec.values();  }  }  else  {  header  =  format.getHeader();  }    if  (header  !=  null)  {  for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }    [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map    CSVFormat  format  [VARIABLES]  Lexer  lexer  boolean  List  record  records  Token  reusableToken  CSVRecord  current  rec  result  CSVFormat  format  String[]  header  Map  hdrMap  headerMapping  int  i    	[P9_Replace_Statement]
[PATCH]  if  (  rec  !=  null  )  {	[BUG]  [BUGGY]  if  (  current  ==  null)  {[CE]  cannot  find  symbol  current  [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  if  (format.getHeader()  !=  null)  {  hdrMap  =  new  HashMap<String,  Integer>();  String[]  header  =  null;  if  (format.getHeader().length  ==  0)  {    CSVRecord  rec  =  getRecord();  [BUGGY]  if  (  current  ==  null)  {  [BUGGY]  header  =  rec.values();  }  }  else  {  header  =  format.getHeader();  }    if  (header  !=  null)  {  for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }    [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map    CSVFormat  format  [VARIABLES]  Lexer  lexer  boolean  List  record  records  Token  reusableToken  CSVRecord  current  rec  result  CSVFormat  format  String[]  header  Map  hdrMap  headerMapping  int  i    	[P9_Replace_Statement]
[PATCH]  if  (  rec  !=  null  )  {	[BUG]  [BUGGY]  if  (  next  ==  null)  {[CE]  cannot  find  symbol  next  [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  if  (format.getHeader()  !=  null)  {  hdrMap  =  new  HashMap<String,  Integer>();  String[]  header  =  null;  if  (format.getHeader().length  ==  0)  {    CSVRecord  rec  =  getRecord();  [BUGGY]  if  (  next  ==  null)  {  [BUGGY]  header  =  rec.values();  }  }  else  {  header  =  format.getHeader();  }    if  (header  !=  null)  {  for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }    [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map    CSVFormat  format  [VARIABLES]  Lexer  lexer  boolean  List  record  records  Token  reusableToken  CSVRecord  current  rec  result  CSVFormat  format  String[]  header  Map  hdrMap  headerMapping  int  i    	[P9_Replace_Statement]
[PATCH]  if  (  rec  !=  null  )  {  header  =  rec.values  (  )  ;  }	[BUG]  [BUGGY]  header  =  rec.values();[CE]  illegal  start  of  expression  [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  if  (format.getHeader()  !=  null)  {  hdrMap  =  new  HashMap<String,  Integer>();  String[]  header  =  null;  if  (format.getHeader().length  ==  0)  {    CSVRecord  rec  =  getRecord();  [BUGGY]  header  =  rec.values();  [BUGGY]    header  =  rec.values();  }  else  {  header  =  format.getHeader();  }    if  (header  !=  null)  {  for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;    [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map    CSVFormat  format  [VARIABLES]  Lexer  lexer  boolean  List  record  records  Token  reusableToken  CSVRecord  current  rec  result  CSVFormat  format  String[]  header  Map  hdrMap  headerMapping  int  i    	[P15_Unwrap_Block]
[PATCH]  if  (  rec  !=  null  )  {  header  =  rec.values  (  )  ;  }	[BUG]  [BUGGY]  [CE]  illegal  start  of  expression  [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  if  (format.getHeader()  !=  null)  {  hdrMap  =  new  HashMap<String,  Integer>();  String[]  header  =  null;  if  (format.getHeader().length  ==  0)  {    CSVRecord  rec  =  getRecord();  [BUGGY]  [BUGGY]      }  else  {  header  =  format.getHeader();  }    if  (header  !=  null)  {  for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;    [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map    CSVFormat  format  [VARIABLES]  Lexer  lexer  boolean  List  record  records  Token  reusableToken  CSVRecord  current  rec  result  CSVFormat  format  String[]  header  Map  hdrMap  headerMapping  int  i    	[P16_Remove_Block]
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  (  current)  ==  null)  {      current  =  getNextRecord(  )  ;  }[CE]  illegal  start  of  type  [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  if  (format.getHeader()  !=  null)  {  hdrMap  =  new  HashMap<String,  Integer>();  String[]  header  =  null;  if  (format.getHeader().length  ==  0)  {    CSVRecord  rec  =  getRecord();  [BUGGY]  if  (  (  current)  ==  null)  {      current  =  getNextRecord(  )  ;  }  [BUGGY]  header  =  rec.values();  }  }  else  {  header  =  format.getHeader();  }    if  (header  !=  null)  {  for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }    [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map    CSVFormat  format  [VARIABLES]  Lexer  lexer  boolean  List  record  records  Token  reusableToken  CSVRecord  current  rec  result  CSVFormat  format  String[]  header  Map  hdrMap  headerMapping  int  i    	[P13_Insert_Block]
[PATCH]  header  =  rec.values  (  )  ;	[BUG]  [BUGGY]  header  =  result.values(  )  ;[CE]  cannot  find  symbol  result  [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  if  (format.getHeader()  !=  null)  {  hdrMap  =  new  HashMap<String,  Integer>();  String[]  header  =  null;  if  (format.getHeader().length  ==  0)  {    CSVRecord  rec  =  getRecord();  if  (rec  !=  null)  {  [BUGGY]  header  =  result.values(  )  ;  [BUGGY]  }  }  else  {  header  =  format.getHeader();  }    if  (header  !=  null)  {  for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }    [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map    CSVFormat  format  [VARIABLES]  Lexer  lexer  boolean  List  record  records  Token  reusableToken  CSVRecord  current  rec  result  CSVFormat  format  String[]  header  Map  hdrMap  headerMapping  int  i    	[P5_Replace_Variable]
[PATCH]  header  =  rec.values  (  )  ;	[BUG]  [BUGGY]  header  =  null.values(  )  ;[CE]  <null>  cannot  be  dereferenced  [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  if  (format.getHeader()  !=  null)  {  hdrMap  =  new  HashMap<String,  Integer>();  String[]  header  =  null;  if  (format.getHeader().length  ==  0)  {    CSVRecord  rec  =  getRecord();  if  (rec  !=  null)  {  [BUGGY]  header  =  null.values(  )  ;  [BUGGY]  }  }  else  {  header  =  format.getHeader();  }    if  (header  !=  null)  {  for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }    [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map    CSVFormat  format  [VARIABLES]  Lexer  lexer  boolean  List  record  records  Token  reusableToken  CSVRecord  current  rec  result  CSVFormat  format  String[]  header  Map  hdrMap  headerMapping  int  i    	[P8_Replace_Mix]
[PATCH]  header  =  rec.values  (  )  ;	[BUG]  [BUGGY]  header  =  format.getHeader(  )  ;header  =  rec.values(  )  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  if  (format.getHeader()  !=  null)  {  hdrMap  =  new  HashMap<String,  Integer>();  String[]  header  =  null;  if  (format.getHeader().length  ==  0)  {    CSVRecord  rec  =  getRecord();  if  (rec  !=  null)  {  [BUGGY]  header  =  format.getHeader(  )  ;header  =  rec.values(  )  ;  [BUGGY]  }  }  else  {  header  =  format.getHeader();  }    if  (header  !=  null)  {  for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }    [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map    CSVFormat  format  [VARIABLES]  Lexer  lexer  boolean  List  record  records  Token  reusableToken  CSVRecord  current  rec  result  CSVFormat  format  String[]  header  Map  hdrMap  headerMapping  int  i    	[P11_Insert_Donor_Statement]
[PATCH]  header  =  rec.values  (  )  ;	[BUG]  [BUGGY]  [FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  if  (format.getHeader()  !=  null)  {  hdrMap  =  new  HashMap<String,  Integer>();  String[]  header  =  null;  if  (format.getHeader().length  ==  0)  {    CSVRecord  rec  =  getRecord();  if  (rec  !=  null)  {  [BUGGY]  [BUGGY]    }  }  else  {  header  =  format.getHeader();  }    if  (header  !=  null)  {  for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;    [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map    CSVFormat  format  [VARIABLES]  Lexer  lexer  boolean  List  record  records  Token  reusableToken  CSVRecord  current  rec  result  CSVFormat  format  String[]  header  Map  hdrMap  headerMapping  int  i    	[P14_Delete_Statement]
[PATCH]  CSVRecord  rec  =  getRecord  (  )  ;	[BUG]  [BUGGY]  CSVRecord  rec  =  toString(  )  ;[CE]  incompatible  types  [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  if  (format.getHeader()  !=  null)  {  hdrMap  =  new  HashMap<String,  Integer>();  String[]  header  =  null;  if  (format.getHeader().length  ==  0)  {    [BUGGY]  CSVRecord  rec  =  toString(  )  ;  [BUGGY]  if  (rec  !=  null)  {  header  =  rec.values();  }  }  else  {  header  =  format.getHeader();  }    if  (header  !=  null)  {  for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }    [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map    CSVFormat  format  [VARIABLES]  Lexer  lexer  boolean  List  record  records  Token  reusableToken  CSVRecord  current  rec  result  CSVFormat  format  String[]  header  Map  hdrMap  headerMapping  int  i    	[P7_Replace_Invocation]
[PATCH]  CSVRecord  rec  =  getRecord  (  )  ;	[BUG]  [BUGGY]  List<CSVRecord>  records  =  new  ArrayList<CSVRecord>(  )  ;CSVRecord  rec  =  getRecord(  )  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  if  (format.getHeader()  !=  null)  {  hdrMap  =  new  HashMap<String,  Integer>();  String[]  header  =  null;  if  (format.getHeader().length  ==  0)  {    [BUGGY]  List<CSVRecord>  records  =  new  ArrayList<CSVRecord>(  )  ;CSVRecord  rec  =  getRecord(  )  ;  [BUGGY]  if  (rec  !=  null)  {  header  =  rec.values();  }  }  else  {  header  =  format.getHeader();  }    if  (header  !=  null)  {  for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }    [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map    CSVFormat  format  [VARIABLES]  Lexer  lexer  boolean  List  record  records  Token  reusableToken  CSVRecord  current  rec  result  CSVFormat  format  String[]  header  Map  hdrMap  headerMapping  int  i    	[P11_Insert_Donor_Statement]
[PATCH]  CSVRecord  rec  =  getRecord  (  )  ;	[BUG]  [BUGGY]  [FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  if  (format.getHeader()  !=  null)  {  hdrMap  =  new  HashMap<String,  Integer>();  String[]  header  =  null;  if  (format.getHeader().length  ==  0)  {    [BUGGY]  [BUGGY]    if  (rec  !=  null)  {  header  =  rec.values();  }  }  else  {  header  =  format.getHeader();  }    if  (header  !=  null)  {  for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;    [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map    CSVFormat  format  [VARIABLES]  Lexer  lexer  boolean  List  record  records  Token  reusableToken  CSVRecord  current  rec  result  CSVFormat  format  String[]  header  Map  hdrMap  headerMapping  int  i    	[P14_Delete_Statement]
[PATCH]  CSVRecord  rec  =  getRecord  (  )  ;	[BUG]  [BUGGY]  next  =  getNextRecord(  )  ;CSVRecord  rec  =  getRecord(  )  ;[CE]  cannot  find  symbol  next  [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  if  (format.getHeader()  !=  null)  {  hdrMap  =  new  HashMap<String,  Integer>();  String[]  header  =  null;  if  (format.getHeader().length  ==  0)  {    [BUGGY]  next  =  getNextRecord(  )  ;CSVRecord  rec  =  getRecord(  )  ;  [BUGGY]  if  (rec  !=  null)  {  header  =  rec.values();  }  }  else  {  header  =  format.getHeader();  }    if  (header  !=  null)  {  for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }    [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map    CSVFormat  format  [VARIABLES]  Lexer  lexer  boolean  List  record  records  Token  reusableToken  CSVRecord  current  rec  result  CSVFormat  format  String[]  header  Map  hdrMap  headerMapping  int  i    	[P11_Insert_Donor_Statement]
[PATCH]  CSVRecord  rec  =  getRecord  (  )  ;	[BUG]  [BUGGY]  current  =  getNextRecord(  )  ;CSVRecord  rec  =  getRecord(  )  ;[CE]  cannot  find  symbol  current  [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  if  (format.getHeader()  !=  null)  {  hdrMap  =  new  HashMap<String,  Integer>();  String[]  header  =  null;  if  (format.getHeader().length  ==  0)  {    [BUGGY]  current  =  getNextRecord(  )  ;CSVRecord  rec  =  getRecord(  )  ;  [BUGGY]  if  (rec  !=  null)  {  header  =  rec.values();  }  }  else  {  header  =  format.getHeader();  }    if  (header  !=  null)  {  for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }    [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map    CSVFormat  format  [VARIABLES]  Lexer  lexer  boolean  List  record  records  Token  reusableToken  CSVRecord  current  rec  result  CSVFormat  format  String[]  header  Map  hdrMap  headerMapping  int  i    	[P11_Insert_Donor_Statement]
[PATCH]  CSVRecord  rec  =  getRecord  (  )  ;	[BUG]  [BUGGY]  return  getRecord(  )  ;CSVRecord  rec  =  getRecord(  )  ;[CE]  incompatible  types  [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  if  (format.getHeader()  !=  null)  {  hdrMap  =  new  HashMap<String,  Integer>();  String[]  header  =  null;  if  (format.getHeader().length  ==  0)  {    [BUGGY]  return  getRecord(  )  ;CSVRecord  rec  =  getRecord(  )  ;  [BUGGY]  if  (rec  !=  null)  {  header  =  rec.values();  }  }  else  {  header  =  format.getHeader();  }    if  (header  !=  null)  {  for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }    [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map    CSVFormat  format  [VARIABLES]  Lexer  lexer  boolean  List  record  records  Token  reusableToken  CSVRecord  current  rec  result  CSVFormat  format  String[]  header  Map  hdrMap  headerMapping  int  i    	[P11_Insert_Donor_Statement]
[PATCH]  if  (  rec  !=  null  )  {	[BUG]  [BUGGY]  if  (  rec  !=  false)  {[CE]  incomparable  types:  CSVRecord  and  boolean  [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  if  (format.getHeader()  !=  null)  {  hdrMap  =  new  HashMap<String,  Integer>();  String[]  header  =  null;  if  (format.getHeader().length  ==  0)  {    CSVRecord  rec  =  getRecord();  [BUGGY]  if  (  rec  !=  false)  {  [BUGGY]  header  =  rec.values();  }  }  else  {  header  =  format.getHeader();  }    if  (header  !=  null)  {  for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }    [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map    CSVFormat  format  [VARIABLES]  Lexer  lexer  boolean  List  record  records  Token  reusableToken  CSVRecord  current  rec  result  CSVFormat  format  String[]  header  Map  hdrMap  headerMapping  int  i    	[P8_Replace_Mix]
[PATCH]  if  (  header  !=  null  )  {	[BUG]  [BUGGY]  if  (  header  ==  null)  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  if  (format.getHeader()  !=  null)  {  hdrMap  =  new  HashMap<String,  Integer>();  String[]  header  =  null;  if  (format.getHeader().length  ==  0)  {    CSVRecord  rec  =  getRecord();  if  (rec  !=  null)  {  header  =  rec.values();  }  }  else  {  header  =  format.getHeader();  }    [BUGGY]  if  (  header  ==  null)  {  [BUGGY]  for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }    [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map    CSVFormat  format  [VARIABLES]  Lexer  lexer  boolean  List  record  records  Token  reusableToken  CSVRecord  current  rec  result  CSVFormat  format  String[]  header  Map  hdrMap  headerMapping  int  i    	[P2_Replace_Operator]
[PATCH]  if  (  header  !=  null  )  {	[BUG]  [BUGGY]  if  (  i  <  header.length)  {[CE]  cannot  find  symbol  i  [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  if  (format.getHeader()  !=  null)  {  hdrMap  =  new  HashMap<String,  Integer>();  String[]  header  =  null;  if  (format.getHeader().length  ==  0)  {    CSVRecord  rec  =  getRecord();  if  (rec  !=  null)  {  header  =  rec.values();  }  }  else  {  header  =  format.getHeader();  }    [BUGGY]  if  (  i  <  header.length)  {  [BUGGY]  for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }    [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map    CSVFormat  format  [VARIABLES]  Lexer  lexer  boolean  List  record  records  Token  reusableToken  CSVRecord  current  rec  result  CSVFormat  format  String[]  header  Map  hdrMap  headerMapping  int  i    	[P6_Replace_Expression]
[PATCH]  if  (  header  !=  null  )  {	[BUG]  [BUGGY]  if  (  header  !=  true)  {[CE]  incomparable  types:  String[]  and  boolean  [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  if  (format.getHeader()  !=  null)  {  hdrMap  =  new  HashMap<String,  Integer>();  String[]  header  =  null;  if  (format.getHeader().length  ==  0)  {    CSVRecord  rec  =  getRecord();  if  (rec  !=  null)  {  header  =  rec.values();  }  }  else  {  header  =  format.getHeader();  }    [BUGGY]  if  (  header  !=  true)  {  [BUGGY]  for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }    [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map    CSVFormat  format  [VARIABLES]  Lexer  lexer  boolean  List  record  records  Token  reusableToken  CSVRecord  current  rec  result  CSVFormat  format  String[]  header  Map  hdrMap  headerMapping  int  i    	[P8_Replace_Mix]
[PATCH]  if  (  header  !=  null  )  {	[BUG]  [BUGGY]  if  (  current  ==  null)  {[CE]  cannot  find  symbol  current  [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  if  (format.getHeader()  !=  null)  {  hdrMap  =  new  HashMap<String,  Integer>();  String[]  header  =  null;  if  (format.getHeader().length  ==  0)  {    CSVRecord  rec  =  getRecord();  if  (rec  !=  null)  {  header  =  rec.values();  }  }  else  {  header  =  format.getHeader();  }    [BUGGY]  if  (  current  ==  null)  {  [BUGGY]  for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }    [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map    CSVFormat  format  [VARIABLES]  Lexer  lexer  boolean  List  record  records  Token  reusableToken  CSVRecord  current  rec  result  CSVFormat  format  String[]  header  Map  hdrMap  headerMapping  int  i    	[P9_Replace_Statement]
[PATCH]  if  (  header  !=  null  )  {	[BUG]  [BUGGY]  if  (  rec  !=  null)  {[CE]  cannot  find  symbol  rec  [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  if  (format.getHeader()  !=  null)  {  hdrMap  =  new  HashMap<String,  Integer>();  String[]  header  =  null;  if  (format.getHeader().length  ==  0)  {    CSVRecord  rec  =  getRecord();  if  (rec  !=  null)  {  header  =  rec.values();  }  }  else  {  header  =  format.getHeader();  }    [BUGGY]  if  (  rec  !=  null)  {  [BUGGY]  for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }    [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map    CSVFormat  format  [VARIABLES]  Lexer  lexer  boolean  List  record  records  Token  reusableToken  CSVRecord  current  rec  result  CSVFormat  format  String[]  header  Map  hdrMap  headerMapping  int  i    	[P9_Replace_Statement]
[PATCH]  if  (  header  !=  null  )  {	[BUG]  [BUGGY]  if  (  next  ==  null)  {[CE]  cannot  find  symbol  next  [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  if  (format.getHeader()  !=  null)  {  hdrMap  =  new  HashMap<String,  Integer>();  String[]  header  =  null;  if  (format.getHeader().length  ==  0)  {    CSVRecord  rec  =  getRecord();  if  (rec  !=  null)  {  header  =  rec.values();  }  }  else  {  header  =  format.getHeader();  }    [BUGGY]  if  (  next  ==  null)  {  [BUGGY]  for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }    [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map    CSVFormat  format  [VARIABLES]  Lexer  lexer  boolean  List  record  records  Token  reusableToken  CSVRecord  current  rec  result  CSVFormat  format  String[]  header  Map  hdrMap  headerMapping  int  i    	[P9_Replace_Statement]
[PATCH]  if  (  header  !=  null  )  {  for  (  int  i  =  0;  i  <  header.length;  i++  )  {  hdrMap.put  (  header[i],  Integer.valueOf  (  i  )  )  ;  }	[BUG]  [BUGGY]  for(int  i  =  0;  i  <(header.length);  i++)  {    hdrMap.put(header[i],  java.lang.Integer.valueOf(i));};[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  if  (format.getHeader()  !=  null)  {  hdrMap  =  new  HashMap<String,  Integer>();  String[]  header  =  null;  if  (format.getHeader().length  ==  0)  {    CSVRecord  rec  =  getRecord();  if  (rec  !=  null)  {  header  =  rec.values();  }  }  else  {  header  =  format.getHeader();  }    [BUGGY]  for(int  i  =  0;  i  <(header.length);  i++)  {    hdrMap.put(header[i],  java.lang.Integer.valueOf(i));};  [BUGGY]    for  (int  i  =  0;  i  <  (header.length);  i++)  {hdrMap.put(header[i],  java.lang.Integer.valueOf(i));};    }  }  return  hdrMap;    [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map    CSVFormat  format  [VARIABLES]  Lexer  lexer  boolean  List  record  records  Token  reusableToken  CSVRecord  current  rec  result  CSVFormat  format  String[]  header  Map  hdrMap  headerMapping  int  i    	[P15_Unwrap_Block]
[PATCH]  if  (  header  !=  null  )  {  for  (  int  i  =  0;  i  <  header.length;  i++  )  {  hdrMap.put  (  header[i],  Integer.valueOf  (  i  )  )  ;  }	[BUG]  [BUGGY]  [FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  if  (format.getHeader()  !=  null)  {  hdrMap  =  new  HashMap<String,  Integer>();  String[]  header  =  null;  if  (format.getHeader().length  ==  0)  {    CSVRecord  rec  =  getRecord();  if  (rec  !=  null)  {  header  =  rec.values();  }  }  else  {  header  =  format.getHeader();  }    [BUGGY]  [BUGGY]      }  }  return  hdrMap;    [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map    CSVFormat  format  [VARIABLES]  Lexer  lexer  boolean  List  record  records  Token  reusableToken  CSVRecord  current  rec  result  CSVFormat  format  String[]  header  Map  hdrMap  headerMapping  int  i    	[P16_Remove_Block]
[PATCH]  for  (  int  i  =  0;  i  <  header.length;  i++  )  {	[BUG]  [BUGGY]  for  (  long  i  =  0;  i  <  header.length;  i++)  {[CE]  possible  loss  of  precision  [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  if  (format.getHeader()  !=  null)  {  hdrMap  =  new  HashMap<String,  Integer>();  String[]  header  =  null;  if  (format.getHeader().length  ==  0)  {    CSVRecord  rec  =  getRecord();  if  (rec  !=  null)  {  header  =  rec.values();  }  }  else  {  header  =  format.getHeader();  }    if  (header  !=  null)  {  [BUGGY]  for  (  long  i  =  0;  i  <  header.length;  i++)  {  [BUGGY]  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }    [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map    CSVFormat  format  [VARIABLES]  Lexer  lexer  boolean  List  record  records  Token  reusableToken  CSVRecord  current  rec  result  CSVFormat  format  String[]  header  Map  hdrMap  headerMapping  int  i    	[P1_Replace_Type]
[PATCH]  for  (  int  i  =  0;  i  <  header.length;  i++  )  {	[BUG]  [BUGGY]  for  (  int  i  =  0;  i  <=  header.length;  i++)  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  if  (format.getHeader()  !=  null)  {  hdrMap  =  new  HashMap<String,  Integer>();  String[]  header  =  null;  if  (format.getHeader().length  ==  0)  {    CSVRecord  rec  =  getRecord();  if  (rec  !=  null)  {  header  =  rec.values();  }  }  else  {  header  =  format.getHeader();  }    if  (header  !=  null)  {  [BUGGY]  for  (  int  i  =  0;  i  <=  header.length;  i++)  {  [BUGGY]  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }    [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map    CSVFormat  format  [VARIABLES]  Lexer  lexer  boolean  List  record  records  Token  reusableToken  CSVRecord  current  rec  result  CSVFormat  format  String[]  header  Map  hdrMap  headerMapping  int  i    	[P2_Replace_Operator]
[PATCH]  for  (  int  i  =  0;  i  <  header.length;  i++  )  {	[BUG]  [BUGGY]  for  (  int  i  =  1;  i  <  header.length;  i++)  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  if  (format.getHeader()  !=  null)  {  hdrMap  =  new  HashMap<String,  Integer>();  String[]  header  =  null;  if  (format.getHeader().length  ==  0)  {    CSVRecord  rec  =  getRecord();  if  (rec  !=  null)  {  header  =  rec.values();  }  }  else  {  header  =  format.getHeader();  }    if  (header  !=  null)  {  [BUGGY]  for  (  int  i  =  1;  i  <  header.length;  i++)  {  [BUGGY]  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }    [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map    CSVFormat  format  [VARIABLES]  Lexer  lexer  boolean  List  record  records  Token  reusableToken  CSVRecord  current  rec  result  CSVFormat  format  String[]  header  Map  hdrMap  headerMapping  int  i    	[P3_Replace_Literal]
[PATCH]  for  (  int  i  =  0;  i  <  header.length;  i++  )  {	[BUG]  [BUGGY]  for  (  header.lengthnt  i  =  0;  i  <  i;  i++)  {[CE]  package  header  does  not  exist  [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  if  (format.getHeader()  !=  null)  {  hdrMap  =  new  HashMap<String,  Integer>();  String[]  header  =  null;  if  (format.getHeader().length  ==  0)  {    CSVRecord  rec  =  getRecord();  if  (rec  !=  null)  {  header  =  rec.values();  }  }  else  {  header  =  format.getHeader();  }    if  (header  !=  null)  {  [BUGGY]  for  (  header.lengthnt  i  =  0;  i  <  i;  i++)  {  [BUGGY]  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }    [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map    CSVFormat  format  [VARIABLES]  Lexer  lexer  boolean  List  record  records  Token  reusableToken  CSVRecord  current  rec  result  CSVFormat  format  String[]  header  Map  hdrMap  headerMapping  int  i    	[P5_Replace_Variable]
[PATCH]  for  (  int  i  =  0;  i  <  header.length;  i++  )  {	[BUG]  [BUGGY]  for  (  int  i  =  0;  i  <  header.length.length;  i++)  {[CE]  int  cannot  be  dereferenced  [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  if  (format.getHeader()  !=  null)  {  hdrMap  =  new  HashMap<String,  Integer>();  String[]  header  =  null;  if  (format.getHeader().length  ==  0)  {    CSVRecord  rec  =  getRecord();  if  (rec  !=  null)  {  header  =  rec.values();  }  }  else  {  header  =  format.getHeader();  }    if  (header  !=  null)  {  [BUGGY]  for  (  int  i  =  0;  i  <  header.length.length;  i++)  {  [BUGGY]  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }    [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map    CSVFormat  format  [VARIABLES]  Lexer  lexer  boolean  List  record  records  Token  reusableToken  CSVRecord  current  rec  result  CSVFormat  format  String[]  header  Map  hdrMap  headerMapping  int  i    	[P5_Replace_Variable]
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  header  !=  null)  {      for  (  int  i  =  0;  i  <  (  header.length)  ;  i++)  {          hdrMap.put(  header[i],  valueOf(  i)  )  ;      }  }[CE]  illegal  start  of  type  [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  if  (format.getHeader()  !=  null)  {  hdrMap  =  new  HashMap<String,  Integer>();  String[]  header  =  null;  if  (format.getHeader().length  ==  0)  {    CSVRecord  rec  =  getRecord();  if  (rec  !=  null)  {  header  =  rec.values();  }  }  else  {  header  =  format.getHeader();  }    if  (header  !=  null)  {  [BUGGY]  if  (  header  !=  null)  {      for  (  int  i  =  0;  i  <  (  header.length)  ;  i++)  {          hdrMap.put(  header[i],  valueOf(  i)  )  ;      }  }  [BUGGY]  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }    [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map    CSVFormat  format  [VARIABLES]  Lexer  lexer  boolean  List  record  records  Token  reusableToken  CSVRecord  current  rec  result  CSVFormat  format  String[]  header  Map  hdrMap  headerMapping  int  i    	[P13_Insert_Block]
[PATCH]  hdrMap.put  (  header[i],  Integer.valueOf  (  i  )  )  ;	[BUG]  [BUGGY]  [FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  if  (format.getHeader()  !=  null)  {  hdrMap  =  new  HashMap<String,  Integer>();  String[]  header  =  null;  if  (format.getHeader().length  ==  0)  {    CSVRecord  rec  =  getRecord();  if  (rec  !=  null)  {  header  =  rec.values();  }  }  else  {  header  =  format.getHeader();  }    if  (header  !=  null)  {  for  (int  i  =  0;  i  <  header.length;  i++)  {  [BUGGY]  [BUGGY]    }  }  }  return  hdrMap;    [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map    CSVFormat  format  [VARIABLES]  Lexer  lexer  boolean  List  record  records  Token  reusableToken  CSVRecord  current  rec  result  CSVFormat  format  String[]  header  Map  hdrMap  headerMapping  int  i    	[P14_Delete_Statement]
[PATCH]  for  (  int  i  =  0;  i  <  header.length;  i++  )  {	[BUG]  [BUGGY]  for  (  int  i  =  i;  i  <  header.length;  i++)  {[CE]  variable  i  might  not  have  been  initialized  [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  if  (format.getHeader()  !=  null)  {  hdrMap  =  new  HashMap<String,  Integer>();  String[]  header  =  null;  if  (format.getHeader().length  ==  0)  {    CSVRecord  rec  =  getRecord();  if  (rec  !=  null)  {  header  =  rec.values();  }  }  else  {  header  =  format.getHeader();  }    if  (header  !=  null)  {  [BUGGY]  for  (  int  i  =  i;  i  <  header.length;  i++)  {  [BUGGY]  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }    [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map    CSVFormat  format  [VARIABLES]  Lexer  lexer  boolean  List  record  records  Token  reusableToken  CSVRecord  current  rec  result  CSVFormat  format  String[]  header  Map  hdrMap  headerMapping  int  i    	[P3_Replace_Literal]
[PATCH]  for  (  int  i  =  0;  i  <  header.length;  i++  )  {	[BUG]  [BUGGY]  for  (  short  i  =  0;  i  <  header.length;  i++)  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  if  (format.getHeader()  !=  null)  {  hdrMap  =  new  HashMap<String,  Integer>();  String[]  header  =  null;  if  (format.getHeader().length  ==  0)  {    CSVRecord  rec  =  getRecord();  if  (rec  !=  null)  {  header  =  rec.values();  }  }  else  {  header  =  format.getHeader();  }    if  (header  !=  null)  {  [BUGGY]  for  (  short  i  =  0;  i  <  header.length;  i++)  {  [BUGGY]  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }    [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map    CSVFormat  format  [VARIABLES]  Lexer  lexer  boolean  List  record  records  Token  reusableToken  CSVRecord  current  rec  result  CSVFormat  format  String[]  header  Map  hdrMap  headerMapping  int  i    	[P1_Replace_Type]
[PATCH]  for  (  int  i  =  0;  i  <  header.length;  i++  )  {	[BUG]  [BUGGY]  for  (  int  i  =  5;  i  <  header.length;  i++)  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  if  (format.getHeader()  !=  null)  {  hdrMap  =  new  HashMap<String,  Integer>();  String[]  header  =  null;  if  (format.getHeader().length  ==  0)  {    CSVRecord  rec  =  getRecord();  if  (rec  !=  null)  {  header  =  rec.values();  }  }  else  {  header  =  format.getHeader();  }    if  (header  !=  null)  {  [BUGGY]  for  (  int  i  =  5;  i  <  header.length;  i++)  {  [BUGGY]  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }    [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map    CSVFormat  format  [VARIABLES]  Lexer  lexer  boolean  List  record  records  Token  reusableToken  CSVRecord  current  rec  result  CSVFormat  format  String[]  header  Map  hdrMap  headerMapping  int  i    	[P3_Replace_Literal]
[PATCH]  for  (  int  i  =  0;  i  <  header.length;  i++  )  {	[BUG]  [BUGGY]  for  (  headernt  i  =  0;  i  <  i.length;  i++)  {[CE]  cannot  find  symbol  [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  if  (format.getHeader()  !=  null)  {  hdrMap  =  new  HashMap<String,  Integer>();  String[]  header  =  null;  if  (format.getHeader().length  ==  0)  {    CSVRecord  rec  =  getRecord();  if  (rec  !=  null)  {  header  =  rec.values();  }  }  else  {  header  =  format.getHeader();  }    if  (header  !=  null)  {  [BUGGY]  for  (  headernt  i  =  0;  i  <  i.length;  i++)  {  [BUGGY]  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }    [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map    CSVFormat  format  [VARIABLES]  Lexer  lexer  boolean  List  record  records  Token  reusableToken  CSVRecord  current  rec  result  CSVFormat  format  String[]  header  Map  hdrMap  headerMapping  int  i    	[P5_Replace_Variable]
[PATCH]  hdrMap.put  (  header[i],  Integer.valueOf  (  i  )  )  ;	[BUG]  [BUGGY]  hdrMap.put(  i[i],  Integer.valueOf(  header)  )  ;[CE]  array  required,  but  int  found  [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  if  (format.getHeader()  !=  null)  {  hdrMap  =  new  HashMap<String,  Integer>();  String[]  header  =  null;  if  (format.getHeader().length  ==  0)  {    CSVRecord  rec  =  getRecord();  if  (rec  !=  null)  {  header  =  rec.values();  }  }  else  {  header  =  format.getHeader();  }    if  (header  !=  null)  {  for  (int  i  =  0;  i  <  header.length;  i++)  {  [BUGGY]  hdrMap.put(  i[i],  Integer.valueOf(  header)  )  ;  [BUGGY]  }  }  }  return  hdrMap;  }    [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map    CSVFormat  format  [VARIABLES]  Lexer  lexer  boolean  List  record  records  Token  reusableToken  CSVRecord  current  rec  result  CSVFormat  format  String[]  header  Map  hdrMap  headerMapping  int  i    	[P5_Replace_Variable]
[PATCH]  hdrMap  =  new  HashMap<String,  Integer>  (  )  ;	[BUG]  [BUGGY]  hdrMap  =  null  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  if  (format.getHeader()  !=  null)  {  [BUGGY]  hdrMap  =  null  ;  [BUGGY]    String[]  header  =  null;  if  (format.getHeader().length  ==  0)  {    CSVRecord  rec  =  getRecord();  if  (rec  !=  null)  {  header  =  rec.values();  }  }  else  {  header  =  format.getHeader();  }    if  (header  !=  null)  {  for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }    [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map    CSVFormat  format  [VARIABLES]  Lexer  lexer  boolean  List  record  records  Token  reusableToken  CSVRecord  current  rec  result  CSVFormat  format  String[]  header  Map  hdrMap  headerMapping  int  i    	[P8_Replace_Mix]
[PATCH]  for  (  int  i  =  0;  i  <  header.length;  i++  )  {	[BUG]  [BUGGY]  for  (  int  i  =  8;  i  <  header.length;  i++)  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  if  (format.getHeader()  !=  null)  {  hdrMap  =  new  HashMap<String,  Integer>();  String[]  header  =  null;  if  (format.getHeader().length  ==  0)  {    CSVRecord  rec  =  getRecord();  if  (rec  !=  null)  {  header  =  rec.values();  }  }  else  {  header  =  format.getHeader();  }    if  (header  !=  null)  {  [BUGGY]  for  (  int  i  =  8;  i  <  header.length;  i++)  {  [BUGGY]  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }    [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map    CSVFormat  format  [VARIABLES]  Lexer  lexer  boolean  List  record  records  Token  reusableToken  CSVRecord  current  rec  result  CSVFormat  format  String[]  header  Map  hdrMap  headerMapping  int  i    	[P3_Replace_Literal]
[PATCH]  if  (  format.getHeader  (  )  .length  ==  0  )  {	[BUG]  [BUGGY]  if  (  format.getHeader(  ).length  <=  0)  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  if  (format.getHeader()  !=  null)  {  hdrMap  =  new  HashMap<String,  Integer>();  String[]  header  =  null;  [BUGGY]  if  (  format.getHeader(  ).length  <=  0)  {  [BUGGY]    CSVRecord  rec  =  getRecord();  if  (rec  !=  null)  {  header  =  rec.values();  }  }  else  {  header  =  format.getHeader();  }    if  (header  !=  null)  {  for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }    [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map    CSVFormat  format  [VARIABLES]  Lexer  lexer  boolean  List  record  records  Token  reusableToken  CSVRecord  current  rec  result  CSVFormat  format  String[]  header  Map  hdrMap  headerMapping  int  i    	[P2_Replace_Operator]
[PATCH]  if  (  format.getHeader  (  )  .length  ==  0  )  {	[BUG]  [BUGGY]  if  (  format.getHeader(  ).length  ==  0  )  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  if  (format.getHeader()  !=  null)  {  hdrMap  =  new  HashMap<String,  Integer>();  String[]  header  =  null;  [BUGGY]  if  (  format.getHeader(  ).length  ==  0  )  {  [BUGGY]    CSVRecord  rec  =  getRecord();  if  (rec  !=  null)  {  header  =  rec.values();  }  }  else  {  header  =  format.getHeader();  }    if  (header  !=  null)  {  for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }    [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map    CSVFormat  format  [VARIABLES]  Lexer  lexer  boolean  List  record  records  Token  reusableToken  CSVRecord  current  rec  result  CSVFormat  format  String[]  header  Map  hdrMap  headerMapping  int  i    	[P8_Replace_Mix]
[PATCH]  if  (  header  !=  null  )  {	[BUG]  [BUGGY]  if  (  header  !=  false)  {[CE]  incomparable  types:  String[]  and  boolean  [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  if  (format.getHeader()  !=  null)  {  hdrMap  =  new  HashMap<String,  Integer>();  String[]  header  =  null;  if  (format.getHeader().length  ==  0)  {    CSVRecord  rec  =  getRecord();  if  (rec  !=  null)  {  header  =  rec.values();  }  }  else  {  header  =  format.getHeader();  }    [BUGGY]  if  (  header  !=  false)  {  [BUGGY]  for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }    [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map    CSVFormat  format  [VARIABLES]  Lexer  lexer  boolean  List  record  records  Token  reusableToken  CSVRecord  current  rec  result  CSVFormat  format  String[]  header  Map  hdrMap  headerMapping  int  i    	[P8_Replace_Mix]
[PATCH]  for  (  int  i  =  0;  i  <  header.length;  i++  )  {	[BUG]  [BUGGY]  for  (  int  i  =  0;  i  >  header.length;  i++)  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  if  (format.getHeader()  !=  null)  {  hdrMap  =  new  HashMap<String,  Integer>();  String[]  header  =  null;  if  (format.getHeader().length  ==  0)  {    CSVRecord  rec  =  getRecord();  if  (rec  !=  null)  {  header  =  rec.values();  }  }  else  {  header  =  format.getHeader();  }    if  (header  !=  null)  {  [BUGGY]  for  (  int  i  =  0;  i  >  header.length;  i++)  {  [BUGGY]  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }    [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map    CSVFormat  format  [VARIABLES]  Lexer  lexer  boolean  List  record  records  Token  reusableToken  CSVRecord  current  rec  result  CSVFormat  format  String[]  header  Map  hdrMap  headerMapping  int  i    	[P2_Replace_Operator]
[PATCH]  for  (  int  i  =  0;  i  <  header.length;  i++  )  {	[BUG]  [BUGGY]  for  (  int  i  =  -6;  i  <  header.length;  i++)  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  if  (format.getHeader()  !=  null)  {  hdrMap  =  new  HashMap<String,  Integer>();  String[]  header  =  null;  if  (format.getHeader().length  ==  0)  {    CSVRecord  rec  =  getRecord();  if  (rec  !=  null)  {  header  =  rec.values();  }  }  else  {  header  =  format.getHeader();  }    if  (header  !=  null)  {  [BUGGY]  for  (  int  i  =  -6;  i  <  header.length;  i++)  {  [BUGGY]  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }    [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map    CSVFormat  format  [VARIABLES]  Lexer  lexer  boolean  List  record  records  Token  reusableToken  CSVRecord  current  rec  result  CSVFormat  format  String[]  header  Map  hdrMap  headerMapping  int  i    	[P3_Replace_Literal]
[PATCH]  for  (  int  i  =  0;  i  <  header.length;  i++  )  {	[BUG]  [BUGGY]  for  (  int  i  =  -5;  i  <  header.length;  i++)  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  if  (format.getHeader()  !=  null)  {  hdrMap  =  new  HashMap<String,  Integer>();  String[]  header  =  null;  if  (format.getHeader().length  ==  0)  {    CSVRecord  rec  =  getRecord();  if  (rec  !=  null)  {  header  =  rec.values();  }  }  else  {  header  =  format.getHeader();  }    if  (header  !=  null)  {  [BUGGY]  for  (  int  i  =  -5;  i  <  header.length;  i++)  {  [BUGGY]  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }    [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map    CSVFormat  format  [VARIABLES]  Lexer  lexer  boolean  List  record  records  Token  reusableToken  CSVRecord  current  rec  result  CSVFormat  format  String[]  header  Map  hdrMap  headerMapping  int  i    	[P3_Replace_Literal]
[PATCH]  hdrMap  =  new  HashMap<String,  Integer>  (  )  ;	[BUG]  [BUGGY]  hdrMap  =  hdrMap  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  if  (format.getHeader()  !=  null)  {  [BUGGY]  hdrMap  =  hdrMap  ;  [BUGGY]    String[]  header  =  null;  if  (format.getHeader().length  ==  0)  {    CSVRecord  rec  =  getRecord();  if  (rec  !=  null)  {  header  =  rec.values();  }  }  else  {  header  =  format.getHeader();  }    if  (header  !=  null)  {  for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }    [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map    CSVFormat  format  [VARIABLES]  Lexer  lexer  boolean  List  record  records  Token  reusableToken  CSVRecord  current  rec  result  CSVFormat  format  String[]  header  Map  hdrMap  headerMapping  int  i    	[P8_Replace_Mix]
[PATCH]  for  (  int  i  =  0;  i  <  header.length;  i++  )  {	[BUG]  [BUGGY]  for  (  int  i  =  2;  i  <  header.length;  i++)  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  if  (format.getHeader()  !=  null)  {  hdrMap  =  new  HashMap<String,  Integer>();  String[]  header  =  null;  if  (format.getHeader().length  ==  0)  {    CSVRecord  rec  =  getRecord();  if  (rec  !=  null)  {  header  =  rec.values();  }  }  else  {  header  =  format.getHeader();  }    if  (header  !=  null)  {  [BUGGY]  for  (  int  i  =  2;  i  <  header.length;  i++)  {  [BUGGY]  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }    [CLASS]  CSVParser  1  [METHOD]  initializeHeader  [RETURN_TYPE]  Map    CSVFormat  format  [VARIABLES]  Lexer  lexer  boolean  List  record  records  Token  reusableToken  CSVRecord  current  rec  result  CSVFormat  format  String[]  header  Map  hdrMap  headerMapping  int  i    	[P3_Replace_Literal]
[PATCH]  if  (  current  ==  null  )  {	[BUG]  [BUGGY]  if  (  current  !=  null)  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  }  }  }  return  hdrMap;  }          public  Iterator<CSVRecord>  iterator()  {  return  new  Iterator<CSVRecord>()  {  private  CSVRecord  current;  public  boolean  hasNext()  {  [BUGGY]  if  (  current  !=  null)  {  [BUGGY]  current  =  getNextRecord();  }  return  current  !=  null;  }  public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;  if  (next  ==  null)  {    next  =  getNextRecord();  if  (next  ==  null)  {  throw  new  NoSuchElementException( "No  more  CSV  records  available ");    [CLASS]  CSVParser  1  [METHOD]  iterator  [RETURN_TYPE]  Iterator    [VARIABLES]  Lexer  lexer  boolean  List  record  records  Token  reusableToken  CSVRecord  current  next  rec  result  IOException  e  Map  hdrMap  headerMapping    	[P2_Replace_Operator]
[PATCH]  if  (  current  ==  null  )  {	[BUG]  [BUGGY]  if  (  result  ==  null)  {[CE]  cannot  find  symbol  result  [CONTEXT]  }  }  }  return  hdrMap;  }          public  Iterator<CSVRecord>  iterator()  {  return  new  Iterator<CSVRecord>()  {  private  CSVRecord  current;  public  boolean  hasNext()  {  [BUGGY]  if  (  result  ==  null)  {  [BUGGY]  current  =  getNextRecord();  }  return  current  !=  null;  }  public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;  if  (next  ==  null)  {    next  =  getNextRecord();  if  (next  ==  null)  {  throw  new  NoSuchElementException( "No  more  CSV  records  available ");    [CLASS]  CSVParser  1  [METHOD]  iterator  [RETURN_TYPE]  Iterator    [VARIABLES]  Lexer  lexer  boolean  List  record  records  Token  reusableToken  CSVRecord  current  next  rec  result  IOException  e  Map  hdrMap  headerMapping    	[P5_Replace_Variable]
[PATCH]  if  (  current  ==  null  )  {	[BUG]  [BUGGY]  if  (  current  ==  true)  {[CE]  incomparable  types:  CSVRecord  and  boolean  [CONTEXT]  }  }  }  return  hdrMap;  }          public  Iterator<CSVRecord>  iterator()  {  return  new  Iterator<CSVRecord>()  {  private  CSVRecord  current;  public  boolean  hasNext()  {  [BUGGY]  if  (  current  ==  true)  {  [BUGGY]  current  =  getNextRecord();  }  return  current  !=  null;  }  public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;  if  (next  ==  null)  {    next  =  getNextRecord();  if  (next  ==  null)  {  throw  new  NoSuchElementException( "No  more  CSV  records  available ");    [CLASS]  CSVParser  1  [METHOD]  iterator  [RETURN_TYPE]  Iterator    [VARIABLES]  Lexer  lexer  boolean  List  record  records  Token  reusableToken  CSVRecord  current  next  rec  result  IOException  e  Map  hdrMap  headerMapping    	[P8_Replace_Mix]
[PATCH]  if  (  current  ==  null  )  {	[BUG]  [BUGGY]  if  (  header  !=  null)  {[CE]  cannot  find  symbol  header  [CONTEXT]  }  }  }  return  hdrMap;  }          public  Iterator<CSVRecord>  iterator()  {  return  new  Iterator<CSVRecord>()  {  private  CSVRecord  current;  public  boolean  hasNext()  {  [BUGGY]  if  (  header  !=  null)  {  [BUGGY]  current  =  getNextRecord();  }  return  current  !=  null;  }  public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;  if  (next  ==  null)  {    next  =  getNextRecord();  if  (next  ==  null)  {  throw  new  NoSuchElementException( "No  more  CSV  records  available ");    [CLASS]  CSVParser  1  [METHOD]  iterator  [RETURN_TYPE]  Iterator    [VARIABLES]  Lexer  lexer  boolean  List  record  records  Token  reusableToken  CSVRecord  current  next  rec  result  IOException  e  Map  hdrMap  headerMapping    	[P9_Replace_Statement]
[PATCH]  if  (  current  ==  null  )  {	[BUG]  [BUGGY]  if  (  rec  !=  null)  {[CE]  cannot  find  symbol  rec  [CONTEXT]  }  }  }  return  hdrMap;  }          public  Iterator<CSVRecord>  iterator()  {  return  new  Iterator<CSVRecord>()  {  private  CSVRecord  current;  public  boolean  hasNext()  {  [BUGGY]  if  (  rec  !=  null)  {  [BUGGY]  current  =  getNextRecord();  }  return  current  !=  null;  }  public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;  if  (next  ==  null)  {    next  =  getNextRecord();  if  (next  ==  null)  {  throw  new  NoSuchElementException( "No  more  CSV  records  available ");    [CLASS]  CSVParser  1  [METHOD]  iterator  [RETURN_TYPE]  Iterator    [VARIABLES]  Lexer  lexer  boolean  List  record  records  Token  reusableToken  CSVRecord  current  next  rec  result  IOException  e  Map  hdrMap  headerMapping    	[P9_Replace_Statement]
[PATCH]  if  (  current  ==  null  )  {	[BUG]  [BUGGY]  if  (  next  ==  null)  {[CE]  cannot  find  symbol  next  [CONTEXT]  }  }  }  return  hdrMap;  }          public  Iterator<CSVRecord>  iterator()  {  return  new  Iterator<CSVRecord>()  {  private  CSVRecord  current;  public  boolean  hasNext()  {  [BUGGY]  if  (  next  ==  null)  {  [BUGGY]  current  =  getNextRecord();  }  return  current  !=  null;  }  public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;  if  (next  ==  null)  {    next  =  getNextRecord();  if  (next  ==  null)  {  throw  new  NoSuchElementException( "No  more  CSV  records  available ");    [CLASS]  CSVParser  1  [METHOD]  iterator  [RETURN_TYPE]  Iterator    [VARIABLES]  Lexer  lexer  boolean  List  record  records  Token  reusableToken  CSVRecord  current  next  rec  result  IOException  e  Map  hdrMap  headerMapping    	[P9_Replace_Statement]
[PATCH]  if  (  current  ==  null  )  {  current  =  getNextRecord  (  )  ;  }	[BUG]  [BUGGY]  current  =  getNextRecord();[CE]  illegal  start  of  expression  [CONTEXT]  }  }  }  return  hdrMap;  }          public  Iterator<CSVRecord>  iterator()  {  return  new  Iterator<CSVRecord>()  {  private  CSVRecord  current;  public  boolean  hasNext()  {  [BUGGY]  current  =  getNextRecord();  [BUGGY]    current  =  getNextRecord();    return  current  !=  null;  }  public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;  if  (next  ==  null)  {    next  =  getNextRecord();  if  (next  ==  null)  {    [CLASS]  CSVParser  1  [METHOD]  iterator  [RETURN_TYPE]  Iterator    [VARIABLES]  Lexer  lexer  boolean  List  record  records  Token  reusableToken  CSVRecord  current  next  rec  result  IOException  e  Map  hdrMap  headerMapping    	[P15_Unwrap_Block]
[PATCH]  if  (  current  ==  null  )  {  current  =  getNextRecord  (  )  ;  }	[BUG]  [BUGGY]  [CE]  illegal  start  of  expression  [CONTEXT]  }  }  }  return  hdrMap;  }          public  Iterator<CSVRecord>  iterator()  {  return  new  Iterator<CSVRecord>()  {  private  CSVRecord  current;  public  boolean  hasNext()  {  [BUGGY]  [BUGGY]      return  current  !=  null;  }  public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;  if  (next  ==  null)  {    next  =  getNextRecord();  if  (next  ==  null)  {    [CLASS]  CSVParser  1  [METHOD]  iterator  [RETURN_TYPE]  Iterator    [VARIABLES]  Lexer  lexer  boolean  List  record  records  Token  reusableToken  CSVRecord  current  next  rec  result  IOException  e  Map  hdrMap  headerMapping    	[P16_Remove_Block]
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  rec  !=  null)  {      header  =  rec.values(  )  ;  }[CE]  illegal  start  of  type  [CONTEXT]  }  }  }  return  hdrMap;  }          public  Iterator<CSVRecord>  iterator()  {  return  new  Iterator<CSVRecord>()  {  private  CSVRecord  current;  public  boolean  hasNext()  {  [BUGGY]  if  (  rec  !=  null)  {      header  =  rec.values(  )  ;  }  [BUGGY]  current  =  getNextRecord();  }  return  current  !=  null;  }  public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;  if  (next  ==  null)  {    next  =  getNextRecord();  if  (next  ==  null)  {  throw  new  NoSuchElementException( "No  more  CSV  records  available ");    [CLASS]  CSVParser  1  [METHOD]  iterator  [RETURN_TYPE]  Iterator    [VARIABLES]  Lexer  lexer  boolean  List  record  records  Token  reusableToken  CSVRecord  current  next  rec  result  IOException  e  Map  hdrMap  headerMapping    	[P13_Insert_Block]
[PATCH]  current  =  getNextRecord  (  )  ;	[BUG]  [BUGGY]  current  =  1(  )  ;[CE]  ';'  expected  [CONTEXT]  }  }  return  hdrMap;  }          public  Iterator<CSVRecord>  iterator()  {  return  new  Iterator<CSVRecord>()  {  private  CSVRecord  current;  public  boolean  hasNext()  {  if  (current  ==  null)  {  [BUGGY]  current  =  1(  )  ;  [BUGGY]  }  return  current  !=  null;  }  public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;  if  (next  ==  null)  {    next  =  getNextRecord();  if  (next  ==  null)  {  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }    [CLASS]  CSVParser  1  [METHOD]  iterator  [RETURN_TYPE]  Iterator    [VARIABLES]  Lexer  lexer  boolean  List  record  records  Token  reusableToken  CSVRecord  current  next  rec  result  IOException  e  Map  hdrMap  headerMapping    	[P7_Replace_Invocation]
[PATCH]  current  =  getNextRecord  (  )  ;	[BUG]  [BUGGY]  current  =  current  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  }  }  return  hdrMap;  }          public  Iterator<CSVRecord>  iterator()  {  return  new  Iterator<CSVRecord>()  {  private  CSVRecord  current;  public  boolean  hasNext()  {  if  (current  ==  null)  {  [BUGGY]  current  =  current  ;  [BUGGY]  }  return  current  !=  null;  }  public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;  if  (next  ==  null)  {    next  =  getNextRecord();  if  (next  ==  null)  {  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }    [CLASS]  CSVParser  1  [METHOD]  iterator  [RETURN_TYPE]  Iterator    [VARIABLES]  Lexer  lexer  boolean  List  record  records  Token  reusableToken  CSVRecord  current  next  rec  result  IOException  e  Map  hdrMap  headerMapping    	[P8_Replace_Mix]
[PATCH]  current  =  getNextRecord  (  )  ;	[BUG]  [BUGGY]  next  =  getNextRecord(  )  ;current  =  getNextRecord(  )  ;[CE]  cannot  find  symbol  next  [CONTEXT]  }  }  return  hdrMap;  }          public  Iterator<CSVRecord>  iterator()  {  return  new  Iterator<CSVRecord>()  {  private  CSVRecord  current;  public  boolean  hasNext()  {  if  (current  ==  null)  {  [BUGGY]  next  =  getNextRecord(  )  ;current  =  getNextRecord(  )  ;  [BUGGY]  }  return  current  !=  null;  }  public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;  if  (next  ==  null)  {    next  =  getNextRecord();  if  (next  ==  null)  {  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }    [CLASS]  CSVParser  1  [METHOD]  iterator  [RETURN_TYPE]  Iterator    [VARIABLES]  Lexer  lexer  boolean  List  record  records  Token  reusableToken  CSVRecord  current  next  rec  result  IOException  e  Map  hdrMap  headerMapping    	[P11_Insert_Donor_Statement]
[PATCH]  current  =  getNextRecord  (  )  ;	[BUG]  [BUGGY]  [FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  }  }  return  hdrMap;  }          public  Iterator<CSVRecord>  iterator()  {  return  new  Iterator<CSVRecord>()  {  private  CSVRecord  current;  public  boolean  hasNext()  {  if  (current  ==  null)  {  [BUGGY]  [BUGGY]    }  return  current  !=  null;  }  public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;  if  (next  ==  null)  {    next  =  getNextRecord();  if  (next  ==  null)  {  throw  new  NoSuchElementException( "No  more  CSV  records  available ");    [CLASS]  CSVParser  1  [METHOD]  iterator  [RETURN_TYPE]  Iterator    [VARIABLES]  Lexer  lexer  boolean  List  record  records  Token  reusableToken  CSVRecord  current  next  rec  result  IOException  e  Map  hdrMap  headerMapping    	[P14_Delete_Statement]
[PATCH]  current  =  getNextRecord  (  )  ;	[BUG]  [BUGGY]  CSVRecord  rec  =  getRecord(  )  ;current  =  getNextRecord(  )  ;[CE]  unreported  exception  IOException;  must  be  caught  or  declared  to  be  thrown  [CONTEXT]  }  }  return  hdrMap;  }          public  Iterator<CSVRecord>  iterator()  {  return  new  Iterator<CSVRecord>()  {  private  CSVRecord  current;  public  boolean  hasNext()  {  if  (current  ==  null)  {  [BUGGY]  CSVRecord  rec  =  getRecord(  )  ;current  =  getNextRecord(  )  ;  [BUGGY]  }  return  current  !=  null;  }  public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;  if  (next  ==  null)  {    next  =  getNextRecord();  if  (next  ==  null)  {  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }    [CLASS]  CSVParser  1  [METHOD]  iterator  [RETURN_TYPE]  Iterator    [VARIABLES]  Lexer  lexer  boolean  List  record  records  Token  reusableToken  CSVRecord  current  next  rec  result  IOException  e  Map  hdrMap  headerMapping    	[P11_Insert_Donor_Statement]
[PATCH]  current  =  getNextRecord  (  )  ;	[BUG]  [BUGGY]  return  getRecord(  )  ;current  =  getNextRecord(  )  ;[CE]  incompatible  types  [CONTEXT]  }  }  return  hdrMap;  }          public  Iterator<CSVRecord>  iterator()  {  return  new  Iterator<CSVRecord>()  {  private  CSVRecord  current;  public  boolean  hasNext()  {  if  (current  ==  null)  {  [BUGGY]  return  getRecord(  )  ;current  =  getNextRecord(  )  ;  [BUGGY]  }  return  current  !=  null;  }  public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;  if  (next  ==  null)  {    next  =  getNextRecord();  if  (next  ==  null)  {  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }    [CLASS]  CSVParser  1  [METHOD]  iterator  [RETURN_TYPE]  Iterator    [VARIABLES]  Lexer  lexer  boolean  List  record  records  Token  reusableToken  CSVRecord  current  next  rec  result  IOException  e  Map  hdrMap  headerMapping    	[P11_Insert_Donor_Statement]
[PATCH]  if  (  next  ==  null  )  {	[BUG]  [BUGGY]  if  (  next  !=  null)  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  return  new  Iterator<CSVRecord>()  {  private  CSVRecord  current;  public  boolean  hasNext()  {  if  (current  ==  null)  {  current  =  getNextRecord();  }  return  current  !=  null;  }  public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;  [BUGGY]  if  (  next  !=  null)  {  [BUGGY]    next  =  getNextRecord();  if  (next  ==  null)  {  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }  return  next;  }  private  CSVRecord  getNextRecord()  {  try  {  return  getRecord();  }  catch  (IOException  e)  {  throw  new  RuntimeException(e);    [CLASS]  CSVParser  1  [METHOD]  iterator  [RETURN_TYPE]  Iterator    [VARIABLES]  Lexer  lexer  boolean  List  record  records  Token  reusableToken  CSVRecord  current  next  rec  result  IOException  e  Map  hdrMap  headerMapping    	[P2_Replace_Operator]
[PATCH]  if  (  next  ==  null  )  {	[BUG]  [BUGGY]  if  (  result  ==  null)  {[CE]  cannot  find  symbol  result  [CONTEXT]  return  new  Iterator<CSVRecord>()  {  private  CSVRecord  current;  public  boolean  hasNext()  {  if  (current  ==  null)  {  current  =  getNextRecord();  }  return  current  !=  null;  }  public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;  [BUGGY]  if  (  result  ==  null)  {  [BUGGY]    next  =  getNextRecord();  if  (next  ==  null)  {  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }  return  next;  }  private  CSVRecord  getNextRecord()  {  try  {  return  getRecord();  }  catch  (IOException  e)  {  throw  new  RuntimeException(e);    [CLASS]  CSVParser  1  [METHOD]  iterator  [RETURN_TYPE]  Iterator    [VARIABLES]  Lexer  lexer  boolean  List  record  records  Token  reusableToken  CSVRecord  current  next  rec  result  IOException  e  Map  hdrMap  headerMapping    	[P5_Replace_Variable]
[PATCH]  if  (  next  ==  null  )  {	[BUG]  [BUGGY]  if  (  next  ==  false)  {[CE]  incomparable  types:  CSVRecord  and  boolean  [CONTEXT]  return  new  Iterator<CSVRecord>()  {  private  CSVRecord  current;  public  boolean  hasNext()  {  if  (current  ==  null)  {  current  =  getNextRecord();  }  return  current  !=  null;  }  public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;  [BUGGY]  if  (  next  ==  false)  {  [BUGGY]    next  =  getNextRecord();  if  (next  ==  null)  {  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }  return  next;  }  private  CSVRecord  getNextRecord()  {  try  {  return  getRecord();  }  catch  (IOException  e)  {  throw  new  RuntimeException(e);    [CLASS]  CSVParser  1  [METHOD]  iterator  [RETURN_TYPE]  Iterator    [VARIABLES]  Lexer  lexer  boolean  List  record  records  Token  reusableToken  CSVRecord  current  next  rec  result  IOException  e  Map  hdrMap  headerMapping    	[P8_Replace_Mix]
[PATCH]  if  (  next  ==  null  )  {	[BUG]  [BUGGY]  if  (  header  !=  null)  {[CE]  cannot  find  symbol  header  [CONTEXT]  return  new  Iterator<CSVRecord>()  {  private  CSVRecord  current;  public  boolean  hasNext()  {  if  (current  ==  null)  {  current  =  getNextRecord();  }  return  current  !=  null;  }  public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;  [BUGGY]  if  (  header  !=  null)  {  [BUGGY]    next  =  getNextRecord();  if  (next  ==  null)  {  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }  return  next;  }  private  CSVRecord  getNextRecord()  {  try  {  return  getRecord();  }  catch  (IOException  e)  {  throw  new  RuntimeException(e);    [CLASS]  CSVParser  1  [METHOD]  iterator  [RETURN_TYPE]  Iterator    [VARIABLES]  Lexer  lexer  boolean  List  record  records  Token  reusableToken  CSVRecord  current  next  rec  result  IOException  e  Map  hdrMap  headerMapping    	[P9_Replace_Statement]
[PATCH]  if  (  next  ==  null  )  {	[BUG]  [BUGGY]  if  (  current  ==  null)  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  return  new  Iterator<CSVRecord>()  {  private  CSVRecord  current;  public  boolean  hasNext()  {  if  (current  ==  null)  {  current  =  getNextRecord();  }  return  current  !=  null;  }  public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;  [BUGGY]  if  (  current  ==  null)  {  [BUGGY]    next  =  getNextRecord();  if  (next  ==  null)  {  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }  return  next;  }  private  CSVRecord  getNextRecord()  {  try  {  return  getRecord();  }  catch  (IOException  e)  {  throw  new  RuntimeException(e);    [CLASS]  CSVParser  1  [METHOD]  iterator  [RETURN_TYPE]  Iterator    [VARIABLES]  Lexer  lexer  boolean  List  record  records  Token  reusableToken  CSVRecord  current  next  rec  result  IOException  e  Map  hdrMap  headerMapping    	[P9_Replace_Statement]
[PATCH]  if  (  next  ==  null  )  {	[BUG]  [BUGGY]  if  (  rec  !=  null)  {[CE]  cannot  find  symbol  rec  [CONTEXT]  return  new  Iterator<CSVRecord>()  {  private  CSVRecord  current;  public  boolean  hasNext()  {  if  (current  ==  null)  {  current  =  getNextRecord();  }  return  current  !=  null;  }  public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;  [BUGGY]  if  (  rec  !=  null)  {  [BUGGY]    next  =  getNextRecord();  if  (next  ==  null)  {  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }  return  next;  }  private  CSVRecord  getNextRecord()  {  try  {  return  getRecord();  }  catch  (IOException  e)  {  throw  new  RuntimeException(e);    [CLASS]  CSVParser  1  [METHOD]  iterator  [RETURN_TYPE]  Iterator    [VARIABLES]  Lexer  lexer  boolean  List  record  records  Token  reusableToken  CSVRecord  current  next  rec  result  IOException  e  Map  hdrMap  headerMapping    	[P9_Replace_Statement]
[PATCH]  if  (  next  ==  null  )  {  next  =  getNextRecord  (  )  ;  if  (  next  ==  null  )  {  throw  new  NoSuchElementException  ( "   ")  ;  }	[BUG]  [BUGGY]  next  =  getNextRecord();  if(next  ==  null)  {    throw  new  java.util.NoSuchElementException( "No  more  CSV  records  available ");};[CE]  illegal  start  of  type  [CONTEXT]  return  new  Iterator<CSVRecord>()  {  private  CSVRecord  current;  public  boolean  hasNext()  {  if  (current  ==  null)  {  current  =  getNextRecord();  }  return  current  !=  null;  }  public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;  [BUGGY]  next  =  getNextRecord();  if(next  ==  null)  {    throw  new  java.util.NoSuchElementException( "No  more  CSV  records  available ");};  [BUGGY]    next  =  getNextRecord();  if  (next  ==  null)  {throw  new  java.util.NoSuchElementException( "No  more  CSV  records  available ");};    }  }  return  next;  }  private  CSVRecord  getNextRecord()  {  try  {  return  getRecord();  }  catch  (IOException  e)  {    [CLASS]  CSVParser  1  [METHOD]  iterator  [RETURN_TYPE]  Iterator    [VARIABLES]  Lexer  lexer  boolean  List  record  records  Token  reusableToken  CSVRecord  current  next  rec  result  IOException  e  Map  hdrMap  headerMapping    	[P15_Unwrap_Block]
[PATCH]  if  (  next  ==  null  )  {  next  =  getNextRecord  (  )  ;  if  (  next  ==  null  )  {  throw  new  NoSuchElementException  ( "   ")  ;  }	[BUG]  [BUGGY]  [CE]  illegal  start  of  type  [CONTEXT]  return  new  Iterator<CSVRecord>()  {  private  CSVRecord  current;  public  boolean  hasNext()  {  if  (current  ==  null)  {  current  =  getNextRecord();  }  return  current  !=  null;  }  public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;  [BUGGY]  [BUGGY]        }  }  return  next;  }  private  CSVRecord  getNextRecord()  {  try  {  return  getRecord();  }  catch  (IOException  e)  {    [CLASS]  CSVParser  1  [METHOD]  iterator  [RETURN_TYPE]  Iterator    [VARIABLES]  Lexer  lexer  boolean  List  record  records  Token  reusableToken  CSVRecord  current  next  rec  result  IOException  e  Map  hdrMap  headerMapping    	[P16_Remove_Block]
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  next  ==  null)  {      throw  new  NoSuchElementException(   "No  more  CSV  records  available ")  ;  }[CE]  illegal  start  of  type  [CONTEXT]  return  new  Iterator<CSVRecord>()  {  private  CSVRecord  current;  public  boolean  hasNext()  {  if  (current  ==  null)  {  current  =  getNextRecord();  }  return  current  !=  null;  }  public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;  [BUGGY]  if  (  next  ==  null)  {      throw  new  NoSuchElementException(   "No  more  CSV  records  available ")  ;  }  [BUGGY]    next  =  getNextRecord();  if  (next  ==  null)  {  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }  return  next;  }  private  CSVRecord  getNextRecord()  {  try  {  return  getRecord();  }  catch  (IOException  e)  {  throw  new  RuntimeException(e);    [CLASS]  CSVParser  1  [METHOD]  iterator  [RETURN_TYPE]  Iterator    [VARIABLES]  Lexer  lexer  boolean  List  record  records  Token  reusableToken  CSVRecord  current  next  rec  result  IOException  e  Map  hdrMap  headerMapping    	[P13_Insert_Block]
[PATCH]  if  (  next  ==  null  )  {	[BUG]  [BUGGY]  if  (  next  !=  null)  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  boolean  hasNext()  {  if  (current  ==  null)  {  current  =  getNextRecord();  }  return  current  !=  null;  }  public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;  if  (next  ==  null)  {    next  =  getNextRecord();  [BUGGY]  if  (  next  !=  null)  {  [BUGGY]  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }  return  next;  }  private  CSVRecord  getNextRecord()  {  try  {  return  getRecord();  }  catch  (IOException  e)  {  throw  new  RuntimeException(e);  }  }      [CLASS]  CSVParser  1  [METHOD]  iterator  [RETURN_TYPE]  Iterator    [VARIABLES]  Lexer  lexer  boolean  List  record  records  Token  reusableToken  CSVRecord  current  next  rec  result  IOException  e  Map  hdrMap  headerMapping    	[P2_Replace_Operator]
[PATCH]  if  (  next  ==  null  )  {	[BUG]  [BUGGY]  if  (  result  ==  null)  {[CE]  cannot  find  symbol  result  [CONTEXT]  public  boolean  hasNext()  {  if  (current  ==  null)  {  current  =  getNextRecord();  }  return  current  !=  null;  }  public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;  if  (next  ==  null)  {    next  =  getNextRecord();  [BUGGY]  if  (  result  ==  null)  {  [BUGGY]  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }  return  next;  }  private  CSVRecord  getNextRecord()  {  try  {  return  getRecord();  }  catch  (IOException  e)  {  throw  new  RuntimeException(e);  }  }      [CLASS]  CSVParser  1  [METHOD]  iterator  [RETURN_TYPE]  Iterator    [VARIABLES]  Lexer  lexer  boolean  List  record  records  Token  reusableToken  CSVRecord  current  next  rec  result  IOException  e  Map  hdrMap  headerMapping    	[P5_Replace_Variable]
[PATCH]  if  (  next  ==  null  )  {	[BUG]  [BUGGY]  if  (  next  ==  true)  {[CE]  incomparable  types:  CSVRecord  and  boolean  [CONTEXT]  public  boolean  hasNext()  {  if  (current  ==  null)  {  current  =  getNextRecord();  }  return  current  !=  null;  }  public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;  if  (next  ==  null)  {    next  =  getNextRecord();  [BUGGY]  if  (  next  ==  true)  {  [BUGGY]  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }  return  next;  }  private  CSVRecord  getNextRecord()  {  try  {  return  getRecord();  }  catch  (IOException  e)  {  throw  new  RuntimeException(e);  }  }      [CLASS]  CSVParser  1  [METHOD]  iterator  [RETURN_TYPE]  Iterator    [VARIABLES]  Lexer  lexer  boolean  List  record  records  Token  reusableToken  CSVRecord  current  next  rec  result  IOException  e  Map  hdrMap  headerMapping    	[P8_Replace_Mix]
[PATCH]  if  (  next  ==  null  )  {	[BUG]  [BUGGY]  if  (  header  !=  null)  {[CE]  cannot  find  symbol  header  [CONTEXT]  public  boolean  hasNext()  {  if  (current  ==  null)  {  current  =  getNextRecord();  }  return  current  !=  null;  }  public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;  if  (next  ==  null)  {    next  =  getNextRecord();  [BUGGY]  if  (  header  !=  null)  {  [BUGGY]  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }  return  next;  }  private  CSVRecord  getNextRecord()  {  try  {  return  getRecord();  }  catch  (IOException  e)  {  throw  new  RuntimeException(e);  }  }      [CLASS]  CSVParser  1  [METHOD]  iterator  [RETURN_TYPE]  Iterator    [VARIABLES]  Lexer  lexer  boolean  List  record  records  Token  reusableToken  CSVRecord  current  next  rec  result  IOException  e  Map  hdrMap  headerMapping    	[P9_Replace_Statement]
[PATCH]  if  (  next  ==  null  )  {	[BUG]  [BUGGY]  if  (  current  ==  null)  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  boolean  hasNext()  {  if  (current  ==  null)  {  current  =  getNextRecord();  }  return  current  !=  null;  }  public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;  if  (next  ==  null)  {    next  =  getNextRecord();  [BUGGY]  if  (  current  ==  null)  {  [BUGGY]  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }  return  next;  }  private  CSVRecord  getNextRecord()  {  try  {  return  getRecord();  }  catch  (IOException  e)  {  throw  new  RuntimeException(e);  }  }      [CLASS]  CSVParser  1  [METHOD]  iterator  [RETURN_TYPE]  Iterator    [VARIABLES]  Lexer  lexer  boolean  List  record  records  Token  reusableToken  CSVRecord  current  next  rec  result  IOException  e  Map  hdrMap  headerMapping    	[P9_Replace_Statement]
[PATCH]  if  (  next  ==  null  )  {	[BUG]  [BUGGY]  if  (  rec  !=  null)  {[CE]  cannot  find  symbol  rec  [CONTEXT]  public  boolean  hasNext()  {  if  (current  ==  null)  {  current  =  getNextRecord();  }  return  current  !=  null;  }  public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;  if  (next  ==  null)  {    next  =  getNextRecord();  [BUGGY]  if  (  rec  !=  null)  {  [BUGGY]  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }  return  next;  }  private  CSVRecord  getNextRecord()  {  try  {  return  getRecord();  }  catch  (IOException  e)  {  throw  new  RuntimeException(e);  }  }      [CLASS]  CSVParser  1  [METHOD]  iterator  [RETURN_TYPE]  Iterator    [VARIABLES]  Lexer  lexer  boolean  List  record  records  Token  reusableToken  CSVRecord  current  next  rec  result  IOException  e  Map  hdrMap  headerMapping    	[P9_Replace_Statement]
[PATCH]  if  (  next  ==  null  )  {  throw  new  NoSuchElementException  ( "   ")  ;  }	[BUG]  [BUGGY]  throw  new  java.util.NoSuchElementException( "No  more  CSV  records  available ");[CE]  illegal  start  of  expression  [CONTEXT]  public  boolean  hasNext()  {  if  (current  ==  null)  {  current  =  getNextRecord();  }  return  current  !=  null;  }  public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;  if  (next  ==  null)  {    next  =  getNextRecord();  [BUGGY]  throw  new  java.util.NoSuchElementException( "No  more  CSV  records  available ");  [BUGGY]    throw  new  java.util.NoSuchElementException( "No  more  CSV  records  available ");  }  return  next;  }  private  CSVRecord  getNextRecord()  {  try  {  return  getRecord();  }  catch  (IOException  e)  {  throw  new  RuntimeException(e);  }  }    [CLASS]  CSVParser  1  [METHOD]  iterator  [RETURN_TYPE]  Iterator    [VARIABLES]  Lexer  lexer  boolean  List  record  records  Token  reusableToken  CSVRecord  current  next  rec  result  IOException  e  Map  hdrMap  headerMapping    	[P15_Unwrap_Block]
[PATCH]  if  (  next  ==  null  )  {  throw  new  NoSuchElementException  ( "   ")  ;  }	[BUG]  [BUGGY]  [CE]  illegal  start  of  expression  [CONTEXT]  public  boolean  hasNext()  {  if  (current  ==  null)  {  current  =  getNextRecord();  }  return  current  !=  null;  }  public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;  if  (next  ==  null)  {    next  =  getNextRecord();  [BUGGY]  [BUGGY]      }  return  next;  }  private  CSVRecord  getNextRecord()  {  try  {  return  getRecord();  }  catch  (IOException  e)  {  throw  new  RuntimeException(e);  }  }    [CLASS]  CSVParser  1  [METHOD]  iterator  [RETURN_TYPE]  Iterator    [VARIABLES]  Lexer  lexer  boolean  List  record  records  Token  reusableToken  CSVRecord  current  next  rec  result  IOException  e  Map  hdrMap  headerMapping    	[P16_Remove_Block]
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  next  ==  null)  {      next  =  getNextRecord(  )  ;      if  (  next  ==  null)  {          throw  new  NoSuchElementException(   "No  more  CSV  records  available ")  ;      }  }[CE]  illegal  start  of  type  [CONTEXT]  public  boolean  hasNext()  {  if  (current  ==  null)  {  current  =  getNextRecord();  }  return  current  !=  null;  }  public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;  if  (next  ==  null)  {    next  =  getNextRecord();  [BUGGY]  if  (  next  ==  null)  {      next  =  getNextRecord(  )  ;      if  (  next  ==  null)  {          throw  new  NoSuchElementException(   "No  more  CSV  records  available ")  ;      }  }  [BUGGY]  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }  return  next;  }  private  CSVRecord  getNextRecord()  {  try  {  return  getRecord();  }  catch  (IOException  e)  {  throw  new  RuntimeException(e);  }  }      [CLASS]  CSVParser  1  [METHOD]  iterator  [RETURN_TYPE]  Iterator    [VARIABLES]  Lexer  lexer  boolean  List  record  records  Token  reusableToken  CSVRecord  current  next  rec  result  IOException  e  Map  hdrMap  headerMapping    	[P13_Insert_Block]
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  next  ==  null)  {      throw  new  NoSuchElementException(   "No  more  CSV  records  available ")  ;  }[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  if  (current  ==  null)  {  current  =  getNextRecord();  }  return  current  !=  null;  }  public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;  if  (next  ==  null)  {    next  =  getNextRecord();  if  (next  ==  null)  {  [BUGGY]  if  (  next  ==  null)  {      throw  new  NoSuchElementException(   "No  more  CSV  records  available ")  ;  }  [BUGGY]  }  }  return  next;  }  private  CSVRecord  getNextRecord()  {  try  {  return  getRecord();  }  catch  (IOException  e)  {  throw  new  RuntimeException(e);  }  }  public  void  remove()  {    [CLASS]  CSVParser  1  [METHOD]  iterator  [RETURN_TYPE]  Iterator    [VARIABLES]  Lexer  lexer  boolean  List  record  records  Token  reusableToken  CSVRecord  current  next  rec  result  IOException  e  Map  hdrMap  headerMapping    	[P13_Insert_Block]
[PATCH]  throw  new  NoSuchElementException  ( "   ")  ;	[BUG]  [BUGGY]  return  0;[CE]  incompatible  types  [CONTEXT]  if  (current  ==  null)  {  current  =  getNextRecord();  }  return  current  !=  null;  }  public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;  if  (next  ==  null)  {    next  =  getNextRecord();  if  (next  ==  null)  {  [BUGGY]  return  0;  [BUGGY]  }  }  return  next;  }  private  CSVRecord  getNextRecord()  {  try  {  return  getRecord();  }  catch  (IOException  e)  {  throw  new  RuntimeException(e);  }  }  public  void  remove()  {    [CLASS]  CSVParser  1  [METHOD]  iterator  [RETURN_TYPE]  Iterator    [VARIABLES]  Lexer  lexer  boolean  List  record  records  Token  reusableToken  CSVRecord  current  next  rec  result  IOException  e  Map  hdrMap  headerMapping    	[P8_Replace_Mix]
[PATCH]  throw  new  NoSuchElementException  ( "   ")  ;	[BUG]  [BUGGY]  throw  new  UnsupportedOperationException  ( "   ")  ;throw  new  NoSuchElementException  ( "   ")  ;[CE]  unreachable  statement  [CONTEXT]  if  (current  ==  null)  {  current  =  getNextRecord();  }  return  current  !=  null;  }  public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;  if  (next  ==  null)  {    next  =  getNextRecord();  if  (next  ==  null)  {  [BUGGY]  throw  new  UnsupportedOperationException  ( "   ")  ;throw  new  NoSuchElementException  ( "   ")  ;  [BUGGY]  }  }  return  next;  }  private  CSVRecord  getNextRecord()  {  try  {  return  getRecord();  }  catch  (IOException  e)  {  throw  new  RuntimeException(e);  }  }  public  void  remove()  {    [CLASS]  CSVParser  1  [METHOD]  iterator  [RETURN_TYPE]  Iterator    [VARIABLES]  Lexer  lexer  boolean  List  record  records  Token  reusableToken  CSVRecord  current  next  rec  result  IOException  e  Map  hdrMap  headerMapping    	[P11_Insert_Donor_Statement]
[PATCH]  throw  new  NoSuchElementException  ( "   ")  ;	[BUG]  [BUGGY]  throw  new  RuntimeException  ( "   ")  ;throw  new  NoSuchElementException  ( "   ")  ;[CE]  unreachable  statement  [CONTEXT]  if  (current  ==  null)  {  current  =  getNextRecord();  }  return  current  !=  null;  }  public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;  if  (next  ==  null)  {    next  =  getNextRecord();  if  (next  ==  null)  {  [BUGGY]  throw  new  RuntimeException  ( "   ")  ;throw  new  NoSuchElementException  ( "   ")  ;  [BUGGY]  }  }  return  next;  }  private  CSVRecord  getNextRecord()  {  try  {  return  getRecord();  }  catch  (IOException  e)  {  throw  new  RuntimeException(e);  }  }  public  void  remove()  {    [CLASS]  CSVParser  1  [METHOD]  iterator  [RETURN_TYPE]  Iterator    [VARIABLES]  Lexer  lexer  boolean  List  record  records  Token  reusableToken  CSVRecord  current  next  rec  result  IOException  e  Map  hdrMap  headerMapping    	[P11_Insert_Donor_Statement]
[PATCH]  throw  new  NoSuchElementException  ( "   ")  ;	[BUG]  [BUGGY]  throw  new  IOException  ( "   ")  ;throw  new  NoSuchElementException  ( "   ")  ;[CE]  unreachable  statement  [CONTEXT]  if  (current  ==  null)  {  current  =  getNextRecord();  }  return  current  !=  null;  }  public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;  if  (next  ==  null)  {    next  =  getNextRecord();  if  (next  ==  null)  {  [BUGGY]  throw  new  IOException  ( "   ")  ;throw  new  NoSuchElementException  ( "   ")  ;  [BUGGY]  }  }  return  next;  }  private  CSVRecord  getNextRecord()  {  try  {  return  getRecord();  }  catch  (IOException  e)  {  throw  new  RuntimeException(e);  }  }  public  void  remove()  {    [CLASS]  CSVParser  1  [METHOD]  iterator  [RETURN_TYPE]  Iterator    [VARIABLES]  Lexer  lexer  boolean  List  record  records  Token  reusableToken  CSVRecord  current  next  rec  result  IOException  e  Map  hdrMap  headerMapping    	[P11_Insert_Donor_Statement]
[PATCH]  next  =  getNextRecord  (  )  ;	[BUG]  [BUGGY]  next  =  1(  )  ;[CE]  ';'  expected  [CONTEXT]  public  boolean  hasNext()  {  if  (current  ==  null)  {  current  =  getNextRecord();  }  return  current  !=  null;  }  public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;  if  (next  ==  null)  {    [BUGGY]  next  =  1(  )  ;  [BUGGY]  if  (next  ==  null)  {  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }  return  next;  }  private  CSVRecord  getNextRecord()  {  try  {  return  getRecord();  }  catch  (IOException  e)  {  throw  new  RuntimeException(e);  }  }    [CLASS]  CSVParser  1  [METHOD]  iterator  [RETURN_TYPE]  Iterator    [VARIABLES]  Lexer  lexer  boolean  List  record  records  Token  reusableToken  CSVRecord  current  next  rec  result  IOException  e  Map  hdrMap  headerMapping    	[P7_Replace_Invocation]
[PATCH]  next  =  getNextRecord  (  )  ;	[BUG]  [BUGGY]  next  =  next  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  boolean  hasNext()  {  if  (current  ==  null)  {  current  =  getNextRecord();  }  return  current  !=  null;  }  public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;  if  (next  ==  null)  {    [BUGGY]  next  =  next  ;  [BUGGY]  if  (next  ==  null)  {  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }  return  next;  }  private  CSVRecord  getNextRecord()  {  try  {  return  getRecord();  }  catch  (IOException  e)  {  throw  new  RuntimeException(e);  }  }    [CLASS]  CSVParser  1  [METHOD]  iterator  [RETURN_TYPE]  Iterator    [VARIABLES]  Lexer  lexer  boolean  List  record  records  Token  reusableToken  CSVRecord  current  next  rec  result  IOException  e  Map  hdrMap  headerMapping    	[P8_Replace_Mix]
[PATCH]  next  =  getNextRecord  (  )  ;	[BUG]  [BUGGY]  current  =  getNextRecord(  )  ;next  =  getNextRecord(  )  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  boolean  hasNext()  {  if  (current  ==  null)  {  current  =  getNextRecord();  }  return  current  !=  null;  }  public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;  if  (next  ==  null)  {    [BUGGY]  current  =  getNextRecord(  )  ;next  =  getNextRecord(  )  ;  [BUGGY]  if  (next  ==  null)  {  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }  return  next;  }  private  CSVRecord  getNextRecord()  {  try  {  return  getRecord();  }  catch  (IOException  e)  {  throw  new  RuntimeException(e);  }  }    [CLASS]  CSVParser  1  [METHOD]  iterator  [RETURN_TYPE]  Iterator    [VARIABLES]  Lexer  lexer  boolean  List  record  records  Token  reusableToken  CSVRecord  current  next  rec  result  IOException  e  Map  hdrMap  headerMapping    	[P11_Insert_Donor_Statement]
[PATCH]  next  =  getNextRecord  (  )  ;	[BUG]  [BUGGY]  [FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  boolean  hasNext()  {  if  (current  ==  null)  {  current  =  getNextRecord();  }  return  current  !=  null;  }  public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;  if  (next  ==  null)  {    [BUGGY]  [BUGGY]    if  (next  ==  null)  {  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }  return  next;  }  private  CSVRecord  getNextRecord()  {  try  {  return  getRecord();  }  catch  (IOException  e)  {  throw  new  RuntimeException(e);  }    [CLASS]  CSVParser  1  [METHOD]  iterator  [RETURN_TYPE]  Iterator    [VARIABLES]  Lexer  lexer  boolean  List  record  records  Token  reusableToken  CSVRecord  current  next  rec  result  IOException  e  Map  hdrMap  headerMapping    	[P14_Delete_Statement]
[PATCH]  next  =  getNextRecord  (  )  ;	[BUG]  [BUGGY]  CSVRecord  rec  =  getRecord(  )  ;next  =  getNextRecord(  )  ;[CE]  unreported  exception  IOException;  must  be  caught  or  declared  to  be  thrown  [CONTEXT]  public  boolean  hasNext()  {  if  (current  ==  null)  {  current  =  getNextRecord();  }  return  current  !=  null;  }  public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;  if  (next  ==  null)  {    [BUGGY]  CSVRecord  rec  =  getRecord(  )  ;next  =  getNextRecord(  )  ;  [BUGGY]  if  (next  ==  null)  {  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }  return  next;  }  private  CSVRecord  getNextRecord()  {  try  {  return  getRecord();  }  catch  (IOException  e)  {  throw  new  RuntimeException(e);  }  }    [CLASS]  CSVParser  1  [METHOD]  iterator  [RETURN_TYPE]  Iterator    [VARIABLES]  Lexer  lexer  boolean  List  record  records  Token  reusableToken  CSVRecord  current  next  rec  result  IOException  e  Map  hdrMap  headerMapping    	[P11_Insert_Donor_Statement]
[PATCH]  next  =  getNextRecord  (  )  ;	[BUG]  [BUGGY]  return  getRecord(  )  ;next  =  getNextRecord(  )  ;[CE]  unreachable  statement  [CONTEXT]  public  boolean  hasNext()  {  if  (current  ==  null)  {  current  =  getNextRecord();  }  return  current  !=  null;  }  public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;  if  (next  ==  null)  {    [BUGGY]  return  getRecord(  )  ;next  =  getNextRecord(  )  ;  [BUGGY]  if  (next  ==  null)  {  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }  return  next;  }  private  CSVRecord  getNextRecord()  {  try  {  return  getRecord();  }  catch  (IOException  e)  {  throw  new  RuntimeException(e);  }  }    [CLASS]  CSVParser  1  [METHOD]  iterator  [RETURN_TYPE]  Iterator    [VARIABLES]  Lexer  lexer  boolean  List  record  records  Token  reusableToken  CSVRecord  current  next  rec  result  IOException  e  Map  hdrMap  headerMapping    	[P11_Insert_Donor_Statement]
[PATCH]  if  (  next  ==  null  )  {	[BUG]  [BUGGY]  if  (  next  ==  this)  {[CE]  incomparable  types:  CSVRecord  and  <anonymous  Iterator<CSVRecord>>  [CONTEXT]  public  boolean  hasNext()  {  if  (current  ==  null)  {  current  =  getNextRecord();  }  return  current  !=  null;  }  public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;  if  (next  ==  null)  {    next  =  getNextRecord();  [BUGGY]  if  (  next  ==  this)  {  [BUGGY]  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }  return  next;  }  private  CSVRecord  getNextRecord()  {  try  {  return  getRecord();  }  catch  (IOException  e)  {  throw  new  RuntimeException(e);  }  }      [CLASS]  CSVParser  1  [METHOD]  iterator  [RETURN_TYPE]  Iterator    [VARIABLES]  Lexer  lexer  boolean  List  record  records  Token  reusableToken  CSVRecord  current  next  rec  result  IOException  e  Map  hdrMap  headerMapping    	[P8_Replace_Mix]
[PATCH]  throw  new  NoSuchElementException  ( "   ")  ;	[BUG]  [BUGGY]  throw  new  UnsupportedOperationException  ( "   ")  ;  ;[CE]  unreachable  statement  [CONTEXT]  if  (current  ==  null)  {  current  =  getNextRecord();  }  return  current  !=  null;  }  public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;  if  (next  ==  null)  {    next  =  getNextRecord();  if  (next  ==  null)  {  [BUGGY]  throw  new  UnsupportedOperationException  ( "   ")  ;  ;  [BUGGY]  }  }  return  next;  }  private  CSVRecord  getNextRecord()  {  try  {  return  getRecord();  }  catch  (IOException  e)  {  throw  new  RuntimeException(e);  }  }  public  void  remove()  {    [CLASS]  CSVParser  1  [METHOD]  iterator  [RETURN_TYPE]  Iterator    [VARIABLES]  Lexer  lexer  boolean  List  record  records  Token  reusableToken  CSVRecord  current  next  rec  result  IOException  e  Map  hdrMap  headerMapping    	[P8_Replace_Mix]
[PATCH]  return  getRecord  (  )  ;	[BUG]  [BUGGY]  return  toString(  )  ;[CE]  incompatible  types  [CONTEXT]  current  =  null;  if  (next  ==  null)  {    next  =  getNextRecord();  if  (next  ==  null)  {  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }  return  next;  }  private  CSVRecord  getNextRecord()  {  try  {  [BUGGY]  return  toString(  )  ;  [BUGGY]  }  catch  (IOException  e)  {  throw  new  RuntimeException(e);  }  }  public  void  remove()  {  throw  new  UnsupportedOperationException();  }  };  }              [CLASS]  CSVParser  1  [METHOD]  iterator  [RETURN_TYPE]  Iterator    [VARIABLES]  Lexer  lexer  boolean  List  record  records  Token  reusableToken  CSVRecord  current  next  rec  result  IOException  e  Map  hdrMap  headerMapping    	[P7_Replace_Invocation]
[PATCH]  return  getRecord  (  )  ;	[BUG]  [BUGGY]  [FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  current  =  null;  if  (next  ==  null)  {    next  =  getNextRecord();  if  (next  ==  null)  {  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }  return  next;  }  private  CSVRecord  getNextRecord()  {  try  {  [BUGGY]  [BUGGY]    }  catch  (IOException  e)  {  throw  new  RuntimeException(e);  }  }  public  void  remove()  {  throw  new  UnsupportedOperationException();  }  };  }            [CLASS]  CSVParser  1  [METHOD]  iterator  [RETURN_TYPE]  Iterator    [VARIABLES]  Lexer  lexer  boolean  List  record  records  Token  reusableToken  CSVRecord  current  next  rec  result  IOException  e  Map  hdrMap  headerMapping    	[P14_Delete_Statement]
[PATCH]  current  =  null;	[BUG]  [BUGGY]  current  =  this;[CE]  incompatible  types  [CONTEXT]    public  Iterator<CSVRecord>  iterator()  {  return  new  Iterator<CSVRecord>()  {  private  CSVRecord  current;  public  boolean  hasNext()  {  if  (current  ==  null)  {  current  =  getNextRecord();  }  return  current  !=  null;  }  public  CSVRecord  next()  {  CSVRecord  next  =  current;  [BUGGY]  current  =  this;  [BUGGY]    if  (next  ==  null)  {    next  =  getNextRecord();  if  (next  ==  null)  {  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }  return  next;  }  private  CSVRecord  getNextRecord()  {  try  {  return  getRecord();    [CLASS]  CSVParser  1  [METHOD]  iterator  [RETURN_TYPE]  Iterator    [VARIABLES]  Lexer  lexer  boolean  List  record  records  Token  reusableToken  CSVRecord  current  next  rec  result  IOException  e  Map  hdrMap  headerMapping    	[P8_Replace_Mix]
[PATCH]  current  =  null;	[BUG]  [BUGGY]  result  =  null;current  =  null;[CE]  cannot  find  symbol  result  [CONTEXT]    public  Iterator<CSVRecord>  iterator()  {  return  new  Iterator<CSVRecord>()  {  private  CSVRecord  current;  public  boolean  hasNext()  {  if  (current  ==  null)  {  current  =  getNextRecord();  }  return  current  !=  null;  }  public  CSVRecord  next()  {  CSVRecord  next  =  current;  [BUGGY]  result  =  null;current  =  null;  [BUGGY]    if  (next  ==  null)  {    next  =  getNextRecord();  if  (next  ==  null)  {  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }  return  next;  }  private  CSVRecord  getNextRecord()  {  try  {  return  getRecord();    [CLASS]  CSVParser  1  [METHOD]  iterator  [RETURN_TYPE]  Iterator    [VARIABLES]  Lexer  lexer  boolean  List  record  records  Token  reusableToken  CSVRecord  current  next  rec  result  IOException  e  Map  hdrMap  headerMapping    	[P11_Insert_Donor_Statement]
[PATCH]  current  =  null;	[BUG]  [BUGGY]  if  (  current  ==  null)  {  current  =  null;  }[FE]  [CONTEXT]    public  Iterator<CSVRecord>  iterator()  {  return  new  Iterator<CSVRecord>()  {  private  CSVRecord  current;  public  boolean  hasNext()  {  if  (current  ==  null)  {  current  =  getNextRecord();  }  return  current  !=  null;  }  public  CSVRecord  next()  {  CSVRecord  next  =  current;  [BUGGY]  if  (  current  ==  null)  {  current  =  null;  }  [BUGGY]    if  (next  ==  null)  {    next  =  getNextRecord();  if  (next  ==  null)  {  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }  return  next;  }  private  CSVRecord  getNextRecord()  {  try  {  return  getRecord();    [CLASS]  CSVParser  1  [METHOD]  iterator  [RETURN_TYPE]  Iterator    [VARIABLES]  Lexer  lexer  boolean  List  record  records  Token  reusableToken  CSVRecord  current  next  rec  result  IOException  e  Map  hdrMap  headerMapping    	[P12_Insert_Condition]
[PATCH]  next  =  getNextRecord  (  )  ;	[BUG]  [BUGGY]  next  =  null  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  boolean  hasNext()  {  if  (current  ==  null)  {  current  =  getNextRecord();  }  return  current  !=  null;  }  public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;  if  (next  ==  null)  {    [BUGGY]  next  =  null  ;  [BUGGY]  if  (next  ==  null)  {  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }  return  next;  }  private  CSVRecord  getNextRecord()  {  try  {  return  getRecord();  }  catch  (IOException  e)  {  throw  new  RuntimeException(e);  }  }    [CLASS]  CSVParser  1  [METHOD]  iterator  [RETURN_TYPE]  Iterator    [VARIABLES]  Lexer  lexer  boolean  List  record  records  Token  reusableToken  CSVRecord  current  next  rec  result  IOException  e  Map  hdrMap  headerMapping    	[P8_Replace_Mix]
[PATCH]  return  new  Iterator<CSVRecord>  (  )  {	[BUG]  [BUGGY]  return  new  Iterator;[CE]  '('  or  '['  expected  [CONTEXT]    if  (header  !=  null)  {  for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }          public  Iterator<CSVRecord>  iterator()  {  [BUGGY]  return  new  Iterator;  [BUGGY]  private  CSVRecord  current;  public  boolean  hasNext()  {  if  (current  ==  null)  {  current  =  getNextRecord();  }  return  current  !=  null;  }  public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;  if  (next  ==  null)  {    [CLASS]  CSVParser  1  [METHOD]  iterator  [RETURN_TYPE]  Iterator    [VARIABLES]  Lexer  lexer  boolean  List  record  records  Token  reusableToken  CSVRecord  current  next  rec  result  IOException  e  Map  hdrMap  headerMapping    	[P8_Replace_Mix]
[PATCH]  return  current  !=  null;	[BUG]  [BUGGY]  return  current  ==  null;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  }          public  Iterator<CSVRecord>  iterator()  {  return  new  Iterator<CSVRecord>()  {  private  CSVRecord  current;  public  boolean  hasNext()  {  if  (current  ==  null)  {  current  =  getNextRecord();  }  [BUGGY]  return  current  ==  null;  [BUGGY]  }  public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;  if  (next  ==  null)  {    next  =  getNextRecord();  if  (next  ==  null)  {  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }  return  next;    [CLASS]  CSVParser  1  [METHOD]  iterator  [RETURN_TYPE]  Iterator    [VARIABLES]  Lexer  lexer  boolean  List  record  records  Token  reusableToken  CSVRecord  current  next  rec  result  IOException  e  Map  hdrMap  headerMapping    	[P2_Replace_Operator]
[PATCH]  return  current  !=  null;	[BUG]  [BUGGY]  return  result  !=  null;[CE]  cannot  find  symbol  result  [CONTEXT]  }          public  Iterator<CSVRecord>  iterator()  {  return  new  Iterator<CSVRecord>()  {  private  CSVRecord  current;  public  boolean  hasNext()  {  if  (current  ==  null)  {  current  =  getNextRecord();  }  [BUGGY]  return  result  !=  null;  [BUGGY]  }  public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;  if  (next  ==  null)  {    next  =  getNextRecord();  if  (next  ==  null)  {  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }  return  next;    [CLASS]  CSVParser  1  [METHOD]  iterator  [RETURN_TYPE]  Iterator    [VARIABLES]  Lexer  lexer  boolean  List  record  records  Token  reusableToken  CSVRecord  current  next  rec  result  IOException  e  Map  hdrMap  headerMapping    	[P5_Replace_Variable]
[PATCH]  return  current  !=  null;	[BUG]  [BUGGY]  return  result  ;[CE]  cannot  find  symbol  result  [CONTEXT]  }          public  Iterator<CSVRecord>  iterator()  {  return  new  Iterator<CSVRecord>()  {  private  CSVRecord  current;  public  boolean  hasNext()  {  if  (current  ==  null)  {  current  =  getNextRecord();  }  [BUGGY]  return  result  ;  [BUGGY]  }  public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;  if  (next  ==  null)  {    next  =  getNextRecord();  if  (next  ==  null)  {  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }  return  next;    [CLASS]  CSVParser  1  [METHOD]  iterator  [RETURN_TYPE]  Iterator    [VARIABLES]  Lexer  lexer  boolean  List  record  records  Token  reusableToken  CSVRecord  current  next  rec  result  IOException  e  Map  hdrMap  headerMapping    	[P8_Replace_Mix]
[PATCH]  return  current  !=  null;	[BUG]  [BUGGY]  if  (  current  ==  null)  {  return  current  !=  null;  }[CE]  missing  return  statement  [CONTEXT]  }          public  Iterator<CSVRecord>  iterator()  {  return  new  Iterator<CSVRecord>()  {  private  CSVRecord  current;  public  boolean  hasNext()  {  if  (current  ==  null)  {  current  =  getNextRecord();  }  [BUGGY]  if  (  current  ==  null)  {  return  current  !=  null;  }  [BUGGY]  }  public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;  if  (next  ==  null)  {    next  =  getNextRecord();  if  (next  ==  null)  {  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }  return  next;    [CLASS]  CSVParser  1  [METHOD]  iterator  [RETURN_TYPE]  Iterator    [VARIABLES]  Lexer  lexer  boolean  List  record  records  Token  reusableToken  CSVRecord  current  next  rec  result  IOException  e  Map  hdrMap  headerMapping    	[P12_Insert_Condition]
[PATCH]  return  next;	[BUG]  [BUGGY]  return  result;[CE]  cannot  find  symbol  result  [CONTEXT]  return  current  !=  null;  }  public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;  if  (next  ==  null)  {    next  =  getNextRecord();  if  (next  ==  null)  {  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }  [BUGGY]  return  result;  [BUGGY]  }  private  CSVRecord  getNextRecord()  {  try  {  return  getRecord();  }  catch  (IOException  e)  {  throw  new  RuntimeException(e);  }  }  public  void  remove()  {  throw  new  UnsupportedOperationException();  }  };  }    [CLASS]  CSVParser  1  [METHOD]  iterator  [RETURN_TYPE]  Iterator    [VARIABLES]  Lexer  lexer  boolean  List  record  records  Token  reusableToken  CSVRecord  current  next  rec  result  IOException  e  Map  hdrMap  headerMapping    	[P5_Replace_Variable]
[PATCH]  CSVRecord  next  =  current;	[BUG]  [BUGGY]  CSVRecord  next  =  result;[CE]  cannot  find  symbol  result  [CONTEXT]      public  Iterator<CSVRecord>  iterator()  {  return  new  Iterator<CSVRecord>()  {  private  CSVRecord  current;  public  boolean  hasNext()  {  if  (current  ==  null)  {  current  =  getNextRecord();  }  return  current  !=  null;  }  public  CSVRecord  next()  {  [BUGGY]  CSVRecord  next  =  result;  [BUGGY]  current  =  null;  if  (next  ==  null)  {    next  =  getNextRecord();  if  (next  ==  null)  {  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }  return  next;  }  private  CSVRecord  getNextRecord()  {  try  {    [CLASS]  CSVParser  1  [METHOD]  iterator  [RETURN_TYPE]  Iterator    [VARIABLES]  Lexer  lexer  boolean  List  record  records  Token  reusableToken  CSVRecord  current  next  rec  result  IOException  e  Map  hdrMap  headerMapping    	[P5_Replace_Variable]
[PATCH]  CSVRecord  next  =  current;	[BUG]  [BUGGY]  CSVRecord  rec;CSVRecord  next  =  current;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]      public  Iterator<CSVRecord>  iterator()  {  return  new  Iterator<CSVRecord>()  {  private  CSVRecord  current;  public  boolean  hasNext()  {  if  (current  ==  null)  {  current  =  getNextRecord();  }  return  current  !=  null;  }  public  CSVRecord  next()  {  [BUGGY]  CSVRecord  rec;CSVRecord  next  =  current;  [BUGGY]  current  =  null;  if  (next  ==  null)  {    next  =  getNextRecord();  if  (next  ==  null)  {  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }  return  next;  }  private  CSVRecord  getNextRecord()  {  try  {    [CLASS]  CSVParser  1  [METHOD]  iterator  [RETURN_TYPE]  Iterator    [VARIABLES]  Lexer  lexer  boolean  List  record  records  Token  reusableToken  CSVRecord  current  next  rec  result  IOException  e  Map  hdrMap  headerMapping    	[P11_Insert_Donor_Statement]
[PATCH]  throw  new  RuntimeException  ( "   ")  ;	[BUG]  [BUGGY]  throw  new  UnsupportedOperationException  ( "   ")  ;throw  new  RuntimeException  ( "   ")  ;[CE]  unreachable  statement  [CONTEXT]  if  (next  ==  null)  {    next  =  getNextRecord();  if  (next  ==  null)  {  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }  return  next;  }  private  CSVRecord  getNextRecord()  {  try  {  return  getRecord();  }  catch  (IOException  e)  {  [BUGGY]  throw  new  UnsupportedOperationException  ( "   ")  ;throw  new  RuntimeException  ( "   ")  ;  [BUGGY]  }  }  public  void  remove()  {  throw  new  UnsupportedOperationException();  }  };  }                  [CLASS]  CSVParser  1  [METHOD]  iterator  [RETURN_TYPE]  Iterator    [VARIABLES]  Lexer  lexer  boolean  List  record  records  Token  reusableToken  CSVRecord  current  next  rec  result  IOException  e  Map  hdrMap  headerMapping    	[P11_Insert_Donor_Statement]
[PATCH]  throw  new  RuntimeException  ( "   ")  ;	[BUG]  [BUGGY]  throw  new  IOException  ( "   ")  ;throw  new  RuntimeException  ( "   ")  ;[CE]  unreachable  statement  [CONTEXT]  if  (next  ==  null)  {    next  =  getNextRecord();  if  (next  ==  null)  {  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }  return  next;  }  private  CSVRecord  getNextRecord()  {  try  {  return  getRecord();  }  catch  (IOException  e)  {  [BUGGY]  throw  new  IOException  ( "   ")  ;throw  new  RuntimeException  ( "   ")  ;  [BUGGY]  }  }  public  void  remove()  {  throw  new  UnsupportedOperationException();  }  };  }                  [CLASS]  CSVParser  1  [METHOD]  iterator  [RETURN_TYPE]  Iterator    [VARIABLES]  Lexer  lexer  boolean  List  record  records  Token  reusableToken  CSVRecord  current  next  rec  result  IOException  e  Map  hdrMap  headerMapping    	[P11_Insert_Donor_Statement]
[PATCH]  throw  new  RuntimeException  ( "   ")  ;	[BUG]  [BUGGY]  throw  new  NoSuchElementException  ( "   ")  ;throw  new  RuntimeException  ( "   ")  ;[CE]  unreachable  statement  [CONTEXT]  if  (next  ==  null)  {    next  =  getNextRecord();  if  (next  ==  null)  {  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }  return  next;  }  private  CSVRecord  getNextRecord()  {  try  {  return  getRecord();  }  catch  (IOException  e)  {  [BUGGY]  throw  new  NoSuchElementException  ( "   ")  ;throw  new  RuntimeException  ( "   ")  ;  [BUGGY]  }  }  public  void  remove()  {  throw  new  UnsupportedOperationException();  }  };  }                  [CLASS]  CSVParser  1  [METHOD]  iterator  [RETURN_TYPE]  Iterator    [VARIABLES]  Lexer  lexer  boolean  List  record  records  Token  reusableToken  CSVRecord  current  next  rec  result  IOException  e  Map  hdrMap  headerMapping    	[P11_Insert_Donor_Statement]
[PATCH]  throw  new  UnsupportedOperationException  ( "   ")  ;	[BUG]  [BUGGY]  throw  new  RuntimeException  ( "   ")  ;throw  new  UnsupportedOperationException  ( "   ")  ;[CE]  unreachable  statement  [CONTEXT]  }  }  return  next;  }  private  CSVRecord  getNextRecord()  {  try  {  return  getRecord();  }  catch  (IOException  e)  {  throw  new  RuntimeException(e);  }  }  public  void  remove()  {  [BUGGY]  throw  new  RuntimeException  ( "   ")  ;throw  new  UnsupportedOperationException  ( "   ")  ;  [BUGGY]  }  };  }                  public  int  getLineNumber()  {  return  lexer.getLineNumber();  }    [CLASS]  CSVParser  1  [METHOD]  iterator  [RETURN_TYPE]  Iterator    [VARIABLES]  Lexer  lexer  boolean  List  record  records  Token  reusableToken  CSVRecord  current  next  rec  result  IOException  e  Map  hdrMap  headerMapping    	[P11_Insert_Donor_Statement]
[PATCH]  throw  new  UnsupportedOperationException  ( "   ")  ;	[BUG]  [BUGGY]  throw  new  IOException  ( "   ")  ;throw  new  UnsupportedOperationException  ( "   ")  ;[CE]  unreachable  statement  [CONTEXT]  }  }  return  next;  }  private  CSVRecord  getNextRecord()  {  try  {  return  getRecord();  }  catch  (IOException  e)  {  throw  new  RuntimeException(e);  }  }  public  void  remove()  {  [BUGGY]  throw  new  IOException  ( "   ")  ;throw  new  UnsupportedOperationException  ( "   ")  ;  [BUGGY]  }  };  }                  public  int  getLineNumber()  {  return  lexer.getLineNumber();  }    [CLASS]  CSVParser  1  [METHOD]  iterator  [RETURN_TYPE]  Iterator    [VARIABLES]  Lexer  lexer  boolean  List  record  records  Token  reusableToken  CSVRecord  current  next  rec  result  IOException  e  Map  hdrMap  headerMapping    	[P11_Insert_Donor_Statement]
[PATCH]  throw  new  UnsupportedOperationException  ( "   ")  ;	[BUG]  [BUGGY]  throw  new  NoSuchElementException  ( "   ")  ;throw  new  UnsupportedOperationException  ( "   ")  ;[CE]  unreachable  statement  [CONTEXT]  }  }  return  next;  }  private  CSVRecord  getNextRecord()  {  try  {  return  getRecord();  }  catch  (IOException  e)  {  throw  new  RuntimeException(e);  }  }  public  void  remove()  {  [BUGGY]  throw  new  NoSuchElementException  ( "   ")  ;throw  new  UnsupportedOperationException  ( "   ")  ;  [BUGGY]  }  };  }                  public  int  getLineNumber()  {  return  lexer.getLineNumber();  }    [CLASS]  CSVParser  1  [METHOD]  iterator  [RETURN_TYPE]  Iterator    [VARIABLES]  Lexer  lexer  boolean  List  record  records  Token  reusableToken  CSVRecord  current  next  rec  result  IOException  e  Map  hdrMap  headerMapping    	[P11_Insert_Donor_Statement]
[PATCH]  if  (  current  ==  null  )  {	[BUG]  [BUGGY]  if  (  current  !=  null)  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  boolean  hasNext()  {  [BUGGY]  if  (  current  !=  null)  {  [BUGGY]  current  =  getNextRecord();  }  return  current  !=  null;  }    [CLASS]  CSVParser  1  [METHOD]  hasNext  [RETURN_TYPE]  boolean    [VARIABLES]  Lexer  lexer  List  record  records  Token  reusableToken  CSVRecord  current  next  rec  result  boolean  Map  hdrMap  headerMapping    	[P2_Replace_Operator]
[PATCH]  if  (  current  ==  null  )  {	[BUG]  [BUGGY]  if  (  result  ==  null)  {[CE]  cannot  find  symbol  result  [CONTEXT]  public  boolean  hasNext()  {  [BUGGY]  if  (  result  ==  null)  {  [BUGGY]  current  =  getNextRecord();  }  return  current  !=  null;  }    [CLASS]  CSVParser  1  [METHOD]  hasNext  [RETURN_TYPE]  boolean    [VARIABLES]  Lexer  lexer  List  record  records  Token  reusableToken  CSVRecord  current  next  rec  result  boolean  Map  hdrMap  headerMapping    	[P5_Replace_Variable]
[PATCH]  if  (  current  ==  null  )  {	[BUG]  [BUGGY]  if  (  current  ==  true)  {[CE]  incomparable  types:  CSVRecord  and  boolean  [CONTEXT]  public  boolean  hasNext()  {  [BUGGY]  if  (  current  ==  true)  {  [BUGGY]  current  =  getNextRecord();  }  return  current  !=  null;  }    [CLASS]  CSVParser  1  [METHOD]  hasNext  [RETURN_TYPE]  boolean    [VARIABLES]  Lexer  lexer  List  record  records  Token  reusableToken  CSVRecord  current  next  rec  result  boolean  Map  hdrMap  headerMapping    	[P8_Replace_Mix]
[PATCH]  if  (  current  ==  null  )  {	[BUG]  [BUGGY]  if  (  header  !=  null)  {[CE]  cannot  find  symbol  header  [CONTEXT]  public  boolean  hasNext()  {  [BUGGY]  if  (  header  !=  null)  {  [BUGGY]  current  =  getNextRecord();  }  return  current  !=  null;  }    [CLASS]  CSVParser  1  [METHOD]  hasNext  [RETURN_TYPE]  boolean    [VARIABLES]  Lexer  lexer  List  record  records  Token  reusableToken  CSVRecord  current  next  rec  result  boolean  Map  hdrMap  headerMapping    	[P9_Replace_Statement]
[PATCH]  if  (  current  ==  null  )  {	[BUG]  [BUGGY]  if  (  rec  !=  null)  {[CE]  cannot  find  symbol  rec  [CONTEXT]  public  boolean  hasNext()  {  [BUGGY]  if  (  rec  !=  null)  {  [BUGGY]  current  =  getNextRecord();  }  return  current  !=  null;  }    [CLASS]  CSVParser  1  [METHOD]  hasNext  [RETURN_TYPE]  boolean    [VARIABLES]  Lexer  lexer  List  record  records  Token  reusableToken  CSVRecord  current  next  rec  result  boolean  Map  hdrMap  headerMapping    	[P9_Replace_Statement]
[PATCH]  if  (  current  ==  null  )  {	[BUG]  [BUGGY]  if  (  next  ==  null)  {[CE]  cannot  find  symbol  next  [CONTEXT]  public  boolean  hasNext()  {  [BUGGY]  if  (  next  ==  null)  {  [BUGGY]  current  =  getNextRecord();  }  return  current  !=  null;  }    [CLASS]  CSVParser  1  [METHOD]  hasNext  [RETURN_TYPE]  boolean    [VARIABLES]  Lexer  lexer  List  record  records  Token  reusableToken  CSVRecord  current  next  rec  result  boolean  Map  hdrMap  headerMapping    	[P9_Replace_Statement]
[PATCH]  if  (  current  ==  null  )  {  current  =  getNextRecord  (  )  ;  }	[BUG]  [BUGGY]  current  =  getNextRecord();[CE]  illegal  start  of  expression  [CONTEXT]  public  boolean  hasNext()  {  [BUGGY]  current  =  getNextRecord();  [BUGGY]    current  =  getNextRecord();    return  current  !=  null;    [CLASS]  CSVParser  1  [METHOD]  hasNext  [RETURN_TYPE]  boolean    [VARIABLES]  Lexer  lexer  List  record  records  Token  reusableToken  CSVRecord  current  next  rec  result  boolean  Map  hdrMap  headerMapping    	[P15_Unwrap_Block]
[PATCH]  if  (  current  ==  null  )  {  current  =  getNextRecord  (  )  ;  }	[BUG]  [BUGGY]  [CE]  illegal  start  of  expression  [CONTEXT]  public  boolean  hasNext()  {  [BUGGY]  [BUGGY]      return  current  !=  null;    [CLASS]  CSVParser  1  [METHOD]  hasNext  [RETURN_TYPE]  boolean    [VARIABLES]  Lexer  lexer  List  record  records  Token  reusableToken  CSVRecord  current  next  rec  result  boolean  Map  hdrMap  headerMapping    	[P16_Remove_Block]
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  rec  !=  null)  {      header  =  rec.values(  )  ;  }[CE]  illegal  start  of  type  [CONTEXT]  public  boolean  hasNext()  {  [BUGGY]  if  (  rec  !=  null)  {      header  =  rec.values(  )  ;  }  [BUGGY]  current  =  getNextRecord();  }  return  current  !=  null;  }    [CLASS]  CSVParser  1  [METHOD]  hasNext  [RETURN_TYPE]  boolean    [VARIABLES]  Lexer  lexer  List  record  records  Token  reusableToken  CSVRecord  current  next  rec  result  boolean  Map  hdrMap  headerMapping    	[P13_Insert_Block]
[PATCH]  current  =  getNextRecord  (  )  ;	[BUG]  [BUGGY]  current  =  1(  )  ;[CE]  ';'  expected  [CONTEXT]  public  boolean  hasNext()  {  if  (current  ==  null)  {  [BUGGY]  current  =  1(  )  ;  [BUGGY]  }  return  current  !=  null;  }    [CLASS]  CSVParser  1  [METHOD]  hasNext  [RETURN_TYPE]  boolean    [VARIABLES]  Lexer  lexer  List  record  records  Token  reusableToken  CSVRecord  current  next  rec  result  boolean  Map  hdrMap  headerMapping    	[P7_Replace_Invocation]
[PATCH]  current  =  getNextRecord  (  )  ;	[BUG]  [BUGGY]  current  =  current  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  boolean  hasNext()  {  if  (current  ==  null)  {  [BUGGY]  current  =  current  ;  [BUGGY]  }  return  current  !=  null;  }    [CLASS]  CSVParser  1  [METHOD]  hasNext  [RETURN_TYPE]  boolean    [VARIABLES]  Lexer  lexer  List  record  records  Token  reusableToken  CSVRecord  current  next  rec  result  boolean  Map  hdrMap  headerMapping    	[P8_Replace_Mix]
[PATCH]  current  =  getNextRecord  (  )  ;	[BUG]  [BUGGY]  next  =  getNextRecord(  )  ;current  =  getNextRecord(  )  ;[CE]  cannot  find  symbol  next  [CONTEXT]  public  boolean  hasNext()  {  if  (current  ==  null)  {  [BUGGY]  next  =  getNextRecord(  )  ;current  =  getNextRecord(  )  ;  [BUGGY]  }  return  current  !=  null;  }    [CLASS]  CSVParser  1  [METHOD]  hasNext  [RETURN_TYPE]  boolean    [VARIABLES]  Lexer  lexer  List  record  records  Token  reusableToken  CSVRecord  current  next  rec  result  boolean  Map  hdrMap  headerMapping    	[P11_Insert_Donor_Statement]
[PATCH]  current  =  getNextRecord  (  )  ;	[BUG]  [BUGGY]  [FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  boolean  hasNext()  {  if  (current  ==  null)  {  [BUGGY]  [BUGGY]    }  return  current  !=  null;    [CLASS]  CSVParser  1  [METHOD]  hasNext  [RETURN_TYPE]  boolean    [VARIABLES]  Lexer  lexer  List  record  records  Token  reusableToken  CSVRecord  current  next  rec  result  boolean  Map  hdrMap  headerMapping    	[P14_Delete_Statement]
[PATCH]  current  =  getNextRecord  (  )  ;	[BUG]  [BUGGY]  CSVRecord  rec  =  getRecord(  )  ;current  =  getNextRecord(  )  ;[CE]  unreported  exception  IOException;  must  be  caught  or  declared  to  be  thrown  [CONTEXT]  public  boolean  hasNext()  {  if  (current  ==  null)  {  [BUGGY]  CSVRecord  rec  =  getRecord(  )  ;current  =  getNextRecord(  )  ;  [BUGGY]  }  return  current  !=  null;  }    [CLASS]  CSVParser  1  [METHOD]  hasNext  [RETURN_TYPE]  boolean    [VARIABLES]  Lexer  lexer  List  record  records  Token  reusableToken  CSVRecord  current  next  rec  result  boolean  Map  hdrMap  headerMapping    	[P11_Insert_Donor_Statement]
[PATCH]  current  =  getNextRecord  (  )  ;	[BUG]  [BUGGY]  return  getRecord(  )  ;current  =  getNextRecord(  )  ;[CE]  incompatible  types  [CONTEXT]  public  boolean  hasNext()  {  if  (current  ==  null)  {  [BUGGY]  return  getRecord(  )  ;current  =  getNextRecord(  )  ;  [BUGGY]  }  return  current  !=  null;  }    [CLASS]  CSVParser  1  [METHOD]  hasNext  [RETURN_TYPE]  boolean    [VARIABLES]  Lexer  lexer  List  record  records  Token  reusableToken  CSVRecord  current  next  rec  result  boolean  Map  hdrMap  headerMapping    	[P11_Insert_Donor_Statement]
[PATCH]  current  =  getNextRecord  (  )  ;	[BUG]  [BUGGY]  current  =  null  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  boolean  hasNext()  {  if  (current  ==  null)  {  [BUGGY]  current  =  null  ;  [BUGGY]  }  return  current  !=  null;  }    [CLASS]  CSVParser  1  [METHOD]  hasNext  [RETURN_TYPE]  boolean    [VARIABLES]  Lexer  lexer  List  record  records  Token  reusableToken  CSVRecord  current  next  rec  result  boolean  Map  hdrMap  headerMapping    	[P8_Replace_Mix]
[PATCH]  return  current  !=  null;	[BUG]  [BUGGY]  return  current  ==  null;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  boolean  hasNext()  {  if  (current  ==  null)  {  current  =  getNextRecord();  }  [BUGGY]  return  current  ==  null;  [BUGGY]  }    [CLASS]  CSVParser  1  [METHOD]  hasNext  [RETURN_TYPE]  boolean    [VARIABLES]  Lexer  lexer  List  record  records  Token  reusableToken  CSVRecord  current  next  rec  result  boolean  Map  hdrMap  headerMapping    	[P2_Replace_Operator]
[PATCH]  return  current  !=  null;	[BUG]  [BUGGY]  return  result  !=  null;[CE]  cannot  find  symbol  result  [CONTEXT]  public  boolean  hasNext()  {  if  (current  ==  null)  {  current  =  getNextRecord();  }  [BUGGY]  return  result  !=  null;  [BUGGY]  }    [CLASS]  CSVParser  1  [METHOD]  hasNext  [RETURN_TYPE]  boolean    [VARIABLES]  Lexer  lexer  List  record  records  Token  reusableToken  CSVRecord  current  next  rec  result  boolean  Map  hdrMap  headerMapping    	[P5_Replace_Variable]
[PATCH]  return  current  !=  null;	[BUG]  [BUGGY]  returnresult  ;[CE]  not  a  statement  [CONTEXT]  public  boolean  hasNext()  {  if  (current  ==  null)  {  current  =  getNextRecord();  }  [BUGGY]  returnresult  ;  [BUGGY]  }    [CLASS]  CSVParser  1  [METHOD]  hasNext  [RETURN_TYPE]  boolean    [VARIABLES]  Lexer  lexer  List  record  records  Token  reusableToken  CSVRecord  current  next  rec  result  boolean  Map  hdrMap  headerMapping    	[P8_Replace_Mix]
[PATCH]  return  current  !=  null;	[BUG]  [BUGGY]  if  (  current  ==  null)  {  return  current  !=  null;  }[CE]  missing  return  statement  [CONTEXT]  public  boolean  hasNext()  {  if  (current  ==  null)  {  current  =  getNextRecord();  }  [BUGGY]  if  (  current  ==  null)  {  return  current  !=  null;  }  [BUGGY]  }    [CLASS]  CSVParser  1  [METHOD]  hasNext  [RETURN_TYPE]  boolean    [VARIABLES]  Lexer  lexer  List  record  records  Token  reusableToken  CSVRecord  current  next  rec  result  boolean  Map  hdrMap  headerMapping    	[P12_Insert_Condition]
[PATCH]  CSVRecord  next  =  current;	[BUG]  [BUGGY]  CSVRecord  next  =  result;[CE]  cannot  find  symbol  result  [CONTEXT]  public  CSVRecord  next()  {  [BUGGY]  CSVRecord  next  =  result;  [BUGGY]  current  =  null;  if  (next  ==  null)  {    next  =  getNextRecord();  if  (next  ==  null)  {  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }  return  next;  }    [CLASS]  CSVParser  1  [METHOD]  next  [RETURN_TYPE]  CSVRecord    [VARIABLES]  Lexer  lexer  List  record  records  Token  reusableToken  CSVRecord  current  next  rec  result  boolean  Map  hdrMap  headerMapping    	[P5_Replace_Variable]
[PATCH]  CSVRecord  next  =  current;	[BUG]  [BUGGY]  CSVRecord  rec;CSVRecord  next  =  current;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  CSVRecord  next()  {  [BUGGY]  CSVRecord  rec;CSVRecord  next  =  current;  [BUGGY]  current  =  null;  if  (next  ==  null)  {    next  =  getNextRecord();  if  (next  ==  null)  {  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }  return  next;  }    [CLASS]  CSVParser  1  [METHOD]  next  [RETURN_TYPE]  CSVRecord    [VARIABLES]  Lexer  lexer  List  record  records  Token  reusableToken  CSVRecord  current  next  rec  result  boolean  Map  hdrMap  headerMapping    	[P11_Insert_Donor_Statement]
[PATCH]  current  =  null;	[BUG]  [BUGGY]  current  =  this;[CE]  incompatible  types  [CONTEXT]  public  CSVRecord  next()  {  CSVRecord  next  =  current;  [BUGGY]  current  =  this;  [BUGGY]    if  (next  ==  null)  {    next  =  getNextRecord();  if  (next  ==  null)  {  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }  return  next;  }    [CLASS]  CSVParser  1  [METHOD]  next  [RETURN_TYPE]  CSVRecord    [VARIABLES]  Lexer  lexer  List  record  records  Token  reusableToken  CSVRecord  current  next  rec  result  boolean  Map  hdrMap  headerMapping    	[P8_Replace_Mix]
[PATCH]  current  =  null;	[BUG]  [BUGGY]  result  =  null;current  =  null;[CE]  cannot  find  symbol  result  [CONTEXT]  public  CSVRecord  next()  {  CSVRecord  next  =  current;  [BUGGY]  result  =  null;current  =  null;  [BUGGY]    if  (next  ==  null)  {    next  =  getNextRecord();  if  (next  ==  null)  {  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }  return  next;  }    [CLASS]  CSVParser  1  [METHOD]  next  [RETURN_TYPE]  CSVRecord    [VARIABLES]  Lexer  lexer  List  record  records  Token  reusableToken  CSVRecord  current  next  rec  result  boolean  Map  hdrMap  headerMapping    	[P11_Insert_Donor_Statement]
[PATCH]  current  =  null;	[BUG]  [BUGGY]  if  (  current  ==  null)  {  current  =  null;  }[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  CSVRecord  next()  {  CSVRecord  next  =  current;  [BUGGY]  if  (  current  ==  null)  {  current  =  null;  }  [BUGGY]    if  (next  ==  null)  {    next  =  getNextRecord();  if  (next  ==  null)  {  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }  return  next;  }    [CLASS]  CSVParser  1  [METHOD]  next  [RETURN_TYPE]  CSVRecord    [VARIABLES]  Lexer  lexer  List  record  records  Token  reusableToken  CSVRecord  current  next  rec  result  boolean  Map  hdrMap  headerMapping    	[P12_Insert_Condition]
[PATCH]  if  (  next  ==  null  )  {	[BUG]  [BUGGY]  if  (  next  !=  null)  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;  [BUGGY]  if  (  next  !=  null)  {  [BUGGY]    next  =  getNextRecord();  if  (next  ==  null)  {  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }  return  next;  }    [CLASS]  CSVParser  1  [METHOD]  next  [RETURN_TYPE]  CSVRecord    [VARIABLES]  Lexer  lexer  List  record  records  Token  reusableToken  CSVRecord  current  next  rec  result  boolean  Map  hdrMap  headerMapping    	[P2_Replace_Operator]
[PATCH]  if  (  next  ==  null  )  {	[BUG]  [BUGGY]  if  (  result  ==  null)  {[CE]  cannot  find  symbol  result  [CONTEXT]  public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;  [BUGGY]  if  (  result  ==  null)  {  [BUGGY]    next  =  getNextRecord();  if  (next  ==  null)  {  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }  return  next;  }    [CLASS]  CSVParser  1  [METHOD]  next  [RETURN_TYPE]  CSVRecord    [VARIABLES]  Lexer  lexer  List  record  records  Token  reusableToken  CSVRecord  current  next  rec  result  boolean  Map  hdrMap  headerMapping    	[P5_Replace_Variable]
[PATCH]  if  (  next  ==  null  )  {	[BUG]  [BUGGY]  if  (  next  ==  false)  {[CE]  incomparable  types:  CSVRecord  and  boolean  [CONTEXT]  public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;  [BUGGY]  if  (  next  ==  false)  {  [BUGGY]    next  =  getNextRecord();  if  (next  ==  null)  {  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }  return  next;  }    [CLASS]  CSVParser  1  [METHOD]  next  [RETURN_TYPE]  CSVRecord    [VARIABLES]  Lexer  lexer  List  record  records  Token  reusableToken  CSVRecord  current  next  rec  result  boolean  Map  hdrMap  headerMapping    	[P8_Replace_Mix]
[PATCH]  if  (  next  ==  null  )  {	[BUG]  [BUGGY]  if  (  header  !=  null)  {[CE]  cannot  find  symbol  header  [CONTEXT]  public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;  [BUGGY]  if  (  header  !=  null)  {  [BUGGY]    next  =  getNextRecord();  if  (next  ==  null)  {  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }  return  next;  }    [CLASS]  CSVParser  1  [METHOD]  next  [RETURN_TYPE]  CSVRecord    [VARIABLES]  Lexer  lexer  List  record  records  Token  reusableToken  CSVRecord  current  next  rec  result  boolean  Map  hdrMap  headerMapping    	[P9_Replace_Statement]
[PATCH]  if  (  next  ==  null  )  {	[BUG]  [BUGGY]  if  (  current  ==  null)  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;  [BUGGY]  if  (  current  ==  null)  {  [BUGGY]    next  =  getNextRecord();  if  (next  ==  null)  {  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }  return  next;  }    [CLASS]  CSVParser  1  [METHOD]  next  [RETURN_TYPE]  CSVRecord    [VARIABLES]  Lexer  lexer  List  record  records  Token  reusableToken  CSVRecord  current  next  rec  result  boolean  Map  hdrMap  headerMapping    	[P9_Replace_Statement]
[PATCH]  if  (  next  ==  null  )  {	[BUG]  [BUGGY]  if  (  rec  !=  null)  {[CE]  cannot  find  symbol  rec  [CONTEXT]  public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;  [BUGGY]  if  (  rec  !=  null)  {  [BUGGY]    next  =  getNextRecord();  if  (next  ==  null)  {  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }  return  next;  }    [CLASS]  CSVParser  1  [METHOD]  next  [RETURN_TYPE]  CSVRecord    [VARIABLES]  Lexer  lexer  List  record  records  Token  reusableToken  CSVRecord  current  next  rec  result  boolean  Map  hdrMap  headerMapping    	[P9_Replace_Statement]
[PATCH]  if  (  next  ==  null  )  {  next  =  getNextRecord  (  )  ;  if  (  next  ==  null  )  {  throw  new  NoSuchElementException  ( "   ")  ;  }	[BUG]  [BUGGY]  next  =  getNextRecord();  if(next  ==  null)  {    throw  new  java.util.NoSuchElementException( "No  more  CSV  records  available ");};[CE]  illegal  start  of  type  [CONTEXT]  public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;  [BUGGY]  next  =  getNextRecord();  if(next  ==  null)  {    throw  new  java.util.NoSuchElementException( "No  more  CSV  records  available ");};  [BUGGY]    next  =  getNextRecord();  if  (next  ==  null)  {throw  new  java.util.NoSuchElementException( "No  more  CSV  records  available ");};    }  }  return  next;    [CLASS]  CSVParser  1  [METHOD]  next  [RETURN_TYPE]  CSVRecord    [VARIABLES]  Lexer  lexer  List  record  records  Token  reusableToken  CSVRecord  current  next  rec  result  boolean  Map  hdrMap  headerMapping    	[P15_Unwrap_Block]
[PATCH]  if  (  next  ==  null  )  {  next  =  getNextRecord  (  )  ;  if  (  next  ==  null  )  {  throw  new  NoSuchElementException  ( "   ")  ;  }	[BUG]  [BUGGY]  [CE]  illegal  start  of  type  [CONTEXT]  public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;  [BUGGY]  [BUGGY]        }  }  return  next;    [CLASS]  CSVParser  1  [METHOD]  next  [RETURN_TYPE]  CSVRecord    [VARIABLES]  Lexer  lexer  List  record  records  Token  reusableToken  CSVRecord  current  next  rec  result  boolean  Map  hdrMap  headerMapping    	[P16_Remove_Block]
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  next  ==  null)  {      throw  new  NoSuchElementException(   "No  more  CSV  records  available ")  ;  }[CE]  illegal  start  of  type  [CONTEXT]  public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;  [BUGGY]  if  (  next  ==  null)  {      throw  new  NoSuchElementException(   "No  more  CSV  records  available ")  ;  }  [BUGGY]    next  =  getNextRecord();  if  (next  ==  null)  {  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }  return  next;  }    [CLASS]  CSVParser  1  [METHOD]  next  [RETURN_TYPE]  CSVRecord    [VARIABLES]  Lexer  lexer  List  record  records  Token  reusableToken  CSVRecord  current  next  rec  result  boolean  Map  hdrMap  headerMapping    	[P13_Insert_Block]
[PATCH]  if  (  next  ==  null  )  {	[BUG]  [BUGGY]  if  (  next  !=  null)  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;  if  (next  ==  null)  {    next  =  getNextRecord();  [BUGGY]  if  (  next  !=  null)  {  [BUGGY]  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }  return  next;  }    [CLASS]  CSVParser  1  [METHOD]  next  [RETURN_TYPE]  CSVRecord    [VARIABLES]  Lexer  lexer  List  record  records  Token  reusableToken  CSVRecord  current  next  rec  result  boolean  Map  hdrMap  headerMapping    	[P2_Replace_Operator]
[PATCH]  if  (  next  ==  null  )  {	[BUG]  [BUGGY]  if  (  result  ==  null)  {[CE]  cannot  find  symbol  result  [CONTEXT]  public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;  if  (next  ==  null)  {    next  =  getNextRecord();  [BUGGY]  if  (  result  ==  null)  {  [BUGGY]  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }  return  next;  }    [CLASS]  CSVParser  1  [METHOD]  next  [RETURN_TYPE]  CSVRecord    [VARIABLES]  Lexer  lexer  List  record  records  Token  reusableToken  CSVRecord  current  next  rec  result  boolean  Map  hdrMap  headerMapping    	[P5_Replace_Variable]
[PATCH]  if  (  next  ==  null  )  {	[BUG]  [BUGGY]  if  (  next  ==  false)  {[CE]  incomparable  types:  CSVRecord  and  boolean  [CONTEXT]  public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;  if  (next  ==  null)  {    next  =  getNextRecord();  [BUGGY]  if  (  next  ==  false)  {  [BUGGY]  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }  return  next;  }    [CLASS]  CSVParser  1  [METHOD]  next  [RETURN_TYPE]  CSVRecord    [VARIABLES]  Lexer  lexer  List  record  records  Token  reusableToken  CSVRecord  current  next  rec  result  boolean  Map  hdrMap  headerMapping    	[P8_Replace_Mix]
[PATCH]  if  (  next  ==  null  )  {	[BUG]  [BUGGY]  if  (  header  !=  null)  {[CE]  cannot  find  symbol  header  [CONTEXT]  public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;  if  (next  ==  null)  {    next  =  getNextRecord();  [BUGGY]  if  (  header  !=  null)  {  [BUGGY]  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }  return  next;  }    [CLASS]  CSVParser  1  [METHOD]  next  [RETURN_TYPE]  CSVRecord    [VARIABLES]  Lexer  lexer  List  record  records  Token  reusableToken  CSVRecord  current  next  rec  result  boolean  Map  hdrMap  headerMapping    	[P9_Replace_Statement]
[PATCH]  if  (  next  ==  null  )  {	[BUG]  [BUGGY]  if  (  current  ==  null)  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;  if  (next  ==  null)  {    next  =  getNextRecord();  [BUGGY]  if  (  current  ==  null)  {  [BUGGY]  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }  return  next;  }    [CLASS]  CSVParser  1  [METHOD]  next  [RETURN_TYPE]  CSVRecord    [VARIABLES]  Lexer  lexer  List  record  records  Token  reusableToken  CSVRecord  current  next  rec  result  boolean  Map  hdrMap  headerMapping    	[P9_Replace_Statement]
[PATCH]  if  (  next  ==  null  )  {	[BUG]  [BUGGY]  if  (  rec  !=  null)  {[CE]  cannot  find  symbol  rec  [CONTEXT]  public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;  if  (next  ==  null)  {    next  =  getNextRecord();  [BUGGY]  if  (  rec  !=  null)  {  [BUGGY]  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }  return  next;  }    [CLASS]  CSVParser  1  [METHOD]  next  [RETURN_TYPE]  CSVRecord    [VARIABLES]  Lexer  lexer  List  record  records  Token  reusableToken  CSVRecord  current  next  rec  result  boolean  Map  hdrMap  headerMapping    	[P9_Replace_Statement]
[PATCH]  if  (  next  ==  null  )  {  throw  new  NoSuchElementException  ( "   ")  ;  }	[BUG]  [BUGGY]  throw  new  java.util.NoSuchElementException( "No  more  CSV  records  available ");[CE]  illegal  start  of  expression  [CONTEXT]  public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;  if  (next  ==  null)  {    next  =  getNextRecord();  [BUGGY]  throw  new  java.util.NoSuchElementException( "No  more  CSV  records  available ");  [BUGGY]    throw  new  java.util.NoSuchElementException( "No  more  CSV  records  available ");  }  return  next;    [CLASS]  CSVParser  1  [METHOD]  next  [RETURN_TYPE]  CSVRecord    [VARIABLES]  Lexer  lexer  List  record  records  Token  reusableToken  CSVRecord  current  next  rec  result  boolean  Map  hdrMap  headerMapping    	[P15_Unwrap_Block]
[PATCH]  if  (  next  ==  null  )  {  throw  new  NoSuchElementException  ( "   ")  ;  }	[BUG]  [BUGGY]  [CE]  illegal  start  of  expression  [CONTEXT]  public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;  if  (next  ==  null)  {    next  =  getNextRecord();  [BUGGY]  [BUGGY]      }  return  next;    [CLASS]  CSVParser  1  [METHOD]  next  [RETURN_TYPE]  CSVRecord    [VARIABLES]  Lexer  lexer  List  record  records  Token  reusableToken  CSVRecord  current  next  rec  result  boolean  Map  hdrMap  headerMapping    	[P16_Remove_Block]
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  next  ==  null)  {      next  =  getNextRecord(  )  ;      if  (  next  ==  null)  {          throw  new  NoSuchElementException(   "No  more  CSV  records  available ")  ;      }  }[CE]  illegal  start  of  type  [CONTEXT]  public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;  if  (next  ==  null)  {    next  =  getNextRecord();  [BUGGY]  if  (  next  ==  null)  {      next  =  getNextRecord(  )  ;      if  (  next  ==  null)  {          throw  new  NoSuchElementException(   "No  more  CSV  records  available ")  ;      }  }  [BUGGY]  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }  return  next;  }    [CLASS]  CSVParser  1  [METHOD]  next  [RETURN_TYPE]  CSVRecord    [VARIABLES]  Lexer  lexer  List  record  records  Token  reusableToken  CSVRecord  current  next  rec  result  boolean  Map  hdrMap  headerMapping    	[P13_Insert_Block]
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  next  ==  null)  {      throw  new  NoSuchElementException(   "No  more  CSV  records  available ")  ;  }[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;  if  (next  ==  null)  {    next  =  getNextRecord();  if  (next  ==  null)  {  [BUGGY]  if  (  next  ==  null)  {      throw  new  NoSuchElementException(   "No  more  CSV  records  available ")  ;  }  [BUGGY]  }  }  return  next;  }    [CLASS]  CSVParser  1  [METHOD]  next  [RETURN_TYPE]  CSVRecord    [VARIABLES]  Lexer  lexer  List  record  records  Token  reusableToken  CSVRecord  current  next  rec  result  boolean  Map  hdrMap  headerMapping    	[P13_Insert_Block]
[PATCH]  throw  new  NoSuchElementException  ( "   ")  ;	[BUG]  [BUGGY]  throw  new  UnsupportedOperationException  ( "   ")  ;throw  new  NoSuchElementException  ( "   ")  ;[CE]  unreachable  statement  [CONTEXT]  public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;  if  (next  ==  null)  {    next  =  getNextRecord();  if  (next  ==  null)  {  [BUGGY]  throw  new  UnsupportedOperationException  ( "   ")  ;throw  new  NoSuchElementException  ( "   ")  ;  [BUGGY]  }  }  return  next;  }    [CLASS]  CSVParser  1  [METHOD]  next  [RETURN_TYPE]  CSVRecord    [VARIABLES]  Lexer  lexer  List  record  records  Token  reusableToken  CSVRecord  current  next  rec  result  boolean  Map  hdrMap  headerMapping    	[P11_Insert_Donor_Statement]
[PATCH]  throw  new  NoSuchElementException  ( "   ")  ;	[BUG]  [BUGGY]  throw  new  RuntimeException  ( "   ")  ;throw  new  NoSuchElementException  ( "   ")  ;[CE]  unreachable  statement  [CONTEXT]  public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;  if  (next  ==  null)  {    next  =  getNextRecord();  if  (next  ==  null)  {  [BUGGY]  throw  new  RuntimeException  ( "   ")  ;throw  new  NoSuchElementException  ( "   ")  ;  [BUGGY]  }  }  return  next;  }    [CLASS]  CSVParser  1  [METHOD]  next  [RETURN_TYPE]  CSVRecord    [VARIABLES]  Lexer  lexer  List  record  records  Token  reusableToken  CSVRecord  current  next  rec  result  boolean  Map  hdrMap  headerMapping    	[P11_Insert_Donor_Statement]
[PATCH]  throw  new  NoSuchElementException  ( "   ")  ;	[BUG]  [BUGGY]  throw  new  IOException  ( "   ")  ;throw  new  NoSuchElementException  ( "   ")  ;[CE]  unreachable  statement  [CONTEXT]  public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;  if  (next  ==  null)  {    next  =  getNextRecord();  if  (next  ==  null)  {  [BUGGY]  throw  new  IOException  ( "   ")  ;throw  new  NoSuchElementException  ( "   ")  ;  [BUGGY]  }  }  return  next;  }    [CLASS]  CSVParser  1  [METHOD]  next  [RETURN_TYPE]  CSVRecord    [VARIABLES]  Lexer  lexer  List  record  records  Token  reusableToken  CSVRecord  current  next  rec  result  boolean  Map  hdrMap  headerMapping    	[P11_Insert_Donor_Statement]
[PATCH]  next  =  getNextRecord  (  )  ;	[BUG]  [BUGGY]  next  =  1(  )  ;[CE]  ';'  expected  [CONTEXT]  public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;  if  (next  ==  null)  {    [BUGGY]  next  =  1(  )  ;  [BUGGY]  if  (next  ==  null)  {  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }  return  next;  }    [CLASS]  CSVParser  1  [METHOD]  next  [RETURN_TYPE]  CSVRecord    [VARIABLES]  Lexer  lexer  List  record  records  Token  reusableToken  CSVRecord  current  next  rec  result  boolean  Map  hdrMap  headerMapping    	[P7_Replace_Invocation]
[PATCH]  next  =  getNextRecord  (  )  ;	[BUG]  [BUGGY]  next  ;[CE]  not  a  statement  [CONTEXT]  public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;  if  (next  ==  null)  {    [BUGGY]  next  ;  [BUGGY]  if  (next  ==  null)  {  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }  return  next;  }    [CLASS]  CSVParser  1  [METHOD]  next  [RETURN_TYPE]  CSVRecord    [VARIABLES]  Lexer  lexer  List  record  records  Token  reusableToken  CSVRecord  current  next  rec  result  boolean  Map  hdrMap  headerMapping    	[P8_Replace_Mix]
[PATCH]  next  =  getNextRecord  (  )  ;	[BUG]  [BUGGY]  current  =  getNextRecord(  )  ;next  =  getNextRecord(  )  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;  if  (next  ==  null)  {    [BUGGY]  current  =  getNextRecord(  )  ;next  =  getNextRecord(  )  ;  [BUGGY]  if  (next  ==  null)  {  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }  return  next;  }    [CLASS]  CSVParser  1  [METHOD]  next  [RETURN_TYPE]  CSVRecord    [VARIABLES]  Lexer  lexer  List  record  records  Token  reusableToken  CSVRecord  current  next  rec  result  boolean  Map  hdrMap  headerMapping    	[P11_Insert_Donor_Statement]
[PATCH]  next  =  getNextRecord  (  )  ;	[BUG]  [BUGGY]  [FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;  if  (next  ==  null)  {    [BUGGY]  [BUGGY]    if  (next  ==  null)  {  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }  return  next;    [CLASS]  CSVParser  1  [METHOD]  next  [RETURN_TYPE]  CSVRecord    [VARIABLES]  Lexer  lexer  List  record  records  Token  reusableToken  CSVRecord  current  next  rec  result  boolean  Map  hdrMap  headerMapping    	[P14_Delete_Statement]
[PATCH]  next  =  getNextRecord  (  )  ;	[BUG]  [BUGGY]  CSVRecord  rec  =  getRecord(  )  ;next  =  getNextRecord(  )  ;[CE]  unreported  exception  IOException;  must  be  caught  or  declared  to  be  thrown  [CONTEXT]  public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;  if  (next  ==  null)  {    [BUGGY]  CSVRecord  rec  =  getRecord(  )  ;next  =  getNextRecord(  )  ;  [BUGGY]  if  (next  ==  null)  {  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }  return  next;  }    [CLASS]  CSVParser  1  [METHOD]  next  [RETURN_TYPE]  CSVRecord    [VARIABLES]  Lexer  lexer  List  record  records  Token  reusableToken  CSVRecord  current  next  rec  result  boolean  Map  hdrMap  headerMapping    	[P11_Insert_Donor_Statement]
[PATCH]  next  =  getNextRecord  (  )  ;	[BUG]  [BUGGY]  return  getRecord(  )  ;next  =  getNextRecord(  )  ;[CE]  unreachable  statement  [CONTEXT]  public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;  if  (next  ==  null)  {    [BUGGY]  return  getRecord(  )  ;next  =  getNextRecord(  )  ;  [BUGGY]  if  (next  ==  null)  {  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }  return  next;  }    [CLASS]  CSVParser  1  [METHOD]  next  [RETURN_TYPE]  CSVRecord    [VARIABLES]  Lexer  lexer  List  record  records  Token  reusableToken  CSVRecord  current  next  rec  result  boolean  Map  hdrMap  headerMapping    	[P11_Insert_Donor_Statement]
[PATCH]  if  (  next  ==  null  )  {	[BUG]  [BUGGY]  if  (  next  ==  true)  {[CE]  incomparable  types:  CSVRecord  and  boolean  [CONTEXT]  public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;  if  (next  ==  null)  {    next  =  getNextRecord();  [BUGGY]  if  (  next  ==  true)  {  [BUGGY]  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }  return  next;  }    [CLASS]  CSVParser  1  [METHOD]  next  [RETURN_TYPE]  CSVRecord    [VARIABLES]  Lexer  lexer  List  record  records  Token  reusableToken  CSVRecord  current  next  rec  result  boolean  Map  hdrMap  headerMapping    	[P8_Replace_Mix]
[PATCH]  throw  new  NoSuchElementException  ( "   ")  ;	[BUG]  [BUGGY]  throw  new  UnsupportedOperationException  ( "   ")  ;  ;[CE]  unreachable  statement  [CONTEXT]  public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;  if  (next  ==  null)  {    next  =  getNextRecord();  if  (next  ==  null)  {  [BUGGY]  throw  new  UnsupportedOperationException  ( "   ")  ;  ;  [BUGGY]  }  }  return  next;  }    [CLASS]  CSVParser  1  [METHOD]  next  [RETURN_TYPE]  CSVRecord    [VARIABLES]  Lexer  lexer  List  record  records  Token  reusableToken  CSVRecord  current  next  rec  result  boolean  Map  hdrMap  headerMapping    	[P8_Replace_Mix]
[PATCH]  next  =  getNextRecord  (  )  ;	[BUG]  [BUGGY]  next  =  next  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;  if  (next  ==  null)  {    [BUGGY]  next  =  next  ;  [BUGGY]  if  (next  ==  null)  {  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }  return  next;  }    [CLASS]  CSVParser  1  [METHOD]  next  [RETURN_TYPE]  CSVRecord    [VARIABLES]  Lexer  lexer  List  record  records  Token  reusableToken  CSVRecord  current  next  rec  result  boolean  Map  hdrMap  headerMapping    	[P8_Replace_Mix]
[PATCH]  return  next;	[BUG]  [BUGGY]  return  result;[CE]  cannot  find  symbol  result  [CONTEXT]  public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;  if  (next  ==  null)  {    next  =  getNextRecord();  if  (next  ==  null)  {  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }  [BUGGY]  return  result;  [BUGGY]  }    [CLASS]  CSVParser  1  [METHOD]  next  [RETURN_TYPE]  CSVRecord    [VARIABLES]  Lexer  lexer  List  record  records  Token  reusableToken  CSVRecord  current  next  rec  result  boolean  Map  hdrMap  headerMapping    	[P5_Replace_Variable]
[PATCH]  return  getRecord  (  )  ;	[BUG]  [BUGGY]  return  toString(  )  ;[CE]  incompatible  types  [CONTEXT]  private  CSVRecord  getNextRecord()  {  try  {  [BUGGY]  return  toString(  )  ;  [BUGGY]  }  catch  (IOException  e)  {  throw  new  RuntimeException(e);  }  }    [CLASS]  CSVParser  1  [METHOD]  getNextRecord  [RETURN_TYPE]  CSVRecord    [VARIABLES]  Lexer  lexer  boolean  List  record  records  Token  reusableToken  CSVRecord  current  next  rec  result  IOException  e  Map  hdrMap  headerMapping    	[P7_Replace_Invocation]
[PATCH]  return  getRecord  (  )  ;	[BUG]  [BUGGY]  [FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  private  CSVRecord  getNextRecord()  {  try  {  [BUGGY]  [BUGGY]    }  catch  (IOException  e)  {  throw  new  RuntimeException(e);  }    [CLASS]  CSVParser  1  [METHOD]  getNextRecord  [RETURN_TYPE]  CSVRecord    [VARIABLES]  Lexer  lexer  boolean  List  record  records  Token  reusableToken  CSVRecord  current  next  rec  result  IOException  e  Map  hdrMap  headerMapping    	[P14_Delete_Statement]
[PATCH]  throw  new  RuntimeException  ( "   ")  ;	[BUG]  [BUGGY]  throw  new  UnsupportedOperationException  ( "   ")  ;  ;[CE]  unreachable  statement  [CONTEXT]  private  CSVRecord  getNextRecord()  {  try  {  return  getRecord();  }  catch  (IOException  e)  {  [BUGGY]  throw  new  UnsupportedOperationException  ( "   ")  ;  ;  [BUGGY]  }  }    [CLASS]  CSVParser  1  [METHOD]  getNextRecord  [RETURN_TYPE]  CSVRecord    [VARIABLES]  Lexer  lexer  boolean  List  record  records  Token  reusableToken  CSVRecord  current  next  rec  result  IOException  e  Map  hdrMap  headerMapping    	[P8_Replace_Mix]
[PATCH]  throw  new  RuntimeException  ( "   ")  ;	[BUG]  [BUGGY]  throw  new  UnsupportedOperationException  ( "   ")  ;throw  new  RuntimeException  ( "   ")  ;[CE]  unreachable  statement  [CONTEXT]  private  CSVRecord  getNextRecord()  {  try  {  return  getRecord();  }  catch  (IOException  e)  {  [BUGGY]  throw  new  UnsupportedOperationException  ( "   ")  ;throw  new  RuntimeException  ( "   ")  ;  [BUGGY]  }  }    [CLASS]  CSVParser  1  [METHOD]  getNextRecord  [RETURN_TYPE]  CSVRecord    [VARIABLES]  Lexer  lexer  boolean  List  record  records  Token  reusableToken  CSVRecord  current  next  rec  result  IOException  e  Map  hdrMap  headerMapping    	[P11_Insert_Donor_Statement]
[PATCH]  throw  new  RuntimeException  ( "   ")  ;	[BUG]  [BUGGY]  throw  new  IOException  ( "   ")  ;throw  new  RuntimeException  ( "   ")  ;[CE]  unreachable  statement  [CONTEXT]  private  CSVRecord  getNextRecord()  {  try  {  return  getRecord();  }  catch  (IOException  e)  {  [BUGGY]  throw  new  IOException  ( "   ")  ;throw  new  RuntimeException  ( "   ")  ;  [BUGGY]  }  }    [CLASS]  CSVParser  1  [METHOD]  getNextRecord  [RETURN_TYPE]  CSVRecord    [VARIABLES]  Lexer  lexer  boolean  List  record  records  Token  reusableToken  CSVRecord  current  next  rec  result  IOException  e  Map  hdrMap  headerMapping    	[P11_Insert_Donor_Statement]
[PATCH]  throw  new  RuntimeException  ( "   ")  ;	[BUG]  [BUGGY]  throw  new  NoSuchElementException  ( "   ")  ;throw  new  RuntimeException  ( "   ")  ;[CE]  unreachable  statement  [CONTEXT]  private  CSVRecord  getNextRecord()  {  try  {  return  getRecord();  }  catch  (IOException  e)  {  [BUGGY]  throw  new  NoSuchElementException  ( "   ")  ;throw  new  RuntimeException  ( "   ")  ;  [BUGGY]  }  }    [CLASS]  CSVParser  1  [METHOD]  getNextRecord  [RETURN_TYPE]  CSVRecord    [VARIABLES]  Lexer  lexer  boolean  List  record  records  Token  reusableToken  CSVRecord  current  next  rec  result  IOException  e  Map  hdrMap  headerMapping    	[P11_Insert_Donor_Statement]
[PATCH]  throw  new  UnsupportedOperationException  ( "   ")  ;	[BUG]  [BUGGY]  throw  new  RuntimeException  ( "   ")  ;throw  new  UnsupportedOperationException  ( "   ")  ;[CE]  unreachable  statement  [CONTEXT]  public  void  remove()  {  [BUGGY]  throw  new  RuntimeException  ( "   ")  ;throw  new  UnsupportedOperationException  ( "   ")  ;  [BUGGY]  }    [CLASS]  CSVParser  1  [METHOD]  remove  [RETURN_TYPE]  void    [VARIABLES]  Lexer  lexer  List  record  records  Token  reusableToken  CSVRecord  current  next  rec  result  boolean  Map  hdrMap  headerMapping    	[P11_Insert_Donor_Statement]
[PATCH]  throw  new  UnsupportedOperationException  ( "   ")  ;	[BUG]  [BUGGY]  throw  new  IOException  ( "   ")  ;throw  new  UnsupportedOperationException  ( "   ")  ;[CE]  unreachable  statement  [CONTEXT]  public  void  remove()  {  [BUGGY]  throw  new  IOException  ( "   ")  ;throw  new  UnsupportedOperationException  ( "   ")  ;  [BUGGY]  }    [CLASS]  CSVParser  1  [METHOD]  remove  [RETURN_TYPE]  void    [VARIABLES]  Lexer  lexer  List  record  records  Token  reusableToken  CSVRecord  current  next  rec  result  boolean  Map  hdrMap  headerMapping    	[P11_Insert_Donor_Statement]
[PATCH]  throw  new  UnsupportedOperationException  ( "   ")  ;	[BUG]  [BUGGY]  throw  new  NoSuchElementException  ( "   ")  ;throw  new  UnsupportedOperationException  ( "   ")  ;[CE]  unreachable  statement  [CONTEXT]  public  void  remove()  {  [BUGGY]  throw  new  NoSuchElementException  ( "   ")  ;throw  new  UnsupportedOperationException  ( "   ")  ;  [BUGGY]  }    [CLASS]  CSVParser  1  [METHOD]  remove  [RETURN_TYPE]  void    [VARIABLES]  Lexer  lexer  List  record  records  Token  reusableToken  CSVRecord  current  next  rec  result  boolean  Map  hdrMap  headerMapping    	[P11_Insert_Donor_Statement]
[PATCH]  return  lexer.getLineNumber  (  )  ;	[BUG]  [BUGGY]  [FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  int  getLineNumber()  {  [BUGGY]  [BUGGY]      [CLASS]  CSVParser  1  [METHOD]  getLineNumber  [RETURN_TYPE]  int    [VARIABLES]  Lexer  lexer  List  record  records  Token  reusableToken  CSVRecord  current  next  rec  result  boolean  Map  hdrMap  headerMapping    	[P14_Delete_Statement]
[PATCH]  if  (  current  ==  null  )  {	[BUG]  [BUGGY]  if  (  current  !=  null)  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  boolean  hasNext()  {  [BUGGY]  if  (  current  !=  null)  {  [BUGGY]  current  =  getNextRecord();  }  return  current  !=  null;  }    [CLASS]  1  [METHOD]  hasNext  [RETURN_TYPE]  boolean    [VARIABLES]  CSVRecord  current  boolean    	[P2_Replace_Operator]
[PATCH]  if  (  current  ==  null  )  {	[BUG]  [BUGGY]  if  (  current  ==  true)  {[CE]  incomparable  types:  CSVRecord  and  boolean  [CONTEXT]  public  boolean  hasNext()  {  [BUGGY]  if  (  current  ==  true)  {  [BUGGY]  current  =  getNextRecord();  }  return  current  !=  null;  }    [CLASS]  1  [METHOD]  hasNext  [RETURN_TYPE]  boolean    [VARIABLES]  CSVRecord  current  boolean    	[P8_Replace_Mix]
[PATCH]  if  (  current  ==  null  )  {	[BUG]  [BUGGY]  if  (  next  ==  null)  {[CE]  cannot  find  symbol  next  [CONTEXT]  public  boolean  hasNext()  {  [BUGGY]  if  (  next  ==  null)  {  [BUGGY]  current  =  getNextRecord();  }  return  current  !=  null;  }    [CLASS]  1  [METHOD]  hasNext  [RETURN_TYPE]  boolean    [VARIABLES]  CSVRecord  current  boolean    	[P9_Replace_Statement]
[PATCH]  if  (  current  ==  null  )  {  current  =  getNextRecord  (  )  ;  }	[BUG]  [BUGGY]  current  =  getNextRecord();[CE]  illegal  start  of  expression  [CONTEXT]  public  boolean  hasNext()  {  [BUGGY]  current  =  getNextRecord();  [BUGGY]    current  =  getNextRecord();    return  current  !=  null;    [CLASS]  1  [METHOD]  hasNext  [RETURN_TYPE]  boolean    [VARIABLES]  CSVRecord  current  boolean    	[P15_Unwrap_Block]
[PATCH]  if  (  current  ==  null  )  {  current  =  getNextRecord  (  )  ;  }	[BUG]  [BUGGY]  [CE]  illegal  start  of  expression  [CONTEXT]  public  boolean  hasNext()  {  [BUGGY]  [BUGGY]      return  current  !=  null;    [CLASS]  1  [METHOD]  hasNext  [RETURN_TYPE]  boolean    [VARIABLES]  CSVRecord  current  boolean    	[P16_Remove_Block]
[PATCH]  current  =  getNextRecord  (  )  ;	[BUG]  [BUGGY]  current  =  current  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  boolean  hasNext()  {  if  (current  ==  null)  {  [BUGGY]  current  =  current  ;  [BUGGY]  }  return  current  !=  null;  }    [CLASS]  1  [METHOD]  hasNext  [RETURN_TYPE]  boolean    [VARIABLES]  CSVRecord  current  boolean    	[P8_Replace_Mix]
[PATCH]  current  =  getNextRecord  (  )  ;	[BUG]  [BUGGY]  next  =  getNextRecord(  )  ;current  =  getNextRecord(  )  ;[CE]  cannot  find  symbol  next  [CONTEXT]  public  boolean  hasNext()  {  if  (current  ==  null)  {  [BUGGY]  next  =  getNextRecord(  )  ;current  =  getNextRecord(  )  ;  [BUGGY]  }  return  current  !=  null;  }    [CLASS]  1  [METHOD]  hasNext  [RETURN_TYPE]  boolean    [VARIABLES]  CSVRecord  current  boolean    	[P11_Insert_Donor_Statement]
[PATCH]  current  =  getNextRecord  (  )  ;	[BUG]  [BUGGY]  [FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  boolean  hasNext()  {  if  (current  ==  null)  {  [BUGGY]  [BUGGY]    }  return  current  !=  null;    [CLASS]  1  [METHOD]  hasNext  [RETURN_TYPE]  boolean    [VARIABLES]  CSVRecord  current  boolean    	[P14_Delete_Statement]
[PATCH]  current  =  getNextRecord  (  )  ;	[BUG]  [BUGGY]  return  getRecord(  )  ;current  =  getNextRecord(  )  ;[CE]  incompatible  types  [CONTEXT]  public  boolean  hasNext()  {  if  (current  ==  null)  {  [BUGGY]  return  getRecord(  )  ;current  =  getNextRecord(  )  ;  [BUGGY]  }  return  current  !=  null;  }    [CLASS]  1  [METHOD]  hasNext  [RETURN_TYPE]  boolean    [VARIABLES]  CSVRecord  current  boolean    	[P11_Insert_Donor_Statement]
[PATCH]  return  current  !=  null;	[BUG]  [BUGGY]  return  current  ==  null;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  boolean  hasNext()  {  if  (current  ==  null)  {  current  =  getNextRecord();  }  [BUGGY]  return  current  ==  null;  [BUGGY]  }    [CLASS]  1  [METHOD]  hasNext  [RETURN_TYPE]  boolean    [VARIABLES]  CSVRecord  current  boolean    	[P2_Replace_Operator]
[PATCH]  return  current  !=  null;	[BUG]  [BUGGY]  return  current  ;[CE]  incompatible  types  [CONTEXT]  public  boolean  hasNext()  {  if  (current  ==  null)  {  current  =  getNextRecord();  }  [BUGGY]  return  current  ;  [BUGGY]  }    [CLASS]  1  [METHOD]  hasNext  [RETURN_TYPE]  boolean    [VARIABLES]  CSVRecord  current  boolean    	[P8_Replace_Mix]
[PATCH]  return  current  !=  null;	[BUG]  [BUGGY]  if  (  current  ==  null)  {  return  current  !=  null;  }[CE]  missing  return  statement  [CONTEXT]  public  boolean  hasNext()  {  if  (current  ==  null)  {  current  =  getNextRecord();  }  [BUGGY]  if  (  current  ==  null)  {  return  current  !=  null;  }  [BUGGY]  }    [CLASS]  1  [METHOD]  hasNext  [RETURN_TYPE]  boolean    [VARIABLES]  CSVRecord  current  boolean    	[P12_Insert_Condition]
[PATCH]  current  =  null;	[BUG]  [BUGGY]  current  =  true;[CE]  incompatible  types  [CONTEXT]  public  CSVRecord  next()  {  CSVRecord  next  =  current;  [BUGGY]  current  =  true;  [BUGGY]    if  (next  ==  null)  {    next  =  getNextRecord();  if  (next  ==  null)  {  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }  return  next;  }    [CLASS]  1  [METHOD]  next  [RETURN_TYPE]  CSVRecord    [VARIABLES]  CSVRecord  current  next  boolean    	[P8_Replace_Mix]
[PATCH]  current  =  null;	[BUG]  [BUGGY]  if  (  current  ==  null)  {  current  =  null;  }[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  CSVRecord  next()  {  CSVRecord  next  =  current;  [BUGGY]  if  (  current  ==  null)  {  current  =  null;  }  [BUGGY]    if  (next  ==  null)  {    next  =  getNextRecord();  if  (next  ==  null)  {  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }  return  next;  }    [CLASS]  1  [METHOD]  next  [RETURN_TYPE]  CSVRecord    [VARIABLES]  CSVRecord  current  next  boolean    	[P12_Insert_Condition]
[PATCH]  if  (  next  ==  null  )  {	[BUG]  [BUGGY]  if  (  next  !=  null)  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;  [BUGGY]  if  (  next  !=  null)  {  [BUGGY]    next  =  getNextRecord();  if  (next  ==  null)  {  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }  return  next;  }    [CLASS]  1  [METHOD]  next  [RETURN_TYPE]  CSVRecord    [VARIABLES]  CSVRecord  current  next  boolean    	[P2_Replace_Operator]
[PATCH]  if  (  next  ==  null  )  {	[BUG]  [BUGGY]  if  (  current  ==  null)  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;  [BUGGY]  if  (  current  ==  null)  {  [BUGGY]    next  =  getNextRecord();  if  (next  ==  null)  {  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }  return  next;  }    [CLASS]  1  [METHOD]  next  [RETURN_TYPE]  CSVRecord    [VARIABLES]  CSVRecord  current  next  boolean    	[P5_Replace_Variable]
[PATCH]  if  (  next  ==  null  )  {	[BUG]  [BUGGY]  if  (  next  ==  true)  {[CE]  incomparable  types:  CSVRecord  and  boolean  [CONTEXT]  public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;  [BUGGY]  if  (  next  ==  true)  {  [BUGGY]    next  =  getNextRecord();  if  (next  ==  null)  {  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }  return  next;  }    [CLASS]  1  [METHOD]  next  [RETURN_TYPE]  CSVRecord    [VARIABLES]  CSVRecord  current  next  boolean    	[P8_Replace_Mix]
[PATCH]  if  (  next  ==  null  )  {  next  =  getNextRecord  (  )  ;  if  (  next  ==  null  )  {  throw  new  NoSuchElementException  ( "   ")  ;  }	[BUG]  [BUGGY]  next  =  getNextRecord();  if(next  ==  null)  {    throw  new  java.util.NoSuchElementException( "No  more  CSV  records  available ");};[CE]  illegal  start  of  type  [CONTEXT]  public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;  [BUGGY]  next  =  getNextRecord();  if(next  ==  null)  {    throw  new  java.util.NoSuchElementException( "No  more  CSV  records  available ");};  [BUGGY]    next  =  getNextRecord();  if  (next  ==  null)  {throw  new  java.util.NoSuchElementException( "No  more  CSV  records  available ");};    }  }  return  next;    [CLASS]  1  [METHOD]  next  [RETURN_TYPE]  CSVRecord    [VARIABLES]  CSVRecord  current  next  boolean    	[P15_Unwrap_Block]
[PATCH]  if  (  next  ==  null  )  {  next  =  getNextRecord  (  )  ;  if  (  next  ==  null  )  {  throw  new  NoSuchElementException  ( "   ")  ;  }	[BUG]  [BUGGY]  [CE]  illegal  start  of  type  [CONTEXT]  public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;  [BUGGY]  [BUGGY]        }  }  return  next;    [CLASS]  1  [METHOD]  next  [RETURN_TYPE]  CSVRecord    [VARIABLES]  CSVRecord  current  next  boolean    	[P16_Remove_Block]
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  next  ==  null)  {      throw  new  NoSuchElementException(   "No  more  CSV  records  available ")  ;  }[CE]  illegal  start  of  type  [CONTEXT]  public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;  [BUGGY]  if  (  next  ==  null)  {      throw  new  NoSuchElementException(   "No  more  CSV  records  available ")  ;  }  [BUGGY]    next  =  getNextRecord();  if  (next  ==  null)  {  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }  return  next;  }    [CLASS]  1  [METHOD]  next  [RETURN_TYPE]  CSVRecord    [VARIABLES]  CSVRecord  current  next  boolean    	[P13_Insert_Block]
[PATCH]  if  (  next  ==  null  )  {	[BUG]  [BUGGY]  if  (  next  !=  null)  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;  if  (next  ==  null)  {    next  =  getNextRecord();  [BUGGY]  if  (  next  !=  null)  {  [BUGGY]  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }  return  next;  }    [CLASS]  1  [METHOD]  next  [RETURN_TYPE]  CSVRecord    [VARIABLES]  CSVRecord  current  next  boolean    	[P2_Replace_Operator]
[PATCH]  if  (  next  ==  null  )  {	[BUG]  [BUGGY]  if  (  current  ==  null)  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;  if  (next  ==  null)  {    next  =  getNextRecord();  [BUGGY]  if  (  current  ==  null)  {  [BUGGY]  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }  return  next;  }    [CLASS]  1  [METHOD]  next  [RETURN_TYPE]  CSVRecord    [VARIABLES]  CSVRecord  current  next  boolean    	[P5_Replace_Variable]
[PATCH]  if  (  next  ==  null  )  {	[BUG]  [BUGGY]  if  (  next  ==  true)  {[CE]  incomparable  types:  CSVRecord  and  boolean  [CONTEXT]  public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;  if  (next  ==  null)  {    next  =  getNextRecord();  [BUGGY]  if  (  next  ==  true)  {  [BUGGY]  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }  return  next;  }    [CLASS]  1  [METHOD]  next  [RETURN_TYPE]  CSVRecord    [VARIABLES]  CSVRecord  current  next  boolean    	[P8_Replace_Mix]
[PATCH]  if  (  next  ==  null  )  {  throw  new  NoSuchElementException  ( "   ")  ;  }	[BUG]  [BUGGY]  throw  new  java.util.NoSuchElementException( "No  more  CSV  records  available ");[CE]  illegal  start  of  expression  [CONTEXT]  public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;  if  (next  ==  null)  {    next  =  getNextRecord();  [BUGGY]  throw  new  java.util.NoSuchElementException( "No  more  CSV  records  available ");  [BUGGY]    throw  new  java.util.NoSuchElementException( "No  more  CSV  records  available ");  }  return  next;    [CLASS]  1  [METHOD]  next  [RETURN_TYPE]  CSVRecord    [VARIABLES]  CSVRecord  current  next  boolean    	[P15_Unwrap_Block]
[PATCH]  if  (  next  ==  null  )  {  throw  new  NoSuchElementException  ( "   ")  ;  }	[BUG]  [BUGGY]  [CE]  illegal  start  of  expression  [CONTEXT]  public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;  if  (next  ==  null)  {    next  =  getNextRecord();  [BUGGY]  [BUGGY]      }  return  next;    [CLASS]  1  [METHOD]  next  [RETURN_TYPE]  CSVRecord    [VARIABLES]  CSVRecord  current  next  boolean    	[P16_Remove_Block]
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  next  ==  null)  {      next  =  getNextRecord(  )  ;      if  (  next  ==  null)  {          throw  new  NoSuchElementException(   "No  more  CSV  records  available ")  ;      }  }[CE]  illegal  start  of  type  [CONTEXT]  public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;  if  (next  ==  null)  {    next  =  getNextRecord();  [BUGGY]  if  (  next  ==  null)  {      next  =  getNextRecord(  )  ;      if  (  next  ==  null)  {          throw  new  NoSuchElementException(   "No  more  CSV  records  available ")  ;      }  }  [BUGGY]  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }  return  next;  }    [CLASS]  1  [METHOD]  next  [RETURN_TYPE]  CSVRecord    [VARIABLES]  CSVRecord  current  next  boolean    	[P13_Insert_Block]
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  next  ==  null)  {      throw  new  NoSuchElementException(   "No  more  CSV  records  available ")  ;  }[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;  if  (next  ==  null)  {    next  =  getNextRecord();  if  (next  ==  null)  {  [BUGGY]  if  (  next  ==  null)  {      throw  new  NoSuchElementException(   "No  more  CSV  records  available ")  ;  }  [BUGGY]  }  }  return  next;  }    [CLASS]  1  [METHOD]  next  [RETURN_TYPE]  CSVRecord    [VARIABLES]  CSVRecord  current  next  boolean    	[P13_Insert_Block]
[PATCH]  throw  new  NoSuchElementException  ( "   ")  ;	[BUG]  [BUGGY]  throw  new  UnsupportedOperationException  ( "   ")  ;throw  new  NoSuchElementException  ( "   ")  ;[CE]  unreachable  statement  [CONTEXT]  public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;  if  (next  ==  null)  {    next  =  getNextRecord();  if  (next  ==  null)  {  [BUGGY]  throw  new  UnsupportedOperationException  ( "   ")  ;throw  new  NoSuchElementException  ( "   ")  ;  [BUGGY]  }  }  return  next;  }    [CLASS]  1  [METHOD]  next  [RETURN_TYPE]  CSVRecord    [VARIABLES]  CSVRecord  current  next  boolean    	[P11_Insert_Donor_Statement]
[PATCH]  throw  new  NoSuchElementException  ( "   ")  ;	[BUG]  [BUGGY]  throw  new  RuntimeException  ( "   ")  ;throw  new  NoSuchElementException  ( "   ")  ;[CE]  unreachable  statement  [CONTEXT]  public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;  if  (next  ==  null)  {    next  =  getNextRecord();  if  (next  ==  null)  {  [BUGGY]  throw  new  RuntimeException  ( "   ")  ;throw  new  NoSuchElementException  ( "   ")  ;  [BUGGY]  }  }  return  next;  }    [CLASS]  1  [METHOD]  next  [RETURN_TYPE]  CSVRecord    [VARIABLES]  CSVRecord  current  next  boolean    	[P11_Insert_Donor_Statement]
[PATCH]  next  =  getNextRecord  (  )  ;	[BUG]  [BUGGY]  next  =  null  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;  if  (next  ==  null)  {    [BUGGY]  next  =  null  ;  [BUGGY]  if  (next  ==  null)  {  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }  return  next;  }    [CLASS]  1  [METHOD]  next  [RETURN_TYPE]  CSVRecord    [VARIABLES]  CSVRecord  current  next  boolean    	[P8_Replace_Mix]
[PATCH]  next  =  getNextRecord  (  )  ;	[BUG]  [BUGGY]  current  =  getNextRecord(  )  ;next  =  getNextRecord(  )  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;  if  (next  ==  null)  {    [BUGGY]  current  =  getNextRecord(  )  ;next  =  getNextRecord(  )  ;  [BUGGY]  if  (next  ==  null)  {  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }  return  next;  }    [CLASS]  1  [METHOD]  next  [RETURN_TYPE]  CSVRecord    [VARIABLES]  CSVRecord  current  next  boolean    	[P11_Insert_Donor_Statement]
[PATCH]  next  =  getNextRecord  (  )  ;	[BUG]  [BUGGY]  [FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;  if  (next  ==  null)  {    [BUGGY]  [BUGGY]    if  (next  ==  null)  {  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }  return  next;    [CLASS]  1  [METHOD]  next  [RETURN_TYPE]  CSVRecord    [VARIABLES]  CSVRecord  current  next  boolean    	[P14_Delete_Statement]
[PATCH]  next  =  getNextRecord  (  )  ;	[BUG]  [BUGGY]  return  getRecord(  )  ;next  =  getNextRecord(  )  ;[CE]  unreachable  statement  [CONTEXT]  public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;  if  (next  ==  null)  {    [BUGGY]  return  getRecord(  )  ;next  =  getNextRecord(  )  ;  [BUGGY]  if  (next  ==  null)  {  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }  return  next;  }    [CLASS]  1  [METHOD]  next  [RETURN_TYPE]  CSVRecord    [VARIABLES]  CSVRecord  current  next  boolean    	[P11_Insert_Donor_Statement]
[PATCH]  if  (  next  ==  null  )  {	[BUG]  [BUGGY]  if  (  current  ==  false)  {[CE]  incomparable  types:  CSVRecord  and  boolean  [CONTEXT]  public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;  if  (next  ==  null)  {    next  =  getNextRecord();  [BUGGY]  if  (  current  ==  false)  {  [BUGGY]  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }  return  next;  }    [CLASS]  1  [METHOD]  next  [RETURN_TYPE]  CSVRecord    [VARIABLES]  CSVRecord  current  next  boolean    	[P8_Replace_Mix]
[PATCH]  throw  new  NoSuchElementException  ( "   ")  ;	[BUG]  [BUGGY]  throw  new  UnsupportedOperationException  ( "   ")  ;  ;[CE]  unreachable  statement  [CONTEXT]  public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;  if  (next  ==  null)  {    next  =  getNextRecord();  if  (next  ==  null)  {  [BUGGY]  throw  new  UnsupportedOperationException  ( "   ")  ;  ;  [BUGGY]  }  }  return  next;  }    [CLASS]  1  [METHOD]  next  [RETURN_TYPE]  CSVRecord    [VARIABLES]  CSVRecord  current  next  boolean    	[P8_Replace_Mix]
[PATCH]  next  =  getNextRecord  (  )  ;	[BUG]  [BUGGY]  next  ;[CE]  not  a  statement  [CONTEXT]  public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;  if  (next  ==  null)  {    [BUGGY]  next  ;  [BUGGY]  if  (next  ==  null)  {  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }  return  next;  }    [CLASS]  1  [METHOD]  next  [RETURN_TYPE]  CSVRecord    [VARIABLES]  CSVRecord  current  next  boolean    	[P8_Replace_Mix]
[PATCH]  return  next;	[BUG]  [BUGGY]  return  current;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;  if  (next  ==  null)  {    next  =  getNextRecord();  if  (next  ==  null)  {  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }  [BUGGY]  return  current;  [BUGGY]  }    [CLASS]  1  [METHOD]  next  [RETURN_TYPE]  CSVRecord    [VARIABLES]  CSVRecord  current  next  boolean    	[P8_Replace_Mix]
[PATCH]  return  getRecord  (  )  ;	[BUG]  [BUGGY]  [FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  private  CSVRecord  getNextRecord()  {  try  {  [BUGGY]  [BUGGY]    }  catch  (IOException  e)  {  throw  new  RuntimeException(e);  }    [CLASS]  1  [METHOD]  getNextRecord  [RETURN_TYPE]  CSVRecord    [VARIABLES]  CSVRecord  current  next  IOException  e  boolean    	[P14_Delete_Statement]
[PATCH]  throw  new  RuntimeException  ( "   ")  ;	[BUG]  [BUGGY]  throw  new  UnsupportedOperationException  ( "   ")  ;  ;[CE]  unreachable  statement  [CONTEXT]  private  CSVRecord  getNextRecord()  {  try  {  return  getRecord();  }  catch  (IOException  e)  {  [BUGGY]  throw  new  UnsupportedOperationException  ( "   ")  ;  ;  [BUGGY]  }  }    [CLASS]  1  [METHOD]  getNextRecord  [RETURN_TYPE]  CSVRecord    [VARIABLES]  CSVRecord  current  next  IOException  e  boolean    	[P8_Replace_Mix]
[PATCH]  throw  new  RuntimeException  ( "   ")  ;	[BUG]  [BUGGY]  throw  new  UnsupportedOperationException  ( "   ")  ;throw  new  RuntimeException  ( "   ")  ;[CE]  unreachable  statement  [CONTEXT]  private  CSVRecord  getNextRecord()  {  try  {  return  getRecord();  }  catch  (IOException  e)  {  [BUGGY]  throw  new  UnsupportedOperationException  ( "   ")  ;throw  new  RuntimeException  ( "   ")  ;  [BUGGY]  }  }    [CLASS]  1  [METHOD]  getNextRecord  [RETURN_TYPE]  CSVRecord    [VARIABLES]  CSVRecord  current  next  IOException  e  boolean    	[P11_Insert_Donor_Statement]
[PATCH]  throw  new  RuntimeException  ( "   ")  ;	[BUG]  [BUGGY]  throw  new  NoSuchElementException  ( "   ")  ;throw  new  RuntimeException  ( "   ")  ;[CE]  unreachable  statement  [CONTEXT]  private  CSVRecord  getNextRecord()  {  try  {  return  getRecord();  }  catch  (IOException  e)  {  [BUGGY]  throw  new  NoSuchElementException  ( "   ")  ;throw  new  RuntimeException  ( "   ")  ;  [BUGGY]  }  }    [CLASS]  1  [METHOD]  getNextRecord  [RETURN_TYPE]  CSVRecord    [VARIABLES]  CSVRecord  current  next  IOException  e  boolean    	[P11_Insert_Donor_Statement]
[PATCH]  throw  new  UnsupportedOperationException  ( "   ")  ;	[BUG]  [BUGGY]  return  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  void  remove()  {  [BUGGY]  return  ;  [BUGGY]  }    [CLASS]  1  [METHOD]  remove  [RETURN_TYPE]  void    [VARIABLES]  CSVRecord  current  next  boolean    	[P8_Replace_Mix]
[PATCH]  throw  new  UnsupportedOperationException  ( "   ")  ;	[BUG]  [BUGGY]  throw  new  RuntimeException  ( "   ")  ;throw  new  UnsupportedOperationException  ( "   ")  ;[CE]  unreachable  statement  [CONTEXT]  public  void  remove()  {  [BUGGY]  throw  new  RuntimeException  ( "   ")  ;throw  new  UnsupportedOperationException  ( "   ")  ;  [BUGGY]  }    [CLASS]  1  [METHOD]  remove  [RETURN_TYPE]  void    [VARIABLES]  CSVRecord  current  next  boolean    	[P11_Insert_Donor_Statement]
[PATCH]  throw  new  UnsupportedOperationException  ( "   ")  ;	[BUG]  [BUGGY]  throw  new  NoSuchElementException  ( "   ")  ;throw  new  UnsupportedOperationException  ( "   ")  ;[CE]  unreachable  statement  [CONTEXT]  public  void  remove()  {  [BUGGY]  throw  new  NoSuchElementException  ( "   ")  ;throw  new  UnsupportedOperationException  ( "   ")  ;  [BUGGY]  }    [CLASS]  1  [METHOD]  remove  [RETURN_TYPE]  void    [VARIABLES]  CSVRecord  current  next  boolean    	[P11_Insert_Donor_Statement]
[PATCH]  super  (  format,  in  )  ;	[BUG]  [BUGGY]  super(  in)  ;[CE]  constructor  Lexer  in  class  Lexer  cannot  be  applied  to  given  types;  [CONTEXT]  public  CSVLexer(CSVFormat  format,  ExtendedBufferedReader  in)  {  [BUGGY]  super(  in)  ;  [BUGGY]  }    [CLASS]  CSVLexer  [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)    CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  boolean  ExtendedBufferedReader  in  CSVFormat  format    	[P5_Replace_Variable]
[PATCH]  super  (  format,  in  )  ;	[BUG]  [BUGGY]  super(  format)  ;[CE]  constructor  Lexer  in  class  Lexer  cannot  be  applied  to  given  types;  [CONTEXT]  public  CSVLexer(CSVFormat  format,  ExtendedBufferedReader  in)  {  [BUGGY]  super(  format)  ;  [BUGGY]  }    [CLASS]  CSVLexer  [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)    CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  boolean  ExtendedBufferedReader  in  CSVFormat  format    	[P5_Replace_Variable]
[PATCH]  super  (  format,  in  )  ;	[BUG]  [BUGGY]  super(  in,  format)  ;[CE]  constructor  Lexer  in  class  Lexer  cannot  be  applied  to  given  types;  [CONTEXT]  public  CSVLexer(CSVFormat  format,  ExtendedBufferedReader  in)  {  [BUGGY]  super(  in,  format)  ;  [BUGGY]  }    [CLASS]  CSVLexer  [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)    CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  boolean  ExtendedBufferedReader  in  CSVFormat  format    	[P5_Replace_Variable]
[PATCH]  super  (  format,  in  )  ;  }	[BUG]  [BUGGY]  [CE]  ';'  expected  [CONTEXT]  public  CSVLexer(CSVFormat  format,  ExtendedBufferedReader  in)  {  [BUGGY]  [BUGGY]      [CLASS]  CSVLexer  [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)    CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  boolean  ExtendedBufferedReader  in  CSVFormat  format    	[P14_Delete_Statement]
[PATCH]  int  lastChar  =  in.readAgain  (  )  ;	[BUG]  [BUGGY]  short  lastChar  =  in.readAgain(  )  ;[CE]  possible  loss  of  precision  [CONTEXT]  }                    @Override  Token  nextToken(Token  tkn)  throws  IOException  {    [BUGGY]  short  lastChar  =  in.readAgain(  )  ;  [BUGGY]              int  c  =  in.read();  boolean  eol  =  isEndOfLine(c);  c  =  in.readAgain();    if  (emptyLinesIgnored)  {  while  (eol  &&  (lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(lastChar))  {    [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P1_Replace_Type]
[PATCH]  int  lastChar  =  in.readAgain  (  )  ;	[BUG]  [BUGGY]  int  lastChar  =  in.readLine(  )  ;[CE]  incompatible  types  [CONTEXT]  }                    @Override  Token  nextToken(Token  tkn)  throws  IOException  {    [BUGGY]  int  lastChar  =  in.readLine(  )  ;  [BUGGY]              int  c  =  in.read();  boolean  eol  =  isEndOfLine(c);  c  =  in.readAgain();    if  (emptyLinesIgnored)  {  while  (eol  &&  (lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(lastChar))  {    [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P7_Replace_Invocation]
[PATCH]  int  lastChar  =  in.readAgain  (  )  ;	[BUG]  [BUGGY]  int  c  =  in.read(  )  ;int  lastChar  =  in.readAgain(  )  ;[CE]  variable  c  is  already  defined  in  method  nextToken(Token)  [CONTEXT]  }                    @Override  Token  nextToken(Token  tkn)  throws  IOException  {    [BUGGY]  int  c  =  in.read(  )  ;int  lastChar  =  in.readAgain(  )  ;  [BUGGY]              int  c  =  in.read();  boolean  eol  =  isEndOfLine(c);  c  =  in.readAgain();    if  (emptyLinesIgnored)  {  while  (eol  &&  (lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(lastChar))  {    [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P11_Insert_Donor_Statement]
[PATCH]  int  lastChar  =  in.readAgain  (  )  ;	[BUG]  [BUGGY]  [FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  }                    @Override  Token  nextToken(Token  tkn)  throws  IOException  {    [BUGGY]  [BUGGY]              int  c  =  in.read();  boolean  eol  =  isEndOfLine(c);  c  =  in.readAgain();    if  (emptyLinesIgnored)  {  while  (eol  &&  (lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)    [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P14_Delete_Statement]
[PATCH]  int  lastChar  =  in.readAgain  (  )  ;	[BUG]  [BUGGY]  c  =  in.readAgain(  )  ;int  lastChar  =  in.readAgain(  )  ;[CE]  cannot  find  symbol  c  [CONTEXT]  }                    @Override  Token  nextToken(Token  tkn)  throws  IOException  {    [BUGGY]  c  =  in.readAgain(  )  ;int  lastChar  =  in.readAgain(  )  ;  [BUGGY]              int  c  =  in.read();  boolean  eol  =  isEndOfLine(c);  c  =  in.readAgain();    if  (emptyLinesIgnored)  {  while  (eol  &&  (lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(lastChar))  {    [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P11_Insert_Donor_Statement]
[PATCH]  int  lastChar  =  in.readAgain  (  )  ;	[BUG]  [BUGGY]  c  =  in.read(  )  ;int  lastChar  =  in.readAgain(  )  ;[CE]  cannot  find  symbol  c  [CONTEXT]  }                    @Override  Token  nextToken(Token  tkn)  throws  IOException  {    [BUGGY]  c  =  in.read(  )  ;int  lastChar  =  in.readAgain(  )  ;  [BUGGY]              int  c  =  in.read();  boolean  eol  =  isEndOfLine(c);  c  =  in.readAgain();    if  (emptyLinesIgnored)  {  while  (eol  &&  (lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(lastChar))  {    [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P11_Insert_Donor_Statement]
[PATCH]  int  c  =  in.read  (  )  ;	[BUG]  [BUGGY]  short  c  =  in.read(  )  ;[CE]  possible  loss  of  precision  [CONTEXT]          @Override  Token  nextToken(Token  tkn)  throws  IOException  {    int  lastChar  =  in.readAgain();            [BUGGY]  short  c  =  in.read(  )  ;  [BUGGY]  boolean  eol  =  isEndOfLine(c);  c  =  in.readAgain();    if  (emptyLinesIgnored)  {  while  (eol  &&  (lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(lastChar))  {    lastChar  =  c;  c  =  in.read();  eol  =  isEndOfLine(c);  c  =  in.readAgain();    if  (isEndOfFile(c))  {    [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P1_Replace_Type]
[PATCH]  int  c  =  in.read  (  )  ;	[BUG]  [BUGGY]  int  c  =  in.readLine(  )  ;[CE]  incompatible  types  [CONTEXT]          @Override  Token  nextToken(Token  tkn)  throws  IOException  {    int  lastChar  =  in.readAgain();            [BUGGY]  int  c  =  in.readLine(  )  ;  [BUGGY]  boolean  eol  =  isEndOfLine(c);  c  =  in.readAgain();    if  (emptyLinesIgnored)  {  while  (eol  &&  (lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(lastChar))  {    lastChar  =  c;  c  =  in.read();  eol  =  isEndOfLine(c);  c  =  in.readAgain();    if  (isEndOfFile(c))  {    [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P7_Replace_Invocation]
[PATCH]  int  c  =  in.read  (  )  ;	[BUG]  [BUGGY]  int  lastChar  =  in.readAgain(  )  ;int  c  =  in.read(  )  ;[CE]  variable  lastChar  is  already  defined  in  method  nextToken(Token)  [CONTEXT]          @Override  Token  nextToken(Token  tkn)  throws  IOException  {    int  lastChar  =  in.readAgain();            [BUGGY]  int  lastChar  =  in.readAgain(  )  ;int  c  =  in.read(  )  ;  [BUGGY]  boolean  eol  =  isEndOfLine(c);  c  =  in.readAgain();    if  (emptyLinesIgnored)  {  while  (eol  &&  (lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(lastChar))  {    lastChar  =  c;  c  =  in.read();  eol  =  isEndOfLine(c);  c  =  in.readAgain();    if  (isEndOfFile(c))  {    [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P11_Insert_Donor_Statement]
[PATCH]  int  c  =  in.read  (  )  ;  boolean  eol  =  isEndOfLine  (  c  )  ;	[BUG]  [BUGGY]  [CE]  cannot  find  symbol  eol  [CONTEXT]          @Override  Token  nextToken(Token  tkn)  throws  IOException  {    int  lastChar  =  in.readAgain();            [BUGGY]  [BUGGY]    c  =  in.readAgain();    if  (emptyLinesIgnored)  {  while  (eol  &&  (lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(lastChar))  {    lastChar  =  c;  c  =  in.read();  eol  =  isEndOfLine(c);  c  =  in.readAgain();      [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P14_Delete_Statement]
[PATCH]  int  c  =  in.read  (  )  ;	[BUG]  [BUGGY]  c  =  in.readAgain(  )  ;int  c  =  in.read(  )  ;[CE]  cannot  find  symbol  c  [CONTEXT]          @Override  Token  nextToken(Token  tkn)  throws  IOException  {    int  lastChar  =  in.readAgain();            [BUGGY]  c  =  in.readAgain(  )  ;int  c  =  in.read(  )  ;  [BUGGY]  boolean  eol  =  isEndOfLine(c);  c  =  in.readAgain();    if  (emptyLinesIgnored)  {  while  (eol  &&  (lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(lastChar))  {    lastChar  =  c;  c  =  in.read();  eol  =  isEndOfLine(c);  c  =  in.readAgain();    if  (isEndOfFile(c))  {    [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P11_Insert_Donor_Statement]
[PATCH]  int  c  =  in.read  (  )  ;	[BUG]  [BUGGY]  c  =  in.read(  )  ;int  c  =  in.read(  )  ;[CE]  cannot  find  symbol  c  [CONTEXT]          @Override  Token  nextToken(Token  tkn)  throws  IOException  {    int  lastChar  =  in.readAgain();            [BUGGY]  c  =  in.read(  )  ;int  c  =  in.read(  )  ;  [BUGGY]  boolean  eol  =  isEndOfLine(c);  c  =  in.readAgain();    if  (emptyLinesIgnored)  {  while  (eol  &&  (lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(lastChar))  {    lastChar  =  c;  c  =  in.read();  eol  =  isEndOfLine(c);  c  =  in.readAgain();    if  (isEndOfFile(c))  {    [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P11_Insert_Donor_Statement]
[PATCH]  int  c  =  in.read  (  )  ;	[BUG]  [BUGGY]  in.readLine(  )  ;int  c  =  in.read(  )  ;[FE]  Token  type  expected:<TOKEN>  but  was:<EOF>  testNextToken1  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]          @Override  Token  nextToken(Token  tkn)  throws  IOException  {    int  lastChar  =  in.readAgain();            [BUGGY]  in.readLine(  )  ;int  c  =  in.read(  )  ;  [BUGGY]  boolean  eol  =  isEndOfLine(c);  c  =  in.readAgain();    if  (emptyLinesIgnored)  {  while  (eol  &&  (lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(lastChar))  {    lastChar  =  c;  c  =  in.read();  eol  =  isEndOfLine(c);  c  =  in.readAgain();    if  (isEndOfFile(c))  {    [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P11_Insert_Donor_Statement]
[PATCH]  boolean  eol  =  isEndOfLine  (  c  )  ;	[BUG]  [BUGGY]  boolean  eol  =  isEndOfLine(  lastChar)  ;[FE]  Token  content  expected:<[a]>  but  was:<[]>  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]        @Override  Token  nextToken(Token  tkn)  throws  IOException  {    int  lastChar  =  in.readAgain();            int  c  =  in.read();  [BUGGY]  boolean  eol  =  isEndOfLine(  lastChar)  ;  [BUGGY]  c  =  in.readAgain();    if  (emptyLinesIgnored)  {  while  (eol  &&  (lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(lastChar))  {    lastChar  =  c;  c  =  in.read();  eol  =  isEndOfLine(c);  c  =  in.readAgain();    if  (isEndOfFile(c))  {  tkn.type  =  EOF;    [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P5_Replace_Variable]
[PATCH]  boolean  eol  =  isEndOfLine  (  c  )  ;	[BUG]  [BUGGY]  boolean  eol  =  isEndOfFile(  c)  ;[FE]  Token  type  expected:<EOF>  but  was:<EORECORD>  testNextToken1  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]        @Override  Token  nextToken(Token  tkn)  throws  IOException  {    int  lastChar  =  in.readAgain();            int  c  =  in.read();  [BUGGY]  boolean  eol  =  isEndOfFile(  c)  ;  [BUGGY]  c  =  in.readAgain();    if  (emptyLinesIgnored)  {  while  (eol  &&  (lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(lastChar))  {    lastChar  =  c;  c  =  in.read();  eol  =  isEndOfLine(c);  c  =  in.readAgain();    if  (isEndOfFile(c))  {  tkn.type  =  EOF;    [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P7_Replace_Invocation]
[PATCH]  boolean  eol  =  isEndOfLine  (  c  )  ;	[BUG]  [BUGGY]  boolean  eol  =  isEndOfFile(  lastChar)  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]        @Override  Token  nextToken(Token  tkn)  throws  IOException  {    int  lastChar  =  in.readAgain();            int  c  =  in.read();  [BUGGY]  boolean  eol  =  isEndOfFile(  lastChar)  ;  [BUGGY]  c  =  in.readAgain();    if  (emptyLinesIgnored)  {  while  (eol  &&  (lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(lastChar))  {    lastChar  =  c;  c  =  in.read();  eol  =  isEndOfLine(c);  c  =  in.readAgain();    if  (isEndOfFile(c))  {  tkn.type  =  EOF;    [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P8_Replace_Mix]
[PATCH]  boolean  eol  =  isEndOfLine  (  c  )  ;	[BUG]  [BUGGY]  [FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]        @Override  Token  nextToken(Token  tkn)  throws  IOException  {    int  lastChar  =  in.readAgain();            int  c  =  in.read();  [BUGGY]  [BUGGY]    c  =  in.readAgain();    if  (emptyLinesIgnored)  {  while  (eol  &&  (lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(lastChar))  {    lastChar  =  c;  c  =  in.read();  eol  =  isEndOfLine(c);  c  =  in.readAgain();    if  (isEndOfFile(c))  {    [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P14_Delete_Statement]
[PATCH]  c  =  in.readAgain  (  )  ;	[BUG]  [BUGGY]  c  =  in.readLine(  )  ;[CE]  incompatible  types  [CONTEXT]      @Override  Token  nextToken(Token  tkn)  throws  IOException  {    int  lastChar  =  in.readAgain();            int  c  =  in.read();  boolean  eol  =  isEndOfLine(c);  [BUGGY]  c  =  in.readLine(  )  ;  [BUGGY]      if  (emptyLinesIgnored)  {  while  (eol  &&  (lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(lastChar))  {    lastChar  =  c;  c  =  in.read();  eol  =  isEndOfLine(c);  c  =  in.readAgain();    if  (isEndOfFile(c))  {  tkn.type  =  EOF;      [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P7_Replace_Invocation]
[PATCH]  c  =  in.readAgain  (  )  ;	[BUG]  [BUGGY]  c  =  c  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]      @Override  Token  nextToken(Token  tkn)  throws  IOException  {    int  lastChar  =  in.readAgain();            int  c  =  in.read();  boolean  eol  =  isEndOfLine(c);  [BUGGY]  c  =  c  ;  [BUGGY]      if  (emptyLinesIgnored)  {  while  (eol  &&  (lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(lastChar))  {    lastChar  =  c;  c  =  in.read();  eol  =  isEndOfLine(c);  c  =  in.readAgain();    if  (isEndOfFile(c))  {  tkn.type  =  EOF;      [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P8_Replace_Mix]
[PATCH]  c  =  in.readAgain  (  )  ;	[BUG]  [BUGGY]  eol  =  isEndOfLine(  c)  ;c  =  in.readAgain(  )  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]      @Override  Token  nextToken(Token  tkn)  throws  IOException  {    int  lastChar  =  in.readAgain();            int  c  =  in.read();  boolean  eol  =  isEndOfLine(c);  [BUGGY]  eol  =  isEndOfLine(  c)  ;c  =  in.readAgain(  )  ;  [BUGGY]      if  (emptyLinesIgnored)  {  while  (eol  &&  (lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(lastChar))  {    lastChar  =  c;  c  =  in.read();  eol  =  isEndOfLine(c);  c  =  in.readAgain();    if  (isEndOfFile(c))  {  tkn.type  =  EOF;      [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P11_Insert_Donor_Statement]
[PATCH]  c  =  in.readAgain  (  )  ;	[BUG]  [BUGGY]  c  =  in.read(  )  ;c  =  in.readAgain(  )  ;[FE]  Token  content  expected:<[a]bc>  but  was:<[]bc>  testNextToken1  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]      @Override  Token  nextToken(Token  tkn)  throws  IOException  {    int  lastChar  =  in.readAgain();            int  c  =  in.read();  boolean  eol  =  isEndOfLine(c);  [BUGGY]  c  =  in.read(  )  ;c  =  in.readAgain(  )  ;  [BUGGY]      if  (emptyLinesIgnored)  {  while  (eol  &&  (lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(lastChar))  {    lastChar  =  c;  c  =  in.read();  eol  =  isEndOfLine(c);  c  =  in.readAgain();    if  (isEndOfFile(c))  {  tkn.type  =  EOF;      [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P11_Insert_Donor_Statement]
[PATCH]  c  =  in.readAgain  (  )  ;	[BUG]  [BUGGY]  [FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]      @Override  Token  nextToken(Token  tkn)  throws  IOException  {    int  lastChar  =  in.readAgain();            int  c  =  in.read();  boolean  eol  =  isEndOfLine(c);  [BUGGY]  [BUGGY]      if  (emptyLinesIgnored)  {  while  (eol  &&  (lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(lastChar))  {    lastChar  =  c;  c  =  in.read();  eol  =  isEndOfLine(c);  c  =  in.readAgain();    if  (isEndOfFile(c))  {  tkn.type  =  EOF;    [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P14_Delete_Statement]
[PATCH]  c  =  in.readAgain  (  )  ;	[BUG]  [BUGGY]  int  lastChar  =  in.readAgain(  )  ;c  =  in.readAgain(  )  ;[CE]  variable  lastChar  is  already  defined  in  method  nextToken(Token)  [CONTEXT]      @Override  Token  nextToken(Token  tkn)  throws  IOException  {    int  lastChar  =  in.readAgain();            int  c  =  in.read();  boolean  eol  =  isEndOfLine(c);  [BUGGY]  int  lastChar  =  in.readAgain(  )  ;c  =  in.readAgain(  )  ;  [BUGGY]      if  (emptyLinesIgnored)  {  while  (eol  &&  (lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(lastChar))  {    lastChar  =  c;  c  =  in.read();  eol  =  isEndOfLine(c);  c  =  in.readAgain();    if  (isEndOfFile(c))  {  tkn.type  =  EOF;      [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P11_Insert_Donor_Statement]
[PATCH]  c  =  in.readAgain  (  )  ;	[BUG]  [BUGGY]  int  c  =  in.read(  )  ;c  =  in.readAgain(  )  ;[CE]  variable  c  is  already  defined  in  method  nextToken(Token)  [CONTEXT]      @Override  Token  nextToken(Token  tkn)  throws  IOException  {    int  lastChar  =  in.readAgain();            int  c  =  in.read();  boolean  eol  =  isEndOfLine(c);  [BUGGY]  int  c  =  in.read(  )  ;c  =  in.readAgain(  )  ;  [BUGGY]      if  (emptyLinesIgnored)  {  while  (eol  &&  (lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(lastChar))  {    lastChar  =  c;  c  =  in.read();  eol  =  isEndOfLine(c);  c  =  in.readAgain();    if  (isEndOfFile(c))  {  tkn.type  =  EOF;      [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P11_Insert_Donor_Statement]
[PATCH]  c  =  in.readAgain  (  )  ;	[BUG]  [BUGGY]  in.readLine(  )  ;c  =  in.readAgain(  )  ;[FE]  Token  content  expected:<[abc]>  but  was:<[]>  testNextToken1  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]      @Override  Token  nextToken(Token  tkn)  throws  IOException  {    int  lastChar  =  in.readAgain();            int  c  =  in.read();  boolean  eol  =  isEndOfLine(c);  [BUGGY]  in.readLine(  )  ;c  =  in.readAgain(  )  ;  [BUGGY]      if  (emptyLinesIgnored)  {  while  (eol  &&  (lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(lastChar))  {    lastChar  =  c;  c  =  in.read();  eol  =  isEndOfLine(c);  c  =  in.readAgain();    if  (isEndOfFile(c))  {  tkn.type  =  EOF;      [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P11_Insert_Donor_Statement]
[PATCH]  while  (  eol  &&  (  lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {	[BUG]  [BUGGY]  while  (  eol  ||  (  lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(  lastChar)  )  {[FE]  Token  content  expected:<[a]bc>  but  was:<[]bc>  testNextToken1  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]    int  lastChar  =  in.readAgain();            int  c  =  in.read();  boolean  eol  =  isEndOfLine(c);  c  =  in.readAgain();    if  (emptyLinesIgnored)  {  [BUGGY]  while  (  eol  ||  (  lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(  lastChar)  )  {  [BUGGY]      lastChar  =  c;  c  =  in.read();  eol  =  isEndOfLine(c);  c  =  in.readAgain();    if  (isEndOfFile(c))  {  tkn.type  =  EOF;    return  tkn;  }  }  }    [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P2_Replace_Operator]
[PATCH]  while  (  eol  &&  (  lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {	[BUG]  [BUGGY]  while  (  eol  &&  (  lastChar  ==  '\n'  &&  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(  lastChar)  )  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]    int  lastChar  =  in.readAgain();            int  c  =  in.read();  boolean  eol  =  isEndOfLine(c);  c  =  in.readAgain();    if  (emptyLinesIgnored)  {  [BUGGY]  while  (  eol  &&  (  lastChar  ==  '\n'  &&  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(  lastChar)  )  {  [BUGGY]      lastChar  =  c;  c  =  in.read();  eol  =  isEndOfLine(c);  c  =  in.readAgain();    if  (isEndOfFile(c))  {  tkn.type  =  EOF;    return  tkn;  }  }  }    [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P2_Replace_Operator]
[PATCH]  while  (  eol  &&  (  lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {	[BUG]  [BUGGY]  while  (  eol  &&  (  lastChar  <=  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(  lastChar)  )  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]    int  lastChar  =  in.readAgain();            int  c  =  in.read();  boolean  eol  =  isEndOfLine(c);  c  =  in.readAgain();    if  (emptyLinesIgnored)  {  [BUGGY]  while  (  eol  &&  (  lastChar  <=  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(  lastChar)  )  {  [BUGGY]      lastChar  =  c;  c  =  in.read();  eol  =  isEndOfLine(c);  c  =  in.readAgain();    if  (isEndOfFile(c))  {  tkn.type  =  EOF;    return  tkn;  }  }  }    [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P2_Replace_Operator]
[PATCH]  while  (  eol  &&  (  lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {	[BUG]  [BUGGY]  while  (  eol  &&  (  lastChar  ==  '\n'  ||  lastChar  >=  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(  lastChar)  )  {[FE]  Token  type  expected:<EORECORD>  but  was:<TOKEN>  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]    int  lastChar  =  in.readAgain();            int  c  =  in.read();  boolean  eol  =  isEndOfLine(c);  c  =  in.readAgain();    if  (emptyLinesIgnored)  {  [BUGGY]  while  (  eol  &&  (  lastChar  ==  '\n'  ||  lastChar  >=  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(  lastChar)  )  {  [BUGGY]      lastChar  =  c;  c  =  in.read();  eol  =  isEndOfLine(c);  c  =  in.readAgain();    if  (isEndOfFile(c))  {  tkn.type  =  EOF;    return  tkn;  }  }  }    [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P2_Replace_Operator]
[PATCH]  while  (  eol  &&  (  lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {	[BUG]  [BUGGY]  while  (  eol  &&  (  lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  <=  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(  lastChar)  )  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]    int  lastChar  =  in.readAgain();            int  c  =  in.read();  boolean  eol  =  isEndOfLine(c);  c  =  in.readAgain();    if  (emptyLinesIgnored)  {  [BUGGY]  while  (  eol  &&  (  lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  <=  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(  lastChar)  )  {  [BUGGY]      lastChar  =  c;  c  =  in.read();  eol  =  isEndOfLine(c);  c  =  in.readAgain();    if  (isEndOfFile(c))  {  tkn.type  =  EOF;    return  tkn;  }  }  }    [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P2_Replace_Operator]
[PATCH]  while  (  eol  &&  (  lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {	[BUG]  [BUGGY]  while  (  eol  &&  (  lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  1)  &&  !isEndOfFile(  lastChar)  )  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]    int  lastChar  =  in.readAgain();            int  c  =  in.read();  boolean  eol  =  isEndOfLine(c);  c  =  in.readAgain();    if  (emptyLinesIgnored)  {  [BUGGY]  while  (  eol  &&  (  lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  1)  &&  !isEndOfFile(  lastChar)  )  {  [BUGGY]      lastChar  =  c;  c  =  in.read();  eol  =  isEndOfLine(c);  c  =  in.readAgain();    if  (isEndOfFile(c))  {  tkn.type  =  EOF;    return  tkn;  }  }  }    [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P5_Replace_Variable]
[PATCH]  while  (  eol  &&  (  lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {	[BUG]  [BUGGY]  while  (  lastChar  &&  (  eol  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(  lastChar)  )  {[CE]  incomparable  types:  boolean  and  char  [CONTEXT]    int  lastChar  =  in.readAgain();            int  c  =  in.read();  boolean  eol  =  isEndOfLine(c);  c  =  in.readAgain();    if  (emptyLinesIgnored)  {  [BUGGY]  while  (  lastChar  &&  (  eol  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(  lastChar)  )  {  [BUGGY]      lastChar  =  c;  c  =  in.read();  eol  =  isEndOfLine(c);  c  =  in.readAgain();    if  (isEndOfFile(c))  {  tkn.type  =  EOF;    return  tkn;  }  }  }    [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P5_Replace_Variable]
[PATCH]  while  (  eol  &&  (  lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {	[BUG]  [BUGGY]  while  (  eol  &&  (  lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfLine(  lastChar)  )  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]    int  lastChar  =  in.readAgain();            int  c  =  in.read();  boolean  eol  =  isEndOfLine(c);  c  =  in.readAgain();    if  (emptyLinesIgnored)  {  [BUGGY]  while  (  eol  &&  (  lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfLine(  lastChar)  )  {  [BUGGY]      lastChar  =  c;  c  =  in.read();  eol  =  isEndOfLine(c);  c  =  in.readAgain();    if  (isEndOfFile(c))  {  tkn.type  =  EOF;    return  tkn;  }  }  }    [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P7_Replace_Invocation]
[PATCH]  if  (  isEndOfFile  (  c  )  )  {	[BUG]  [BUGGY]  if  (  isEndOfFile(  lastChar)  )  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  while  (eol  &&  (lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(lastChar))  {    lastChar  =  c;  c  =  in.read();  eol  =  isEndOfLine(c);  c  =  in.readAgain();    [BUGGY]  if  (  isEndOfFile(  lastChar)  )  {  [BUGGY]  tkn.type  =  EOF;    return  tkn;  }  }    [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P5_Replace_Variable]
[PATCH]  if  (  isEndOfFile  (  c  )  )  {	[BUG]  [BUGGY]  if  (  isEndOfLine(  c)  )  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  while  (eol  &&  (lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(lastChar))  {    lastChar  =  c;  c  =  in.read();  eol  =  isEndOfLine(c);  c  =  in.readAgain();    [BUGGY]  if  (  isEndOfLine(  c)  )  {  [BUGGY]  tkn.type  =  EOF;    return  tkn;  }  }    [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P7_Replace_Invocation]
[PATCH]  if  (  isEndOfFile  (  c  )  )  {	[BUG]  [BUGGY]  if  (  isEndOfLine(  lastChar)  )  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  while  (eol  &&  (lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(lastChar))  {    lastChar  =  c;  c  =  in.read();  eol  =  isEndOfLine(c);  c  =  in.readAgain();    [BUGGY]  if  (  isEndOfLine(  lastChar)  )  {  [BUGGY]  tkn.type  =  EOF;    return  tkn;  }  }    [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P8_Replace_Mix]
[PATCH]  if  (  isEndOfFile  (  c  )  )  {	[BUG]  [BUGGY]  if  (  isEscape(  c)  )  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  while  (eol  &&  (lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(lastChar))  {    lastChar  =  c;  c  =  in.read();  eol  =  isEndOfLine(c);  c  =  in.readAgain();    [BUGGY]  if  (  isEscape(  c)  )  {  [BUGGY]  tkn.type  =  EOF;    return  tkn;  }  }    [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P9_Replace_Statement]
[PATCH]  if  (  isEndOfFile  (  c  )  )  {  tkn.type  =  EOF;  return  tkn;  }	[BUG]  [BUGGY]  tkn.type  =  EOF;  return  tkn;[CE]  illegal  start  of  expression  [CONTEXT]  while  (eol  &&  (lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(lastChar))  {    lastChar  =  c;  c  =  in.read();  eol  =  isEndOfLine(c);  c  =  in.readAgain();    [BUGGY]  tkn.type  =  EOF;  return  tkn;  [BUGGY]    tkn.type  =  EOF;  return  tkn;        [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P15_Unwrap_Block]
[PATCH]  if  (  isEndOfFile  (  c  )  )  {  tkn.type  =  EOF;  return  tkn;  }	[BUG]  [BUGGY]  [CE]  illegal  start  of  expression  [CONTEXT]  while  (eol  &&  (lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(lastChar))  {    lastChar  =  c;  c  =  in.read();  eol  =  isEndOfLine(c);  c  =  in.readAgain();    [BUGGY]  [BUGGY]            [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P16_Remove_Block]
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  isEndOfFile(  c)  )  {      tkn.type  =  EOF;      tkn.isReady  =  true;  }else  {      simpleTokenLexer(  tkn,  c)  ;  }[CE]  illegal  start  of  type  [CONTEXT]  while  (eol  &&  (lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(lastChar))  {    lastChar  =  c;  c  =  in.read();  eol  =  isEndOfLine(c);  c  =  in.readAgain();    [BUGGY]  if  (  isEndOfFile(  c)  )  {      tkn.type  =  EOF;      tkn.isReady  =  true;  }else  {      simpleTokenLexer(  tkn,  c)  ;  }  [BUGGY]  tkn.type  =  EOF;    return  tkn;  }  }    [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P13_Insert_Block]
[PATCH]  tkn.type  =  EOF;	[BUG]  [BUGGY]  tkn.type  =  tkn.type  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  while  (eol  &&  (lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(lastChar))  {    lastChar  =  c;  c  =  in.read();  eol  =  isEndOfLine(c);  c  =  in.readAgain();    if  (isEndOfFile(c))  {  [BUGGY]  tkn.type  =  tkn.type  ;  [BUGGY]    return  tkn;  }  }    [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P8_Replace_Mix]
[PATCH]  tkn.type  =  EOF;	[BUG]  [BUGGY]  tkn.type  =  TOKEN;tkn.type  =  EOF;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  while  (eol  &&  (lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(lastChar))  {    lastChar  =  c;  c  =  in.read();  eol  =  isEndOfLine(c);  c  =  in.readAgain();    if  (isEndOfFile(c))  {  [BUGGY]  tkn.type  =  TOKEN;tkn.type  =  EOF;  [BUGGY]    return  tkn;  }  }    [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P11_Insert_Donor_Statement]
[PATCH]  tkn.type  =  EOF;	[BUG]  [BUGGY]  tkn.type  =  EORECORD;tkn.type  =  EOF;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  while  (eol  &&  (lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(lastChar))  {    lastChar  =  c;  c  =  in.read();  eol  =  isEndOfLine(c);  c  =  in.readAgain();    if  (isEndOfFile(c))  {  [BUGGY]  tkn.type  =  EORECORD;tkn.type  =  EOF;  [BUGGY]    return  tkn;  }  }    [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P11_Insert_Donor_Statement]
[PATCH]  lastChar  =  c;	[BUG]  [BUGGY]  lastChar  =  lastChar;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  while  (eol  &&  (lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(lastChar))  {    [BUGGY]  lastChar  =  lastChar;  [BUGGY]  c  =  in.read();  eol  =  isEndOfLine(c);  c  =  in.readAgain();    if  (isEndOfFile(c))  {  tkn.type  =  EOF;    return  tkn;  }  }    [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P5_Replace_Variable]
[PATCH]  lastChar  =  c;	[BUG]  [BUGGY]  lastChar  =  null;[CE]  incompatible  types  [CONTEXT]  while  (eol  &&  (lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(lastChar))  {    [BUGGY]  lastChar  =  null;  [BUGGY]  c  =  in.read();  eol  =  isEndOfLine(c);  c  =  in.readAgain();    if  (isEndOfFile(c))  {  tkn.type  =  EOF;    return  tkn;  }  }    [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P8_Replace_Mix]
[PATCH]  c  =  in.read  (  )  ;	[BUG]  [BUGGY]  c  =  null.read(  )  ;[CE]  <null>  cannot  be  dereferenced  [CONTEXT]  while  (eol  &&  (lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(lastChar))  {    lastChar  =  c;  [BUGGY]  c  =  null.read(  )  ;  [BUGGY]  eol  =  isEndOfLine(c);  c  =  in.readAgain();    if  (isEndOfFile(c))  {  tkn.type  =  EOF;    return  tkn;  }  }    [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P5_Replace_Variable]
[PATCH]  c  =  in.read  (  )  ;	[BUG]  [BUGGY]  c  =  in.readLine(  )  ;[CE]  incompatible  types  [CONTEXT]  while  (eol  &&  (lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(lastChar))  {    lastChar  =  c;  [BUGGY]  c  =  in.readLine(  )  ;  [BUGGY]  eol  =  isEndOfLine(c);  c  =  in.readAgain();    if  (isEndOfFile(c))  {  tkn.type  =  EOF;    return  tkn;  }  }    [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P7_Replace_Invocation]
[PATCH]  c  =  in.read  (  )  ;	[BUG]  [BUGGY]  c  =  null  ;[CE]  incompatible  types  [CONTEXT]  while  (eol  &&  (lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(lastChar))  {    lastChar  =  c;  [BUGGY]  c  =  null  ;  [BUGGY]  eol  =  isEndOfLine(c);  c  =  in.readAgain();    if  (isEndOfFile(c))  {  tkn.type  =  EOF;    return  tkn;  }  }    [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P8_Replace_Mix]
[PATCH]  c  =  in.read  (  )  ;	[BUG]  [BUGGY]  c  =  in.readAgain(  )  ;c  =  in.read(  )  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  while  (eol  &&  (lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(lastChar))  {    lastChar  =  c;  [BUGGY]  c  =  in.readAgain(  )  ;c  =  in.read(  )  ;  [BUGGY]  eol  =  isEndOfLine(c);  c  =  in.readAgain();    if  (isEndOfFile(c))  {  tkn.type  =  EOF;    return  tkn;  }  }    [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P11_Insert_Donor_Statement]
[PATCH]  eol  =  isEndOfLine  (  c  )  ;	[BUG]  [BUGGY]  eol  =  isEndOfLine(  lastChar)  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  while  (eol  &&  (lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(lastChar))  {    lastChar  =  c;  c  =  in.read();  [BUGGY]  eol  =  isEndOfLine(  lastChar)  ;  [BUGGY]  c  =  in.readAgain();    if  (isEndOfFile(c))  {  tkn.type  =  EOF;    return  tkn;  }  }    [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P5_Replace_Variable]
[PATCH]  eol  =  isEndOfLine  (  c  )  ;	[BUG]  [BUGGY]  eol  =  isEndOfFile(  c)  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  while  (eol  &&  (lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(lastChar))  {    lastChar  =  c;  c  =  in.read();  [BUGGY]  eol  =  isEndOfFile(  c)  ;  [BUGGY]  c  =  in.readAgain();    if  (isEndOfFile(c))  {  tkn.type  =  EOF;    return  tkn;  }  }    [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P7_Replace_Invocation]
[PATCH]  eol  =  isEndOfLine  (  c  )  ;	[BUG]  [BUGGY]  c  =  in.readAgain(  )  ;eol  =  isEndOfLine(  c)  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  while  (eol  &&  (lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(lastChar))  {    lastChar  =  c;  c  =  in.read();  [BUGGY]  c  =  in.readAgain(  )  ;eol  =  isEndOfLine(  c)  ;  [BUGGY]  c  =  in.readAgain();    if  (isEndOfFile(c))  {  tkn.type  =  EOF;    return  tkn;  }  }    [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P11_Insert_Donor_Statement]
[PATCH]  c  =  in.readAgain  (  )  ;	[BUG]  [BUGGY]  c  =  in.readLine(  )  ;[CE]  incompatible  types  [CONTEXT]  while  (eol  &&  (lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(lastChar))  {    lastChar  =  c;  c  =  in.read();  eol  =  isEndOfLine(c);  [BUGGY]  c  =  in.readLine(  )  ;  [BUGGY]    if  (isEndOfFile(c))  {  tkn.type  =  EOF;    return  tkn;  }  }    [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P7_Replace_Invocation]
[PATCH]  c  =  in.readAgain  (  )  ;	[BUG]  [BUGGY]  c  =  null  ;[CE]  incompatible  types  [CONTEXT]  while  (eol  &&  (lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(lastChar))  {    lastChar  =  c;  c  =  in.read();  eol  =  isEndOfLine(c);  [BUGGY]  c  =  null  ;  [BUGGY]    if  (isEndOfFile(c))  {  tkn.type  =  EOF;    return  tkn;  }  }    [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P8_Replace_Mix]
[PATCH]  c  =  in.readAgain  (  )  ;	[BUG]  [BUGGY]  eol  =  isEndOfLine(  c)  ;c  =  in.readAgain(  )  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  while  (eol  &&  (lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(lastChar))  {    lastChar  =  c;  c  =  in.read();  eol  =  isEndOfLine(c);  [BUGGY]  eol  =  isEndOfLine(  c)  ;c  =  in.readAgain(  )  ;  [BUGGY]    if  (isEndOfFile(c))  {  tkn.type  =  EOF;    return  tkn;  }  }    [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P11_Insert_Donor_Statement]
[PATCH]  c  =  in.readAgain  (  )  ;	[BUG]  [BUGGY]  c  =  in.read(  )  ;c  =  in.readAgain(  )  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  while  (eol  &&  (lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(lastChar))  {    lastChar  =  c;  c  =  in.read();  eol  =  isEndOfLine(c);  [BUGGY]  c  =  in.read(  )  ;c  =  in.readAgain(  )  ;  [BUGGY]    if  (isEndOfFile(c))  {  tkn.type  =  EOF;    return  tkn;  }  }    [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P11_Insert_Donor_Statement]
[PATCH]  tkn.type  =  EOF;	[BUG]  [BUGGY]  tkn.type  =  0;[CE]  incompatible  types  [CONTEXT]  while  (eol  &&  (lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(lastChar))  {    lastChar  =  c;  c  =  in.read();  eol  =  isEndOfLine(c);  c  =  in.readAgain();    if  (isEndOfFile(c))  {  [BUGGY]  tkn.type  =  0;  [BUGGY]    return  tkn;  }  }    [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P5_Replace_Variable]
[PATCH]  tkn.type  =  EOF;	[BUG]  [BUGGY]  tkn.type  ;[CE]  not  a  statement  [CONTEXT]  while  (eol  &&  (lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(lastChar))  {    lastChar  =  c;  c  =  in.read();  eol  =  isEndOfLine(c);  c  =  in.readAgain();    if  (isEndOfFile(c))  {  [BUGGY]  tkn.type  ;  [BUGGY]    return  tkn;  }  }    [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P8_Replace_Mix]
[PATCH]  c  =  in.read  (  )  ;	[BUG]  [BUGGY]  c  =  null.readLine(  )  ;[CE]  <null>  cannot  be  dereferenced  [CONTEXT]  while  (eol  &&  (lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(lastChar))  {    lastChar  =  c;  [BUGGY]  c  =  null.readLine(  )  ;  [BUGGY]  eol  =  isEndOfLine(c);  c  =  in.readAgain();    if  (isEndOfFile(c))  {  tkn.type  =  EOF;    return  tkn;  }  }    [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P8_Replace_Mix]
[PATCH]  c  =  in.read  (  )  ;	[BUG]  [BUGGY]  [FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  while  (eol  &&  (lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(lastChar))  {    lastChar  =  c;  [BUGGY]  [BUGGY]    eol  =  isEndOfLine(c);  c  =  in.readAgain();    if  (isEndOfFile(c))  {  tkn.type  =  EOF;    return  tkn;  }    [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P14_Delete_Statement]
[PATCH]  c  =  in.read  (  )  ;	[BUG]  [BUGGY]  int  lastChar  =  in.readAgain(  )  ;c  =  in.read(  )  ;[CE]  variable  lastChar  is  already  defined  in  method  nextToken(Token)  [CONTEXT]  while  (eol  &&  (lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(lastChar))  {    lastChar  =  c;  [BUGGY]  int  lastChar  =  in.readAgain(  )  ;c  =  in.read(  )  ;  [BUGGY]  eol  =  isEndOfLine(c);  c  =  in.readAgain();    if  (isEndOfFile(c))  {  tkn.type  =  EOF;    return  tkn;  }  }    [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P11_Insert_Donor_Statement]
[PATCH]  c  =  in.read  (  )  ;	[BUG]  [BUGGY]  int  c  =  in.read(  )  ;c  =  in.read(  )  ;[CE]  variable  c  is  already  defined  in  method  nextToken(Token)  [CONTEXT]  while  (eol  &&  (lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(lastChar))  {    lastChar  =  c;  [BUGGY]  int  c  =  in.read(  )  ;c  =  in.read(  )  ;  [BUGGY]  eol  =  isEndOfLine(c);  c  =  in.readAgain();    if  (isEndOfFile(c))  {  tkn.type  =  EOF;    return  tkn;  }  }    [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P11_Insert_Donor_Statement]
[PATCH]  c  =  in.read  (  )  ;	[BUG]  [BUGGY]  in.readLine(  )  ;c  =  in.read(  )  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  while  (eol  &&  (lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(lastChar))  {    lastChar  =  c;  [BUGGY]  in.readLine(  )  ;c  =  in.read(  )  ;  [BUGGY]  eol  =  isEndOfLine(c);  c  =  in.readAgain();    if  (isEndOfFile(c))  {  tkn.type  =  EOF;    return  tkn;  }  }    [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P11_Insert_Donor_Statement]
[PATCH]  eol  =  isEndOfLine  (  c  )  ;	[BUG]  [BUGGY]  [FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  while  (eol  &&  (lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(lastChar))  {    lastChar  =  c;  c  =  in.read();  [BUGGY]  [BUGGY]    c  =  in.readAgain();    if  (isEndOfFile(c))  {  tkn.type  =  EOF;    return  tkn;  }    [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P14_Delete_Statement]
[PATCH]  c  =  in.readAgain  (  )  ;	[BUG]  [BUGGY]  [FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  while  (eol  &&  (lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(lastChar))  {    lastChar  =  c;  c  =  in.read();  eol  =  isEndOfLine(c);  [BUGGY]  [BUGGY]      if  (isEndOfFile(c))  {  tkn.type  =  EOF;    return  tkn;  }    [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P14_Delete_Statement]
[PATCH]  c  =  in.readAgain  (  )  ;	[BUG]  [BUGGY]  int  lastChar  =  in.readAgain(  )  ;c  =  in.readAgain(  )  ;[CE]  variable  lastChar  is  already  defined  in  method  nextToken(Token)  [CONTEXT]  while  (eol  &&  (lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(lastChar))  {    lastChar  =  c;  c  =  in.read();  eol  =  isEndOfLine(c);  [BUGGY]  int  lastChar  =  in.readAgain(  )  ;c  =  in.readAgain(  )  ;  [BUGGY]    if  (isEndOfFile(c))  {  tkn.type  =  EOF;    return  tkn;  }  }    [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P11_Insert_Donor_Statement]
[PATCH]  c  =  in.readAgain  (  )  ;	[BUG]  [BUGGY]  int  c  =  in.read(  )  ;c  =  in.readAgain(  )  ;[CE]  variable  c  is  already  defined  in  method  nextToken(Token)  [CONTEXT]  while  (eol  &&  (lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(lastChar))  {    lastChar  =  c;  c  =  in.read();  eol  =  isEndOfLine(c);  [BUGGY]  int  c  =  in.read(  )  ;c  =  in.readAgain(  )  ;  [BUGGY]    if  (isEndOfFile(c))  {  tkn.type  =  EOF;    return  tkn;  }  }    [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P11_Insert_Donor_Statement]
[PATCH]  c  =  in.readAgain  (  )  ;	[BUG]  [BUGGY]  in.readLine(  )  ;c  =  in.readAgain(  )  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  while  (eol  &&  (lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(lastChar))  {    lastChar  =  c;  c  =  in.read();  eol  =  isEndOfLine(c);  [BUGGY]  in.readLine(  )  ;c  =  in.readAgain(  )  ;  [BUGGY]    if  (isEndOfFile(c))  {  tkn.type  =  EOF;    return  tkn;  }  }    [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P11_Insert_Donor_Statement]
[PATCH]  if  (  emptyLinesIgnored  )  {	[BUG]  [BUGGY]  if  ((eol  &&((lastChar  ==  '\n')  ||(lastChar  ==  '\r'))  ||(lastChar  ==  ExtendedBufferedReader.UNDEFINED)))  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  Token  nextToken(Token  tkn)  throws  IOException  {    int  lastChar  =  in.readAgain();            int  c  =  in.read();  boolean  eol  =  isEndOfLine(c);  c  =  in.readAgain();    [BUGGY]  if  ((eol  &&((lastChar  ==  '\n')  ||(lastChar  ==  '\r'))  ||(lastChar  ==  ExtendedBufferedReader.UNDEFINED)))  {  [BUGGY]  while  (eol  &&  (lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(lastChar))  {    lastChar  =  c;  c  =  in.read();  eol  =  isEndOfLine(c);  c  =  in.readAgain();    if  (isEndOfFile(c))  {  tkn.type  =  EOF;    return  tkn;  }  }    [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P6_Replace_Expression]
[PATCH]  if  (  emptyLinesIgnored  )  {	[BUG]  [BUGGY]  if  (((lastChar  ==  '\n')  ||(lastChar  ==  '\r')  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED))  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  Token  nextToken(Token  tkn)  throws  IOException  {    int  lastChar  =  in.readAgain();            int  c  =  in.read();  boolean  eol  =  isEndOfLine(c);  c  =  in.readAgain();    [BUGGY]  if  (((lastChar  ==  '\n')  ||(lastChar  ==  '\r')  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED))  {  [BUGGY]  while  (eol  &&  (lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(lastChar))  {    lastChar  =  c;  c  =  in.read();  eol  =  isEndOfLine(c);  c  =  in.readAgain();    if  (isEndOfFile(c))  {  tkn.type  =  EOF;    return  tkn;  }  }    [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P6_Replace_Expression]
[PATCH]  if  (  emptyLinesIgnored  )  {	[BUG]  [BUGGY]  if  ((lastChar  ==  '\n'  ||  lastChar  ==  '\r'))  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  Token  nextToken(Token  tkn)  throws  IOException  {    int  lastChar  =  in.readAgain();            int  c  =  in.read();  boolean  eol  =  isEndOfLine(c);  c  =  in.readAgain();    [BUGGY]  if  ((lastChar  ==  '\n'  ||  lastChar  ==  '\r'))  {  [BUGGY]  while  (eol  &&  (lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(lastChar))  {    lastChar  =  c;  c  =  in.read();  eol  =  isEndOfLine(c);  c  =  in.readAgain();    if  (isEndOfFile(c))  {  tkn.type  =  EOF;    return  tkn;  }  }    [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P6_Replace_Expression]
[PATCH]  if  (  emptyLinesIgnored  )  {	[BUG]  [BUGGY]  if  (  lastChar  ==  '\n')  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  Token  nextToken(Token  tkn)  throws  IOException  {    int  lastChar  =  in.readAgain();            int  c  =  in.read();  boolean  eol  =  isEndOfLine(c);  c  =  in.readAgain();    [BUGGY]  if  (  lastChar  ==  '\n')  {  [BUGGY]  while  (eol  &&  (lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(lastChar))  {    lastChar  =  c;  c  =  in.read();  eol  =  isEndOfLine(c);  c  =  in.readAgain();    if  (isEndOfFile(c))  {  tkn.type  =  EOF;    return  tkn;  }  }    [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P6_Replace_Expression]
[PATCH]  if  (  emptyLinesIgnored  )  {	[BUG]  [BUGGY]  if  (  lastChar  ==  '\r')  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  Token  nextToken(Token  tkn)  throws  IOException  {    int  lastChar  =  in.readAgain();            int  c  =  in.read();  boolean  eol  =  isEndOfLine(c);  c  =  in.readAgain();    [BUGGY]  if  (  lastChar  ==  '\r')  {  [BUGGY]  while  (eol  &&  (lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(lastChar))  {    lastChar  =  c;  c  =  in.read();  eol  =  isEndOfLine(c);  c  =  in.readAgain();    if  (isEndOfFile(c))  {  tkn.type  =  EOF;    return  tkn;  }  }    [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P6_Replace_Expression]
[PATCH]  if  (  emptyLinesIgnored  )  {	[BUG]  [BUGGY]  if  (  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  Token  nextToken(Token  tkn)  throws  IOException  {    int  lastChar  =  in.readAgain();            int  c  =  in.read();  boolean  eol  =  isEndOfLine(c);  c  =  in.readAgain();    [BUGGY]  if  (  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  {  [BUGGY]  while  (eol  &&  (lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(lastChar))  {    lastChar  =  c;  c  =  in.read();  eol  =  isEndOfLine(c);  c  =  in.readAgain();    if  (isEndOfFile(c))  {  tkn.type  =  EOF;    return  tkn;  }  }    [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P6_Replace_Expression]
[PATCH]  while  (  eol  &&  (  lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {	[BUG]  [BUGGY]  while  (  eol  &&  (  lastChar  !=  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(  lastChar)  )  {[FE]  Token  type  expected:<EORECORD>  but  was:<TOKEN>  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]    int  lastChar  =  in.readAgain();            int  c  =  in.read();  boolean  eol  =  isEndOfLine(c);  c  =  in.readAgain();    if  (emptyLinesIgnored)  {  [BUGGY]  while  (  eol  &&  (  lastChar  !=  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(  lastChar)  )  {  [BUGGY]      lastChar  =  c;  c  =  in.read();  eol  =  isEndOfLine(c);  c  =  in.readAgain();    if  (isEndOfFile(c))  {  tkn.type  =  EOF;    return  tkn;  }  }  }    [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P2_Replace_Operator]
[PATCH]  while  (  eol  &&  (  lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {	[BUG]  [BUGGY]  while  (  eol  &&  (  lastChar  ==  '\n'  ||  lastChar  !=  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(  lastChar)  )  {[FE]  Token  type  expected:<EORECORD>  but  was:<TOKEN>  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]    int  lastChar  =  in.readAgain();            int  c  =  in.read();  boolean  eol  =  isEndOfLine(c);  c  =  in.readAgain();    if  (emptyLinesIgnored)  {  [BUGGY]  while  (  eol  &&  (  lastChar  ==  '\n'  ||  lastChar  !=  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(  lastChar)  )  {  [BUGGY]      lastChar  =  c;  c  =  in.read();  eol  =  isEndOfLine(c);  c  =  in.readAgain();    if  (isEndOfFile(c))  {  tkn.type  =  EOF;    return  tkn;  }  }  }    [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P2_Replace_Operator]
[PATCH]  while  (  eol  &&  (  lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {	[BUG]  [BUGGY]  while  (  eol  &&  (  c  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(  lastChar)  )  {[FE]  Token  type  expected:<EORECORD>  but  was:<TOKEN>  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]    int  lastChar  =  in.readAgain();            int  c  =  in.read();  boolean  eol  =  isEndOfLine(c);  c  =  in.readAgain();    if  (emptyLinesIgnored)  {  [BUGGY]  while  (  eol  &&  (  c  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(  lastChar)  )  {  [BUGGY]      lastChar  =  c;  c  =  in.read();  eol  =  isEndOfLine(c);  c  =  in.readAgain();    if  (isEndOfFile(c))  {  tkn.type  =  EOF;    return  tkn;  }  }  }    [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P5_Replace_Variable]
[PATCH]  c  =  in.read  (  )  ;	[BUG]  [BUGGY]  c  =  c  ;[FE]  [CONTEXT]  while  (eol  &&  (lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(lastChar))  {    lastChar  =  c;  [BUGGY]  c  =  c  ;  [BUGGY]  eol  =  isEndOfLine(c);  c  =  in.readAgain();    if  (isEndOfFile(c))  {  tkn.type  =  EOF;    return  tkn;  }  }    [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P8_Replace_Mix]
[PATCH]  c  =  in.readAgain  (  )  ;	[BUG]  [BUGGY]  c  ;[CE]  not  a  statement  [CONTEXT]  while  (eol  &&  (lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(lastChar))  {    lastChar  =  c;  c  =  in.read();  eol  =  isEndOfLine(c);  [BUGGY]  c  ;  [BUGGY]    if  (isEndOfFile(c))  {  tkn.type  =  EOF;    return  tkn;  }  }    [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P8_Replace_Mix]
[PATCH]  c  =  in.read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;	[BUG]  [BUGGY]  [FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  while  (eol  &&  (lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(lastChar))  {    lastChar  =  c;  [BUGGY]  [BUGGY]    c  =  in.readAgain();    if  (isEndOfFile(c))  {  tkn.type  =  EOF;    return  tkn;  }    [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P14_Delete_Statement]
[PATCH]  eol  =  isEndOfLine  (  c  )  ;	[BUG]  [BUGGY]  eol  =  isEndOfFile(  lastChar)  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  while  (eol  &&  (lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(lastChar))  {    lastChar  =  c;  c  =  in.read();  [BUGGY]  eol  =  isEndOfFile(  lastChar)  ;  [BUGGY]  c  =  in.readAgain();    if  (isEndOfFile(c))  {  tkn.type  =  EOF;    return  tkn;  }  }    [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P8_Replace_Mix]
[PATCH]  eol  =  isEndOfLine  (  c  )  ;  c  =  in.readAgain  (  )  ;	[BUG]  [BUGGY]  [FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  while  (eol  &&  (lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(lastChar))  {    lastChar  =  c;  c  =  in.read();  [BUGGY]  [BUGGY]      if  (isEndOfFile(c))  {  tkn.type  =  EOF;    return  tkn;  }    [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P14_Delete_Statement]
[PATCH]  if  (  isEndOfFile  (  c  )  )  {	[BUG]  [BUGGY]  if  (  isEndOfFile(  lastChar)  )  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  int  c  =  in.read();  boolean  eol  =  isEndOfLine(c);  c  =  in.readAgain();    if  (emptyLinesIgnored)  {  while  (eol  &&  (lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(lastChar))  {    lastChar  =  c;  c  =  in.read();  eol  =  isEndOfLine(c);  c  =  in.readAgain();    [BUGGY]  if  (  isEndOfFile(  lastChar)  )  {  [BUGGY]  tkn.type  =  EOF;    return  tkn;  }  }  }    if  (isEndOfFile(lastChar)  ||  (!isDelimiter(lastChar)  &&  isEndOfFile(c)))  {  tkn.type  =  EOF;    return  tkn;  }        [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P5_Replace_Variable]
[PATCH]  if  (  isEndOfFile  (  c  )  )  {	[BUG]  [BUGGY]  if  (  isEndOfLine(  c)  )  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  int  c  =  in.read();  boolean  eol  =  isEndOfLine(c);  c  =  in.readAgain();    if  (emptyLinesIgnored)  {  while  (eol  &&  (lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(lastChar))  {    lastChar  =  c;  c  =  in.read();  eol  =  isEndOfLine(c);  c  =  in.readAgain();    [BUGGY]  if  (  isEndOfLine(  c)  )  {  [BUGGY]  tkn.type  =  EOF;    return  tkn;  }  }  }    if  (isEndOfFile(lastChar)  ||  (!isDelimiter(lastChar)  &&  isEndOfFile(c)))  {  tkn.type  =  EOF;    return  tkn;  }        [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P7_Replace_Invocation]
[PATCH]  if  (  isEndOfFile  (  c  )  )  {	[BUG]  [BUGGY]  if  (  isEscape(  c)  )  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  int  c  =  in.read();  boolean  eol  =  isEndOfLine(c);  c  =  in.readAgain();    if  (emptyLinesIgnored)  {  while  (eol  &&  (lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(lastChar))  {    lastChar  =  c;  c  =  in.read();  eol  =  isEndOfLine(c);  c  =  in.readAgain();    [BUGGY]  if  (  isEscape(  c)  )  {  [BUGGY]  tkn.type  =  EOF;    return  tkn;  }  }  }    if  (isEndOfFile(lastChar)  ||  (!isDelimiter(lastChar)  &&  isEndOfFile(c)))  {  tkn.type  =  EOF;    return  tkn;  }        [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P9_Replace_Statement]
[PATCH]  if  (  isEndOfFile  (  c  )  )  {  tkn.type  =  EOF;  return  tkn;  }	[BUG]  [BUGGY]  tkn.type  =  EOF;  return  tkn;[CE]  illegal  start  of  expression  [CONTEXT]  int  c  =  in.read();  boolean  eol  =  isEndOfLine(c);  c  =  in.readAgain();    if  (emptyLinesIgnored)  {  while  (eol  &&  (lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(lastChar))  {    lastChar  =  c;  c  =  in.read();  eol  =  isEndOfLine(c);  c  =  in.readAgain();    [BUGGY]  tkn.type  =  EOF;  return  tkn;  [BUGGY]    tkn.type  =  EOF;  return  tkn;      }  }    if  (isEndOfFile(lastChar)  ||  (!isDelimiter(lastChar)  &&  isEndOfFile(c)))  {  tkn.type  =  EOF;    return  tkn;  }      [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P15_Unwrap_Block]
[PATCH]  if  (  isEndOfFile  (  c  )  )  {  tkn.type  =  EOF;  return  tkn;  }	[BUG]  [BUGGY]  [CE]  illegal  start  of  expression  [CONTEXT]  int  c  =  in.read();  boolean  eol  =  isEndOfLine(c);  c  =  in.readAgain();    if  (emptyLinesIgnored)  {  while  (eol  &&  (lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(lastChar))  {    lastChar  =  c;  c  =  in.read();  eol  =  isEndOfLine(c);  c  =  in.readAgain();    [BUGGY]  [BUGGY]        }  }    if  (isEndOfFile(lastChar)  ||  (!isDelimiter(lastChar)  &&  isEndOfFile(c)))  {  tkn.type  =  EOF;    return  tkn;  }      [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P16_Remove_Block]
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  isEndOfFile(  c)  )  {      tkn.type  =  EOF;      tkn.isReady  =  true;  }else  {      simpleTokenLexer(  tkn,  c)  ;  }[CE]  illegal  start  of  type  [CONTEXT]  int  c  =  in.read();  boolean  eol  =  isEndOfLine(c);  c  =  in.readAgain();    if  (emptyLinesIgnored)  {  while  (eol  &&  (lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(lastChar))  {    lastChar  =  c;  c  =  in.read();  eol  =  isEndOfLine(c);  c  =  in.readAgain();    [BUGGY]  if  (  isEndOfFile(  c)  )  {      tkn.type  =  EOF;      tkn.isReady  =  true;  }else  {      simpleTokenLexer(  tkn,  c)  ;  }  [BUGGY]  tkn.type  =  EOF;    return  tkn;  }  }  }    if  (isEndOfFile(lastChar)  ||  (!isDelimiter(lastChar)  &&  isEndOfFile(c)))  {  tkn.type  =  EOF;    return  tkn;  }        [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P13_Insert_Block]
[PATCH]  tkn.type  =  EOF;	[BUG]  [BUGGY]  tkn.type  ;[CE]  not  a  statement  [CONTEXT]  boolean  eol  =  isEndOfLine(c);  c  =  in.readAgain();    if  (emptyLinesIgnored)  {  while  (eol  &&  (lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(lastChar))  {    lastChar  =  c;  c  =  in.read();  eol  =  isEndOfLine(c);  c  =  in.readAgain();    if  (isEndOfFile(c))  {  [BUGGY]  tkn.type  ;  [BUGGY]    return  tkn;  }  }  }    if  (isEndOfFile(lastChar)  ||  (!isDelimiter(lastChar)  &&  isEndOfFile(c)))  {  tkn.type  =  EOF;    return  tkn;  }    while  (tkn.type  ==  INVALID)  {    [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P8_Replace_Mix]
[PATCH]  tkn.type  =  EOF;	[BUG]  [BUGGY]  tkn.type  =  TOKEN;tkn.type  =  EOF;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  boolean  eol  =  isEndOfLine(c);  c  =  in.readAgain();    if  (emptyLinesIgnored)  {  while  (eol  &&  (lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(lastChar))  {    lastChar  =  c;  c  =  in.read();  eol  =  isEndOfLine(c);  c  =  in.readAgain();    if  (isEndOfFile(c))  {  [BUGGY]  tkn.type  =  TOKEN;tkn.type  =  EOF;  [BUGGY]    return  tkn;  }  }  }    if  (isEndOfFile(lastChar)  ||  (!isDelimiter(lastChar)  &&  isEndOfFile(c)))  {  tkn.type  =  EOF;    return  tkn;  }    while  (tkn.type  ==  INVALID)  {    [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P11_Insert_Donor_Statement]
[PATCH]  tkn.type  =  EOF;	[BUG]  [BUGGY]  tkn.type  =  EORECORD;tkn.type  =  EOF;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  boolean  eol  =  isEndOfLine(c);  c  =  in.readAgain();    if  (emptyLinesIgnored)  {  while  (eol  &&  (lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(lastChar))  {    lastChar  =  c;  c  =  in.read();  eol  =  isEndOfLine(c);  c  =  in.readAgain();    if  (isEndOfFile(c))  {  [BUGGY]  tkn.type  =  EORECORD;tkn.type  =  EOF;  [BUGGY]    return  tkn;  }  }  }    if  (isEndOfFile(lastChar)  ||  (!isDelimiter(lastChar)  &&  isEndOfFile(c)))  {  tkn.type  =  EOF;    return  tkn;  }    while  (tkn.type  ==  INVALID)  {    [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P11_Insert_Donor_Statement]
[PATCH]  lastChar  =  c;	[BUG]  [BUGGY]  lastChar  =  lastChar;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]            int  c  =  in.read();  boolean  eol  =  isEndOfLine(c);  c  =  in.readAgain();    if  (emptyLinesIgnored)  {  while  (eol  &&  (lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(lastChar))  {    [BUGGY]  lastChar  =  lastChar;  [BUGGY]  c  =  in.read();  eol  =  isEndOfLine(c);  c  =  in.readAgain();    if  (isEndOfFile(c))  {  tkn.type  =  EOF;    return  tkn;  }  }  }    if  (isEndOfFile(lastChar)  ||  (!isDelimiter(lastChar)  &&  isEndOfFile(c)))  {  tkn.type  =  EOF;    [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P5_Replace_Variable]
[PATCH]  lastChar  =  c;	[BUG]  [BUGGY]  lastChar  =  null;[CE]  incompatible  types  [CONTEXT]            int  c  =  in.read();  boolean  eol  =  isEndOfLine(c);  c  =  in.readAgain();    if  (emptyLinesIgnored)  {  while  (eol  &&  (lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(lastChar))  {    [BUGGY]  lastChar  =  null;  [BUGGY]  c  =  in.read();  eol  =  isEndOfLine(c);  c  =  in.readAgain();    if  (isEndOfFile(c))  {  tkn.type  =  EOF;    return  tkn;  }  }  }    if  (isEndOfFile(lastChar)  ||  (!isDelimiter(lastChar)  &&  isEndOfFile(c)))  {  tkn.type  =  EOF;    [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P8_Replace_Mix]
[PATCH]  c  =  in.read  (  )  ;	[BUG]  [BUGGY]  c  =  in.readLine(  )  ;[CE]  incompatible  types  [CONTEXT]          int  c  =  in.read();  boolean  eol  =  isEndOfLine(c);  c  =  in.readAgain();    if  (emptyLinesIgnored)  {  while  (eol  &&  (lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(lastChar))  {    lastChar  =  c;  [BUGGY]  c  =  in.readLine(  )  ;  [BUGGY]  eol  =  isEndOfLine(c);  c  =  in.readAgain();    if  (isEndOfFile(c))  {  tkn.type  =  EOF;    return  tkn;  }  }  }    if  (isEndOfFile(lastChar)  ||  (!isDelimiter(lastChar)  &&  isEndOfFile(c)))  {  tkn.type  =  EOF;      [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P7_Replace_Invocation]
[PATCH]  c  =  in.read  (  )  ;	[BUG]  [BUGGY]  c  ;[CE]  not  a  statement  [CONTEXT]          int  c  =  in.read();  boolean  eol  =  isEndOfLine(c);  c  =  in.readAgain();    if  (emptyLinesIgnored)  {  while  (eol  &&  (lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(lastChar))  {    lastChar  =  c;  [BUGGY]  c  ;  [BUGGY]  eol  =  isEndOfLine(c);  c  =  in.readAgain();    if  (isEndOfFile(c))  {  tkn.type  =  EOF;    return  tkn;  }  }  }    if  (isEndOfFile(lastChar)  ||  (!isDelimiter(lastChar)  &&  isEndOfFile(c)))  {  tkn.type  =  EOF;      [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P8_Replace_Mix]
[PATCH]  c  =  in.read  (  )  ;	[BUG]  [BUGGY]  c  =  in.readAgain(  )  ;c  =  in.read(  )  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]          int  c  =  in.read();  boolean  eol  =  isEndOfLine(c);  c  =  in.readAgain();    if  (emptyLinesIgnored)  {  while  (eol  &&  (lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(lastChar))  {    lastChar  =  c;  [BUGGY]  c  =  in.readAgain(  )  ;c  =  in.read(  )  ;  [BUGGY]  eol  =  isEndOfLine(c);  c  =  in.readAgain();    if  (isEndOfFile(c))  {  tkn.type  =  EOF;    return  tkn;  }  }  }    if  (isEndOfFile(lastChar)  ||  (!isDelimiter(lastChar)  &&  isEndOfFile(c)))  {  tkn.type  =  EOF;      [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P11_Insert_Donor_Statement]
[PATCH]  eol  =  isEndOfLine  (  c  )  ;	[BUG]  [BUGGY]  eol  =  isEndOfFile(  c)  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]        int  c  =  in.read();  boolean  eol  =  isEndOfLine(c);  c  =  in.readAgain();    if  (emptyLinesIgnored)  {  while  (eol  &&  (lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(lastChar))  {    lastChar  =  c;  c  =  in.read();  [BUGGY]  eol  =  isEndOfFile(  c)  ;  [BUGGY]  c  =  in.readAgain();    if  (isEndOfFile(c))  {  tkn.type  =  EOF;    return  tkn;  }  }  }    if  (isEndOfFile(lastChar)  ||  (!isDelimiter(lastChar)  &&  isEndOfFile(c)))  {  tkn.type  =  EOF;    return  tkn;    [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P7_Replace_Invocation]
[PATCH]  eol  =  isEndOfLine  (  c  )  ;	[BUG]  [BUGGY]  eol  =  isEndOfLine(  lastChar)  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]        int  c  =  in.read();  boolean  eol  =  isEndOfLine(c);  c  =  in.readAgain();    if  (emptyLinesIgnored)  {  while  (eol  &&  (lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(lastChar))  {    lastChar  =  c;  c  =  in.read();  [BUGGY]  eol  =  isEndOfLine(  lastChar)  ;  [BUGGY]  c  =  in.readAgain();    if  (isEndOfFile(c))  {  tkn.type  =  EOF;    return  tkn;  }  }  }    if  (isEndOfFile(lastChar)  ||  (!isDelimiter(lastChar)  &&  isEndOfFile(c)))  {  tkn.type  =  EOF;    return  tkn;    [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P8_Replace_Mix]
[PATCH]  eol  =  isEndOfLine  (  c  )  ;	[BUG]  [BUGGY]  c  =  in.readAgain(  )  ;eol  =  isEndOfLine(  c)  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]        int  c  =  in.read();  boolean  eol  =  isEndOfLine(c);  c  =  in.readAgain();    if  (emptyLinesIgnored)  {  while  (eol  &&  (lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(lastChar))  {    lastChar  =  c;  c  =  in.read();  [BUGGY]  c  =  in.readAgain(  )  ;eol  =  isEndOfLine(  c)  ;  [BUGGY]  c  =  in.readAgain();    if  (isEndOfFile(c))  {  tkn.type  =  EOF;    return  tkn;  }  }  }    if  (isEndOfFile(lastChar)  ||  (!isDelimiter(lastChar)  &&  isEndOfFile(c)))  {  tkn.type  =  EOF;    return  tkn;    [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P11_Insert_Donor_Statement]
[PATCH]  c  =  in.readAgain  (  )  ;	[BUG]  [BUGGY]  c  =  in.readLine(  )  ;[CE]  incompatible  types  [CONTEXT]      int  c  =  in.read();  boolean  eol  =  isEndOfLine(c);  c  =  in.readAgain();    if  (emptyLinesIgnored)  {  while  (eol  &&  (lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(lastChar))  {    lastChar  =  c;  c  =  in.read();  eol  =  isEndOfLine(c);  [BUGGY]  c  =  in.readLine(  )  ;  [BUGGY]    if  (isEndOfFile(c))  {  tkn.type  =  EOF;    return  tkn;  }  }  }    if  (isEndOfFile(lastChar)  ||  (!isDelimiter(lastChar)  &&  isEndOfFile(c)))  {  tkn.type  =  EOF;    return  tkn;  }    [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P7_Replace_Invocation]
[PATCH]  c  =  in.readAgain  (  )  ;	[BUG]  [BUGGY]  c  ;[CE]  not  a  statement  [CONTEXT]      int  c  =  in.read();  boolean  eol  =  isEndOfLine(c);  c  =  in.readAgain();    if  (emptyLinesIgnored)  {  while  (eol  &&  (lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(lastChar))  {    lastChar  =  c;  c  =  in.read();  eol  =  isEndOfLine(c);  [BUGGY]  c  ;  [BUGGY]    if  (isEndOfFile(c))  {  tkn.type  =  EOF;    return  tkn;  }  }  }    if  (isEndOfFile(lastChar)  ||  (!isDelimiter(lastChar)  &&  isEndOfFile(c)))  {  tkn.type  =  EOF;    return  tkn;  }    [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P8_Replace_Mix]
[PATCH]  c  =  in.readAgain  (  )  ;	[BUG]  [BUGGY]  eol  =  isEndOfLine(  c)  ;c  =  in.readAgain(  )  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]      int  c  =  in.read();  boolean  eol  =  isEndOfLine(c);  c  =  in.readAgain();    if  (emptyLinesIgnored)  {  while  (eol  &&  (lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(lastChar))  {    lastChar  =  c;  c  =  in.read();  eol  =  isEndOfLine(c);  [BUGGY]  eol  =  isEndOfLine(  c)  ;c  =  in.readAgain(  )  ;  [BUGGY]    if  (isEndOfFile(c))  {  tkn.type  =  EOF;    return  tkn;  }  }  }    if  (isEndOfFile(lastChar)  ||  (!isDelimiter(lastChar)  &&  isEndOfFile(c)))  {  tkn.type  =  EOF;    return  tkn;  }    [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P11_Insert_Donor_Statement]
[PATCH]  c  =  in.readAgain  (  )  ;	[BUG]  [BUGGY]  c  =  in.read(  )  ;c  =  in.readAgain(  )  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]      int  c  =  in.read();  boolean  eol  =  isEndOfLine(c);  c  =  in.readAgain();    if  (emptyLinesIgnored)  {  while  (eol  &&  (lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(lastChar))  {    lastChar  =  c;  c  =  in.read();  eol  =  isEndOfLine(c);  [BUGGY]  c  =  in.read(  )  ;c  =  in.readAgain(  )  ;  [BUGGY]    if  (isEndOfFile(c))  {  tkn.type  =  EOF;    return  tkn;  }  }  }    if  (isEndOfFile(lastChar)  ||  (!isDelimiter(lastChar)  &&  isEndOfFile(c)))  {  tkn.type  =  EOF;    return  tkn;  }    [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P11_Insert_Donor_Statement]
[PATCH]  tkn.type  =  EOF;	[BUG]  [BUGGY]  tkn.type  =  tkn.type  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  boolean  eol  =  isEndOfLine(c);  c  =  in.readAgain();    if  (emptyLinesIgnored)  {  while  (eol  &&  (lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(lastChar))  {    lastChar  =  c;  c  =  in.read();  eol  =  isEndOfLine(c);  c  =  in.readAgain();    if  (isEndOfFile(c))  {  [BUGGY]  tkn.type  =  tkn.type  ;  [BUGGY]    return  tkn;  }  }  }    if  (isEndOfFile(lastChar)  ||  (!isDelimiter(lastChar)  &&  isEndOfFile(c)))  {  tkn.type  =  EOF;    return  tkn;  }    while  (tkn.type  ==  INVALID)  {    [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P8_Replace_Mix]
[PATCH]  &&  !isEndOfFile  (  lastChar  )  )  {	[BUG]  [BUGGY]  &&  !isEndOfFile(  c)  )  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  int  lastChar  =  in.readAgain();            int  c  =  in.read();  boolean  eol  =  isEndOfLine(c);  c  =  in.readAgain();    if  (emptyLinesIgnored)  {  while  (eol  &&  (lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  [BUGGY]  &&  !isEndOfFile(  c)  )  {  [BUGGY]    lastChar  =  c;  c  =  in.read();  eol  =  isEndOfLine(c);  c  =  in.readAgain();    if  (isEndOfFile(c))  {  tkn.type  =  EOF;    return  tkn;  }  }  }        [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P5_Replace_Variable]
[PATCH]  &&  !isEndOfFile  (  lastChar  )  )  {	[BUG]  [BUGGY]  &&  !isEndOfLine(  lastChar)  )  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  int  lastChar  =  in.readAgain();            int  c  =  in.read();  boolean  eol  =  isEndOfLine(c);  c  =  in.readAgain();    if  (emptyLinesIgnored)  {  while  (eol  &&  (lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  [BUGGY]  &&  !isEndOfLine(  lastChar)  )  {  [BUGGY]    lastChar  =  c;  c  =  in.read();  eol  =  isEndOfLine(c);  c  =  in.readAgain();    if  (isEndOfFile(c))  {  tkn.type  =  EOF;    return  tkn;  }  }  }        [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P7_Replace_Invocation]
[PATCH]  &&  !isEndOfFile  (  lastChar  )  )  {	[BUG]  [BUGGY]  &&  !isEndOfLine(  c)  )  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  int  lastChar  =  in.readAgain();            int  c  =  in.read();  boolean  eol  =  isEndOfLine(c);  c  =  in.readAgain();    if  (emptyLinesIgnored)  {  while  (eol  &&  (lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  [BUGGY]  &&  !isEndOfLine(  c)  )  {  [BUGGY]    lastChar  =  c;  c  =  in.read();  eol  =  isEndOfLine(c);  c  =  in.readAgain();    if  (isEndOfFile(c))  {  tkn.type  =  EOF;    return  tkn;  }  }  }        [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P8_Replace_Mix]
[PATCH]  &&  !isEndOfFile  (  lastChar  )  )  {  lastChar  =  c;	[BUG]  [BUGGY]  [FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  int  lastChar  =  in.readAgain();            int  c  =  in.read();  boolean  eol  =  isEndOfLine(c);  c  =  in.readAgain();    if  (emptyLinesIgnored)  {  while  (eol  &&  (lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  [BUGGY]  [BUGGY]      c  =  in.read();  eol  =  isEndOfLine(c);  c  =  in.readAgain();    if  (isEndOfFile(c))  {  tkn.type  =  EOF;    return  tkn;  }  }  }      [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P14_Delete_Statement]
[PATCH]  c  =  in.read  (  )  ;	[BUG]  [BUGGY]  c  =  this.read(  )  ;[CE]  cannot  find  symbol  [CONTEXT]          int  c  =  in.read();  boolean  eol  =  isEndOfLine(c);  c  =  in.readAgain();    if  (emptyLinesIgnored)  {  while  (eol  &&  (lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(lastChar))  {    lastChar  =  c;  [BUGGY]  c  =  this.read(  )  ;  [BUGGY]  eol  =  isEndOfLine(c);  c  =  in.readAgain();    if  (isEndOfFile(c))  {  tkn.type  =  EOF;    return  tkn;  }  }  }    if  (isEndOfFile(lastChar)  ||  (!isDelimiter(lastChar)  &&  isEndOfFile(c)))  {  tkn.type  =  EOF;      [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P5_Replace_Variable]
[PATCH]  c  =  in.read  (  )  ;	[BUG]  [BUGGY]  [FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]          int  c  =  in.read();  boolean  eol  =  isEndOfLine(c);  c  =  in.readAgain();    if  (emptyLinesIgnored)  {  while  (eol  &&  (lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(lastChar))  {    lastChar  =  c;  [BUGGY]  [BUGGY]    eol  =  isEndOfLine(c);  c  =  in.readAgain();    if  (isEndOfFile(c))  {  tkn.type  =  EOF;    return  tkn;  }  }  }    if  (isEndOfFile(lastChar)  ||  (!isDelimiter(lastChar)  &&  isEndOfFile(c)))  {  tkn.type  =  EOF;    [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P14_Delete_Statement]
[PATCH]  c  =  in.read  (  )  ;	[BUG]  [BUGGY]  int  lastChar  =  in.readAgain(  )  ;c  =  in.read(  )  ;[CE]  variable  lastChar  is  already  defined  in  method  nextToken(Token)  [CONTEXT]          int  c  =  in.read();  boolean  eol  =  isEndOfLine(c);  c  =  in.readAgain();    if  (emptyLinesIgnored)  {  while  (eol  &&  (lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(lastChar))  {    lastChar  =  c;  [BUGGY]  int  lastChar  =  in.readAgain(  )  ;c  =  in.read(  )  ;  [BUGGY]  eol  =  isEndOfLine(c);  c  =  in.readAgain();    if  (isEndOfFile(c))  {  tkn.type  =  EOF;    return  tkn;  }  }  }    if  (isEndOfFile(lastChar)  ||  (!isDelimiter(lastChar)  &&  isEndOfFile(c)))  {  tkn.type  =  EOF;      [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P11_Insert_Donor_Statement]
[PATCH]  c  =  in.read  (  )  ;	[BUG]  [BUGGY]  int  c  =  in.read(  )  ;c  =  in.read(  )  ;[CE]  variable  c  is  already  defined  in  method  nextToken(Token)  [CONTEXT]          int  c  =  in.read();  boolean  eol  =  isEndOfLine(c);  c  =  in.readAgain();    if  (emptyLinesIgnored)  {  while  (eol  &&  (lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(lastChar))  {    lastChar  =  c;  [BUGGY]  int  c  =  in.read(  )  ;c  =  in.read(  )  ;  [BUGGY]  eol  =  isEndOfLine(c);  c  =  in.readAgain();    if  (isEndOfFile(c))  {  tkn.type  =  EOF;    return  tkn;  }  }  }    if  (isEndOfFile(lastChar)  ||  (!isDelimiter(lastChar)  &&  isEndOfFile(c)))  {  tkn.type  =  EOF;      [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P11_Insert_Donor_Statement]
[PATCH]  c  =  in.read  (  )  ;	[BUG]  [BUGGY]  in.readLine(  )  ;c  =  in.read(  )  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]          int  c  =  in.read();  boolean  eol  =  isEndOfLine(c);  c  =  in.readAgain();    if  (emptyLinesIgnored)  {  while  (eol  &&  (lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(lastChar))  {    lastChar  =  c;  [BUGGY]  in.readLine(  )  ;c  =  in.read(  )  ;  [BUGGY]  eol  =  isEndOfLine(c);  c  =  in.readAgain();    if  (isEndOfFile(c))  {  tkn.type  =  EOF;    return  tkn;  }  }  }    if  (isEndOfFile(lastChar)  ||  (!isDelimiter(lastChar)  &&  isEndOfFile(c)))  {  tkn.type  =  EOF;      [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P11_Insert_Donor_Statement]
[PATCH]  eol  =  isEndOfLine  (  c  )  ;  c  =  in.readAgain  (  )  ;	[BUG]  [BUGGY]  [FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]        int  c  =  in.read();  boolean  eol  =  isEndOfLine(c);  c  =  in.readAgain();    if  (emptyLinesIgnored)  {  while  (eol  &&  (lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(lastChar))  {    lastChar  =  c;  c  =  in.read();  [BUGGY]  [BUGGY]      if  (isEndOfFile(c))  {  tkn.type  =  EOF;    return  tkn;  }  }  }    if  (isEndOfFile(lastChar)  ||  (!isDelimiter(lastChar)  &&  isEndOfFile(c)))  {  tkn.type  =  EOF;      [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P14_Delete_Statement]
[PATCH]  c  =  in.readAgain  (  )  ;	[BUG]  [BUGGY]  c  =  0.readAgain(  )  ;[CE]  ';'  expected  [CONTEXT]      int  c  =  in.read();  boolean  eol  =  isEndOfLine(c);  c  =  in.readAgain();    if  (emptyLinesIgnored)  {  while  (eol  &&  (lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(lastChar))  {    lastChar  =  c;  c  =  in.read();  eol  =  isEndOfLine(c);  [BUGGY]  c  =  0.readAgain(  )  ;  [BUGGY]    if  (isEndOfFile(c))  {  tkn.type  =  EOF;    return  tkn;  }  }  }    if  (isEndOfFile(lastChar)  ||  (!isDelimiter(lastChar)  &&  isEndOfFile(c)))  {  tkn.type  =  EOF;    return  tkn;  }    [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P8_Replace_Mix]
[PATCH]  c  =  in.readAgain  (  )  ;	[BUG]  [BUGGY]  [FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]      int  c  =  in.read();  boolean  eol  =  isEndOfLine(c);  c  =  in.readAgain();    if  (emptyLinesIgnored)  {  while  (eol  &&  (lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(lastChar))  {    lastChar  =  c;  c  =  in.read();  eol  =  isEndOfLine(c);  [BUGGY]  [BUGGY]      if  (isEndOfFile(c))  {  tkn.type  =  EOF;    return  tkn;  }  }  }    if  (isEndOfFile(lastChar)  ||  (!isDelimiter(lastChar)  &&  isEndOfFile(c)))  {  tkn.type  =  EOF;    return  tkn;    [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P14_Delete_Statement]
[PATCH]  c  =  in.readAgain  (  )  ;	[BUG]  [BUGGY]  int  lastChar  =  in.readAgain(  )  ;c  =  in.readAgain(  )  ;[CE]  variable  lastChar  is  already  defined  in  method  nextToken(Token)  [CONTEXT]      int  c  =  in.read();  boolean  eol  =  isEndOfLine(c);  c  =  in.readAgain();    if  (emptyLinesIgnored)  {  while  (eol  &&  (lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(lastChar))  {    lastChar  =  c;  c  =  in.read();  eol  =  isEndOfLine(c);  [BUGGY]  int  lastChar  =  in.readAgain(  )  ;c  =  in.readAgain(  )  ;  [BUGGY]    if  (isEndOfFile(c))  {  tkn.type  =  EOF;    return  tkn;  }  }  }    if  (isEndOfFile(lastChar)  ||  (!isDelimiter(lastChar)  &&  isEndOfFile(c)))  {  tkn.type  =  EOF;    return  tkn;  }    [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P11_Insert_Donor_Statement]
[PATCH]  c  =  in.readAgain  (  )  ;	[BUG]  [BUGGY]  int  c  =  in.read(  )  ;c  =  in.readAgain(  )  ;[CE]  variable  c  is  already  defined  in  method  nextToken(Token)  [CONTEXT]      int  c  =  in.read();  boolean  eol  =  isEndOfLine(c);  c  =  in.readAgain();    if  (emptyLinesIgnored)  {  while  (eol  &&  (lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(lastChar))  {    lastChar  =  c;  c  =  in.read();  eol  =  isEndOfLine(c);  [BUGGY]  int  c  =  in.read(  )  ;c  =  in.readAgain(  )  ;  [BUGGY]    if  (isEndOfFile(c))  {  tkn.type  =  EOF;    return  tkn;  }  }  }    if  (isEndOfFile(lastChar)  ||  (!isDelimiter(lastChar)  &&  isEndOfFile(c)))  {  tkn.type  =  EOF;    return  tkn;  }    [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P11_Insert_Donor_Statement]
[PATCH]  c  =  in.readAgain  (  )  ;	[BUG]  [BUGGY]  in.readLine(  )  ;c  =  in.readAgain(  )  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]      int  c  =  in.read();  boolean  eol  =  isEndOfLine(c);  c  =  in.readAgain();    if  (emptyLinesIgnored)  {  while  (eol  &&  (lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(lastChar))  {    lastChar  =  c;  c  =  in.read();  eol  =  isEndOfLine(c);  [BUGGY]  in.readLine(  )  ;c  =  in.readAgain(  )  ;  [BUGGY]    if  (isEndOfFile(c))  {  tkn.type  =  EOF;    return  tkn;  }  }  }    if  (isEndOfFile(lastChar)  ||  (!isDelimiter(lastChar)  &&  isEndOfFile(c)))  {  tkn.type  =  EOF;    return  tkn;  }    [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P11_Insert_Donor_Statement]
[PATCH]  c  =  in.read  (  )  ;	[BUG]  [BUGGY]  c  =  null  ;[CE]  incompatible  types  [CONTEXT]          int  c  =  in.read();  boolean  eol  =  isEndOfLine(c);  c  =  in.readAgain();    if  (emptyLinesIgnored)  {  while  (eol  &&  (lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(lastChar))  {    lastChar  =  c;  [BUGGY]  c  =  null  ;  [BUGGY]  eol  =  isEndOfLine(c);  c  =  in.readAgain();    if  (isEndOfFile(c))  {  tkn.type  =  EOF;    return  tkn;  }  }  }    if  (isEndOfFile(lastChar)  ||  (!isDelimiter(lastChar)  &&  isEndOfFile(c)))  {  tkn.type  =  EOF;      [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P8_Replace_Mix]
[PATCH]  eol  =  isEndOfLine  (  c  )  ;	[BUG]  [BUGGY]  [FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]        int  c  =  in.read();  boolean  eol  =  isEndOfLine(c);  c  =  in.readAgain();    if  (emptyLinesIgnored)  {  while  (eol  &&  (lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(lastChar))  {    lastChar  =  c;  c  =  in.read();  [BUGGY]  [BUGGY]    c  =  in.readAgain();    if  (isEndOfFile(c))  {  tkn.type  =  EOF;    return  tkn;  }  }  }    if  (isEndOfFile(lastChar)  ||  (!isDelimiter(lastChar)  &&  isEndOfFile(c)))  {  tkn.type  =  EOF;      [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P14_Delete_Statement]
[PATCH]  if  (  isEndOfFile  (  c  )  )  {	[BUG]  [BUGGY]  if  (  isEndOfLine(  lastChar)  )  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  int  c  =  in.read();  boolean  eol  =  isEndOfLine(c);  c  =  in.readAgain();    if  (emptyLinesIgnored)  {  while  (eol  &&  (lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(lastChar))  {    lastChar  =  c;  c  =  in.read();  eol  =  isEndOfLine(c);  c  =  in.readAgain();    [BUGGY]  if  (  isEndOfLine(  lastChar)  )  {  [BUGGY]  tkn.type  =  EOF;    return  tkn;  }  }  }    if  (isEndOfFile(lastChar)  ||  (!isDelimiter(lastChar)  &&  isEndOfFile(c)))  {  tkn.type  =  EOF;    return  tkn;  }        [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P8_Replace_Mix]
[PATCH]  if  (  isEndOfFile  (  lastChar  )  ||  (  !isDelimiter  (  lastChar  )  &&  isEndOfFile  (  c  )  )  )  {	[BUG]  [BUGGY]  if  (  isEndOfFile(  lastChar)  &&  (  !isDelimiter(  lastChar)  &&  isEndOfFile(  c)  )  )  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]    lastChar  =  c;  c  =  in.read();  eol  =  isEndOfLine(c);  c  =  in.readAgain();    if  (isEndOfFile(c))  {  tkn.type  =  EOF;    return  tkn;  }  }  }    [BUGGY]  if  (  isEndOfFile(  lastChar)  &&  (  !isDelimiter(  lastChar)  &&  isEndOfFile(  c)  )  )  {  [BUGGY]  tkn.type  =  EOF;    return  tkn;  }    while  (tkn.type  ==  INVALID)  {    if  (surroundingSpacesIgnored)  {  while  (isWhitespace(c)  &&  !eol)  {  c  =  in.read();  eol  =  isEndOfLine(c);  }  }      [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P2_Replace_Operator]
[PATCH]  if  (  isEndOfFile  (  lastChar  )  ||  (  !isDelimiter  (  lastChar  )  &&  isEndOfFile  (  c  )  )  )  {	[BUG]  [BUGGY]  if  (  isEndOfFile(  lastChar)  ||  (  !isDelimiter(  lastChar)  ||  isEndOfFile(  c)  )  )  {[FE]  Token  type  expected:<TOKEN>  but  was:<EOF>  testNextToken1  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]    lastChar  =  c;  c  =  in.read();  eol  =  isEndOfLine(c);  c  =  in.readAgain();    if  (isEndOfFile(c))  {  tkn.type  =  EOF;    return  tkn;  }  }  }    [BUGGY]  if  (  isEndOfFile(  lastChar)  ||  (  !isDelimiter(  lastChar)  ||  isEndOfFile(  c)  )  )  {  [BUGGY]  tkn.type  =  EOF;    return  tkn;  }    while  (tkn.type  ==  INVALID)  {    if  (surroundingSpacesIgnored)  {  while  (isWhitespace(c)  &&  !eol)  {  c  =  in.read();  eol  =  isEndOfLine(c);  }  }      [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P2_Replace_Operator]
[PATCH]  if  (  isEndOfFile  (  lastChar  )  ||  (  !isDelimiter  (  lastChar  )  &&  isEndOfFile  (  c  )  )  )  {	[BUG]  [BUGGY]  if  (  isEndOfFile(  c)  ||  (  !isDelimiter(  lastChar)  &&  isEndOfFile(  c)  )  )  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]    lastChar  =  c;  c  =  in.read();  eol  =  isEndOfLine(c);  c  =  in.readAgain();    if  (isEndOfFile(c))  {  tkn.type  =  EOF;    return  tkn;  }  }  }    [BUGGY]  if  (  isEndOfFile(  c)  ||  (  !isDelimiter(  lastChar)  &&  isEndOfFile(  c)  )  )  {  [BUGGY]  tkn.type  =  EOF;    return  tkn;  }    while  (tkn.type  ==  INVALID)  {    if  (surroundingSpacesIgnored)  {  while  (isWhitespace(c)  &&  !eol)  {  c  =  in.read();  eol  =  isEndOfLine(c);  }  }      [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P5_Replace_Variable]
[PATCH]  if  (  isEndOfFile  (  lastChar  )  ||  (  !isDelimiter  (  lastChar  )  &&  isEndOfFile  (  c  )  )  )  {	[BUG]  [BUGGY]  if  (  isEndOfFile(  lastChar)  ||  (  !isDelimiter(  lastChar)  &&  isEndOfFile(  lastChar)  )  )  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]    lastChar  =  c;  c  =  in.read();  eol  =  isEndOfLine(c);  c  =  in.readAgain();    if  (isEndOfFile(c))  {  tkn.type  =  EOF;    return  tkn;  }  }  }    [BUGGY]  if  (  isEndOfFile(  lastChar)  ||  (  !isDelimiter(  lastChar)  &&  isEndOfFile(  lastChar)  )  )  {  [BUGGY]  tkn.type  =  EOF;    return  tkn;  }    while  (tkn.type  ==  INVALID)  {    if  (surroundingSpacesIgnored)  {  while  (isWhitespace(c)  &&  !eol)  {  c  =  in.read();  eol  =  isEndOfLine(c);  }  }      [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P5_Replace_Variable]
[PATCH]  if  (  isEndOfFile  (  lastChar  )  ||  (  !isDelimiter  (  lastChar  )  &&  isEndOfFile  (  c  )  )  )  {	[BUG]  [BUGGY]  if  (  isEndOfFile(  c)  ||  (  !isDelimiter(  lastChar)  &&  isEndOfFile(  lastChar)  )  )  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]    lastChar  =  c;  c  =  in.read();  eol  =  isEndOfLine(c);  c  =  in.readAgain();    if  (isEndOfFile(c))  {  tkn.type  =  EOF;    return  tkn;  }  }  }    [BUGGY]  if  (  isEndOfFile(  c)  ||  (  !isDelimiter(  lastChar)  &&  isEndOfFile(  lastChar)  )  )  {  [BUGGY]  tkn.type  =  EOF;    return  tkn;  }    while  (tkn.type  ==  INVALID)  {    if  (surroundingSpacesIgnored)  {  while  (isWhitespace(c)  &&  !eol)  {  c  =  in.read();  eol  =  isEndOfLine(c);  }  }      [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P5_Replace_Variable]
[PATCH]  if  (  isEndOfFile  (  lastChar  )  ||  (  !isDelimiter  (  lastChar  )  &&  isEndOfFile  (  c  )  )  )  {	[BUG]  [BUGGY]  if  (  isEndOfFile(  lastChar)  )  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]    lastChar  =  c;  c  =  in.read();  eol  =  isEndOfLine(c);  c  =  in.readAgain();    if  (isEndOfFile(c))  {  tkn.type  =  EOF;    return  tkn;  }  }  }    [BUGGY]  if  (  isEndOfFile(  lastChar)  )  {  [BUGGY]  tkn.type  =  EOF;    return  tkn;  }    while  (tkn.type  ==  INVALID)  {    if  (surroundingSpacesIgnored)  {  while  (isWhitespace(c)  &&  !eol)  {  c  =  in.read();  eol  =  isEndOfLine(c);  }  }      [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P6_Replace_Expression]
[PATCH]  if  (  isEndOfFile  (  lastChar  )  ||  (  !isDelimiter  (  lastChar  )  &&  isEndOfFile  (  c  )  )  )  {	[BUG]  [BUGGY]  if  (  (  !isDelimiter(  lastChar)  &&  isEndOfFile(  c)  )  )  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]    lastChar  =  c;  c  =  in.read();  eol  =  isEndOfLine(c);  c  =  in.readAgain();    if  (isEndOfFile(c))  {  tkn.type  =  EOF;    return  tkn;  }  }  }    [BUGGY]  if  (  (  !isDelimiter(  lastChar)  &&  isEndOfFile(  c)  )  )  {  [BUGGY]  tkn.type  =  EOF;    return  tkn;  }    while  (tkn.type  ==  INVALID)  {    if  (surroundingSpacesIgnored)  {  while  (isWhitespace(c)  &&  !eol)  {  c  =  in.read();  eol  =  isEndOfLine(c);  }  }      [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P6_Replace_Expression]
[PATCH]  if  (  isEndOfFile  (  lastChar  )  ||  (  !isDelimiter  (  lastChar  )  &&  isEndOfFile  (  c  )  )  )  {	[BUG]  [BUGGY]  if  (  !(isDelimiter(lastChar)  &&  isEndOfFile(c)))  {[FE]  Token  type  expected:<TOKEN>  but  was:<EOF>  testNextToken1  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]    lastChar  =  c;  c  =  in.read();  eol  =  isEndOfLine(c);  c  =  in.readAgain();    if  (isEndOfFile(c))  {  tkn.type  =  EOF;    return  tkn;  }  }  }    [BUGGY]  if  (  !(isDelimiter(lastChar)  &&  isEndOfFile(c)))  {  [BUGGY]  tkn.type  =  EOF;    return  tkn;  }    while  (tkn.type  ==  INVALID)  {    if  (surroundingSpacesIgnored)  {  while  (isWhitespace(c)  &&  !eol)  {  c  =  in.read();  eol  =  isEndOfLine(c);  }  }      [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P6_Replace_Expression]
[PATCH]  if  (  isEndOfFile  (  lastChar  )  ||  (  !isDelimiter  (  lastChar  )  &&  isEndOfFile  (  c  )  )  )  {	[BUG]  [BUGGY]  if  (  isEndOfLine(  lastChar)  ||  (  !isDelimiter(  lastChar)  &&  isEndOfFile(  c)  )  )  {[FE]  Token  type  expected:<TOKEN>  but  was:<EOF>  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]    lastChar  =  c;  c  =  in.read();  eol  =  isEndOfLine(c);  c  =  in.readAgain();    if  (isEndOfFile(c))  {  tkn.type  =  EOF;    return  tkn;  }  }  }    [BUGGY]  if  (  isEndOfLine(  lastChar)  ||  (  !isDelimiter(  lastChar)  &&  isEndOfFile(  c)  )  )  {  [BUGGY]  tkn.type  =  EOF;    return  tkn;  }    while  (tkn.type  ==  INVALID)  {    if  (surroundingSpacesIgnored)  {  while  (isWhitespace(c)  &&  !eol)  {  c  =  in.read();  eol  =  isEndOfLine(c);  }  }      [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P7_Replace_Invocation]
[PATCH]  if  (  isEndOfFile  (  lastChar  )  ||  (  !isDelimiter  (  lastChar  )  &&  isEndOfFile  (  c  )  )  )  {	[BUG]  [BUGGY]  if  (  isEndOfFile(  lastChar)  ||  (  !isEscape(  lastChar)  &&  isEndOfFile(  c)  )  )  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]    lastChar  =  c;  c  =  in.read();  eol  =  isEndOfLine(c);  c  =  in.readAgain();    if  (isEndOfFile(c))  {  tkn.type  =  EOF;    return  tkn;  }  }  }    [BUGGY]  if  (  isEndOfFile(  lastChar)  ||  (  !isEscape(  lastChar)  &&  isEndOfFile(  c)  )  )  {  [BUGGY]  tkn.type  =  EOF;    return  tkn;  }    while  (tkn.type  ==  INVALID)  {    if  (surroundingSpacesIgnored)  {  while  (isWhitespace(c)  &&  !eol)  {  c  =  in.read();  eol  =  isEndOfLine(c);  }  }      [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P7_Replace_Invocation]
[PATCH]  if  (  isEndOfFile  (  lastChar  )  ||  (  !isDelimiter  (  lastChar  )  &&  isEndOfFile  (  c  )  )  )  {  tkn.type  =  EOF;  return  tkn;  }	[BUG]  [BUGGY]  tkn.type  =  EOF;  return  tkn;[CE]  illegal  start  of  expression  [CONTEXT]    lastChar  =  c;  c  =  in.read();  eol  =  isEndOfLine(c);  c  =  in.readAgain();    if  (isEndOfFile(c))  {  tkn.type  =  EOF;    return  tkn;  }  }  }    [BUGGY]  tkn.type  =  EOF;  return  tkn;  [BUGGY]    tkn.type  =  EOF;  return  tkn;        while  (tkn.type  ==  INVALID)  {    if  (surroundingSpacesIgnored)  {  while  (isWhitespace(c)  &&  !eol)  {  c  =  in.read();  eol  =  isEndOfLine(c);  }  }    [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P15_Unwrap_Block]
[PATCH]  if  (  isEndOfFile  (  lastChar  )  ||  (  !isDelimiter  (  lastChar  )  &&  isEndOfFile  (  c  )  )  )  {  tkn.type  =  EOF;  return  tkn;  }	[BUG]  [BUGGY]  [CE]  illegal  start  of  expression  [CONTEXT]    lastChar  =  c;  c  =  in.read();  eol  =  isEndOfLine(c);  c  =  in.readAgain();    if  (isEndOfFile(c))  {  tkn.type  =  EOF;    return  tkn;  }  }  }    [BUGGY]  [BUGGY]            while  (tkn.type  ==  INVALID)  {    if  (surroundingSpacesIgnored)  {  while  (isWhitespace(c)  &&  !eol)  {  c  =  in.read();  eol  =  isEndOfLine(c);  }  }    [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P16_Remove_Block]
[PATCH]  tkn.type  =  EOF;	[BUG]  [BUGGY]  tkn.type  =  null  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  lastChar  =  c;  c  =  in.read();  eol  =  isEndOfLine(c);  c  =  in.readAgain();    if  (isEndOfFile(c))  {  tkn.type  =  EOF;    return  tkn;  }  }  }    if  (isEndOfFile(lastChar)  ||  (!isDelimiter(lastChar)  &&  isEndOfFile(c)))  {  [BUGGY]  tkn.type  =  null  ;  [BUGGY]    return  tkn;  }    while  (tkn.type  ==  INVALID)  {    if  (surroundingSpacesIgnored)  {  while  (isWhitespace(c)  &&  !eol)  {  c  =  in.read();  eol  =  isEndOfLine(c);  }  }        [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P8_Replace_Mix]
[PATCH]  tkn.type  =  EOF;	[BUG]  [BUGGY]  tkn.type  =  TOKEN;tkn.type  =  EOF;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  lastChar  =  c;  c  =  in.read();  eol  =  isEndOfLine(c);  c  =  in.readAgain();    if  (isEndOfFile(c))  {  tkn.type  =  EOF;    return  tkn;  }  }  }    if  (isEndOfFile(lastChar)  ||  (!isDelimiter(lastChar)  &&  isEndOfFile(c)))  {  [BUGGY]  tkn.type  =  TOKEN;tkn.type  =  EOF;  [BUGGY]    return  tkn;  }    while  (tkn.type  ==  INVALID)  {    if  (surroundingSpacesIgnored)  {  while  (isWhitespace(c)  &&  !eol)  {  c  =  in.read();  eol  =  isEndOfLine(c);  }  }        [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P11_Insert_Donor_Statement]
[PATCH]  tkn.type  =  EOF;	[BUG]  [BUGGY]  tkn.type  =  EORECORD;tkn.type  =  EOF;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  lastChar  =  c;  c  =  in.read();  eol  =  isEndOfLine(c);  c  =  in.readAgain();    if  (isEndOfFile(c))  {  tkn.type  =  EOF;    return  tkn;  }  }  }    if  (isEndOfFile(lastChar)  ||  (!isDelimiter(lastChar)  &&  isEndOfFile(c)))  {  [BUGGY]  tkn.type  =  EORECORD;tkn.type  =  EOF;  [BUGGY]    return  tkn;  }    while  (tkn.type  ==  INVALID)  {    if  (surroundingSpacesIgnored)  {  while  (isWhitespace(c)  &&  !eol)  {  c  =  in.read();  eol  =  isEndOfLine(c);  }  }        [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P11_Insert_Donor_Statement]
[PATCH]  tkn.type  =  EOF;	[BUG]  [BUGGY]  tkn.type  ;[CE]  not  a  statement  [CONTEXT]  lastChar  =  c;  c  =  in.read();  eol  =  isEndOfLine(c);  c  =  in.readAgain();    if  (isEndOfFile(c))  {  tkn.type  =  EOF;    return  tkn;  }  }  }    if  (isEndOfFile(lastChar)  ||  (!isDelimiter(lastChar)  &&  isEndOfFile(c)))  {  [BUGGY]  tkn.type  ;  [BUGGY]    return  tkn;  }    while  (tkn.type  ==  INVALID)  {    if  (surroundingSpacesIgnored)  {  while  (isWhitespace(c)  &&  !eol)  {  c  =  in.read();  eol  =  isEndOfLine(c);  }  }        [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P8_Replace_Mix]
[PATCH]  while  (  tkn.type  ==  INVALID  )  {	[BUG]  [BUGGY]  while  (  tkn.type  >=  INVALID)  {[CE]  bad  operand  types  for  binary  operator  '>='  [CONTEXT]  tkn.type  =  EOF;    return  tkn;  }  }  }    if  (isEndOfFile(lastChar)  ||  (!isDelimiter(lastChar)  &&  isEndOfFile(c)))  {  tkn.type  =  EOF;    return  tkn;  }    [BUGGY]  while  (  tkn.type  >=  INVALID)  {  [BUGGY]    if  (surroundingSpacesIgnored)  {  while  (isWhitespace(c)  &&  !eol)  {  c  =  in.read();  eol  =  isEndOfLine(c);  }  }    if  (isCommentStart(c))  {    in.readLine();  tkn  =  nextToken(tkn.reset());  }  else  if  (isDelimiter(c))  {      [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P2_Replace_Operator]
[PATCH]  while  (  isWhitespace  (  c  )  &&  !eol  )  {	[BUG]  [BUGGY]  while  (  isWhitespace(  c)  ||  !eol)  {[FE]  [CONTEXT]  }  }  }    if  (isEndOfFile(lastChar)  ||  (!isDelimiter(lastChar)  &&  isEndOfFile(c)))  {  tkn.type  =  EOF;    return  tkn;  }    while  (tkn.type  ==  INVALID)  {    if  (surroundingSpacesIgnored)  {  [BUGGY]  while  (  isWhitespace(  c)  ||  !eol)  {  [BUGGY]  c  =  in.read();  eol  =  isEndOfLine(c);  }  }    if  (isCommentStart(c))  {    in.readLine();  tkn  =  nextToken(tkn.reset());  }  else  if  (isDelimiter(c))  {    tkn.type  =  TOKEN;  }  else  if  (eol)  {      [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P2_Replace_Operator]
[PATCH]  while  (  isWhitespace  (  c  )  &&  !eol  )  {	[BUG]  [BUGGY]  while  (  isWhitespace(  lastChar)  &&  !eol)  {[FE]  Token  content  expected:<[]hijk>  but  was:<[  ]hijk>  testNextToken1  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  }  }  }    if  (isEndOfFile(lastChar)  ||  (!isDelimiter(lastChar)  &&  isEndOfFile(c)))  {  tkn.type  =  EOF;    return  tkn;  }    while  (tkn.type  ==  INVALID)  {    if  (surroundingSpacesIgnored)  {  [BUGGY]  while  (  isWhitespace(  lastChar)  &&  !eol)  {  [BUGGY]  c  =  in.read();  eol  =  isEndOfLine(c);  }  }    if  (isCommentStart(c))  {    in.readLine();  tkn  =  nextToken(tkn.reset());  }  else  if  (isDelimiter(c))  {    tkn.type  =  TOKEN;  }  else  if  (eol)  {      [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P5_Replace_Variable]
[PATCH]  while  (  isWhitespace  (  c  )  &&  !eol  )  {	[BUG]  [BUGGY]  while  (  isEscape(  c)  &&  !eol)  {[FE]  Token  content  expected:<[]hijk>  but  was:<[  ]hijk>  testNextToken1  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  }  }  }    if  (isEndOfFile(lastChar)  ||  (!isDelimiter(lastChar)  &&  isEndOfFile(c)))  {  tkn.type  =  EOF;    return  tkn;  }    while  (tkn.type  ==  INVALID)  {    if  (surroundingSpacesIgnored)  {  [BUGGY]  while  (  isEscape(  c)  &&  !eol)  {  [BUGGY]  c  =  in.read();  eol  =  isEndOfLine(c);  }  }    if  (isCommentStart(c))  {    in.readLine();  tkn  =  nextToken(tkn.reset());  }  else  if  (isDelimiter(c))  {    tkn.type  =  TOKEN;  }  else  if  (eol)  {      [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P7_Replace_Invocation]
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  surroundingSpacesIgnored)  {      while  (  (  isWhitespace(  c)  )  &&  (  !eol)  )  {          c  =  in.read(  )  ;          eol  =  isEndOfLine(  c)  ;      }  }[CE]  illegal  start  of  type  [CONTEXT]  }  }  }    if  (isEndOfFile(lastChar)  ||  (!isDelimiter(lastChar)  &&  isEndOfFile(c)))  {  tkn.type  =  EOF;    return  tkn;  }    while  (tkn.type  ==  INVALID)  {    if  (surroundingSpacesIgnored)  {  [BUGGY]  if  (  surroundingSpacesIgnored)  {      while  (  (  isWhitespace(  c)  )  &&  (  !eol)  )  {          c  =  in.read(  )  ;          eol  =  isEndOfLine(  c)  ;      }  }  [BUGGY]  c  =  in.read();  eol  =  isEndOfLine(c);  }  }    if  (isCommentStart(c))  {    in.readLine();  tkn  =  nextToken(tkn.reset());  }  else  if  (isDelimiter(c))  {    tkn.type  =  TOKEN;  }  else  if  (eol)  {      [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P13_Insert_Block]
[PATCH]  c  =  in.read  (  )  ;	[BUG]  [BUGGY]  c  =  in.readLine(  )  ;[CE]  incompatible  types  [CONTEXT]  }  }    if  (isEndOfFile(lastChar)  ||  (!isDelimiter(lastChar)  &&  isEndOfFile(c)))  {  tkn.type  =  EOF;    return  tkn;  }    while  (tkn.type  ==  INVALID)  {    if  (surroundingSpacesIgnored)  {  while  (isWhitespace(c)  &&  !eol)  {  [BUGGY]  c  =  in.readLine(  )  ;  [BUGGY]  eol  =  isEndOfLine(c);  }  }    if  (isCommentStart(c))  {    in.readLine();  tkn  =  nextToken(tkn.reset());  }  else  if  (isDelimiter(c))  {    tkn.type  =  TOKEN;  }  else  if  (eol)  {        [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P7_Replace_Invocation]
[PATCH]  c  =  in.read  (  )  ;	[BUG]  [BUGGY]  c  =  c  ;[FE]  [CONTEXT]  }  }    if  (isEndOfFile(lastChar)  ||  (!isDelimiter(lastChar)  &&  isEndOfFile(c)))  {  tkn.type  =  EOF;    return  tkn;  }    while  (tkn.type  ==  INVALID)  {    if  (surroundingSpacesIgnored)  {  while  (isWhitespace(c)  &&  !eol)  {  [BUGGY]  c  =  c  ;  [BUGGY]  eol  =  isEndOfLine(c);  }  }    if  (isCommentStart(c))  {    in.readLine();  tkn  =  nextToken(tkn.reset());  }  else  if  (isDelimiter(c))  {    tkn.type  =  TOKEN;  }  else  if  (eol)  {        [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P8_Replace_Mix]
[PATCH]  c  =  in.read  (  )  ;	[BUG]  [BUGGY]  c  =  in.readAgain(  )  ;c  =  in.read(  )  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  }  }    if  (isEndOfFile(lastChar)  ||  (!isDelimiter(lastChar)  &&  isEndOfFile(c)))  {  tkn.type  =  EOF;    return  tkn;  }    while  (tkn.type  ==  INVALID)  {    if  (surroundingSpacesIgnored)  {  while  (isWhitespace(c)  &&  !eol)  {  [BUGGY]  c  =  in.readAgain(  )  ;c  =  in.read(  )  ;  [BUGGY]  eol  =  isEndOfLine(c);  }  }    if  (isCommentStart(c))  {    in.readLine();  tkn  =  nextToken(tkn.reset());  }  else  if  (isDelimiter(c))  {    tkn.type  =  TOKEN;  }  else  if  (eol)  {        [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P11_Insert_Donor_Statement]
[PATCH]  eol  =  isEndOfLine  (  c  )  ;	[BUG]  [BUGGY]  eol  =  isEndOfLine(  lastChar)  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  }    if  (isEndOfFile(lastChar)  ||  (!isDelimiter(lastChar)  &&  isEndOfFile(c)))  {  tkn.type  =  EOF;    return  tkn;  }    while  (tkn.type  ==  INVALID)  {    if  (surroundingSpacesIgnored)  {  while  (isWhitespace(c)  &&  !eol)  {  c  =  in.read();  [BUGGY]  eol  =  isEndOfLine(  lastChar)  ;  [BUGGY]  }  }    if  (isCommentStart(c))  {    in.readLine();  tkn  =  nextToken(tkn.reset());  }  else  if  (isDelimiter(c))  {    tkn.type  =  TOKEN;  }  else  if  (eol)  {      tkn.type  =  EORECORD;    [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P5_Replace_Variable]
[PATCH]  eol  =  isEndOfLine  (  c  )  ;	[BUG]  [BUGGY]  eol  =  isEndOfFile(  c)  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  }    if  (isEndOfFile(lastChar)  ||  (!isDelimiter(lastChar)  &&  isEndOfFile(c)))  {  tkn.type  =  EOF;    return  tkn;  }    while  (tkn.type  ==  INVALID)  {    if  (surroundingSpacesIgnored)  {  while  (isWhitespace(c)  &&  !eol)  {  c  =  in.read();  [BUGGY]  eol  =  isEndOfFile(  c)  ;  [BUGGY]  }  }    if  (isCommentStart(c))  {    in.readLine();  tkn  =  nextToken(tkn.reset());  }  else  if  (isDelimiter(c))  {    tkn.type  =  TOKEN;  }  else  if  (eol)  {      tkn.type  =  EORECORD;    [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P7_Replace_Invocation]
[PATCH]  eol  =  isEndOfLine  (  c  )  ;	[BUG]  [BUGGY]  c  =  in.readAgain(  )  ;eol  =  isEndOfLine(  c)  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  }    if  (isEndOfFile(lastChar)  ||  (!isDelimiter(lastChar)  &&  isEndOfFile(c)))  {  tkn.type  =  EOF;    return  tkn;  }    while  (tkn.type  ==  INVALID)  {    if  (surroundingSpacesIgnored)  {  while  (isWhitespace(c)  &&  !eol)  {  c  =  in.read();  [BUGGY]  c  =  in.readAgain(  )  ;eol  =  isEndOfLine(  c)  ;  [BUGGY]  }  }    if  (isCommentStart(c))  {    in.readLine();  tkn  =  nextToken(tkn.reset());  }  else  if  (isDelimiter(c))  {    tkn.type  =  TOKEN;  }  else  if  (eol)  {      tkn.type  =  EORECORD;    [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P11_Insert_Donor_Statement]
[PATCH]  c  =  in.read  (  )  ;	[BUG]  [BUGGY]  [FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  }  }    if  (isEndOfFile(lastChar)  ||  (!isDelimiter(lastChar)  &&  isEndOfFile(c)))  {  tkn.type  =  EOF;    return  tkn;  }    while  (tkn.type  ==  INVALID)  {    if  (surroundingSpacesIgnored)  {  while  (isWhitespace(c)  &&  !eol)  {  [BUGGY]  [BUGGY]    eol  =  isEndOfLine(c);  }  }    if  (isCommentStart(c))  {    in.readLine();  tkn  =  nextToken(tkn.reset());  }  else  if  (isDelimiter(c))  {    tkn.type  =  TOKEN;  }  else  if  (eol)  {      [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P14_Delete_Statement]
[PATCH]  c  =  in.read  (  )  ;	[BUG]  [BUGGY]  int  lastChar  =  in.readAgain(  )  ;c  =  in.read(  )  ;[CE]  variable  lastChar  is  already  defined  in  method  nextToken(Token)  [CONTEXT]  }  }    if  (isEndOfFile(lastChar)  ||  (!isDelimiter(lastChar)  &&  isEndOfFile(c)))  {  tkn.type  =  EOF;    return  tkn;  }    while  (tkn.type  ==  INVALID)  {    if  (surroundingSpacesIgnored)  {  while  (isWhitespace(c)  &&  !eol)  {  [BUGGY]  int  lastChar  =  in.readAgain(  )  ;c  =  in.read(  )  ;  [BUGGY]  eol  =  isEndOfLine(c);  }  }    if  (isCommentStart(c))  {    in.readLine();  tkn  =  nextToken(tkn.reset());  }  else  if  (isDelimiter(c))  {    tkn.type  =  TOKEN;  }  else  if  (eol)  {        [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P11_Insert_Donor_Statement]
[PATCH]  c  =  in.read  (  )  ;	[BUG]  [BUGGY]  int  c  =  in.read(  )  ;c  =  in.read(  )  ;[CE]  variable  c  is  already  defined  in  method  nextToken(Token)  [CONTEXT]  }  }    if  (isEndOfFile(lastChar)  ||  (!isDelimiter(lastChar)  &&  isEndOfFile(c)))  {  tkn.type  =  EOF;    return  tkn;  }    while  (tkn.type  ==  INVALID)  {    if  (surroundingSpacesIgnored)  {  while  (isWhitespace(c)  &&  !eol)  {  [BUGGY]  int  c  =  in.read(  )  ;c  =  in.read(  )  ;  [BUGGY]  eol  =  isEndOfLine(c);  }  }    if  (isCommentStart(c))  {    in.readLine();  tkn  =  nextToken(tkn.reset());  }  else  if  (isDelimiter(c))  {    tkn.type  =  TOKEN;  }  else  if  (eol)  {        [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P11_Insert_Donor_Statement]
[PATCH]  c  =  in.read  (  )  ;	[BUG]  [BUGGY]  in.readLine(  )  ;c  =  in.read(  )  ;[FE]  Token  type  expected:<TOKEN>  but  was:<EOF>  testNextToken1  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  }  }    if  (isEndOfFile(lastChar)  ||  (!isDelimiter(lastChar)  &&  isEndOfFile(c)))  {  tkn.type  =  EOF;    return  tkn;  }    while  (tkn.type  ==  INVALID)  {    if  (surroundingSpacesIgnored)  {  while  (isWhitespace(c)  &&  !eol)  {  [BUGGY]  in.readLine(  )  ;c  =  in.read(  )  ;  [BUGGY]  eol  =  isEndOfLine(c);  }  }    if  (isCommentStart(c))  {    in.readLine();  tkn  =  nextToken(tkn.reset());  }  else  if  (isDelimiter(c))  {    tkn.type  =  TOKEN;  }  else  if  (eol)  {        [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P11_Insert_Donor_Statement]
[PATCH]  eol  =  isEndOfLine  (  c  )  ;	[BUG]  [BUGGY]  [FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  }    if  (isEndOfFile(lastChar)  ||  (!isDelimiter(lastChar)  &&  isEndOfFile(c)))  {  tkn.type  =  EOF;    return  tkn;  }    while  (tkn.type  ==  INVALID)  {    if  (surroundingSpacesIgnored)  {  while  (isWhitespace(c)  &&  !eol)  {  c  =  in.read();  [BUGGY]  [BUGGY]    }  }    if  (isCommentStart(c))  {    in.readLine();  tkn  =  nextToken(tkn.reset());  }  else  if  (isDelimiter(c))  {    tkn.type  =  TOKEN;  }  else  if  (eol)  {        [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P14_Delete_Statement]
[PATCH]  if  (  surroundingSpacesIgnored  )  {  while  (  isWhitespace  (  c  )  &&  !eol  )  {  c  =  in.read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  }	[BUG]  [BUGGY]  while((isWhitespace(c))  &&(!eol))  {    c  =  in.read();    eol  =  isEndOfLine(c);}  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  return  tkn;  }  }  }    if  (isEndOfFile(lastChar)  ||  (!isDelimiter(lastChar)  &&  isEndOfFile(c)))  {  tkn.type  =  EOF;    return  tkn;  }    while  (tkn.type  ==  INVALID)  {    [BUGGY]  while((isWhitespace(c))  &&(!eol))  {    c  =  in.read();    eol  =  isEndOfLine(c);}  ;  [BUGGY]    while  ((isWhitespace(c))  &&  (!eol))  {c  =  in.read();eol  =  isEndOfLine(c);}  ;    }    if  (isCommentStart(c))  {    in.readLine();  tkn  =  nextToken(tkn.reset());  }  else  if  (isDelimiter(c))  {    tkn.type  =  TOKEN;    [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P15_Unwrap_Block]
[PATCH]  if  (  surroundingSpacesIgnored  )  {  while  (  isWhitespace  (  c  )  &&  !eol  )  {  c  =  in.read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  }	[BUG]  [BUGGY]  [FE]  Token  content  expected:<[]hijk>  but  was:<[  ]hijk>  testNextToken1  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  return  tkn;  }  }  }    if  (isEndOfFile(lastChar)  ||  (!isDelimiter(lastChar)  &&  isEndOfFile(c)))  {  tkn.type  =  EOF;    return  tkn;  }    while  (tkn.type  ==  INVALID)  {    [BUGGY]  [BUGGY]        }    if  (isCommentStart(c))  {    in.readLine();  tkn  =  nextToken(tkn.reset());  }  else  if  (isDelimiter(c))  {    tkn.type  =  TOKEN;    [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P16_Remove_Block]
[PATCH]  c  =  in.read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;	[BUG]  [BUGGY]  [FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  }  }    if  (isEndOfFile(lastChar)  ||  (!isDelimiter(lastChar)  &&  isEndOfFile(c)))  {  tkn.type  =  EOF;    return  tkn;  }    while  (tkn.type  ==  INVALID)  {    if  (surroundingSpacesIgnored)  {  while  (isWhitespace(c)  &&  !eol)  {  [BUGGY]  [BUGGY]    }  }    if  (isCommentStart(c))  {    in.readLine();  tkn  =  nextToken(tkn.reset());  }  else  if  (isDelimiter(c))  {    tkn.type  =  TOKEN;  }  else  if  (eol)  {      [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P14_Delete_Statement]
[PATCH]  eol  =  isEndOfLine  (  c  )  ;	[BUG]  [BUGGY]  eol  =  isEndOfFile(  lastChar)  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  }    if  (isEndOfFile(lastChar)  ||  (!isDelimiter(lastChar)  &&  isEndOfFile(c)))  {  tkn.type  =  EOF;    return  tkn;  }    while  (tkn.type  ==  INVALID)  {    if  (surroundingSpacesIgnored)  {  while  (isWhitespace(c)  &&  !eol)  {  c  =  in.read();  [BUGGY]  eol  =  isEndOfFile(  lastChar)  ;  [BUGGY]  }  }    if  (isCommentStart(c))  {    in.readLine();  tkn  =  nextToken(tkn.reset());  }  else  if  (isDelimiter(c))  {    tkn.type  =  TOKEN;  }  else  if  (eol)  {      tkn.type  =  EORECORD;    [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P8_Replace_Mix]
[PATCH]  c  =  in.read  (  )  ;	[BUG]  [BUGGY]  c  =  null  ;[CE]  incompatible  types  [CONTEXT]  }  }    if  (isEndOfFile(lastChar)  ||  (!isDelimiter(lastChar)  &&  isEndOfFile(c)))  {  tkn.type  =  EOF;    return  tkn;  }    while  (tkn.type  ==  INVALID)  {    if  (surroundingSpacesIgnored)  {  while  (isWhitespace(c)  &&  !eol)  {  [BUGGY]  c  =  null  ;  [BUGGY]  eol  =  isEndOfLine(c);  }  }    if  (isCommentStart(c))  {    in.readLine();  tkn  =  nextToken(tkn.reset());  }  else  if  (isDelimiter(c))  {    tkn.type  =  TOKEN;  }  else  if  (eol)  {        [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P8_Replace_Mix]
[PATCH]  while  (  isWhitespace  (  c  )  &&  !eol  )  {  c  =  in.read  (  )  ;	[BUG]  [BUGGY]  [FE]  [CONTEXT]  }  }  }    if  (isEndOfFile(lastChar)  ||  (!isDelimiter(lastChar)  &&  isEndOfFile(c)))  {  tkn.type  =  EOF;    return  tkn;  }    while  (tkn.type  ==  INVALID)  {    if  (surroundingSpacesIgnored)  {  [BUGGY]  [BUGGY]    eol  =  isEndOfLine(c);  }  }    if  (isCommentStart(c))  {    in.readLine();  tkn  =  nextToken(tkn.reset());  }  else  if  (isDelimiter(c))  {    tkn.type  =  TOKEN;  }  else  if  (eol)  {    [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P14_Delete_Statement]
[PATCH]  if  (  isCommentStart  (  c  )  )  {	[BUG]  [BUGGY]  if  (  isCommentStart(  lastChar)  )  {[FE]  Token  content  expected:<[]>  but  was:<[#foo]>  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]    return  tkn;  }    while  (tkn.type  ==  INVALID)  {    if  (surroundingSpacesIgnored)  {  while  (isWhitespace(c)  &&  !eol)  {  c  =  in.read();  eol  =  isEndOfLine(c);  }  }    [BUGGY]  if  (  isCommentStart(  lastChar)  )  {  [BUGGY]    in.readLine();  tkn  =  nextToken(tkn.reset());  }  else  if  (isDelimiter(c))  {    tkn.type  =  TOKEN;  }  else  if  (eol)  {      tkn.type  =  EORECORD;  }  else  if  (isEncapsulator(c))  {    encapsulatedTokenLexer(tkn,  c);  }  else  if  (isEndOfFile(c))  {      [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P5_Replace_Variable]
[PATCH]  if  (  isCommentStart  (  c  )  )  {	[BUG]  [BUGGY]  if  (  isWhitespace(  c)  )  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]    return  tkn;  }    while  (tkn.type  ==  INVALID)  {    if  (surroundingSpacesIgnored)  {  while  (isWhitespace(c)  &&  !eol)  {  c  =  in.read();  eol  =  isEndOfLine(c);  }  }    [BUGGY]  if  (  isWhitespace(  c)  )  {  [BUGGY]    in.readLine();  tkn  =  nextToken(tkn.reset());  }  else  if  (isDelimiter(c))  {    tkn.type  =  TOKEN;  }  else  if  (eol)  {      tkn.type  =  EORECORD;  }  else  if  (isEncapsulator(c))  {    encapsulatedTokenLexer(tkn,  c);  }  else  if  (isEndOfFile(c))  {      [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P7_Replace_Invocation]
[PATCH]  if  (  isCommentStart  (  c  )  )  {	[BUG]  [BUGGY]  if  (  isEscape(  c)  )  {[FE]  Token  content  expected:<[]>  but  was:<[#foo]>  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]    return  tkn;  }    while  (tkn.type  ==  INVALID)  {    if  (surroundingSpacesIgnored)  {  while  (isWhitespace(c)  &&  !eol)  {  c  =  in.read();  eol  =  isEndOfLine(c);  }  }    [BUGGY]  if  (  isEscape(  c)  )  {  [BUGGY]    in.readLine();  tkn  =  nextToken(tkn.reset());  }  else  if  (isDelimiter(c))  {    tkn.type  =  TOKEN;  }  else  if  (eol)  {      tkn.type  =  EORECORD;  }  else  if  (isEncapsulator(c))  {    encapsulatedTokenLexer(tkn,  c);  }  else  if  (isEndOfFile(c))  {      [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P9_Replace_Statement]
[PATCH]  if  (  isCommentStart  (  c  )  )  {	[BUG]  [BUGGY]  if  (  isDelimiter(  c)  )  {[FE]  null  testNextToken1  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]    return  tkn;  }    while  (tkn.type  ==  INVALID)  {    if  (surroundingSpacesIgnored)  {  while  (isWhitespace(c)  &&  !eol)  {  c  =  in.read();  eol  =  isEndOfLine(c);  }  }    [BUGGY]  if  (  isDelimiter(  c)  )  {  [BUGGY]    in.readLine();  tkn  =  nextToken(tkn.reset());  }  else  if  (isDelimiter(c))  {    tkn.type  =  TOKEN;  }  else  if  (eol)  {      tkn.type  =  EORECORD;  }  else  if  (isEncapsulator(c))  {    encapsulatedTokenLexer(tkn,  c);  }  else  if  (isEndOfFile(c))  {      [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P9_Replace_Statement]
[PATCH]  if  (  isCommentStart  (  c  )  )  {	[BUG]  [BUGGY]  if  (  isEndOfLine(  c)  )  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]    return  tkn;  }    while  (tkn.type  ==  INVALID)  {    if  (surroundingSpacesIgnored)  {  while  (isWhitespace(c)  &&  !eol)  {  c  =  in.read();  eol  =  isEndOfLine(c);  }  }    [BUGGY]  if  (  isEndOfLine(  c)  )  {  [BUGGY]    in.readLine();  tkn  =  nextToken(tkn.reset());  }  else  if  (isDelimiter(c))  {    tkn.type  =  TOKEN;  }  else  if  (eol)  {      tkn.type  =  EORECORD;  }  else  if  (isEncapsulator(c))  {    encapsulatedTokenLexer(tkn,  c);  }  else  if  (isEndOfFile(c))  {      [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P9_Replace_Statement]
[PATCH]  if  (  isCommentStart  (  c  )  )  {	[BUG]  [BUGGY]  if  (  isEndOfFile(  c)  )  {[FE]  null  testNextToken1  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]    return  tkn;  }    while  (tkn.type  ==  INVALID)  {    if  (surroundingSpacesIgnored)  {  while  (isWhitespace(c)  &&  !eol)  {  c  =  in.read();  eol  =  isEndOfLine(c);  }  }    [BUGGY]  if  (  isEndOfFile(  c)  )  {  [BUGGY]    in.readLine();  tkn  =  nextToken(tkn.reset());  }  else  if  (isDelimiter(c))  {    tkn.type  =  TOKEN;  }  else  if  (eol)  {      tkn.type  =  EORECORD;  }  else  if  (isEncapsulator(c))  {    encapsulatedTokenLexer(tkn,  c);  }  else  if  (isEndOfFile(c))  {      [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P9_Replace_Statement]
[PATCH]  }  else  if  (  isDelimiter  (  c  )  )  {	[BUG]  [BUGGY]  }  else  if  (  isDelimiter(  lastChar)  )  {[FE]  Token  content  expected:<[def]>  but  was:<[]>  testNextToken1  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]    while  (tkn.type  ==  INVALID)  {    if  (surroundingSpacesIgnored)  {  while  (isWhitespace(c)  &&  !eol)  {  c  =  in.read();  eol  =  isEndOfLine(c);  }  }    if  (isCommentStart(c))  {    in.readLine();  tkn  =  nextToken(tkn.reset());  [BUGGY]  }  else  if  (  isDelimiter(  lastChar)  )  {  [BUGGY]    tkn.type  =  TOKEN;  }  else  if  (eol)  {      tkn.type  =  EORECORD;  }  else  if  (isEncapsulator(c))  {    encapsulatedTokenLexer(tkn,  c);  }  else  if  (isEndOfFile(c))  {      tkn.type  =  EOF;  tkn.isReady  =  true;  //  there  is  data  at  EOF  }  else  {    [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P5_Replace_Variable]
[PATCH]  }  else  if  (  isDelimiter  (  c  )  )  {	[BUG]  [BUGGY]  }  else  {[CE]  'else'  without  'if'  [CONTEXT]    while  (tkn.type  ==  INVALID)  {    if  (surroundingSpacesIgnored)  {  while  (isWhitespace(c)  &&  !eol)  {  c  =  in.read();  eol  =  isEndOfLine(c);  }  }    if  (isCommentStart(c))  {    in.readLine();  tkn  =  nextToken(tkn.reset());  [BUGGY]  }  else  {  [BUGGY]    tkn.type  =  TOKEN;  }  else  if  (eol)  {      tkn.type  =  EORECORD;  }  else  if  (isEncapsulator(c))  {    encapsulatedTokenLexer(tkn,  c);  }  else  if  (isEndOfFile(c))  {      tkn.type  =  EOF;  tkn.isReady  =  true;  //  there  is  data  at  EOF  }  else  {    [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P6_Replace_Expression]
[PATCH]  }  else  if  (  isDelimiter  (  c  )  )  {	[BUG]  [BUGGY]  }  else  if  (  isEscape(  c)  )  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]    while  (tkn.type  ==  INVALID)  {    if  (surroundingSpacesIgnored)  {  while  (isWhitespace(c)  &&  !eol)  {  c  =  in.read();  eol  =  isEndOfLine(c);  }  }    if  (isCommentStart(c))  {    in.readLine();  tkn  =  nextToken(tkn.reset());  [BUGGY]  }  else  if  (  isEscape(  c)  )  {  [BUGGY]    tkn.type  =  TOKEN;  }  else  if  (eol)  {      tkn.type  =  EORECORD;  }  else  if  (isEncapsulator(c))  {    encapsulatedTokenLexer(tkn,  c);  }  else  if  (isEndOfFile(c))  {      tkn.type  =  EOF;  tkn.isReady  =  true;  //  there  is  data  at  EOF  }  else  {    [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P7_Replace_Invocation]
[PATCH]  }  else  if  (  isDelimiter  (  c  )  )  {	[BUG]  [BUGGY]  }  else  if  (  isEndOfFile(  c)  )  {[FE]  Token  type  expected:<EOF>  but  was:<TOKEN>  testNextToken1  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]    while  (tkn.type  ==  INVALID)  {    if  (surroundingSpacesIgnored)  {  while  (isWhitespace(c)  &&  !eol)  {  c  =  in.read();  eol  =  isEndOfLine(c);  }  }    if  (isCommentStart(c))  {    in.readLine();  tkn  =  nextToken(tkn.reset());  [BUGGY]  }  else  if  (  isEndOfFile(  c)  )  {  [BUGGY]    tkn.type  =  TOKEN;  }  else  if  (eol)  {      tkn.type  =  EORECORD;  }  else  if  (isEncapsulator(c))  {    encapsulatedTokenLexer(tkn,  c);  }  else  if  (isEndOfFile(c))  {      tkn.type  =  EOF;  tkn.isReady  =  true;  //  there  is  data  at  EOF  }  else  {    [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P9_Replace_Statement]
[PATCH]  }  else  if  (  eol  )  {	[BUG]  [BUGGY]  }  else  {[CE]  'else'  without  'if'  [CONTEXT]  if  (surroundingSpacesIgnored)  {  while  (isWhitespace(c)  &&  !eol)  {  c  =  in.read();  eol  =  isEndOfLine(c);  }  }    if  (isCommentStart(c))  {    in.readLine();  tkn  =  nextToken(tkn.reset());  }  else  if  (isDelimiter(c))  {    tkn.type  =  TOKEN;  [BUGGY]  }  else  {  [BUGGY]      tkn.type  =  EORECORD;  }  else  if  (isEncapsulator(c))  {    encapsulatedTokenLexer(tkn,  c);  }  else  if  (isEndOfFile(c))  {      tkn.type  =  EOF;  tkn.isReady  =  true;  //  there  is  data  at  EOF  }  else  {      simpleTokenLexer(tkn,  c);    [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P6_Replace_Expression]
[PATCH]  }  else  if  (  isEncapsulator  (  c  )  )  {	[BUG]  [BUGGY]  }  else  if  (  isEncapsulator(  lastChar)  )  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  }  }    if  (isCommentStart(c))  {    in.readLine();  tkn  =  nextToken(tkn.reset());  }  else  if  (isDelimiter(c))  {    tkn.type  =  TOKEN;  }  else  if  (eol)  {      tkn.type  =  EORECORD;  [BUGGY]  }  else  if  (  isEncapsulator(  lastChar)  )  {  [BUGGY]    encapsulatedTokenLexer(tkn,  c);  }  else  if  (isEndOfFile(c))  {      tkn.type  =  EOF;  tkn.isReady  =  true;  //  there  is  data  at  EOF  }  else  {      simpleTokenLexer(tkn,  c);  }  }  return  tkn;  }    [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P5_Replace_Variable]
[PATCH]  }  else  if  (  isEncapsulator  (  c  )  )  {	[BUG]  [BUGGY]  }  else  {[CE]  'else'  without  'if'  [CONTEXT]  }  }    if  (isCommentStart(c))  {    in.readLine();  tkn  =  nextToken(tkn.reset());  }  else  if  (isDelimiter(c))  {    tkn.type  =  TOKEN;  }  else  if  (eol)  {      tkn.type  =  EORECORD;  [BUGGY]  }  else  {  [BUGGY]    encapsulatedTokenLexer(tkn,  c);  }  else  if  (isEndOfFile(c))  {      tkn.type  =  EOF;  tkn.isReady  =  true;  //  there  is  data  at  EOF  }  else  {      simpleTokenLexer(tkn,  c);  }  }  return  tkn;  }    [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P6_Replace_Expression]
[PATCH]  }  else  if  (  isEncapsulator  (  c  )  )  {	[BUG]  [BUGGY]  }  if  (  isEncapsulator(  lastChar)  )  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  }  }    if  (isCommentStart(c))  {    in.readLine();  tkn  =  nextToken(tkn.reset());  }  else  if  (isDelimiter(c))  {    tkn.type  =  TOKEN;  }  else  if  (eol)  {      tkn.type  =  EORECORD;  [BUGGY]  }  if  (  isEncapsulator(  lastChar)  )  {  [BUGGY]    encapsulatedTokenLexer(tkn,  c);  }  else  if  (isEndOfFile(c))  {      tkn.type  =  EOF;  tkn.isReady  =  true;  //  there  is  data  at  EOF  }  else  {      simpleTokenLexer(tkn,  c);  }  }  return  tkn;  }    [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P8_Replace_Mix]
[PATCH]  }  else  if  (  isEncapsulator  (  c  )  )  {	[BUG]  [BUGGY]  }  else  if  (  isDelimiter(  c)  )  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  }  }    if  (isCommentStart(c))  {    in.readLine();  tkn  =  nextToken(tkn.reset());  }  else  if  (isDelimiter(c))  {    tkn.type  =  TOKEN;  }  else  if  (eol)  {      tkn.type  =  EORECORD;  [BUGGY]  }  else  if  (  isDelimiter(  c)  )  {  [BUGGY]    encapsulatedTokenLexer(tkn,  c);  }  else  if  (isEndOfFile(c))  {      tkn.type  =  EOF;  tkn.isReady  =  true;  //  there  is  data  at  EOF  }  else  {      simpleTokenLexer(tkn,  c);  }  }  return  tkn;  }    [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P9_Replace_Statement]
[PATCH]  }  else  if  (  isEncapsulator  (  c  )  )  {	[BUG]  [BUGGY]  }  else  if  (  isEndOfFile(  c)  )  {[FE]  (startline  0)  EOF  reached  before  encapsulated  token  finished  testNextToken1  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  }  }    if  (isCommentStart(c))  {    in.readLine();  tkn  =  nextToken(tkn.reset());  }  else  if  (isDelimiter(c))  {    tkn.type  =  TOKEN;  }  else  if  (eol)  {      tkn.type  =  EORECORD;  [BUGGY]  }  else  if  (  isEndOfFile(  c)  )  {  [BUGGY]    encapsulatedTokenLexer(tkn,  c);  }  else  if  (isEndOfFile(c))  {      tkn.type  =  EOF;  tkn.isReady  =  true;  //  there  is  data  at  EOF  }  else  {      simpleTokenLexer(tkn,  c);  }  }  return  tkn;  }    [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P9_Replace_Statement]
[PATCH]  }  else  if  (  isEncapsulator  (  c  )  )  {	[BUG]  [BUGGY]  }  else  if  (  isEndOfLine(  c)  )  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  }  }    if  (isCommentStart(c))  {    in.readLine();  tkn  =  nextToken(tkn.reset());  }  else  if  (isDelimiter(c))  {    tkn.type  =  TOKEN;  }  else  if  (eol)  {      tkn.type  =  EORECORD;  [BUGGY]  }  else  if  (  isEndOfLine(  c)  )  {  [BUGGY]    encapsulatedTokenLexer(tkn,  c);  }  else  if  (isEndOfFile(c))  {      tkn.type  =  EOF;  tkn.isReady  =  true;  //  there  is  data  at  EOF  }  else  {      simpleTokenLexer(tkn,  c);  }  }  return  tkn;  }    [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P9_Replace_Statement]
[PATCH]  }  else  if  (  isEncapsulator  (  c  )  )  {	[BUG]  [BUGGY]  }  else  if  (  isEscape(  c)  )  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  }  }    if  (isCommentStart(c))  {    in.readLine();  tkn  =  nextToken(tkn.reset());  }  else  if  (isDelimiter(c))  {    tkn.type  =  TOKEN;  }  else  if  (eol)  {      tkn.type  =  EORECORD;  [BUGGY]  }  else  if  (  isEscape(  c)  )  {  [BUGGY]    encapsulatedTokenLexer(tkn,  c);  }  else  if  (isEndOfFile(c))  {      tkn.type  =  EOF;  tkn.isReady  =  true;  //  there  is  data  at  EOF  }  else  {      simpleTokenLexer(tkn,  c);  }  }  return  tkn;  }    [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P9_Replace_Statement]
[PATCH]  }  else  if  (  isEncapsulator  (  c  )  )  {	[BUG]  [BUGGY]  }  else  if  (  !isWhitespace(  c)  )  {[FE]  (startline  0)  EOF  reached  before  encapsulated  token  finished  testNextToken1  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  }  }    if  (isCommentStart(c))  {    in.readLine();  tkn  =  nextToken(tkn.reset());  }  else  if  (isDelimiter(c))  {    tkn.type  =  TOKEN;  }  else  if  (eol)  {      tkn.type  =  EORECORD;  [BUGGY]  }  else  if  (  !isWhitespace(  c)  )  {  [BUGGY]    encapsulatedTokenLexer(tkn,  c);  }  else  if  (isEndOfFile(c))  {      tkn.type  =  EOF;  tkn.isReady  =  true;  //  there  is  data  at  EOF  }  else  {      simpleTokenLexer(tkn,  c);  }  }  return  tkn;  }    [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P9_Replace_Statement]
[PATCH]  }  else  if  (  isEndOfFile  (  c  )  )  {	[BUG]  [BUGGY]  }  else  if  (  isEndOfFile(  lastChar)  )  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]    if  (isCommentStart(c))  {    in.readLine();  tkn  =  nextToken(tkn.reset());  }  else  if  (isDelimiter(c))  {    tkn.type  =  TOKEN;  }  else  if  (eol)  {      tkn.type  =  EORECORD;  }  else  if  (isEncapsulator(c))  {    encapsulatedTokenLexer(tkn,  c);  [BUGGY]  }  else  if  (  isEndOfFile(  lastChar)  )  {  [BUGGY]      tkn.type  =  EOF;  tkn.isReady  =  true;  //  there  is  data  at  EOF  }  else  {      simpleTokenLexer(tkn,  c);  }  }  return  tkn;  }          [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P5_Replace_Variable]
[PATCH]  }  else  if  (  isEndOfFile  (  c  )  )  {	[BUG]  [BUGGY]  }  else  {[CE]  'else'  without  'if'  [CONTEXT]    if  (isCommentStart(c))  {    in.readLine();  tkn  =  nextToken(tkn.reset());  }  else  if  (isDelimiter(c))  {    tkn.type  =  TOKEN;  }  else  if  (eol)  {      tkn.type  =  EORECORD;  }  else  if  (isEncapsulator(c))  {    encapsulatedTokenLexer(tkn,  c);  [BUGGY]  }  else  {  [BUGGY]      tkn.type  =  EOF;  tkn.isReady  =  true;  //  there  is  data  at  EOF  }  else  {      simpleTokenLexer(tkn,  c);  }  }  return  tkn;  }          [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P6_Replace_Expression]
[PATCH]  }  else  if  (  isEndOfFile  (  c  )  )  {	[BUG]  [BUGGY]  }  else  if  (  isEndOfLine(  c)  )  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]    if  (isCommentStart(c))  {    in.readLine();  tkn  =  nextToken(tkn.reset());  }  else  if  (isDelimiter(c))  {    tkn.type  =  TOKEN;  }  else  if  (eol)  {      tkn.type  =  EORECORD;  }  else  if  (isEncapsulator(c))  {    encapsulatedTokenLexer(tkn,  c);  [BUGGY]  }  else  if  (  isEndOfLine(  c)  )  {  [BUGGY]      tkn.type  =  EOF;  tkn.isReady  =  true;  //  there  is  data  at  EOF  }  else  {      simpleTokenLexer(tkn,  c);  }  }  return  tkn;  }          [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P7_Replace_Invocation]
[PATCH]  }  else  if  (  isEndOfFile  (  c  )  )  {	[BUG]  [BUGGY]  }  else  if  (  isDelimiter(  c)  )  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]    if  (isCommentStart(c))  {    in.readLine();  tkn  =  nextToken(tkn.reset());  }  else  if  (isDelimiter(c))  {    tkn.type  =  TOKEN;  }  else  if  (eol)  {      tkn.type  =  EORECORD;  }  else  if  (isEncapsulator(c))  {    encapsulatedTokenLexer(tkn,  c);  [BUGGY]  }  else  if  (  isDelimiter(  c)  )  {  [BUGGY]      tkn.type  =  EOF;  tkn.isReady  =  true;  //  there  is  data  at  EOF  }  else  {      simpleTokenLexer(tkn,  c);  }  }  return  tkn;  }          [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P9_Replace_Statement]
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  isEndOfFile(  c)  )  {      tkn.type  =  EOF;      return  tkn;  }[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]    if  (isCommentStart(c))  {    in.readLine();  tkn  =  nextToken(tkn.reset());  }  else  if  (isDelimiter(c))  {    tkn.type  =  TOKEN;  }  else  if  (eol)  {      tkn.type  =  EORECORD;  }  else  if  (isEncapsulator(c))  {    encapsulatedTokenLexer(tkn,  c);  [BUGGY]  if  (  isEndOfFile(  c)  )  {      tkn.type  =  EOF;      return  tkn;  }  [BUGGY]      tkn.type  =  EOF;  tkn.isReady  =  true;  //  there  is  data  at  EOF  }  else  {      simpleTokenLexer(tkn,  c);  }  }  return  tkn;  }          [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P13_Insert_Block]
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  isEncapsulator(  c)  )  {      encapsulatedTokenLexer(  tkn,  c)  ;  }else      if  (  isEndOfFile(  c)  )  {          tkn.type  =  EOF;          tkn.isReady  =  true;      }else  {          simpleTokenLexer(  tkn,  c)  ;      }[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]    if  (isCommentStart(c))  {    in.readLine();  tkn  =  nextToken(tkn.reset());  }  else  if  (isDelimiter(c))  {    tkn.type  =  TOKEN;  }  else  if  (eol)  {      tkn.type  =  EORECORD;  }  else  if  (isEncapsulator(c))  {    encapsulatedTokenLexer(tkn,  c);  [BUGGY]  if  (  isEncapsulator(  c)  )  {      encapsulatedTokenLexer(  tkn,  c)  ;  }else      if  (  isEndOfFile(  c)  )  {          tkn.type  =  EOF;          tkn.isReady  =  true;      }else  {          simpleTokenLexer(  tkn,  c)  ;      }  [BUGGY]      tkn.type  =  EOF;  tkn.isReady  =  true;  //  there  is  data  at  EOF  }  else  {      simpleTokenLexer(tkn,  c);  }  }  return  tkn;  }          [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P13_Insert_Block]
[PATCH]  simpleTokenLexer  (  tkn,  c  )  ;	[BUG]  [BUGGY]  simpleTokenLexer(  tkn,  lastChar)  ;[FE]  Token  content  expected:<[a]bc>  but  was:<[  testNextToken1  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  }  else  if  (isEndOfFile(c))  {      tkn.type  =  EOF;  tkn.isReady  =  true;  //  there  is  data  at  EOF  }  else  {      [BUGGY]  simpleTokenLexer(  tkn,  lastChar)  ;  [BUGGY]  }    [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P5_Replace_Variable]
[PATCH]  simpleTokenLexer  (  tkn,  c  )  ;	[BUG]  [BUGGY]  simpleTokenLexer(  c)  ;[CE]  method  simpleTokenLexer  in  class  CSVLexer  cannot  be  applied  to  given  types;  [CONTEXT]  }  else  if  (isEndOfFile(c))  {      tkn.type  =  EOF;  tkn.isReady  =  true;  //  there  is  data  at  EOF  }  else  {      [BUGGY]  simpleTokenLexer(  c)  ;  [BUGGY]  }    [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P5_Replace_Variable]
[PATCH]  simpleTokenLexer  (  tkn,  c  )  ;	[BUG]  [BUGGY]  simpleTokenLexer(  tkn)  ;[CE]  method  simpleTokenLexer  in  class  CSVLexer  cannot  be  applied  to  given  types;  [CONTEXT]  }  else  if  (isEndOfFile(c))  {      tkn.type  =  EOF;  tkn.isReady  =  true;  //  there  is  data  at  EOF  }  else  {      [BUGGY]  simpleTokenLexer(  tkn)  ;  [BUGGY]  }    [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P5_Replace_Variable]
[PATCH]  simpleTokenLexer  (  tkn,  c  )  ;	[BUG]  [BUGGY]  simpleTokenLexer(  c,  tkn)  ;[CE]  method  simpleTokenLexer  in  class  CSVLexer  cannot  be  applied  to  given  types;  [CONTEXT]  }  else  if  (isEndOfFile(c))  {      tkn.type  =  EOF;  tkn.isReady  =  true;  //  there  is  data  at  EOF  }  else  {      [BUGGY]  simpleTokenLexer(  c,  tkn)  ;  [BUGGY]  }    [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P5_Replace_Variable]
[PATCH]  simpleTokenLexer  (  tkn,  c  )  ;	[BUG]  [BUGGY]  encapsulatedTokenLexer(  tkn,  c)  ;[FE]  (startline  0)  EOF  reached  before  encapsulated  token  finished  testNextToken1  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  }  else  if  (isEndOfFile(c))  {      tkn.type  =  EOF;  tkn.isReady  =  true;  //  there  is  data  at  EOF  }  else  {      [BUGGY]  encapsulatedTokenLexer(  tkn,  c)  ;  [BUGGY]  }    [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P7_Replace_Invocation]
[PATCH]  simpleTokenLexer  (  tkn,  c  )  ;	[BUG]  [BUGGY]  [FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  }  else  if  (isEndOfFile(c))  {      tkn.type  =  EOF;  tkn.isReady  =  true;  //  there  is  data  at  EOF  }  else  {      [BUGGY]  [BUGGY]      [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P14_Delete_Statement]
[PATCH]  simpleTokenLexer  (  tkn,  c  )  ;	[BUG]  [BUGGY]  encapsulatedTokenLexer(  tkn,  c)  ;simpleTokenLexer(  tkn,  c)  ;[FE]  (startline  0)  EOF  reached  before  encapsulated  token  finished  testNextToken1  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  }  else  if  (isEndOfFile(c))  {      tkn.type  =  EOF;  tkn.isReady  =  true;  //  there  is  data  at  EOF  }  else  {      [BUGGY]  encapsulatedTokenLexer(  tkn,  c)  ;simpleTokenLexer(  tkn,  c)  ;  [BUGGY]  }    [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P11_Insert_Donor_Statement]
[PATCH]  tkn.type  =  EOF;	[BUG]  [BUGGY]  tkn.type  =  tkn.type  ;[FE]  [CONTEXT]  in.readLine();  tkn  =  nextToken(tkn.reset());  }  else  if  (isDelimiter(c))  {    tkn.type  =  TOKEN;  }  else  if  (eol)  {      tkn.type  =  EORECORD;  }  else  if  (isEncapsulator(c))  {    encapsulatedTokenLexer(tkn,  c);  }  else  if  (isEndOfFile(c))  {      [BUGGY]  tkn.type  =  tkn.type  ;  [BUGGY]  tkn.isReady  =  true;  //  there  is  data  at  EOF  }  else  {      simpleTokenLexer(tkn,  c);  }  }  return  tkn;  }                [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P8_Replace_Mix]
[PATCH]  tkn.type  =  EOF;	[BUG]  [BUGGY]  tkn.type  =  TOKEN;tkn.type  =  EOF;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  in.readLine();  tkn  =  nextToken(tkn.reset());  }  else  if  (isDelimiter(c))  {    tkn.type  =  TOKEN;  }  else  if  (eol)  {      tkn.type  =  EORECORD;  }  else  if  (isEncapsulator(c))  {    encapsulatedTokenLexer(tkn,  c);  }  else  if  (isEndOfFile(c))  {      [BUGGY]  tkn.type  =  TOKEN;tkn.type  =  EOF;  [BUGGY]  tkn.isReady  =  true;  //  there  is  data  at  EOF  }  else  {      simpleTokenLexer(tkn,  c);  }  }  return  tkn;  }                [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P11_Insert_Donor_Statement]
[PATCH]  tkn.type  =  EOF;	[BUG]  [BUGGY]  tkn.type  =  EORECORD;tkn.type  =  EOF;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  in.readLine();  tkn  =  nextToken(tkn.reset());  }  else  if  (isDelimiter(c))  {    tkn.type  =  TOKEN;  }  else  if  (eol)  {      tkn.type  =  EORECORD;  }  else  if  (isEncapsulator(c))  {    encapsulatedTokenLexer(tkn,  c);  }  else  if  (isEndOfFile(c))  {      [BUGGY]  tkn.type  =  EORECORD;tkn.type  =  EOF;  [BUGGY]  tkn.isReady  =  true;  //  there  is  data  at  EOF  }  else  {      simpleTokenLexer(tkn,  c);  }  }  return  tkn;  }                [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P11_Insert_Donor_Statement]
[PATCH]  tkn.isReady  =  true;	[BUG]  [BUGGY]  tkn.isReady  =  false;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  tkn  =  nextToken(tkn.reset());  }  else  if  (isDelimiter(c))  {    tkn.type  =  TOKEN;  }  else  if  (eol)  {      tkn.type  =  EORECORD;  }  else  if  (isEncapsulator(c))  {    encapsulatedTokenLexer(tkn,  c);  }  else  if  (isEndOfFile(c))  {      tkn.type  =  EOF;  [BUGGY]  tkn.isReady  =  false;  [BUGGY]  }  else  {      simpleTokenLexer(tkn,  c);  }  }  return  tkn;  }                  [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P3_Replace_Literal]
[PATCH]  tkn.isReady  =  true;	[BUG]  [BUGGY]  tkn.type  =  TOKEN;tkn.isReady  =  true;[FE]  Token  type  expected:<EOF>  but  was:<TOKEN>  testNextToken1  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  tkn  =  nextToken(tkn.reset());  }  else  if  (isDelimiter(c))  {    tkn.type  =  TOKEN;  }  else  if  (eol)  {      tkn.type  =  EORECORD;  }  else  if  (isEncapsulator(c))  {    encapsulatedTokenLexer(tkn,  c);  }  else  if  (isEndOfFile(c))  {      tkn.type  =  EOF;  [BUGGY]  tkn.type  =  TOKEN;tkn.isReady  =  true;  [BUGGY]  }  else  {      simpleTokenLexer(tkn,  c);  }  }  return  tkn;  }                  [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P11_Insert_Donor_Statement]
[PATCH]  }  else  if  (  isEndOfFile  (  c  )  )  {	[BUG]  [BUGGY]  }  else  if  (  isEndOfLine(  lastChar)  )  {[FE]  Token  type  expected:<TOKEN>  but  was:<EOF>  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]    if  (isCommentStart(c))  {    in.readLine();  tkn  =  nextToken(tkn.reset());  }  else  if  (isDelimiter(c))  {    tkn.type  =  TOKEN;  }  else  if  (eol)  {      tkn.type  =  EORECORD;  }  else  if  (isEncapsulator(c))  {    encapsulatedTokenLexer(tkn,  c);  [BUGGY]  }  else  if  (  isEndOfLine(  lastChar)  )  {  [BUGGY]      tkn.type  =  EOF;  tkn.isReady  =  true;  //  there  is  data  at  EOF  }  else  {      simpleTokenLexer(tkn,  c);  }  }  return  tkn;  }          [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P8_Replace_Mix]
[PATCH]  simpleTokenLexer  (  tkn,  c  )  ;	[BUG]  [BUGGY]  simpleTokenLexer(  tkn,  lastChar)  ;[FE]  Token  content  expected:<[a]bc>  but  was:<[  testNextToken1  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  }  else  if  (eol)  {      tkn.type  =  EORECORD;  }  else  if  (isEncapsulator(c))  {    encapsulatedTokenLexer(tkn,  c);  }  else  if  (isEndOfFile(c))  {      tkn.type  =  EOF;  tkn.isReady  =  true;  //  there  is  data  at  EOF  }  else  {      [BUGGY]  simpleTokenLexer(  tkn,  lastChar)  ;  [BUGGY]  }  }  return  tkn;  }                          [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P5_Replace_Variable]
[PATCH]  simpleTokenLexer  (  tkn,  c  )  ;	[BUG]  [BUGGY]  simpleTokenLexer(  c)  ;[CE]  method  simpleTokenLexer  in  class  CSVLexer  cannot  be  applied  to  given  types;  [CONTEXT]  }  else  if  (eol)  {      tkn.type  =  EORECORD;  }  else  if  (isEncapsulator(c))  {    encapsulatedTokenLexer(tkn,  c);  }  else  if  (isEndOfFile(c))  {      tkn.type  =  EOF;  tkn.isReady  =  true;  //  there  is  data  at  EOF  }  else  {      [BUGGY]  simpleTokenLexer(  c)  ;  [BUGGY]  }  }  return  tkn;  }                          [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P5_Replace_Variable]
[PATCH]  simpleTokenLexer  (  tkn,  c  )  ;	[BUG]  [BUGGY]  simpleTokenLexer(  tkn)  ;[CE]  method  simpleTokenLexer  in  class  CSVLexer  cannot  be  applied  to  given  types;  [CONTEXT]  }  else  if  (eol)  {      tkn.type  =  EORECORD;  }  else  if  (isEncapsulator(c))  {    encapsulatedTokenLexer(tkn,  c);  }  else  if  (isEndOfFile(c))  {      tkn.type  =  EOF;  tkn.isReady  =  true;  //  there  is  data  at  EOF  }  else  {      [BUGGY]  simpleTokenLexer(  tkn)  ;  [BUGGY]  }  }  return  tkn;  }                          [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P5_Replace_Variable]
[PATCH]  simpleTokenLexer  (  tkn,  c  )  ;	[BUG]  [BUGGY]  simpleTokenLexer(  c,  tkn)  ;[CE]  method  simpleTokenLexer  in  class  CSVLexer  cannot  be  applied  to  given  types;  [CONTEXT]  }  else  if  (eol)  {      tkn.type  =  EORECORD;  }  else  if  (isEncapsulator(c))  {    encapsulatedTokenLexer(tkn,  c);  }  else  if  (isEndOfFile(c))  {      tkn.type  =  EOF;  tkn.isReady  =  true;  //  there  is  data  at  EOF  }  else  {      [BUGGY]  simpleTokenLexer(  c,  tkn)  ;  [BUGGY]  }  }  return  tkn;  }                          [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P5_Replace_Variable]
[PATCH]  simpleTokenLexer  (  tkn,  c  )  ;	[BUG]  [BUGGY]  encapsulatedTokenLexer(  tkn,  c)  ;[FE]  (startline  0)  EOF  reached  before  encapsulated  token  finished  testNextToken1  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  }  else  if  (eol)  {      tkn.type  =  EORECORD;  }  else  if  (isEncapsulator(c))  {    encapsulatedTokenLexer(tkn,  c);  }  else  if  (isEndOfFile(c))  {      tkn.type  =  EOF;  tkn.isReady  =  true;  //  there  is  data  at  EOF  }  else  {      [BUGGY]  encapsulatedTokenLexer(  tkn,  c)  ;  [BUGGY]  }  }  return  tkn;  }                          [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P7_Replace_Invocation]
[PATCH]  simpleTokenLexer  (  tkn,  c  )  ;	[BUG]  [BUGGY]  [FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  }  else  if  (eol)  {      tkn.type  =  EORECORD;  }  else  if  (isEncapsulator(c))  {    encapsulatedTokenLexer(tkn,  c);  }  else  if  (isEndOfFile(c))  {      tkn.type  =  EOF;  tkn.isReady  =  true;  //  there  is  data  at  EOF  }  else  {      [BUGGY]  [BUGGY]    }  }  return  tkn;  }                        [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P14_Delete_Statement]
[PATCH]  simpleTokenLexer  (  tkn,  c  )  ;	[BUG]  [BUGGY]  encapsulatedTokenLexer(  tkn,  c)  ;simpleTokenLexer(  tkn,  c)  ;[FE]  (startline  0)  EOF  reached  before  encapsulated  token  finished  testNextToken1  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  }  else  if  (eol)  {      tkn.type  =  EORECORD;  }  else  if  (isEncapsulator(c))  {    encapsulatedTokenLexer(tkn,  c);  }  else  if  (isEndOfFile(c))  {      tkn.type  =  EOF;  tkn.isReady  =  true;  //  there  is  data  at  EOF  }  else  {      [BUGGY]  encapsulatedTokenLexer(  tkn,  c)  ;simpleTokenLexer(  tkn,  c)  ;  [BUGGY]  }  }  return  tkn;  }                          [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P11_Insert_Donor_Statement]
[PATCH]  encapsulatedTokenLexer  (  tkn,  c  )  ;	[BUG]  [BUGGY]  encapsulatedTokenLexer(  tkn,  lastChar)  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]    if  (isCommentStart(c))  {    in.readLine();  tkn  =  nextToken(tkn.reset());  }  else  if  (isDelimiter(c))  {    tkn.type  =  TOKEN;  }  else  if  (eol)  {      tkn.type  =  EORECORD;  }  else  if  (isEncapsulator(c))  {    [BUGGY]  encapsulatedTokenLexer(  tkn,  lastChar)  ;  [BUGGY]  }  else  if  (isEndOfFile(c))  {      tkn.type  =  EOF;  tkn.isReady  =  true;  //  there  is  data  at  EOF  }  else  {      simpleTokenLexer(tkn,  c);  }  }  return  tkn;  }        [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P5_Replace_Variable]
[PATCH]  encapsulatedTokenLexer  (  tkn,  c  )  ;	[BUG]  [BUGGY]  encapsulatedTokenLexer(  c)  ;[CE]  method  encapsulatedTokenLexer  in  class  CSVLexer  cannot  be  applied  to  given  types;  [CONTEXT]    if  (isCommentStart(c))  {    in.readLine();  tkn  =  nextToken(tkn.reset());  }  else  if  (isDelimiter(c))  {    tkn.type  =  TOKEN;  }  else  if  (eol)  {      tkn.type  =  EORECORD;  }  else  if  (isEncapsulator(c))  {    [BUGGY]  encapsulatedTokenLexer(  c)  ;  [BUGGY]  }  else  if  (isEndOfFile(c))  {      tkn.type  =  EOF;  tkn.isReady  =  true;  //  there  is  data  at  EOF  }  else  {      simpleTokenLexer(tkn,  c);  }  }  return  tkn;  }        [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P5_Replace_Variable]
[PATCH]  encapsulatedTokenLexer  (  tkn,  c  )  ;	[BUG]  [BUGGY]  encapsulatedTokenLexer(  tkn)  ;[CE]  method  encapsulatedTokenLexer  in  class  CSVLexer  cannot  be  applied  to  given  types;  [CONTEXT]    if  (isCommentStart(c))  {    in.readLine();  tkn  =  nextToken(tkn.reset());  }  else  if  (isDelimiter(c))  {    tkn.type  =  TOKEN;  }  else  if  (eol)  {      tkn.type  =  EORECORD;  }  else  if  (isEncapsulator(c))  {    [BUGGY]  encapsulatedTokenLexer(  tkn)  ;  [BUGGY]  }  else  if  (isEndOfFile(c))  {      tkn.type  =  EOF;  tkn.isReady  =  true;  //  there  is  data  at  EOF  }  else  {      simpleTokenLexer(tkn,  c);  }  }  return  tkn;  }        [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P5_Replace_Variable]
[PATCH]  encapsulatedTokenLexer  (  tkn,  c  )  ;	[BUG]  [BUGGY]  encapsulatedTokenLexer(  c,  tkn)  ;[CE]  method  encapsulatedTokenLexer  in  class  CSVLexer  cannot  be  applied  to  given  types;  [CONTEXT]    if  (isCommentStart(c))  {    in.readLine();  tkn  =  nextToken(tkn.reset());  }  else  if  (isDelimiter(c))  {    tkn.type  =  TOKEN;  }  else  if  (eol)  {      tkn.type  =  EORECORD;  }  else  if  (isEncapsulator(c))  {    [BUGGY]  encapsulatedTokenLexer(  c,  tkn)  ;  [BUGGY]  }  else  if  (isEndOfFile(c))  {      tkn.type  =  EOF;  tkn.isReady  =  true;  //  there  is  data  at  EOF  }  else  {      simpleTokenLexer(tkn,  c);  }  }  return  tkn;  }        [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P5_Replace_Variable]
[PATCH]  encapsulatedTokenLexer  (  tkn,  c  )  ;	[BUG]  [BUGGY]  simpleTokenLexer(  tkn,  c)  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]    if  (isCommentStart(c))  {    in.readLine();  tkn  =  nextToken(tkn.reset());  }  else  if  (isDelimiter(c))  {    tkn.type  =  TOKEN;  }  else  if  (eol)  {      tkn.type  =  EORECORD;  }  else  if  (isEncapsulator(c))  {    [BUGGY]  simpleTokenLexer(  tkn,  c)  ;  [BUGGY]  }  else  if  (isEndOfFile(c))  {      tkn.type  =  EOF;  tkn.isReady  =  true;  //  there  is  data  at  EOF  }  else  {      simpleTokenLexer(tkn,  c);  }  }  return  tkn;  }        [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P7_Replace_Invocation]
[PATCH]  encapsulatedTokenLexer  (  tkn,  c  )  ;	[BUG]  [BUGGY]  simpleTokenLexer(  tkn,  lastChar)  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]    if  (isCommentStart(c))  {    in.readLine();  tkn  =  nextToken(tkn.reset());  }  else  if  (isDelimiter(c))  {    tkn.type  =  TOKEN;  }  else  if  (eol)  {      tkn.type  =  EORECORD;  }  else  if  (isEncapsulator(c))  {    [BUGGY]  simpleTokenLexer(  tkn,  lastChar)  ;  [BUGGY]  }  else  if  (isEndOfFile(c))  {      tkn.type  =  EOF;  tkn.isReady  =  true;  //  there  is  data  at  EOF  }  else  {      simpleTokenLexer(tkn,  c);  }  }  return  tkn;  }        [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P8_Replace_Mix]
[PATCH]  encapsulatedTokenLexer  (  tkn,  c  )  ;	[BUG]  [BUGGY]  [FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]    if  (isCommentStart(c))  {    in.readLine();  tkn  =  nextToken(tkn.reset());  }  else  if  (isDelimiter(c))  {    tkn.type  =  TOKEN;  }  else  if  (eol)  {      tkn.type  =  EORECORD;  }  else  if  (isEncapsulator(c))  {    [BUGGY]  [BUGGY]    }  else  if  (isEndOfFile(c))  {      tkn.type  =  EOF;  tkn.isReady  =  true;  //  there  is  data  at  EOF  }  else  {      simpleTokenLexer(tkn,  c);  }  }  return  tkn;  }      [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P14_Delete_Statement]
[PATCH]  encapsulatedTokenLexer  (  tkn,  c  )  ;	[BUG]  [BUGGY]  simpleTokenLexer(  tkn,  c)  ;encapsulatedTokenLexer(  tkn,  c)  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]    if  (isCommentStart(c))  {    in.readLine();  tkn  =  nextToken(tkn.reset());  }  else  if  (isDelimiter(c))  {    tkn.type  =  TOKEN;  }  else  if  (eol)  {      tkn.type  =  EORECORD;  }  else  if  (isEncapsulator(c))  {    [BUGGY]  simpleTokenLexer(  tkn,  c)  ;encapsulatedTokenLexer(  tkn,  c)  ;  [BUGGY]  }  else  if  (isEndOfFile(c))  {      tkn.type  =  EOF;  tkn.isReady  =  true;  //  there  is  data  at  EOF  }  else  {      simpleTokenLexer(tkn,  c);  }  }  return  tkn;  }        [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P11_Insert_Donor_Statement]
[PATCH]  tkn.type  =  EORECORD;	[BUG]  [BUGGY]  tkn.type  =  tkn.type  ;[FE]  [CONTEXT]  eol  =  isEndOfLine(c);  }  }    if  (isCommentStart(c))  {    in.readLine();  tkn  =  nextToken(tkn.reset());  }  else  if  (isDelimiter(c))  {    tkn.type  =  TOKEN;  }  else  if  (eol)  {      [BUGGY]  tkn.type  =  tkn.type  ;  [BUGGY]  }  else  if  (isEncapsulator(c))  {    encapsulatedTokenLexer(tkn,  c);  }  else  if  (isEndOfFile(c))  {      tkn.type  =  EOF;  tkn.isReady  =  true;  //  there  is  data  at  EOF  }  else  {      simpleTokenLexer(tkn,  c);  }  }  return  tkn;    [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P8_Replace_Mix]
[PATCH]  tkn.type  =  EORECORD;	[BUG]  [BUGGY]  tkn.type  =  TOKEN;tkn.type  =  EORECORD;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  eol  =  isEndOfLine(c);  }  }    if  (isCommentStart(c))  {    in.readLine();  tkn  =  nextToken(tkn.reset());  }  else  if  (isDelimiter(c))  {    tkn.type  =  TOKEN;  }  else  if  (eol)  {      [BUGGY]  tkn.type  =  TOKEN;tkn.type  =  EORECORD;  [BUGGY]  }  else  if  (isEncapsulator(c))  {    encapsulatedTokenLexer(tkn,  c);  }  else  if  (isEndOfFile(c))  {      tkn.type  =  EOF;  tkn.isReady  =  true;  //  there  is  data  at  EOF  }  else  {      simpleTokenLexer(tkn,  c);  }  }  return  tkn;    [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P11_Insert_Donor_Statement]
[PATCH]  tkn.type  =  EORECORD;	[BUG]  [BUGGY]  tkn.type  =  EOF;tkn.type  =  EORECORD;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  eol  =  isEndOfLine(c);  }  }    if  (isCommentStart(c))  {    in.readLine();  tkn  =  nextToken(tkn.reset());  }  else  if  (isDelimiter(c))  {    tkn.type  =  TOKEN;  }  else  if  (eol)  {      [BUGGY]  tkn.type  =  EOF;tkn.type  =  EORECORD;  [BUGGY]  }  else  if  (isEncapsulator(c))  {    encapsulatedTokenLexer(tkn,  c);  }  else  if  (isEndOfFile(c))  {      tkn.type  =  EOF;  tkn.isReady  =  true;  //  there  is  data  at  EOF  }  else  {      simpleTokenLexer(tkn,  c);  }  }  return  tkn;    [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P11_Insert_Donor_Statement]
[PATCH]  }  else  if  (  isEndOfFile  (  c  )  )  {	[BUG]  [BUGGY]  }  if  (  isEndOfFile(  lastChar)  )  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]    if  (isCommentStart(c))  {    in.readLine();  tkn  =  nextToken(tkn.reset());  }  else  if  (isDelimiter(c))  {    tkn.type  =  TOKEN;  }  else  if  (eol)  {      tkn.type  =  EORECORD;  }  else  if  (isEncapsulator(c))  {    encapsulatedTokenLexer(tkn,  c);  [BUGGY]  }  if  (  isEndOfFile(  lastChar)  )  {  [BUGGY]      tkn.type  =  EOF;  tkn.isReady  =  true;  //  there  is  data  at  EOF  }  else  {      simpleTokenLexer(tkn,  c);  }  }  return  tkn;  }          [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P8_Replace_Mix]
[PATCH]  tkn.type  =  EOF;	[BUG]  [BUGGY]  tkn.type  =  this;[CE]  incompatible  types  [CONTEXT]  in.readLine();  tkn  =  nextToken(tkn.reset());  }  else  if  (isDelimiter(c))  {    tkn.type  =  TOKEN;  }  else  if  (eol)  {      tkn.type  =  EORECORD;  }  else  if  (isEncapsulator(c))  {    encapsulatedTokenLexer(tkn,  c);  }  else  if  (isEndOfFile(c))  {      [BUGGY]  tkn.type  =  this;  [BUGGY]  tkn.isReady  =  true;  //  there  is  data  at  EOF  }  else  {      simpleTokenLexer(tkn,  c);  }  }  return  tkn;  }                [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P5_Replace_Variable]
[PATCH]  tkn.type  =  EOF;	[BUG]  [BUGGY]  tkn.type  =  null  ;[FE]  Token  type  expected:<EOF>  but  was:<null>  testNextToken1  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  in.readLine();  tkn  =  nextToken(tkn.reset());  }  else  if  (isDelimiter(c))  {    tkn.type  =  TOKEN;  }  else  if  (eol)  {      tkn.type  =  EORECORD;  }  else  if  (isEncapsulator(c))  {    encapsulatedTokenLexer(tkn,  c);  }  else  if  (isEndOfFile(c))  {      [BUGGY]  tkn.type  =  null  ;  [BUGGY]  tkn.isReady  =  true;  //  there  is  data  at  EOF  }  else  {      simpleTokenLexer(tkn,  c);  }  }  return  tkn;  }                [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P8_Replace_Mix]
[PATCH]  simpleTokenLexer  (  tkn,  c  )  ;	[BUG]  [BUGGY]  encapsulatedTokenLexer(  tkn,  lastChar)  ;[FE]  (startline  0)  EOF  reached  before  encapsulated  token  finished  testNextToken1  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  }  else  if  (isEndOfFile(c))  {      tkn.type  =  EOF;  tkn.isReady  =  true;  //  there  is  data  at  EOF  }  else  {      [BUGGY]  encapsulatedTokenLexer(  tkn,  lastChar)  ;  [BUGGY]  }    [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P8_Replace_Mix]
[PATCH]  tkn.type  =  EOF;	[BUG]  [BUGGY]  tkn.type  ;[CE]  not  a  statement  [CONTEXT]  in.readLine();  tkn  =  nextToken(tkn.reset());  }  else  if  (isDelimiter(c))  {    tkn.type  =  TOKEN;  }  else  if  (eol)  {      tkn.type  =  EORECORD;  }  else  if  (isEncapsulator(c))  {    encapsulatedTokenLexer(tkn,  c);  }  else  if  (isEndOfFile(c))  {      [BUGGY]  tkn.type  ;  [BUGGY]  tkn.isReady  =  true;  //  there  is  data  at  EOF  }  else  {      simpleTokenLexer(tkn,  c);  }  }  return  tkn;  }                [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P8_Replace_Mix]
[PATCH]  tkn.type  =  TOKEN;	[BUG]  [BUGGY]  tkn.type  ;[CE]  not  a  statement  [CONTEXT]    if  (surroundingSpacesIgnored)  {  while  (isWhitespace(c)  &&  !eol)  {  c  =  in.read();  eol  =  isEndOfLine(c);  }  }    if  (isCommentStart(c))  {    in.readLine();  tkn  =  nextToken(tkn.reset());  }  else  if  (isDelimiter(c))  {    [BUGGY]  tkn.type  ;  [BUGGY]  }  else  if  (eol)  {      tkn.type  =  EORECORD;  }  else  if  (isEncapsulator(c))  {    encapsulatedTokenLexer(tkn,  c);  }  else  if  (isEndOfFile(c))  {      tkn.type  =  EOF;  tkn.isReady  =  true;  //  there  is  data  at  EOF  }  else  {        [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P8_Replace_Mix]
[PATCH]  tkn.type  =  TOKEN;	[BUG]  [BUGGY]  tkn.type  =  EORECORD;tkn.type  =  TOKEN;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]    if  (surroundingSpacesIgnored)  {  while  (isWhitespace(c)  &&  !eol)  {  c  =  in.read();  eol  =  isEndOfLine(c);  }  }    if  (isCommentStart(c))  {    in.readLine();  tkn  =  nextToken(tkn.reset());  }  else  if  (isDelimiter(c))  {    [BUGGY]  tkn.type  =  EORECORD;tkn.type  =  TOKEN;  [BUGGY]  }  else  if  (eol)  {      tkn.type  =  EORECORD;  }  else  if  (isEncapsulator(c))  {    encapsulatedTokenLexer(tkn,  c);  }  else  if  (isEndOfFile(c))  {      tkn.type  =  EOF;  tkn.isReady  =  true;  //  there  is  data  at  EOF  }  else  {        [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P11_Insert_Donor_Statement]
[PATCH]  tkn.type  =  TOKEN;	[BUG]  [BUGGY]  tkn.type  =  EOF;tkn.type  =  TOKEN;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]    if  (surroundingSpacesIgnored)  {  while  (isWhitespace(c)  &&  !eol)  {  c  =  in.read();  eol  =  isEndOfLine(c);  }  }    if  (isCommentStart(c))  {    in.readLine();  tkn  =  nextToken(tkn.reset());  }  else  if  (isDelimiter(c))  {    [BUGGY]  tkn.type  =  EOF;tkn.type  =  TOKEN;  [BUGGY]  }  else  if  (eol)  {      tkn.type  =  EORECORD;  }  else  if  (isEncapsulator(c))  {    encapsulatedTokenLexer(tkn,  c);  }  else  if  (isEndOfFile(c))  {      tkn.type  =  EOF;  tkn.isReady  =  true;  //  there  is  data  at  EOF  }  else  {        [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P11_Insert_Donor_Statement]
[PATCH]  tkn.type  =  TOKEN;	[BUG]  [BUGGY]  tkn.isReady  =  true;tkn.type  =  TOKEN;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]    if  (surroundingSpacesIgnored)  {  while  (isWhitespace(c)  &&  !eol)  {  c  =  in.read();  eol  =  isEndOfLine(c);  }  }    if  (isCommentStart(c))  {    in.readLine();  tkn  =  nextToken(tkn.reset());  }  else  if  (isDelimiter(c))  {    [BUGGY]  tkn.isReady  =  true;tkn.type  =  TOKEN;  [BUGGY]  }  else  if  (eol)  {      tkn.type  =  EORECORD;  }  else  if  (isEncapsulator(c))  {    encapsulatedTokenLexer(tkn,  c);  }  else  if  (isEndOfFile(c))  {      tkn.type  =  EOF;  tkn.isReady  =  true;  //  there  is  data  at  EOF  }  else  {        [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P11_Insert_Donor_Statement]
[PATCH]  }  else  if  (  eol  )  {	[BUG]  [BUGGY]  }  if  (  eol)  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  if  (surroundingSpacesIgnored)  {  while  (isWhitespace(c)  &&  !eol)  {  c  =  in.read();  eol  =  isEndOfLine(c);  }  }    if  (isCommentStart(c))  {    in.readLine();  tkn  =  nextToken(tkn.reset());  }  else  if  (isDelimiter(c))  {    tkn.type  =  TOKEN;  [BUGGY]  }  if  (  eol)  {  [BUGGY]      tkn.type  =  EORECORD;  }  else  if  (isEncapsulator(c))  {    encapsulatedTokenLexer(tkn,  c);  }  else  if  (isEndOfFile(c))  {      tkn.type  =  EOF;  tkn.isReady  =  true;  //  there  is  data  at  EOF  }  else  {      simpleTokenLexer(tkn,  c);    [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P8_Replace_Mix]
[PATCH]  simpleTokenLexer  (  tkn,  c  )  ;	[BUG]  [BUGGY]  encapsulatedTokenLexer(  tkn,  lastChar)  ;[FE]  (startline  0)  EOF  reached  before  encapsulated  token  finished  testNextToken1  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  }  else  if  (eol)  {      tkn.type  =  EORECORD;  }  else  if  (isEncapsulator(c))  {    encapsulatedTokenLexer(tkn,  c);  }  else  if  (isEndOfFile(c))  {      tkn.type  =  EOF;  tkn.isReady  =  true;  //  there  is  data  at  EOF  }  else  {      [BUGGY]  encapsulatedTokenLexer(  tkn,  lastChar)  ;  [BUGGY]  }  }  return  tkn;  }                          [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P8_Replace_Mix]
[PATCH]  tkn.type  =  EORECORD;	[BUG]  [BUGGY]  tkn.type  =  null  ;[FE]  Token  type  expected:<EORECORD>  but  was:<null>  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  eol  =  isEndOfLine(c);  }  }    if  (isCommentStart(c))  {    in.readLine();  tkn  =  nextToken(tkn.reset());  }  else  if  (isDelimiter(c))  {    tkn.type  =  TOKEN;  }  else  if  (eol)  {      [BUGGY]  tkn.type  =  null  ;  [BUGGY]  }  else  if  (isEncapsulator(c))  {    encapsulatedTokenLexer(tkn,  c);  }  else  if  (isEndOfFile(c))  {      tkn.type  =  EOF;  tkn.isReady  =  true;  //  there  is  data  at  EOF  }  else  {      simpleTokenLexer(tkn,  c);  }  }  return  tkn;    [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P8_Replace_Mix]
[PATCH]  tkn.type  =  EOF;	[BUG]  [BUGGY]  tkn.type  =  2;[CE]  incompatible  types  [CONTEXT]  in.readLine();  tkn  =  nextToken(tkn.reset());  }  else  if  (isDelimiter(c))  {    tkn.type  =  TOKEN;  }  else  if  (eol)  {      tkn.type  =  EORECORD;  }  else  if  (isEncapsulator(c))  {    encapsulatedTokenLexer(tkn,  c);  }  else  if  (isEndOfFile(c))  {      [BUGGY]  tkn.type  =  2;  [BUGGY]  tkn.isReady  =  true;  //  there  is  data  at  EOF  }  else  {      simpleTokenLexer(tkn,  c);  }  }  return  tkn;  }                [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P5_Replace_Variable]
[PATCH]  tkn.type  =  TOKEN;	[BUG]  [BUGGY]  tkn.type  =  1;[CE]  incompatible  types  [CONTEXT]    if  (surroundingSpacesIgnored)  {  while  (isWhitespace(c)  &&  !eol)  {  c  =  in.read();  eol  =  isEndOfLine(c);  }  }    if  (isCommentStart(c))  {    in.readLine();  tkn  =  nextToken(tkn.reset());  }  else  if  (isDelimiter(c))  {    [BUGGY]  tkn.type  =  1;  [BUGGY]  }  else  if  (eol)  {      tkn.type  =  EORECORD;  }  else  if  (isEncapsulator(c))  {    encapsulatedTokenLexer(tkn,  c);  }  else  if  (isEndOfFile(c))  {      tkn.type  =  EOF;  tkn.isReady  =  true;  //  there  is  data  at  EOF  }  else  {        [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P5_Replace_Variable]
[PATCH]  tkn.type  =  TOKEN;	[BUG]  [BUGGY]  tkn.type  =  null  ;[FE]  Token  type  expected:<TOKEN>  but  was:<null>  testNextToken1  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]    if  (surroundingSpacesIgnored)  {  while  (isWhitespace(c)  &&  !eol)  {  c  =  in.read();  eol  =  isEndOfLine(c);  }  }    if  (isCommentStart(c))  {    in.readLine();  tkn  =  nextToken(tkn.reset());  }  else  if  (isDelimiter(c))  {    [BUGGY]  tkn.type  =  null  ;  [BUGGY]  }  else  if  (eol)  {      tkn.type  =  EORECORD;  }  else  if  (isEncapsulator(c))  {    encapsulatedTokenLexer(tkn,  c);  }  else  if  (isEndOfFile(c))  {      tkn.type  =  EOF;  tkn.isReady  =  true;  //  there  is  data  at  EOF  }  else  {        [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P8_Replace_Mix]
[PATCH]  tkn  =  nextToken  (  tkn.reset  (  )  )  ;	[BUG]  [BUGGY]  tkn  =  nextToken(  null.reset(  )  )  ;[CE]  <null>  cannot  be  dereferenced  [CONTEXT]    while  (tkn.type  ==  INVALID)  {    if  (surroundingSpacesIgnored)  {  while  (isWhitespace(c)  &&  !eol)  {  c  =  in.read();  eol  =  isEndOfLine(c);  }  }    if  (isCommentStart(c))  {    in.readLine();  [BUGGY]  tkn  =  nextToken(  null.reset(  )  )  ;  [BUGGY]  }  else  if  (isDelimiter(c))  {    tkn.type  =  TOKEN;  }  else  if  (eol)  {      tkn.type  =  EORECORD;  }  else  if  (isEncapsulator(c))  {    encapsulatedTokenLexer(tkn,  c);  }  else  if  (isEndOfFile(c))  {      tkn.type  =  EOF;  tkn.isReady  =  true;  //  there  is  data  at  EOF    [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P8_Replace_Mix]
[PATCH]  in.readLine  (  )  ;	[BUG]  [BUGGY]  in.readAgain(  )  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  }    while  (tkn.type  ==  INVALID)  {    if  (surroundingSpacesIgnored)  {  while  (isWhitespace(c)  &&  !eol)  {  c  =  in.read();  eol  =  isEndOfLine(c);  }  }    if  (isCommentStart(c))  {    [BUGGY]  in.readAgain(  )  ;  [BUGGY]  tkn  =  nextToken(tkn.reset());  }  else  if  (isDelimiter(c))  {    tkn.type  =  TOKEN;  }  else  if  (eol)  {      tkn.type  =  EORECORD;  }  else  if  (isEncapsulator(c))  {    encapsulatedTokenLexer(tkn,  c);  }  else  if  (isEndOfFile(c))  {      tkn.type  =  EOF;    [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P7_Replace_Invocation]
[PATCH]  in.readLine  (  )  ;	[BUG]  [BUGGY]  [FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  }    while  (tkn.type  ==  INVALID)  {    if  (surroundingSpacesIgnored)  {  while  (isWhitespace(c)  &&  !eol)  {  c  =  in.read();  eol  =  isEndOfLine(c);  }  }    if  (isCommentStart(c))  {    [BUGGY]  [BUGGY]    tkn  =  nextToken(tkn.reset());  }  else  if  (isDelimiter(c))  {    tkn.type  =  TOKEN;  }  else  if  (eol)  {      tkn.type  =  EORECORD;  }  else  if  (isEncapsulator(c))  {    encapsulatedTokenLexer(tkn,  c);  }  else  if  (isEndOfFile(c))  {        [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P14_Delete_Statement]
[PATCH]  in.readLine  (  )  ;	[BUG]  [BUGGY]  c  =  in.readAgain(  )  ;in.readLine(  )  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  }    while  (tkn.type  ==  INVALID)  {    if  (surroundingSpacesIgnored)  {  while  (isWhitespace(c)  &&  !eol)  {  c  =  in.read();  eol  =  isEndOfLine(c);  }  }    if  (isCommentStart(c))  {    [BUGGY]  c  =  in.readAgain(  )  ;in.readLine(  )  ;  [BUGGY]  tkn  =  nextToken(tkn.reset());  }  else  if  (isDelimiter(c))  {    tkn.type  =  TOKEN;  }  else  if  (eol)  {      tkn.type  =  EORECORD;  }  else  if  (isEncapsulator(c))  {    encapsulatedTokenLexer(tkn,  c);  }  else  if  (isEndOfFile(c))  {      tkn.type  =  EOF;    [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P11_Insert_Donor_Statement]
[PATCH]  in.readLine  (  )  ;	[BUG]  [BUGGY]  int  c  =  in.read(  )  ;in.readLine(  )  ;[CE]  variable  c  is  already  defined  in  method  nextToken(Token)  [CONTEXT]  }    while  (tkn.type  ==  INVALID)  {    if  (surroundingSpacesIgnored)  {  while  (isWhitespace(c)  &&  !eol)  {  c  =  in.read();  eol  =  isEndOfLine(c);  }  }    if  (isCommentStart(c))  {    [BUGGY]  int  c  =  in.read(  )  ;in.readLine(  )  ;  [BUGGY]  tkn  =  nextToken(tkn.reset());  }  else  if  (isDelimiter(c))  {    tkn.type  =  TOKEN;  }  else  if  (eol)  {      tkn.type  =  EORECORD;  }  else  if  (isEncapsulator(c))  {    encapsulatedTokenLexer(tkn,  c);  }  else  if  (isEndOfFile(c))  {      tkn.type  =  EOF;    [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P11_Insert_Donor_Statement]
[PATCH]  in.readLine  (  )  ;	[BUG]  [BUGGY]  eol  =  isEndOfLine(  c)  ;in.readLine(  )  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  }    while  (tkn.type  ==  INVALID)  {    if  (surroundingSpacesIgnored)  {  while  (isWhitespace(c)  &&  !eol)  {  c  =  in.read();  eol  =  isEndOfLine(c);  }  }    if  (isCommentStart(c))  {    [BUGGY]  eol  =  isEndOfLine(  c)  ;in.readLine(  )  ;  [BUGGY]  tkn  =  nextToken(tkn.reset());  }  else  if  (isDelimiter(c))  {    tkn.type  =  TOKEN;  }  else  if  (eol)  {      tkn.type  =  EORECORD;  }  else  if  (isEncapsulator(c))  {    encapsulatedTokenLexer(tkn,  c);  }  else  if  (isEndOfFile(c))  {      tkn.type  =  EOF;    [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P11_Insert_Donor_Statement]
[PATCH]  in.readLine  (  )  ;	[BUG]  [BUGGY]  c  =  in.read(  )  ;in.readLine(  )  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  }    while  (tkn.type  ==  INVALID)  {    if  (surroundingSpacesIgnored)  {  while  (isWhitespace(c)  &&  !eol)  {  c  =  in.read();  eol  =  isEndOfLine(c);  }  }    if  (isCommentStart(c))  {    [BUGGY]  c  =  in.read(  )  ;in.readLine(  )  ;  [BUGGY]  tkn  =  nextToken(tkn.reset());  }  else  if  (isDelimiter(c))  {    tkn.type  =  TOKEN;  }  else  if  (eol)  {      tkn.type  =  EORECORD;  }  else  if  (isEncapsulator(c))  {    encapsulatedTokenLexer(tkn,  c);  }  else  if  (isEndOfFile(c))  {      tkn.type  =  EOF;    [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P11_Insert_Donor_Statement]
[PATCH]  tkn  =  nextToken  (  tkn.reset  (  )  )  ;	[BUG]  [BUGGY]  [FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]    while  (tkn.type  ==  INVALID)  {    if  (surroundingSpacesIgnored)  {  while  (isWhitespace(c)  &&  !eol)  {  c  =  in.read();  eol  =  isEndOfLine(c);  }  }    if  (isCommentStart(c))  {    in.readLine();  [BUGGY]  [BUGGY]    }  else  if  (isDelimiter(c))  {    tkn.type  =  TOKEN;  }  else  if  (eol)  {      tkn.type  =  EORECORD;  }  else  if  (isEncapsulator(c))  {    encapsulatedTokenLexer(tkn,  c);  }  else  if  (isEndOfFile(c))  {      tkn.type  =  EOF;    [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P14_Delete_Statement]
[PATCH]  }  else  if  (  isEndOfFile  (  c  )  )  {	[BUG]  [BUGGY]  }  if  (  isEndOfLine(  lastChar)  )  {[FE]  Token  type  expected:<TOKEN>  but  was:<EOF>  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]    if  (isCommentStart(c))  {    in.readLine();  tkn  =  nextToken(tkn.reset());  }  else  if  (isDelimiter(c))  {    tkn.type  =  TOKEN;  }  else  if  (eol)  {      tkn.type  =  EORECORD;  }  else  if  (isEncapsulator(c))  {    encapsulatedTokenLexer(tkn,  c);  [BUGGY]  }  if  (  isEndOfLine(  lastChar)  )  {  [BUGGY]      tkn.type  =  EOF;  tkn.isReady  =  true;  //  there  is  data  at  EOF  }  else  {      simpleTokenLexer(tkn,  c);  }  }  return  tkn;  }          [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P8_Replace_Mix]
[PATCH]  tkn.type  =  EORECORD;	[BUG]  [BUGGY]  tkn.type  ;[CE]  not  a  statement  [CONTEXT]  eol  =  isEndOfLine(c);  }  }    if  (isCommentStart(c))  {    in.readLine();  tkn  =  nextToken(tkn.reset());  }  else  if  (isDelimiter(c))  {    tkn.type  =  TOKEN;  }  else  if  (eol)  {      [BUGGY]  tkn.type  ;  [BUGGY]  }  else  if  (isEncapsulator(c))  {    encapsulatedTokenLexer(tkn,  c);  }  else  if  (isEndOfFile(c))  {      tkn.type  =  EOF;  tkn.isReady  =  true;  //  there  is  data  at  EOF  }  else  {      simpleTokenLexer(tkn,  c);  }  }  return  tkn;    [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P8_Replace_Mix]
[PATCH]  tkn.type  =  TOKEN;	[BUG]  [BUGGY]  tkn.type  =  tkn.type  ;[FE]  [CONTEXT]    if  (surroundingSpacesIgnored)  {  while  (isWhitespace(c)  &&  !eol)  {  c  =  in.read();  eol  =  isEndOfLine(c);  }  }    if  (isCommentStart(c))  {    in.readLine();  tkn  =  nextToken(tkn.reset());  }  else  if  (isDelimiter(c))  {    [BUGGY]  tkn.type  =  tkn.type  ;  [BUGGY]  }  else  if  (eol)  {      tkn.type  =  EORECORD;  }  else  if  (isEncapsulator(c))  {    encapsulatedTokenLexer(tkn,  c);  }  else  if  (isEndOfFile(c))  {      tkn.type  =  EOF;  tkn.isReady  =  true;  //  there  is  data  at  EOF  }  else  {        [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P8_Replace_Mix]
[PATCH]  c  =  in.read  (  )  ;	[BUG]  [BUGGY]  c  =  this.read(  )  ;[CE]  cannot  find  symbol  [CONTEXT]  }  }    if  (isEndOfFile(lastChar)  ||  (!isDelimiter(lastChar)  &&  isEndOfFile(c)))  {  tkn.type  =  EOF;    return  tkn;  }    while  (tkn.type  ==  INVALID)  {    if  (surroundingSpacesIgnored)  {  while  (isWhitespace(c)  &&  !eol)  {  [BUGGY]  c  =  this.read(  )  ;  [BUGGY]  eol  =  isEndOfLine(c);  }  }    if  (isCommentStart(c))  {    in.readLine();  tkn  =  nextToken(tkn.reset());  }  else  if  (isDelimiter(c))  {    tkn.type  =  TOKEN;  }  else  if  (eol)  {        [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P5_Replace_Variable]
[PATCH]  if  (  isCommentStart  (  c  )  )  {	[BUG]  [BUGGY]  if  (  isWhitespace(  lastChar)  )  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]    return  tkn;  }    while  (tkn.type  ==  INVALID)  {    if  (surroundingSpacesIgnored)  {  while  (isWhitespace(c)  &&  !eol)  {  c  =  in.read();  eol  =  isEndOfLine(c);  }  }    [BUGGY]  if  (  isWhitespace(  lastChar)  )  {  [BUGGY]    in.readLine();  tkn  =  nextToken(tkn.reset());  }  else  if  (isDelimiter(c))  {    tkn.type  =  TOKEN;  }  else  if  (eol)  {      tkn.type  =  EORECORD;  }  else  if  (isEncapsulator(c))  {    encapsulatedTokenLexer(tkn,  c);  }  else  if  (isEndOfFile(c))  {      [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P8_Replace_Mix]
[PATCH]  c  =  in.read  (  )  ;	[BUG]  [BUGGY]  c  =  4.read(  )  ;[CE]  ';'  expected  [CONTEXT]  }  }    if  (isEndOfFile(lastChar)  ||  (!isDelimiter(lastChar)  &&  isEndOfFile(c)))  {  tkn.type  =  EOF;    return  tkn;  }    while  (tkn.type  ==  INVALID)  {    if  (surroundingSpacesIgnored)  {  while  (isWhitespace(c)  &&  !eol)  {  [BUGGY]  c  =  4.read(  )  ;  [BUGGY]  eol  =  isEndOfLine(c);  }  }    if  (isCommentStart(c))  {    in.readLine();  tkn  =  nextToken(tkn.reset());  }  else  if  (isDelimiter(c))  {    tkn.type  =  TOKEN;  }  else  if  (eol)  {        [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P5_Replace_Variable]
[PATCH]  eol  =  isEndOfLine  (  c  )  ;	[BUG]  [BUGGY]  eol  =  isEndOfLine(  null)  ;[CE]  method  isEndOfLine  in  class  Lexer  cannot  be  applied  to  given  types;  [CONTEXT]  }    if  (isEndOfFile(lastChar)  ||  (!isDelimiter(lastChar)  &&  isEndOfFile(c)))  {  tkn.type  =  EOF;    return  tkn;  }    while  (tkn.type  ==  INVALID)  {    if  (surroundingSpacesIgnored)  {  while  (isWhitespace(c)  &&  !eol)  {  c  =  in.read();  [BUGGY]  eol  =  isEndOfLine(  null)  ;  [BUGGY]  }  }    if  (isCommentStart(c))  {    in.readLine();  tkn  =  nextToken(tkn.reset());  }  else  if  (isDelimiter(c))  {    tkn.type  =  TOKEN;  }  else  if  (eol)  {      tkn.type  =  EORECORD;    [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P8_Replace_Mix]
[PATCH]  while  (  isWhitespace  (  c  )  &&  !eol  )  {	[BUG]  [BUGGY]  while  (  isEscape(  lastChar)  &&  !eol)  {[FE]  Token  content  expected:<[]hijk>  but  was:<[  ]hijk>  testNextToken1  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  }  }  }    if  (isEndOfFile(lastChar)  ||  (!isDelimiter(lastChar)  &&  isEndOfFile(c)))  {  tkn.type  =  EOF;    return  tkn;  }    while  (tkn.type  ==  INVALID)  {    if  (surroundingSpacesIgnored)  {  [BUGGY]  while  (  isEscape(  lastChar)  &&  !eol)  {  [BUGGY]  c  =  in.read();  eol  =  isEndOfLine(c);  }  }    if  (isCommentStart(c))  {    in.readLine();  tkn  =  nextToken(tkn.reset());  }  else  if  (isDelimiter(c))  {    tkn.type  =  TOKEN;  }  else  if  (eol)  {      [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P8_Replace_Mix]
[PATCH]  c  =  in.read  (  )  ;	[BUG]  [BUGGY]  c  =  null.read(  )  ;[CE]  <null>  cannot  be  dereferenced  [CONTEXT]  }  }    if  (isEndOfFile(lastChar)  ||  (!isDelimiter(lastChar)  &&  isEndOfFile(c)))  {  tkn.type  =  EOF;    return  tkn;  }    while  (tkn.type  ==  INVALID)  {    if  (surroundingSpacesIgnored)  {  while  (isWhitespace(c)  &&  !eol)  {  [BUGGY]  c  =  null.read(  )  ;  [BUGGY]  eol  =  isEndOfLine(c);  }  }    if  (isCommentStart(c))  {    in.readLine();  tkn  =  nextToken(tkn.reset());  }  else  if  (isDelimiter(c))  {    tkn.type  =  TOKEN;  }  else  if  (eol)  {        [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P8_Replace_Mix]
[PATCH]  tkn.type  =  EOF;	[BUG]  [BUGGY]  tkn.type  =  4;[CE]  incompatible  types  [CONTEXT]  in.readLine();  tkn  =  nextToken(tkn.reset());  }  else  if  (isDelimiter(c))  {    tkn.type  =  TOKEN;  }  else  if  (eol)  {      tkn.type  =  EORECORD;  }  else  if  (isEncapsulator(c))  {    encapsulatedTokenLexer(tkn,  c);  }  else  if  (isEndOfFile(c))  {      [BUGGY]  tkn.type  =  4;  [BUGGY]  tkn.isReady  =  true;  //  there  is  data  at  EOF  }  else  {      simpleTokenLexer(tkn,  c);  }  }  return  tkn;  }                [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P5_Replace_Variable]
[PATCH]  in.readLine  (  )  ;  tkn  =  nextToken  (  tkn.reset  (  )  )  ;	[BUG]  [BUGGY]  [FE]  [CONTEXT]  }    while  (tkn.type  ==  INVALID)  {    if  (surroundingSpacesIgnored)  {  while  (isWhitespace(c)  &&  !eol)  {  c  =  in.read();  eol  =  isEndOfLine(c);  }  }    if  (isCommentStart(c))  {    [BUGGY]  [BUGGY]    }  else  if  (isDelimiter(c))  {    tkn.type  =  TOKEN;  }  else  if  (eol)  {      tkn.type  =  EORECORD;  }  else  if  (isEncapsulator(c))  {    encapsulatedTokenLexer(tkn,  c);  }  else  if  (isEndOfFile(c))  {        [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P14_Delete_Statement]
[PATCH]  }  else  if  (  isEndOfFile  (  c  )  )  {	[BUG]  [BUGGY]  }  if  (  isEndOfLine(  c)  )  {[FE]  Token  type  expected:<EORECORD>  but  was:<EOF>  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]    if  (isCommentStart(c))  {    in.readLine();  tkn  =  nextToken(tkn.reset());  }  else  if  (isDelimiter(c))  {    tkn.type  =  TOKEN;  }  else  if  (eol)  {      tkn.type  =  EORECORD;  }  else  if  (isEncapsulator(c))  {    encapsulatedTokenLexer(tkn,  c);  [BUGGY]  }  if  (  isEndOfLine(  c)  )  {  [BUGGY]      tkn.type  =  EOF;  tkn.isReady  =  true;  //  there  is  data  at  EOF  }  else  {      simpleTokenLexer(tkn,  c);  }  }  return  tkn;  }          [CLASS]  CSVLexer  [METHOD]  nextToken  [RETURN_TYPE]  Token    Token  tkn  [VARIABLES]  boolean  eol  Token  tkn  int  c  lastChar    	[P8_Replace_Mix]
[PATCH]  while  (  true  )  {	[BUG]  [BUGGY]  while  (  false)  {[CE]  unreachable  statement  [CONTEXT]  private  Token  simpleTokenLexer(Token  tkn,  int  c)  throws  IOException  {  [BUGGY]  while  (  false)  {  [BUGGY]  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  break;  }  else  if  (isEndOfFile(c))  {    tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  break;  }  else  if  (isDelimiter(c))  {    tkn.type  =  TOKEN;  break;  }  else  if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  {  tkn.content.append((char)  c);  }  c  =  in.read();  }  if  (surroundingSpacesIgnored)  {  trimTrailingSpaces(tkn.content);  }  return  tkn;  }    [CLASS]  CSVLexer  [METHOD]  simpleTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c    	[P3_Replace_Literal]
[PATCH]  if  (  isEndOfLine  (  c  )  )  {	[BUG]  [BUGGY]  if  (  isEndOfFile(  c)  )  {[FE]  Token  type  expected:<EORECORD>  but  was:<TOKEN>  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  private  Token  simpleTokenLexer(Token  tkn,  int  c)  throws  IOException  {  while  (true)  {  [BUGGY]  if  (  isEndOfFile(  c)  )  {  [BUGGY]    tkn.type  =  EORECORD;  break;  }  else  if  (isEndOfFile(c))  {    tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  break;  }  else  if  (isDelimiter(c))  {    tkn.type  =  TOKEN;  break;  }  else  if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  {  tkn.content.append((char)  c);  }  c  =  in.read();  }  if  (surroundingSpacesIgnored)  {  trimTrailingSpaces(tkn.content);  }  return  tkn;  }    [CLASS]  CSVLexer  [METHOD]  simpleTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c    	[P7_Replace_Invocation]
[PATCH]  if  (  isEndOfLine  (  c  )  )  {	[BUG]  [BUGGY]  if  (  isEscape(  c)  )  {[FE]  Token  type  expected:<EORECORD>  but  was:<TOKEN>  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  private  Token  simpleTokenLexer(Token  tkn,  int  c)  throws  IOException  {  while  (true)  {  [BUGGY]  if  (  isEscape(  c)  )  {  [BUGGY]    tkn.type  =  EORECORD;  break;  }  else  if  (isEndOfFile(c))  {    tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  break;  }  else  if  (isDelimiter(c))  {    tkn.type  =  TOKEN;  break;  }  else  if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  {  tkn.content.append((char)  c);  }  c  =  in.read();  }  if  (surroundingSpacesIgnored)  {  trimTrailingSpaces(tkn.content);  }  return  tkn;  }    [CLASS]  CSVLexer  [METHOD]  simpleTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c    	[P9_Replace_Statement]
[PATCH]  }  else  if  (  isEndOfFile  (  c  )  )  {	[BUG]  [BUGGY]  }  else  {[CE]  'else'  without  'if'  [CONTEXT]  private  Token  simpleTokenLexer(Token  tkn,  int  c)  throws  IOException  {  while  (true)  {  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  break;  [BUGGY]  }  else  {  [BUGGY]    tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  break;  }  else  if  (isDelimiter(c))  {    tkn.type  =  TOKEN;  break;  }  else  if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  {  tkn.content.append((char)  c);  }  c  =  in.read();  }  if  (surroundingSpacesIgnored)  {  trimTrailingSpaces(tkn.content);  }  return  tkn;  }    [CLASS]  CSVLexer  [METHOD]  simpleTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c    	[P6_Replace_Expression]
[PATCH]  }  else  if  (  isEndOfFile  (  c  )  )  {	[BUG]  [BUGGY]  }  else  if  (  isEndOfLine(  c)  )  {[FE]  [CONTEXT]  private  Token  simpleTokenLexer(Token  tkn,  int  c)  throws  IOException  {  while  (true)  {  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  break;  [BUGGY]  }  else  if  (  isEndOfLine(  c)  )  {  [BUGGY]    tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  break;  }  else  if  (isDelimiter(c))  {    tkn.type  =  TOKEN;  break;  }  else  if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  {  tkn.content.append((char)  c);  }  c  =  in.read();  }  if  (surroundingSpacesIgnored)  {  trimTrailingSpaces(tkn.content);  }  return  tkn;  }    [CLASS]  CSVLexer  [METHOD]  simpleTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c    	[P7_Replace_Invocation]
[PATCH]  }  else  if  (  isEndOfFile  (  c  )  )  {	[BUG]  [BUGGY]  }  else  if  (  isDelimiter(  c)  )  {[FE]  [CONTEXT]  private  Token  simpleTokenLexer(Token  tkn,  int  c)  throws  IOException  {  while  (true)  {  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  break;  [BUGGY]  }  else  if  (  isDelimiter(  c)  )  {  [BUGGY]    tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  break;  }  else  if  (isDelimiter(c))  {    tkn.type  =  TOKEN;  break;  }  else  if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  {  tkn.content.append((char)  c);  }  c  =  in.read();  }  if  (surroundingSpacesIgnored)  {  trimTrailingSpaces(tkn.content);  }  return  tkn;  }    [CLASS]  CSVLexer  [METHOD]  simpleTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c    	[P9_Replace_Statement]
[PATCH]  }  else  if  (  isDelimiter  (  c  )  )  {	[BUG]  [BUGGY]  }  else  {[CE]  'else'  without  'if'  [CONTEXT]  private  Token  simpleTokenLexer(Token  tkn,  int  c)  throws  IOException  {  while  (true)  {  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  break;  }  else  if  (isEndOfFile(c))  {    tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  break;  [BUGGY]  }  else  {  [BUGGY]    tkn.type  =  TOKEN;  break;  }  else  if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  {  tkn.content.append((char)  c);  }  c  =  in.read();  }  if  (surroundingSpacesIgnored)  {  trimTrailingSpaces(tkn.content);  }  return  tkn;  }    [CLASS]  CSVLexer  [METHOD]  simpleTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c    	[P6_Replace_Expression]
[PATCH]  }  else  if  (  isDelimiter  (  c  )  )  {	[BUG]  [BUGGY]  }  else  if  (  isEscape(  c)  )  {[FE]  Token  type  expected:<TOKEN>  but  was:<EOF>  testNextToken1  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  private  Token  simpleTokenLexer(Token  tkn,  int  c)  throws  IOException  {  while  (true)  {  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  break;  }  else  if  (isEndOfFile(c))  {    tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  break;  [BUGGY]  }  else  if  (  isEscape(  c)  )  {  [BUGGY]    tkn.type  =  TOKEN;  break;  }  else  if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  {  tkn.content.append((char)  c);  }  c  =  in.read();  }  if  (surroundingSpacesIgnored)  {  trimTrailingSpaces(tkn.content);  }  return  tkn;  }    [CLASS]  CSVLexer  [METHOD]  simpleTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c    	[P7_Replace_Invocation]
[PATCH]  }  else  if  (  isDelimiter  (  c  )  )  {	[BUG]  [BUGGY]  }  if  (  isEscape(  c)  )  {[FE]  Token  type  expected:<TOKEN>  but  was:<EOF>  testNextToken1  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  private  Token  simpleTokenLexer(Token  tkn,  int  c)  throws  IOException  {  while  (true)  {  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  break;  }  else  if  (isEndOfFile(c))  {    tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  break;  [BUGGY]  }  if  (  isEscape(  c)  )  {  [BUGGY]    tkn.type  =  TOKEN;  break;  }  else  if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  {  tkn.content.append((char)  c);  }  c  =  in.read();  }  if  (surroundingSpacesIgnored)  {  trimTrailingSpaces(tkn.content);  }  return  tkn;  }    [CLASS]  CSVLexer  [METHOD]  simpleTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c    	[P8_Replace_Mix]
[PATCH]  }  else  if  (  isDelimiter  (  c  )  )  {	[BUG]  [BUGGY]  }  else  if  (  isEndOfFile(  c)  )  {[FE]  Token  type  expected:<TOKEN>  but  was:<EOF>  testNextToken1  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  private  Token  simpleTokenLexer(Token  tkn,  int  c)  throws  IOException  {  while  (true)  {  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  break;  }  else  if  (isEndOfFile(c))  {    tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  break;  [BUGGY]  }  else  if  (  isEndOfFile(  c)  )  {  [BUGGY]    tkn.type  =  TOKEN;  break;  }  else  if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  {  tkn.content.append((char)  c);  }  c  =  in.read();  }  if  (surroundingSpacesIgnored)  {  trimTrailingSpaces(tkn.content);  }  return  tkn;  }    [CLASS]  CSVLexer  [METHOD]  simpleTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c    	[P9_Replace_Statement]
[PATCH]  }  else  if  (  isEscape  (  c  )  )  {	[BUG]  [BUGGY]  }  else  {[CE]  'else'  without  'if'  [CONTEXT]  private  Token  simpleTokenLexer(Token  tkn,  int  c)  throws  IOException  {  while  (true)  {  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  break;  }  else  if  (isEndOfFile(c))  {    tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  break;  }  else  if  (isDelimiter(c))  {    tkn.type  =  TOKEN;  break;  [BUGGY]  }  else  {  [BUGGY]  tkn.content.append((char)  readEscape(c));  }  else  {  tkn.content.append((char)  c);  }  c  =  in.read();  }  if  (surroundingSpacesIgnored)  {  trimTrailingSpaces(tkn.content);  }  return  tkn;  }    [CLASS]  CSVLexer  [METHOD]  simpleTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c    	[P6_Replace_Expression]
[PATCH]  }  else  if  (  isEscape  (  c  )  )  {	[BUG]  [BUGGY]  }  else  if  (  readEscape(  c)  )  {[CE]  incompatible  types  [CONTEXT]  private  Token  simpleTokenLexer(Token  tkn,  int  c)  throws  IOException  {  while  (true)  {  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  break;  }  else  if  (isEndOfFile(c))  {    tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  break;  }  else  if  (isDelimiter(c))  {    tkn.type  =  TOKEN;  break;  [BUGGY]  }  else  if  (  readEscape(  c)  )  {  [BUGGY]  tkn.content.append((char)  readEscape(c));  }  else  {  tkn.content.append((char)  c);  }  c  =  in.read();  }  if  (surroundingSpacesIgnored)  {  trimTrailingSpaces(tkn.content);  }  return  tkn;  }    [CLASS]  CSVLexer  [METHOD]  simpleTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c    	[P7_Replace_Invocation]
[PATCH]  }  else  if  (  isEscape  (  c  )  )  {	[BUG]  [BUGGY]  }  if  (  readEscape(  c)  )  {[CE]  incompatible  types  [CONTEXT]  private  Token  simpleTokenLexer(Token  tkn,  int  c)  throws  IOException  {  while  (true)  {  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  break;  }  else  if  (isEndOfFile(c))  {    tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  break;  }  else  if  (isDelimiter(c))  {    tkn.type  =  TOKEN;  break;  [BUGGY]  }  if  (  readEscape(  c)  )  {  [BUGGY]  tkn.content.append((char)  readEscape(c));  }  else  {  tkn.content.append((char)  c);  }  c  =  in.read();  }  if  (surroundingSpacesIgnored)  {  trimTrailingSpaces(tkn.content);  }  return  tkn;  }    [CLASS]  CSVLexer  [METHOD]  simpleTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c    	[P8_Replace_Mix]
[PATCH]  }  else  if  (  isEscape  (  c  )  )  {  tkn.content.append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  {  tkn.content.append  (  (  char  )  c  )  ;  }	[BUG]  [BUGGY]  tkn.content.append(((char)(readEscape(c))));[CE]  illegal  start  of  expression  [CONTEXT]  private  Token  simpleTokenLexer(Token  tkn,  int  c)  throws  IOException  {  while  (true)  {  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  break;  }  else  if  (isEndOfFile(c))  {    tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  break;  }  else  if  (isDelimiter(c))  {    tkn.type  =  TOKEN;  break;  [BUGGY]  tkn.content.append(((char)(readEscape(c))));  [BUGGY]    tkn.content.append(((char)  (readEscape(c))));      c  =  in.read();  }  if  (surroundingSpacesIgnored)  {  trimTrailingSpaces(tkn.content);  }  return  tkn;    [CLASS]  CSVLexer  [METHOD]  simpleTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c    	[P15_Unwrap_Block]
[PATCH]  }  else  if  (  isEscape  (  c  )  )  {  tkn.content.append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  {  tkn.content.append  (  (  char  )  c  )  ;  }	[BUG]  [BUGGY]  [CE]  illegal  start  of  expression  [CONTEXT]  private  Token  simpleTokenLexer(Token  tkn,  int  c)  throws  IOException  {  while  (true)  {  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  break;  }  else  if  (isEndOfFile(c))  {    tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  break;  }  else  if  (isDelimiter(c))  {    tkn.type  =  TOKEN;  break;  [BUGGY]  [BUGGY]        c  =  in.read();  }  if  (surroundingSpacesIgnored)  {  trimTrailingSpaces(tkn.content);  }  return  tkn;    [CLASS]  CSVLexer  [METHOD]  simpleTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c    	[P16_Remove_Block]
[PATCH]  tkn.content.append  (  (  char  )  c  )  ;	[BUG]  [BUGGY]  [FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  }  else  if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  {  [BUGGY]  [BUGGY]      [CLASS]  CSVLexer  [METHOD]  simpleTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c    	[P14_Delete_Statement]
[PATCH]  tkn.content.append  (  (  char  )  c  )  ;	[BUG]  [BUGGY]  tkn.content.append(  (  char)  readEscape(  c)  )  ;tkn.content.append(  (  char)  c)  ;[FE]  Token  content  expected:<[abc]>  but  was:<[  testNextToken1  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  }  else  if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  {  [BUGGY]  tkn.content.append(  (  char)  readEscape(  c)  )  ;tkn.content.append(  (  char)  c)  ;  [BUGGY]  }    [CLASS]  CSVLexer  [METHOD]  simpleTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c    	[P11_Insert_Donor_Statement]
[PATCH]  tkn.content.append  (  (  char  )  readEscape  (  c  )  )  ;	[BUG]  [BUGGY]  tkn.content.append(  (  char)  isEscape(  c)  )  ;[CE]  inconvertible  types  [CONTEXT]  private  Token  simpleTokenLexer(Token  tkn,  int  c)  throws  IOException  {  while  (true)  {  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  break;  }  else  if  (isEndOfFile(c))  {    tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  break;  }  else  if  (isDelimiter(c))  {    tkn.type  =  TOKEN;  break;  }  else  if  (isEscape(c))  {  [BUGGY]  tkn.content.append(  (  char)  isEscape(  c)  )  ;  [BUGGY]  }  else  {  tkn.content.append((char)  c);  }  c  =  in.read();  }  if  (surroundingSpacesIgnored)  {  trimTrailingSpaces(tkn.content);  }  return  tkn;  }    [CLASS]  CSVLexer  [METHOD]  simpleTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c    	[P7_Replace_Invocation]
[PATCH]  tkn.content.append  (  (  char  )  readEscape  (  c  )  )  ;	[BUG]  [BUGGY]  [FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  private  Token  simpleTokenLexer(Token  tkn,  int  c)  throws  IOException  {  while  (true)  {  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  break;  }  else  if  (isEndOfFile(c))  {    tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  break;  }  else  if  (isDelimiter(c))  {    tkn.type  =  TOKEN;  break;  }  else  if  (isEscape(c))  {  [BUGGY]  [BUGGY]    }  else  {  tkn.content.append((char)  c);  }  c  =  in.read();  }  if  (surroundingSpacesIgnored)  {  trimTrailingSpaces(tkn.content);  }  return  tkn;    [CLASS]  CSVLexer  [METHOD]  simpleTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c    	[P14_Delete_Statement]
[PATCH]  tkn.content.append  (  (  char  )  readEscape  (  c  )  )  ;	[BUG]  [BUGGY]  tkn.content.append(  (  int)  readEscape(  c)  )  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  private  Token  simpleTokenLexer(Token  tkn,  int  c)  throws  IOException  {  while  (true)  {  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  break;  }  else  if  (isEndOfFile(c))  {    tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  break;  }  else  if  (isDelimiter(c))  {    tkn.type  =  TOKEN;  break;  }  else  if  (isEscape(c))  {  [BUGGY]  tkn.content.append(  (  int)  readEscape(  c)  )  ;  [BUGGY]  }  else  {  tkn.content.append((char)  c);  }  c  =  in.read();  }  if  (surroundingSpacesIgnored)  {  trimTrailingSpaces(tkn.content);  }  return  tkn;  }    [CLASS]  CSVLexer  [METHOD]  simpleTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c    	[P1_Replace_Type]
[PATCH]  tkn.content.append  (  (  char  )  c  )  ;	[BUG]  [BUGGY]  [FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  private  Token  simpleTokenLexer(Token  tkn,  int  c)  throws  IOException  {  while  (true)  {  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  break;  }  else  if  (isEndOfFile(c))  {    tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  break;  }  else  if  (isDelimiter(c))  {    tkn.type  =  TOKEN;  break;  }  else  if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  {  [BUGGY]  [BUGGY]    }  c  =  in.read();  }  if  (surroundingSpacesIgnored)  {  trimTrailingSpaces(tkn.content);  }  return  tkn;    [CLASS]  CSVLexer  [METHOD]  simpleTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c    	[P14_Delete_Statement]
[PATCH]  tkn.content.append  (  (  char  )  c  )  ;	[BUG]  [BUGGY]  tkn.content.append(  (  char)  readEscape(  c)  )  ;tkn.content.append(  (  char)  c)  ;[FE]  Token  content  expected:<[abc]>  but  was:<[  testNextToken1  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  private  Token  simpleTokenLexer(Token  tkn,  int  c)  throws  IOException  {  while  (true)  {  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  break;  }  else  if  (isEndOfFile(c))  {    tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  break;  }  else  if  (isDelimiter(c))  {    tkn.type  =  TOKEN;  break;  }  else  if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  {  [BUGGY]  tkn.content.append(  (  char)  readEscape(  c)  )  ;tkn.content.append(  (  char)  c)  ;  [BUGGY]  }  c  =  in.read();  }  if  (surroundingSpacesIgnored)  {  trimTrailingSpaces(tkn.content);  }  return  tkn;  }    [CLASS]  CSVLexer  [METHOD]  simpleTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c    	[P11_Insert_Donor_Statement]
[PATCH]  tkn.type  =  TOKEN;	[BUG]  [BUGGY]  tkn.type  =  null  ;[FE]  Token  type  expected:<TOKEN>  but  was:<null>  testNextToken1  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  private  Token  simpleTokenLexer(Token  tkn,  int  c)  throws  IOException  {  while  (true)  {  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  break;  }  else  if  (isEndOfFile(c))  {    tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  break;  }  else  if  (isDelimiter(c))  {    [BUGGY]  tkn.type  =  null  ;  [BUGGY]  break;  }  else  if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  {  tkn.content.append((char)  c);  }  c  =  in.read();  }  if  (surroundingSpacesIgnored)  {  trimTrailingSpaces(tkn.content);  }  return  tkn;  }    [CLASS]  CSVLexer  [METHOD]  simpleTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c    	[P8_Replace_Mix]
[PATCH]  tkn.type  =  TOKEN;	[BUG]  [BUGGY]  tkn.type  =  EORECORD;tkn.type  =  TOKEN;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  private  Token  simpleTokenLexer(Token  tkn,  int  c)  throws  IOException  {  while  (true)  {  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  break;  }  else  if  (isEndOfFile(c))  {    tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  break;  }  else  if  (isDelimiter(c))  {    [BUGGY]  tkn.type  =  EORECORD;tkn.type  =  TOKEN;  [BUGGY]  break;  }  else  if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  {  tkn.content.append((char)  c);  }  c  =  in.read();  }  if  (surroundingSpacesIgnored)  {  trimTrailingSpaces(tkn.content);  }  return  tkn;  }    [CLASS]  CSVLexer  [METHOD]  simpleTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c    	[P11_Insert_Donor_Statement]
[PATCH]  tkn.type  =  TOKEN;	[BUG]  [BUGGY]  tkn.type  =  EOF;tkn.type  =  TOKEN;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  private  Token  simpleTokenLexer(Token  tkn,  int  c)  throws  IOException  {  while  (true)  {  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  break;  }  else  if  (isEndOfFile(c))  {    tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  break;  }  else  if  (isDelimiter(c))  {    [BUGGY]  tkn.type  =  EOF;tkn.type  =  TOKEN;  [BUGGY]  break;  }  else  if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  {  tkn.content.append((char)  c);  }  c  =  in.read();  }  if  (surroundingSpacesIgnored)  {  trimTrailingSpaces(tkn.content);  }  return  tkn;  }    [CLASS]  CSVLexer  [METHOD]  simpleTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c    	[P11_Insert_Donor_Statement]
[PATCH]  tkn.type  =  TOKEN;	[BUG]  [BUGGY]  tkn.isReady  =  true;tkn.type  =  TOKEN;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  private  Token  simpleTokenLexer(Token  tkn,  int  c)  throws  IOException  {  while  (true)  {  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  break;  }  else  if  (isEndOfFile(c))  {    tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  break;  }  else  if  (isDelimiter(c))  {    [BUGGY]  tkn.isReady  =  true;tkn.type  =  TOKEN;  [BUGGY]  break;  }  else  if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  {  tkn.content.append((char)  c);  }  c  =  in.read();  }  if  (surroundingSpacesIgnored)  {  trimTrailingSpaces(tkn.content);  }  return  tkn;  }    [CLASS]  CSVLexer  [METHOD]  simpleTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c    	[P11_Insert_Donor_Statement]
[PATCH]  tkn.type  =  EOF;	[BUG]  [BUGGY]  tkn.type  ;[CE]  not  a  statement  [CONTEXT]  private  Token  simpleTokenLexer(Token  tkn,  int  c)  throws  IOException  {  while  (true)  {  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  break;  }  else  if  (isEndOfFile(c))  {    [BUGGY]  tkn.type  ;  [BUGGY]  tkn.isReady  =  true;  //  There  is  data  at  EOF  break;  }  else  if  (isDelimiter(c))  {    tkn.type  =  TOKEN;  break;  }  else  if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  {  tkn.content.append((char)  c);  }  c  =  in.read();  }  if  (surroundingSpacesIgnored)  {  trimTrailingSpaces(tkn.content);  }  return  tkn;  }    [CLASS]  CSVLexer  [METHOD]  simpleTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c    	[P8_Replace_Mix]
[PATCH]  tkn.type  =  EOF;	[BUG]  [BUGGY]  tkn.type  =  TOKEN;tkn.type  =  EOF;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  private  Token  simpleTokenLexer(Token  tkn,  int  c)  throws  IOException  {  while  (true)  {  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  break;  }  else  if  (isEndOfFile(c))  {    [BUGGY]  tkn.type  =  TOKEN;tkn.type  =  EOF;  [BUGGY]  tkn.isReady  =  true;  //  There  is  data  at  EOF  break;  }  else  if  (isDelimiter(c))  {    tkn.type  =  TOKEN;  break;  }  else  if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  {  tkn.content.append((char)  c);  }  c  =  in.read();  }  if  (surroundingSpacesIgnored)  {  trimTrailingSpaces(tkn.content);  }  return  tkn;  }    [CLASS]  CSVLexer  [METHOD]  simpleTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c    	[P11_Insert_Donor_Statement]
[PATCH]  tkn.type  =  EOF;	[BUG]  [BUGGY]  tkn.type  =  EORECORD;tkn.type  =  EOF;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  private  Token  simpleTokenLexer(Token  tkn,  int  c)  throws  IOException  {  while  (true)  {  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  break;  }  else  if  (isEndOfFile(c))  {    [BUGGY]  tkn.type  =  EORECORD;tkn.type  =  EOF;  [BUGGY]  tkn.isReady  =  true;  //  There  is  data  at  EOF  break;  }  else  if  (isDelimiter(c))  {    tkn.type  =  TOKEN;  break;  }  else  if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  {  tkn.content.append((char)  c);  }  c  =  in.read();  }  if  (surroundingSpacesIgnored)  {  trimTrailingSpaces(tkn.content);  }  return  tkn;  }    [CLASS]  CSVLexer  [METHOD]  simpleTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c    	[P11_Insert_Donor_Statement]
[PATCH]  tkn.isReady  =  true;	[BUG]  [BUGGY]  tkn.isReady  =  false;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  private  Token  simpleTokenLexer(Token  tkn,  int  c)  throws  IOException  {  while  (true)  {  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  break;  }  else  if  (isEndOfFile(c))  {    tkn.type  =  EOF;  [BUGGY]  tkn.isReady  =  false;  [BUGGY]  break;  }  else  if  (isDelimiter(c))  {    tkn.type  =  TOKEN;  break;  }  else  if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  {  tkn.content.append((char)  c);  }  c  =  in.read();  }  if  (surroundingSpacesIgnored)  {  trimTrailingSpaces(tkn.content);  }  return  tkn;  }    [CLASS]  CSVLexer  [METHOD]  simpleTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c    	[P3_Replace_Literal]
[PATCH]  tkn.isReady  =  true;	[BUG]  [BUGGY]  tkn.type  =  TOKEN;tkn.isReady  =  true;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  private  Token  simpleTokenLexer(Token  tkn,  int  c)  throws  IOException  {  while  (true)  {  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  break;  }  else  if  (isEndOfFile(c))  {    tkn.type  =  EOF;  [BUGGY]  tkn.type  =  TOKEN;tkn.isReady  =  true;  [BUGGY]  break;  }  else  if  (isDelimiter(c))  {    tkn.type  =  TOKEN;  break;  }  else  if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  {  tkn.content.append((char)  c);  }  c  =  in.read();  }  if  (surroundingSpacesIgnored)  {  trimTrailingSpaces(tkn.content);  }  return  tkn;  }    [CLASS]  CSVLexer  [METHOD]  simpleTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c    	[P11_Insert_Donor_Statement]
[PATCH]  tkn.type  =  TOKEN;	[BUG]  [BUGGY]  tkn.type  =  3;[CE]  incompatible  types  [CONTEXT]  private  Token  simpleTokenLexer(Token  tkn,  int  c)  throws  IOException  {  while  (true)  {  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  break;  }  else  if  (isEndOfFile(c))  {    tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  break;  }  else  if  (isDelimiter(c))  {    [BUGGY]  tkn.type  =  3;  [BUGGY]  break;  }  else  if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  {  tkn.content.append((char)  c);  }  c  =  in.read();  }  if  (surroundingSpacesIgnored)  {  trimTrailingSpaces(tkn.content);  }  return  tkn;  }    [CLASS]  CSVLexer  [METHOD]  simpleTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c    	[P5_Replace_Variable]
[PATCH]  tkn.type  =  TOKEN;	[BUG]  [BUGGY]  tkn.type  ;[CE]  not  a  statement  [CONTEXT]  private  Token  simpleTokenLexer(Token  tkn,  int  c)  throws  IOException  {  while  (true)  {  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  break;  }  else  if  (isEndOfFile(c))  {    tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  break;  }  else  if  (isDelimiter(c))  {    [BUGGY]  tkn.type  ;  [BUGGY]  break;  }  else  if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  {  tkn.content.append((char)  c);  }  c  =  in.read();  }  if  (surroundingSpacesIgnored)  {  trimTrailingSpaces(tkn.content);  }  return  tkn;  }    [CLASS]  CSVLexer  [METHOD]  simpleTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c    	[P8_Replace_Mix]
[PATCH]  tkn.content.append  (  (  char  )  readEscape  (  c  )  )  ;	[BUG]  [BUGGY]  tkn.content.append(  (  String)  readEscape(  c)  )  ;[CE]  inconvertible  types  [CONTEXT]  private  Token  simpleTokenLexer(Token  tkn,  int  c)  throws  IOException  {  while  (true)  {  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  break;  }  else  if  (isEndOfFile(c))  {    tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  break;  }  else  if  (isDelimiter(c))  {    tkn.type  =  TOKEN;  break;  }  else  if  (isEscape(c))  {  [BUGGY]  tkn.content.append(  (  String)  readEscape(  c)  )  ;  [BUGGY]  }  else  {  tkn.content.append((char)  c);  }  c  =  in.read();  }  if  (surroundingSpacesIgnored)  {  trimTrailingSpaces(tkn.content);  }  return  tkn;  }    [CLASS]  CSVLexer  [METHOD]  simpleTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c    	[P1_Replace_Type]
[PATCH]  tkn.type  =  EORECORD;	[BUG]  [BUGGY]  tkn.type  ;[CE]  not  a  statement  [CONTEXT]  private  Token  simpleTokenLexer(Token  tkn,  int  c)  throws  IOException  {  while  (true)  {  if  (isEndOfLine(c))  {    [BUGGY]  tkn.type  ;  [BUGGY]  break;  }  else  if  (isEndOfFile(c))  {    tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  break;  }  else  if  (isDelimiter(c))  {    tkn.type  =  TOKEN;  break;  }  else  if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  {  tkn.content.append((char)  c);  }  c  =  in.read();  }  if  (surroundingSpacesIgnored)  {  trimTrailingSpaces(tkn.content);  }  return  tkn;  }    [CLASS]  CSVLexer  [METHOD]  simpleTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c    	[P8_Replace_Mix]
[PATCH]  tkn.type  =  EORECORD;	[BUG]  [BUGGY]  tkn.type  =  TOKEN;tkn.type  =  EORECORD;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  private  Token  simpleTokenLexer(Token  tkn,  int  c)  throws  IOException  {  while  (true)  {  if  (isEndOfLine(c))  {    [BUGGY]  tkn.type  =  TOKEN;tkn.type  =  EORECORD;  [BUGGY]  break;  }  else  if  (isEndOfFile(c))  {    tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  break;  }  else  if  (isDelimiter(c))  {    tkn.type  =  TOKEN;  break;  }  else  if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  {  tkn.content.append((char)  c);  }  c  =  in.read();  }  if  (surroundingSpacesIgnored)  {  trimTrailingSpaces(tkn.content);  }  return  tkn;  }    [CLASS]  CSVLexer  [METHOD]  simpleTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c    	[P11_Insert_Donor_Statement]
[PATCH]  tkn.type  =  EORECORD;	[BUG]  [BUGGY]  tkn.type  =  EOF;tkn.type  =  EORECORD;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  private  Token  simpleTokenLexer(Token  tkn,  int  c)  throws  IOException  {  while  (true)  {  if  (isEndOfLine(c))  {    [BUGGY]  tkn.type  =  EOF;tkn.type  =  EORECORD;  [BUGGY]  break;  }  else  if  (isEndOfFile(c))  {    tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  break;  }  else  if  (isDelimiter(c))  {    tkn.type  =  TOKEN;  break;  }  else  if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  {  tkn.content.append((char)  c);  }  c  =  in.read();  }  if  (surroundingSpacesIgnored)  {  trimTrailingSpaces(tkn.content);  }  return  tkn;  }    [CLASS]  CSVLexer  [METHOD]  simpleTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c    	[P11_Insert_Donor_Statement]
[PATCH]  tkn.type  =  TOKEN;	[BUG]  [BUGGY]  tkn.type  =  tkn.type  ;[FE]  Token  type  expected:<TOKEN>  but  was:<EOF>  testNextToken1  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  private  Token  simpleTokenLexer(Token  tkn,  int  c)  throws  IOException  {  while  (true)  {  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  break;  }  else  if  (isEndOfFile(c))  {    tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  break;  }  else  if  (isDelimiter(c))  {    [BUGGY]  tkn.type  =  tkn.type  ;  [BUGGY]  break;  }  else  if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  {  tkn.content.append((char)  c);  }  c  =  in.read();  }  if  (surroundingSpacesIgnored)  {  trimTrailingSpaces(tkn.content);  }  return  tkn;  }    [CLASS]  CSVLexer  [METHOD]  simpleTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c    	[P8_Replace_Mix]
[PATCH]  c  =  in.read  (  )  ;	[BUG]  [BUGGY]  c  =  in.readLine(  )  ;[CE]  incompatible  types  [CONTEXT]  private  Token  simpleTokenLexer(Token  tkn,  int  c)  throws  IOException  {  while  (true)  {  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  break;  }  else  if  (isEndOfFile(c))  {    tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  break;  }  else  if  (isDelimiter(c))  {    tkn.type  =  TOKEN;  break;  }  else  if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  {  tkn.content.append((char)  c);  }  [BUGGY]  c  =  in.readLine(  )  ;  [BUGGY]  }  if  (surroundingSpacesIgnored)  {  trimTrailingSpaces(tkn.content);  }  return  tkn;  }    [CLASS]  CSVLexer  [METHOD]  simpleTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c    	[P7_Replace_Invocation]
[PATCH]  c  =  in.read  (  )  ;	[BUG]  [BUGGY]  c  =  c  ;[FE]  [CONTEXT]  private  Token  simpleTokenLexer(Token  tkn,  int  c)  throws  IOException  {  while  (true)  {  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  break;  }  else  if  (isEndOfFile(c))  {    tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  break;  }  else  if  (isDelimiter(c))  {    tkn.type  =  TOKEN;  break;  }  else  if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  {  tkn.content.append((char)  c);  }  [BUGGY]  c  =  c  ;  [BUGGY]  }  if  (surroundingSpacesIgnored)  {  trimTrailingSpaces(tkn.content);  }  return  tkn;  }    [CLASS]  CSVLexer  [METHOD]  simpleTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c    	[P8_Replace_Mix]
[PATCH]  c  =  in.read  (  )  ;	[BUG]  [BUGGY]  c  =  in.readAgain(  )  ;c  =  in.read(  )  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  private  Token  simpleTokenLexer(Token  tkn,  int  c)  throws  IOException  {  while  (true)  {  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  break;  }  else  if  (isEndOfFile(c))  {    tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  break;  }  else  if  (isDelimiter(c))  {    tkn.type  =  TOKEN;  break;  }  else  if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  {  tkn.content.append((char)  c);  }  [BUGGY]  c  =  in.readAgain(  )  ;c  =  in.read(  )  ;  [BUGGY]  }  if  (surroundingSpacesIgnored)  {  trimTrailingSpaces(tkn.content);  }  return  tkn;  }    [CLASS]  CSVLexer  [METHOD]  simpleTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c    	[P11_Insert_Donor_Statement]
[PATCH]  c  =  in.read  (  )  ;	[BUG]  [BUGGY]  c  =  1.read(  )  ;[CE]  ';'  expected  [CONTEXT]  private  Token  simpleTokenLexer(Token  tkn,  int  c)  throws  IOException  {  while  (true)  {  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  break;  }  else  if  (isEndOfFile(c))  {    tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  break;  }  else  if  (isDelimiter(c))  {    tkn.type  =  TOKEN;  break;  }  else  if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  {  tkn.content.append((char)  c);  }  [BUGGY]  c  =  1.read(  )  ;  [BUGGY]  }  if  (surroundingSpacesIgnored)  {  trimTrailingSpaces(tkn.content);  }  return  tkn;  }    [CLASS]  CSVLexer  [METHOD]  simpleTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c    	[P5_Replace_Variable]
[PATCH]  c  =  in.read  (  )  ;	[BUG]  [BUGGY]  [FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  private  Token  simpleTokenLexer(Token  tkn,  int  c)  throws  IOException  {  while  (true)  {  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  break;  }  else  if  (isEndOfFile(c))  {    tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  break;  }  else  if  (isDelimiter(c))  {    tkn.type  =  TOKEN;  break;  }  else  if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  {  tkn.content.append((char)  c);  }  [BUGGY]  [BUGGY]    }  if  (surroundingSpacesIgnored)  {  trimTrailingSpaces(tkn.content);  }  return  tkn;    [CLASS]  CSVLexer  [METHOD]  simpleTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c    	[P14_Delete_Statement]
[PATCH]  c  =  in.read  (  )  ;	[BUG]  [BUGGY]  int  lastChar  =  in.readAgain(  )  ;c  =  in.read(  )  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  private  Token  simpleTokenLexer(Token  tkn,  int  c)  throws  IOException  {  while  (true)  {  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  break;  }  else  if  (isEndOfFile(c))  {    tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  break;  }  else  if  (isDelimiter(c))  {    tkn.type  =  TOKEN;  break;  }  else  if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  {  tkn.content.append((char)  c);  }  [BUGGY]  int  lastChar  =  in.readAgain(  )  ;c  =  in.read(  )  ;  [BUGGY]  }  if  (surroundingSpacesIgnored)  {  trimTrailingSpaces(tkn.content);  }  return  tkn;  }    [CLASS]  CSVLexer  [METHOD]  simpleTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c    	[P11_Insert_Donor_Statement]
[PATCH]  c  =  in.read  (  )  ;	[BUG]  [BUGGY]  int  c  =  in.read(  )  ;c  =  in.read(  )  ;[CE]  variable  c  is  already  defined  in  method  simpleTokenLexer(Token,int)  [CONTEXT]  private  Token  simpleTokenLexer(Token  tkn,  int  c)  throws  IOException  {  while  (true)  {  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  break;  }  else  if  (isEndOfFile(c))  {    tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  break;  }  else  if  (isDelimiter(c))  {    tkn.type  =  TOKEN;  break;  }  else  if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  {  tkn.content.append((char)  c);  }  [BUGGY]  int  c  =  in.read(  )  ;c  =  in.read(  )  ;  [BUGGY]  }  if  (surroundingSpacesIgnored)  {  trimTrailingSpaces(tkn.content);  }  return  tkn;  }    [CLASS]  CSVLexer  [METHOD]  simpleTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c    	[P11_Insert_Donor_Statement]
[PATCH]  c  =  in.read  (  )  ;	[BUG]  [BUGGY]  in.readLine(  )  ;c  =  in.read(  )  ;[FE]  Token  type  expected:<TOKEN>  but  was:<EOF>  testNextToken1  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  private  Token  simpleTokenLexer(Token  tkn,  int  c)  throws  IOException  {  while  (true)  {  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  break;  }  else  if  (isEndOfFile(c))  {    tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  break;  }  else  if  (isDelimiter(c))  {    tkn.type  =  TOKEN;  break;  }  else  if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  {  tkn.content.append((char)  c);  }  [BUGGY]  in.readLine(  )  ;c  =  in.read(  )  ;  [BUGGY]  }  if  (surroundingSpacesIgnored)  {  trimTrailingSpaces(tkn.content);  }  return  tkn;  }    [CLASS]  CSVLexer  [METHOD]  simpleTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c    	[P11_Insert_Donor_Statement]
[PATCH]  }  else  if  (  isEndOfFile  (  c  )  )  {	[BUG]  [BUGGY]  }  if  (  isEndOfLine(  c)  )  {[FE]  [CONTEXT]  private  Token  simpleTokenLexer(Token  tkn,  int  c)  throws  IOException  {  while  (true)  {  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  break;  [BUGGY]  }  if  (  isEndOfLine(  c)  )  {  [BUGGY]    tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  break;  }  else  if  (isDelimiter(c))  {    tkn.type  =  TOKEN;  break;  }  else  if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  {  tkn.content.append((char)  c);  }  c  =  in.read();  }  if  (surroundingSpacesIgnored)  {  trimTrailingSpaces(tkn.content);  }  return  tkn;  }    [CLASS]  CSVLexer  [METHOD]  simpleTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c    	[P8_Replace_Mix]
[PATCH]  tkn.type  =  EOF;	[BUG]  [BUGGY]  tkn.type  =  tkn.type  ;[FE]  [CONTEXT]  private  Token  simpleTokenLexer(Token  tkn,  int  c)  throws  IOException  {  while  (true)  {  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  break;  }  else  if  (isEndOfFile(c))  {    [BUGGY]  tkn.type  =  tkn.type  ;  [BUGGY]  tkn.isReady  =  true;  //  There  is  data  at  EOF  break;  }  else  if  (isDelimiter(c))  {    tkn.type  =  TOKEN;  break;  }  else  if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  {  tkn.content.append((char)  c);  }  c  =  in.read();  }  if  (surroundingSpacesIgnored)  {  trimTrailingSpaces(tkn.content);  }  return  tkn;  }    [CLASS]  CSVLexer  [METHOD]  simpleTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c    	[P8_Replace_Mix]
[PATCH]  tkn.type  =  EORECORD;	[BUG]  [BUGGY]  tkn.type  =  null  ;[FE]  Token  type  expected:<EORECORD>  but  was:<null>  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  private  Token  simpleTokenLexer(Token  tkn,  int  c)  throws  IOException  {  while  (true)  {  if  (isEndOfLine(c))  {    [BUGGY]  tkn.type  =  null  ;  [BUGGY]  break;  }  else  if  (isEndOfFile(c))  {    tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  break;  }  else  if  (isDelimiter(c))  {    tkn.type  =  TOKEN;  break;  }  else  if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  {  tkn.content.append((char)  c);  }  c  =  in.read();  }  if  (surroundingSpacesIgnored)  {  trimTrailingSpaces(tkn.content);  }  return  tkn;  }    [CLASS]  CSVLexer  [METHOD]  simpleTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c    	[P8_Replace_Mix]
[PATCH]  tkn.type  =  EOF;	[BUG]  [BUGGY]  tkn.type  =  null;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  private  Token  simpleTokenLexer(Token  tkn,  int  c)  throws  IOException  {  while  (true)  {  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  break;  }  else  if  (isEndOfFile(c))  {    [BUGGY]  tkn.type  =  null;  [BUGGY]  tkn.isReady  =  true;  //  There  is  data  at  EOF  break;  }  else  if  (isDelimiter(c))  {    tkn.type  =  TOKEN;  break;  }  else  if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  {  tkn.content.append((char)  c);  }  c  =  in.read();  }  if  (surroundingSpacesIgnored)  {  trimTrailingSpaces(tkn.content);  }  return  tkn;  }    [CLASS]  CSVLexer  [METHOD]  simpleTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c    	[P5_Replace_Variable]
[PATCH]  c  =  in.read  (  )  ;	[BUG]  [BUGGY]  c  ;[CE]  not  a  statement  [CONTEXT]  private  Token  simpleTokenLexer(Token  tkn,  int  c)  throws  IOException  {  while  (true)  {  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  break;  }  else  if  (isEndOfFile(c))  {    tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  break;  }  else  if  (isDelimiter(c))  {    tkn.type  =  TOKEN;  break;  }  else  if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  {  tkn.content.append((char)  c);  }  [BUGGY]  c  ;  [BUGGY]  }  if  (surroundingSpacesIgnored)  {  trimTrailingSpaces(tkn.content);  }  return  tkn;  }    [CLASS]  CSVLexer  [METHOD]  simpleTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c    	[P8_Replace_Mix]
[PATCH]  if  (  surroundingSpacesIgnored  )  {  trimTrailingSpaces  (  tkn.content  )  ;  }	[BUG]  [BUGGY]  trimTrailingSpaces(tkn.content);[CE]  illegal  start  of  expression  [CONTEXT]  private  Token  simpleTokenLexer(Token  tkn,  int  c)  throws  IOException  {  while  (true)  {  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  break;  }  else  if  (isEndOfFile(c))  {    tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  break;  }  else  if  (isDelimiter(c))  {    tkn.type  =  TOKEN;  break;  }  else  if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  {  tkn.content.append((char)  c);  }  c  =  in.read();  }  [BUGGY]  trimTrailingSpaces(tkn.content);  [BUGGY]    trimTrailingSpaces(tkn.content);    return  tkn;    [CLASS]  CSVLexer  [METHOD]  simpleTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c    	[P15_Unwrap_Block]
[PATCH]  if  (  surroundingSpacesIgnored  )  {  trimTrailingSpaces  (  tkn.content  )  ;  }	[BUG]  [BUGGY]  [CE]  illegal  start  of  expression  [CONTEXT]  private  Token  simpleTokenLexer(Token  tkn,  int  c)  throws  IOException  {  while  (true)  {  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  break;  }  else  if  (isEndOfFile(c))  {    tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  break;  }  else  if  (isDelimiter(c))  {    tkn.type  =  TOKEN;  break;  }  else  if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  {  tkn.content.append((char)  c);  }  c  =  in.read();  }  [BUGGY]  [BUGGY]      return  tkn;    [CLASS]  CSVLexer  [METHOD]  simpleTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c    	[P16_Remove_Block]
[PATCH]  trimTrailingSpaces  (  tkn.content  )  ;	[BUG]  [BUGGY]  isEncapsulator(  tkn.content)  ;[CE]  method  isEncapsulator  in  class  Lexer  cannot  be  applied  to  given  types;  [CONTEXT]  private  Token  simpleTokenLexer(Token  tkn,  int  c)  throws  IOException  {  while  (true)  {  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  break;  }  else  if  (isEndOfFile(c))  {    tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  break;  }  else  if  (isDelimiter(c))  {    tkn.type  =  TOKEN;  break;  }  else  if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  {  tkn.content.append((char)  c);  }  c  =  in.read();  }  if  (surroundingSpacesIgnored)  {  [BUGGY]  isEncapsulator(  tkn.content)  ;  [BUGGY]  }  return  tkn;  }    [CLASS]  CSVLexer  [METHOD]  simpleTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c    	[P7_Replace_Invocation]
[PATCH]  trimTrailingSpaces  (  tkn.content  )  ;	[BUG]  [BUGGY]  [FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  private  Token  simpleTokenLexer(Token  tkn,  int  c)  throws  IOException  {  while  (true)  {  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  break;  }  else  if  (isEndOfFile(c))  {    tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  break;  }  else  if  (isDelimiter(c))  {    tkn.type  =  TOKEN;  break;  }  else  if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  {  tkn.content.append((char)  c);  }  c  =  in.read();  }  if  (surroundingSpacesIgnored)  {  [BUGGY]  [BUGGY]    }  return  tkn;    [CLASS]  CSVLexer  [METHOD]  simpleTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c    	[P14_Delete_Statement]
[PATCH]  int  startLineNumber  =  getLineNumber  (  )  ;	[BUG]  [BUGGY]  short  startLineNumber  =  getLineNumber(  )  ;[CE]  possible  loss  of  precision  [CONTEXT]                            private  Token  encapsulatedTokenLexer(Token  tkn,  int  c)  throws  IOException  {    [BUGGY]  short  startLineNumber  =  getLineNumber(  )  ;  [BUGGY]      while  (true)  {  c  =  in.read();  if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  if  (isEncapsulator(c))  {  if  (isEncapsulator(in.lookAhead()))  {    c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P1_Replace_Type]
[PATCH]  int  startLineNumber  =  getLineNumber  (  )  ;	[BUG]  [BUGGY]  [FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]                            private  Token  encapsulatedTokenLexer(Token  tkn,  int  c)  throws  IOException  {    [BUGGY]  [BUGGY]        while  (true)  {  c  =  in.read();  if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  if  (isEncapsulator(c))  {  if  (isEncapsulator(in.lookAhead()))  {    c  =  in.read();  tkn.content.append((char)  c);  }  else  {      [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P14_Delete_Statement]
[PATCH]  while  (  true  )  {	[BUG]  [BUGGY]  while  (  false)  {[CE]  unreachable  statement  [CONTEXT]                      private  Token  encapsulatedTokenLexer(Token  tkn,  int  c)  throws  IOException  {    int  startLineNumber  =  getLineNumber();      [BUGGY]  while  (  false)  {  [BUGGY]  c  =  in.read();  if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  if  (isEncapsulator(c))  {  if  (isEncapsulator(in.lookAhead()))  {    c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P3_Replace_Literal]
[PATCH]  while  (  true  )  {	[BUG]  [BUGGY]  while  (  false)  {[CE]  unreachable  statement  [CONTEXT]  int  startLineNumber  =  getLineNumber();      while  (true)  {  c  =  in.read();  if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  if  (isEncapsulator(c))  {  if  (isEncapsulator(in.lookAhead()))  {    c  =  in.read();  tkn.content.append((char)  c);  }  else  {    [BUGGY]  while  (  false)  {  [BUGGY]  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {    throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P3_Replace_Literal]
[PATCH]  if  (  isDelimiter  (  c  )  )  {	[BUG]  [BUGGY]  if  (  isDelimiter(  startLineNumber)  )  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]    while  (true)  {  c  =  in.read();  if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  if  (isEncapsulator(c))  {  if  (isEncapsulator(in.lookAhead()))  {    c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {  c  =  in.read();  [BUGGY]  if  (  isDelimiter(  startLineNumber)  )  {  [BUGGY]  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {    throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P5_Replace_Variable]
[PATCH]  if  (  isDelimiter  (  c  )  )  {	[BUG]  [BUGGY]  if  (   "(  line   "  +  getLineNumber(  ))  {[CE]  incompatible  types  [CONTEXT]    while  (true)  {  c  =  in.read();  if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  if  (isEncapsulator(c))  {  if  (isEncapsulator(in.lookAhead()))  {    c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {  c  =  in.read();  [BUGGY]  if  (   "(  line   "  +  getLineNumber(  ))  {  [BUGGY]  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {    throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P6_Replace_Expression]
[PATCH]  if  (  isDelimiter  (  c  )  )  {	[BUG]  [BUGGY]  if  (  isEscape(  c)  )  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]    while  (true)  {  c  =  in.read();  if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  if  (isEncapsulator(c))  {  if  (isEncapsulator(in.lookAhead()))  {    c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {  c  =  in.read();  [BUGGY]  if  (  isEscape(  c)  )  {  [BUGGY]  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {    throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P7_Replace_Invocation]
[PATCH]  }  else  if  (  isEndOfFile  (  c  )  )  {	[BUG]  [BUGGY]  }  else  if  (  isEndOfFile(  startLineNumber)  )  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  if  (isEncapsulator(c))  {  if  (isEncapsulator(in.lookAhead()))  {    c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  [BUGGY]  }  else  if  (  isEndOfFile(  startLineNumber)  )  {  [BUGGY]  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {    throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }  }  else  if  (isEndOfFile(c))  {      [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P5_Replace_Variable]
[PATCH]  }  else  if  (  isEndOfFile  (  c  )  )  {	[BUG]  [BUGGY]  }  else  if  (   "(  line   "  +  getLineNumber(  ))  {[CE]  incompatible  types  [CONTEXT]  if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  if  (isEncapsulator(c))  {  if  (isEncapsulator(in.lookAhead()))  {    c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  [BUGGY]  }  else  if  (   "(  line   "  +  getLineNumber(  ))  {  [BUGGY]  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {    throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }  }  else  if  (isEndOfFile(c))  {      [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P6_Replace_Expression]
[PATCH]  }  else  if  (  isEndOfFile  (  c  )  )  {	[BUG]  [BUGGY]  }  else  {[CE]  'else'  without  'if'  [CONTEXT]  if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  if  (isEncapsulator(c))  {  if  (isEncapsulator(in.lookAhead()))  {    c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  [BUGGY]  }  else  {  [BUGGY]  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {    throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }  }  else  if  (isEndOfFile(c))  {      [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P6_Replace_Expression]
[PATCH]  }  else  if  (  isEndOfFile  (  c  )  )  {	[BUG]  [BUGGY]  }  else  if  (  isEndOfLine(  c)  )  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  if  (isEncapsulator(c))  {  if  (isEncapsulator(in.lookAhead()))  {    c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  [BUGGY]  }  else  if  (  isEndOfLine(  c)  )  {  [BUGGY]  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {    throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }  }  else  if  (isEndOfFile(c))  {      [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P7_Replace_Invocation]
[PATCH]  }  else  if  (  isEndOfFile  (  c  )  )  {	[BUG]  [BUGGY]  }  else  if  (  isDelimiter(  c)  )  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  if  (isEncapsulator(c))  {  if  (isEncapsulator(in.lookAhead()))  {    c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  [BUGGY]  }  else  if  (  isDelimiter(  c)  )  {  [BUGGY]  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {    throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }  }  else  if  (isEndOfFile(c))  {      [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P9_Replace_Statement]
[PATCH]  }  else  if  (  isEndOfLine  (  c  )  )  {	[BUG]  [BUGGY]  }  else  if  (  isEndOfLine(  startLineNumber)  )  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  if  (isEncapsulator(in.lookAhead()))  {    c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  [BUGGY]  }  else  if  (  isEndOfLine(  startLineNumber)  )  {  [BUGGY]    tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {    throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }  }  else  if  (isEndOfFile(c))  {    throw  new  IOException( "(startline   "  +  startLineNumber  +   ")  EOF  reached  before  encapsulated  token  finished ");  }  else  {    tkn.content.append((char)  c);    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P5_Replace_Variable]
[PATCH]  }  else  if  (  isEndOfLine  (  c  )  )  {	[BUG]  [BUGGY]  }  else  if  (   "(  line   "  +  getLineNumber(  ))  {[CE]  incompatible  types  [CONTEXT]  if  (isEncapsulator(in.lookAhead()))  {    c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  [BUGGY]  }  else  if  (   "(  line   "  +  getLineNumber(  ))  {  [BUGGY]    tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {    throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }  }  else  if  (isEndOfFile(c))  {    throw  new  IOException( "(startline   "  +  startLineNumber  +   ")  EOF  reached  before  encapsulated  token  finished ");  }  else  {    tkn.content.append((char)  c);    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P6_Replace_Expression]
[PATCH]  }  else  if  (  isEndOfLine  (  c  )  )  {	[BUG]  [BUGGY]  }  else  {[CE]  'else'  without  'if'  [CONTEXT]  if  (isEncapsulator(in.lookAhead()))  {    c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  [BUGGY]  }  else  {  [BUGGY]    tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {    throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }  }  else  if  (isEndOfFile(c))  {    throw  new  IOException( "(startline   "  +  startLineNumber  +   ")  EOF  reached  before  encapsulated  token  finished ");  }  else  {    tkn.content.append((char)  c);    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P6_Replace_Expression]
[PATCH]  }  else  if  (  isEndOfLine  (  c  )  )  {	[BUG]  [BUGGY]  }  else  if  (  isEndOfFile(  c)  )  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  if  (isEncapsulator(in.lookAhead()))  {    c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  [BUGGY]  }  else  if  (  isEndOfFile(  c)  )  {  [BUGGY]    tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {    throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }  }  else  if  (isEndOfFile(c))  {    throw  new  IOException( "(startline   "  +  startLineNumber  +   ")  EOF  reached  before  encapsulated  token  finished ");  }  else  {    tkn.content.append((char)  c);    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P7_Replace_Invocation]
[PATCH]  }  else  if  (  isEndOfLine  (  c  )  )  {	[BUG]  [BUGGY]  }  else  if  (  isDelimiter(  c)  )  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  if  (isEncapsulator(in.lookAhead()))  {    c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  [BUGGY]  }  else  if  (  isDelimiter(  c)  )  {  [BUGGY]    tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {    throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }  }  else  if  (isEndOfFile(c))  {    throw  new  IOException( "(startline   "  +  startLineNumber  +   ")  EOF  reached  before  encapsulated  token  finished ");  }  else  {    tkn.content.append((char)  c);    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P9_Replace_Statement]
[PATCH]  }  else  if  (  !isWhitespace  (  c  )  )  {	[BUG]  [BUGGY]  }  else  if  (  !isWhitespace(  startLineNumber)  )  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  }  else  {    while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  return  tkn;  [BUGGY]  }  else  if  (  !isWhitespace(  startLineNumber)  )  {  [BUGGY]    throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }  }  else  if  (isEndOfFile(c))  {    throw  new  IOException( "(startline   "  +  startLineNumber  +   ")  EOF  reached  before  encapsulated  token  finished ");  }  else  {    tkn.content.append((char)  c);  }  }  }      [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P5_Replace_Variable]
[PATCH]  }  else  if  (  !isWhitespace  (  c  )  )  {	[BUG]  [BUGGY]  }  else  if  (   "(  line   "  +  getLineNumber(  ))  {[CE]  incompatible  types  [CONTEXT]  }  else  {    while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  return  tkn;  [BUGGY]  }  else  if  (   "(  line   "  +  getLineNumber(  ))  {  [BUGGY]    throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }  }  else  if  (isEndOfFile(c))  {    throw  new  IOException( "(startline   "  +  startLineNumber  +   ")  EOF  reached  before  encapsulated  token  finished ");  }  else  {    tkn.content.append((char)  c);  }  }  }      [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P6_Replace_Expression]
[PATCH]  }  else  if  (  !isWhitespace  (  c  )  )  {	[BUG]  [BUGGY]  }  else  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  }  else  {    while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  return  tkn;  [BUGGY]  }  else  {  [BUGGY]    throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }  }  else  if  (isEndOfFile(c))  {    throw  new  IOException( "(startline   "  +  startLineNumber  +   ")  EOF  reached  before  encapsulated  token  finished ");  }  else  {    tkn.content.append((char)  c);  }  }  }      [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P6_Replace_Expression]
[PATCH]  }  else  if  (  !isWhitespace  (  c  )  )  {	[BUG]  [BUGGY]  }  else  if  (  !isEscape(  c)  )  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  }  else  {    while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  return  tkn;  [BUGGY]  }  else  if  (  !isEscape(  c)  )  {  [BUGGY]    throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }  }  else  if  (isEndOfFile(c))  {    throw  new  IOException( "(startline   "  +  startLineNumber  +   ")  EOF  reached  before  encapsulated  token  finished ");  }  else  {    tkn.content.append((char)  c);  }  }  }      [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P7_Replace_Invocation]
[PATCH]  }  else  if  (  !isWhitespace  (  c  )  )  {	[BUG]  [BUGGY]  }  if  (  !isWhitespace(  startLineNumber)  )  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  }  else  {    while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  return  tkn;  [BUGGY]  }  if  (  !isWhitespace(  startLineNumber)  )  {  [BUGGY]    throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }  }  else  if  (isEndOfFile(c))  {    throw  new  IOException( "(startline   "  +  startLineNumber  +   ")  EOF  reached  before  encapsulated  token  finished ");  }  else  {    tkn.content.append((char)  c);  }  }  }      [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P8_Replace_Mix]
[PATCH]  }  else  if  (  !isWhitespace  (  c  )  )  {	[BUG]  [BUGGY]  }  else  if  (  isDelimiter(  c)  )  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  }  else  {    while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  return  tkn;  [BUGGY]  }  else  if  (  isDelimiter(  c)  )  {  [BUGGY]    throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }  }  else  if  (isEndOfFile(c))  {    throw  new  IOException( "(startline   "  +  startLineNumber  +   ")  EOF  reached  before  encapsulated  token  finished ");  }  else  {    tkn.content.append((char)  c);  }  }  }      [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P9_Replace_Statement]
[PATCH]  }  else  if  (  !isWhitespace  (  c  )  )  {	[BUG]  [BUGGY]  }  else  if  (  isEndOfFile(  c)  )  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  }  else  {    while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  return  tkn;  [BUGGY]  }  else  if  (  isEndOfFile(  c)  )  {  [BUGGY]    throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }  }  else  if  (isEndOfFile(c))  {    throw  new  IOException( "(startline   "  +  startLineNumber  +   ")  EOF  reached  before  encapsulated  token  finished ");  }  else  {    tkn.content.append((char)  c);  }  }  }      [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P9_Replace_Statement]
[PATCH]  }  else  if  (  !isWhitespace  (  c  )  )  {	[BUG]  [BUGGY]  }  else  if  (  isEndOfLine(  c)  )  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  }  else  {    while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  return  tkn;  [BUGGY]  }  else  if  (  isEndOfLine(  c)  )  {  [BUGGY]    throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }  }  else  if  (isEndOfFile(c))  {    throw  new  IOException( "(startline   "  +  startLineNumber  +   ")  EOF  reached  before  encapsulated  token  finished ");  }  else  {    tkn.content.append((char)  c);  }  }  }      [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P9_Replace_Statement]
[PATCH]  }  else  if  (  !isWhitespace  (  c  )  )  {	[BUG]  [BUGGY]  }  else  if  (  isEscape(  c)  )  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  }  else  {    while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  return  tkn;  [BUGGY]  }  else  if  (  isEscape(  c)  )  {  [BUGGY]    throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }  }  else  if  (isEndOfFile(c))  {    throw  new  IOException( "(startline   "  +  startLineNumber  +   ")  EOF  reached  before  encapsulated  token  finished ");  }  else  {    tkn.content.append((char)  c);  }  }  }      [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P9_Replace_Statement]
[PATCH]  }  else  if  (  !isWhitespace  (  c  )  )  {	[BUG]  [BUGGY]  }  else  if  (  isEncapsulator(  c)  )  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  }  else  {    while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  return  tkn;  [BUGGY]  }  else  if  (  isEncapsulator(  c)  )  {  [BUGGY]    throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }  }  else  if  (isEndOfFile(c))  {    throw  new  IOException( "(startline   "  +  startLineNumber  +   ")  EOF  reached  before  encapsulated  token  finished ");  }  else  {    tkn.content.append((char)  c);  }  }  }      [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P9_Replace_Statement]
[PATCH]  }  else  if  (  !isWhitespace  (  c  )  )  {  throw  new  IOException  ( "   ")  ;  }	[BUG]  [BUGGY]  throw  new  java.io.IOException((( "(line   "  +(getLineNumber()))  +   ")  invalid  char  between  encapsulated  token  and  delimiter "));[CE]  'else'  without  'if'  [CONTEXT]  }  else  {    while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  return  tkn;  [BUGGY]  throw  new  java.io.IOException((( "(line   "  +(getLineNumber()))  +   ")  invalid  char  between  encapsulated  token  and  delimiter "));  [BUGGY]    throw  new  java.io.IOException((( "(line   "  +  (getLineNumber()))  +   ")  invalid  char  between  encapsulated  token  and  delimiter "));    }  }  }  else  if  (isEndOfFile(c))  {    throw  new  IOException( "(startline   "  +  startLineNumber  +   ")  EOF  reached  before  encapsulated  token  finished ");  }  else  {    tkn.content.append((char)  c);  }  }  }    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P15_Unwrap_Block]
[PATCH]  }  else  if  (  !isWhitespace  (  c  )  )  {  throw  new  IOException  ( "   ")  ;  }	[BUG]  [BUGGY]  [CE]  'else'  without  'if'  [CONTEXT]  }  else  {    while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  return  tkn;  [BUGGY]  [BUGGY]      }  }  }  else  if  (isEndOfFile(c))  {    throw  new  IOException( "(startline   "  +  startLineNumber  +   ")  EOF  reached  before  encapsulated  token  finished ");  }  else  {    tkn.content.append((char)  c);  }  }  }    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P16_Remove_Block]
[PATCH]  throw  new  IOException  ( "   ")  ;	[BUG]  [BUGGY]  return  ;[CE]  missing  return  value  [CONTEXT]  while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {    [BUGGY]  return  ;  [BUGGY]  }  }  }  }  else  if  (isEndOfFile(c))  {    throw  new  IOException( "(startline   "  +  startLineNumber  +   ")  EOF  reached  before  encapsulated  token  finished ");  }  else  {    tkn.content.append((char)  c);  }  }  }  }    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P8_Replace_Mix]
[PATCH]  throw  new  IOException  ( "   ")  ;	[BUG]  [BUGGY]  [FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {    [BUGGY]  [BUGGY]    }  }  }  }  else  if  (isEndOfFile(c))  {    throw  new  IOException( "(startline   "  +  startLineNumber  +   ")  EOF  reached  before  encapsulated  token  finished ");  }  else  {    tkn.content.append((char)  c);  }  }  }  }    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P14_Delete_Statement]
[PATCH]  }  else  if  (  !isWhitespace  (  c  )  )  {	[BUG]  [BUGGY]  }  else  if  (  !isEscape(  startLineNumber)  )  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  }  else  {    while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  return  tkn;  [BUGGY]  }  else  if  (  !isEscape(  startLineNumber)  )  {  [BUGGY]    throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }  }  else  if  (isEndOfFile(c))  {    throw  new  IOException( "(startline   "  +  startLineNumber  +   ")  EOF  reached  before  encapsulated  token  finished ");  }  else  {    tkn.content.append((char)  c);  }  }  }      [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P8_Replace_Mix]
[PATCH]  tkn.type  =  EORECORD;	[BUG]  [BUGGY]  tkn.type  =  tkn.type  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {    [BUGGY]  tkn.type  =  tkn.type  ;  [BUGGY]  return  tkn;  }  else  if  (!isWhitespace(c))  {    throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }  }  else  if  (isEndOfFile(c))  {    throw  new  IOException( "(startline   "  +  startLineNumber  +   ")  EOF  reached  before  encapsulated  token  finished ");  }  else  {    tkn.content.append((char)  c);  }  }    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P8_Replace_Mix]
[PATCH]  tkn.type  =  EORECORD;	[BUG]  [BUGGY]  tkn.type  =  TOKEN;tkn.type  =  EORECORD;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {    [BUGGY]  tkn.type  =  TOKEN;tkn.type  =  EORECORD;  [BUGGY]  return  tkn;  }  else  if  (!isWhitespace(c))  {    throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }  }  else  if  (isEndOfFile(c))  {    throw  new  IOException( "(startline   "  +  startLineNumber  +   ")  EOF  reached  before  encapsulated  token  finished ");  }  else  {    tkn.content.append((char)  c);  }  }    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P11_Insert_Donor_Statement]
[PATCH]  tkn.type  =  EORECORD;	[BUG]  [BUGGY]  tkn.type  =  EOF;tkn.type  =  EORECORD;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {    [BUGGY]  tkn.type  =  EOF;tkn.type  =  EORECORD;  [BUGGY]  return  tkn;  }  else  if  (!isWhitespace(c))  {    throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }  }  else  if  (isEndOfFile(c))  {    throw  new  IOException( "(startline   "  +  startLineNumber  +   ")  EOF  reached  before  encapsulated  token  finished ");  }  else  {    tkn.content.append((char)  c);  }  }    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P11_Insert_Donor_Statement]
[PATCH]  tkn.type  =  EOF;	[BUG]  [BUGGY]  tkn.type  =  tkn.type  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  if  (isEncapsulator(c))  {  if  (isEncapsulator(in.lookAhead()))  {    c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  [BUGGY]  tkn.type  =  tkn.type  ;  [BUGGY]  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {    throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }  }  else  if  (isEndOfFile(c))  {    throw  new  IOException( "(startline   "  +  startLineNumber  +   ")  EOF  reached  before  encapsulated  token  finished ");    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P8_Replace_Mix]
[PATCH]  tkn.type  =  EOF;	[BUG]  [BUGGY]  tkn.type  =  TOKEN;tkn.type  =  EOF;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  if  (isEncapsulator(c))  {  if  (isEncapsulator(in.lookAhead()))  {    c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  [BUGGY]  tkn.type  =  TOKEN;tkn.type  =  EOF;  [BUGGY]  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {    throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }  }  else  if  (isEndOfFile(c))  {    throw  new  IOException( "(startline   "  +  startLineNumber  +   ")  EOF  reached  before  encapsulated  token  finished ");    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P11_Insert_Donor_Statement]
[PATCH]  tkn.type  =  EOF;	[BUG]  [BUGGY]  tkn.type  =  EORECORD;tkn.type  =  EOF;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  if  (isEncapsulator(c))  {  if  (isEncapsulator(in.lookAhead()))  {    c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  [BUGGY]  tkn.type  =  EORECORD;tkn.type  =  EOF;  [BUGGY]  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {    throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }  }  else  if  (isEndOfFile(c))  {    throw  new  IOException( "(startline   "  +  startLineNumber  +   ")  EOF  reached  before  encapsulated  token  finished ");    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P11_Insert_Donor_Statement]
[PATCH]  tkn.isReady  =  true;	[BUG]  [BUGGY]  tkn.isReady  =  false;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  tkn.content.append((char)  readEscape(c));  }  else  if  (isEncapsulator(c))  {  if  (isEncapsulator(in.lookAhead()))  {    c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  [BUGGY]  tkn.isReady  =  false;  [BUGGY]  return  tkn;  }  else  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {    throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }  }  else  if  (isEndOfFile(c))  {    throw  new  IOException( "(startline   "  +  startLineNumber  +   ")  EOF  reached  before  encapsulated  token  finished ");  }  else  {    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P3_Replace_Literal]
[PATCH]  tkn.isReady  =  true;	[BUG]  [BUGGY]  tkn.type  =  TOKEN;tkn.isReady  =  true;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  tkn.content.append((char)  readEscape(c));  }  else  if  (isEncapsulator(c))  {  if  (isEncapsulator(in.lookAhead()))  {    c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  [BUGGY]  tkn.type  =  TOKEN;tkn.isReady  =  true;  [BUGGY]  return  tkn;  }  else  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {    throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }  }  else  if  (isEndOfFile(c))  {    throw  new  IOException( "(startline   "  +  startLineNumber  +   ")  EOF  reached  before  encapsulated  token  finished ");  }  else  {    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P11_Insert_Donor_Statement]
[PATCH]  }  else  if  (  isEndOfLine  (  c  )  )  {	[BUG]  [BUGGY]  }  if  (  isEndOfLine(  startLineNumber)  )  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  if  (isEncapsulator(in.lookAhead()))  {    c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  [BUGGY]  }  if  (  isEndOfLine(  startLineNumber)  )  {  [BUGGY]    tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {    throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }  }  else  if  (isEndOfFile(c))  {    throw  new  IOException( "(startline   "  +  startLineNumber  +   ")  EOF  reached  before  encapsulated  token  finished ");  }  else  {    tkn.content.append((char)  c);    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P8_Replace_Mix]
[PATCH]  tkn.type  =  EORECORD;	[BUG]  [BUGGY]  tkn.type  ;[CE]  not  a  statement  [CONTEXT]  c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {    [BUGGY]  tkn.type  ;  [BUGGY]  return  tkn;  }  else  if  (!isWhitespace(c))  {    throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }  }  else  if  (isEndOfFile(c))  {    throw  new  IOException( "(startline   "  +  startLineNumber  +   ")  EOF  reached  before  encapsulated  token  finished ");  }  else  {    tkn.content.append((char)  c);  }  }    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P8_Replace_Mix]
[PATCH]  tkn.type  =  EOF;	[BUG]  [BUGGY]  tkn.type  ;[CE]  not  a  statement  [CONTEXT]  if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  if  (isEncapsulator(c))  {  if  (isEncapsulator(in.lookAhead()))  {    c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  [BUGGY]  tkn.type  ;  [BUGGY]  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {    throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }  }  else  if  (isEndOfFile(c))  {    throw  new  IOException( "(startline   "  +  startLineNumber  +   ")  EOF  reached  before  encapsulated  token  finished ");    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P8_Replace_Mix]
[PATCH]  tkn.type  =  TOKEN;	[BUG]  [BUGGY]  tkn.type  =  tkn.type  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  while  (true)  {  c  =  in.read();  if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  if  (isEncapsulator(c))  {  if  (isEncapsulator(in.lookAhead()))  {    c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  [BUGGY]  tkn.type  =  tkn.type  ;  [BUGGY]  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {    throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P8_Replace_Mix]
[PATCH]  tkn.type  =  TOKEN;	[BUG]  [BUGGY]  tkn.type  =  EORECORD;tkn.type  =  TOKEN;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  while  (true)  {  c  =  in.read();  if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  if  (isEncapsulator(c))  {  if  (isEncapsulator(in.lookAhead()))  {    c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  [BUGGY]  tkn.type  =  EORECORD;tkn.type  =  TOKEN;  [BUGGY]  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {    throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P11_Insert_Donor_Statement]
[PATCH]  tkn.type  =  TOKEN;	[BUG]  [BUGGY]  tkn.type  =  EOF;tkn.type  =  TOKEN;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  while  (true)  {  c  =  in.read();  if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  if  (isEncapsulator(c))  {  if  (isEncapsulator(in.lookAhead()))  {    c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  [BUGGY]  tkn.type  =  EOF;tkn.type  =  TOKEN;  [BUGGY]  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {    throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P11_Insert_Donor_Statement]
[PATCH]  tkn.type  =  TOKEN;	[BUG]  [BUGGY]  tkn.isReady  =  true;tkn.type  =  TOKEN;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  while  (true)  {  c  =  in.read();  if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  if  (isEncapsulator(c))  {  if  (isEncapsulator(in.lookAhead()))  {    c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  [BUGGY]  tkn.isReady  =  true;tkn.type  =  TOKEN;  [BUGGY]  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {    throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P11_Insert_Donor_Statement]
[PATCH]  }  else  if  (  isEndOfFile  (  c  )  )  {	[BUG]  [BUGGY]  }  if  (  isEndOfLine(  c)  )  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  if  (isEncapsulator(c))  {  if  (isEncapsulator(in.lookAhead()))  {    c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  [BUGGY]  }  if  (  isEndOfLine(  c)  )  {  [BUGGY]  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {    throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }  }  else  if  (isEndOfFile(c))  {      [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P8_Replace_Mix]
[PATCH]  tkn.type  =  EORECORD;	[BUG]  [BUGGY]  tkn.type  =  null  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {    [BUGGY]  tkn.type  =  null  ;  [BUGGY]  return  tkn;  }  else  if  (!isWhitespace(c))  {    throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }  }  else  if  (isEndOfFile(c))  {    throw  new  IOException( "(startline   "  +  startLineNumber  +   ")  EOF  reached  before  encapsulated  token  finished ");  }  else  {    tkn.content.append((char)  c);  }  }    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P8_Replace_Mix]
[PATCH]  throw  new  IOException  ( "   ")  ;	[BUG]  [BUGGY]  return  false;[CE]  incompatible  types  [CONTEXT]  while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {    [BUGGY]  return  false;  [BUGGY]  }  }  }  }  else  if  (isEndOfFile(c))  {    throw  new  IOException( "(startline   "  +  startLineNumber  +   ")  EOF  reached  before  encapsulated  token  finished ");  }  else  {    tkn.content.append((char)  c);  }  }  }  }    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P8_Replace_Mix]
[PATCH]  c  =  in.read  (  )  ;	[BUG]  [BUGGY]  c  =  in.readLine(  )  ;[CE]  incompatible  types  [CONTEXT]      while  (true)  {  c  =  in.read();  if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  if  (isEncapsulator(c))  {  if  (isEncapsulator(in.lookAhead()))  {    c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {  [BUGGY]  c  =  in.readLine(  )  ;  [BUGGY]  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {    throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P7_Replace_Invocation]
[PATCH]  c  =  in.read  (  )  ;	[BUG]  [BUGGY]  c  =  c  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]      while  (true)  {  c  =  in.read();  if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  if  (isEncapsulator(c))  {  if  (isEncapsulator(in.lookAhead()))  {    c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {  [BUGGY]  c  =  c  ;  [BUGGY]  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {    throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P8_Replace_Mix]
[PATCH]  c  =  in.read  (  )  ;	[BUG]  [BUGGY]  c  =  in.readAgain(  )  ;c  =  in.read(  )  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]      while  (true)  {  c  =  in.read();  if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  if  (isEncapsulator(c))  {  if  (isEncapsulator(in.lookAhead()))  {    c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {  [BUGGY]  c  =  in.readAgain(  )  ;c  =  in.read(  )  ;  [BUGGY]  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {    throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P11_Insert_Donor_Statement]
[PATCH]  tkn.type  =  TOKEN;	[BUG]  [BUGGY]  tkn.type  =  0;[CE]  incompatible  types  [CONTEXT]  while  (true)  {  c  =  in.read();  if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  if  (isEncapsulator(c))  {  if  (isEncapsulator(in.lookAhead()))  {    c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  [BUGGY]  tkn.type  =  0;  [BUGGY]  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {    throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P5_Replace_Variable]
[PATCH]  tkn.type  =  TOKEN;	[BUG]  [BUGGY]  tkn.type  ;[CE]  not  a  statement  [CONTEXT]  while  (true)  {  c  =  in.read();  if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  if  (isEncapsulator(c))  {  if  (isEncapsulator(in.lookAhead()))  {    c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  [BUGGY]  tkn.type  ;  [BUGGY]  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {    throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P8_Replace_Mix]
[PATCH]  c  =  in.read  (  )  ;	[BUG]  [BUGGY]  [FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]      while  (true)  {  c  =  in.read();  if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  if  (isEncapsulator(c))  {  if  (isEncapsulator(in.lookAhead()))  {    c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {  [BUGGY]  [BUGGY]    if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {    throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P14_Delete_Statement]
[PATCH]  c  =  in.read  (  )  ;	[BUG]  [BUGGY]  int  lastChar  =  in.readAgain(  )  ;c  =  in.read(  )  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]      while  (true)  {  c  =  in.read();  if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  if  (isEncapsulator(c))  {  if  (isEncapsulator(in.lookAhead()))  {    c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {  [BUGGY]  int  lastChar  =  in.readAgain(  )  ;c  =  in.read(  )  ;  [BUGGY]  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {    throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P11_Insert_Donor_Statement]
[PATCH]  c  =  in.read  (  )  ;	[BUG]  [BUGGY]  int  c  =  in.read(  )  ;c  =  in.read(  )  ;[CE]  variable  c  is  already  defined  in  method  encapsulatedTokenLexer(Token,int)  [CONTEXT]      while  (true)  {  c  =  in.read();  if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  if  (isEncapsulator(c))  {  if  (isEncapsulator(in.lookAhead()))  {    c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {  [BUGGY]  int  c  =  in.read(  )  ;c  =  in.read(  )  ;  [BUGGY]  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {    throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P11_Insert_Donor_Statement]
[PATCH]  c  =  in.read  (  )  ;	[BUG]  [BUGGY]  in.readLine(  )  ;c  =  in.read(  )  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]      while  (true)  {  c  =  in.read();  if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  if  (isEncapsulator(c))  {  if  (isEncapsulator(in.lookAhead()))  {    c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {  [BUGGY]  in.readLine(  )  ;c  =  in.read(  )  ;  [BUGGY]  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {    throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P11_Insert_Donor_Statement]
[PATCH]  }  else  if  (  isEndOfLine  (  c  )  )  {	[BUG]  [BUGGY]  }  else  if  (  isEndOfFile(  startLineNumber)  )  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  if  (isEncapsulator(in.lookAhead()))  {    c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  [BUGGY]  }  else  if  (  isEndOfFile(  startLineNumber)  )  {  [BUGGY]    tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {    throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }  }  else  if  (isEndOfFile(c))  {    throw  new  IOException( "(startline   "  +  startLineNumber  +   ")  EOF  reached  before  encapsulated  token  finished ");  }  else  {    tkn.content.append((char)  c);    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P8_Replace_Mix]
[PATCH]  if  (  isEscape  (  c  )  )  {	[BUG]  [BUGGY]  if  (   "(  line   "  +  getLineNumber(  ))  {[CE]  incompatible  types  [CONTEXT]                private  Token  encapsulatedTokenLexer(Token  tkn,  int  c)  throws  IOException  {    int  startLineNumber  =  getLineNumber();      while  (true)  {  c  =  in.read();  [BUGGY]  if  (   "(  line   "  +  getLineNumber(  ))  {  [BUGGY]  tkn.content.append((char)  readEscape(c));  }  else  if  (isEncapsulator(c))  {  if  (isEncapsulator(in.lookAhead()))  {    c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P6_Replace_Expression]
[PATCH]  if  (  isEscape  (  c  )  )  {	[BUG]  [BUGGY]  if  (   "(  startline   "  +  startLineNumber  +   ")  EOF  reached  before  encapsulated  token  finished ")  {[CE]  incompatible  types  [CONTEXT]                private  Token  encapsulatedTokenLexer(Token  tkn,  int  c)  throws  IOException  {    int  startLineNumber  =  getLineNumber();      while  (true)  {  c  =  in.read();  [BUGGY]  if  (   "(  startline   "  +  startLineNumber  +   ")  EOF  reached  before  encapsulated  token  finished ")  {  [BUGGY]  tkn.content.append((char)  readEscape(c));  }  else  if  (isEncapsulator(c))  {  if  (isEncapsulator(in.lookAhead()))  {    c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P6_Replace_Expression]
[PATCH]  if  (  isEscape  (  c  )  )  {	[BUG]  [BUGGY]  if  (   "(  startline   "  +  startLineNumber)  {[CE]  incompatible  types  [CONTEXT]                private  Token  encapsulatedTokenLexer(Token  tkn,  int  c)  throws  IOException  {    int  startLineNumber  =  getLineNumber();      while  (true)  {  c  =  in.read();  [BUGGY]  if  (   "(  startline   "  +  startLineNumber)  {  [BUGGY]  tkn.content.append((char)  readEscape(c));  }  else  if  (isEncapsulator(c))  {  if  (isEncapsulator(in.lookAhead()))  {    c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P6_Replace_Expression]
[PATCH]  if  (  isEscape  (  c  )  )  {	[BUG]  [BUGGY]  if  (  readEscape(  c)  )  {[CE]  incompatible  types  [CONTEXT]                private  Token  encapsulatedTokenLexer(Token  tkn,  int  c)  throws  IOException  {    int  startLineNumber  =  getLineNumber();      while  (true)  {  c  =  in.read();  [BUGGY]  if  (  readEscape(  c)  )  {  [BUGGY]  tkn.content.append((char)  readEscape(c));  }  else  if  (isEncapsulator(c))  {  if  (isEncapsulator(in.lookAhead()))  {    c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P7_Replace_Invocation]
[PATCH]  if  (  isEscape  (  c  )  )  {	[BUG]  [BUGGY]  if  (  isDelimiter(  c)  )  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]                private  Token  encapsulatedTokenLexer(Token  tkn,  int  c)  throws  IOException  {    int  startLineNumber  =  getLineNumber();      while  (true)  {  c  =  in.read();  [BUGGY]  if  (  isDelimiter(  c)  )  {  [BUGGY]  tkn.content.append((char)  readEscape(c));  }  else  if  (isEncapsulator(c))  {  if  (isEncapsulator(in.lookAhead()))  {    c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P9_Replace_Statement]
[PATCH]  if  (  isEscape  (  c  )  )  {	[BUG]  [BUGGY]  if  (  isEndOfLine(  c)  )  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]                private  Token  encapsulatedTokenLexer(Token  tkn,  int  c)  throws  IOException  {    int  startLineNumber  =  getLineNumber();      while  (true)  {  c  =  in.read();  [BUGGY]  if  (  isEndOfLine(  c)  )  {  [BUGGY]  tkn.content.append((char)  readEscape(c));  }  else  if  (isEncapsulator(c))  {  if  (isEncapsulator(in.lookAhead()))  {    c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P9_Replace_Statement]
[PATCH]  if  (  isEscape  (  c  )  )  {	[BUG]  [BUGGY]  if  (  isCommentStart(  c)  )  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]                private  Token  encapsulatedTokenLexer(Token  tkn,  int  c)  throws  IOException  {    int  startLineNumber  =  getLineNumber();      while  (true)  {  c  =  in.read();  [BUGGY]  if  (  isCommentStart(  c)  )  {  [BUGGY]  tkn.content.append((char)  readEscape(c));  }  else  if  (isEncapsulator(c))  {  if  (isEncapsulator(in.lookAhead()))  {    c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P9_Replace_Statement]
[PATCH]  c  =  in.read  (  )  ;	[BUG]  [BUGGY]  c  ;[CE]  not  a  statement  [CONTEXT]      while  (true)  {  c  =  in.read();  if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  if  (isEncapsulator(c))  {  if  (isEncapsulator(in.lookAhead()))  {    c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {  [BUGGY]  c  ;  [BUGGY]  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {    throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P8_Replace_Mix]
[PATCH]  if  (  isDelimiter  (  c  )  )  {	[BUG]  [BUGGY]  if  (  isEscape(  startLineNumber)  )  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]    while  (true)  {  c  =  in.read();  if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  if  (isEncapsulator(c))  {  if  (isEncapsulator(in.lookAhead()))  {    c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {  c  =  in.read();  [BUGGY]  if  (  isEscape(  startLineNumber)  )  {  [BUGGY]  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {    throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P8_Replace_Mix]
[PATCH]  }  else  if  (  isEncapsulator  (  c  )  )  {	[BUG]  [BUGGY]  }  else  if  (   "(  line   "  +  getLineNumber(  ))  {[CE]  incompatible  types  [CONTEXT]            private  Token  encapsulatedTokenLexer(Token  tkn,  int  c)  throws  IOException  {    int  startLineNumber  =  getLineNumber();      while  (true)  {  c  =  in.read();  if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  [BUGGY]  }  else  if  (   "(  line   "  +  getLineNumber(  ))  {  [BUGGY]  if  (isEncapsulator(in.lookAhead()))  {    c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P6_Replace_Expression]
[PATCH]  }  else  if  (  isEncapsulator  (  c  )  )  {	[BUG]  [BUGGY]  }  else  if  (   "(  startline   "  +  startLineNumber  +   ")  EOF  reached  before  encapsulated  token  finished ")  {[CE]  incompatible  types  [CONTEXT]            private  Token  encapsulatedTokenLexer(Token  tkn,  int  c)  throws  IOException  {    int  startLineNumber  =  getLineNumber();      while  (true)  {  c  =  in.read();  if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  [BUGGY]  }  else  if  (   "(  startline   "  +  startLineNumber  +   ")  EOF  reached  before  encapsulated  token  finished ")  {  [BUGGY]  if  (isEncapsulator(in.lookAhead()))  {    c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P6_Replace_Expression]
[PATCH]  }  else  if  (  isEncapsulator  (  c  )  )  {	[BUG]  [BUGGY]  }  else  if  (   "(  startline   "  +  startLineNumber)  {[CE]  incompatible  types  [CONTEXT]            private  Token  encapsulatedTokenLexer(Token  tkn,  int  c)  throws  IOException  {    int  startLineNumber  =  getLineNumber();      while  (true)  {  c  =  in.read();  if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  [BUGGY]  }  else  if  (   "(  startline   "  +  startLineNumber)  {  [BUGGY]  if  (isEncapsulator(in.lookAhead()))  {    c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P6_Replace_Expression]
[PATCH]  }  else  if  (  isEncapsulator  (  c  )  )  {	[BUG]  [BUGGY]  }  else  {[CE]  'else'  without  'if'  [CONTEXT]            private  Token  encapsulatedTokenLexer(Token  tkn,  int  c)  throws  IOException  {    int  startLineNumber  =  getLineNumber();      while  (true)  {  c  =  in.read();  if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  [BUGGY]  }  else  {  [BUGGY]  if  (isEncapsulator(in.lookAhead()))  {    c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P6_Replace_Expression]
[PATCH]  }  else  if  (  isEncapsulator  (  c  )  )  {	[BUG]  [BUGGY]  }  else  if  (  getLineNumber(  c)  )  {[CE]  method  getLineNumber  in  class  Lexer  cannot  be  applied  to  given  types;  [CONTEXT]            private  Token  encapsulatedTokenLexer(Token  tkn,  int  c)  throws  IOException  {    int  startLineNumber  =  getLineNumber();      while  (true)  {  c  =  in.read();  if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  [BUGGY]  }  else  if  (  getLineNumber(  c)  )  {  [BUGGY]  if  (isEncapsulator(in.lookAhead()))  {    c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P7_Replace_Invocation]
[PATCH]  }  else  if  (  isEncapsulator  (  c  )  )  {	[BUG]  [BUGGY]  }  if  (  isEncapsulator(  c)  )  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]            private  Token  encapsulatedTokenLexer(Token  tkn,  int  c)  throws  IOException  {    int  startLineNumber  =  getLineNumber();      while  (true)  {  c  =  in.read();  if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  [BUGGY]  }  if  (  isEncapsulator(  c)  )  {  [BUGGY]  if  (isEncapsulator(in.lookAhead()))  {    c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P8_Replace_Mix]
[PATCH]  }  else  if  (  isEncapsulator  (  c  )  )  {	[BUG]  [BUGGY]  }  else  if  (  isDelimiter(  c)  )  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]            private  Token  encapsulatedTokenLexer(Token  tkn,  int  c)  throws  IOException  {    int  startLineNumber  =  getLineNumber();      while  (true)  {  c  =  in.read();  if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  [BUGGY]  }  else  if  (  isDelimiter(  c)  )  {  [BUGGY]  if  (isEncapsulator(in.lookAhead()))  {    c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P9_Replace_Statement]
[PATCH]  }  else  if  (  isEncapsulator  (  c  )  )  {	[BUG]  [BUGGY]  }  else  if  (  isEndOfFile(  c)  )  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]            private  Token  encapsulatedTokenLexer(Token  tkn,  int  c)  throws  IOException  {    int  startLineNumber  =  getLineNumber();      while  (true)  {  c  =  in.read();  if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  [BUGGY]  }  else  if  (  isEndOfFile(  c)  )  {  [BUGGY]  if  (isEncapsulator(in.lookAhead()))  {    c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P9_Replace_Statement]
[PATCH]  }  else  if  (  isEncapsulator  (  c  )  )  {	[BUG]  [BUGGY]  }  else  if  (  isEndOfLine(  c)  )  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]            private  Token  encapsulatedTokenLexer(Token  tkn,  int  c)  throws  IOException  {    int  startLineNumber  =  getLineNumber();      while  (true)  {  c  =  in.read();  if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  [BUGGY]  }  else  if  (  isEndOfLine(  c)  )  {  [BUGGY]  if  (isEncapsulator(in.lookAhead()))  {    c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P9_Replace_Statement]
[PATCH]  }  else  if  (  isEncapsulator  (  c  )  )  {	[BUG]  [BUGGY]  }  else  if  (  isEscape(  c)  )  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]            private  Token  encapsulatedTokenLexer(Token  tkn,  int  c)  throws  IOException  {    int  startLineNumber  =  getLineNumber();      while  (true)  {  c  =  in.read();  if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  [BUGGY]  }  else  if  (  isEscape(  c)  )  {  [BUGGY]  if  (isEncapsulator(in.lookAhead()))  {    c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P9_Replace_Statement]
[PATCH]  }  else  if  (  isEncapsulator  (  c  )  )  {	[BUG]  [BUGGY]  }  else  if  (  !isWhitespace(  c)  )  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]            private  Token  encapsulatedTokenLexer(Token  tkn,  int  c)  throws  IOException  {    int  startLineNumber  =  getLineNumber();      while  (true)  {  c  =  in.read();  if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  [BUGGY]  }  else  if  (  !isWhitespace(  c)  )  {  [BUGGY]  if  (isEncapsulator(in.lookAhead()))  {    c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P9_Replace_Statement]
[PATCH]  }  else  if  (  isEndOfFile  (  c  )  )  {	[BUG]  [BUGGY]  }  else  if  (   "(  startline   "  +  startLineNumber)  {[CE]  incompatible  types  [CONTEXT]  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {    throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }  [BUGGY]  }  else  if  (   "(  startline   "  +  startLineNumber)  {  [BUGGY]    throw  new  IOException( "(startline   "  +  startLineNumber  +   ")  EOF  reached  before  encapsulated  token  finished ");  }  else  {    tkn.content.append((char)  c);  }  }  }  }    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P6_Replace_Expression]
[PATCH]  }  else  if  (  isEndOfFile  (  c  )  )  {	[BUG]  [BUGGY]  }  else  {[CE]  'else'  without  'if'  [CONTEXT]  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {    throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }  [BUGGY]  }  else  {  [BUGGY]    throw  new  IOException( "(startline   "  +  startLineNumber  +   ")  EOF  reached  before  encapsulated  token  finished ");  }  else  {    tkn.content.append((char)  c);  }  }  }  }    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P6_Replace_Expression]
[PATCH]  }  else  if  (  isEndOfFile  (  c  )  )  {	[BUG]  [BUGGY]  }  else  if  (  isEndOfLine(  c)  )  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {    throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }  [BUGGY]  }  else  if  (  isEndOfLine(  c)  )  {  [BUGGY]    throw  new  IOException( "(startline   "  +  startLineNumber  +   ")  EOF  reached  before  encapsulated  token  finished ");  }  else  {    tkn.content.append((char)  c);  }  }  }  }    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P7_Replace_Invocation]
[PATCH]  }  else  if  (  isEndOfFile  (  c  )  )  {	[BUG]  [BUGGY]  }  else  if  (  isDelimiter(  c)  )  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {    throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }  [BUGGY]  }  else  if  (  isDelimiter(  c)  )  {  [BUGGY]    throw  new  IOException( "(startline   "  +  startLineNumber  +   ")  EOF  reached  before  encapsulated  token  finished ");  }  else  {    tkn.content.append((char)  c);  }  }  }  }    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P9_Replace_Statement]
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  !(  isWhitespace(  c)  )  )  {      throw  new  IOException(  (  (   "(  line   "  +  (  getLineNumber(  )  )  )  +   ")  invalid  char  between  encapsulated  token  and  delimiter ")  )  ;  }[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {    throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }  [BUGGY]  if  (  !(  isWhitespace(  c)  )  )  {      throw  new  IOException(  (  (   "(  line   "  +  (  getLineNumber(  )  )  )  +   ")  invalid  char  between  encapsulated  token  and  delimiter ")  )  ;  }  [BUGGY]    throw  new  IOException( "(startline   "  +  startLineNumber  +   ")  EOF  reached  before  encapsulated  token  finished ");  }  else  {    tkn.content.append((char)  c);  }  }  }  }    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P13_Insert_Block]
[PATCH]  tkn.content.append  (  (  char  )  c  )  ;	[BUG]  [BUGGY]  [FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  }  else  if  (isEndOfFile(c))  {    throw  new  IOException( "(startline   "  +  startLineNumber  +   ")  EOF  reached  before  encapsulated  token  finished ");  }  else  {    [BUGGY]  [BUGGY]      [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P14_Delete_Statement]
[PATCH]  tkn.content.append  (  (  char  )  c  )  ;	[BUG]  [BUGGY]  tkn.content.append(  (  char)  readEscape(  c)  )  ;tkn.content.append(  (  char)  c)  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  }  else  if  (isEndOfFile(c))  {    throw  new  IOException( "(startline   "  +  startLineNumber  +   ")  EOF  reached  before  encapsulated  token  finished ");  }  else  {    [BUGGY]  tkn.content.append(  (  char)  readEscape(  c)  )  ;tkn.content.append(  (  char)  c)  ;  [BUGGY]  }    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P11_Insert_Donor_Statement]
[PATCH]  throw  new  IOException  ( "   ")  ;	[BUG]  [BUGGY]  return  ;[CE]  missing  return  value  [CONTEXT]  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {    throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }  }  else  if  (isEndOfFile(c))  {    [BUGGY]  return  ;  [BUGGY]  }  else  {    tkn.content.append((char)  c);  }  }  }  }    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P8_Replace_Mix]
[PATCH]  }  else  if  (  isEndOfFile  (  c  )  )  {	[BUG]  [BUGGY]  }  else  if  (  isEndOfFile(  startLineNumber)  )  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {    throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }  [BUGGY]  }  else  if  (  isEndOfFile(  startLineNumber)  )  {  [BUGGY]    throw  new  IOException( "(startline   "  +  startLineNumber  +   ")  EOF  reached  before  encapsulated  token  finished ");  }  else  {    tkn.content.append((char)  c);  }  }  }  }    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P5_Replace_Variable]
[PATCH]  tkn.content.append  (  (  char  )  c  )  ;	[BUG]  [BUGGY]  [FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  }  else  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {    throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }  }  else  if  (isEndOfFile(c))  {    throw  new  IOException( "(startline   "  +  startLineNumber  +   ")  EOF  reached  before  encapsulated  token  finished ");  }  else  {    [BUGGY]  [BUGGY]    }  }  }  }    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P14_Delete_Statement]
[PATCH]  tkn.content.append  (  (  char  )  c  )  ;	[BUG]  [BUGGY]  tkn.content.append(  (  char)  readEscape(  c)  )  ;tkn.content.append(  (  char)  c)  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  }  else  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {    throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }  }  else  if  (isEndOfFile(c))  {    throw  new  IOException( "(startline   "  +  startLineNumber  +   ")  EOF  reached  before  encapsulated  token  finished ");  }  else  {    [BUGGY]  tkn.content.append(  (  char)  readEscape(  c)  )  ;tkn.content.append(  (  char)  c)  ;  [BUGGY]  }  }  }  }    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P11_Insert_Donor_Statement]
[PATCH]  }  else  if  (  isEndOfFile  (  c  )  )  {	[BUG]  [BUGGY]  }  if  (  isEndOfFile(  startLineNumber)  )  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  if  (isEncapsulator(c))  {  if  (isEncapsulator(in.lookAhead()))  {    c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  [BUGGY]  }  if  (  isEndOfFile(  startLineNumber)  )  {  [BUGGY]  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {    throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }  }  else  if  (isEndOfFile(c))  {      [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P8_Replace_Mix]
[PATCH]  tkn.type  =  TOKEN;	[BUG]  [BUGGY]  tkn.type  =  null  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  while  (true)  {  c  =  in.read();  if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  if  (isEncapsulator(c))  {  if  (isEncapsulator(in.lookAhead()))  {    c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  [BUGGY]  tkn.type  =  null  ;  [BUGGY]  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {    throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P8_Replace_Mix]
[PATCH]  throw  new  IOException  ( "   ")  ;	[BUG]  [BUGGY]  return  0;[CE]  incompatible  types  [CONTEXT]  while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {    [BUGGY]  return  0;  [BUGGY]  }  }  }  }  else  if  (isEndOfFile(c))  {    throw  new  IOException( "(startline   "  +  startLineNumber  +   ")  EOF  reached  before  encapsulated  token  finished ");  }  else  {    tkn.content.append((char)  c);  }  }  }  }    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P8_Replace_Mix]
[PATCH]  c  =  in.read  (  )  ;	[BUG]  [BUGGY]  c  =  4.read(  )  ;[CE]  ';'  expected  [CONTEXT]      while  (true)  {  c  =  in.read();  if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  if  (isEncapsulator(c))  {  if  (isEncapsulator(in.lookAhead()))  {    c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {  [BUGGY]  c  =  4.read(  )  ;  [BUGGY]  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {    throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P5_Replace_Variable]
[PATCH]  }  else  if  (  isEndOfFile  (  c  )  )  {	[BUG]  [BUGGY]  }  else  if  (  isEndOfLine(  startLineNumber)  )  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  if  (isEncapsulator(c))  {  if  (isEncapsulator(in.lookAhead()))  {    c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  [BUGGY]  }  else  if  (  isEndOfLine(  startLineNumber)  )  {  [BUGGY]  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {    throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }  }  else  if  (isEndOfFile(c))  {      [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P8_Replace_Mix]
[PATCH]  if  (  isEncapsulator  (  in.lookAhead  (  )  )  )  {	[BUG]  [BUGGY]  if  (   "(  line   "  +  getLineNumber(  ))  {[CE]  incompatible  types  [CONTEXT]          private  Token  encapsulatedTokenLexer(Token  tkn,  int  c)  throws  IOException  {    int  startLineNumber  =  getLineNumber();      while  (true)  {  c  =  in.read();  if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  if  (isEncapsulator(c))  {  [BUGGY]  if  (   "(  line   "  +  getLineNumber(  ))  {  [BUGGY]    c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P6_Replace_Expression]
[PATCH]  if  (  isEncapsulator  (  in.lookAhead  (  )  )  )  {	[BUG]  [BUGGY]  if  (  getLineNumber(  in.lookAhead(  )  )  )  {[CE]  method  getLineNumber  in  class  Lexer  cannot  be  applied  to  given  types;  [CONTEXT]          private  Token  encapsulatedTokenLexer(Token  tkn,  int  c)  throws  IOException  {    int  startLineNumber  =  getLineNumber();      while  (true)  {  c  =  in.read();  if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  if  (isEncapsulator(c))  {  [BUGGY]  if  (  getLineNumber(  in.lookAhead(  )  )  )  {  [BUGGY]    c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P7_Replace_Invocation]
[PATCH]  if  (  isEncapsulator  (  in.lookAhead  (  )  )  )  {	[BUG]  [BUGGY]  if  (  isEncapsulator(  in.read(  )  )  )  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]          private  Token  encapsulatedTokenLexer(Token  tkn,  int  c)  throws  IOException  {    int  startLineNumber  =  getLineNumber();      while  (true)  {  c  =  in.read();  if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  if  (isEncapsulator(c))  {  [BUGGY]  if  (  isEncapsulator(  in.read(  )  )  )  {  [BUGGY]    c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P7_Replace_Invocation]
[PATCH]  while  (  true  )  {	[BUG]  [BUGGY]  while  (  false)  {[CE]  unreachable  statement  [CONTEXT]  if  (isEncapsulator(in.lookAhead()))  {    c  =  in.read();  tkn.content.append((char)  c);  }  else  {    [BUGGY]  while  (  false)  {  [BUGGY]  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {    throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P3_Replace_Literal]
[PATCH]  if  (  isDelimiter  (  c  )  )  {	[BUG]  [BUGGY]  if  (  isDelimiter(  startLineNumber)  )  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  if  (isEncapsulator(in.lookAhead()))  {    c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {  c  =  in.read();  [BUGGY]  if  (  isDelimiter(  startLineNumber)  )  {  [BUGGY]  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {    throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P5_Replace_Variable]
[PATCH]  if  (  isDelimiter  (  c  )  )  {	[BUG]  [BUGGY]  if  (   "(  line   "  +  getLineNumber(  ))  {[CE]  incompatible  types  [CONTEXT]  if  (isEncapsulator(in.lookAhead()))  {    c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {  c  =  in.read();  [BUGGY]  if  (   "(  line   "  +  getLineNumber(  ))  {  [BUGGY]  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {    throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P6_Replace_Expression]
[PATCH]  if  (  isDelimiter  (  c  )  )  {	[BUG]  [BUGGY]  if  (  isEscape(  c)  )  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  if  (isEncapsulator(in.lookAhead()))  {    c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {  c  =  in.read();  [BUGGY]  if  (  isEscape(  c)  )  {  [BUGGY]  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {    throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P7_Replace_Invocation]
[PATCH]  }  else  if  (  isEndOfFile  (  c  )  )  {	[BUG]  [BUGGY]  }  else  if  (  isEndOfFile(  startLineNumber)  )  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  if  (isEncapsulator(in.lookAhead()))  {    c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  [BUGGY]  }  else  if  (  isEndOfFile(  startLineNumber)  )  {  [BUGGY]  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {    throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P5_Replace_Variable]
[PATCH]  }  else  if  (  isEndOfFile  (  c  )  )  {	[BUG]  [BUGGY]  }  else  if  (   "(  line   "  +  getLineNumber(  ))  {[CE]  incompatible  types  [CONTEXT]  if  (isEncapsulator(in.lookAhead()))  {    c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  [BUGGY]  }  else  if  (   "(  line   "  +  getLineNumber(  ))  {  [BUGGY]  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {    throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P6_Replace_Expression]
[PATCH]  }  else  if  (  isEndOfFile  (  c  )  )  {	[BUG]  [BUGGY]  }  else  {[CE]  'else'  without  'if'  [CONTEXT]  if  (isEncapsulator(in.lookAhead()))  {    c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  [BUGGY]  }  else  {  [BUGGY]  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {    throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P6_Replace_Expression]
[PATCH]  }  else  if  (  isEndOfFile  (  c  )  )  {	[BUG]  [BUGGY]  }  else  if  (  isEndOfLine(  c)  )  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  if  (isEncapsulator(in.lookAhead()))  {    c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  [BUGGY]  }  else  if  (  isEndOfLine(  c)  )  {  [BUGGY]  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {    throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P7_Replace_Invocation]
[PATCH]  }  else  if  (  isEndOfFile  (  c  )  )  {	[BUG]  [BUGGY]  }  else  if  (  isDelimiter(  c)  )  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  if  (isEncapsulator(in.lookAhead()))  {    c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  [BUGGY]  }  else  if  (  isDelimiter(  c)  )  {  [BUGGY]  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {    throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P9_Replace_Statement]
[PATCH]  }  else  if  (  isEndOfLine  (  c  )  )  {	[BUG]  [BUGGY]  }  else  if  (  isEndOfLine(  startLineNumber)  )  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  if  (isEncapsulator(in.lookAhead()))  {    c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  [BUGGY]  }  else  if  (  isEndOfLine(  startLineNumber)  )  {  [BUGGY]    tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {    throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P5_Replace_Variable]
[PATCH]  }  else  if  (  isEndOfLine  (  c  )  )  {	[BUG]  [BUGGY]  }  else  if  (   "(  line   "  +  getLineNumber(  ))  {[CE]  incompatible  types  [CONTEXT]  if  (isEncapsulator(in.lookAhead()))  {    c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  [BUGGY]  }  else  if  (   "(  line   "  +  getLineNumber(  ))  {  [BUGGY]    tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {    throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P6_Replace_Expression]
[PATCH]  }  else  if  (  isEndOfLine  (  c  )  )  {	[BUG]  [BUGGY]  }  else  {[CE]  'else'  without  'if'  [CONTEXT]  if  (isEncapsulator(in.lookAhead()))  {    c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  [BUGGY]  }  else  {  [BUGGY]    tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {    throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P6_Replace_Expression]
[PATCH]  }  else  if  (  isEndOfLine  (  c  )  )  {	[BUG]  [BUGGY]  }  else  if  (  isEndOfFile(  c)  )  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  if  (isEncapsulator(in.lookAhead()))  {    c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  [BUGGY]  }  else  if  (  isEndOfFile(  c)  )  {  [BUGGY]    tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {    throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P7_Replace_Invocation]
[PATCH]  }  else  if  (  isEndOfLine  (  c  )  )  {	[BUG]  [BUGGY]  }  else  if  (  isDelimiter(  c)  )  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  if  (isEncapsulator(in.lookAhead()))  {    c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  [BUGGY]  }  else  if  (  isDelimiter(  c)  )  {  [BUGGY]    tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {    throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P9_Replace_Statement]
[PATCH]  }  else  if  (  !isWhitespace  (  c  )  )  {	[BUG]  [BUGGY]  }  else  if  (  !isWhitespace(  startLineNumber)  )  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  if  (isEncapsulator(in.lookAhead()))  {    c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  return  tkn;  [BUGGY]  }  else  if  (  !isWhitespace(  startLineNumber)  )  {  [BUGGY]    throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P5_Replace_Variable]
[PATCH]  }  else  if  (  !isWhitespace  (  c  )  )  {	[BUG]  [BUGGY]  }  else  if  (   "(  line   "  +  getLineNumber(  ))  {[CE]  incompatible  types  [CONTEXT]  if  (isEncapsulator(in.lookAhead()))  {    c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  return  tkn;  [BUGGY]  }  else  if  (   "(  line   "  +  getLineNumber(  ))  {  [BUGGY]    throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P6_Replace_Expression]
[PATCH]  }  else  if  (  !isWhitespace  (  c  )  )  {	[BUG]  [BUGGY]  }  else  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  if  (isEncapsulator(in.lookAhead()))  {    c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  return  tkn;  [BUGGY]  }  else  {  [BUGGY]    throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P6_Replace_Expression]
[PATCH]  }  else  if  (  !isWhitespace  (  c  )  )  {	[BUG]  [BUGGY]  }  else  if  (  !isEscape(  c)  )  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  if  (isEncapsulator(in.lookAhead()))  {    c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  return  tkn;  [BUGGY]  }  else  if  (  !isEscape(  c)  )  {  [BUGGY]    throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P7_Replace_Invocation]
[PATCH]  }  else  if  (  !isWhitespace  (  c  )  )  {	[BUG]  [BUGGY]  }  if  (  !isWhitespace(  startLineNumber)  )  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  if  (isEncapsulator(in.lookAhead()))  {    c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  return  tkn;  [BUGGY]  }  if  (  !isWhitespace(  startLineNumber)  )  {  [BUGGY]    throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P8_Replace_Mix]
[PATCH]  }  else  if  (  !isWhitespace  (  c  )  )  {	[BUG]  [BUGGY]  }  else  if  (  isDelimiter(  c)  )  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  if  (isEncapsulator(in.lookAhead()))  {    c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  return  tkn;  [BUGGY]  }  else  if  (  isDelimiter(  c)  )  {  [BUGGY]    throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P9_Replace_Statement]
[PATCH]  }  else  if  (  !isWhitespace  (  c  )  )  {	[BUG]  [BUGGY]  }  else  if  (  isEndOfFile(  c)  )  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  if  (isEncapsulator(in.lookAhead()))  {    c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  return  tkn;  [BUGGY]  }  else  if  (  isEndOfFile(  c)  )  {  [BUGGY]    throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P9_Replace_Statement]
[PATCH]  }  else  if  (  !isWhitespace  (  c  )  )  {	[BUG]  [BUGGY]  }  else  if  (  isEndOfLine(  c)  )  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  if  (isEncapsulator(in.lookAhead()))  {    c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  return  tkn;  [BUGGY]  }  else  if  (  isEndOfLine(  c)  )  {  [BUGGY]    throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P9_Replace_Statement]
[PATCH]  }  else  if  (  !isWhitespace  (  c  )  )  {	[BUG]  [BUGGY]  }  else  if  (  isEscape(  c)  )  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  if  (isEncapsulator(in.lookAhead()))  {    c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  return  tkn;  [BUGGY]  }  else  if  (  isEscape(  c)  )  {  [BUGGY]    throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P9_Replace_Statement]
[PATCH]  }  else  if  (  !isWhitespace  (  c  )  )  {	[BUG]  [BUGGY]  }  else  if  (  isEncapsulator(  c)  )  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  if  (isEncapsulator(in.lookAhead()))  {    c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  return  tkn;  [BUGGY]  }  else  if  (  isEncapsulator(  c)  )  {  [BUGGY]    throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P9_Replace_Statement]
[PATCH]  }  else  if  (  !isWhitespace  (  c  )  )  {  throw  new  IOException  ( "   ")  ;  }	[BUG]  [BUGGY]  throw  new  java.io.IOException((( "(line   "  +(getLineNumber()))  +   ")  invalid  char  between  encapsulated  token  and  delimiter "));[CE]  'else'  without  'if'  [CONTEXT]  if  (isEncapsulator(in.lookAhead()))  {    c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  return  tkn;  [BUGGY]  throw  new  java.io.IOException((( "(line   "  +(getLineNumber()))  +   ")  invalid  char  between  encapsulated  token  and  delimiter "));  [BUGGY]    throw  new  java.io.IOException((( "(line   "  +  (getLineNumber()))  +   ")  invalid  char  between  encapsulated  token  and  delimiter "));    }    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P15_Unwrap_Block]
[PATCH]  }  else  if  (  !isWhitespace  (  c  )  )  {  throw  new  IOException  ( "   ")  ;  }	[BUG]  [BUGGY]  [CE]  'else'  without  'if'  [CONTEXT]  if  (isEncapsulator(in.lookAhead()))  {    c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  return  tkn;  [BUGGY]  [BUGGY]      }    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P16_Remove_Block]
[PATCH]  throw  new  IOException  ( "   ")  ;	[BUG]  [BUGGY]  [FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  if  (isEncapsulator(in.lookAhead()))  {    c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {    [BUGGY]  [BUGGY]    }  }    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P14_Delete_Statement]
[PATCH]  tkn.type  =  EORECORD;	[BUG]  [BUGGY]  tkn.type  =  null  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  if  (isEncapsulator(in.lookAhead()))  {    c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {    [BUGGY]  tkn.type  =  null  ;  [BUGGY]  return  tkn;  }  else  if  (!isWhitespace(c))  {    throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P8_Replace_Mix]
[PATCH]  tkn.type  =  EORECORD;	[BUG]  [BUGGY]  tkn.type  =  TOKEN;tkn.type  =  EORECORD;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  if  (isEncapsulator(in.lookAhead()))  {    c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {    [BUGGY]  tkn.type  =  TOKEN;tkn.type  =  EORECORD;  [BUGGY]  return  tkn;  }  else  if  (!isWhitespace(c))  {    throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P11_Insert_Donor_Statement]
[PATCH]  tkn.type  =  EORECORD;	[BUG]  [BUGGY]  tkn.type  =  EOF;tkn.type  =  EORECORD;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  if  (isEncapsulator(in.lookAhead()))  {    c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {    [BUGGY]  tkn.type  =  EOF;tkn.type  =  EORECORD;  [BUGGY]  return  tkn;  }  else  if  (!isWhitespace(c))  {    throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P11_Insert_Donor_Statement]
[PATCH]  throw  new  IOException  ( "   ")  ;	[BUG]  [BUGGY]  return  ;[CE]  missing  return  value  [CONTEXT]  if  (isEncapsulator(in.lookAhead()))  {    c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {    [BUGGY]  return  ;  [BUGGY]  }  }  }    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P8_Replace_Mix]
[PATCH]  tkn.type  =  EOF;	[BUG]  [BUGGY]  tkn.type  =  tkn.type  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  if  (isEncapsulator(in.lookAhead()))  {    c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  [BUGGY]  tkn.type  =  tkn.type  ;  [BUGGY]  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {    throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P8_Replace_Mix]
[PATCH]  tkn.type  =  EOF;	[BUG]  [BUGGY]  tkn.type  =  TOKEN;tkn.type  =  EOF;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  if  (isEncapsulator(in.lookAhead()))  {    c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  [BUGGY]  tkn.type  =  TOKEN;tkn.type  =  EOF;  [BUGGY]  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {    throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P11_Insert_Donor_Statement]
[PATCH]  tkn.type  =  EOF;	[BUG]  [BUGGY]  tkn.type  =  EORECORD;tkn.type  =  EOF;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  if  (isEncapsulator(in.lookAhead()))  {    c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  [BUGGY]  tkn.type  =  EORECORD;tkn.type  =  EOF;  [BUGGY]  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {    throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P11_Insert_Donor_Statement]
[PATCH]  tkn.isReady  =  true;	[BUG]  [BUGGY]  tkn.isReady  =  false;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  if  (isEncapsulator(in.lookAhead()))  {    c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  [BUGGY]  tkn.isReady  =  false;  [BUGGY]  return  tkn;  }  else  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {    throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P3_Replace_Literal]
[PATCH]  tkn.isReady  =  true;	[BUG]  [BUGGY]  tkn.type  =  TOKEN;tkn.isReady  =  true;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  if  (isEncapsulator(in.lookAhead()))  {    c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  [BUGGY]  tkn.type  =  TOKEN;tkn.isReady  =  true;  [BUGGY]  return  tkn;  }  else  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {    throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P11_Insert_Donor_Statement]
[PATCH]  }  else  if  (  isEndOfLine  (  c  )  )  {	[BUG]  [BUGGY]  }  if  (  isEndOfFile(  startLineNumber)  )  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  if  (isEncapsulator(in.lookAhead()))  {    c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  [BUGGY]  }  if  (  isEndOfFile(  startLineNumber)  )  {  [BUGGY]    tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {    throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P8_Replace_Mix]
[PATCH]  }  else  if  (  !isWhitespace  (  c  )  )  {	[BUG]  [BUGGY]  }  else  if  (  !isEscape(  startLineNumber)  )  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  if  (isEncapsulator(in.lookAhead()))  {    c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  return  tkn;  [BUGGY]  }  else  if  (  !isEscape(  startLineNumber)  )  {  [BUGGY]    throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P8_Replace_Mix]
[PATCH]  tkn.type  =  EORECORD;	[BUG]  [BUGGY]  tkn.type  ;[CE]  not  a  statement  [CONTEXT]  if  (isEncapsulator(in.lookAhead()))  {    c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {    [BUGGY]  tkn.type  ;  [BUGGY]  return  tkn;  }  else  if  (!isWhitespace(c))  {    throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P8_Replace_Mix]
[PATCH]  throw  new  IOException  ( "   ")  ;	[BUG]  [BUGGY]  return  false;[CE]  incompatible  types  [CONTEXT]  if  (isEncapsulator(in.lookAhead()))  {    c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {    [BUGGY]  return  false;  [BUGGY]  }  }  }    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P8_Replace_Mix]
[PATCH]  tkn.type  =  EOF;	[BUG]  [BUGGY]  tkn.type  ;[CE]  not  a  statement  [CONTEXT]  if  (isEncapsulator(in.lookAhead()))  {    c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  [BUGGY]  tkn.type  ;  [BUGGY]  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {    throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P8_Replace_Mix]
[PATCH]  tkn.type  =  EORECORD;	[BUG]  [BUGGY]  tkn.type  =  1;[CE]  incompatible  types  [CONTEXT]  if  (isEncapsulator(in.lookAhead()))  {    c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {    [BUGGY]  tkn.type  =  1;  [BUGGY]  return  tkn;  }  else  if  (!isWhitespace(c))  {    throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P5_Replace_Variable]
[PATCH]  tkn.type  =  EORECORD;	[BUG]  [BUGGY]  tkn.type  =  tkn.type  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  if  (isEncapsulator(in.lookAhead()))  {    c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {    [BUGGY]  tkn.type  =  tkn.type  ;  [BUGGY]  return  tkn;  }  else  if  (!isWhitespace(c))  {    throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P8_Replace_Mix]
[PATCH]  }  else  if  (  isEndOfLine  (  c  )  )  {	[BUG]  [BUGGY]  }  else  if  (  isEndOfFile(  startLineNumber)  )  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  if  (isEncapsulator(in.lookAhead()))  {    c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  [BUGGY]  }  else  if  (  isEndOfFile(  startLineNumber)  )  {  [BUGGY]    tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {    throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P8_Replace_Mix]
[PATCH]  tkn.type  =  TOKEN;	[BUG]  [BUGGY]  tkn.type  =  tkn.type  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  if  (isEncapsulator(in.lookAhead()))  {    c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  [BUGGY]  tkn.type  =  tkn.type  ;  [BUGGY]  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {    throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P8_Replace_Mix]
[PATCH]  tkn.type  =  TOKEN;	[BUG]  [BUGGY]  tkn.type  =  EORECORD;tkn.type  =  TOKEN;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  if  (isEncapsulator(in.lookAhead()))  {    c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  [BUGGY]  tkn.type  =  EORECORD;tkn.type  =  TOKEN;  [BUGGY]  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {    throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P11_Insert_Donor_Statement]
[PATCH]  tkn.type  =  TOKEN;	[BUG]  [BUGGY]  tkn.type  =  EOF;tkn.type  =  TOKEN;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  if  (isEncapsulator(in.lookAhead()))  {    c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  [BUGGY]  tkn.type  =  EOF;tkn.type  =  TOKEN;  [BUGGY]  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {    throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P11_Insert_Donor_Statement]
[PATCH]  tkn.type  =  TOKEN;	[BUG]  [BUGGY]  tkn.isReady  =  true;tkn.type  =  TOKEN;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  if  (isEncapsulator(in.lookAhead()))  {    c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  [BUGGY]  tkn.isReady  =  true;tkn.type  =  TOKEN;  [BUGGY]  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {    throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P11_Insert_Donor_Statement]
[PATCH]  }  else  if  (  isEndOfFile  (  c  )  )  {	[BUG]  [BUGGY]  }  if  (  isEndOfLine(  c)  )  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  if  (isEncapsulator(in.lookAhead()))  {    c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  [BUGGY]  }  if  (  isEndOfLine(  c)  )  {  [BUGGY]  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {    throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P8_Replace_Mix]
[PATCH]  }  else  if  (  !isWhitespace  (  c  )  )  {	[BUG]  [BUGGY]  }  if  (  !isEscape(  c)  )  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  if  (isEncapsulator(in.lookAhead()))  {    c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  return  tkn;  [BUGGY]  }  if  (  !isEscape(  c)  )  {  [BUGGY]    throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P8_Replace_Mix]
[PATCH]  c  =  in.read  (  )  ;	[BUG]  [BUGGY]  c  =  in.readLine(  )  ;[CE]  incompatible  types  [CONTEXT]  if  (isEncapsulator(in.lookAhead()))  {    c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {  [BUGGY]  c  =  in.readLine(  )  ;  [BUGGY]  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {    throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P7_Replace_Invocation]
[PATCH]  c  =  in.read  (  )  ;	[BUG]  [BUGGY]  c  =  null  ;[CE]  incompatible  types  [CONTEXT]  if  (isEncapsulator(in.lookAhead()))  {    c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {  [BUGGY]  c  =  null  ;  [BUGGY]  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {    throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P8_Replace_Mix]
[PATCH]  c  =  in.read  (  )  ;	[BUG]  [BUGGY]  c  =  in.readAgain(  )  ;c  =  in.read(  )  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  if  (isEncapsulator(in.lookAhead()))  {    c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {  [BUGGY]  c  =  in.readAgain(  )  ;c  =  in.read(  )  ;  [BUGGY]  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {    throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P11_Insert_Donor_Statement]
[PATCH]  tkn.type  =  TOKEN;	[BUG]  [BUGGY]  tkn.type  ;[CE]  not  a  statement  [CONTEXT]  if  (isEncapsulator(in.lookAhead()))  {    c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  [BUGGY]  tkn.type  ;  [BUGGY]  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {    throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P8_Replace_Mix]
[PATCH]  c  =  in.read  (  )  ;	[BUG]  [BUGGY]  [FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  if  (isEncapsulator(in.lookAhead()))  {    c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {  [BUGGY]  [BUGGY]    if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {    throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P14_Delete_Statement]
[PATCH]  c  =  in.read  (  )  ;	[BUG]  [BUGGY]  int  lastChar  =  in.readAgain(  )  ;c  =  in.read(  )  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  if  (isEncapsulator(in.lookAhead()))  {    c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {  [BUGGY]  int  lastChar  =  in.readAgain(  )  ;c  =  in.read(  )  ;  [BUGGY]  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {    throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P11_Insert_Donor_Statement]
[PATCH]  c  =  in.read  (  )  ;	[BUG]  [BUGGY]  int  c  =  in.read(  )  ;c  =  in.read(  )  ;[CE]  variable  c  is  already  defined  in  method  encapsulatedTokenLexer(Token,int)  [CONTEXT]  if  (isEncapsulator(in.lookAhead()))  {    c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {  [BUGGY]  int  c  =  in.read(  )  ;c  =  in.read(  )  ;  [BUGGY]  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {    throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P11_Insert_Donor_Statement]
[PATCH]  c  =  in.read  (  )  ;	[BUG]  [BUGGY]  in.readLine(  )  ;c  =  in.read(  )  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  if  (isEncapsulator(in.lookAhead()))  {    c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {  [BUGGY]  in.readLine(  )  ;c  =  in.read(  )  ;  [BUGGY]  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {    throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P11_Insert_Donor_Statement]
[PATCH]  }  else  if  (  isEndOfFile  (  c  )  )  {	[BUG]  [BUGGY]  }  else  if  (  isEndOfLine(  startLineNumber)  )  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  if  (isEncapsulator(in.lookAhead()))  {    c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  [BUGGY]  }  else  if  (  isEndOfLine(  startLineNumber)  )  {  [BUGGY]  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {    throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P8_Replace_Mix]
[PATCH]  }  else  if  (  isEndOfLine  (  c  )  )  {	[BUG]  [BUGGY]  }  if  (  isEndOfLine(  startLineNumber)  )  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  if  (isEncapsulator(in.lookAhead()))  {    c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  [BUGGY]  }  if  (  isEndOfLine(  startLineNumber)  )  {  [BUGGY]    tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {    throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P8_Replace_Mix]
[PATCH]  tkn.type  =  EOF;	[BUG]  [BUGGY]  tkn.type  =  4;[CE]  incompatible  types  [CONTEXT]  if  (isEncapsulator(in.lookAhead()))  {    c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  [BUGGY]  tkn.type  =  4;  [BUGGY]  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {    throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P5_Replace_Variable]
[PATCH]  c  =  in.read  (  )  ;	[BUG]  [BUGGY]  c  ;[CE]  not  a  statement  [CONTEXT]  if  (isEncapsulator(in.lookAhead()))  {    c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {  [BUGGY]  c  ;  [BUGGY]  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {    throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P8_Replace_Mix]
[PATCH]  tkn.type  =  TOKEN;	[BUG]  [BUGGY]  tkn.type  =  null  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  if  (isEncapsulator(in.lookAhead()))  {    c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  [BUGGY]  tkn.type  =  null  ;  [BUGGY]  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {    throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P8_Replace_Mix]
[PATCH]  tkn.type  =  EOF;	[BUG]  [BUGGY]  tkn.type  =  this;[CE]  incompatible  types  [CONTEXT]  if  (isEncapsulator(in.lookAhead()))  {    c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  [BUGGY]  tkn.type  =  this;  [BUGGY]  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {    throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P5_Replace_Variable]
[PATCH]  c  =  in.read  (  )  ;	[BUG]  [BUGGY]  c  =  in.readLine(  )  ;[CE]  incompatible  types  [CONTEXT]      private  Token  encapsulatedTokenLexer(Token  tkn,  int  c)  throws  IOException  {    int  startLineNumber  =  getLineNumber();      while  (true)  {  c  =  in.read();  if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  if  (isEncapsulator(c))  {  if  (isEncapsulator(in.lookAhead()))  {    [BUGGY]  c  =  in.readLine(  )  ;  [BUGGY]  tkn.content.append((char)  c);  }  else  {    while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P7_Replace_Invocation]
[PATCH]  c  =  in.read  (  )  ;	[BUG]  [BUGGY]  c  =  c  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]      private  Token  encapsulatedTokenLexer(Token  tkn,  int  c)  throws  IOException  {    int  startLineNumber  =  getLineNumber();      while  (true)  {  c  =  in.read();  if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  if  (isEncapsulator(c))  {  if  (isEncapsulator(in.lookAhead()))  {    [BUGGY]  c  =  c  ;  [BUGGY]  tkn.content.append((char)  c);  }  else  {    while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P8_Replace_Mix]
[PATCH]  c  =  in.read  (  )  ;	[BUG]  [BUGGY]  c  =  in.readAgain(  )  ;c  =  in.read(  )  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]      private  Token  encapsulatedTokenLexer(Token  tkn,  int  c)  throws  IOException  {    int  startLineNumber  =  getLineNumber();      while  (true)  {  c  =  in.read();  if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  if  (isEncapsulator(c))  {  if  (isEncapsulator(in.lookAhead()))  {    [BUGGY]  c  =  in.readAgain(  )  ;c  =  in.read(  )  ;  [BUGGY]  tkn.content.append((char)  c);  }  else  {    while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P11_Insert_Donor_Statement]
[PATCH]  c  =  in.read  (  )  ;  tkn.content.append  (  (  char  )  c  )  ;	[BUG]  [BUGGY]  [FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]      private  Token  encapsulatedTokenLexer(Token  tkn,  int  c)  throws  IOException  {    int  startLineNumber  =  getLineNumber();      while  (true)  {  c  =  in.read();  if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  if  (isEncapsulator(c))  {  if  (isEncapsulator(in.lookAhead()))  {    [BUGGY]  [BUGGY]    }  else  {    while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {      [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P14_Delete_Statement]
[PATCH]  c  =  in.read  (  )  ;	[BUG]  [BUGGY]  int  lastChar  =  in.readAgain(  )  ;c  =  in.read(  )  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]      private  Token  encapsulatedTokenLexer(Token  tkn,  int  c)  throws  IOException  {    int  startLineNumber  =  getLineNumber();      while  (true)  {  c  =  in.read();  if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  if  (isEncapsulator(c))  {  if  (isEncapsulator(in.lookAhead()))  {    [BUGGY]  int  lastChar  =  in.readAgain(  )  ;c  =  in.read(  )  ;  [BUGGY]  tkn.content.append((char)  c);  }  else  {    while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P11_Insert_Donor_Statement]
[PATCH]  c  =  in.read  (  )  ;	[BUG]  [BUGGY]  int  c  =  in.read(  )  ;c  =  in.read(  )  ;[CE]  variable  c  is  already  defined  in  method  encapsulatedTokenLexer(Token,int)  [CONTEXT]      private  Token  encapsulatedTokenLexer(Token  tkn,  int  c)  throws  IOException  {    int  startLineNumber  =  getLineNumber();      while  (true)  {  c  =  in.read();  if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  if  (isEncapsulator(c))  {  if  (isEncapsulator(in.lookAhead()))  {    [BUGGY]  int  c  =  in.read(  )  ;c  =  in.read(  )  ;  [BUGGY]  tkn.content.append((char)  c);  }  else  {    while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P11_Insert_Donor_Statement]
[PATCH]  c  =  in.read  (  )  ;	[BUG]  [BUGGY]  in.readLine(  )  ;c  =  in.read(  )  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]      private  Token  encapsulatedTokenLexer(Token  tkn,  int  c)  throws  IOException  {    int  startLineNumber  =  getLineNumber();      while  (true)  {  c  =  in.read();  if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  if  (isEncapsulator(c))  {  if  (isEncapsulator(in.lookAhead()))  {    [BUGGY]  in.readLine(  )  ;c  =  in.read(  )  ;  [BUGGY]  tkn.content.append((char)  c);  }  else  {    while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P11_Insert_Donor_Statement]
[PATCH]  tkn.content.append  (  (  char  )  c  )  ;	[BUG]  [BUGGY]  [FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]    private  Token  encapsulatedTokenLexer(Token  tkn,  int  c)  throws  IOException  {    int  startLineNumber  =  getLineNumber();      while  (true)  {  c  =  in.read();  if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  if  (isEncapsulator(c))  {  if  (isEncapsulator(in.lookAhead()))  {    c  =  in.read();  [BUGGY]  [BUGGY]    }  else  {    while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P14_Delete_Statement]
[PATCH]  tkn.content.append  (  (  char  )  c  )  ;	[BUG]  [BUGGY]  tkn.content.append(  (  char)  readEscape(  c)  )  ;tkn.content.append(  (  char)  c)  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]    private  Token  encapsulatedTokenLexer(Token  tkn,  int  c)  throws  IOException  {    int  startLineNumber  =  getLineNumber();      while  (true)  {  c  =  in.read();  if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  if  (isEncapsulator(c))  {  if  (isEncapsulator(in.lookAhead()))  {    c  =  in.read();  [BUGGY]  tkn.content.append(  (  char)  readEscape(  c)  )  ;tkn.content.append(  (  char)  c)  ;  [BUGGY]  }  else  {    while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  return  tkn;    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P11_Insert_Donor_Statement]
[PATCH]  }  else  if  (  isEndOfLine  (  c  )  )  {	[BUG]  [BUGGY]  }  if  (  isEndOfFile(  startLineNumber)  )  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  if  (isEncapsulator(in.lookAhead()))  {    c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  [BUGGY]  }  if  (  isEndOfFile(  startLineNumber)  )  {  [BUGGY]    tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {    throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }  }  else  if  (isEndOfFile(c))  {    throw  new  IOException( "(startline   "  +  startLineNumber  +   ")  EOF  reached  before  encapsulated  token  finished ");  }  else  {    tkn.content.append((char)  c);    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P8_Replace_Mix]
[PATCH]  }  else  if  (  isEndOfLine  (  c  )  )  {	[BUG]  [BUGGY]  }  if  (  isEndOfFile(  c)  )  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  if  (isEncapsulator(in.lookAhead()))  {    c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  [BUGGY]  }  if  (  isEndOfFile(  c)  )  {  [BUGGY]    tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {    throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }  }  else  if  (isEndOfFile(c))  {    throw  new  IOException( "(startline   "  +  startLineNumber  +   ")  EOF  reached  before  encapsulated  token  finished ");  }  else  {    tkn.content.append((char)  c);    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P8_Replace_Mix]
[PATCH]  tkn.type  =  TOKEN;	[BUG]  [BUGGY]  tkn.type  =  this;[CE]  incompatible  types  [CONTEXT]  while  (true)  {  c  =  in.read();  if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  if  (isEncapsulator(c))  {  if  (isEncapsulator(in.lookAhead()))  {    c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  [BUGGY]  tkn.type  =  this;  [BUGGY]  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {    throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P5_Replace_Variable]
[PATCH]  tkn.type  =  EOF;	[BUG]  [BUGGY]  tkn.type  =  this;[CE]  incompatible  types  [CONTEXT]  if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  if  (isEncapsulator(c))  {  if  (isEncapsulator(in.lookAhead()))  {    c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  [BUGGY]  tkn.type  =  this;  [BUGGY]  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {    throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }  }  else  if  (isEndOfFile(c))  {    throw  new  IOException( "(startline   "  +  startLineNumber  +   ")  EOF  reached  before  encapsulated  token  finished ");    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P5_Replace_Variable]
[PATCH]  tkn.type  =  EOF;	[BUG]  [BUGGY]  tkn.type  =  null;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  if  (isEncapsulator(c))  {  if  (isEncapsulator(in.lookAhead()))  {    c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  [BUGGY]  tkn.type  =  null;  [BUGGY]  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {    throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }  }  else  if  (isEndOfFile(c))  {    throw  new  IOException( "(startline   "  +  startLineNumber  +   ")  EOF  reached  before  encapsulated  token  finished ");    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P5_Replace_Variable]
[PATCH]  c  =  in.read  (  )  ;	[BUG]  [BUGGY]  [FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]      private  Token  encapsulatedTokenLexer(Token  tkn,  int  c)  throws  IOException  {    int  startLineNumber  =  getLineNumber();      while  (true)  {  c  =  in.read();  if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  if  (isEncapsulator(c))  {  if  (isEncapsulator(in.lookAhead()))  {    [BUGGY]  [BUGGY]    tkn.content.append((char)  c);  }  else  {    while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {      [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P14_Delete_Statement]
[PATCH]  c  =  in.read  (  )  ;	[BUG]  [BUGGY]  c  =  2.read(  )  ;[CE]  ';'  expected  [CONTEXT]      while  (true)  {  c  =  in.read();  if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  if  (isEncapsulator(c))  {  if  (isEncapsulator(in.lookAhead()))  {    c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {  [BUGGY]  c  =  2.read(  )  ;  [BUGGY]  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {    throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P5_Replace_Variable]
[PATCH]  }  else  if  (  isEndOfFile  (  c  )  )  {	[BUG]  [BUGGY]  }  if  (  isEndOfLine(  startLineNumber)  )  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  if  (isEncapsulator(in.lookAhead()))  {    c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  [BUGGY]  }  if  (  isEndOfLine(  startLineNumber)  )  {  [BUGGY]  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {    throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P8_Replace_Mix]
[PATCH]  }  else  if  (  !isWhitespace  (  c  )  )  {	[BUG]  [BUGGY]  }  if  (  !isEscape(  startLineNumber)  )  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  if  (isEncapsulator(in.lookAhead()))  {    c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  return  tkn;  [BUGGY]  }  if  (  !isEscape(  startLineNumber)  )  {  [BUGGY]    throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P8_Replace_Mix]
[PATCH]  tkn.type  =  EOF;	[BUG]  [BUGGY]  tkn.type  =  null;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  if  (isEncapsulator(in.lookAhead()))  {    c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  [BUGGY]  tkn.type  =  null;  [BUGGY]  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {    throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P5_Replace_Variable]
[PATCH]  throw  new  IOException  ( "   ")  ;	[BUG]  [BUGGY]  return  true;[CE]  incompatible  types  [CONTEXT]  if  (isEncapsulator(in.lookAhead()))  {    c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {    [BUGGY]  return  true;  [BUGGY]  }  }  }    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P8_Replace_Mix]
[PATCH]  c  =  in.read  (  )  ;	[BUG]  [BUGGY]  c  =  0.read(  )  ;[CE]  ';'  expected  [CONTEXT]  if  (isEncapsulator(in.lookAhead()))  {    c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {  [BUGGY]  c  =  0.read(  )  ;  [BUGGY]  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {    throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P5_Replace_Variable]
[PATCH]  }  else  if  (  isEndOfFile  (  c  )  )  {	[BUG]  [BUGGY]  }  if  (  isEndOfFile(  startLineNumber)  )  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  if  (isEncapsulator(in.lookAhead()))  {    c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  [BUGGY]  }  if  (  isEndOfFile(  startLineNumber)  )  {  [BUGGY]  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {    throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P8_Replace_Mix]
[PATCH]  c  =  in.read  (  )  ;	[BUG]  [BUGGY]  c  =  null.read(  )  ;[CE]  <null>  cannot  be  dereferenced  [CONTEXT]  if  (isEncapsulator(in.lookAhead()))  {    c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {  [BUGGY]  c  =  null.read(  )  ;  [BUGGY]  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {    throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P5_Replace_Variable]
[PATCH]  if  (  isDelimiter  (  c  )  )  {	[BUG]  [BUGGY]  if  (  isEscape(  startLineNumber)  )  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  if  (isEncapsulator(in.lookAhead()))  {    c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {  c  =  in.read();  [BUGGY]  if  (  isEscape(  startLineNumber)  )  {  [BUGGY]  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {    throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P8_Replace_Mix]
[PATCH]  }  else  if  (  isEndOfFile  (  c  )  )  {	[BUG]  [BUGGY]  }  if  (  isEndOfLine(  startLineNumber)  )  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  if  (isEncapsulator(c))  {  if  (isEncapsulator(in.lookAhead()))  {    c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  [BUGGY]  }  if  (  isEndOfLine(  startLineNumber)  )  {  [BUGGY]  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {    throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }  }  else  if  (isEndOfFile(c))  {      [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P8_Replace_Mix]
[PATCH]  }  else  if  (  !isWhitespace  (  c  )  )  {	[BUG]  [BUGGY]  }  if  (  !isEscape(  c)  )  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  }  else  {    while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  return  tkn;  [BUGGY]  }  if  (  !isEscape(  c)  )  {  [BUGGY]    throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }  }  else  if  (isEndOfFile(c))  {    throw  new  IOException( "(startline   "  +  startLineNumber  +   ")  EOF  reached  before  encapsulated  token  finished ");  }  else  {    tkn.content.append((char)  c);  }  }  }      [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P8_Replace_Mix]
[PATCH]  }  else  if  (  isEncapsulator  (  c  )  )  {	[BUG]  [BUGGY]  }  else  if  (  isEncapsulator(  startLineNumber)  )  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]            private  Token  encapsulatedTokenLexer(Token  tkn,  int  c)  throws  IOException  {    int  startLineNumber  =  getLineNumber();      while  (true)  {  c  =  in.read();  if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  [BUGGY]  }  else  if  (  isEncapsulator(  startLineNumber)  )  {  [BUGGY]  if  (isEncapsulator(in.lookAhead()))  {    c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P5_Replace_Variable]
[PATCH]  }  else  if  (  isEndOfFile  (  c  )  )  {	[BUG]  [BUGGY]  }  else  if  (  isEndOfLine(  startLineNumber)  )  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {    throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }  [BUGGY]  }  else  if  (  isEndOfLine(  startLineNumber)  )  {  [BUGGY]    throw  new  IOException( "(startline   "  +  startLineNumber  +   ")  EOF  reached  before  encapsulated  token  finished ");  }  else  {    tkn.content.append((char)  c);  }  }  }  }    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P8_Replace_Mix]
[PATCH]  tkn.content.append  (  (  char  )  readEscape  (  c  )  )  ;	[BUG]  [BUGGY]  tkn.content.append(  (  char)  isEscape(  c)  )  ;[CE]  inconvertible  types  [CONTEXT]              private  Token  encapsulatedTokenLexer(Token  tkn,  int  c)  throws  IOException  {    int  startLineNumber  =  getLineNumber();      while  (true)  {  c  =  in.read();  if  (isEscape(c))  {  [BUGGY]  tkn.content.append(  (  char)  isEscape(  c)  )  ;  [BUGGY]  }  else  if  (isEncapsulator(c))  {  if  (isEncapsulator(in.lookAhead()))  {    c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P7_Replace_Invocation]
[PATCH]  tkn.content.append  (  (  char  )  readEscape  (  c  )  )  ;	[BUG]  [BUGGY]  [FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]              private  Token  encapsulatedTokenLexer(Token  tkn,  int  c)  throws  IOException  {    int  startLineNumber  =  getLineNumber();      while  (true)  {  c  =  in.read();  if  (isEscape(c))  {  [BUGGY]  [BUGGY]    }  else  if  (isEncapsulator(c))  {  if  (isEncapsulator(in.lookAhead()))  {    c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P14_Delete_Statement]
[PATCH]  tkn.content.append  (  (  char  )  readEscape  (  c  )  )  ;	[BUG]  [BUGGY]  tkn.content.append(  (  int)  readEscape(  c)  )  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]              private  Token  encapsulatedTokenLexer(Token  tkn,  int  c)  throws  IOException  {    int  startLineNumber  =  getLineNumber();      while  (true)  {  c  =  in.read();  if  (isEscape(c))  {  [BUGGY]  tkn.content.append(  (  int)  readEscape(  c)  )  ;  [BUGGY]  }  else  if  (isEncapsulator(c))  {  if  (isEncapsulator(in.lookAhead()))  {    c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P1_Replace_Type]
[PATCH]  tkn.content.append  (  (  char  )  readEscape  (  c  )  )  ;	[BUG]  [BUGGY]  tkn.content.append(  (  startLineNumberhar)  readEscape(  c)  )  ;[CE]  cannot  find  symbol  [CONTEXT]              private  Token  encapsulatedTokenLexer(Token  tkn,  int  c)  throws  IOException  {    int  startLineNumber  =  getLineNumber();      while  (true)  {  c  =  in.read();  if  (isEscape(c))  {  [BUGGY]  tkn.content.append(  (  startLineNumberhar)  readEscape(  c)  )  ;  [BUGGY]  }  else  if  (isEncapsulator(c))  {  if  (isEncapsulator(in.lookAhead()))  {    c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P5_Replace_Variable]
[PATCH]  }  else  if  (  isEncapsulator  (  c  )  )  {	[BUG]  [BUGGY]  }  if  (  getLineNumber(  c)  )  {[CE]  method  getLineNumber  in  class  Lexer  cannot  be  applied  to  given  types;  [CONTEXT]            private  Token  encapsulatedTokenLexer(Token  tkn,  int  c)  throws  IOException  {    int  startLineNumber  =  getLineNumber();      while  (true)  {  c  =  in.read();  if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  [BUGGY]  }  if  (  getLineNumber(  c)  )  {  [BUGGY]  if  (isEncapsulator(in.lookAhead()))  {    c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P8_Replace_Mix]
[PATCH]  c  =  in.read  (  )  ;	[BUG]  [BUGGY]  c  =  null  ;[CE]  incompatible  types  [CONTEXT]      while  (true)  {  c  =  in.read();  if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  if  (isEncapsulator(c))  {  if  (isEncapsulator(in.lookAhead()))  {    c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {  [BUGGY]  c  =  null  ;  [BUGGY]  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {    throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P8_Replace_Mix]
[PATCH]  tkn.type  =  EORECORD;	[BUG]  [BUGGY]  tkn.type  =  2;[CE]  incompatible  types  [CONTEXT]  if  (isEncapsulator(in.lookAhead()))  {    c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {    [BUGGY]  tkn.type  =  2;  [BUGGY]  return  tkn;  }  else  if  (!isWhitespace(c))  {    throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P5_Replace_Variable]
[PATCH]  tkn.type  =  EORECORD;	[BUG]  [BUGGY]  tkn.type  =  0;[CE]  incompatible  types  [CONTEXT]  if  (isEncapsulator(in.lookAhead()))  {    c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {    [BUGGY]  tkn.type  =  0;  [BUGGY]  return  tkn;  }  else  if  (!isWhitespace(c))  {    throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P5_Replace_Variable]
[PATCH]  c  =  in.read  (  )  ;	[BUG]  [BUGGY]  c  =  c  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  if  (isEncapsulator(in.lookAhead()))  {    c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {  [BUGGY]  c  =  c  ;  [BUGGY]  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {    throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P8_Replace_Mix]
[PATCH]  throw  new  IOException  ( "   ")  ;	[BUG]  [BUGGY]  return  0;[CE]  incompatible  types  [CONTEXT]  if  (isEncapsulator(in.lookAhead()))  {    c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {    [BUGGY]  return  0;  [BUGGY]  }  }  }    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P8_Replace_Mix]
[PATCH]  tkn.type  =  EORECORD;	[BUG]  [BUGGY]  tkn.type  =  3;[CE]  incompatible  types  [CONTEXT]  if  (isEncapsulator(in.lookAhead()))  {    c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {    [BUGGY]  tkn.type  =  3;  [BUGGY]  return  tkn;  }  else  if  (!isWhitespace(c))  {    throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P5_Replace_Variable]
[PATCH]  c  =  in.read  (  )  ;	[BUG]  [BUGGY]  c  ;[CE]  not  a  statement  [CONTEXT]      private  Token  encapsulatedTokenLexer(Token  tkn,  int  c)  throws  IOException  {    int  startLineNumber  =  getLineNumber();      while  (true)  {  c  =  in.read();  if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  if  (isEncapsulator(c))  {  if  (isEncapsulator(in.lookAhead()))  {    [BUGGY]  c  ;  [BUGGY]  tkn.content.append((char)  c);  }  else  {    while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P8_Replace_Mix]
[PATCH]  throw  new  IOException  ( "   ")  ;	[BUG]  [BUGGY]  return  true;[CE]  incompatible  types  [CONTEXT]  while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {    [BUGGY]  return  true;  [BUGGY]  }  }  }  }  else  if  (isEndOfFile(c))  {    throw  new  IOException( "(startline   "  +  startLineNumber  +   ")  EOF  reached  before  encapsulated  token  finished ");  }  else  {    tkn.content.append((char)  c);  }  }  }  }    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P8_Replace_Mix]
[PATCH]  tkn.type  =  EORECORD;	[BUG]  [BUGGY]  tkn.type  =  0;[CE]  incompatible  types  [CONTEXT]  c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {    [BUGGY]  tkn.type  =  0;  [BUGGY]  return  tkn;  }  else  if  (!isWhitespace(c))  {    throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }  }  else  if  (isEndOfFile(c))  {    throw  new  IOException( "(startline   "  +  startLineNumber  +   ")  EOF  reached  before  encapsulated  token  finished ");  }  else  {    tkn.content.append((char)  c);  }  }    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P5_Replace_Variable]
[PATCH]  tkn.type  =  EORECORD;	[BUG]  [BUGGY]  tkn.type  =  2;[CE]  incompatible  types  [CONTEXT]  c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {    [BUGGY]  tkn.type  =  2;  [BUGGY]  return  tkn;  }  else  if  (!isWhitespace(c))  {    throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }  }  else  if  (isEndOfFile(c))  {    throw  new  IOException( "(startline   "  +  startLineNumber  +   ")  EOF  reached  before  encapsulated  token  finished ");  }  else  {    tkn.content.append((char)  c);  }  }    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P5_Replace_Variable]
[PATCH]  if  (  isEncapsulator  (  in.lookAhead  (  )  )  )  {	[BUG]  [BUGGY]  if  (  isEncapsulator(  2.lookAhead(  )  )  )  {[CE]  ')'  expected  [CONTEXT]          private  Token  encapsulatedTokenLexer(Token  tkn,  int  c)  throws  IOException  {    int  startLineNumber  =  getLineNumber();      while  (true)  {  c  =  in.read();  if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  if  (isEncapsulator(c))  {  [BUGGY]  if  (  isEncapsulator(  2.lookAhead(  )  )  )  {  [BUGGY]    c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P5_Replace_Variable]
[PATCH]  c  =  in.read  (  )  ;	[BUG]  [BUGGY]  c  =  1.read(  )  ;[CE]  ';'  expected  [CONTEXT]      private  Token  encapsulatedTokenLexer(Token  tkn,  int  c)  throws  IOException  {    int  startLineNumber  =  getLineNumber();      while  (true)  {  c  =  in.read();  if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  if  (isEncapsulator(c))  {  if  (isEncapsulator(in.lookAhead()))  {    [BUGGY]  c  =  1.read(  )  ;  [BUGGY]  tkn.content.append((char)  c);  }  else  {    while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P8_Replace_Mix]
[PATCH]  }  else  if  (  isEndOfLine  (  c  )  )  {	[BUG]  [BUGGY]  }  if  (  isEndOfFile(  c)  )  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  if  (isEncapsulator(in.lookAhead()))  {    c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  [BUGGY]  }  if  (  isEndOfFile(  c)  )  {  [BUGGY]    tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {    throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P8_Replace_Mix]
[PATCH]  c  =  in.read  (  )  ;	[BUG]  [BUGGY]  c  =  null  ;[CE]  incompatible  types  [CONTEXT]      private  Token  encapsulatedTokenLexer(Token  tkn,  int  c)  throws  IOException  {    int  startLineNumber  =  getLineNumber();      while  (true)  {  c  =  in.read();  if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  if  (isEncapsulator(c))  {  if  (isEncapsulator(in.lookAhead()))  {    [BUGGY]  c  =  null  ;  [BUGGY]  tkn.content.append((char)  c);  }  else  {    while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P8_Replace_Mix]
[PATCH]  c  =  in.read  (  )  ;	[BUG]  [BUGGY]  c  =  this.read(  )  ;[CE]  cannot  find  symbol  [CONTEXT]      private  Token  encapsulatedTokenLexer(Token  tkn,  int  c)  throws  IOException  {    int  startLineNumber  =  getLineNumber();      while  (true)  {  c  =  in.read();  if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  if  (isEncapsulator(c))  {  if  (isEncapsulator(in.lookAhead()))  {    [BUGGY]  c  =  this.read(  )  ;  [BUGGY]  tkn.content.append((char)  c);  }  else  {    while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P5_Replace_Variable]
[PATCH]  c  =  in.read  (  )  ;	[BUG]  [BUGGY]  c  =  null.readLine(  )  ;[CE]  <null>  cannot  be  dereferenced  [CONTEXT]      private  Token  encapsulatedTokenLexer(Token  tkn,  int  c)  throws  IOException  {    int  startLineNumber  =  getLineNumber();      while  (true)  {  c  =  in.read();  if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  if  (isEncapsulator(c))  {  if  (isEncapsulator(in.lookAhead()))  {    [BUGGY]  c  =  null.readLine(  )  ;  [BUGGY]  tkn.content.append((char)  c);  }  else  {    while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P8_Replace_Mix]
[PATCH]  c  =  in.read  (  )  ;	[BUG]  [BUGGY]  c  =  in.readLine(  )  ;[CE]  incompatible  types  [CONTEXT]                    private  Token  encapsulatedTokenLexer(Token  tkn,  int  c)  throws  IOException  {    int  startLineNumber  =  getLineNumber();      while  (true)  {  [BUGGY]  c  =  in.readLine(  )  ;  [BUGGY]    if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  if  (isEncapsulator(c))  {  if  (isEncapsulator(in.lookAhead()))  {    c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P7_Replace_Invocation]
[PATCH]  c  =  in.read  (  )  ;	[BUG]  [BUGGY]  c  =  null  ;[CE]  incompatible  types  [CONTEXT]                    private  Token  encapsulatedTokenLexer(Token  tkn,  int  c)  throws  IOException  {    int  startLineNumber  =  getLineNumber();      while  (true)  {  [BUGGY]  c  =  null  ;  [BUGGY]    if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  if  (isEncapsulator(c))  {  if  (isEncapsulator(in.lookAhead()))  {    c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P8_Replace_Mix]
[PATCH]  c  =  in.read  (  )  ;	[BUG]  [BUGGY]  c  =  in.readAgain(  )  ;c  =  in.read(  )  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]                    private  Token  encapsulatedTokenLexer(Token  tkn,  int  c)  throws  IOException  {    int  startLineNumber  =  getLineNumber();      while  (true)  {  [BUGGY]  c  =  in.readAgain(  )  ;c  =  in.read(  )  ;  [BUGGY]    if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  if  (isEncapsulator(c))  {  if  (isEncapsulator(in.lookAhead()))  {    c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P11_Insert_Donor_Statement]
[PATCH]  c  =  in.read  (  )  ;	[BUG]  [BUGGY]  [FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]                    private  Token  encapsulatedTokenLexer(Token  tkn,  int  c)  throws  IOException  {    int  startLineNumber  =  getLineNumber();      while  (true)  {  [BUGGY]  [BUGGY]    if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  if  (isEncapsulator(c))  {  if  (isEncapsulator(in.lookAhead()))  {    c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P14_Delete_Statement]
[PATCH]  c  =  in.read  (  )  ;	[BUG]  [BUGGY]  int  lastChar  =  in.readAgain(  )  ;c  =  in.read(  )  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]                    private  Token  encapsulatedTokenLexer(Token  tkn,  int  c)  throws  IOException  {    int  startLineNumber  =  getLineNumber();      while  (true)  {  [BUGGY]  int  lastChar  =  in.readAgain(  )  ;c  =  in.read(  )  ;  [BUGGY]    if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  if  (isEncapsulator(c))  {  if  (isEncapsulator(in.lookAhead()))  {    c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P11_Insert_Donor_Statement]
[PATCH]  c  =  in.read  (  )  ;	[BUG]  [BUGGY]  int  c  =  in.read(  )  ;c  =  in.read(  )  ;[CE]  variable  c  is  already  defined  in  method  encapsulatedTokenLexer(Token,int)  [CONTEXT]                    private  Token  encapsulatedTokenLexer(Token  tkn,  int  c)  throws  IOException  {    int  startLineNumber  =  getLineNumber();      while  (true)  {  [BUGGY]  int  c  =  in.read(  )  ;c  =  in.read(  )  ;  [BUGGY]    if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  if  (isEncapsulator(c))  {  if  (isEncapsulator(in.lookAhead()))  {    c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P11_Insert_Donor_Statement]
[PATCH]  c  =  in.read  (  )  ;	[BUG]  [BUGGY]  in.readLine(  )  ;c  =  in.read(  )  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]                    private  Token  encapsulatedTokenLexer(Token  tkn,  int  c)  throws  IOException  {    int  startLineNumber  =  getLineNumber();      while  (true)  {  [BUGGY]  in.readLine(  )  ;c  =  in.read(  )  ;  [BUGGY]    if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  if  (isEncapsulator(c))  {  if  (isEncapsulator(in.lookAhead()))  {    c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P11_Insert_Donor_Statement]
[PATCH]  if  (  isEscape  (  c  )  )  {	[BUG]  [BUGGY]  if  (  isEscape(  startLineNumber)  )  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]                private  Token  encapsulatedTokenLexer(Token  tkn,  int  c)  throws  IOException  {    int  startLineNumber  =  getLineNumber();      while  (true)  {  c  =  in.read();  [BUGGY]  if  (  isEscape(  startLineNumber)  )  {  [BUGGY]  tkn.content.append((char)  readEscape(c));  }  else  if  (isEncapsulator(c))  {  if  (isEncapsulator(in.lookAhead()))  {    c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P5_Replace_Variable]
[PATCH]  c  =  in.read  (  )  ;	[BUG]  [BUGGY]  c  =  this.read(  )  ;[CE]  cannot  find  symbol  [CONTEXT]      while  (true)  {  c  =  in.read();  if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  if  (isEncapsulator(c))  {  if  (isEncapsulator(in.lookAhead()))  {    c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {  [BUGGY]  c  =  this.read(  )  ;  [BUGGY]  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {    throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P8_Replace_Mix]
[PATCH]  }  else  if  (  !isWhitespace  (  c  )  )  {	[BUG]  [BUGGY]  }  if  (  !isEscape(  startLineNumber)  )  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  }  else  {    while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  return  tkn;  [BUGGY]  }  if  (  !isEscape(  startLineNumber)  )  {  [BUGGY]    throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }  }  else  if  (isEndOfFile(c))  {    throw  new  IOException( "(startline   "  +  startLineNumber  +   ")  EOF  reached  before  encapsulated  token  finished ");  }  else  {    tkn.content.append((char)  c);  }  }  }      [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P8_Replace_Mix]
[PATCH]  tkn.type  =  EORECORD;	[BUG]  [BUGGY]  tkn.type  =  4;[CE]  incompatible  types  [CONTEXT]  c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {    [BUGGY]  tkn.type  =  4;  [BUGGY]  return  tkn;  }  else  if  (!isWhitespace(c))  {    throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }  }  else  if  (isEndOfFile(c))  {    throw  new  IOException( "(startline   "  +  startLineNumber  +   ")  EOF  reached  before  encapsulated  token  finished ");  }  else  {    tkn.content.append((char)  c);  }  }    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P5_Replace_Variable]
[PATCH]  tkn.type  =  EOF;	[BUG]  [BUGGY]  tkn.type  =  2;[CE]  incompatible  types  [CONTEXT]  if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  if  (isEncapsulator(c))  {  if  (isEncapsulator(in.lookAhead()))  {    c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  [BUGGY]  tkn.type  =  2;  [BUGGY]  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {    throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }  }  else  if  (isEndOfFile(c))  {    throw  new  IOException( "(startline   "  +  startLineNumber  +   ")  EOF  reached  before  encapsulated  token  finished ");    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P5_Replace_Variable]
[PATCH]  if  (  isEncapsulator  (  in.lookAhead  (  )  )  )  {	[BUG]  [BUGGY]  if  (  isEncapsulator(  null.lookAhead(  )  )  )  {[CE]  <null>  cannot  be  dereferenced  [CONTEXT]          private  Token  encapsulatedTokenLexer(Token  tkn,  int  c)  throws  IOException  {    int  startLineNumber  =  getLineNumber();      while  (true)  {  c  =  in.read();  if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  if  (isEncapsulator(c))  {  [BUGGY]  if  (  isEncapsulator(  null.lookAhead(  )  )  )  {  [BUGGY]    c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P8_Replace_Mix]
[PATCH]  tkn.type  =  TOKEN;	[BUG]  [BUGGY]  tkn.type  =  1;[CE]  incompatible  types  [CONTEXT]  if  (isEncapsulator(in.lookAhead()))  {    c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  [BUGGY]  tkn.type  =  1;  [BUGGY]  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {    throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P5_Replace_Variable]
[PATCH]  tkn.type  =  EOF;	[BUG]  [BUGGY]  tkn.type  =  2;[CE]  incompatible  types  [CONTEXT]  if  (isEncapsulator(in.lookAhead()))  {    c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  [BUGGY]  tkn.type  =  2;  [BUGGY]  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {    throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P5_Replace_Variable]
[PATCH]  c  =  in.read  (  )  ;	[BUG]  [BUGGY]  c  =  2.read(  )  ;[CE]  ';'  expected  [CONTEXT]  if  (isEncapsulator(in.lookAhead()))  {    c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {  [BUGGY]  c  =  2.read(  )  ;  [BUGGY]  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {    throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P5_Replace_Variable]
[PATCH]  c  =  in.read  (  )  ;	[BUG]  [BUGGY]  c  =  null.read(  )  ;[CE]  <null>  cannot  be  dereferenced  [CONTEXT]      private  Token  encapsulatedTokenLexer(Token  tkn,  int  c)  throws  IOException  {    int  startLineNumber  =  getLineNumber();      while  (true)  {  c  =  in.read();  if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  if  (isEncapsulator(c))  {  if  (isEncapsulator(in.lookAhead()))  {    [BUGGY]  c  =  null.read(  )  ;  [BUGGY]  tkn.content.append((char)  c);  }  else  {    while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P5_Replace_Variable]
[PATCH]  tkn.content.append  (  (  char  )  readEscape  (  c  )  )  ;	[BUG]  [BUGGY]  tkn.content.append(  (  startLineNumberhar)  isEscape(  c)  )  ;[CE]  cannot  find  symbol  [CONTEXT]              private  Token  encapsulatedTokenLexer(Token  tkn,  int  c)  throws  IOException  {    int  startLineNumber  =  getLineNumber();      while  (true)  {  c  =  in.read();  if  (isEscape(c))  {  [BUGGY]  tkn.content.append(  (  startLineNumberhar)  isEscape(  c)  )  ;  [BUGGY]  }  else  if  (isEncapsulator(c))  {  if  (isEncapsulator(in.lookAhead()))  {    c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P8_Replace_Mix]
[PATCH]  throw  new  IOException  ( "   ")  ;	[BUG]  [BUGGY]  return  false;[CE]  incompatible  types  [CONTEXT]  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {    throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }  }  else  if  (isEndOfFile(c))  {    [BUGGY]  return  false;  [BUGGY]  }  else  {    tkn.content.append((char)  c);  }  }  }  }    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P8_Replace_Mix]
[PATCH]  throw  new  IOException  ( "   ")  ;	[BUG]  [BUGGY]  return  0;[CE]  incompatible  types  [CONTEXT]  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {    throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }  }  else  if  (isEndOfFile(c))  {    [BUGGY]  return  0;  [BUGGY]  }  else  {    tkn.content.append((char)  c);  }  }  }  }    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P8_Replace_Mix]
[PATCH]  c  =  in.read  (  )  ;	[BUG]  [BUGGY]  c  =  this.read(  )  ;[CE]  cannot  find  symbol  [CONTEXT]  if  (isEncapsulator(in.lookAhead()))  {    c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {  [BUGGY]  c  =  this.read(  )  ;  [BUGGY]  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {    tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {    throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P8_Replace_Mix]
[PATCH]  if  (  isEncapsulator  (  in.lookAhead  (  )  )  )  {	[BUG]  [BUGGY]  if  (  isEncapsulator(  4.lookAhead(  )  )  )  {[CE]  ')'  expected  [CONTEXT]          private  Token  encapsulatedTokenLexer(Token  tkn,  int  c)  throws  IOException  {    int  startLineNumber  =  getLineNumber();      while  (true)  {  c  =  in.read();  if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  if  (isEncapsulator(c))  {  [BUGGY]  if  (  isEncapsulator(  4.lookAhead(  )  )  )  {  [BUGGY]    c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P5_Replace_Variable]
[PATCH]  c  =  in.read  (  )  ;	[BUG]  [BUGGY]  c  ;[CE]  not  a  statement  [CONTEXT]                    private  Token  encapsulatedTokenLexer(Token  tkn,  int  c)  throws  IOException  {    int  startLineNumber  =  getLineNumber();      while  (true)  {  [BUGGY]  c  ;  [BUGGY]    if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  if  (isEncapsulator(c))  {  if  (isEncapsulator(in.lookAhead()))  {    c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P8_Replace_Mix]
[PATCH]  tkn.type  =  EORECORD;	[BUG]  [BUGGY]  tkn.type  =  this;[CE]  incompatible  types  [CONTEXT]  c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {    [BUGGY]  tkn.type  =  this;  [BUGGY]  return  tkn;  }  else  if  (!isWhitespace(c))  {    throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }  }  else  if  (isEndOfFile(c))  {    throw  new  IOException( "(startline   "  +  startLineNumber  +   ")  EOF  reached  before  encapsulated  token  finished ");  }  else  {    tkn.content.append((char)  c);  }  }    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P5_Replace_Variable]
[PATCH]  if  (  isEscape  (  c  )  )  {	[BUG]  [BUGGY]  if  (  readEscape(  startLineNumber)  )  {[CE]  incompatible  types  [CONTEXT]                private  Token  encapsulatedTokenLexer(Token  tkn,  int  c)  throws  IOException  {    int  startLineNumber  =  getLineNumber();      while  (true)  {  c  =  in.read();  [BUGGY]  if  (  readEscape(  startLineNumber)  )  {  [BUGGY]  tkn.content.append((char)  readEscape(c));  }  else  if  (isEncapsulator(c))  {  if  (isEncapsulator(in.lookAhead()))  {    c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P8_Replace_Mix]
[PATCH]  tkn.content.append  (  (  char  )  readEscape  (  c  )  )  ;	[BUG]  [BUGGY]  tkn.content.append(  (  String)  readEscape(  c)  )  ;[CE]  inconvertible  types  [CONTEXT]              private  Token  encapsulatedTokenLexer(Token  tkn,  int  c)  throws  IOException  {    int  startLineNumber  =  getLineNumber();      while  (true)  {  c  =  in.read();  if  (isEscape(c))  {  [BUGGY]  tkn.content.append(  (  String)  readEscape(  c)  )  ;  [BUGGY]  }  else  if  (isEncapsulator(c))  {  if  (isEncapsulator(in.lookAhead()))  {    c  =  in.read();  tkn.content.append((char)  c);  }  else  {    while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF    [CLASS]  CSVLexer  [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token    Token  tkn  int  c  [VARIABLES]  boolean  Token  tkn  int  c  startLineNumber    	[P1_Replace_Type]
[PATCH]  private  final  Appendable  out;	[BUG]  [BUGGY]  private  Appendable  out;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]      public  class  CSVPrinter  {    [BUGGY]  private  Appendable  out;  [BUGGY]  private  final  CSVFormat  format;    private  boolean  newLine  =  true;      [CLASS]  CSVPrinter    [VARIABLES]  	[P8_Replace_Mix]
[PATCH]  private  final  CSVFormat  format;	[BUG]  [BUGGY]  private  CSVFormat  format;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]    public  class  CSVPrinter  {    private  final  Appendable  out;  [BUGGY]  private  CSVFormat  format;  [BUGGY]      private  boolean  newLine  =  true;        [CLASS]  CSVPrinter    [VARIABLES]  	[P8_Replace_Mix]
[PATCH]  private  boolean  newLine  =  true;	[BUG]  [BUGGY]  private  boolean  newLine  =  false;[FE]  expected:<[]a,b,c>  but  was:<[,]a,b,c>  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]    private  final  Appendable  out;  private  final  CSVFormat  format;    [BUGGY]  private  boolean  newLine  =  false;  [BUGGY]              [CLASS]  CSVPrinter    [VARIABLES]  	[P3_Replace_Literal]
[PATCH]  private  boolean  newLine  =  true;	[BUG]  [BUGGY]  private  boolean  newLine  =  null  ;[CE]  incompatible  types  [CONTEXT]    private  final  Appendable  out;  private  final  CSVFormat  format;    [BUGGY]  private  boolean  newLine  =  null  ;  [BUGGY]              [CLASS]  CSVPrinter    [VARIABLES]  	[P8_Replace_Mix]
[PATCH]  this.out  =  out;	[BUG]  [BUGGY]  this.out  =  null;[FE]  null  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]  public  CSVPrinter(Appendable  out,  CSVFormat  format)  {  [BUGGY]  this.out  =  null;  [BUGGY]  this.format  =  format  ==  null  ?  CSVFormat.DEFAULT  :  format;  this.format.validate();  }    [CLASS]  CSVPrinter  [METHOD]  <init>  [RETURN_TYPE]  CSVFormat)    Appendable  out  CSVFormat  format  [VARIABLES]  CSVFormat  format  boolean  newLine  Appendable  out    	[P8_Replace_Mix]
[PATCH]  this.format  =  format  ==  null  ?  CSVFormat.DEFAULT  :  format;	[BUG]  [BUGGY]  this.format  =  format  !=  null  ?  CSVFormat.DEFAULT  :  format;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  CSVPrinter(Appendable  out,  CSVFormat  format)  {  this.out  =  out;  [BUGGY]  this.format  =  format  !=  null  ?  CSVFormat.DEFAULT  :  format;  [BUGGY]    this.format.validate();  }    [CLASS]  CSVPrinter  [METHOD]  <init>  [RETURN_TYPE]  CSVFormat)    Appendable  out  CSVFormat  format  [VARIABLES]  CSVFormat  format  boolean  newLine  Appendable  out    	[P2_Replace_Operator]
[PATCH]  this.format  =  format  ==  null  ?  CSVFormat.DEFAULT  :  format;	[BUG]  [BUGGY]  this.format  =  CSVFormat.DEFAULT  ==  null  ?  format  :  format;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  CSVPrinter(Appendable  out,  CSVFormat  format)  {  this.out  =  out;  [BUGGY]  this.format  =  CSVFormat.DEFAULT  ==  null  ?  format  :  format;  [BUGGY]    this.format.validate();  }    [CLASS]  CSVPrinter  [METHOD]  <init>  [RETURN_TYPE]  CSVFormat)    Appendable  out  CSVFormat  format  [VARIABLES]  CSVFormat  format  boolean  newLine  Appendable  out    	[P5_Replace_Variable]
[PATCH]  this.format  =  format  ==  null  ?  CSVFormat.DEFAULT  :  format;	[BUG]  [BUGGY]  this.format  =  format(  format;[CE]  ')'  expected  [CONTEXT]  public  CSVPrinter(Appendable  out,  CSVFormat  format)  {  this.out  =  out;  [BUGGY]  this.format  =  format(  format;  [BUGGY]    this.format.validate();  }    [CLASS]  CSVPrinter  [METHOD]  <init>  [RETURN_TYPE]  CSVFormat)    Appendable  out  CSVFormat  format  [VARIABLES]  CSVFormat  format  boolean  newLine  Appendable  out    	[P6_Replace_Expression]
[PATCH]  this.format  =  format  ==  null  ?  CSVFormat.DEFAULT  :  format;	[BUG]  [BUGGY]  this.format  =  format  ==  true  ?  CSVFormat.DEFAULT  :  format;[CE]  incomparable  types:  CSVFormat  and  boolean  [CONTEXT]  public  CSVPrinter(Appendable  out,  CSVFormat  format)  {  this.out  =  out;  [BUGGY]  this.format  =  format  ==  true  ?  CSVFormat.DEFAULT  :  format;  [BUGGY]    this.format.validate();  }    [CLASS]  CSVPrinter  [METHOD]  <init>  [RETURN_TYPE]  CSVFormat)    Appendable  out  CSVFormat  format  [VARIABLES]  CSVFormat  format  boolean  newLine  Appendable  out    	[P8_Replace_Mix]
[PATCH]  this.format.validate  (  )  ;	[BUG]  [BUGGY]  this.format.getEscape(  )  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  CSVPrinter(Appendable  out,  CSVFormat  format)  {  this.out  =  out;  this.format  =  format  ==  null  ?  CSVFormat.DEFAULT  :  format;  [BUGGY]  this.format.getEscape(  )  ;  [BUGGY]  }    [CLASS]  CSVPrinter  [METHOD]  <init>  [RETURN_TYPE]  CSVFormat)    Appendable  out  CSVFormat  format  [VARIABLES]  CSVFormat  format  boolean  newLine  Appendable  out    	[P7_Replace_Invocation]
[PATCH]  this.format.validate  (  )  ;  }	[BUG]  [BUGGY]  [CE]  illegal  start  of  expression  [CONTEXT]  public  CSVPrinter(Appendable  out,  CSVFormat  format)  {  this.out  =  out;  this.format  =  format  ==  null  ?  CSVFormat.DEFAULT  :  format;  [BUGGY]  [BUGGY]      [CLASS]  CSVPrinter  [METHOD]  <init>  [RETURN_TYPE]  CSVFormat)    Appendable  out  CSVFormat  format  [VARIABLES]  CSVFormat  format  boolean  newLine  Appendable  out    	[P14_Delete_Statement]
[PATCH]  this.format.validate  (  )  ;	[BUG]  [BUGGY]  char  delim  =  format.getDelimiter(  )  ;this.format.validate(  )  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  CSVPrinter(Appendable  out,  CSVFormat  format)  {  this.out  =  out;  this.format  =  format  ==  null  ?  CSVFormat.DEFAULT  :  format;  [BUGGY]  char  delim  =  format.getDelimiter(  )  ;this.format.validate(  )  ;  [BUGGY]  }    [CLASS]  CSVPrinter  [METHOD]  <init>  [RETURN_TYPE]  CSVFormat)    Appendable  out  CSVFormat  format  [VARIABLES]  CSVFormat  format  boolean  newLine  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  out.append  (  format.getLineSeparator  (  )  )  ;	[BUG]  [BUGGY]  out.append(  format.getEncapsulator(  )  )  ;[FE]  expected:<[]>  but  was:<[ "]>  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]  public  void  println()  throws  IOException  {  [BUGGY]  out.append(  format.getEncapsulator(  )  )  ;  [BUGGY]  newLine  =  true;  }    [CLASS]  CSVPrinter  [METHOD]  println  [RETURN_TYPE]  void    [VARIABLES]  CSVFormat  format  boolean  newLine  Appendable  out    	[P7_Replace_Invocation]
[PATCH]  out.append  (  format.getLineSeparator  (  )  )  ;  newLine  =  true;  }	[BUG]  [BUGGY]  [CE]  illegal  start  of  expression  [CONTEXT]  public  void  println()  throws  IOException  {  [BUGGY]  [BUGGY]        [CLASS]  CSVPrinter  [METHOD]  println  [RETURN_TYPE]  void    [VARIABLES]  CSVFormat  format  boolean  newLine  Appendable  out    	[P14_Delete_Statement]
[PATCH]  out.append  (  format.getLineSeparator  (  )  )  ;	[BUG]  [BUGGY]  out.append(  value,  start,  end)  ;out.append(  format.getLineSeparator(  )  )  ;[CE]  cannot  find  symbol  value  [CONTEXT]  public  void  println()  throws  IOException  {  [BUGGY]  out.append(  value,  start,  end)  ;out.append(  format.getLineSeparator(  )  )  ;  [BUGGY]  newLine  =  true;  }    [CLASS]  CSVPrinter  [METHOD]  println  [RETURN_TYPE]  void    [VARIABLES]  CSVFormat  format  boolean  newLine  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  out.append  (  format.getLineSeparator  (  )  )  ;	[BUG]  [BUGGY]  out.append(  format.getCommentStart(  )  )  ;out.append(  format.getLineSeparator(  )  )  ;[FE]  expected:<[]>  but  was:<[  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]  public  void  println()  throws  IOException  {  [BUGGY]  out.append(  format.getCommentStart(  )  )  ;out.append(  format.getLineSeparator(  )  )  ;  [BUGGY]  newLine  =  true;  }    [CLASS]  CSVPrinter  [METHOD]  println  [RETURN_TYPE]  void    [VARIABLES]  CSVFormat  format  boolean  newLine  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  out.append  (  format.getLineSeparator  (  )  )  ;	[BUG]  [BUGGY]  out.append(  value,  start,  pos)  ;out.append(  format.getLineSeparator(  )  )  ;[CE]  cannot  find  symbol  value  [CONTEXT]  public  void  println()  throws  IOException  {  [BUGGY]  out.append(  value,  start,  pos)  ;out.append(  format.getLineSeparator(  )  )  ;  [BUGGY]  newLine  =  true;  }    [CLASS]  CSVPrinter  [METHOD]  println  [RETURN_TYPE]  void    [VARIABLES]  CSVFormat  format  boolean  newLine  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  out.append  (  format.getLineSeparator  (  )  )  ;	[BUG]  [BUGGY]  out.append(  format.getDelimiter(  )  )  ;out.append(  format.getLineSeparator(  )  )  ;[FE]  expected:<[]>  but  was:<[,]>  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]  public  void  println()  throws  IOException  {  [BUGGY]  out.append(  format.getDelimiter(  )  )  ;out.append(  format.getLineSeparator(  )  )  ;  [BUGGY]  newLine  =  true;  }    [CLASS]  CSVPrinter  [METHOD]  println  [RETURN_TYPE]  void    [VARIABLES]  CSVFormat  format  boolean  newLine  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  out.append  (  format.getLineSeparator  (  )  )  ;	[BUG]  [BUGGY]  out.append(  value,  start,  pos  +  1)  ;out.append(  format.getLineSeparator(  )  )  ;[CE]  cannot  find  symbol  value  [CONTEXT]  public  void  println()  throws  IOException  {  [BUGGY]  out.append(  value,  start,  pos  +  1)  ;out.append(  format.getLineSeparator(  )  )  ;  [BUGGY]  newLine  =  true;  }    [CLASS]  CSVPrinter  [METHOD]  println  [RETURN_TYPE]  void    [VARIABLES]  CSVFormat  format  boolean  newLine  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  newLine  =  true;	[BUG]  [BUGGY]  newLine  =  false;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  void  println()  throws  IOException  {  out.append(format.getLineSeparator());  [BUGGY]  newLine  =  false;  [BUGGY]  }    [CLASS]  CSVPrinter  [METHOD]  println  [RETURN_TYPE]  void    [VARIABLES]  CSVFormat  format  boolean  newLine  Appendable  out    	[P3_Replace_Literal]
[PATCH]  newLine  =  true;	[BUG]  [BUGGY]  newLine  =  false;newLine  =  true;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  void  println()  throws  IOException  {  out.append(format.getLineSeparator());  [BUGGY]  newLine  =  false;newLine  =  true;  [BUGGY]  }    [CLASS]  CSVPrinter  [METHOD]  println  [RETURN_TYPE]  void    [VARIABLES]  CSVFormat  format  boolean  newLine  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  newLine  =  true;	[BUG]  [BUGGY]  quote  =  true;newLine  =  true;[CE]  cannot  find  symbol  quote  [CONTEXT]  public  void  println()  throws  IOException  {  out.append(format.getLineSeparator());  [BUGGY]  quote  =  true;newLine  =  true;  [BUGGY]  }    [CLASS]  CSVPrinter  [METHOD]  println  [RETURN_TYPE]  void    [VARIABLES]  CSVFormat  format  boolean  newLine  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  if  (  out  instanceof  Flushable  )  {	[BUG]  [BUGGY]  if  (  out  >>  Flushable)  {[CE]  cannot  find  symbol  Flushable  [CONTEXT]  public  void  flush()  throws  IOException  {  [BUGGY]  if  (  out  >>  Flushable)  {  [BUGGY]  ((Flushable)  out).flush();  }  }    [CLASS]  CSVPrinter  [METHOD]  flush  [RETURN_TYPE]  void    [VARIABLES]  CSVFormat  format  boolean  newLine  Appendable  out    	[P2_Replace_Operator]
[PATCH]  if  (  out  instanceof  Flushable  )  {  (  (  Flushable  )  out  )  .flush  (  )  ;  }	[BUG]  [BUGGY]  ((java.io.Flushable)(out)).flush();[CE]  illegal  start  of  expression  [CONTEXT]  public  void  flush()  throws  IOException  {  [BUGGY]  ((java.io.Flushable)(out)).flush();  [BUGGY]    ((java.io.Flushable)  (out)).flush();      [CLASS]  CSVPrinter  [METHOD]  flush  [RETURN_TYPE]  void    [VARIABLES]  CSVFormat  format  boolean  newLine  Appendable  out    	[P15_Unwrap_Block]
[PATCH]  if  (  out  instanceof  Flushable  )  {  (  (  Flushable  )  out  )  .flush  (  )  ;  }	[BUG]  [BUGGY]  [CE]  illegal  start  of  expression  [CONTEXT]  public  void  flush()  throws  IOException  {  [BUGGY]  [BUGGY]        [CLASS]  CSVPrinter  [METHOD]  flush  [RETURN_TYPE]  void    [VARIABLES]  CSVFormat  format  boolean  newLine  Appendable  out    	[P16_Remove_Block]
[PATCH]  (  (  Flushable  )  out  )  .flush  (  )  ;	[BUG]  [BUGGY]  [FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  void  flush()  throws  IOException  {  if  (out  instanceof  Flushable)  {  [BUGGY]  [BUGGY]    }    [CLASS]  CSVPrinter  [METHOD]  flush  [RETURN_TYPE]  void    [VARIABLES]  CSVFormat  format  boolean  newLine  Appendable  out    	[P14_Delete_Statement]
[PATCH]  (  (  Flushable  )  out  )  .flush  (  )  ;	[BUG]  [BUGGY]  (  (  Flushable)  out)  .flush(  )  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  void  flush()  throws  IOException  {  if  (out  instanceof  Flushable)  {  [BUGGY]  (  (  Flushable)  out)  .flush(  )  ;  [BUGGY]  }  }    [CLASS]  CSVPrinter  [METHOD]  flush  [RETURN_TYPE]  void    [VARIABLES]  CSVFormat  format  boolean  newLine  Appendable  out    	[P7_Replace_Invocation]
[PATCH]  for  (  String  value  :  values  )  {	[BUG]  [BUGGY]  for  (  char  value  :  values)  {[CE]  incompatible  types  [CONTEXT]  public  void  println(String...  values)  throws  IOException  {  [BUGGY]  for  (  char  value  :  values)  {  [BUGGY]  print(value);  }  println();  }    [CLASS]  CSVPrinter  [METHOD]  println  [RETURN_TYPE]  void    values  [VARIABLES]  CSVFormat  format  boolean  newLine  String[]  values  String  value  Appendable  out    	[P1_Replace_Type]
[PATCH]  print  (  value  )  ;	[BUG]  [BUGGY]  println(  value)  ;[FE]  null  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]  public  void  println(String...  values)  throws  IOException  {  for  (String  value  :  values)  {  [BUGGY]  println(  value)  ;  [BUGGY]  }  println();  }    [CLASS]  CSVPrinter  [METHOD]  println  [RETURN_TYPE]  void    values  [VARIABLES]  CSVFormat  format  boolean  newLine  String[]  values  String  value  Appendable  out    	[P7_Replace_Invocation]
[PATCH]  print  (  value  )  ;	[BUG]  [BUGGY]  [FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  void  println(String...  values)  throws  IOException  {  for  (String  value  :  values)  {  [BUGGY]  [BUGGY]    }  println();    [CLASS]  CSVPrinter  [METHOD]  println  [RETURN_TYPE]  void    values  [VARIABLES]  CSVFormat  format  boolean  newLine  String[]  values  String  value  Appendable  out    	[P14_Delete_Statement]
[PATCH]  print  (  value  )  ;	[BUG]  [BUGGY]  print(  value,  true)  ;print(  value)  ;[FE]  expected:<a,[b],c>  but  was:<a,[a,b,b,c],c>  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]  public  void  println(String...  values)  throws  IOException  {  for  (String  value  :  values)  {  [BUGGY]  print(  value,  true)  ;print(  value)  ;  [BUGGY]  }  println();  }    [CLASS]  CSVPrinter  [METHOD]  println  [RETURN_TYPE]  void    values  [VARIABLES]  CSVFormat  format  boolean  newLine  String[]  values  String  value  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  print  (  value  )  ;	[BUG]  [BUGGY]  println(  )  ;print(  value)  ;[FE]  expected:<a[,b,]c>  but  was:<a[  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]  public  void  println(String...  values)  throws  IOException  {  for  (String  value  :  values)  {  [BUGGY]  println(  )  ;print(  value)  ;  [BUGGY]  }  println();  }    [CLASS]  CSVPrinter  [METHOD]  println  [RETURN_TYPE]  void    values  [VARIABLES]  CSVFormat  format  boolean  newLine  String[]  values  String  value  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  print  (  value  )  ;	[BUG]  [BUGGY]  out.append(  value)  ;print(  value)  ;[FE]  expected:<a[,b],c>  but  was:<a[ab,bc],c>  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]  public  void  println(String...  values)  throws  IOException  {  for  (String  value  :  values)  {  [BUGGY]  out.append(  value)  ;print(  value)  ;  [BUGGY]  }  println();  }    [CLASS]  CSVPrinter  [METHOD]  println  [RETURN_TYPE]  void    values  [VARIABLES]  CSVFormat  format  boolean  newLine  String[]  values  String  value  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  print  (  value  )  ;	[BUG]  [BUGGY]  printSep(  )  ;print(  value)  ;[FE]  expected:<[a,b],c>  but  was:<[,a,,b,],c>  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]  public  void  println(String...  values)  throws  IOException  {  for  (String  value  :  values)  {  [BUGGY]  printSep(  )  ;print(  value)  ;  [BUGGY]  }  println();  }    [CLASS]  CSVPrinter  [METHOD]  println  [RETURN_TYPE]  void    values  [VARIABLES]  CSVFormat  format  boolean  newLine  String[]  values  String  value  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  println  (  )  ;	[BUG]  [BUGGY]  printSep(  )  ;[FE]  expected:<a,b,c[]>  but  was:<a,b,c[,]>  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]  public  void  println(String...  values)  throws  IOException  {  for  (String  value  :  values)  {  print(value);  }  [BUGGY]  printSep(  )  ;  [BUGGY]  }    [CLASS]  CSVPrinter  [METHOD]  println  [RETURN_TYPE]  void    values  [VARIABLES]  CSVFormat  format  boolean  newLine  String[]  values  String  value  Appendable  out    	[P7_Replace_Invocation]
[PATCH]  println  (  )  ;	[BUG]  [BUGGY]  [FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  void  println(String...  values)  throws  IOException  {  for  (String  value  :  values)  {  print(value);  }  [BUGGY]  [BUGGY]      [CLASS]  CSVPrinter  [METHOD]  println  [RETURN_TYPE]  void    values  [VARIABLES]  CSVFormat  format  boolean  newLine  String[]  values  String  value  Appendable  out    	[P14_Delete_Statement]
[PATCH]  println  (  )  ;	[BUG]  [BUGGY]  print(  value)  ;println(  )  ;[CE]  cannot  find  symbol  value  [CONTEXT]  public  void  println(String...  values)  throws  IOException  {  for  (String  value  :  values)  {  print(value);  }  [BUGGY]  print(  value)  ;println(  )  ;  [BUGGY]  }    [CLASS]  CSVPrinter  [METHOD]  println  [RETURN_TYPE]  void    values  [VARIABLES]  CSVFormat  format  boolean  newLine  String[]  values  String  value  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  println  (  )  ;	[BUG]  [BUGGY]  printSep(  )  ;println(  )  ;[FE]  expected:<a,b,c[]>  but  was:<a,b,c[,]>  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]  public  void  println(String...  values)  throws  IOException  {  for  (String  value  :  values)  {  print(value);  }  [BUGGY]  printSep(  )  ;println(  )  ;  [BUGGY]  }    [CLASS]  CSVPrinter  [METHOD]  println  [RETURN_TYPE]  void    values  [VARIABLES]  CSVFormat  format  boolean  newLine  String[]  values  String  value  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  if  (  !format.isCommentingEnabled  (  )  )  {	[BUG]  [BUGGY]  if  (  !format.getCommentStart(  )  )  {[CE]  bad  operand  type  char  for  unary  operator  '!'  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  [BUGGY]  if  (  !format.getCommentStart(  )  )  {  [BUGGY]  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  for  (int  i  =  0;  i  <  comment.length();  i++)  {  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  if  (i  +  1  <  comment.length()  &&  comment.charAt(i  +  1)  ==  '\n')  {  i++;  }    case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();  }    [CLASS]  CSVPrinter  [METHOD]  printComment  [RETURN_TYPE]  void    String  comment  [VARIABLES]  char  c  CSVFormat  format  boolean  newLine  String  comment  int  i  Appendable  out    	[P7_Replace_Invocation]
[PATCH]  if  (  !format.isCommentingEnabled  (  )  )  {	[BUG]  [BUGGY]  if  (  format.isEncapsulating(  )  )  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  [BUGGY]  if  (  format.isEncapsulating(  )  )  {  [BUGGY]  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  for  (int  i  =  0;  i  <  comment.length();  i++)  {  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  if  (i  +  1  <  comment.length()  &&  comment.charAt(i  +  1)  ==  '\n')  {  i++;  }    case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();  }    [CLASS]  CSVPrinter  [METHOD]  printComment  [RETURN_TYPE]  void    String  comment  [VARIABLES]  char  c  CSVFormat  format  boolean  newLine  String  comment  int  i  Appendable  out    	[P9_Replace_Statement]
[PATCH]  if  (  !format.isCommentingEnabled  (  )  )  {  return;  }	[BUG]  [BUGGY]  return  ;[CE]  illegal  start  of  expression  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  [BUGGY]  return  ;  [BUGGY]    return  ;  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  for  (int  i  =  0;  i  <  comment.length();  i++)  {  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  if  (i  +  1  <  comment.length()  &&  comment.charAt(i  +  1)  ==  '\n')  {  i++;  }    case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();    [CLASS]  CSVPrinter  [METHOD]  printComment  [RETURN_TYPE]  void    String  comment  [VARIABLES]  char  c  CSVFormat  format  boolean  newLine  String  comment  int  i  Appendable  out    	[P15_Unwrap_Block]
[PATCH]  if  (  !format.isCommentingEnabled  (  )  )  {  return;  }	[BUG]  [BUGGY]  [CE]  illegal  start  of  expression  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  [BUGGY]  [BUGGY]      if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  for  (int  i  =  0;  i  <  comment.length();  i++)  {  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  if  (i  +  1  <  comment.length()  &&  comment.charAt(i  +  1)  ==  '\n')  {  i++;  }    case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();    [CLASS]  CSVPrinter  [METHOD]  printComment  [RETURN_TYPE]  void    String  comment  [VARIABLES]  char  c  CSVFormat  format  boolean  newLine  String  comment  int  i  Appendable  out    	[P16_Remove_Block]
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  !(  format.isCommentingEnabled(  )  )  )  {      return  ;  }[CE]  illegal  start  of  type  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  [BUGGY]  if  (  !(  format.isCommentingEnabled(  )  )  )  {      return  ;  }  [BUGGY]  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  for  (int  i  =  0;  i  <  comment.length();  i++)  {  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  if  (i  +  1  <  comment.length()  &&  comment.charAt(i  +  1)  ==  '\n')  {  i++;  }    case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();  }    [CLASS]  CSVPrinter  [METHOD]  printComment  [RETURN_TYPE]  void    String  comment  [VARIABLES]  char  c  CSVFormat  format  boolean  newLine  String  comment  int  i  Appendable  out    	[P13_Insert_Block]
[PATCH]  if  (  !newLine  )  {	[BUG]  [BUGGY]  if  (  newLine)  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  [BUGGY]  if  (  newLine)  {  [BUGGY]  println();  }  out.append(format.getCommentStart());  out.append('  ');  for  (int  i  =  0;  i  <  comment.length();  i++)  {  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  if  (i  +  1  <  comment.length()  &&  comment.charAt(i  +  1)  ==  '\n')  {  i++;  }    case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();  }    [CLASS]  CSVPrinter  [METHOD]  printComment  [RETURN_TYPE]  void    String  comment  [VARIABLES]  char  c  CSVFormat  format  boolean  newLine  String  comment  int  i  Appendable  out    	[P8_Replace_Mix]
[PATCH]  if  (  !newLine  )  {	[BUG]  [BUGGY]  if  (  !quote)  {[CE]  cannot  find  symbol  quote  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  [BUGGY]  if  (  !quote)  {  [BUGGY]  println();  }  out.append(format.getCommentStart());  out.append('  ');  for  (int  i  =  0;  i  <  comment.length();  i++)  {  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  if  (i  +  1  <  comment.length()  &&  comment.charAt(i  +  1)  ==  '\n')  {  i++;  }    case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();  }    [CLASS]  CSVPrinter  [METHOD]  printComment  [RETURN_TYPE]  void    String  comment  [VARIABLES]  char  c  CSVFormat  format  boolean  newLine  String  comment  int  i  Appendable  out    	[P9_Replace_Statement]
[PATCH]  if  (  !newLine  )  {  println  (  )  ;  }	[BUG]  [BUGGY]  println();[CE]  illegal  start  of  expression  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  [BUGGY]  println();  [BUGGY]    println();  out.append(format.getCommentStart());  out.append('  ');  for  (int  i  =  0;  i  <  comment.length();  i++)  {  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  if  (i  +  1  <  comment.length()  &&  comment.charAt(i  +  1)  ==  '\n')  {  i++;  }    case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();    [CLASS]  CSVPrinter  [METHOD]  printComment  [RETURN_TYPE]  void    String  comment  [VARIABLES]  char  c  CSVFormat  format  boolean  newLine  String  comment  int  i  Appendable  out    	[P15_Unwrap_Block]
[PATCH]  if  (  !newLine  )  {  println  (  )  ;  }	[BUG]  [BUGGY]  [CE]  illegal  start  of  expression  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  [BUGGY]  [BUGGY]      out.append(format.getCommentStart());  out.append('  ');  for  (int  i  =  0;  i  <  comment.length();  i++)  {  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  if  (i  +  1  <  comment.length()  &&  comment.charAt(i  +  1)  ==  '\n')  {  i++;  }    case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();    [CLASS]  CSVPrinter  [METHOD]  printComment  [RETURN_TYPE]  void    String  comment  [VARIABLES]  char  c  CSVFormat  format  boolean  newLine  String  comment  int  i  Appendable  out    	[P16_Remove_Block]
[PATCH]  println  (  )  ;	[BUG]  [BUGGY]  printSep(  )  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  [BUGGY]  printSep(  )  ;  [BUGGY]  }  out.append(format.getCommentStart());  out.append('  ');  for  (int  i  =  0;  i  <  comment.length();  i++)  {  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  if  (i  +  1  <  comment.length()  &&  comment.charAt(i  +  1)  ==  '\n')  {  i++;  }    case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();  }    [CLASS]  CSVPrinter  [METHOD]  printComment  [RETURN_TYPE]  void    String  comment  [VARIABLES]  char  c  CSVFormat  format  boolean  newLine  String  comment  int  i  Appendable  out    	[P7_Replace_Invocation]
[PATCH]  println  (  )  ;	[BUG]  [BUGGY]  [FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  [BUGGY]  [BUGGY]    }  out.append(format.getCommentStart());  out.append('  ');  for  (int  i  =  0;  i  <  comment.length();  i++)  {  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  if  (i  +  1  <  comment.length()  &&  comment.charAt(i  +  1)  ==  '\n')  {  i++;  }    case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();    [CLASS]  CSVPrinter  [METHOD]  printComment  [RETURN_TYPE]  void    String  comment  [VARIABLES]  char  c  CSVFormat  format  boolean  newLine  String  comment  int  i  Appendable  out    	[P14_Delete_Statement]
[PATCH]  println  (  )  ;	[BUG]  [BUGGY]  print(  value)  ;println(  )  ;[CE]  cannot  find  symbol  value  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  [BUGGY]  print(  value)  ;println(  )  ;  [BUGGY]  }  out.append(format.getCommentStart());  out.append('  ');  for  (int  i  =  0;  i  <  comment.length();  i++)  {  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  if  (i  +  1  <  comment.length()  &&  comment.charAt(i  +  1)  ==  '\n')  {  i++;  }    case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();  }    [CLASS]  CSVPrinter  [METHOD]  printComment  [RETURN_TYPE]  void    String  comment  [VARIABLES]  char  c  CSVFormat  format  boolean  newLine  String  comment  int  i  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  println  (  )  ;	[BUG]  [BUGGY]  printSep(  )  ;println(  )  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  [BUGGY]  printSep(  )  ;println(  )  ;  [BUGGY]  }  out.append(format.getCommentStart());  out.append('  ');  for  (int  i  =  0;  i  <  comment.length();  i++)  {  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  if  (i  +  1  <  comment.length()  &&  comment.charAt(i  +  1)  ==  '\n')  {  i++;  }    case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();  }    [CLASS]  CSVPrinter  [METHOD]  printComment  [RETURN_TYPE]  void    String  comment  [VARIABLES]  char  c  CSVFormat  format  boolean  newLine  String  comment  int  i  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  out.append  (  format.getCommentStart  (  )  )  ;	[BUG]  [BUGGY]  out.append(  format.getEscape(  )  )  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  [BUGGY]  out.append(  format.getEscape(  )  )  ;  [BUGGY]  out.append('  ');  for  (int  i  =  0;  i  <  comment.length();  i++)  {  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  if  (i  +  1  <  comment.length()  &&  comment.charAt(i  +  1)  ==  '\n')  {  i++;  }    case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();  }    [CLASS]  CSVPrinter  [METHOD]  printComment  [RETURN_TYPE]  void    String  comment  [VARIABLES]  char  c  CSVFormat  format  boolean  newLine  String  comment  int  i  Appendable  out    	[P7_Replace_Invocation]
[PATCH]  out.append  (  format.getCommentStart  (  )  )  ;	[BUG]  [BUGGY]  out.append(  value,  start,  end)  ;out.append(  format.getCommentStart(  )  )  ;[CE]  cannot  find  symbol  value  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  [BUGGY]  out.append(  value,  start,  end)  ;out.append(  format.getCommentStart(  )  )  ;  [BUGGY]  out.append('  ');  for  (int  i  =  0;  i  <  comment.length();  i++)  {  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  if  (i  +  1  <  comment.length()  &&  comment.charAt(i  +  1)  ==  '\n')  {  i++;  }    case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();  }    [CLASS]  CSVPrinter  [METHOD]  printComment  [RETURN_TYPE]  void    String  comment  [VARIABLES]  char  c  CSVFormat  format  boolean  newLine  String  comment  int  i  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  out.append  (  format.getCommentStart  (  )  )  ;	[BUG]  [BUGGY]  out.append(  value,  start,  pos)  ;out.append(  format.getCommentStart(  )  )  ;[CE]  cannot  find  symbol  value  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  [BUGGY]  out.append(  value,  start,  pos)  ;out.append(  format.getCommentStart(  )  )  ;  [BUGGY]  out.append('  ');  for  (int  i  =  0;  i  <  comment.length();  i++)  {  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  if  (i  +  1  <  comment.length()  &&  comment.charAt(i  +  1)  ==  '\n')  {  i++;  }    case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();  }    [CLASS]  CSVPrinter  [METHOD]  printComment  [RETURN_TYPE]  void    String  comment  [VARIABLES]  char  c  CSVFormat  format  boolean  newLine  String  comment  int  i  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  out.append  (  format.getCommentStart  (  )  )  ;	[BUG]  [BUGGY]  out.append(  format.getLineSeparator(  )  )  ;out.append(  format.getCommentStart(  )  )  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  [BUGGY]  out.append(  format.getLineSeparator(  )  )  ;out.append(  format.getCommentStart(  )  )  ;  [BUGGY]  out.append('  ');  for  (int  i  =  0;  i  <  comment.length();  i++)  {  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  if  (i  +  1  <  comment.length()  &&  comment.charAt(i  +  1)  ==  '\n')  {  i++;  }    case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();  }    [CLASS]  CSVPrinter  [METHOD]  printComment  [RETURN_TYPE]  void    String  comment  [VARIABLES]  char  c  CSVFormat  format  boolean  newLine  String  comment  int  i  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  out.append  (  format.getCommentStart  (  )  )  ;	[BUG]  [BUGGY]  out.append(  format.getDelimiter(  )  )  ;out.append(  format.getCommentStart(  )  )  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  [BUGGY]  out.append(  format.getDelimiter(  )  )  ;out.append(  format.getCommentStart(  )  )  ;  [BUGGY]  out.append('  ');  for  (int  i  =  0;  i  <  comment.length();  i++)  {  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  if  (i  +  1  <  comment.length()  &&  comment.charAt(i  +  1)  ==  '\n')  {  i++;  }    case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();  }    [CLASS]  CSVPrinter  [METHOD]  printComment  [RETURN_TYPE]  void    String  comment  [VARIABLES]  char  c  CSVFormat  format  boolean  newLine  String  comment  int  i  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  out.append  (  format.getCommentStart  (  )  )  ;	[BUG]  [BUGGY]  out.append(  value,  start,  pos  +  1)  ;out.append(  format.getCommentStart(  )  )  ;[CE]  cannot  find  symbol  value  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  [BUGGY]  out.append(  value,  start,  pos  +  1)  ;out.append(  format.getCommentStart(  )  )  ;  [BUGGY]  out.append('  ');  for  (int  i  =  0;  i  <  comment.length();  i++)  {  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  if  (i  +  1  <  comment.length()  &&  comment.charAt(i  +  1)  ==  '\n')  {  i++;  }    case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();  }    [CLASS]  CSVPrinter  [METHOD]  printComment  [RETURN_TYPE]  void    String  comment  [VARIABLES]  char  c  CSVFormat  format  boolean  newLine  String  comment  int  i  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  out.append  (  '  '  )  ;	[BUG]  [BUGGY]  [FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  [BUGGY]  [BUGGY]    for  (int  i  =  0;  i  <  comment.length();  i++)  {  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  if  (i  +  1  <  comment.length()  &&  comment.charAt(i  +  1)  ==  '\n')  {  i++;  }    case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();    [CLASS]  CSVPrinter  [METHOD]  printComment  [RETURN_TYPE]  void    String  comment  [VARIABLES]  char  c  CSVFormat  format  boolean  newLine  String  comment  int  i  Appendable  out    	[P14_Delete_Statement]
[PATCH]  out.append  (  '  '  )  ;	[BUG]  [BUGGY]  out.append(  value,  start,  end)  ;out.append(  '  ')  ;[CE]  cannot  find  symbol  value  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  [BUGGY]  out.append(  value,  start,  end)  ;out.append(  '  ')  ;  [BUGGY]  for  (int  i  =  0;  i  <  comment.length();  i++)  {  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  if  (i  +  1  <  comment.length()  &&  comment.charAt(i  +  1)  ==  '\n')  {  i++;  }    case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();  }    [CLASS]  CSVPrinter  [METHOD]  printComment  [RETURN_TYPE]  void    String  comment  [VARIABLES]  char  c  CSVFormat  format  boolean  newLine  String  comment  int  i  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  out.append  (  '  '  )  ;	[BUG]  [BUGGY]  out.append(  value,  start,  pos)  ;out.append(  '  ')  ;[CE]  cannot  find  symbol  value  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  [BUGGY]  out.append(  value,  start,  pos)  ;out.append(  '  ')  ;  [BUGGY]  for  (int  i  =  0;  i  <  comment.length();  i++)  {  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  if  (i  +  1  <  comment.length()  &&  comment.charAt(i  +  1)  ==  '\n')  {  i++;  }    case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();  }    [CLASS]  CSVPrinter  [METHOD]  printComment  [RETURN_TYPE]  void    String  comment  [VARIABLES]  char  c  CSVFormat  format  boolean  newLine  String  comment  int  i  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  out.append  (  '  '  )  ;	[BUG]  [BUGGY]  out.append(  c)  ;out.append(  '  ')  ;[CE]  cannot  find  symbol  c  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  [BUGGY]  out.append(  c)  ;out.append(  '  ')  ;  [BUGGY]  for  (int  i  =  0;  i  <  comment.length();  i++)  {  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  if  (i  +  1  <  comment.length()  &&  comment.charAt(i  +  1)  ==  '\n')  {  i++;  }    case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();  }    [CLASS]  CSVPrinter  [METHOD]  printComment  [RETURN_TYPE]  void    String  comment  [VARIABLES]  char  c  CSVFormat  format  boolean  newLine  String  comment  int  i  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  out.append  (  '  '  )  ;	[BUG]  [BUGGY]  out.append(  value)  ;out.append(  '  ')  ;[CE]  cannot  find  symbol  value  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  [BUGGY]  out.append(  value)  ;out.append(  '  ')  ;  [BUGGY]  for  (int  i  =  0;  i  <  comment.length();  i++)  {  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  if  (i  +  1  <  comment.length()  &&  comment.charAt(i  +  1)  ==  '\n')  {  i++;  }    case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();  }    [CLASS]  CSVPrinter  [METHOD]  printComment  [RETURN_TYPE]  void    String  comment  [VARIABLES]  char  c  CSVFormat  format  boolean  newLine  String  comment  int  i  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  out.append  (  '  '  )  ;	[BUG]  [BUGGY]  out.append(  encapsulator)  ;out.append(  '  ')  ;[CE]  cannot  find  symbol  encapsulator  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  [BUGGY]  out.append(  encapsulator)  ;out.append(  '  ')  ;  [BUGGY]  for  (int  i  =  0;  i  <  comment.length();  i++)  {  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  if  (i  +  1  <  comment.length()  &&  comment.charAt(i  +  1)  ==  '\n')  {  i++;  }    case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();  }    [CLASS]  CSVPrinter  [METHOD]  printComment  [RETURN_TYPE]  void    String  comment  [VARIABLES]  char  c  CSVFormat  format  boolean  newLine  String  comment  int  i  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  out.append  (  '  '  )  ;	[BUG]  [BUGGY]  out.append(  escape)  ;out.append(  '  ')  ;[CE]  cannot  find  symbol  escape  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  [BUGGY]  out.append(  escape)  ;out.append(  '  ')  ;  [BUGGY]  for  (int  i  =  0;  i  <  comment.length();  i++)  {  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  if  (i  +  1  <  comment.length()  &&  comment.charAt(i  +  1)  ==  '\n')  {  i++;  }    case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();  }    [CLASS]  CSVPrinter  [METHOD]  printComment  [RETURN_TYPE]  void    String  comment  [VARIABLES]  char  c  CSVFormat  format  boolean  newLine  String  comment  int  i  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  if  (  i  +  1  <  comment.length  (  )  &&  comment.charAt  (  i  +  1  )  ==  '\n'  )  {	[BUG]  [BUGGY]  if  (  i  +  1  <  comment.length(  )  ||  comment.charAt(  i  +  1)  ==  '\n')  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  for  (int  i  =  0;  i  <  comment.length();  i++)  {  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  [BUGGY]  if  (  i  +  1  <  comment.length(  )  ||  comment.charAt(  i  +  1)  ==  '\n')  {  [BUGGY]  i++;  }    case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();  }    [CLASS]  CSVPrinter  [METHOD]  printComment  [RETURN_TYPE]  void    String  comment  [VARIABLES]  char  c  CSVFormat  format  boolean  newLine  String  comment  int  i  Appendable  out    	[P2_Replace_Operator]
[PATCH]  if  (  i  +  1  <  comment.length  (  )  &&  comment.charAt  (  i  +  1  )  ==  '\n'  )  {	[BUG]  [BUGGY]  if  (  i  +  1  <=  comment.length(  )  &&  comment.charAt(  i  +  1)  ==  '\n')  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  for  (int  i  =  0;  i  <  comment.length();  i++)  {  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  [BUGGY]  if  (  i  +  1  <=  comment.length(  )  &&  comment.charAt(  i  +  1)  ==  '\n')  {  [BUGGY]  i++;  }    case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();  }    [CLASS]  CSVPrinter  [METHOD]  printComment  [RETURN_TYPE]  void    String  comment  [VARIABLES]  char  c  CSVFormat  format  boolean  newLine  String  comment  int  i  Appendable  out    	[P2_Replace_Operator]
[PATCH]  if  (  i  +  1  <  comment.length  (  )  &&  comment.charAt  (  i  +  1  )  ==  '\n'  )  {	[BUG]  [BUGGY]  if  (  i  !=  1  <  comment.length(  )  &&  comment.charAt(  i  !=  1)  ==  '\n')  {[CE]  incomparable  types:  int  and  boolean  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  for  (int  i  =  0;  i  <  comment.length();  i++)  {  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  [BUGGY]  if  (  i  !=  1  <  comment.length(  )  &&  comment.charAt(  i  !=  1)  ==  '\n')  {  [BUGGY]  i++;  }    case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();  }    [CLASS]  CSVPrinter  [METHOD]  printComment  [RETURN_TYPE]  void    String  comment  [VARIABLES]  char  c  CSVFormat  format  boolean  newLine  String  comment  int  i  Appendable  out    	[P2_Replace_Operator]
[PATCH]  if  (  i  +  1  <  comment.length  (  )  &&  comment.charAt  (  i  +  1  )  ==  '\n'  )  {	[BUG]  [BUGGY]  if  (  i  +  1  <  comment.length(  )  &&  comment.charAt(  i  +  1)  >=  '\n')  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  for  (int  i  =  0;  i  <  comment.length();  i++)  {  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  [BUGGY]  if  (  i  +  1  <  comment.length(  )  &&  comment.charAt(  i  +  1)  >=  '\n')  {  [BUGGY]  i++;  }    case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();  }    [CLASS]  CSVPrinter  [METHOD]  printComment  [RETURN_TYPE]  void    String  comment  [VARIABLES]  char  c  CSVFormat  format  boolean  newLine  String  comment  int  i  Appendable  out    	[P2_Replace_Operator]
[PATCH]  if  (  i  +  1  <  comment.length  (  )  &&  comment.charAt  (  i  +  1  )  ==  '\n'  )  {	[BUG]  [BUGGY]  if  (  i  &&  1  <  comment.length(  )  &&  comment.charAt(  i  &&  1)  ==  '\n')  {[CE]  bad  operand  types  for  binary  operator  '&&'  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  for  (int  i  =  0;  i  <  comment.length();  i++)  {  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  [BUGGY]  if  (  i  &&  1  <  comment.length(  )  &&  comment.charAt(  i  &&  1)  ==  '\n')  {  [BUGGY]  i++;  }    case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();  }    [CLASS]  CSVPrinter  [METHOD]  printComment  [RETURN_TYPE]  void    String  comment  [VARIABLES]  char  c  CSVFormat  format  boolean  newLine  String  comment  int  i  Appendable  out    	[P2_Replace_Operator]
[PATCH]  if  (  i  +  1  <  comment.length  (  )  &&  comment.charAt  (  i  +  1  )  ==  '\n'  )  {	[BUG]  [BUGGY]  if  (  i  +  <  comment.length(  )  &&  comment.charAt(  i  +  )  ==  '\n')  {[CE]  >  expected  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  for  (int  i  =  0;  i  <  comment.length();  i++)  {  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  [BUGGY]  if  (  i  +  <  comment.length(  )  &&  comment.charAt(  i  +  )  ==  '\n')  {  [BUGGY]  i++;  }    case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();  }    [CLASS]  CSVPrinter  [METHOD]  printComment  [RETURN_TYPE]  void    String  comment  [VARIABLES]  char  c  CSVFormat  format  boolean  newLine  String  comment  int  i  Appendable  out    	[P3_Replace_Literal]
[PATCH]  if  (  i  +  1  <  comment.length  (  )  &&  comment.charAt  (  i  +  1  )  ==  '\n'  )  {	[BUG]  [BUGGY]  if  (  i  <  comment.length(  )  &&  comment.charAt(  i  )  ==  '\n')  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  for  (int  i  =  0;  i  <  comment.length();  i++)  {  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  [BUGGY]  if  (  i  <  comment.length(  )  &&  comment.charAt(  i  )  ==  '\n')  {  [BUGGY]  i++;  }    case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();  }    [CLASS]  CSVPrinter  [METHOD]  printComment  [RETURN_TYPE]  void    String  comment  [VARIABLES]  char  c  CSVFormat  format  boolean  newLine  String  comment  int  i  Appendable  out    	[P3_Replace_Literal]
[PATCH]  if  (  i  +  1  <  comment.length  (  )  &&  comment.charAt  (  i  +  1  )  ==  '\n'  )  {	[BUG]  [BUGGY]  if  (  i  +  1  <  comment.length()  +  1  &&  comment.charAt(  i  +  1)  ==  '\n')  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  for  (int  i  =  0;  i  <  comment.length();  i++)  {  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  [BUGGY]  if  (  i  +  1  <  comment.length()  +  1  &&  comment.charAt(  i  +  1)  ==  '\n')  {  [BUGGY]  i++;  }    case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();  }    [CLASS]  CSVPrinter  [METHOD]  printComment  [RETURN_TYPE]  void    String  comment  [VARIABLES]  char  c  CSVFormat  format  boolean  newLine  String  comment  int  i  Appendable  out    	[P3_Replace_Literal]
[PATCH]  if  (  i  +  1  <  comment.length  (  )  &&  comment.charAt  (  i  +  1  )  ==  '\n'  )  {	[BUG]  [BUGGY]  if  (  comment  +  1  <  i.length(  )  &&  comment.charAt(  i  +  1)  ==  '\n')  {[CE]  int  cannot  be  dereferenced  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  for  (int  i  =  0;  i  <  comment.length();  i++)  {  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  [BUGGY]  if  (  comment  +  1  <  i.length(  )  &&  comment.charAt(  i  +  1)  ==  '\n')  {  [BUGGY]  i++;  }    case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();  }    [CLASS]  CSVPrinter  [METHOD]  printComment  [RETURN_TYPE]  void    String  comment  [VARIABLES]  char  c  CSVFormat  format  boolean  newLine  String  comment  int  i  Appendable  out    	[P5_Replace_Variable]
[PATCH]  if  (  i  +  1  <  comment.length  (  )  &&  comment.charAt  (  i  +  1  )  ==  '\n'  )  {	[BUG]  [BUGGY]  if  (  i  +  1  <  comment.length(  )  )  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  for  (int  i  =  0;  i  <  comment.length();  i++)  {  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  [BUGGY]  if  (  i  +  1  <  comment.length(  )  )  {  [BUGGY]  i++;  }    case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();  }    [CLASS]  CSVPrinter  [METHOD]  printComment  [RETURN_TYPE]  void    String  comment  [VARIABLES]  char  c  CSVFormat  format  boolean  newLine  String  comment  int  i  Appendable  out    	[P6_Replace_Expression]
[PATCH]  if  (  i  +  1  <  comment.length  (  )  &&  comment.charAt  (  i  +  1  )  ==  '\n'  )  {	[BUG]  [BUGGY]  if  (  comment.charAt(  i  +  1)  ==  '\n')  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  for  (int  i  =  0;  i  <  comment.length();  i++)  {  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  [BUGGY]  if  (  comment.charAt(  i  +  1)  ==  '\n')  {  [BUGGY]  i++;  }    case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();  }    [CLASS]  CSVPrinter  [METHOD]  printComment  [RETURN_TYPE]  void    String  comment  [VARIABLES]  char  c  CSVFormat  format  boolean  newLine  String  comment  int  i  Appendable  out    	[P6_Replace_Expression]
[PATCH]  if  (  i  +  1  <  comment.length  (  )  &&  comment.charAt  (  i  +  1  )  ==  '\n'  )  {	[BUG]  [BUGGY]  if  (  i  +  1)  {[CE]  incompatible  types  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  for  (int  i  =  0;  i  <  comment.length();  i++)  {  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  [BUGGY]  if  (  i  +  1)  {  [BUGGY]  i++;  }    case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();  }    [CLASS]  CSVPrinter  [METHOD]  printComment  [RETURN_TYPE]  void    String  comment  [VARIABLES]  char  c  CSVFormat  format  boolean  newLine  String  comment  int  i  Appendable  out    	[P6_Replace_Expression]
[PATCH]  if  (  i  +  1  <  comment.length  (  )  &&  comment.charAt  (  i  +  1  )  ==  '\n'  )  {	[BUG]  [BUGGY]  if  (  comment.charAt(  (  i  +  1)  )  ==  '\n')  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  for  (int  i  =  0;  i  <  comment.length();  i++)  {  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  [BUGGY]  if  (  comment.charAt(  (  i  +  1)  )  ==  '\n')  {  [BUGGY]  i++;  }    case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();  }    [CLASS]  CSVPrinter  [METHOD]  printComment  [RETURN_TYPE]  void    String  comment  [VARIABLES]  char  c  CSVFormat  format  boolean  newLine  String  comment  int  i  Appendable  out    	[P6_Replace_Expression]
[PATCH]  if  (  i  +  1  <  comment.length  (  )  &&  comment.charAt  (  i  +  1  )  ==  '\n'  )  {	[BUG]  [BUGGY]  if  (  i  +  1  <  comment.charAt(  )  &&  comment.charAt(  i  +  1)  ==  '\n')  {[CE]  method  charAt  in  class  String  cannot  be  applied  to  given  types;  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  for  (int  i  =  0;  i  <  comment.length();  i++)  {  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  [BUGGY]  if  (  i  +  1  <  comment.charAt(  )  &&  comment.charAt(  i  +  1)  ==  '\n')  {  [BUGGY]  i++;  }    case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();  }    [CLASS]  CSVPrinter  [METHOD]  printComment  [RETURN_TYPE]  void    String  comment  [VARIABLES]  char  c  CSVFormat  format  boolean  newLine  String  comment  int  i  Appendable  out    	[P7_Replace_Invocation]
[PATCH]  if  (  i  +  1  <  comment.length  (  )  &&  comment.charAt  (  i  +  1  )  ==  '\n'  )  {	[BUG]  [BUGGY]  if  (  i  +  0  <  comment.length(  )  )  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  for  (int  i  =  0;  i  <  comment.length();  i++)  {  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  [BUGGY]  if  (  i  +  0  <  comment.length(  )  )  {  [BUGGY]  i++;  }    case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();  }    [CLASS]  CSVPrinter  [METHOD]  printComment  [RETURN_TYPE]  void    String  comment  [VARIABLES]  char  c  CSVFormat  format  boolean  newLine  String  comment  int  i  Appendable  out    	[P8_Replace_Mix]
[PATCH]  if  (  i  +  1  <  comment.length  (  )  &&  comment.charAt  (  i  +  1  )  ==  '\n'  )  {  i++;  }	[BUG]  [BUGGY]  i++;[CE]  orphaned  case  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  for  (int  i  =  0;  i  <  comment.length();  i++)  {  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  [BUGGY]  i++;  [BUGGY]    i++;    case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();    [CLASS]  CSVPrinter  [METHOD]  printComment  [RETURN_TYPE]  void    String  comment  [VARIABLES]  char  c  CSVFormat  format  boolean  newLine  String  comment  int  i  Appendable  out    	[P15_Unwrap_Block]
[PATCH]  if  (  i  +  1  <  comment.length  (  )  &&  comment.charAt  (  i  +  1  )  ==  '\n'  )  {  i++;  }	[BUG]  [BUGGY]  [CE]  orphaned  case  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  for  (int  i  =  0;  i  <  comment.length();  i++)  {  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  [BUGGY]  [BUGGY]        case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();    [CLASS]  CSVPrinter  [METHOD]  printComment  [RETURN_TYPE]  void    String  comment  [VARIABLES]  char  c  CSVFormat  format  boolean  newLine  String  comment  int  i  Appendable  out    	[P16_Remove_Block]
[PATCH]  for  (  int  i  =  0;  i  <  comment.length  (  )  ;  i++  )  {	[BUG]  [BUGGY]  for  (  long  i  =  0;  i  <  comment.length(  )  ;  i++)  {[CE]  method  charAt  in  class  String  cannot  be  applied  to  given  types;  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  [BUGGY]  for  (  long  i  =  0;  i  <  comment.length(  )  ;  i++)  {  [BUGGY]  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  if  (i  +  1  <  comment.length()  &&  comment.charAt(i  +  1)  ==  '\n')  {  i++;  }    case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();  }    [CLASS]  CSVPrinter  [METHOD]  printComment  [RETURN_TYPE]  void    String  comment  [VARIABLES]  char  c  CSVFormat  format  boolean  newLine  String  comment  int  i  Appendable  out    	[P1_Replace_Type]
[PATCH]  for  (  int  i  =  0;  i  <  comment.length  (  )  ;  i++  )  {	[BUG]  [BUGGY]  for  (  int  i  =  0;  i  <=  comment.length(  )  ;  i++)  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  [BUGGY]  for  (  int  i  =  0;  i  <=  comment.length(  )  ;  i++)  {  [BUGGY]  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  if  (i  +  1  <  comment.length()  &&  comment.charAt(i  +  1)  ==  '\n')  {  i++;  }    case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();  }    [CLASS]  CSVPrinter  [METHOD]  printComment  [RETURN_TYPE]  void    String  comment  [VARIABLES]  char  c  CSVFormat  format  boolean  newLine  String  comment  int  i  Appendable  out    	[P2_Replace_Operator]
[PATCH]  for  (  int  i  =  0;  i  <  comment.length  (  )  ;  i++  )  {	[BUG]  [BUGGY]  for  ==  (  int  i  =  0;  i  <  comment.length(  )  ;  i++)  {[CE]  '('  expected  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  [BUGGY]  for  ==  (  int  i  =  0;  i  <  comment.length(  )  ;  i++)  {  [BUGGY]  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  if  (i  +  1  <  comment.length()  &&  comment.charAt(i  +  1)  ==  '\n')  {  i++;  }    case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();  }    [CLASS]  CSVPrinter  [METHOD]  printComment  [RETURN_TYPE]  void    String  comment  [VARIABLES]  char  c  CSVFormat  format  boolean  newLine  String  comment  int  i  Appendable  out    	[P2_Replace_Operator]
[PATCH]  for  (  int  i  =  0;  i  <  comment.length  (  )  ;  i++  )  {	[BUG]  [BUGGY]  for  &&  (  int  i  =  0;  i  <  comment.length(  )  ;  i++)  {[CE]  '('  expected  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  [BUGGY]  for  &&  (  int  i  =  0;  i  <  comment.length(  )  ;  i++)  {  [BUGGY]  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  if  (i  +  1  <  comment.length()  &&  comment.charAt(i  +  1)  ==  '\n')  {  i++;  }    case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();  }    [CLASS]  CSVPrinter  [METHOD]  printComment  [RETURN_TYPE]  void    String  comment  [VARIABLES]  char  c  CSVFormat  format  boolean  newLine  String  comment  int  i  Appendable  out    	[P2_Replace_Operator]
[PATCH]  for  (  int  i  =  0;  i  <  comment.length  (  )  ;  i++  )  {	[BUG]  [BUGGY]  for  (  int  i  =  i;  i  <  comment.length(  )  ;  i++)  {[CE]  variable  i  might  not  have  been  initialized  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  [BUGGY]  for  (  int  i  =  i;  i  <  comment.length(  )  ;  i++)  {  [BUGGY]  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  if  (i  +  1  <  comment.length()  &&  comment.charAt(i  +  1)  ==  '\n')  {  i++;  }    case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();  }    [CLASS]  CSVPrinter  [METHOD]  printComment  [RETURN_TYPE]  void    String  comment  [VARIABLES]  char  c  CSVFormat  format  boolean  newLine  String  comment  int  i  Appendable  out    	[P3_Replace_Literal]
[PATCH]  for  (  int  i  =  0;  i  <  comment.length  (  )  ;  i++  )  {	[BUG]  [BUGGY]  for  (  int  i  =  0;  i  <  comment.length()  -  5  ;  i++)  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  [BUGGY]  for  (  int  i  =  0;  i  <  comment.length()  -  5  ;  i++)  {  [BUGGY]  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  if  (i  +  1  <  comment.length()  &&  comment.charAt(i  +  1)  ==  '\n')  {  i++;  }    case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();  }    [CLASS]  CSVPrinter  [METHOD]  printComment  [RETURN_TYPE]  void    String  comment  [VARIABLES]  char  c  CSVFormat  format  boolean  newLine  String  comment  int  i  Appendable  out    	[P3_Replace_Literal]
[PATCH]  for  (  int  i  =  0;  i  <  comment.length  (  )  ;  i++  )  {	[BUG]  [BUGGY]  for  (  commentnt  i  =  0;  i  <  i.length(  )  ;  i++)  {[CE]  cannot  find  symbol  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  [BUGGY]  for  (  commentnt  i  =  0;  i  <  i.length(  )  ;  i++)  {  [BUGGY]  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  if  (i  +  1  <  comment.length()  &&  comment.charAt(i  +  1)  ==  '\n')  {  i++;  }    case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();  }    [CLASS]  CSVPrinter  [METHOD]  printComment  [RETURN_TYPE]  void    String  comment  [VARIABLES]  char  c  CSVFormat  format  boolean  newLine  String  comment  int  i  Appendable  out    	[P5_Replace_Variable]
[PATCH]  for  (  int  i  =  0;  i  <  comment.length  (  )  ;  i++  )  {	[BUG]  [BUGGY]  for  (  cnt  i  =  0;  i  <  iomment.length(  )  ;  i++)  {[CE]  cannot  find  symbol  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  [BUGGY]  for  (  cnt  i  =  0;  i  <  iomment.length(  )  ;  i++)  {  [BUGGY]  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  if  (i  +  1  <  comment.length()  &&  comment.charAt(i  +  1)  ==  '\n')  {  i++;  }    case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();  }    [CLASS]  CSVPrinter  [METHOD]  printComment  [RETURN_TYPE]  void    String  comment  [VARIABLES]  char  c  CSVFormat  format  boolean  newLine  String  comment  int  i  Appendable  out    	[P5_Replace_Variable]
[PATCH]  for  (  int  i  =  0;  i  <  comment.length  (  )  ;  i++  )  {	[BUG]  [BUGGY]  for  (  int  i  =  0;  i  <  comment.charAt(  )  ;  i++)  {[CE]  method  charAt  in  class  String  cannot  be  applied  to  given  types;  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  [BUGGY]  for  (  int  i  =  0;  i  <  comment.charAt(  )  ;  i++)  {  [BUGGY]  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  if  (i  +  1  <  comment.length()  &&  comment.charAt(i  +  1)  ==  '\n')  {  i++;  }    case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();  }    [CLASS]  CSVPrinter  [METHOD]  printComment  [RETURN_TYPE]  void    String  comment  [VARIABLES]  char  c  CSVFormat  format  boolean  newLine  String  comment  int  i  Appendable  out    	[P7_Replace_Invocation]
[PATCH]  if  (  i  +  1  <  comment.length  (  )  &&  comment.charAt  (  i  +  1  )  ==  '\n'  )  {	[BUG]  [BUGGY]  if  (  i  &  1  <  comment.length(  )  &&  comment.charAt(  i  &  1)  ==  '\n')  {[CE]  bad  operand  types  for  binary  operator  '&'  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  for  (int  i  =  0;  i  <  comment.length();  i++)  {  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  [BUGGY]  if  (  i  &  1  <  comment.length(  )  &&  comment.charAt(  i  &  1)  ==  '\n')  {  [BUGGY]  i++;  }    case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();  }    [CLASS]  CSVPrinter  [METHOD]  printComment  [RETURN_TYPE]  void    String  comment  [VARIABLES]  char  c  CSVFormat  format  boolean  newLine  String  comment  int  i  Appendable  out    	[P2_Replace_Operator]
[PATCH]  if  (  i  +  1  <  comment.length  (  )  &&  comment.charAt  (  i  +  1  )  ==  '\n'  )  {	[BUG]  [BUGGY]  if  (  i  +  1  <  comment.length(  )  &&  comment.charAt(  i  +  1)  !=  '\n')  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  for  (int  i  =  0;  i  <  comment.length();  i++)  {  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  [BUGGY]  if  (  i  +  1  <  comment.length(  )  &&  comment.charAt(  i  +  1)  !=  '\n')  {  [BUGGY]  i++;  }    case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();  }    [CLASS]  CSVPrinter  [METHOD]  printComment  [RETURN_TYPE]  void    String  comment  [VARIABLES]  char  c  CSVFormat  format  boolean  newLine  String  comment  int  i  Appendable  out    	[P2_Replace_Operator]
[PATCH]  if  (  i  +  1  <  comment.length  (  )  &&  comment.charAt  (  i  +  1  )  ==  '\n'  )  {	[BUG]  [BUGGY]  if  (  i    instanceof    1  <  comment.length(  )  &&  comment.charAt(  i    instanceof    1)  ==  '\n')  {[CE]  illegal  start  of  type  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  for  (int  i  =  0;  i  <  comment.length();  i++)  {  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  [BUGGY]  if  (  i    instanceof    1  <  comment.length(  )  &&  comment.charAt(  i    instanceof    1)  ==  '\n')  {  [BUGGY]  i++;  }    case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();  }    [CLASS]  CSVPrinter  [METHOD]  printComment  [RETURN_TYPE]  void    String  comment  [VARIABLES]  char  c  CSVFormat  format  boolean  newLine  String  comment  int  i  Appendable  out    	[P2_Replace_Operator]
[PATCH]  if  (  i  +  1  <  comment.length  (  )  &&  comment.charAt  (  i  +  1  )  ==  '\n'  )  {	[BUG]  [BUGGY]  if  (  i  +  i  <  comment.length(  )  &&  comment.charAt(  i  +  i)  ==  '\n')  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  for  (int  i  =  0;  i  <  comment.length();  i++)  {  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  [BUGGY]  if  (  i  +  i  <  comment.length(  )  &&  comment.charAt(  i  +  i)  ==  '\n')  {  [BUGGY]  i++;  }    case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();  }    [CLASS]  CSVPrinter  [METHOD]  printComment  [RETURN_TYPE]  void    String  comment  [VARIABLES]  char  c  CSVFormat  format  boolean  newLine  String  comment  int  i  Appendable  out    	[P3_Replace_Literal]
[PATCH]  if  (  i  +  1  <  comment.length  (  )  &&  comment.charAt  (  i  +  1  )  ==  '\n'  )  {	[BUG]  [BUGGY]  if  (  i  +  1  <  comment.length()  -  7  &&  comment.charAt(  i  +  1)  ==  '\n')  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  for  (int  i  =  0;  i  <  comment.length();  i++)  {  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  [BUGGY]  if  (  i  +  1  <  comment.length()  -  7  &&  comment.charAt(  i  +  1)  ==  '\n')  {  [BUGGY]  i++;  }    case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();  }    [CLASS]  CSVPrinter  [METHOD]  printComment  [RETURN_TYPE]  void    String  comment  [VARIABLES]  char  c  CSVFormat  format  boolean  newLine  String  comment  int  i  Appendable  out    	[P3_Replace_Literal]
[PATCH]  if  (  i  +  1  <  comment.length  (  )  &&  comment.charAt  (  i  +  1  )  ==  '\n'  )  {	[BUG]  [BUGGY]  if  (  i  +  0  <  comment.length(  )  &&  comment.charAt(  i  +  0  )  ==  '\n')  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  for  (int  i  =  0;  i  <  comment.length();  i++)  {  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  [BUGGY]  if  (  i  +  0  <  comment.length(  )  &&  comment.charAt(  i  +  0  )  ==  '\n')  {  [BUGGY]  i++;  }    case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();  }    [CLASS]  CSVPrinter  [METHOD]  printComment  [RETURN_TYPE]  void    String  comment  [VARIABLES]  char  c  CSVFormat  format  boolean  newLine  String  comment  int  i  Appendable  out    	[P8_Replace_Mix]
[PATCH]  char  c  =  comment.charAt  (  i  )  ;	[BUG]  [BUGGY]  int  c  =  comment.charAt(  i)  ;[CE]  no  suitable  method  found  for  append(int)  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  for  (int  i  =  0;  i  <  comment.length();  i++)  {  [BUGGY]  int  c  =  comment.charAt(  i)  ;  [BUGGY]  switch  (c)  {  case  '\r':  if  (i  +  1  <  comment.length()  &&  comment.charAt(i  +  1)  ==  '\n')  {  i++;  }    case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();  }    [CLASS]  CSVPrinter  [METHOD]  printComment  [RETURN_TYPE]  void    String  comment  [VARIABLES]  char  c  CSVFormat  format  boolean  newLine  String  comment  int  i  Appendable  out    	[P1_Replace_Type]
[PATCH]  char  c  =  comment.charAt  (  i  )  ;	[BUG]  [BUGGY]  char  c  =  i.charAt(  comment)  ;[CE]  int  cannot  be  dereferenced  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  for  (int  i  =  0;  i  <  comment.length();  i++)  {  [BUGGY]  char  c  =  i.charAt(  comment)  ;  [BUGGY]  switch  (c)  {  case  '\r':  if  (i  +  1  <  comment.length()  &&  comment.charAt(i  +  1)  ==  '\n')  {  i++;  }    case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();  }    [CLASS]  CSVPrinter  [METHOD]  printComment  [RETURN_TYPE]  void    String  comment  [VARIABLES]  char  c  CSVFormat  format  boolean  newLine  String  comment  int  i  Appendable  out    	[P5_Replace_Variable]
[PATCH]  char  c  =  comment.charAt  (  i  )  ;	[BUG]  [BUGGY]  char  escape  =  format.getEscape(  )  ;char  c  =  comment.charAt(  i)  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  for  (int  i  =  0;  i  <  comment.length();  i++)  {  [BUGGY]  char  escape  =  format.getEscape(  )  ;char  c  =  comment.charAt(  i)  ;  [BUGGY]  switch  (c)  {  case  '\r':  if  (i  +  1  <  comment.length()  &&  comment.charAt(i  +  1)  ==  '\n')  {  i++;  }    case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();  }    [CLASS]  CSVPrinter  [METHOD]  printComment  [RETURN_TYPE]  void    String  comment  [VARIABLES]  char  c  CSVFormat  format  boolean  newLine  String  comment  int  i  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  char  c  =  comment.charAt  (  i  )  ;	[BUG]  [BUGGY]  char  c  =  value.charAt(  pos)  ;char  c  =  comment.charAt(  i)  ;[CE]  cannot  find  symbol  pos  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  for  (int  i  =  0;  i  <  comment.length();  i++)  {  [BUGGY]  char  c  =  value.charAt(  pos)  ;char  c  =  comment.charAt(  i)  ;  [BUGGY]  switch  (c)  {  case  '\r':  if  (i  +  1  <  comment.length()  &&  comment.charAt(i  +  1)  ==  '\n')  {  i++;  }    case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();  }    [CLASS]  CSVPrinter  [METHOD]  printComment  [RETURN_TYPE]  void    String  comment  [VARIABLES]  char  c  CSVFormat  format  boolean  newLine  String  comment  int  i  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  char  c  =  comment.charAt  (  i  )  ;	[BUG]  [BUGGY]  [FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  for  (int  i  =  0;  i  <  comment.length();  i++)  {  [BUGGY]  [BUGGY]    switch  (c)  {  case  '\r':  if  (i  +  1  <  comment.length()  &&  comment.charAt(i  +  1)  ==  '\n')  {  i++;  }    case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();    [CLASS]  CSVPrinter  [METHOD]  printComment  [RETURN_TYPE]  void    String  comment  [VARIABLES]  char  c  CSVFormat  format  boolean  newLine  String  comment  int  i  Appendable  out    	[P14_Delete_Statement]
[PATCH]  char  c  =  comment.charAt  (  i  )  ;	[BUG]  [BUGGY]  c  =  value.charAt(  pos)  ;char  c  =  comment.charAt(  i)  ;[CE]  cannot  find  symbol  c  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  for  (int  i  =  0;  i  <  comment.length();  i++)  {  [BUGGY]  c  =  value.charAt(  pos)  ;char  c  =  comment.charAt(  i)  ;  [BUGGY]  switch  (c)  {  case  '\r':  if  (i  +  1  <  comment.length()  &&  comment.charAt(i  +  1)  ==  '\n')  {  i++;  }    case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();  }    [CLASS]  CSVPrinter  [METHOD]  printComment  [RETURN_TYPE]  void    String  comment  [VARIABLES]  char  c  CSVFormat  format  boolean  newLine  String  comment  int  i  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  if  (  i  +  1  <  comment.length  (  )  &&  comment.charAt  (  i  +  1  )  ==  '\n'  )  {	[BUG]  [BUGGY]  if  (  i  +  1  <  comment.length()  +  9  &&  comment.charAt(  i  +  1)  ==  '\n')  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  for  (int  i  =  0;  i  <  comment.length();  i++)  {  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  [BUGGY]  if  (  i  +  1  <  comment.length()  +  9  &&  comment.charAt(  i  +  1)  ==  '\n')  {  [BUGGY]  i++;  }    case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();  }    [CLASS]  CSVPrinter  [METHOD]  printComment  [RETURN_TYPE]  void    String  comment  [VARIABLES]  char  c  CSVFormat  format  boolean  newLine  String  comment  int  i  Appendable  out    	[P3_Replace_Literal]
[PATCH]  if  (  i  +  1  <  comment.length  (  )  &&  comment.charAt  (  i  +  1  )  ==  '\n'  )  {	[BUG]  [BUGGY]  if  (  i  +  1  <  comment.length()  -  1  &&  comment.charAt(  i  +  1)  ==  '\n')  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  for  (int  i  =  0;  i  <  comment.length();  i++)  {  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  [BUGGY]  if  (  i  +  1  <  comment.length()  -  1  &&  comment.charAt(  i  +  1)  ==  '\n')  {  [BUGGY]  i++;  }    case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();  }    [CLASS]  CSVPrinter  [METHOD]  printComment  [RETURN_TYPE]  void    String  comment  [VARIABLES]  char  c  CSVFormat  format  boolean  newLine  String  comment  int  i  Appendable  out    	[P3_Replace_Literal]
[PATCH]  println  (  )  ;	[BUG]  [BUGGY]  printSep(  )  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  for  (int  i  =  0;  i  <  comment.length();  i++)  {  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  if  (i  +  1  <  comment.length()  &&  comment.charAt(i  +  1)  ==  '\n')  {  i++;  }    case  '\n':  [BUGGY]  printSep(  )  ;  [BUGGY]  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();  }    [CLASS]  CSVPrinter  [METHOD]  printComment  [RETURN_TYPE]  void    String  comment  [VARIABLES]  char  c  CSVFormat  format  boolean  newLine  String  comment  int  i  Appendable  out    	[P7_Replace_Invocation]
[PATCH]  println  (  )  ;  out.append  (  format.getCommentStart  (  )  )  ;	[BUG]  [BUGGY]  [FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  for  (int  i  =  0;  i  <  comment.length();  i++)  {  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  if  (i  +  1  <  comment.length()  &&  comment.charAt(i  +  1)  ==  '\n')  {  i++;  }    case  '\n':  [BUGGY]  [BUGGY]    out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();    [CLASS]  CSVPrinter  [METHOD]  printComment  [RETURN_TYPE]  void    String  comment  [VARIABLES]  char  c  CSVFormat  format  boolean  newLine  String  comment  int  i  Appendable  out    	[P14_Delete_Statement]
[PATCH]  println  (  )  ;	[BUG]  [BUGGY]  print(  value)  ;println(  )  ;[CE]  cannot  find  symbol  value  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  for  (int  i  =  0;  i  <  comment.length();  i++)  {  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  if  (i  +  1  <  comment.length()  &&  comment.charAt(i  +  1)  ==  '\n')  {  i++;  }    case  '\n':  [BUGGY]  print(  value)  ;println(  )  ;  [BUGGY]  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();  }    [CLASS]  CSVPrinter  [METHOD]  printComment  [RETURN_TYPE]  void    String  comment  [VARIABLES]  char  c  CSVFormat  format  boolean  newLine  String  comment  int  i  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  println  (  )  ;	[BUG]  [BUGGY]  printSep(  )  ;println(  )  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  for  (int  i  =  0;  i  <  comment.length();  i++)  {  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  if  (i  +  1  <  comment.length()  &&  comment.charAt(i  +  1)  ==  '\n')  {  i++;  }    case  '\n':  [BUGGY]  printSep(  )  ;println(  )  ;  [BUGGY]  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();  }    [CLASS]  CSVPrinter  [METHOD]  printComment  [RETURN_TYPE]  void    String  comment  [VARIABLES]  char  c  CSVFormat  format  boolean  newLine  String  comment  int  i  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  out.append  (  format.getCommentStart  (  )  )  ;	[BUG]  [BUGGY]  out.append(  format.getEscape(  )  )  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  for  (int  i  =  0;  i  <  comment.length();  i++)  {  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  if  (i  +  1  <  comment.length()  &&  comment.charAt(i  +  1)  ==  '\n')  {  i++;  }    case  '\n':  println();  [BUGGY]  out.append(  format.getEscape(  )  )  ;  [BUGGY]  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();  }    [CLASS]  CSVPrinter  [METHOD]  printComment  [RETURN_TYPE]  void    String  comment  [VARIABLES]  char  c  CSVFormat  format  boolean  newLine  String  comment  int  i  Appendable  out    	[P7_Replace_Invocation]
[PATCH]  out.append  (  format.getCommentStart  (  )  )  ;	[BUG]  [BUGGY]  out.append(  value,  start,  end)  ;out.append(  format.getCommentStart(  )  )  ;[CE]  cannot  find  symbol  value  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  for  (int  i  =  0;  i  <  comment.length();  i++)  {  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  if  (i  +  1  <  comment.length()  &&  comment.charAt(i  +  1)  ==  '\n')  {  i++;  }    case  '\n':  println();  [BUGGY]  out.append(  value,  start,  end)  ;out.append(  format.getCommentStart(  )  )  ;  [BUGGY]  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();  }    [CLASS]  CSVPrinter  [METHOD]  printComment  [RETURN_TYPE]  void    String  comment  [VARIABLES]  char  c  CSVFormat  format  boolean  newLine  String  comment  int  i  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  out.append  (  format.getCommentStart  (  )  )  ;	[BUG]  [BUGGY]  out.append(  value,  start,  pos)  ;out.append(  format.getCommentStart(  )  )  ;[CE]  cannot  find  symbol  value  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  for  (int  i  =  0;  i  <  comment.length();  i++)  {  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  if  (i  +  1  <  comment.length()  &&  comment.charAt(i  +  1)  ==  '\n')  {  i++;  }    case  '\n':  println();  [BUGGY]  out.append(  value,  start,  pos)  ;out.append(  format.getCommentStart(  )  )  ;  [BUGGY]  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();  }    [CLASS]  CSVPrinter  [METHOD]  printComment  [RETURN_TYPE]  void    String  comment  [VARIABLES]  char  c  CSVFormat  format  boolean  newLine  String  comment  int  i  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  out.append  (  format.getCommentStart  (  )  )  ;	[BUG]  [BUGGY]  out.append(  format.getLineSeparator(  )  )  ;out.append(  format.getCommentStart(  )  )  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  for  (int  i  =  0;  i  <  comment.length();  i++)  {  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  if  (i  +  1  <  comment.length()  &&  comment.charAt(i  +  1)  ==  '\n')  {  i++;  }    case  '\n':  println();  [BUGGY]  out.append(  format.getLineSeparator(  )  )  ;out.append(  format.getCommentStart(  )  )  ;  [BUGGY]  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();  }    [CLASS]  CSVPrinter  [METHOD]  printComment  [RETURN_TYPE]  void    String  comment  [VARIABLES]  char  c  CSVFormat  format  boolean  newLine  String  comment  int  i  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  out.append  (  format.getCommentStart  (  )  )  ;	[BUG]  [BUGGY]  out.append(  format.getDelimiter(  )  )  ;out.append(  format.getCommentStart(  )  )  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  for  (int  i  =  0;  i  <  comment.length();  i++)  {  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  if  (i  +  1  <  comment.length()  &&  comment.charAt(i  +  1)  ==  '\n')  {  i++;  }    case  '\n':  println();  [BUGGY]  out.append(  format.getDelimiter(  )  )  ;out.append(  format.getCommentStart(  )  )  ;  [BUGGY]  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();  }    [CLASS]  CSVPrinter  [METHOD]  printComment  [RETURN_TYPE]  void    String  comment  [VARIABLES]  char  c  CSVFormat  format  boolean  newLine  String  comment  int  i  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  out.append  (  format.getCommentStart  (  )  )  ;	[BUG]  [BUGGY]  out.append(  value,  start,  pos  +  1)  ;out.append(  format.getCommentStart(  )  )  ;[CE]  cannot  find  symbol  value  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  for  (int  i  =  0;  i  <  comment.length();  i++)  {  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  if  (i  +  1  <  comment.length()  &&  comment.charAt(i  +  1)  ==  '\n')  {  i++;  }    case  '\n':  println();  [BUGGY]  out.append(  value,  start,  pos  +  1)  ;out.append(  format.getCommentStart(  )  )  ;  [BUGGY]  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();  }    [CLASS]  CSVPrinter  [METHOD]  printComment  [RETURN_TYPE]  void    String  comment  [VARIABLES]  char  c  CSVFormat  format  boolean  newLine  String  comment  int  i  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  out.append  (  '  '  )  ;  break;	[BUG]  [BUGGY]  [FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  for  (int  i  =  0;  i  <  comment.length();  i++)  {  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  if  (i  +  1  <  comment.length()  &&  comment.charAt(i  +  1)  ==  '\n')  {  i++;  }    case  '\n':  println();  out.append(format.getCommentStart());  [BUGGY]  [BUGGY]    default:  out.append(c);  break;  }  }  println();    [CLASS]  CSVPrinter  [METHOD]  printComment  [RETURN_TYPE]  void    String  comment  [VARIABLES]  char  c  CSVFormat  format  boolean  newLine  String  comment  int  i  Appendable  out    	[P14_Delete_Statement]
[PATCH]  out.append  (  '  '  )  ;	[BUG]  [BUGGY]  out.append(  value,  start,  end)  ;out.append(  '  ')  ;[CE]  cannot  find  symbol  value  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  for  (int  i  =  0;  i  <  comment.length();  i++)  {  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  if  (i  +  1  <  comment.length()  &&  comment.charAt(i  +  1)  ==  '\n')  {  i++;  }    case  '\n':  println();  out.append(format.getCommentStart());  [BUGGY]  out.append(  value,  start,  end)  ;out.append(  '  ')  ;  [BUGGY]  break;  default:  out.append(c);  break;  }  }  println();  }    [CLASS]  CSVPrinter  [METHOD]  printComment  [RETURN_TYPE]  void    String  comment  [VARIABLES]  char  c  CSVFormat  format  boolean  newLine  String  comment  int  i  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  out.append  (  '  '  )  ;	[BUG]  [BUGGY]  out.append(  value,  start,  pos)  ;out.append(  '  ')  ;[CE]  cannot  find  symbol  value  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  for  (int  i  =  0;  i  <  comment.length();  i++)  {  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  if  (i  +  1  <  comment.length()  &&  comment.charAt(i  +  1)  ==  '\n')  {  i++;  }    case  '\n':  println();  out.append(format.getCommentStart());  [BUGGY]  out.append(  value,  start,  pos)  ;out.append(  '  ')  ;  [BUGGY]  break;  default:  out.append(c);  break;  }  }  println();  }    [CLASS]  CSVPrinter  [METHOD]  printComment  [RETURN_TYPE]  void    String  comment  [VARIABLES]  char  c  CSVFormat  format  boolean  newLine  String  comment  int  i  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  out.append  (  '  '  )  ;	[BUG]  [BUGGY]  out.append(  c)  ;out.append(  '  ')  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  for  (int  i  =  0;  i  <  comment.length();  i++)  {  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  if  (i  +  1  <  comment.length()  &&  comment.charAt(i  +  1)  ==  '\n')  {  i++;  }    case  '\n':  println();  out.append(format.getCommentStart());  [BUGGY]  out.append(  c)  ;out.append(  '  ')  ;  [BUGGY]  break;  default:  out.append(c);  break;  }  }  println();  }    [CLASS]  CSVPrinter  [METHOD]  printComment  [RETURN_TYPE]  void    String  comment  [VARIABLES]  char  c  CSVFormat  format  boolean  newLine  String  comment  int  i  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  out.append  (  '  '  )  ;	[BUG]  [BUGGY]  out.append(  value)  ;out.append(  '  ')  ;[CE]  cannot  find  symbol  value  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  for  (int  i  =  0;  i  <  comment.length();  i++)  {  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  if  (i  +  1  <  comment.length()  &&  comment.charAt(i  +  1)  ==  '\n')  {  i++;  }    case  '\n':  println();  out.append(format.getCommentStart());  [BUGGY]  out.append(  value)  ;out.append(  '  ')  ;  [BUGGY]  break;  default:  out.append(c);  break;  }  }  println();  }    [CLASS]  CSVPrinter  [METHOD]  printComment  [RETURN_TYPE]  void    String  comment  [VARIABLES]  char  c  CSVFormat  format  boolean  newLine  String  comment  int  i  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  out.append  (  '  '  )  ;	[BUG]  [BUGGY]  out.append(  encapsulator)  ;out.append(  '  ')  ;[CE]  cannot  find  symbol  encapsulator  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  for  (int  i  =  0;  i  <  comment.length();  i++)  {  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  if  (i  +  1  <  comment.length()  &&  comment.charAt(i  +  1)  ==  '\n')  {  i++;  }    case  '\n':  println();  out.append(format.getCommentStart());  [BUGGY]  out.append(  encapsulator)  ;out.append(  '  ')  ;  [BUGGY]  break;  default:  out.append(c);  break;  }  }  println();  }    [CLASS]  CSVPrinter  [METHOD]  printComment  [RETURN_TYPE]  void    String  comment  [VARIABLES]  char  c  CSVFormat  format  boolean  newLine  String  comment  int  i  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  out.append  (  '  '  )  ;	[BUG]  [BUGGY]  out.append(  escape)  ;out.append(  '  ')  ;[CE]  cannot  find  symbol  escape  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  for  (int  i  =  0;  i  <  comment.length();  i++)  {  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  if  (i  +  1  <  comment.length()  &&  comment.charAt(i  +  1)  ==  '\n')  {  i++;  }    case  '\n':  println();  out.append(format.getCommentStart());  [BUGGY]  out.append(  escape)  ;out.append(  '  ')  ;  [BUGGY]  break;  default:  out.append(c);  break;  }  }  println();  }    [CLASS]  CSVPrinter  [METHOD]  printComment  [RETURN_TYPE]  void    String  comment  [VARIABLES]  char  c  CSVFormat  format  boolean  newLine  String  comment  int  i  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  out.append  (  c  )  ;  break;	[BUG]  [BUGGY]  [FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  for  (int  i  =  0;  i  <  comment.length();  i++)  {  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  if  (i  +  1  <  comment.length()  &&  comment.charAt(i  +  1)  ==  '\n')  {  i++;  }    case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  [BUGGY]  [BUGGY]    }  }  println();    [CLASS]  CSVPrinter  [METHOD]  printComment  [RETURN_TYPE]  void    String  comment  [VARIABLES]  char  c  CSVFormat  format  boolean  newLine  String  comment  int  i  Appendable  out    	[P14_Delete_Statement]
[PATCH]  out.append  (  c  )  ;	[BUG]  [BUGGY]  out.append(  value)  ;out.append(  c)  ;[CE]  cannot  find  symbol  value  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  for  (int  i  =  0;  i  <  comment.length();  i++)  {  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  if  (i  +  1  <  comment.length()  &&  comment.charAt(i  +  1)  ==  '\n')  {  i++;  }    case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  [BUGGY]  out.append(  value)  ;out.append(  c)  ;  [BUGGY]  break;  }  }  println();  }    [CLASS]  CSVPrinter  [METHOD]  printComment  [RETURN_TYPE]  void    String  comment  [VARIABLES]  char  c  CSVFormat  format  boolean  newLine  String  comment  int  i  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  out.append  (  c  )  ;	[BUG]  [BUGGY]  out.append(  encapsulator)  ;out.append(  c)  ;[CE]  cannot  find  symbol  encapsulator  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  for  (int  i  =  0;  i  <  comment.length();  i++)  {  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  if  (i  +  1  <  comment.length()  &&  comment.charAt(i  +  1)  ==  '\n')  {  i++;  }    case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  [BUGGY]  out.append(  encapsulator)  ;out.append(  c)  ;  [BUGGY]  break;  }  }  println();  }    [CLASS]  CSVPrinter  [METHOD]  printComment  [RETURN_TYPE]  void    String  comment  [VARIABLES]  char  c  CSVFormat  format  boolean  newLine  String  comment  int  i  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  out.append  (  c  )  ;	[BUG]  [BUGGY]  out.append(  '  ')  ;out.append(  c)  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  for  (int  i  =  0;  i  <  comment.length();  i++)  {  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  if  (i  +  1  <  comment.length()  &&  comment.charAt(i  +  1)  ==  '\n')  {  i++;  }    case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  [BUGGY]  out.append(  '  ')  ;out.append(  c)  ;  [BUGGY]  break;  }  }  println();  }    [CLASS]  CSVPrinter  [METHOD]  printComment  [RETURN_TYPE]  void    String  comment  [VARIABLES]  char  c  CSVFormat  format  boolean  newLine  String  comment  int  i  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  out.append  (  c  )  ;	[BUG]  [BUGGY]  out.append(  escape)  ;out.append(  c)  ;[CE]  cannot  find  symbol  escape  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  for  (int  i  =  0;  i  <  comment.length();  i++)  {  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  if  (i  +  1  <  comment.length()  &&  comment.charAt(i  +  1)  ==  '\n')  {  i++;  }    case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  [BUGGY]  out.append(  escape)  ;out.append(  c)  ;  [BUGGY]  break;  }  }  println();  }    [CLASS]  CSVPrinter  [METHOD]  printComment  [RETURN_TYPE]  void    String  comment  [VARIABLES]  char  c  CSVFormat  format  boolean  newLine  String  comment  int  i  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  for  (  int  i  =  0;  i  <  comment.length  (  )  ;  i++  )  {	[BUG]  [BUGGY]  for  (  short  i  =  0;  i  <  comment.length(  )  ;  i++)  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  [BUGGY]  for  (  short  i  =  0;  i  <  comment.length(  )  ;  i++)  {  [BUGGY]  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  if  (i  +  1  <  comment.length()  &&  comment.charAt(i  +  1)  ==  '\n')  {  i++;  }    case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();  }    [CLASS]  CSVPrinter  [METHOD]  printComment  [RETURN_TYPE]  void    String  comment  [VARIABLES]  char  c  CSVFormat  format  boolean  newLine  String  comment  int  i  Appendable  out    	[P1_Replace_Type]
[PATCH]  for  (  int  i  =  0;  i  <  comment.length  (  )  ;  i++  )  {	[BUG]  [BUGGY]  for  (  int  i  =  7;  i  <  comment.length(  )  ;  i++)  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  [BUGGY]  for  (  int  i  =  7;  i  <  comment.length(  )  ;  i++)  {  [BUGGY]  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  if  (i  +  1  <  comment.length()  &&  comment.charAt(i  +  1)  ==  '\n')  {  i++;  }    case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();  }    [CLASS]  CSVPrinter  [METHOD]  printComment  [RETURN_TYPE]  void    String  comment  [VARIABLES]  char  c  CSVFormat  format  boolean  newLine  String  comment  int  i  Appendable  out    	[P3_Replace_Literal]
[PATCH]  for  (  int  i  =  0;  i  <  comment.length  (  )  ;  i++  )  {	[BUG]  [BUGGY]  for  (  int  i  =  0;  i  <  comment.length()  -  3  ;  i++)  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  [BUGGY]  for  (  int  i  =  0;  i  <  comment.length()  -  3  ;  i++)  {  [BUGGY]  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  if  (i  +  1  <  comment.length()  &&  comment.charAt(i  +  1)  ==  '\n')  {  i++;  }    case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();  }    [CLASS]  CSVPrinter  [METHOD]  printComment  [RETURN_TYPE]  void    String  comment  [VARIABLES]  char  c  CSVFormat  format  boolean  newLine  String  comment  int  i  Appendable  out    	[P3_Replace_Literal]
[PATCH]  for  (  int  i  =  0;  i  <  comment.length  (  )  ;  i++  )  {	[BUG]  [BUGGY]  for  (  int  i  =  0;  i  <  comment.length()  -  4  ;  i++)  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  [BUGGY]  for  (  int  i  =  0;  i  <  comment.length()  -  4  ;  i++)  {  [BUGGY]  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  if  (i  +  1  <  comment.length()  &&  comment.charAt(i  +  1)  ==  '\n')  {  i++;  }    case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();  }    [CLASS]  CSVPrinter  [METHOD]  printComment  [RETURN_TYPE]  void    String  comment  [VARIABLES]  char  c  CSVFormat  format  boolean  newLine  String  comment  int  i  Appendable  out    	[P3_Replace_Literal]
[PATCH]  if  (  i  +  1  <  comment.length  (  )  &&  comment.charAt  (  i  +  1  )  ==  '\n'  )  {	[BUG]  [BUGGY]  if  (  i  +  1  <  comment.length()  +  7  &&  comment.charAt(  i  +  1)  ==  '\n')  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  for  (int  i  =  0;  i  <  comment.length();  i++)  {  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  [BUGGY]  if  (  i  +  1  <  comment.length()  +  7  &&  comment.charAt(  i  +  1)  ==  '\n')  {  [BUGGY]  i++;  }    case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();  }    [CLASS]  CSVPrinter  [METHOD]  printComment  [RETURN_TYPE]  void    String  comment  [VARIABLES]  char  c  CSVFormat  format  boolean  newLine  String  comment  int  i  Appendable  out    	[P3_Replace_Literal]
[PATCH]  println  (  )  ;	[BUG]  [BUGGY]  [FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  for  (int  i  =  0;  i  <  comment.length();  i++)  {  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  if  (i  +  1  <  comment.length()  &&  comment.charAt(i  +  1)  ==  '\n')  {  i++;  }    case  '\n':  [BUGGY]  [BUGGY]    out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();    [CLASS]  CSVPrinter  [METHOD]  printComment  [RETURN_TYPE]  void    String  comment  [VARIABLES]  char  c  CSVFormat  format  boolean  newLine  String  comment  int  i  Appendable  out    	[P14_Delete_Statement]
[PATCH]  out.append  (  '  '  )  ;	[BUG]  [BUGGY]  [FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  for  (int  i  =  0;  i  <  comment.length();  i++)  {  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  if  (i  +  1  <  comment.length()  &&  comment.charAt(i  +  1)  ==  '\n')  {  i++;  }    case  '\n':  println();  out.append(format.getCommentStart());  [BUGGY]  [BUGGY]    break;  default:  out.append(c);  break;  }  }  println();    [CLASS]  CSVPrinter  [METHOD]  printComment  [RETURN_TYPE]  void    String  comment  [VARIABLES]  char  c  CSVFormat  format  boolean  newLine  String  comment  int  i  Appendable  out    	[P14_Delete_Statement]
[PATCH]  println  (  )  ;	[BUG]  [BUGGY]  printSep(  )  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  for  (int  i  =  0;  i  <  comment.length();  i++)  {  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  if  (i  +  1  <  comment.length()  &&  comment.charAt(i  +  1)  ==  '\n')  {  i++;  }    case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  [BUGGY]  printSep(  )  ;  [BUGGY]  }    [CLASS]  CSVPrinter  [METHOD]  printComment  [RETURN_TYPE]  void    String  comment  [VARIABLES]  char  c  CSVFormat  format  boolean  newLine  String  comment  int  i  Appendable  out    	[P7_Replace_Invocation]
[PATCH]  println  (  )  ;	[BUG]  [BUGGY]  [FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  for  (int  i  =  0;  i  <  comment.length();  i++)  {  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  if  (i  +  1  <  comment.length()  &&  comment.charAt(i  +  1)  ==  '\n')  {  i++;  }    case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  [BUGGY]  [BUGGY]      [CLASS]  CSVPrinter  [METHOD]  printComment  [RETURN_TYPE]  void    String  comment  [VARIABLES]  char  c  CSVFormat  format  boolean  newLine  String  comment  int  i  Appendable  out    	[P14_Delete_Statement]
[PATCH]  println  (  )  ;	[BUG]  [BUGGY]  print(  value)  ;println(  )  ;[CE]  cannot  find  symbol  value  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  for  (int  i  =  0;  i  <  comment.length();  i++)  {  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  if  (i  +  1  <  comment.length()  &&  comment.charAt(i  +  1)  ==  '\n')  {  i++;  }    case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  [BUGGY]  print(  value)  ;println(  )  ;  [BUGGY]  }    [CLASS]  CSVPrinter  [METHOD]  printComment  [RETURN_TYPE]  void    String  comment  [VARIABLES]  char  c  CSVFormat  format  boolean  newLine  String  comment  int  i  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  println  (  )  ;	[BUG]  [BUGGY]  printSep(  )  ;println(  )  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  for  (int  i  =  0;  i  <  comment.length();  i++)  {  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  if  (i  +  1  <  comment.length()  &&  comment.charAt(i  +  1)  ==  '\n')  {  i++;  }    case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  [BUGGY]  printSep(  )  ;println(  )  ;  [BUGGY]  }    [CLASS]  CSVPrinter  [METHOD]  printComment  [RETURN_TYPE]  void    String  comment  [VARIABLES]  char  c  CSVFormat  format  boolean  newLine  String  comment  int  i  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  if  (  format.isEncapsulating  (  )  )  {	[BUG]  [BUGGY]  if  (  format.isEscaping(  )  )  {[FE]  expected:<[ "x,y "],z>  but  was:<[x,y],z>  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]  private  void  print(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  [BUGGY]  if  (  format.isEscaping(  )  )  {  [BUGGY]  printAndEncapsulate(value,  offset,  len);  }  else  if  (format.isEscaping())  {  printAndEscape(value,  offset,  len);  }  else  {  printSep();  out.append(value,  offset,  offset  +  len);  }  }    [CLASS]  CSVPrinter  [METHOD]  print  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  CSVFormat  format  boolean  newLine  int  len  offset  Appendable  out    	[P7_Replace_Invocation]
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  format.isEscaping(  )  )  {      printAndEscape(  value,  offset,  len)  ;  }else  {      printSep(  )  ;      out.append(  value,  offset,  (  offset  +  len)  )  ;  }[CE]  illegal  start  of  type  [CONTEXT]  private  void  print(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  [BUGGY]  if  (  format.isEscaping(  )  )  {      printAndEscape(  value,  offset,  len)  ;  }else  {      printSep(  )  ;      out.append(  value,  offset,  (  offset  +  len)  )  ;  }  [BUGGY]  printAndEncapsulate(value,  offset,  len);  }  else  if  (format.isEscaping())  {  printAndEscape(value,  offset,  len);  }  else  {  printSep();  out.append(value,  offset,  offset  +  len);  }  }    [CLASS]  CSVPrinter  [METHOD]  print  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  CSVFormat  format  boolean  newLine  int  len  offset  Appendable  out    	[P13_Insert_Block]
[PATCH]  }  else  if  (  format.isEscaping  (  )  )  {	[BUG]  [BUGGY]  }  else  {[CE]  'else'  without  'if'  [CONTEXT]  private  void  print(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  if  (format.isEncapsulating())  {  printAndEncapsulate(value,  offset,  len);  [BUGGY]  }  else  {  [BUGGY]  printAndEscape(value,  offset,  len);  }  else  {  printSep();  out.append(value,  offset,  offset  +  len);  }  }    [CLASS]  CSVPrinter  [METHOD]  print  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  CSVFormat  format  boolean  newLine  int  len  offset  Appendable  out    	[P6_Replace_Expression]
[PATCH]  }  else  if  (  format.isEscaping  (  )  )  {	[BUG]  [BUGGY]  }  else  if  (  format.isEncapsulating(  )  )  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  private  void  print(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  if  (format.isEncapsulating())  {  printAndEncapsulate(value,  offset,  len);  [BUGGY]  }  else  if  (  format.isEncapsulating(  )  )  {  [BUGGY]  printAndEscape(value,  offset,  len);  }  else  {  printSep();  out.append(value,  offset,  offset  +  len);  }  }    [CLASS]  CSVPrinter  [METHOD]  print  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  CSVFormat  format  boolean  newLine  int  len  offset  Appendable  out    	[P7_Replace_Invocation]
[PATCH]  }  else  if  (  format.isEscaping  (  )  )  {	[BUG]  [BUGGY]  }  if  (  format.isEncapsulating(  )  )  {[FE]  expected:<a,[b],c>  but  was:<a,[a,b,b,c],c>  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]  private  void  print(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  if  (format.isEncapsulating())  {  printAndEncapsulate(value,  offset,  len);  [BUGGY]  }  if  (  format.isEncapsulating(  )  )  {  [BUGGY]  printAndEscape(value,  offset,  len);  }  else  {  printSep();  out.append(value,  offset,  offset  +  len);  }  }    [CLASS]  CSVPrinter  [METHOD]  print  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  CSVFormat  format  boolean  newLine  int  len  offset  Appendable  out    	[P8_Replace_Mix]
[PATCH]  }  else  if  (  format.isEscaping  (  )  )  {  printAndEscape  (  value,  offset,  len  )  ;  }  else  {  printSep  (  )  ;  out.append  (  value,  offset,  offset  +  len  )  ;  }	[BUG]  [BUGGY]  printAndEscape(value,  offset,  len);[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  private  void  print(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  if  (format.isEncapsulating())  {  printAndEncapsulate(value,  offset,  len);  [BUGGY]  printAndEscape(value,  offset,  len);  [BUGGY]    printAndEscape(value,  offset,  len);    }    [CLASS]  CSVPrinter  [METHOD]  print  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  CSVFormat  format  boolean  newLine  int  len  offset  Appendable  out    	[P15_Unwrap_Block]
[PATCH]  }  else  if  (  format.isEscaping  (  )  )  {  printAndEscape  (  value,  offset,  len  )  ;  }  else  {  printSep  (  )  ;  out.append  (  value,  offset,  offset  +  len  )  ;  }	[BUG]  [BUGGY]  [FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  private  void  print(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  if  (format.isEncapsulating())  {  printAndEncapsulate(value,  offset,  len);  [BUGGY]  [BUGGY]        }    [CLASS]  CSVPrinter  [METHOD]  print  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  CSVFormat  format  boolean  newLine  int  len  offset  Appendable  out    	[P16_Remove_Block]
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  format.isEncapsulating(  )  )  {      printAndEncapsulate(  value,  offset,  len)  ;  }else      if  (  format.isEscaping(  )  )  {          printAndEscape(  value,  offset,  len)  ;      }else  {          printSep(  )  ;          out.append(  value,  offset,  (  offset  +  len)  )  ;      }[FE]  expected:<a,[b],c>  but  was:<a,[a,a,b,b,b,c,c],c>  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]  private  void  print(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  if  (format.isEncapsulating())  {  printAndEncapsulate(value,  offset,  len);  [BUGGY]  if  (  format.isEncapsulating(  )  )  {      printAndEncapsulate(  value,  offset,  len)  ;  }else      if  (  format.isEscaping(  )  )  {          printAndEscape(  value,  offset,  len)  ;      }else  {          printSep(  )  ;          out.append(  value,  offset,  (  offset  +  len)  )  ;      }  [BUGGY]  printAndEscape(value,  offset,  len);  }  else  {  printSep();  out.append(value,  offset,  offset  +  len);  }  }    [CLASS]  CSVPrinter  [METHOD]  print  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  CSVFormat  format  boolean  newLine  int  len  offset  Appendable  out    	[P13_Insert_Block]
[PATCH]  printSep  (  )  ;	[BUG]  [BUGGY]  println(  )  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  private  void  print(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  if  (format.isEncapsulating())  {  printAndEncapsulate(value,  offset,  len);  }  else  if  (format.isEscaping())  {  printAndEscape(value,  offset,  len);  }  else  {  [BUGGY]  println(  )  ;  [BUGGY]  out.append(value,  offset,  offset  +  len);  }  }    [CLASS]  CSVPrinter  [METHOD]  print  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  CSVFormat  format  boolean  newLine  int  len  offset  Appendable  out    	[P7_Replace_Invocation]
[PATCH]  printSep  (  )  ;  out.append  (  value,  offset,  offset  +  len  )  ;	[BUG]  [BUGGY]  [FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  private  void  print(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  if  (format.isEncapsulating())  {  printAndEncapsulate(value,  offset,  len);  }  else  if  (format.isEscaping())  {  printAndEscape(value,  offset,  len);  }  else  {  [BUGGY]  [BUGGY]    }    [CLASS]  CSVPrinter  [METHOD]  print  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  CSVFormat  format  boolean  newLine  int  len  offset  Appendable  out    	[P14_Delete_Statement]
[PATCH]  printSep  (  )  ;	[BUG]  [BUGGY]  println(  )  ;printSep(  )  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  private  void  print(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  if  (format.isEncapsulating())  {  printAndEncapsulate(value,  offset,  len);  }  else  if  (format.isEscaping())  {  printAndEscape(value,  offset,  len);  }  else  {  [BUGGY]  println(  )  ;printSep(  )  ;  [BUGGY]  out.append(value,  offset,  offset  +  len);  }  }    [CLASS]  CSVPrinter  [METHOD]  print  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  CSVFormat  format  boolean  newLine  int  len  offset  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  printSep  (  )  ;	[BUG]  [BUGGY]  print(  value)  ;printSep(  )  ;[CE]  no  suitable  method  found  for  print(CharSequence)  [CONTEXT]  private  void  print(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  if  (format.isEncapsulating())  {  printAndEncapsulate(value,  offset,  len);  }  else  if  (format.isEscaping())  {  printAndEscape(value,  offset,  len);  }  else  {  [BUGGY]  print(  value)  ;printSep(  )  ;  [BUGGY]  out.append(value,  offset,  offset  +  len);  }  }    [CLASS]  CSVPrinter  [METHOD]  print  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  CSVFormat  format  boolean  newLine  int  len  offset  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  out.append  (  value,  offset,  offset  +  len  )  ;	[BUG]  [BUGGY]  out.append(  value,  offset,  offset  <  len)  ;[CE]  no  suitable  method  found  for  append(CharSequence,int,boolean)  [CONTEXT]  private  void  print(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  if  (format.isEncapsulating())  {  printAndEncapsulate(value,  offset,  len);  }  else  if  (format.isEscaping())  {  printAndEscape(value,  offset,  len);  }  else  {  printSep();  [BUGGY]  out.append(  value,  offset,  offset  <  len)  ;  [BUGGY]  }  }    [CLASS]  CSVPrinter  [METHOD]  print  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  CSVFormat  format  boolean  newLine  int  len  offset  Appendable  out    	[P2_Replace_Operator]
[PATCH]  out.append  (  value,  offset,  offset  +  len  )  ;	[BUG]  [BUGGY]  out.append(  offset,  offset  +  len)  ;[CE]  no  suitable  method  found  for  append(int,int)  [CONTEXT]  private  void  print(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  if  (format.isEncapsulating())  {  printAndEncapsulate(value,  offset,  len);  }  else  if  (format.isEscaping())  {  printAndEscape(value,  offset,  len);  }  else  {  printSep();  [BUGGY]  out.append(  offset,  offset  +  len)  ;  [BUGGY]  }  }    [CLASS]  CSVPrinter  [METHOD]  print  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  CSVFormat  format  boolean  newLine  int  len  offset  Appendable  out    	[P5_Replace_Variable]
[PATCH]  out.append  (  value,  offset,  offset  +  len  )  ;	[BUG]  [BUGGY]  out.append(  value,  offset  +  len)  ;[CE]  no  suitable  method  found  for  append(CharSequence,int)  [CONTEXT]  private  void  print(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  if  (format.isEncapsulating())  {  printAndEncapsulate(value,  offset,  len);  }  else  if  (format.isEscaping())  {  printAndEscape(value,  offset,  len);  }  else  {  printSep();  [BUGGY]  out.append(  value,  offset  +  len)  ;  [BUGGY]  }  }    [CLASS]  CSVPrinter  [METHOD]  print  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  CSVFormat  format  boolean  newLine  int  len  offset  Appendable  out    	[P5_Replace_Variable]
[PATCH]  out.append  (  value,  offset,  offset  +  len  )  ;	[BUG]  [BUGGY]  out.append(  len,  offset,  offset  +  value)  ;[CE]  bad  operand  types  for  binary  operator  '+'  [CONTEXT]  private  void  print(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  if  (format.isEncapsulating())  {  printAndEncapsulate(value,  offset,  len);  }  else  if  (format.isEscaping())  {  printAndEscape(value,  offset,  len);  }  else  {  printSep();  [BUGGY]  out.append(  len,  offset,  offset  +  value)  ;  [BUGGY]  }  }    [CLASS]  CSVPrinter  [METHOD]  print  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  CSVFormat  format  boolean  newLine  int  len  offset  Appendable  out    	[P5_Replace_Variable]
[PATCH]  out.append  (  value,  offset,  offset  +  len  )  ;	[BUG]  [BUGGY]  out.append(  value,  len,  offset  +  offset)  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  private  void  print(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  if  (format.isEncapsulating())  {  printAndEncapsulate(value,  offset,  len);  }  else  if  (format.isEscaping())  {  printAndEscape(value,  offset,  len);  }  else  {  printSep();  [BUGGY]  out.append(  value,  len,  offset  +  offset)  ;  [BUGGY]  }  }    [CLASS]  CSVPrinter  [METHOD]  print  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  CSVFormat  format  boolean  newLine  int  len  offset  Appendable  out    	[P5_Replace_Variable]
[PATCH]  out.append  (  value,  offset,  offset  +  len  )  ;	[BUG]  [BUGGY]  out.append(  value)  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  private  void  print(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  if  (format.isEncapsulating())  {  printAndEncapsulate(value,  offset,  len);  }  else  if  (format.isEscaping())  {  printAndEscape(value,  offset,  len);  }  else  {  printSep();  [BUGGY]  out.append(  value)  ;  [BUGGY]  }  }    [CLASS]  CSVPrinter  [METHOD]  print  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  CSVFormat  format  boolean  newLine  int  len  offset  Appendable  out    	[P7_Replace_Invocation]
[PATCH]  out.append  (  value,  offset,  offset  +  len  )  ;	[BUG]  [BUGGY]  out.append(  value,  offset,  offset  +  offset)  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  private  void  print(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  if  (format.isEncapsulating())  {  printAndEncapsulate(value,  offset,  len);  }  else  if  (format.isEscaping())  {  printAndEscape(value,  offset,  len);  }  else  {  printSep();  [BUGGY]  out.append(  value,  offset,  offset  +  offset)  ;  [BUGGY]  }  }    [CLASS]  CSVPrinter  [METHOD]  print  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  CSVFormat  format  boolean  newLine  int  len  offset  Appendable  out    	[P8_Replace_Mix]
[PATCH]  out.append  (  value,  offset,  offset  +  len  )  ;	[BUG]  [BUGGY]  [FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  private  void  print(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  if  (format.isEncapsulating())  {  printAndEncapsulate(value,  offset,  len);  }  else  if  (format.isEscaping())  {  printAndEscape(value,  offset,  len);  }  else  {  printSep();  [BUGGY]  [BUGGY]    }    [CLASS]  CSVPrinter  [METHOD]  print  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  CSVFormat  format  boolean  newLine  int  len  offset  Appendable  out    	[P14_Delete_Statement]
[PATCH]  out.append  (  value,  offset,  offset  +  len  )  ;	[BUG]  [BUGGY]  out.append(  value,  start,  end)  ;out.append(  value,  offset,  offset  +  len)  ;[CE]  cannot  find  symbol  start  [CONTEXT]  private  void  print(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  if  (format.isEncapsulating())  {  printAndEncapsulate(value,  offset,  len);  }  else  if  (format.isEscaping())  {  printAndEscape(value,  offset,  len);  }  else  {  printSep();  [BUGGY]  out.append(  value,  start,  end)  ;out.append(  value,  offset,  offset  +  len)  ;  [BUGGY]  }  }    [CLASS]  CSVPrinter  [METHOD]  print  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  CSVFormat  format  boolean  newLine  int  len  offset  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  out.append  (  value,  offset,  offset  +  len  )  ;	[BUG]  [BUGGY]  out.append(  value,  start,  pos)  ;out.append(  value,  offset,  offset  +  len)  ;[CE]  cannot  find  symbol  start  [CONTEXT]  private  void  print(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  if  (format.isEncapsulating())  {  printAndEncapsulate(value,  offset,  len);  }  else  if  (format.isEscaping())  {  printAndEscape(value,  offset,  len);  }  else  {  printSep();  [BUGGY]  out.append(  value,  start,  pos)  ;out.append(  value,  offset,  offset  +  len)  ;  [BUGGY]  }  }    [CLASS]  CSVPrinter  [METHOD]  print  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  CSVFormat  format  boolean  newLine  int  len  offset  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  out.append  (  value,  offset,  offset  +  len  )  ;	[BUG]  [BUGGY]  printAndEscape(  value,  offset,  len)  ;out.append(  value,  offset,  offset  +  len)  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  private  void  print(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  if  (format.isEncapsulating())  {  printAndEncapsulate(value,  offset,  len);  }  else  if  (format.isEscaping())  {  printAndEscape(value,  offset,  len);  }  else  {  printSep();  [BUGGY]  printAndEscape(  value,  offset,  len)  ;out.append(  value,  offset,  offset  +  len)  ;  [BUGGY]  }  }    [CLASS]  CSVPrinter  [METHOD]  print  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  CSVFormat  format  boolean  newLine  int  len  offset  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  out.append  (  value,  offset,  offset  +  len  )  ;	[BUG]  [BUGGY]  out.append(  value,  start,  pos  +  1)  ;out.append(  value,  offset,  offset  +  len)  ;[CE]  cannot  find  symbol  start  [CONTEXT]  private  void  print(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  if  (format.isEncapsulating())  {  printAndEncapsulate(value,  offset,  len);  }  else  if  (format.isEscaping())  {  printAndEscape(value,  offset,  len);  }  else  {  printSep();  [BUGGY]  out.append(  value,  start,  pos  +  1)  ;out.append(  value,  offset,  offset  +  len)  ;  [BUGGY]  }  }    [CLASS]  CSVPrinter  [METHOD]  print  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  CSVFormat  format  boolean  newLine  int  len  offset  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  printAndEscape  (  value,  offset,  len  )  ;	[BUG]  [BUGGY]  printAndEscape(  offset,  len)  ;[CE]  method  printAndEscape  in  class  CSVPrinter  cannot  be  applied  to  given  types;  [CONTEXT]  private  void  print(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  if  (format.isEncapsulating())  {  printAndEncapsulate(value,  offset,  len);  }  else  if  (format.isEscaping())  {  [BUGGY]  printAndEscape(  offset,  len)  ;  [BUGGY]  }  else  {  printSep();  out.append(value,  offset,  offset  +  len);  }  }    [CLASS]  CSVPrinter  [METHOD]  print  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  CSVFormat  format  boolean  newLine  int  len  offset  Appendable  out    	[P5_Replace_Variable]
[PATCH]  printAndEscape  (  value,  offset,  len  )  ;	[BUG]  [BUGGY]  printAndEscape(  value,  len)  ;[CE]  method  printAndEscape  in  class  CSVPrinter  cannot  be  applied  to  given  types;  [CONTEXT]  private  void  print(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  if  (format.isEncapsulating())  {  printAndEncapsulate(value,  offset,  len);  }  else  if  (format.isEscaping())  {  [BUGGY]  printAndEscape(  value,  len)  ;  [BUGGY]  }  else  {  printSep();  out.append(value,  offset,  offset  +  len);  }  }    [CLASS]  CSVPrinter  [METHOD]  print  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  CSVFormat  format  boolean  newLine  int  len  offset  Appendable  out    	[P5_Replace_Variable]
[PATCH]  printAndEscape  (  value,  offset,  len  )  ;	[BUG]  [BUGGY]  printAndEscape(  value,  offset)  ;[CE]  method  printAndEscape  in  class  CSVPrinter  cannot  be  applied  to  given  types;  [CONTEXT]  private  void  print(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  if  (format.isEncapsulating())  {  printAndEncapsulate(value,  offset,  len);  }  else  if  (format.isEscaping())  {  [BUGGY]  printAndEscape(  value,  offset)  ;  [BUGGY]  }  else  {  printSep();  out.append(value,  offset,  offset  +  len);  }  }    [CLASS]  CSVPrinter  [METHOD]  print  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  CSVFormat  format  boolean  newLine  int  len  offset  Appendable  out    	[P5_Replace_Variable]
[PATCH]  printAndEscape  (  value,  offset,  len  )  ;	[BUG]  [BUGGY]  printAndEscape(  len,  offset,  value)  ;[CE]  method  printAndEscape  in  class  CSVPrinter  cannot  be  applied  to  given  types;  [CONTEXT]  private  void  print(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  if  (format.isEncapsulating())  {  printAndEncapsulate(value,  offset,  len);  }  else  if  (format.isEscaping())  {  [BUGGY]  printAndEscape(  len,  offset,  value)  ;  [BUGGY]  }  else  {  printSep();  out.append(value,  offset,  offset  +  len);  }  }    [CLASS]  CSVPrinter  [METHOD]  print  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  CSVFormat  format  boolean  newLine  int  len  offset  Appendable  out    	[P5_Replace_Variable]
[PATCH]  printAndEscape  (  value,  offset,  len  )  ;	[BUG]  [BUGGY]  printAndEscape(  value,  len,  offset)  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  private  void  print(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  if  (format.isEncapsulating())  {  printAndEncapsulate(value,  offset,  len);  }  else  if  (format.isEscaping())  {  [BUGGY]  printAndEscape(  value,  len,  offset)  ;  [BUGGY]  }  else  {  printSep();  out.append(value,  offset,  offset  +  len);  }  }    [CLASS]  CSVPrinter  [METHOD]  print  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  CSVFormat  format  boolean  newLine  int  len  offset  Appendable  out    	[P5_Replace_Variable]
[PATCH]  printAndEscape  (  value,  offset,  len  )  ;	[BUG]  [BUGGY]  printAndEncapsulate(  value,  offset,  len)  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  private  void  print(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  if  (format.isEncapsulating())  {  printAndEncapsulate(value,  offset,  len);  }  else  if  (format.isEscaping())  {  [BUGGY]  printAndEncapsulate(  value,  offset,  len)  ;  [BUGGY]  }  else  {  printSep();  out.append(value,  offset,  offset  +  len);  }  }    [CLASS]  CSVPrinter  [METHOD]  print  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  CSVFormat  format  boolean  newLine  int  len  offset  Appendable  out    	[P7_Replace_Invocation]
[PATCH]  printAndEscape  (  value,  offset,  len  )  ;	[BUG]  [BUGGY]  [FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  private  void  print(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  if  (format.isEncapsulating())  {  printAndEncapsulate(value,  offset,  len);  }  else  if  (format.isEscaping())  {  [BUGGY]  [BUGGY]    }  else  {  printSep();  out.append(value,  offset,  offset  +  len);  }    [CLASS]  CSVPrinter  [METHOD]  print  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  CSVFormat  format  boolean  newLine  int  len  offset  Appendable  out    	[P14_Delete_Statement]
[PATCH]  printAndEscape  (  value,  offset,  len  )  ;	[BUG]  [BUGGY]  out.append(  value,  start,  end)  ;printAndEscape(  value,  offset,  len)  ;[CE]  cannot  find  symbol  start  [CONTEXT]  private  void  print(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  if  (format.isEncapsulating())  {  printAndEncapsulate(value,  offset,  len);  }  else  if  (format.isEscaping())  {  [BUGGY]  out.append(  value,  start,  end)  ;printAndEscape(  value,  offset,  len)  ;  [BUGGY]  }  else  {  printSep();  out.append(value,  offset,  offset  +  len);  }  }    [CLASS]  CSVPrinter  [METHOD]  print  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  CSVFormat  format  boolean  newLine  int  len  offset  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  printAndEscape  (  value,  offset,  len  )  ;	[BUG]  [BUGGY]  print(  value,  true)  ;printAndEscape(  value,  offset,  len)  ;[CE]  no  suitable  method  found  for  print(CharSequence,boolean)  [CONTEXT]  private  void  print(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  if  (format.isEncapsulating())  {  printAndEncapsulate(value,  offset,  len);  }  else  if  (format.isEscaping())  {  [BUGGY]  print(  value,  true)  ;printAndEscape(  value,  offset,  len)  ;  [BUGGY]  }  else  {  printSep();  out.append(value,  offset,  offset  +  len);  }  }    [CLASS]  CSVPrinter  [METHOD]  print  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  CSVFormat  format  boolean  newLine  int  len  offset  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  printAndEscape  (  value,  offset,  len  )  ;	[BUG]  [BUGGY]  printAndEncapsulate(  value,  offset,  len)  ;printAndEscape(  value,  offset,  len)  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  private  void  print(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  if  (format.isEncapsulating())  {  printAndEncapsulate(value,  offset,  len);  }  else  if  (format.isEscaping())  {  [BUGGY]  printAndEncapsulate(  value,  offset,  len)  ;printAndEscape(  value,  offset,  len)  ;  [BUGGY]  }  else  {  printSep();  out.append(value,  offset,  offset  +  len);  }  }    [CLASS]  CSVPrinter  [METHOD]  print  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  CSVFormat  format  boolean  newLine  int  len  offset  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  printAndEscape  (  value,  offset,  len  )  ;	[BUG]  [BUGGY]  out.append(  value,  offset,  offset  +  len)  ;printAndEscape(  value,  offset,  len)  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  private  void  print(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  if  (format.isEncapsulating())  {  printAndEncapsulate(value,  offset,  len);  }  else  if  (format.isEscaping())  {  [BUGGY]  out.append(  value,  offset,  offset  +  len)  ;printAndEscape(  value,  offset,  len)  ;  [BUGGY]  }  else  {  printSep();  out.append(value,  offset,  offset  +  len);  }  }    [CLASS]  CSVPrinter  [METHOD]  print  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  CSVFormat  format  boolean  newLine  int  len  offset  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  printAndEscape  (  value,  offset,  len  )  ;	[BUG]  [BUGGY]  printAndEscape(  offset,  value,  len)  ;[CE]  method  printAndEscape  in  class  CSVPrinter  cannot  be  applied  to  given  types;  [CONTEXT]  private  void  print(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  if  (format.isEncapsulating())  {  printAndEncapsulate(value,  offset,  len);  }  else  if  (format.isEscaping())  {  [BUGGY]  printAndEscape(  offset,  value,  len)  ;  [BUGGY]  }  else  {  printSep();  out.append(value,  offset,  offset  +  len);  }  }    [CLASS]  CSVPrinter  [METHOD]  print  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  CSVFormat  format  boolean  newLine  int  len  offset  Appendable  out    	[P5_Replace_Variable]
[PATCH]  printSep  (  )  ;	[BUG]  [BUGGY]  [FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  private  void  print(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  if  (format.isEncapsulating())  {  printAndEncapsulate(value,  offset,  len);  }  else  if  (format.isEscaping())  {  printAndEscape(value,  offset,  len);  }  else  {  [BUGGY]  [BUGGY]    out.append(value,  offset,  offset  +  len);  }    [CLASS]  CSVPrinter  [METHOD]  print  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  CSVFormat  format  boolean  newLine  int  len  offset  Appendable  out    	[P14_Delete_Statement]
[PATCH]  out.append  (  value,  offset,  offset  +  len  )  ;	[BUG]  [BUGGY]  out.append(  value,  offset,  offset  ==  len)  ;[CE]  no  suitable  method  found  for  append(CharSequence,int,boolean)  [CONTEXT]  private  void  print(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  if  (format.isEncapsulating())  {  printAndEncapsulate(value,  offset,  len);  }  else  if  (format.isEscaping())  {  printAndEscape(value,  offset,  len);  }  else  {  printSep();  [BUGGY]  out.append(  value,  offset,  offset  ==  len)  ;  [BUGGY]  }  }    [CLASS]  CSVPrinter  [METHOD]  print  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  CSVFormat  format  boolean  newLine  int  len  offset  Appendable  out    	[P2_Replace_Operator]
[PATCH]  out.append  (  value,  offset,  offset  +  len  )  ;	[BUG]  [BUGGY]  out.append(  offset,  value,  offset  +  len)  ;[CE]  no  suitable  method  found  for  append(int,CharSequence,int)  [CONTEXT]  private  void  print(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  if  (format.isEncapsulating())  {  printAndEncapsulate(value,  offset,  len);  }  else  if  (format.isEscaping())  {  printAndEscape(value,  offset,  len);  }  else  {  printSep();  [BUGGY]  out.append(  offset,  value,  offset  +  len)  ;  [BUGGY]  }  }    [CLASS]  CSVPrinter  [METHOD]  print  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  CSVFormat  format  boolean  newLine  int  len  offset  Appendable  out    	[P5_Replace_Variable]
[PATCH]  printAndEncapsulate  (  value,  offset,  len  )  ;	[BUG]  [BUGGY]  printAndEncapsulate(  offset,  len)  ;[CE]  method  printAndEncapsulate  in  class  CSVPrinter  cannot  be  applied  to  given  types;  [CONTEXT]  private  void  print(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  if  (format.isEncapsulating())  {  [BUGGY]  printAndEncapsulate(  offset,  len)  ;  [BUGGY]  }  else  if  (format.isEscaping())  {  printAndEscape(value,  offset,  len);  }  else  {  printSep();  out.append(value,  offset,  offset  +  len);  }  }    [CLASS]  CSVPrinter  [METHOD]  print  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  CSVFormat  format  boolean  newLine  int  len  offset  Appendable  out    	[P5_Replace_Variable]
[PATCH]  printAndEncapsulate  (  value,  offset,  len  )  ;	[BUG]  [BUGGY]  printAndEncapsulate(  value,  len)  ;[CE]  method  printAndEncapsulate  in  class  CSVPrinter  cannot  be  applied  to  given  types;  [CONTEXT]  private  void  print(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  if  (format.isEncapsulating())  {  [BUGGY]  printAndEncapsulate(  value,  len)  ;  [BUGGY]  }  else  if  (format.isEscaping())  {  printAndEscape(value,  offset,  len);  }  else  {  printSep();  out.append(value,  offset,  offset  +  len);  }  }    [CLASS]  CSVPrinter  [METHOD]  print  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  CSVFormat  format  boolean  newLine  int  len  offset  Appendable  out    	[P5_Replace_Variable]
[PATCH]  printAndEncapsulate  (  value,  offset,  len  )  ;	[BUG]  [BUGGY]  printAndEncapsulate(  value,  offset)  ;[CE]  method  printAndEncapsulate  in  class  CSVPrinter  cannot  be  applied  to  given  types;  [CONTEXT]  private  void  print(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  if  (format.isEncapsulating())  {  [BUGGY]  printAndEncapsulate(  value,  offset)  ;  [BUGGY]  }  else  if  (format.isEscaping())  {  printAndEscape(value,  offset,  len);  }  else  {  printSep();  out.append(value,  offset,  offset  +  len);  }  }    [CLASS]  CSVPrinter  [METHOD]  print  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  CSVFormat  format  boolean  newLine  int  len  offset  Appendable  out    	[P5_Replace_Variable]
[PATCH]  printAndEncapsulate  (  value,  offset,  len  )  ;	[BUG]  [BUGGY]  printAndEncapsulate(  len,  offset,  value)  ;[CE]  method  printAndEncapsulate  in  class  CSVPrinter  cannot  be  applied  to  given  types;  [CONTEXT]  private  void  print(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  if  (format.isEncapsulating())  {  [BUGGY]  printAndEncapsulate(  len,  offset,  value)  ;  [BUGGY]  }  else  if  (format.isEscaping())  {  printAndEscape(value,  offset,  len);  }  else  {  printSep();  out.append(value,  offset,  offset  +  len);  }  }    [CLASS]  CSVPrinter  [METHOD]  print  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  CSVFormat  format  boolean  newLine  int  len  offset  Appendable  out    	[P5_Replace_Variable]
[PATCH]  printAndEncapsulate  (  value,  offset,  len  )  ;	[BUG]  [BUGGY]  printAndEncapsulate(  value,  len,  offset)  ;[FE]  expected:<[a,b,c]>  but  was:<[ " ",,]>  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]  private  void  print(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  if  (format.isEncapsulating())  {  [BUGGY]  printAndEncapsulate(  value,  len,  offset)  ;  [BUGGY]  }  else  if  (format.isEscaping())  {  printAndEscape(value,  offset,  len);  }  else  {  printSep();  out.append(value,  offset,  offset  +  len);  }  }    [CLASS]  CSVPrinter  [METHOD]  print  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  CSVFormat  format  boolean  newLine  int  len  offset  Appendable  out    	[P5_Replace_Variable]
[PATCH]  printAndEncapsulate  (  value,  offset,  len  )  ;	[BUG]  [BUGGY]  printAndEscape(  value,  offset,  len)  ;[FE]  expected:<[ "x,y "],z>  but  was:<[x  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]  private  void  print(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  if  (format.isEncapsulating())  {  [BUGGY]  printAndEscape(  value,  offset,  len)  ;  [BUGGY]  }  else  if  (format.isEscaping())  {  printAndEscape(value,  offset,  len);  }  else  {  printSep();  out.append(value,  offset,  offset  +  len);  }  }    [CLASS]  CSVPrinter  [METHOD]  print  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  CSVFormat  format  boolean  newLine  int  len  offset  Appendable  out    	[P7_Replace_Invocation]
[PATCH]  printAndEncapsulate  (  value,  offset,  len  )  ;	[BUG]  [BUGGY]  [FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  private  void  print(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  if  (format.isEncapsulating())  {  [BUGGY]  [BUGGY]    }  else  if  (format.isEscaping())  {  printAndEscape(value,  offset,  len);  }  else  {  printSep();  out.append(value,  offset,  offset  +  len);  }    [CLASS]  CSVPrinter  [METHOD]  print  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  CSVFormat  format  boolean  newLine  int  len  offset  Appendable  out    	[P14_Delete_Statement]
[PATCH]  out.append  (  value,  offset,  offset  +  len  )  ;	[BUG]  [BUGGY]  out.append(  value,  offset,  offset  >  len)  ;[CE]  no  suitable  method  found  for  append(CharSequence,int,boolean)  [CONTEXT]  private  void  print(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  if  (format.isEncapsulating())  {  printAndEncapsulate(value,  offset,  len);  }  else  if  (format.isEscaping())  {  printAndEscape(value,  offset,  len);  }  else  {  printSep();  [BUGGY]  out.append(  value,  offset,  offset  >  len)  ;  [BUGGY]  }  }    [CLASS]  CSVPrinter  [METHOD]  print  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  CSVFormat  format  boolean  newLine  int  len  offset  Appendable  out    	[P2_Replace_Operator]
[PATCH]  printAndEscape  (  value,  offset,  len  )  ;	[BUG]  [BUGGY]  printAndEscape(  value,  len,  len)  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  private  void  print(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  if  (format.isEncapsulating())  {  printAndEncapsulate(value,  offset,  len);  }  else  if  (format.isEscaping())  {  [BUGGY]  printAndEscape(  value,  len,  len)  ;  [BUGGY]  }  else  {  printSep();  out.append(value,  offset,  offset  +  len);  }  }    [CLASS]  CSVPrinter  [METHOD]  print  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  CSVFormat  format  boolean  newLine  int  len  offset  Appendable  out    	[P5_Replace_Variable]
[PATCH]  printAndEscape  (  value,  offset,  len  )  ;	[BUG]  [BUGGY]  printAndEscape(  value,  offset,  offset)  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  private  void  print(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  if  (format.isEncapsulating())  {  printAndEncapsulate(value,  offset,  len);  }  else  if  (format.isEscaping())  {  [BUGGY]  printAndEscape(  value,  offset,  offset)  ;  [BUGGY]  }  else  {  printSep();  out.append(value,  offset,  offset  +  len);  }  }    [CLASS]  CSVPrinter  [METHOD]  print  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  CSVFormat  format  boolean  newLine  int  len  offset  Appendable  out    	[P8_Replace_Mix]
[PATCH]  printAndEscape  (  value,  offset,  len  )  ;	[BUG]  [BUGGY]  printAndEncapsulate(  value,  offset,  offset)  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  private  void  print(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  if  (format.isEncapsulating())  {  printAndEncapsulate(value,  offset,  len);  }  else  if  (format.isEscaping())  {  [BUGGY]  printAndEncapsulate(  value,  offset,  offset)  ;  [BUGGY]  }  else  {  printSep();  out.append(value,  offset,  offset  +  len);  }  }    [CLASS]  CSVPrinter  [METHOD]  print  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  CSVFormat  format  boolean  newLine  int  len  offset  Appendable  out    	[P8_Replace_Mix]
[PATCH]  out.append  (  value,  offset,  offset  +  len  )  ;	[BUG]  [BUGGY]  out.append(  value,  offset,  offset  !=  len)  ;[CE]  no  suitable  method  found  for  append(CharSequence,int,boolean)  [CONTEXT]  private  void  print(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  if  (format.isEncapsulating())  {  printAndEncapsulate(value,  offset,  len);  }  else  if  (format.isEscaping())  {  printAndEscape(value,  offset,  len);  }  else  {  printSep();  [BUGGY]  out.append(  value,  offset,  offset  !=  len)  ;  [BUGGY]  }  }    [CLASS]  CSVPrinter  [METHOD]  print  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  CSVFormat  format  boolean  newLine  int  len  offset  Appendable  out    	[P2_Replace_Operator]
[PATCH]  if  (  newLine  )  {	[BUG]  [BUGGY]  if  (  !newLine)  {[FE]  expected:<[]a,b,c>  but  was:<[,]a,b,c>  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]  void  printSep()  throws  IOException  {  [BUGGY]  if  (  !newLine)  {  [BUGGY]  newLine  =  false;  }  else  {  out.append(format.getDelimiter());  }  }    [CLASS]  CSVPrinter  [METHOD]  printSep  [RETURN_TYPE]  void    [VARIABLES]  CSVFormat  format  boolean  newLine  Appendable  out    	[P9_Replace_Statement]
[PATCH]  if  (  newLine  )  {	[BUG]  [BUGGY]  if  (  !quote)  {[CE]  cannot  find  symbol  quote  [CONTEXT]  void  printSep()  throws  IOException  {  [BUGGY]  if  (  !quote)  {  [BUGGY]  newLine  =  false;  }  else  {  out.append(format.getDelimiter());  }  }    [CLASS]  CSVPrinter  [METHOD]  printSep  [RETURN_TYPE]  void    [VARIABLES]  CSVFormat  format  boolean  newLine  Appendable  out    	[P9_Replace_Statement]
[PATCH]  if  (  newLine  )  {  newLine  =  false;  }  else  {  out.append  (  format.getDelimiter  (  )  )  ;  }	[BUG]  [BUGGY]  newLine  =  false;[CE]  illegal  start  of  expression  [CONTEXT]  void  printSep()  throws  IOException  {  [BUGGY]  newLine  =  false;  [BUGGY]    newLine  =  false;        [CLASS]  CSVPrinter  [METHOD]  printSep  [RETURN_TYPE]  void    [VARIABLES]  CSVFormat  format  boolean  newLine  Appendable  out    	[P15_Unwrap_Block]
[PATCH]  if  (  newLine  )  {  newLine  =  false;  }  else  {  out.append  (  format.getDelimiter  (  )  )  ;  }	[BUG]  [BUGGY]  [CE]  illegal  start  of  expression  [CONTEXT]  void  printSep()  throws  IOException  {  [BUGGY]  [BUGGY]          [CLASS]  CSVPrinter  [METHOD]  printSep  [RETURN_TYPE]  void    [VARIABLES]  CSVFormat  format  boolean  newLine  Appendable  out    	[P16_Remove_Block]
[PATCH]  out.append  (  format.getDelimiter  (  )  )  ;	[BUG]  [BUGGY]  out.append(  format.getEscape(  )  )  ;[FE]  expected:<a[,b,]c>  but  was:<a[  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]  void  printSep()  throws  IOException  {  if  (newLine)  {  newLine  =  false;  }  else  {  [BUGGY]  out.append(  format.getEscape(  )  )  ;  [BUGGY]  }  }    [CLASS]  CSVPrinter  [METHOD]  printSep  [RETURN_TYPE]  void    [VARIABLES]  CSVFormat  format  boolean  newLine  Appendable  out    	[P7_Replace_Invocation]
[PATCH]  out.append  (  format.getDelimiter  (  )  )  ;  }	[BUG]  [BUGGY]  [CE]  illegal  start  of  expression  [CONTEXT]  void  printSep()  throws  IOException  {  if  (newLine)  {  newLine  =  false;  }  else  {  [BUGGY]  [BUGGY]        [CLASS]  CSVPrinter  [METHOD]  printSep  [RETURN_TYPE]  void    [VARIABLES]  CSVFormat  format  boolean  newLine  Appendable  out    	[P14_Delete_Statement]
[PATCH]  out.append  (  format.getDelimiter  (  )  )  ;	[BUG]  [BUGGY]  out.append(  value,  start,  end)  ;out.append(  format.getDelimiter(  )  )  ;[CE]  cannot  find  symbol  value  [CONTEXT]  void  printSep()  throws  IOException  {  if  (newLine)  {  newLine  =  false;  }  else  {  [BUGGY]  out.append(  value,  start,  end)  ;out.append(  format.getDelimiter(  )  )  ;  [BUGGY]  }  }    [CLASS]  CSVPrinter  [METHOD]  printSep  [RETURN_TYPE]  void    [VARIABLES]  CSVFormat  format  boolean  newLine  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  out.append  (  format.getDelimiter  (  )  )  ;	[BUG]  [BUGGY]  out.append(  format.getCommentStart(  )  )  ;out.append(  format.getDelimiter(  )  )  ;[FE]  expected:<a[,b],c>  but  was:<a[  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]  void  printSep()  throws  IOException  {  if  (newLine)  {  newLine  =  false;  }  else  {  [BUGGY]  out.append(  format.getCommentStart(  )  )  ;out.append(  format.getDelimiter(  )  )  ;  [BUGGY]  }  }    [CLASS]  CSVPrinter  [METHOD]  printSep  [RETURN_TYPE]  void    [VARIABLES]  CSVFormat  format  boolean  newLine  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  out.append  (  format.getDelimiter  (  )  )  ;	[BUG]  [BUGGY]  char  delim  =  format.getDelimiter(  )  ;out.append(  format.getDelimiter(  )  )  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  void  printSep()  throws  IOException  {  if  (newLine)  {  newLine  =  false;  }  else  {  [BUGGY]  char  delim  =  format.getDelimiter(  )  ;out.append(  format.getDelimiter(  )  )  ;  [BUGGY]  }  }    [CLASS]  CSVPrinter  [METHOD]  printSep  [RETURN_TYPE]  void    [VARIABLES]  CSVFormat  format  boolean  newLine  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  out.append  (  format.getDelimiter  (  )  )  ;	[BUG]  [BUGGY]  out.append(  value,  start,  pos)  ;out.append(  format.getDelimiter(  )  )  ;[CE]  cannot  find  symbol  value  [CONTEXT]  void  printSep()  throws  IOException  {  if  (newLine)  {  newLine  =  false;  }  else  {  [BUGGY]  out.append(  value,  start,  pos)  ;out.append(  format.getDelimiter(  )  )  ;  [BUGGY]  }  }    [CLASS]  CSVPrinter  [METHOD]  printSep  [RETURN_TYPE]  void    [VARIABLES]  CSVFormat  format  boolean  newLine  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  out.append  (  format.getDelimiter  (  )  )  ;	[BUG]  [BUGGY]  out.append(  format.getLineSeparator(  )  )  ;out.append(  format.getDelimiter(  )  )  ;[FE]  expected:<a[,b],c>  but  was:<a[  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]  void  printSep()  throws  IOException  {  if  (newLine)  {  newLine  =  false;  }  else  {  [BUGGY]  out.append(  format.getLineSeparator(  )  )  ;out.append(  format.getDelimiter(  )  )  ;  [BUGGY]  }  }    [CLASS]  CSVPrinter  [METHOD]  printSep  [RETURN_TYPE]  void    [VARIABLES]  CSVFormat  format  boolean  newLine  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  newLine  =  false;	[BUG]  [BUGGY]  newLine  =  true;[FE]  expected:<a[,b,]c>  but  was:<a[b]c>  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]  void  printSep()  throws  IOException  {  if  (newLine)  {  [BUGGY]  newLine  =  true;  [BUGGY]  }  else  {  out.append(format.getDelimiter());  }  }    [CLASS]  CSVPrinter  [METHOD]  printSep  [RETURN_TYPE]  void    [VARIABLES]  CSVFormat  format  boolean  newLine  Appendable  out    	[P3_Replace_Literal]
[PATCH]  newLine  =  false;	[BUG]  [BUGGY]  newLine  =  true;newLine  =  false;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  void  printSep()  throws  IOException  {  if  (newLine)  {  [BUGGY]  newLine  =  true;newLine  =  false;  [BUGGY]  }  else  {  out.append(format.getDelimiter());  }  }    [CLASS]  CSVPrinter  [METHOD]  printSep  [RETURN_TYPE]  void    [VARIABLES]  CSVFormat  format  boolean  newLine  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  int  start  =  offset;	[BUG]  [BUGGY]  long  start  =  offset;[CE]  no  suitable  method  found  for  append(CharSequence,long,int)  [CONTEXT]  }  else  {  printSep();  out.append(value,  offset,  offset  +  len);  }  }  void  printSep()  throws  IOException  {  if  (newLine)  {  newLine  =  false;  }  else  {  out.append(format.getDelimiter());  }  }  void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  [BUGGY]  long  start  =  offset;  [BUGGY]  int  pos  =  offset;  int  end  =  offset  +  len;  printSep();  char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();  while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {    if  (pos  >  start)  {  out.append(value,  start,  pos);  }    [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P1_Replace_Type]
[PATCH]  int  start  =  offset;	[BUG]  [BUGGY]  int  start  =  pos;[CE]  cannot  find  symbol  pos  [CONTEXT]  }  else  {  printSep();  out.append(value,  offset,  offset  +  len);  }  }  void  printSep()  throws  IOException  {  if  (newLine)  {  newLine  =  false;  }  else  {  out.append(format.getDelimiter());  }  }  void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  [BUGGY]  int  start  =  pos;  [BUGGY]  int  pos  =  offset;  int  end  =  offset  +  len;  printSep();  char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();  while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {    if  (pos  >  start)  {  out.append(value,  start,  pos);  }    [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P5_Replace_Variable]
[PATCH]  int  start  =  offset;	[BUG]  [BUGGY]  int  pos  =  offset;int  start  =  offset;[CE]  variable  pos  is  already  defined  in  method  printAndEscape(CharSequence,int,int)  [CONTEXT]  }  else  {  printSep();  out.append(value,  offset,  offset  +  len);  }  }  void  printSep()  throws  IOException  {  if  (newLine)  {  newLine  =  false;  }  else  {  out.append(format.getDelimiter());  }  }  void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  [BUGGY]  int  pos  =  offset;int  start  =  offset;  [BUGGY]  int  pos  =  offset;  int  end  =  offset  +  len;  printSep();  char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();  while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {    if  (pos  >  start)  {  out.append(value,  start,  pos);  }    [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  int  start  =  offset;	[BUG]  [BUGGY]  int  end  =  offset  +  len;int  start  =  offset;[CE]  variable  end  is  already  defined  in  method  printAndEscape(CharSequence,int,int)  [CONTEXT]  }  else  {  printSep();  out.append(value,  offset,  offset  +  len);  }  }  void  printSep()  throws  IOException  {  if  (newLine)  {  newLine  =  false;  }  else  {  out.append(format.getDelimiter());  }  }  void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  [BUGGY]  int  end  =  offset  +  len;int  start  =  offset;  [BUGGY]  int  pos  =  offset;  int  end  =  offset  +  len;  printSep();  char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();  while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {    if  (pos  >  start)  {  out.append(value,  start,  pos);  }    [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  int  pos  =  offset;	[BUG]  [BUGGY]  short  pos  =  offset;[CE]  possible  loss  of  precision  [CONTEXT]  printSep();  out.append(value,  offset,  offset  +  len);  }  }  void  printSep()  throws  IOException  {  if  (newLine)  {  newLine  =  false;  }  else  {  out.append(format.getDelimiter());  }  }  void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  [BUGGY]  short  pos  =  offset;  [BUGGY]  int  end  =  offset  +  len;  printSep();  char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();  while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {    if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {    [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P1_Replace_Type]
[PATCH]  int  pos  =  offset;	[BUG]  [BUGGY]  int  pos  =  start;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  printSep();  out.append(value,  offset,  offset  +  len);  }  }  void  printSep()  throws  IOException  {  if  (newLine)  {  newLine  =  false;  }  else  {  out.append(format.getDelimiter());  }  }  void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  [BUGGY]  int  pos  =  start;  [BUGGY]  int  end  =  offset  +  len;  printSep();  char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();  while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {    if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {    [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P5_Replace_Variable]
[PATCH]  int  pos  =  offset;	[BUG]  [BUGGY]  int  start  =  offset;int  pos  =  offset;[CE]  variable  start  is  already  defined  in  method  printAndEscape(CharSequence,int,int)  [CONTEXT]  printSep();  out.append(value,  offset,  offset  +  len);  }  }  void  printSep()  throws  IOException  {  if  (newLine)  {  newLine  =  false;  }  else  {  out.append(format.getDelimiter());  }  }  void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  [BUGGY]  int  start  =  offset;int  pos  =  offset;  [BUGGY]  int  end  =  offset  +  len;  printSep();  char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();  while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {    if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {    [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  int  pos  =  offset;	[BUG]  [BUGGY]  int  end  =  offset  +  len;int  pos  =  offset;[CE]  variable  end  is  already  defined  in  method  printAndEscape(CharSequence,int,int)  [CONTEXT]  printSep();  out.append(value,  offset,  offset  +  len);  }  }  void  printSep()  throws  IOException  {  if  (newLine)  {  newLine  =  false;  }  else  {  out.append(format.getDelimiter());  }  }  void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  [BUGGY]  int  end  =  offset  +  len;int  pos  =  offset;  [BUGGY]  int  end  =  offset  +  len;  printSep();  char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();  while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {    if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {    [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  int  end  =  offset  +  len;	[BUG]  [BUGGY]  short  end  =  offset  +  len;[CE]  possible  loss  of  precision  [CONTEXT]  out.append(value,  offset,  offset  +  len);  }  }  void  printSep()  throws  IOException  {  if  (newLine)  {  newLine  =  false;  }  else  {  out.append(format.getDelimiter());  }  }  void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  [BUGGY]  short  end  =  offset  +  len;  [BUGGY]    printSep();  char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();  while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {    if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';    [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P1_Replace_Type]
[PATCH]  int  end  =  offset  +  len;	[BUG]  [BUGGY]  int  end  =  offset  +  start;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  out.append(value,  offset,  offset  +  len);  }  }  void  printSep()  throws  IOException  {  if  (newLine)  {  newLine  =  false;  }  else  {  out.append(format.getDelimiter());  }  }  void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  [BUGGY]  int  end  =  offset  +  start;  [BUGGY]    printSep();  char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();  while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {    if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';    [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P5_Replace_Variable]
[PATCH]  int  end  =  offset  +  len;	[BUG]  [BUGGY]  int  end  =  len  +  offset;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  out.append(value,  offset,  offset  +  len);  }  }  void  printSep()  throws  IOException  {  if  (newLine)  {  newLine  =  false;  }  else  {  out.append(format.getDelimiter());  }  }  void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  [BUGGY]  int  end  =  len  +  offset;  [BUGGY]    printSep();  char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();  while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {    if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';    [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P5_Replace_Variable]
[PATCH]  int  end  =  offset  +  len;	[BUG]  [BUGGY]  int  end  =  start  +  len;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  out.append(value,  offset,  offset  +  len);  }  }  void  printSep()  throws  IOException  {  if  (newLine)  {  newLine  =  false;  }  else  {  out.append(format.getDelimiter());  }  }  void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  [BUGGY]  int  end  =  start  +  len;  [BUGGY]    printSep();  char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();  while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {    if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';    [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P8_Replace_Mix]
[PATCH]  int  end  =  offset  +  len;	[BUG]  [BUGGY]  int  pos  =  offset;int  end  =  offset  +  len;[CE]  variable  pos  is  already  defined  in  method  printAndEscape(CharSequence,int,int)  [CONTEXT]  out.append(value,  offset,  offset  +  len);  }  }  void  printSep()  throws  IOException  {  if  (newLine)  {  newLine  =  false;  }  else  {  out.append(format.getDelimiter());  }  }  void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  [BUGGY]  int  pos  =  offset;int  end  =  offset  +  len;  [BUGGY]    printSep();  char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();  while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {    if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';    [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  int  end  =  offset  +  len;	[BUG]  [BUGGY]  int  start  =  offset;int  end  =  offset  +  len;[CE]  variable  start  is  already  defined  in  method  printAndEscape(CharSequence,int,int)  [CONTEXT]  out.append(value,  offset,  offset  +  len);  }  }  void  printSep()  throws  IOException  {  if  (newLine)  {  newLine  =  false;  }  else  {  out.append(format.getDelimiter());  }  }  void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  [BUGGY]  int  start  =  offset;int  end  =  offset  +  len;  [BUGGY]    printSep();  char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();  while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {    if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';    [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  printSep  (  )  ;	[BUG]  [BUGGY]  println(  )  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  }  void  printSep()  throws  IOException  {  if  (newLine)  {  newLine  =  false;  }  else  {  out.append(format.getDelimiter());  }  }  void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;  [BUGGY]  println(  )  ;  [BUGGY]    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();  while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {    if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';    [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P7_Replace_Invocation]
[PATCH]  printSep  (  )  ;	[BUG]  [BUGGY]  [FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  }  void  printSep()  throws  IOException  {  if  (newLine)  {  newLine  =  false;  }  else  {  out.append(format.getDelimiter());  }  }  void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;  [BUGGY]  [BUGGY]    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();  while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {    if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {    [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P14_Delete_Statement]
[PATCH]  printSep  (  )  ;	[BUG]  [BUGGY]  println(  )  ;printSep(  )  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  }  void  printSep()  throws  IOException  {  if  (newLine)  {  newLine  =  false;  }  else  {  out.append(format.getDelimiter());  }  }  void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;  [BUGGY]  println(  )  ;printSep(  )  ;  [BUGGY]    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();  while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {    if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';    [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  printSep  (  )  ;	[BUG]  [BUGGY]  print(  value)  ;printSep(  )  ;[CE]  no  suitable  method  found  for  print(CharSequence)  [CONTEXT]  }  void  printSep()  throws  IOException  {  if  (newLine)  {  newLine  =  false;  }  else  {  out.append(format.getDelimiter());  }  }  void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;  [BUGGY]  print(  value)  ;printSep(  )  ;  [BUGGY]    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();  while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {    if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';    [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  char  delim  =  format.getDelimiter  (  )  ;	[BUG]  [BUGGY]  int  delim  =  format.getDelimiter(  )  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  void  printSep()  throws  IOException  {  if  (newLine)  {  newLine  =  false;  }  else  {  out.append(format.getDelimiter());  }  }  void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;  printSep();  [BUGGY]  int  delim  =  format.getDelimiter(  )  ;  [BUGGY]  char  escape  =  format.getEscape();  while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {    if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }      [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P1_Replace_Type]
[PATCH]  char  delim  =  format.getDelimiter  (  )  ;	[BUG]  [BUGGY]  char  delim  =  format.getEscape(  )  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  void  printSep()  throws  IOException  {  if  (newLine)  {  newLine  =  false;  }  else  {  out.append(format.getDelimiter());  }  }  void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;  printSep();  [BUGGY]  char  delim  =  format.getEscape(  )  ;  [BUGGY]  char  escape  =  format.getEscape();  while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {    if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }      [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P7_Replace_Invocation]
[PATCH]  char  delim  =  format.getDelimiter  (  )  ;	[BUG]  [BUGGY]  char  escape  =  format.getEscape(  )  ;char  delim  =  format.getDelimiter(  )  ;[CE]  variable  escape  is  already  defined  in  method  printAndEscape(CharSequence,int,int)  [CONTEXT]  void  printSep()  throws  IOException  {  if  (newLine)  {  newLine  =  false;  }  else  {  out.append(format.getDelimiter());  }  }  void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;  printSep();  [BUGGY]  char  escape  =  format.getEscape(  )  ;char  delim  =  format.getDelimiter(  )  ;  [BUGGY]  char  escape  =  format.getEscape();  while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {    if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }      [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  char  delim  =  format.getDelimiter  (  )  ;	[BUG]  [BUGGY]  char  encapsulator  =  format.getEncapsulator(  )  ;char  delim  =  format.getDelimiter(  )  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  void  printSep()  throws  IOException  {  if  (newLine)  {  newLine  =  false;  }  else  {  out.append(format.getDelimiter());  }  }  void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;  printSep();  [BUGGY]  char  encapsulator  =  format.getEncapsulator(  )  ;char  delim  =  format.getDelimiter(  )  ;  [BUGGY]  char  escape  =  format.getEscape();  while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {    if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }      [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  char  delim  =  format.getDelimiter  (  )  ;	[BUG]  [BUGGY]  this.format.validate(  )  ;char  delim  =  format.getDelimiter(  )  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  void  printSep()  throws  IOException  {  if  (newLine)  {  newLine  =  false;  }  else  {  out.append(format.getDelimiter());  }  }  void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;  printSep();  [BUGGY]  this.format.validate(  )  ;char  delim  =  format.getDelimiter(  )  ;  [BUGGY]  char  escape  =  format.getEscape();  while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {    if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }      [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  char  delim  =  format.getDelimiter  (  )  ;	[BUG]  [BUGGY]  out.append(  format.getDelimiter(  )  )  ;char  delim  =  format.getDelimiter(  )  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  void  printSep()  throws  IOException  {  if  (newLine)  {  newLine  =  false;  }  else  {  out.append(format.getDelimiter());  }  }  void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;  printSep();  [BUGGY]  out.append(  format.getDelimiter(  )  )  ;char  delim  =  format.getDelimiter(  )  ;  [BUGGY]  char  escape  =  format.getEscape();  while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {    if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }      [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  char  escape  =  format.getEscape  (  )  ;	[BUG]  [BUGGY]  int  escape  =  format.getEscape(  )  ;[CE]  no  suitable  method  found  for  append(int)  [CONTEXT]  if  (newLine)  {  newLine  =  false;  }  else  {  out.append(format.getDelimiter());  }  }  void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;  printSep();  char  delim  =  format.getDelimiter();  [BUGGY]  int  escape  =  format.getEscape(  )  ;  [BUGGY]    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {    if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }  out.append(escape);    [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P1_Replace_Type]
[PATCH]  char  escape  =  format.getEscape  (  )  ;	[BUG]  [BUGGY]  char  escape  =  format.isEscaping(  )  ;[CE]  incompatible  types  [CONTEXT]  if  (newLine)  {  newLine  =  false;  }  else  {  out.append(format.getDelimiter());  }  }  void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;  printSep();  char  delim  =  format.getDelimiter();  [BUGGY]  char  escape  =  format.isEscaping(  )  ;  [BUGGY]    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {    if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }  out.append(escape);    [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P7_Replace_Invocation]
[PATCH]  char  escape  =  format.getEscape  (  )  ;	[BUG]  [BUGGY]  char  delim  =  format.getDelimiter(  )  ;char  escape  =  format.getEscape(  )  ;[CE]  variable  delim  is  already  defined  in  method  printAndEscape(CharSequence,int,int)  [CONTEXT]  if  (newLine)  {  newLine  =  false;  }  else  {  out.append(format.getDelimiter());  }  }  void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;  printSep();  char  delim  =  format.getDelimiter();  [BUGGY]  char  delim  =  format.getDelimiter(  )  ;char  escape  =  format.getEscape(  )  ;  [BUGGY]    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {    if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }  out.append(escape);    [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  char  escape  =  format.getEscape  (  )  ;	[BUG]  [BUGGY]  char  c  =  comment.charAt(  i)  ;char  escape  =  format.getEscape(  )  ;[CE]  cannot  find  symbol  i  [CONTEXT]  if  (newLine)  {  newLine  =  false;  }  else  {  out.append(format.getDelimiter());  }  }  void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;  printSep();  char  delim  =  format.getDelimiter();  [BUGGY]  char  c  =  comment.charAt(  i)  ;char  escape  =  format.getEscape(  )  ;  [BUGGY]    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {    if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }  out.append(escape);    [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  char  escape  =  format.getEscape  (  )  ;	[BUG]  [BUGGY]  char  encapsulator  =  format.getEncapsulator(  )  ;char  escape  =  format.getEscape(  )  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  if  (newLine)  {  newLine  =  false;  }  else  {  out.append(format.getDelimiter());  }  }  void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;  printSep();  char  delim  =  format.getDelimiter();  [BUGGY]  char  encapsulator  =  format.getEncapsulator(  )  ;char  escape  =  format.getEscape(  )  ;  [BUGGY]    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {    if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }  out.append(escape);    [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  char  escape  =  format.getEscape  (  )  ;	[BUG]  [BUGGY]  char  escape  =  format.getEncapsulator(  )  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  if  (newLine)  {  newLine  =  false;  }  else  {  out.append(format.getDelimiter());  }  }  void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;  printSep();  char  delim  =  format.getDelimiter();  [BUGGY]  char  escape  =  format.getEncapsulator(  )  ;  [BUGGY]    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {    if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }  out.append(escape);    [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P8_Replace_Mix]
[PATCH]  while  (  pos  <  end  )  {	[BUG]  [BUGGY]  while  (  pos  <=  end)  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  }  else  {  out.append(format.getDelimiter());  }  }  void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;  printSep();  char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();  [BUGGY]  while  (  pos  <=  end)  {  [BUGGY]  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {    if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }  out.append(escape);  out.append(c);      [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P2_Replace_Operator]
[PATCH]  while  (  pos  <  end  )  {	[BUG]  [BUGGY]  while  (  start  <  end)  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  }  else  {  out.append(format.getDelimiter());  }  }  void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;  printSep();  char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();  [BUGGY]  while  (  start  <  end)  {  [BUGGY]  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {    if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }  out.append(escape);  out.append(c);      [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P5_Replace_Variable]
[PATCH]  while  (  pos  <  end  )  {	[BUG]  [BUGGY]  while  (  pos  <  start)  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  }  else  {  out.append(format.getDelimiter());  }  }  void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;  printSep();  char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();  [BUGGY]  while  (  pos  <  start)  {  [BUGGY]  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {    if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }  out.append(escape);  out.append(c);      [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P5_Replace_Variable]
[PATCH]  while  (  pos  <  end  )  {	[BUG]  [BUGGY]  while  (  end  <  pos)  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  }  else  {  out.append(format.getDelimiter());  }  }  void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;  printSep();  char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();  [BUGGY]  while  (  end  <  pos)  {  [BUGGY]  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {    if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }  out.append(escape);  out.append(c);      [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P5_Replace_Variable]
[PATCH]  while  (  pos  <  end  )  {	[BUG]  [BUGGY]  while  (  offset  <  end)  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  }  else  {  out.append(format.getDelimiter());  }  }  void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;  printSep();  char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();  [BUGGY]  while  (  offset  <  end)  {  [BUGGY]  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {    if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }  out.append(escape);  out.append(c);      [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P8_Replace_Mix]
[PATCH]  if  (  c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape  )  {	[BUG]  [BUGGY]  if  (  c  ==  '\r'  &&  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  }  }  void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;  printSep();  char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();  while  (pos  <  end)  {  char  c  =  value.charAt(pos);  [BUGGY]  if  (  c  ==  '\r'  &&  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {  [BUGGY]    if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }  out.append(escape);  out.append(c);  start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }    [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P2_Replace_Operator]
[PATCH]  if  (  c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape  )  {	[BUG]  [BUGGY]  if  (  c  !=  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  }  }  void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;  printSep();  char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();  while  (pos  <  end)  {  char  c  =  value.charAt(pos);  [BUGGY]  if  (  c  !=  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {  [BUGGY]    if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }  out.append(escape);  out.append(c);  start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }    [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P2_Replace_Operator]
[PATCH]  if  (  c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape  )  {	[BUG]  [BUGGY]  if  (  c  ==  '\r'  ||  c  >=  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  }  }  void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;  printSep();  char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();  while  (pos  <  end)  {  char  c  =  value.charAt(pos);  [BUGGY]  if  (  c  ==  '\r'  ||  c  >=  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {  [BUGGY]    if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }  out.append(escape);  out.append(c);  start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }    [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P2_Replace_Operator]
[PATCH]  if  (  c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape  )  {	[BUG]  [BUGGY]  if  (  c  ==  '\r'  ||  c  ==  '\n'  ||  c  <=  delim  ||  c  ==  escape)  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  }  }  void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;  printSep();  char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();  while  (pos  <  end)  {  char  c  =  value.charAt(pos);  [BUGGY]  if  (  c  ==  '\r'  ||  c  ==  '\n'  ||  c  <=  delim  ||  c  ==  escape)  {  [BUGGY]    if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }  out.append(escape);  out.append(c);  start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }    [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P2_Replace_Operator]
[PATCH]  if  (  c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape  )  {	[BUG]  [BUGGY]  if  (  c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  >=  escape)  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  }  }  void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;  printSep();  char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();  while  (pos  <  end)  {  char  c  =  value.charAt(pos);  [BUGGY]  if  (  c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  >=  escape)  {  [BUGGY]    if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }  out.append(escape);  out.append(c);  start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }    [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P2_Replace_Operator]
[PATCH]  if  (  c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape  )  {	[BUG]  [BUGGY]  if  (  c  ==  '\r'  ||  c  <=  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  }  }  void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;  printSep();  char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();  while  (pos  <  end)  {  char  c  =  value.charAt(pos);  [BUGGY]  if  (  c  ==  '\r'  ||  c  <=  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {  [BUGGY]    if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }  out.append(escape);  out.append(c);  start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }    [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P2_Replace_Operator]
[PATCH]  if  (  c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape  )  {	[BUG]  [BUGGY]  if  (  escape  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  }  }  void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;  printSep();  char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();  while  (pos  <  end)  {  char  c  =  value.charAt(pos);  [BUGGY]  if  (  escape  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {  [BUGGY]    if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }  out.append(escape);  out.append(c);  start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }    [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P5_Replace_Variable]
[PATCH]  if  (  c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape  )  {	[BUG]  [BUGGY]  if  (  c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  escape  ||  c  ==  escape)  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  }  }  void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;  printSep();  char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();  while  (pos  <  end)  {  char  c  =  value.charAt(pos);  [BUGGY]  if  (  c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  escape  ||  c  ==  escape)  {  [BUGGY]    if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }  out.append(escape);  out.append(c);  start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }    [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P5_Replace_Variable]
[PATCH]  if  (  c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape  )  {	[BUG]  [BUGGY]  if  (  c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  c)  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  }  }  void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;  printSep();  char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();  while  (pos  <  end)  {  char  c  =  value.charAt(pos);  [BUGGY]  if  (  c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  c)  {  [BUGGY]    if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }  out.append(escape);  out.append(c);  start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }    [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P5_Replace_Variable]
[PATCH]  if  (  c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape  )  {	[BUG]  [BUGGY]  if  (  delim  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  c  ||  c  ==  escape)  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  }  }  void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;  printSep();  char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();  while  (pos  <  end)  {  char  c  =  value.charAt(pos);  [BUGGY]  if  (  delim  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  c  ||  c  ==  escape)  {  [BUGGY]    if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }  out.append(escape);  out.append(c);  start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }    [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P5_Replace_Variable]
[PATCH]  if  (  c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape  )  {	[BUG]  [BUGGY]  if  (  escape  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  c)  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  }  }  void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;  printSep();  char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();  while  (pos  <  end)  {  char  c  =  value.charAt(pos);  [BUGGY]  if  (  escape  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  c)  {  [BUGGY]    if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }  out.append(escape);  out.append(c);  start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }    [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P5_Replace_Variable]
[PATCH]  if  (  c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape  )  {	[BUG]  [BUGGY]  if  (  c  ==  '\r')  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  }  }  void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;  printSep();  char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();  while  (pos  <  end)  {  char  c  =  value.charAt(pos);  [BUGGY]  if  (  c  ==  '\r')  {  [BUGGY]    if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }  out.append(escape);  out.append(c);  start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }    [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P6_Replace_Expression]
[PATCH]  if  (  c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape  )  {	[BUG]  [BUGGY]  if  (  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  }  }  void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;  printSep();  char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();  while  (pos  <  end)  {  char  c  =  value.charAt(pos);  [BUGGY]  if  (  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {  [BUGGY]    if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }  out.append(escape);  out.append(c);  start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }    [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P6_Replace_Expression]
[PATCH]  if  (  c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape  )  {	[BUG]  [BUGGY]  if  (((c  ==  '\r')  ||(c  ==  '\n')  ||  c  ==  delim))  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  }  }  void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;  printSep();  char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();  while  (pos  <  end)  {  char  c  =  value.charAt(pos);  [BUGGY]  if  (((c  ==  '\r')  ||(c  ==  '\n')  ||  c  ==  delim))  {  [BUGGY]    if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }  out.append(escape);  out.append(c);  start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }    [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P6_Replace_Expression]
[PATCH]  if  (  c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape  )  {	[BUG]  [BUGGY]  if  ((c  ==  '\r'  ||  c  ==  '\n'))  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  }  }  void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;  printSep();  char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();  while  (pos  <  end)  {  char  c  =  value.charAt(pos);  [BUGGY]  if  ((c  ==  '\r'  ||  c  ==  '\n'))  {  [BUGGY]    if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }  out.append(escape);  out.append(c);  start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }    [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P6_Replace_Expression]
[PATCH]  if  (  c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape  )  {	[BUG]  [BUGGY]  if  (  c  ==  '\n')  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  }  }  void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;  printSep();  char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();  while  (pos  <  end)  {  char  c  =  value.charAt(pos);  [BUGGY]  if  (  c  ==  '\n')  {  [BUGGY]    if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }  out.append(escape);  out.append(c);  start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }    [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P6_Replace_Expression]
[PATCH]  if  (  c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape  )  {	[BUG]  [BUGGY]  if  (  c  ==  delim)  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  }  }  void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;  printSep();  char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();  while  (pos  <  end)  {  char  c  =  value.charAt(pos);  [BUGGY]  if  (  c  ==  delim)  {  [BUGGY]    if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }  out.append(escape);  out.append(c);  start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }    [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P6_Replace_Expression]
[PATCH]  if  (  c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape  )  {	[BUG]  [BUGGY]  if  (  c  ==  escape)  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  }  }  void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;  printSep();  char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();  while  (pos  <  end)  {  char  c  =  value.charAt(pos);  [BUGGY]  if  (  c  ==  escape)  {  [BUGGY]    if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }  out.append(escape);  out.append(c);  start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }    [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P6_Replace_Expression]
[PATCH]  if  (  c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape  )  {	[BUG]  [BUGGY]  if  (  pos  >  start)  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  }  }  void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;  printSep();  char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();  while  (pos  <  end)  {  char  c  =  value.charAt(pos);  [BUGGY]  if  (  pos  >  start)  {  [BUGGY]    if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }  out.append(escape);  out.append(c);  start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }    [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P6_Replace_Expression]
[PATCH]  if  (  c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape  )  {	[BUG]  [BUGGY]  if  (  pos  +  1)  {[CE]  incompatible  types  [CONTEXT]  }  }  void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;  printSep();  char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();  while  (pos  <  end)  {  char  c  =  value.charAt(pos);  [BUGGY]  if  (  pos  +  1)  {  [BUGGY]    if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }  out.append(escape);  out.append(c);  start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }    [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P6_Replace_Expression]
[PATCH]  if  (  c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape  )  {	[BUG]  [BUGGY]  if  (  c  ==  '\n'  ||  c  ==  escape  ||  c  ==  escape)  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  }  }  void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;  printSep();  char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();  while  (pos  <  end)  {  char  c  =  value.charAt(pos);  [BUGGY]  if  (  c  ==  '\n'  ||  c  ==  escape  ||  c  ==  escape)  {  [BUGGY]    if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }  out.append(escape);  out.append(c);  start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }    [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P8_Replace_Mix]
[PATCH]  if  (  c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape  )  {	[BUG]  [BUGGY]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {[CE]  cannot  find  symbol  encapsulator  [CONTEXT]  }  }  void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;  printSep();  char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();  while  (pos  <  end)  {  char  c  =  value.charAt(pos);  [BUGGY]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  [BUGGY]    if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }  out.append(escape);  out.append(c);  start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }    [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P9_Replace_Statement]
[PATCH]  if  (  c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape  )  {  if  (  pos  >  start  )  {  out.append  (  value,  start,  pos  )  ;  }	[BUG]  [BUGGY]  if(pos  >  start)  {    out.append(value,  start,  pos);};  if(c  ==  '\n')  {    c  =  'n';}else    if(c  ==  '\r')  {        c  =  'r';    };  out.append(escape);  out.append(c);  start  =  pos  +  1;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  }  }  void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;  printSep();  char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();  while  (pos  <  end)  {  char  c  =  value.charAt(pos);  [BUGGY]  if(pos  >  start)  {    out.append(value,  start,  pos);};  if(c  ==  '\n')  {    c  =  'n';}else    if(c  ==  '\r')  {        c  =  'r';    };  out.append(escape);  out.append(c);  start  =  pos  +  1;  [BUGGY]    if  (pos  >  start)  {out.append(value,  start,  pos);};  if  (c  ==  '\n')  {c  =  'n';}elseif  (c  ==  '\r')  {c  =  'r';};  out.append(escape);  out.append(c);  start  =  pos  +  1;    if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }  out.append(escape);  out.append(c);  start  =  pos  +  1;  //  start  on  the  current  char  after  this  one    [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P15_Unwrap_Block]
[PATCH]  if  (  c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape  )  {  if  (  pos  >  start  )  {  out.append  (  value,  start,  pos  )  ;  }	[BUG]  [BUGGY]  [FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  }  }  void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;  printSep();  char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();  while  (pos  <  end)  {  char  c  =  value.charAt(pos);  [BUGGY]  [BUGGY]        if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }  out.append(escape);  out.append(c);  start  =  pos  +  1;  //  start  on  the  current  char  after  this  one    [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P16_Remove_Block]
[PATCH]  if  (  pos  >  start  )  {	[BUG]  [BUGGY]  if  (  pos  >=  start)  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;  printSep();  char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();  while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {    [BUGGY]  if  (  pos  >=  start)  {  [BUGGY]  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }  out.append(escape);  out.append(c);  start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }  pos++;    [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P2_Replace_Operator]
[PATCH]  if  (  pos  >  start  )  {	[BUG]  [BUGGY]  if  (  offset  >  start)  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;  printSep();  char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();  while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {    [BUGGY]  if  (  offset  >  start)  {  [BUGGY]  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }  out.append(escape);  out.append(c);  start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }  pos++;    [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P5_Replace_Variable]
[PATCH]  if  (  pos  >  start  )  {	[BUG]  [BUGGY]  if  (  pos  >  pos)  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;  printSep();  char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();  while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {    [BUGGY]  if  (  pos  >  pos)  {  [BUGGY]  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }  out.append(escape);  out.append(c);  start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }  pos++;    [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P5_Replace_Variable]
[PATCH]  if  (  pos  >  start  )  {	[BUG]  [BUGGY]  if  (  start  >  pos)  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;  printSep();  char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();  while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {    [BUGGY]  if  (  start  >  pos)  {  [BUGGY]  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }  out.append(escape);  out.append(c);  start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }  pos++;    [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P5_Replace_Variable]
[PATCH]  if  (  pos  >  start  )  {  out.append  (  value,  start,  pos  )  ;  }	[BUG]  [BUGGY]  out.append(value,  start,  pos);[CE]  illegal  start  of  expression  [CONTEXT]  void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;  printSep();  char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();  while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {    [BUGGY]  out.append(value,  start,  pos);  [BUGGY]    out.append(value,  start,  pos);  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }  out.append(escape);  out.append(c);  start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }      [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P15_Unwrap_Block]
[PATCH]  if  (  pos  >  start  )  {  out.append  (  value,  start,  pos  )  ;  }	[BUG]  [BUGGY]  [CE]  illegal  start  of  expression  [CONTEXT]  void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;  printSep();  char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();  while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {    [BUGGY]  [BUGGY]      if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }  out.append(escape);  out.append(c);  start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }      [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P16_Remove_Block]
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  c  ==  encapsulator)  {      out.append(  value,  start,  (  pos  +  1)  )  ;      start  =  pos;  }[CE]  illegal  start  of  type  [CONTEXT]  void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;  printSep();  char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();  while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {    [BUGGY]  if  (  c  ==  encapsulator)  {      out.append(  value,  start,  (  pos  +  1)  )  ;      start  =  pos;  }  [BUGGY]  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }  out.append(escape);  out.append(c);  start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }  pos++;    [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P13_Insert_Block]
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  !quote)  {      out.append(  value,  start,  end)  ;      return  ;  }[CE]  illegal  start  of  type  [CONTEXT]  void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;  printSep();  char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();  while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {    [BUGGY]  if  (  !quote)  {      out.append(  value,  start,  end)  ;      return  ;  }  [BUGGY]  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }  out.append(escape);  out.append(c);  start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }  pos++;    [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P13_Insert_Block]
[PATCH]  out.append  (  value,  start,  pos  )  ;	[BUG]  [BUGGY]  out.append(  value,  offset,  pos)  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;  printSep();  char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();  while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {    if  (pos  >  start)  {  [BUGGY]  out.append(  value,  offset,  pos)  ;  [BUGGY]  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }  out.append(escape);  out.append(c);  start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }  pos++;  }    [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P5_Replace_Variable]
[PATCH]  out.append  (  value,  start,  pos  )  ;	[BUG]  [BUGGY]  out.append(  value,  start,  start)  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;  printSep();  char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();  while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {    if  (pos  >  start)  {  [BUGGY]  out.append(  value,  start,  start)  ;  [BUGGY]  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }  out.append(escape);  out.append(c);  start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }  pos++;  }    [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P5_Replace_Variable]
[PATCH]  out.append  (  value,  start,  pos  )  ;	[BUG]  [BUGGY]  out.append(  start,  pos)  ;[CE]  no  suitable  method  found  for  append(int,int)  [CONTEXT]  void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;  printSep();  char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();  while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {    if  (pos  >  start)  {  [BUGGY]  out.append(  start,  pos)  ;  [BUGGY]  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }  out.append(escape);  out.append(c);  start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }  pos++;  }    [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P5_Replace_Variable]
[PATCH]  out.append  (  value,  start,  pos  )  ;	[BUG]  [BUGGY]  out.append(  value,  pos)  ;[CE]  no  suitable  method  found  for  append(CharSequence,int)  [CONTEXT]  void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;  printSep();  char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();  while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {    if  (pos  >  start)  {  [BUGGY]  out.append(  value,  pos)  ;  [BUGGY]  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }  out.append(escape);  out.append(c);  start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }  pos++;  }    [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P5_Replace_Variable]
[PATCH]  out.append  (  value,  start,  pos  )  ;	[BUG]  [BUGGY]  out.append(  value,  start)  ;[CE]  no  suitable  method  found  for  append(CharSequence,int)  [CONTEXT]  void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;  printSep();  char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();  while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {    if  (pos  >  start)  {  [BUGGY]  out.append(  value,  start)  ;  [BUGGY]  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }  out.append(escape);  out.append(c);  start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }  pos++;  }    [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P5_Replace_Variable]
[PATCH]  out.append  (  value,  start,  pos  )  ;	[BUG]  [BUGGY]  out.append(  pos,  start,  value)  ;[CE]  no  suitable  method  found  for  append(int,int,CharSequence)  [CONTEXT]  void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;  printSep();  char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();  while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {    if  (pos  >  start)  {  [BUGGY]  out.append(  pos,  start,  value)  ;  [BUGGY]  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }  out.append(escape);  out.append(c);  start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }  pos++;  }    [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P5_Replace_Variable]
[PATCH]  out.append  (  value,  start,  pos  )  ;	[BUG]  [BUGGY]  out.append(  value,  pos,  start)  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;  printSep();  char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();  while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {    if  (pos  >  start)  {  [BUGGY]  out.append(  value,  pos,  start)  ;  [BUGGY]  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }  out.append(escape);  out.append(c);  start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }  pos++;  }    [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P5_Replace_Variable]
[PATCH]  out.append  (  value,  start,  pos  )  ;	[BUG]  [BUGGY]  out.append(  value)  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;  printSep();  char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();  while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {    if  (pos  >  start)  {  [BUGGY]  out.append(  value)  ;  [BUGGY]  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }  out.append(escape);  out.append(c);  start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }  pos++;  }    [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P7_Replace_Invocation]
[PATCH]  out.append  (  value,  start,  pos  )  ;	[BUG]  [BUGGY]  out.append(  value,  start,  offset)  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;  printSep();  char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();  while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {    if  (pos  >  start)  {  [BUGGY]  out.append(  value,  start,  offset)  ;  [BUGGY]  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }  out.append(escape);  out.append(c);  start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }  pos++;  }    [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P8_Replace_Mix]
[PATCH]  out.append  (  value,  start,  pos  )  ;	[BUG]  [BUGGY]  [FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;  printSep();  char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();  while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {    if  (pos  >  start)  {  [BUGGY]  [BUGGY]    }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }  out.append(escape);  out.append(c);  start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }  pos++;    [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P14_Delete_Statement]
[PATCH]  out.append  (  value,  start,  pos  )  ;	[BUG]  [BUGGY]  out.append(  value,  start,  end)  ;out.append(  value,  start,  pos)  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;  printSep();  char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();  while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {    if  (pos  >  start)  {  [BUGGY]  out.append(  value,  start,  end)  ;out.append(  value,  start,  pos)  ;  [BUGGY]  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }  out.append(escape);  out.append(c);  start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }  pos++;  }    [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  out.append  (  value,  start,  pos  )  ;	[BUG]  [BUGGY]  print(  value,  true)  ;out.append(  value,  start,  pos)  ;[CE]  no  suitable  method  found  for  print(CharSequence,boolean)  [CONTEXT]  void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;  printSep();  char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();  while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {    if  (pos  >  start)  {  [BUGGY]  print(  value,  true)  ;out.append(  value,  start,  pos)  ;  [BUGGY]  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }  out.append(escape);  out.append(c);  start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }  pos++;  }    [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  out.append  (  value,  start,  pos  )  ;	[BUG]  [BUGGY]  out.append(  format.getCommentStart(  )  )  ;out.append(  value,  start,  pos)  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;  printSep();  char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();  while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {    if  (pos  >  start)  {  [BUGGY]  out.append(  format.getCommentStart(  )  )  ;out.append(  value,  start,  pos)  ;  [BUGGY]  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }  out.append(escape);  out.append(c);  start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }  pos++;  }    [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  out.append  (  value,  start,  pos  )  ;	[BUG]  [BUGGY]  out.append(  value)  ;out.append(  value,  start,  pos)  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;  printSep();  char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();  while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {    if  (pos  >  start)  {  [BUGGY]  out.append(  value)  ;out.append(  value,  start,  pos)  ;  [BUGGY]  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }  out.append(escape);  out.append(c);  start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }  pos++;  }    [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  out.append  (  value,  start,  pos  )  ;	[BUG]  [BUGGY]  out.append(  format.getLineSeparator(  )  )  ;out.append(  value,  start,  pos)  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;  printSep();  char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();  while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {    if  (pos  >  start)  {  [BUGGY]  out.append(  format.getLineSeparator(  )  )  ;out.append(  value,  start,  pos)  ;  [BUGGY]  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }  out.append(escape);  out.append(c);  start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }  pos++;  }    [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  out.append  (  value,  start,  pos  )  ;	[BUG]  [BUGGY]  out.append(  value,  offset,  offset  +  len)  ;out.append(  value,  start,  pos)  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;  printSep();  char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();  while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {    if  (pos  >  start)  {  [BUGGY]  out.append(  value,  offset,  offset  +  len)  ;out.append(  value,  start,  pos)  ;  [BUGGY]  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }  out.append(escape);  out.append(c);  start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }  pos++;  }    [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  out.append  (  value,  start,  pos  )  ;	[BUG]  [BUGGY]  out.append(  encapsulator)  ;out.append(  value,  start,  pos)  ;[CE]  cannot  find  symbol  encapsulator  [CONTEXT]  void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;  printSep();  char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();  while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {    if  (pos  >  start)  {  [BUGGY]  out.append(  encapsulator)  ;out.append(  value,  start,  pos)  ;  [BUGGY]  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }  out.append(escape);  out.append(c);  start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }  pos++;  }    [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  out.append  (  value,  start,  pos  )  ;	[BUG]  [BUGGY]  out.append(  format.getDelimiter(  )  )  ;out.append(  value,  start,  pos)  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;  printSep();  char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();  while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {    if  (pos  >  start)  {  [BUGGY]  out.append(  format.getDelimiter(  )  )  ;out.append(  value,  start,  pos)  ;  [BUGGY]  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }  out.append(escape);  out.append(c);  start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }  pos++;  }    [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  out.append  (  value,  start,  pos  )  ;	[BUG]  [BUGGY]  out.append(  value,  start,  pos  +  1)  ;out.append(  value,  start,  pos)  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;  printSep();  char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();  while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {    if  (pos  >  start)  {  [BUGGY]  out.append(  value,  start,  pos  +  1)  ;out.append(  value,  start,  pos)  ;  [BUGGY]  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }  out.append(escape);  out.append(c);  start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }  pos++;  }    [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  out.append  (  value,  start,  pos  )  ;	[BUG]  [BUGGY]  out.append(  '  ')  ;out.append(  value,  start,  pos)  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;  printSep();  char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();  while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {    if  (pos  >  start)  {  [BUGGY]  out.append(  '  ')  ;out.append(  value,  start,  pos)  ;  [BUGGY]  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }  out.append(escape);  out.append(c);  start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }  pos++;  }    [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  out.append  (  value,  start,  pos  )  ;	[BUG]  [BUGGY]  out.append(  escape)  ;out.append(  value,  start,  pos)  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;  printSep();  char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();  while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {    if  (pos  >  start)  {  [BUGGY]  out.append(  escape)  ;out.append(  value,  start,  pos)  ;  [BUGGY]  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }  out.append(escape);  out.append(c);  start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }  pos++;  }    [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  pos  >  start)  {      out.append(  value,  start,  pos)  ;  }[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;  printSep();  char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();  while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {    if  (pos  >  start)  {  [BUGGY]  if  (  pos  >  start)  {      out.append(  value,  start,  pos)  ;  }  [BUGGY]  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }  out.append(escape);  out.append(c);  start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }  pos++;  }    [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P13_Insert_Block]
[PATCH]  if  (  c  ==  '\n'  )  {	[BUG]  [BUGGY]  if  (  c  >=  '\n')  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  int  pos  =  offset;  int  end  =  offset  +  len;  printSep();  char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();  while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {    if  (pos  >  start)  {  out.append(value,  start,  pos);  }  [BUGGY]  if  (  c  >=  '\n')  {  [BUGGY]  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }  out.append(escape);  out.append(c);  start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }  pos++;  }        [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P2_Replace_Operator]
[PATCH]  if  (  c  ==  '\n'  )  {	[BUG]  [BUGGY]  if  (  c  !=  '\n')  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  int  pos  =  offset;  int  end  =  offset  +  len;  printSep();  char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();  while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {    if  (pos  >  start)  {  out.append(value,  start,  pos);  }  [BUGGY]  if  (  c  !=  '\n')  {  [BUGGY]  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }  out.append(escape);  out.append(c);  start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }  pos++;  }        [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P2_Replace_Operator]
[PATCH]  if  (  c  ==  '\n'  )  {	[BUG]  [BUGGY]  if  (  escape  ==  '\n')  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  int  pos  =  offset;  int  end  =  offset  +  len;  printSep();  char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();  while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {    if  (pos  >  start)  {  out.append(value,  start,  pos);  }  [BUGGY]  if  (  escape  ==  '\n')  {  [BUGGY]  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }  out.append(escape);  out.append(c);  start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }  pos++;  }        [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P5_Replace_Variable]
[PATCH]  if  (  c  ==  '\n'  )  {	[BUG]  [BUGGY]  if  (  c  ==  '\r')  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  int  pos  =  offset;  int  end  =  offset  +  len;  printSep();  char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();  while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {    if  (pos  >  start)  {  out.append(value,  start,  pos);  }  [BUGGY]  if  (  c  ==  '\r')  {  [BUGGY]  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }  out.append(escape);  out.append(c);  start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }  pos++;  }        [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P6_Replace_Expression]
[PATCH]  if  (  c  ==  '\n'  )  {  c  =  'n';  }  else  if  (  c  ==  '\r'  )  {  c  =  'r';  }	[BUG]  [BUGGY]  c  =  'n';[CE]  illegal  start  of  expression  [CONTEXT]  int  pos  =  offset;  int  end  =  offset  +  len;  printSep();  char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();  while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {    if  (pos  >  start)  {  out.append(value,  start,  pos);  }  [BUGGY]  c  =  'n';  [BUGGY]    c  =  'n';      out.append(escape);  out.append(c);  start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }  pos++;  }      [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P15_Unwrap_Block]
[PATCH]  if  (  c  ==  '\n'  )  {  c  =  'n';  }  else  if  (  c  ==  '\r'  )  {  c  =  'r';  }	[BUG]  [BUGGY]  [CE]  illegal  start  of  expression  [CONTEXT]  int  pos  =  offset;  int  end  =  offset  +  len;  printSep();  char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();  while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {    if  (pos  >  start)  {  out.append(value,  start,  pos);  }  [BUGGY]  [BUGGY]        out.append(escape);  out.append(c);  start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }  pos++;  }      [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P16_Remove_Block]
[PATCH]  }  else  if  (  c  ==  '\r'  )  {	[BUG]  [BUGGY]  }  else  if  (  c  <=  '\r')  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  printSep();  char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();  while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {    if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  [BUGGY]  }  else  if  (  c  <=  '\r')  {  [BUGGY]  c  =  'r';  }  out.append(escape);  out.append(c);  start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }  pos++;  }    if  (pos  >  start)  {  out.append(value,  start,  pos);    [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P2_Replace_Operator]
[PATCH]  }  else  if  (  c  ==  '\r'  )  {	[BUG]  [BUGGY]  }  else  if  (  escape  ==  '\r')  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  printSep();  char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();  while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {    if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  [BUGGY]  }  else  if  (  escape  ==  '\r')  {  [BUGGY]  c  =  'r';  }  out.append(escape);  out.append(c);  start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }  pos++;  }    if  (pos  >  start)  {  out.append(value,  start,  pos);    [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P5_Replace_Variable]
[PATCH]  }  else  if  (  c  ==  '\r'  )  {	[BUG]  [BUGGY]  }  else  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  printSep();  char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();  while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {    if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  [BUGGY]  }  else  {  [BUGGY]  c  =  'r';  }  out.append(escape);  out.append(c);  start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }  pos++;  }    if  (pos  >  start)  {  out.append(value,  start,  pos);    [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P6_Replace_Expression]
[PATCH]  }  else  if  (  c  ==  '\r'  )  {  c  =  'r';  }	[BUG]  [BUGGY]  c  =  'r';[CE]  illegal  start  of  expression  [CONTEXT]  printSep();  char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();  while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {    if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  [BUGGY]  c  =  'r';  [BUGGY]    c  =  'r';    out.append(escape);  out.append(c);  start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }  pos++;  }    if  (pos  >  start)  {    [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P15_Unwrap_Block]
[PATCH]  }  else  if  (  c  ==  '\r'  )  {  c  =  'r';  }	[BUG]  [BUGGY]  [CE]  illegal  start  of  expression  [CONTEXT]  printSep();  char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();  while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {    if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  [BUGGY]  [BUGGY]      out.append(escape);  out.append(c);  start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }  pos++;  }    if  (pos  >  start)  {    [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P16_Remove_Block]
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  c  <=  '  ')  {      quote  =  true;  }[CE]  cannot  find  symbol  quote  [CONTEXT]  printSep();  char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();  while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {    if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  [BUGGY]  if  (  c  <=  '  ')  {      quote  =  true;  }  [BUGGY]  c  =  'r';  }  out.append(escape);  out.append(c);  start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }  pos++;  }    if  (pos  >  start)  {  out.append(value,  start,  pos);    [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P13_Insert_Block]
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  value  ==  null)  {      value  =   " ";  }[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  printSep();  char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();  while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {    if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  [BUGGY]  if  (  value  ==  null)  {      value  =   " ";  }  [BUGGY]  c  =  'r';  }  out.append(escape);  out.append(c);  start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }  pos++;  }    if  (pos  >  start)  {  out.append(value,  start,  pos);    [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P13_Insert_Block]
[PATCH]  c  =  'r';	[BUG]  [BUGGY]  c  =  c  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  printSep();  char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();  while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {    if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  [BUGGY]  c  =  c  ;  [BUGGY]  }  out.append(escape);  out.append(c);  start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }  pos++;  }    if  (pos  >  start)  {  out.append(value,  start,  pos);  }    [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P8_Replace_Mix]
[PATCH]  c  =  'r';	[BUG]  [BUGGY]  c  =  'n';c  =  'r';[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  printSep();  char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();  while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {    if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  [BUGGY]  c  =  'n';c  =  'r';  [BUGGY]  }  out.append(escape);  out.append(c);  start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }  pos++;  }    if  (pos  >  start)  {  out.append(value,  start,  pos);  }    [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  c  =  'n';	[BUG]  [BUGGY]  c  =  c  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  int  end  =  offset  +  len;  printSep();  char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();  while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {    if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  [BUGGY]  c  =  c  ;  [BUGGY]  }  else  if  (c  ==  '\r')  {  c  =  'r';  }  out.append(escape);  out.append(c);  start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }  pos++;  }    if  (pos  >  start)  {    [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P8_Replace_Mix]
[PATCH]  c  =  'n';	[BUG]  [BUGGY]  c  =  'r';c  =  'n';[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  int  end  =  offset  +  len;  printSep();  char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();  while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {    if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  [BUGGY]  c  =  'r';c  =  'n';  [BUGGY]  }  else  if  (c  ==  '\r')  {  c  =  'r';  }  out.append(escape);  out.append(c);  start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }  pos++;  }    if  (pos  >  start)  {    [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  }  else  if  (  c  ==  '\r'  )  {	[BUG]  [BUGGY]  }  else  if  (  c  >=  '\r')  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  printSep();  char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();  while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {    if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  [BUGGY]  }  else  if  (  c  >=  '\r')  {  [BUGGY]  c  =  'r';  }  out.append(escape);  out.append(c);  start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }  pos++;  }    if  (pos  >  start)  {  out.append(value,  start,  pos);    [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P2_Replace_Operator]
[PATCH]  start  =  pos  +  1;	[BUG]  [BUGGY]  start  =  pos  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {    if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }  out.append(escape);  out.append(c);  [BUGGY]  start  =  pos  ;  [BUGGY]  }  pos++;  }    if  (pos  >  start)  {  out.append(value,  start,  pos);  }  }  void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;    [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P3_Replace_Literal]
[PATCH]  start  =  pos  +  1;	[BUG]  [BUGGY]  start  =  start  +  1;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {    if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }  out.append(escape);  out.append(c);  [BUGGY]  start  =  start  +  1;  [BUGGY]  }  pos++;  }    if  (pos  >  start)  {  out.append(value,  start,  pos);  }  }  void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;    [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P5_Replace_Variable]
[PATCH]  start  =  pos  +  1;	[BUG]  [BUGGY]  start  =  pos  +  0;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {    if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }  out.append(escape);  out.append(c);  [BUGGY]  start  =  pos  +  0;  [BUGGY]  }  pos++;  }    if  (pos  >  start)  {  out.append(value,  start,  pos);  }  }  void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;    [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P8_Replace_Mix]
[PATCH]  start  =  pos  +  1;	[BUG]  [BUGGY]  start  =  pos;start  =  pos  +  1;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {    if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }  out.append(escape);  out.append(c);  [BUGGY]  start  =  pos;start  =  pos  +  1;  [BUGGY]  }  pos++;  }    if  (pos  >  start)  {  out.append(value,  start,  pos);  }  }  void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;    [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  out.append  (  value,  start,  pos  )  ;	[BUG]  [BUGGY]  out.append(  value,  pos,  pos)  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;  printSep();  char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();  while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {    if  (pos  >  start)  {  [BUGGY]  out.append(  value,  pos,  pos)  ;  [BUGGY]  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }  out.append(escape);  out.append(c);  start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }  pos++;  }    [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P5_Replace_Variable]
[PATCH]  out.append  (  escape  )  ;	[BUG]  [BUGGY]  out.append(  delim)  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  char  escape  =  format.getEscape();  while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {    if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }  [BUGGY]  out.append(  delim)  ;  [BUGGY]  out.append(c);  start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }  pos++;  }    if  (pos  >  start)  {  out.append(value,  start,  pos);  }  }  void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {    [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P8_Replace_Mix]
[PATCH]  out.append  (  escape  )  ;  out.append  (  c  )  ;	[BUG]  [BUGGY]  [FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  char  escape  =  format.getEscape();  while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {    if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }  [BUGGY]  [BUGGY]      start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }  pos++;  }    if  (pos  >  start)  {  out.append(value,  start,  pos);  }  }      [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P14_Delete_Statement]
[PATCH]  out.append  (  escape  )  ;	[BUG]  [BUGGY]  out.append(  value,  start,  end)  ;out.append(  escape)  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  char  escape  =  format.getEscape();  while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {    if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }  [BUGGY]  out.append(  value,  start,  end)  ;out.append(  escape)  ;  [BUGGY]  out.append(c);  start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }  pos++;  }    if  (pos  >  start)  {  out.append(value,  start,  pos);  }  }  void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {    [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  out.append  (  escape  )  ;	[BUG]  [BUGGY]  out.append(  value,  start,  pos)  ;out.append(  escape)  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  char  escape  =  format.getEscape();  while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {    if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }  [BUGGY]  out.append(  value,  start,  pos)  ;out.append(  escape)  ;  [BUGGY]  out.append(c);  start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }  pos++;  }    if  (pos  >  start)  {  out.append(value,  start,  pos);  }  }  void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {    [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  out.append  (  escape  )  ;	[BUG]  [BUGGY]  out.append(  c)  ;out.append(  escape)  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  char  escape  =  format.getEscape();  while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {    if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }  [BUGGY]  out.append(  c)  ;out.append(  escape)  ;  [BUGGY]  out.append(c);  start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }  pos++;  }    if  (pos  >  start)  {  out.append(value,  start,  pos);  }  }  void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {    [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  out.append  (  escape  )  ;	[BUG]  [BUGGY]  out.append(  value)  ;out.append(  escape)  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  char  escape  =  format.getEscape();  while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {    if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }  [BUGGY]  out.append(  value)  ;out.append(  escape)  ;  [BUGGY]  out.append(c);  start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }  pos++;  }    if  (pos  >  start)  {  out.append(value,  start,  pos);  }  }  void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {    [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  out.append  (  escape  )  ;	[BUG]  [BUGGY]  out.append(  encapsulator)  ;out.append(  escape)  ;[CE]  cannot  find  symbol  encapsulator  [CONTEXT]  char  escape  =  format.getEscape();  while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {    if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }  [BUGGY]  out.append(  encapsulator)  ;out.append(  escape)  ;  [BUGGY]  out.append(c);  start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }  pos++;  }    if  (pos  >  start)  {  out.append(value,  start,  pos);  }  }  void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {    [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  out.append  (  escape  )  ;	[BUG]  [BUGGY]  out.append(  value,  start,  pos  +  1)  ;out.append(  escape)  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  char  escape  =  format.getEscape();  while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {    if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }  [BUGGY]  out.append(  value,  start,  pos  +  1)  ;out.append(  escape)  ;  [BUGGY]  out.append(c);  start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }  pos++;  }    if  (pos  >  start)  {  out.append(value,  start,  pos);  }  }  void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {    [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  out.append  (  escape  )  ;	[BUG]  [BUGGY]  out.append(  '  ')  ;out.append(  escape)  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  char  escape  =  format.getEscape();  while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {    if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }  [BUGGY]  out.append(  '  ')  ;out.append(  escape)  ;  [BUGGY]  out.append(c);  start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }  pos++;  }    if  (pos  >  start)  {  out.append(value,  start,  pos);  }  }  void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {    [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  out.append  (  c  )  ;	[BUG]  [BUGGY]  out.append(  escape)  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {    if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }  out.append(escape);  [BUGGY]  out.append(  escape)  ;  [BUGGY]    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }  pos++;  }    if  (pos  >  start)  {  out.append(value,  start,  pos);  }  }  void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?    [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P5_Replace_Variable]
[PATCH]  out.append  (  c  )  ;	[BUG]  [BUGGY]  [FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {    if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }  out.append(escape);  [BUGGY]  [BUGGY]    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }  pos++;  }    if  (pos  >  start)  {  out.append(value,  start,  pos);  }  }  void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {    [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P14_Delete_Statement]
[PATCH]  out.append  (  c  )  ;	[BUG]  [BUGGY]  out.append(  value)  ;out.append(  c)  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {    if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }  out.append(escape);  [BUGGY]  out.append(  value)  ;out.append(  c)  ;  [BUGGY]    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }  pos++;  }    if  (pos  >  start)  {  out.append(value,  start,  pos);  }  }  void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?    [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  out.append  (  c  )  ;	[BUG]  [BUGGY]  out.append(  encapsulator)  ;out.append(  c)  ;[CE]  cannot  find  symbol  encapsulator  [CONTEXT]  while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {    if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }  out.append(escape);  [BUGGY]  out.append(  encapsulator)  ;out.append(  c)  ;  [BUGGY]    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }  pos++;  }    if  (pos  >  start)  {  out.append(value,  start,  pos);  }  }  void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?    [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  out.append  (  c  )  ;	[BUG]  [BUGGY]  out.append(  '  ')  ;out.append(  c)  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {    if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }  out.append(escape);  [BUGGY]  out.append(  '  ')  ;out.append(  c)  ;  [BUGGY]    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }  pos++;  }    if  (pos  >  start)  {  out.append(value,  start,  pos);  }  }  void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?    [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  out.append  (  c  )  ;	[BUG]  [BUGGY]  out.append(  escape)  ;out.append(  c)  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {    if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }  out.append(escape);  [BUGGY]  out.append(  escape)  ;out.append(  c)  ;  [BUGGY]    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }  pos++;  }    if  (pos  >  start)  {  out.append(value,  start,  pos);  }  }  void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?    [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  if  (  pos  >  start  )  {	[BUG]  [BUGGY]  if  (  pos  <  start)  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;  printSep();  char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();  while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {    [BUGGY]  if  (  pos  <  start)  {  [BUGGY]  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }  out.append(escape);  out.append(c);  start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }  pos++;    [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P2_Replace_Operator]
[PATCH]  if  (  pos  >  start  )  {	[BUG]  [BUGGY]  if  (  start  >  start)  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;  printSep();  char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();  while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {    [BUGGY]  if  (  start  >  start)  {  [BUGGY]  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }  out.append(escape);  out.append(c);  start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }  pos++;    [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P5_Replace_Variable]
[PATCH]  out.append  (  value,  start,  pos  )  ;	[BUG]  [BUGGY]  out.append(  start,  value,  pos)  ;[CE]  no  suitable  method  found  for  append(int,CharSequence,int)  [CONTEXT]  void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;  printSep();  char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();  while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {    if  (pos  >  start)  {  [BUGGY]  out.append(  start,  value,  pos)  ;  [BUGGY]  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }  out.append(escape);  out.append(c);  start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }  pos++;  }    [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P5_Replace_Variable]
[PATCH]  }  else  if  (  c  ==  '\r'  )  {	[BUG]  [BUGGY]  }  else  if  (  c  !=  '\r')  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  printSep();  char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();  while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {    if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  [BUGGY]  }  else  if  (  c  !=  '\r')  {  [BUGGY]  c  =  'r';  }  out.append(escape);  out.append(c);  start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }  pos++;  }    if  (pos  >  start)  {  out.append(value,  start,  pos);    [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P2_Replace_Operator]
[PATCH]  }  else  if  (  c  ==  '\r'  )  {	[BUG]  [BUGGY]  }  if  (  escape  ==  '\r')  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  printSep();  char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();  while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {    if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  [BUGGY]  }  if  (  escape  ==  '\r')  {  [BUGGY]  c  =  'r';  }  out.append(escape);  out.append(c);  start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }  pos++;  }    if  (pos  >  start)  {  out.append(value,  start,  pos);    [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P8_Replace_Mix]
[PATCH]  c  =  'r';	[BUG]  [BUGGY]  c  ;[CE]  not  a  statement  [CONTEXT]  printSep();  char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();  while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {    if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  [BUGGY]  c  ;  [BUGGY]  }  out.append(escape);  out.append(c);  start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }  pos++;  }    if  (pos  >  start)  {  out.append(value,  start,  pos);  }    [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P8_Replace_Mix]
[PATCH]  c  =  'r';	[BUG]  [BUGGY]  c  =  null  ;[CE]  incompatible  types  [CONTEXT]  printSep();  char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();  while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {    if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  [BUGGY]  c  =  null  ;  [BUGGY]  }  out.append(escape);  out.append(c);  start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }  pos++;  }    if  (pos  >  start)  {  out.append(value,  start,  pos);  }    [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P8_Replace_Mix]
[PATCH]  c  =  'n';	[BUG]  [BUGGY]  c  ;[CE]  not  a  statement  [CONTEXT]  int  end  =  offset  +  len;  printSep();  char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();  while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {    if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  [BUGGY]  c  ;  [BUGGY]  }  else  if  (c  ==  '\r')  {  c  =  'r';  }  out.append(escape);  out.append(c);  start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }  pos++;  }    if  (pos  >  start)  {    [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P8_Replace_Mix]
[PATCH]  c  =  'n';	[BUG]  [BUGGY]  c  =  null  ;[CE]  incompatible  types  [CONTEXT]  int  end  =  offset  +  len;  printSep();  char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();  while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {    if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  [BUGGY]  c  =  null  ;  [BUGGY]  }  else  if  (c  ==  '\r')  {  c  =  'r';  }  out.append(escape);  out.append(c);  start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }  pos++;  }    if  (pos  >  start)  {    [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P8_Replace_Mix]
[PATCH]  start  =  pos  +  1;	[BUG]  [BUGGY]  start  =  pos  +  1  /  3;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {    if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }  out.append(escape);  out.append(c);  [BUGGY]  start  =  pos  +  1  /  3;  [BUGGY]  }  pos++;  }    if  (pos  >  start)  {  out.append(value,  start,  pos);  }  }  void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;    [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P8_Replace_Mix]
[PATCH]  char  c  =  value.charAt  (  pos  )  ;	[BUG]  [BUGGY]  int  c  =  value.charAt(  pos)  ;[CE]  no  suitable  method  found  for  append(int)  [CONTEXT]  out.append(format.getDelimiter());  }  }  void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;  printSep();  char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();  while  (pos  <  end)  {  [BUGGY]  int  c  =  value.charAt(  pos)  ;  [BUGGY]  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {    if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }  out.append(escape);  out.append(c);  start  =  pos  +  1;  //  start  on  the  current  char  after  this  one    [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P1_Replace_Type]
[PATCH]  char  c  =  value.charAt  (  pos  )  ;	[BUG]  [BUGGY]  char  c  =  value.charAt(  start)  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  out.append(format.getDelimiter());  }  }  void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;  printSep();  char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();  while  (pos  <  end)  {  [BUGGY]  char  c  =  value.charAt(  start)  ;  [BUGGY]  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {    if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }  out.append(escape);  out.append(c);  start  =  pos  +  1;  //  start  on  the  current  char  after  this  one    [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P5_Replace_Variable]
[PATCH]  char  c  =  value.charAt  (  pos  )  ;	[BUG]  [BUGGY]  char  c  =  pos.charAt(  value)  ;[CE]  int  cannot  be  dereferenced  [CONTEXT]  out.append(format.getDelimiter());  }  }  void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;  printSep();  char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();  while  (pos  <  end)  {  [BUGGY]  char  c  =  pos.charAt(  value)  ;  [BUGGY]  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {    if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }  out.append(escape);  out.append(c);  start  =  pos  +  1;  //  start  on  the  current  char  after  this  one    [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P5_Replace_Variable]
[PATCH]  char  c  =  value.charAt  (  pos  )  ;	[BUG]  [BUGGY]  char  c  =  value.charAt(  offset)  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  out.append(format.getDelimiter());  }  }  void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;  printSep();  char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();  while  (pos  <  end)  {  [BUGGY]  char  c  =  value.charAt(  offset)  ;  [BUGGY]  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {    if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }  out.append(escape);  out.append(c);  start  =  pos  +  1;  //  start  on  the  current  char  after  this  one    [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P8_Replace_Mix]
[PATCH]  char  c  =  value.charAt  (  pos  )  ;	[BUG]  [BUGGY]  char  c  =  comment.charAt(  i)  ;char  c  =  value.charAt(  pos)  ;[CE]  cannot  find  symbol  i  [CONTEXT]  out.append(format.getDelimiter());  }  }  void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;  printSep();  char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();  while  (pos  <  end)  {  [BUGGY]  char  c  =  comment.charAt(  i)  ;char  c  =  value.charAt(  pos)  ;  [BUGGY]  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {    if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }  out.append(escape);  out.append(c);  start  =  pos  +  1;  //  start  on  the  current  char  after  this  one    [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  char  c  =  value.charAt  (  pos  )  ;	[BUG]  [BUGGY]  [FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  out.append(format.getDelimiter());  }  }  void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;  printSep();  char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();  while  (pos  <  end)  {  [BUGGY]  [BUGGY]    if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {    if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }  out.append(escape);  out.append(c);      [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P14_Delete_Statement]
[PATCH]  char  c  =  value.charAt  (  pos  )  ;	[BUG]  [BUGGY]  c  =  value.charAt(  pos)  ;char  c  =  value.charAt(  pos)  ;[CE]  cannot  find  symbol  c  [CONTEXT]  out.append(format.getDelimiter());  }  }  void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;  printSep();  char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();  while  (pos  <  end)  {  [BUGGY]  c  =  value.charAt(  pos)  ;char  c  =  value.charAt(  pos)  ;  [BUGGY]  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {    if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }  out.append(escape);  out.append(c);  start  =  pos  +  1;  //  start  on  the  current  char  after  this  one    [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  out.append  (  escape  )  ;	[BUG]  [BUGGY]  out.append(  value  ,  len  ,  offset)  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  char  escape  =  format.getEscape();  while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {    if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }  [BUGGY]  out.append(  value  ,  len  ,  offset)  ;  [BUGGY]  out.append(c);  start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }  pos++;  }    if  (pos  >  start)  {  out.append(value,  start,  pos);  }  }  void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {    [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P7_Replace_Invocation]
[PATCH]  out.append  (  escape  )  ;	[BUG]  [BUGGY]  [FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  char  escape  =  format.getEscape();  while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {    if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }  [BUGGY]  [BUGGY]    out.append(c);  start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }  pos++;  }    if  (pos  >  start)  {  out.append(value,  start,  pos);  }  }      [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P14_Delete_Statement]
[PATCH]  if  (  c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape  )  {	[BUG]  [BUGGY]  if  (  c  ==  '\r'  ||  c  ==  '\n'  ||  c  !=  delim  ||  c  ==  escape)  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  }  }  void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;  printSep();  char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();  while  (pos  <  end)  {  char  c  =  value.charAt(pos);  [BUGGY]  if  (  c  ==  '\r'  ||  c  ==  '\n'  ||  c  !=  delim  ||  c  ==  escape)  {  [BUGGY]    if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }  out.append(escape);  out.append(c);  start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }    [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P2_Replace_Operator]
[PATCH]  if  (  c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape  )  {	[BUG]  [BUGGY]  if  (  c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  !=  escape)  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  }  }  void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;  printSep();  char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();  while  (pos  <  end)  {  char  c  =  value.charAt(pos);  [BUGGY]  if  (  c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  !=  escape)  {  [BUGGY]    if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }  out.append(escape);  out.append(c);  start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }    [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P2_Replace_Operator]
[PATCH]  if  (  c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape  )  {	[BUG]  [BUGGY]  if  (  c  ==  '\r'  ||  c  !=  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  }  }  void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;  printSep();  char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();  while  (pos  <  end)  {  char  c  =  value.charAt(pos);  [BUGGY]  if  (  c  ==  '\r'  ||  c  !=  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {  [BUGGY]    if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }  out.append(escape);  out.append(c);  start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }    [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P2_Replace_Operator]
[PATCH]  if  (  c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape  )  {	[BUG]  [BUGGY]  if  (  c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  delim)  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  }  }  void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;  printSep();  char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();  while  (pos  <  end)  {  char  c  =  value.charAt(pos);  [BUGGY]  if  (  c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  delim)  {  [BUGGY]    if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }  out.append(escape);  out.append(c);  start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }    [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P5_Replace_Variable]
[PATCH]  if  (  c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape  )  {	[BUG]  [BUGGY]  if  (  c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  escape  ||  c  ==  delim)  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  }  }  void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;  printSep();  char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();  while  (pos  <  end)  {  char  c  =  value.charAt(pos);  [BUGGY]  if  (  c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  escape  ||  c  ==  delim)  {  [BUGGY]    if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }  out.append(escape);  out.append(c);  start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }    [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P5_Replace_Variable]
[PATCH]  if  (  c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape  )  {	[BUG]  [BUGGY]  if  (  delim  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  }  }  void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;  printSep();  char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();  while  (pos  <  end)  {  char  c  =  value.charAt(pos);  [BUGGY]  if  (  delim  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {  [BUGGY]    if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }  out.append(escape);  out.append(c);  start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }    [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P8_Replace_Mix]
[PATCH]  if  (  pos  >  start  )  {	[BUG]  [BUGGY]  if  (  pos  ==  start)  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;  printSep();  char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();  while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {    [BUGGY]  if  (  pos  ==  start)  {  [BUGGY]  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }  out.append(escape);  out.append(c);  start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }  pos++;    [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P2_Replace_Operator]
[PATCH]  if  (  pos  >  start  )  {	[BUG]  [BUGGY]  if  (  pos  >  offset)  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;  printSep();  char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();  while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {    [BUGGY]  if  (  pos  >  offset)  {  [BUGGY]  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }  out.append(escape);  out.append(c);  start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }  pos++;    [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P5_Replace_Variable]
[PATCH]  }  else  if  (  c  ==  '\r'  )  {	[BUG]  [BUGGY]  }  else  if  (  c  >  '\r')  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  printSep();  char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();  while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {    if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  [BUGGY]  }  else  if  (  c  >  '\r')  {  [BUGGY]  c  =  'r';  }  out.append(escape);  out.append(c);  start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }  pos++;  }    if  (pos  >  start)  {  out.append(value,  start,  pos);    [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P2_Replace_Operator]
[PATCH]  start  =  pos  +  1;	[BUG]  [BUGGY]  start  =  pos  +  len;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {    if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }  out.append(escape);  out.append(c);  [BUGGY]  start  =  pos  +  len;  [BUGGY]  }  pos++;  }    if  (pos  >  start)  {  out.append(value,  start,  pos);  }  }  void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;    [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P3_Replace_Literal]
[PATCH]  if  (  c  ==  '\n'  )  {	[BUG]  [BUGGY]  if  (  c  <  '\n')  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  int  pos  =  offset;  int  end  =  offset  +  len;  printSep();  char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();  while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {    if  (pos  >  start)  {  out.append(value,  start,  pos);  }  [BUGGY]  if  (  c  <  '\n')  {  [BUGGY]  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }  out.append(escape);  out.append(c);  start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }  pos++;  }        [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P2_Replace_Operator]
[PATCH]  }  else  if  (  c  ==  '\r'  )  {	[BUG]  [BUGGY]  }  else  if  (  c  <  '\r')  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  printSep();  char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();  while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {    if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  [BUGGY]  }  else  if  (  c  <  '\r')  {  [BUGGY]  c  =  'r';  }  out.append(escape);  out.append(c);  start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }  pos++;  }    if  (pos  >  start)  {  out.append(value,  start,  pos);    [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P2_Replace_Operator]
[PATCH]  start  =  pos  +  1;	[BUG]  [BUGGY]  start  =  pos  +  start;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {    if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }  out.append(escape);  out.append(c);  [BUGGY]  start  =  pos  +  start;  [BUGGY]  }  pos++;  }    if  (pos  >  start)  {  out.append(value,  start,  pos);  }  }  void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;    [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P3_Replace_Literal]
[PATCH]  out.append  (  escape  )  ;	[BUG]  [BUGGY]  out.append(  value  ,  offset  ,  len)  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  char  escape  =  format.getEscape();  while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {    if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }  [BUGGY]  out.append(  value  ,  offset  ,  len)  ;  [BUGGY]  out.append(c);  start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }  pos++;  }    if  (pos  >  start)  {  out.append(value,  start,  pos);  }  }  void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {    [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P7_Replace_Invocation]
[PATCH]  out.append  (  c  )  ;	[BUG]  [BUGGY]  out.append(  value  ,  pos  ,  len)  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {    if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }  out.append(escape);  [BUGGY]  out.append(  value  ,  pos  ,  len)  ;  [BUGGY]    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }  pos++;  }    if  (pos  >  start)  {  out.append(value,  start,  pos);  }  }  void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?    [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P7_Replace_Invocation]
[PATCH]  if  (  pos  >  start  )  {	[BUG]  [BUGGY]  if  (  pos  >=  start)  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }  out.append(escape);  out.append(c);  start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }  pos++;  }    [BUGGY]  if  (  pos  >=  start)  {  [BUGGY]  out.append(value,  start,  pos);  }  }  void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;  printSep();  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();    [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P2_Replace_Operator]
[PATCH]  if  (  pos  >  start  )  {	[BUG]  [BUGGY]  if  (  offset  >  start)  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }  out.append(escape);  out.append(c);  start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }  pos++;  }    [BUGGY]  if  (  offset  >  start)  {  [BUGGY]  out.append(value,  start,  pos);  }  }  void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;  printSep();  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();    [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P5_Replace_Variable]
[PATCH]  if  (  pos  >  start  )  {	[BUG]  [BUGGY]  if  (  pos  >  offset)  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }  out.append(escape);  out.append(c);  start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }  pos++;  }    [BUGGY]  if  (  pos  >  offset)  {  [BUGGY]  out.append(value,  start,  pos);  }  }  void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;  printSep();  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();    [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P5_Replace_Variable]
[PATCH]  if  (  pos  >  start  )  {	[BUG]  [BUGGY]  if  (  start  >  pos)  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }  out.append(escape);  out.append(c);  start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }  pos++;  }    [BUGGY]  if  (  start  >  pos)  {  [BUGGY]  out.append(value,  start,  pos);  }  }  void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;  printSep();  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();    [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P5_Replace_Variable]
[PATCH]  if  (  pos  >  start  )  {  out.append  (  value,  start,  pos  )  ;  }	[BUG]  [BUGGY]  out.append(value,  start,  pos);[CE]  illegal  start  of  expression  [CONTEXT]  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }  out.append(escape);  out.append(c);  start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }  pos++;  }    [BUGGY]  out.append(value,  start,  pos);  [BUGGY]    out.append(value,  start,  pos);  }  void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;  printSep();  char  delim  =  format.getDelimiter();    [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P15_Unwrap_Block]
[PATCH]  if  (  pos  >  start  )  {  out.append  (  value,  start,  pos  )  ;  }	[BUG]  [BUGGY]  [CE]  illegal  start  of  expression  [CONTEXT]  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }  out.append(escape);  out.append(c);  start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }  pos++;  }    [BUGGY]  [BUGGY]      }  void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;  printSep();  char  delim  =  format.getDelimiter();    [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P16_Remove_Block]
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  c  ==  encapsulator)  {      out.append(  value,  start,  (  pos  +  1)  )  ;      start  =  pos;  }[CE]  class,  interface,  or  enum  expected  [CONTEXT]  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }  out.append(escape);  out.append(c);  start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }  pos++;  }    [BUGGY]  if  (  c  ==  encapsulator)  {      out.append(  value,  start,  (  pos  +  1)  )  ;      start  =  pos;  }  [BUGGY]  out.append(value,  start,  pos);  }  }  void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;  printSep();  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();    [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P13_Insert_Block]
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  !quote)  {      out.append(  value,  start,  end)  ;      return  ;  }[CE]  class,  interface,  or  enum  expected  [CONTEXT]  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }  out.append(escape);  out.append(c);  start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }  pos++;  }    [BUGGY]  if  (  !quote)  {      out.append(  value,  start,  end)  ;      return  ;  }  [BUGGY]  out.append(value,  start,  pos);  }  }  void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;  printSep();  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();    [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P13_Insert_Block]
[PATCH]  out.append  (  value,  start,  pos  )  ;	[BUG]  [BUGGY]  out.append(  value,  offset,  pos)  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  }  else  if  (c  ==  '\r')  {  c  =  'r';  }  out.append(escape);  out.append(c);  start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }  pos++;  }    if  (pos  >  start)  {  [BUGGY]  out.append(  value,  offset,  pos)  ;  [BUGGY]  }  }  void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;  printSep();  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();      [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P5_Replace_Variable]
[PATCH]  out.append  (  value,  start,  pos  )  ;	[BUG]  [BUGGY]  out.append(  value,  start,  start)  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  }  else  if  (c  ==  '\r')  {  c  =  'r';  }  out.append(escape);  out.append(c);  start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }  pos++;  }    if  (pos  >  start)  {  [BUGGY]  out.append(  value,  start,  start)  ;  [BUGGY]  }  }  void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;  printSep();  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();      [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P5_Replace_Variable]
[PATCH]  out.append  (  value,  start,  pos  )  ;	[BUG]  [BUGGY]  out.append(  start,  pos)  ;[CE]  no  suitable  method  found  for  append(int,int)  [CONTEXT]  }  else  if  (c  ==  '\r')  {  c  =  'r';  }  out.append(escape);  out.append(c);  start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }  pos++;  }    if  (pos  >  start)  {  [BUGGY]  out.append(  start,  pos)  ;  [BUGGY]  }  }  void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;  printSep();  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();      [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P5_Replace_Variable]
[PATCH]  out.append  (  value,  start,  pos  )  ;	[BUG]  [BUGGY]  out.append(  value,  pos)  ;[CE]  no  suitable  method  found  for  append(CharSequence,int)  [CONTEXT]  }  else  if  (c  ==  '\r')  {  c  =  'r';  }  out.append(escape);  out.append(c);  start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }  pos++;  }    if  (pos  >  start)  {  [BUGGY]  out.append(  value,  pos)  ;  [BUGGY]  }  }  void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;  printSep();  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();      [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P5_Replace_Variable]
[PATCH]  out.append  (  value,  start,  pos  )  ;	[BUG]  [BUGGY]  out.append(  value,  start)  ;[CE]  no  suitable  method  found  for  append(CharSequence,int)  [CONTEXT]  }  else  if  (c  ==  '\r')  {  c  =  'r';  }  out.append(escape);  out.append(c);  start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }  pos++;  }    if  (pos  >  start)  {  [BUGGY]  out.append(  value,  start)  ;  [BUGGY]  }  }  void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;  printSep();  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();      [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P5_Replace_Variable]
[PATCH]  out.append  (  value,  start,  pos  )  ;	[BUG]  [BUGGY]  out.append(  value,  pos,  start)  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  }  else  if  (c  ==  '\r')  {  c  =  'r';  }  out.append(escape);  out.append(c);  start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }  pos++;  }    if  (pos  >  start)  {  [BUGGY]  out.append(  value,  pos,  start)  ;  [BUGGY]  }  }  void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;  printSep();  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();      [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P5_Replace_Variable]
[PATCH]  out.append  (  value,  start,  pos  )  ;	[BUG]  [BUGGY]  out.append(  value)  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  }  else  if  (c  ==  '\r')  {  c  =  'r';  }  out.append(escape);  out.append(c);  start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }  pos++;  }    if  (pos  >  start)  {  [BUGGY]  out.append(  value)  ;  [BUGGY]  }  }  void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;  printSep();  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();      [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P7_Replace_Invocation]
[PATCH]  out.append  (  value,  start,  pos  )  ;	[BUG]  [BUGGY]  out.append(  value,  start,  offset)  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  }  else  if  (c  ==  '\r')  {  c  =  'r';  }  out.append(escape);  out.append(c);  start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }  pos++;  }    if  (pos  >  start)  {  [BUGGY]  out.append(  value,  start,  offset)  ;  [BUGGY]  }  }  void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;  printSep();  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();      [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P8_Replace_Mix]
[PATCH]  out.append  (  value,  start,  pos  )  ;	[BUG]  [BUGGY]  [FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  }  else  if  (c  ==  '\r')  {  c  =  'r';  }  out.append(escape);  out.append(c);  start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }  pos++;  }    if  (pos  >  start)  {  [BUGGY]  [BUGGY]    }  }  void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;  printSep();  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();    [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P14_Delete_Statement]
[PATCH]  out.append  (  value,  start,  pos  )  ;	[BUG]  [BUGGY]  out.append(  value,  start,  end)  ;out.append(  value,  start,  pos)  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  }  else  if  (c  ==  '\r')  {  c  =  'r';  }  out.append(escape);  out.append(c);  start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }  pos++;  }    if  (pos  >  start)  {  [BUGGY]  out.append(  value,  start,  end)  ;out.append(  value,  start,  pos)  ;  [BUGGY]  }  }  void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;  printSep();  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();      [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  out.append  (  value,  start,  pos  )  ;	[BUG]  [BUGGY]  print(  value,  true)  ;out.append(  value,  start,  pos)  ;[CE]  no  suitable  method  found  for  print(CharSequence,boolean)  [CONTEXT]  }  else  if  (c  ==  '\r')  {  c  =  'r';  }  out.append(escape);  out.append(c);  start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }  pos++;  }    if  (pos  >  start)  {  [BUGGY]  print(  value,  true)  ;out.append(  value,  start,  pos)  ;  [BUGGY]  }  }  void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;  printSep();  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();      [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  out.append  (  value,  start,  pos  )  ;	[BUG]  [BUGGY]  out.append(  format.getCommentStart(  )  )  ;out.append(  value,  start,  pos)  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  }  else  if  (c  ==  '\r')  {  c  =  'r';  }  out.append(escape);  out.append(c);  start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }  pos++;  }    if  (pos  >  start)  {  [BUGGY]  out.append(  format.getCommentStart(  )  )  ;out.append(  value,  start,  pos)  ;  [BUGGY]  }  }  void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;  printSep();  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();      [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  out.append  (  value,  start,  pos  )  ;	[BUG]  [BUGGY]  out.append(  value)  ;out.append(  value,  start,  pos)  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  }  else  if  (c  ==  '\r')  {  c  =  'r';  }  out.append(escape);  out.append(c);  start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }  pos++;  }    if  (pos  >  start)  {  [BUGGY]  out.append(  value)  ;out.append(  value,  start,  pos)  ;  [BUGGY]  }  }  void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;  printSep();  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();      [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  out.append  (  value,  start,  pos  )  ;	[BUG]  [BUGGY]  out.append(  format.getLineSeparator(  )  )  ;out.append(  value,  start,  pos)  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  }  else  if  (c  ==  '\r')  {  c  =  'r';  }  out.append(escape);  out.append(c);  start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }  pos++;  }    if  (pos  >  start)  {  [BUGGY]  out.append(  format.getLineSeparator(  )  )  ;out.append(  value,  start,  pos)  ;  [BUGGY]  }  }  void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;  printSep();  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();      [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  out.append  (  value,  start,  pos  )  ;	[BUG]  [BUGGY]  out.append(  value,  offset,  offset  +  len)  ;out.append(  value,  start,  pos)  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  }  else  if  (c  ==  '\r')  {  c  =  'r';  }  out.append(escape);  out.append(c);  start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }  pos++;  }    if  (pos  >  start)  {  [BUGGY]  out.append(  value,  offset,  offset  +  len)  ;out.append(  value,  start,  pos)  ;  [BUGGY]  }  }  void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;  printSep();  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();      [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  out.append  (  value,  start,  pos  )  ;	[BUG]  [BUGGY]  out.append(  encapsulator)  ;out.append(  value,  start,  pos)  ;[CE]  cannot  find  symbol  encapsulator  [CONTEXT]  }  else  if  (c  ==  '\r')  {  c  =  'r';  }  out.append(escape);  out.append(c);  start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }  pos++;  }    if  (pos  >  start)  {  [BUGGY]  out.append(  encapsulator)  ;out.append(  value,  start,  pos)  ;  [BUGGY]  }  }  void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;  printSep();  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();      [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  out.append  (  value,  start,  pos  )  ;	[BUG]  [BUGGY]  out.append(  format.getDelimiter(  )  )  ;out.append(  value,  start,  pos)  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  }  else  if  (c  ==  '\r')  {  c  =  'r';  }  out.append(escape);  out.append(c);  start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }  pos++;  }    if  (pos  >  start)  {  [BUGGY]  out.append(  format.getDelimiter(  )  )  ;out.append(  value,  start,  pos)  ;  [BUGGY]  }  }  void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;  printSep();  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();      [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  out.append  (  value,  start,  pos  )  ;	[BUG]  [BUGGY]  out.append(  value,  start,  pos  +  1)  ;out.append(  value,  start,  pos)  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  }  else  if  (c  ==  '\r')  {  c  =  'r';  }  out.append(escape);  out.append(c);  start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }  pos++;  }    if  (pos  >  start)  {  [BUGGY]  out.append(  value,  start,  pos  +  1)  ;out.append(  value,  start,  pos)  ;  [BUGGY]  }  }  void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;  printSep();  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();      [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  out.append  (  value,  start,  pos  )  ;	[BUG]  [BUGGY]  out.append(  '  ')  ;out.append(  value,  start,  pos)  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  }  else  if  (c  ==  '\r')  {  c  =  'r';  }  out.append(escape);  out.append(c);  start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }  pos++;  }    if  (pos  >  start)  {  [BUGGY]  out.append(  '  ')  ;out.append(  value,  start,  pos)  ;  [BUGGY]  }  }  void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;  printSep();  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();      [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  out.append  (  value,  start,  pos  )  ;	[BUG]  [BUGGY]  out.append(  escape)  ;out.append(  value,  start,  pos)  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  }  else  if  (c  ==  '\r')  {  c  =  'r';  }  out.append(escape);  out.append(c);  start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }  pos++;  }    if  (pos  >  start)  {  [BUGGY]  out.append(  escape)  ;out.append(  value,  start,  pos)  ;  [BUGGY]  }  }  void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;  printSep();  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();      [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  pos  >  start)  {      out.append(  value,  start,  pos)  ;  }[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  }  else  if  (c  ==  '\r')  {  c  =  'r';  }  out.append(escape);  out.append(c);  start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }  pos++;  }    if  (pos  >  start)  {  [BUGGY]  if  (  pos  >  start)  {      out.append(  value,  start,  pos)  ;  }  [BUGGY]  }  }  void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;  printSep();  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();      [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P13_Insert_Block]
[PATCH]  out.append  (  value,  start,  pos  )  ;	[BUG]  [BUGGY]  out.append(  pos,  start,  value)  ;[CE]  no  suitable  method  found  for  append(int,int,CharSequence)  [CONTEXT]  }  else  if  (c  ==  '\r')  {  c  =  'r';  }  out.append(escape);  out.append(c);  start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }  pos++;  }    if  (pos  >  start)  {  [BUGGY]  out.append(  pos,  start,  value)  ;  [BUGGY]  }  }  void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;  printSep();  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();      [CLASS]  CSVPrinter  [METHOD]  printAndEscape  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  escape  CSVFormat  format  boolean  newLine  int  end  len  offset  pos  start  Appendable  out    	[P5_Replace_Variable]
[PATCH]  boolean  first  =  newLine;	[BUG]  [BUGGY]  boolean  first  =  quote;[CE]  cannot  find  symbol  quote  [CONTEXT]  out.append(c);  start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }  pos++;  }    if  (pos  >  start)  {  out.append(value,  start,  pos);  }  }  void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  [BUGGY]  boolean  first  =  quote;  [BUGGY]  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;  printSep();  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();  if  (len  <=  0)  {            [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P5_Replace_Variable]
[PATCH]  boolean  first  =  newLine;	[BUG]  [BUGGY]  boolean  quote  =  false;boolean  first  =  newLine;[CE]  variable  quote  is  already  defined  in  method  printAndEncapsulate(CharSequence,int,int)  [CONTEXT]  out.append(c);  start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }  pos++;  }    if  (pos  >  start)  {  out.append(value,  start,  pos);  }  }  void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  [BUGGY]  boolean  quote  =  false;boolean  first  =  newLine;  [BUGGY]  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;  printSep();  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();  if  (len  <=  0)  {            [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  boolean  quote  =  false;	[BUG]  [BUGGY]  boolean  quote  =  true;[FE]  expected:<[a,b,c]>  but  was:<[ "a ", "b ", "c "]>  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]  start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }  pos++;  }    if  (pos  >  start)  {  out.append(value,  start,  pos);  }  }  void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  [BUGGY]  boolean  quote  =  true;  [BUGGY]  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;  printSep();  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();  if  (len  <=  0)  {          if  (first)  {    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P3_Replace_Literal]
[PATCH]  boolean  quote  =  false;	[BUG]  [BUGGY]  boolean  first  =  newLine;boolean  quote  =  false;[CE]  variable  first  is  already  defined  in  method  printAndEncapsulate(CharSequence,int,int)  [CONTEXT]  start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }  pos++;  }    if  (pos  >  start)  {  out.append(value,  start,  pos);  }  }  void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  [BUGGY]  boolean  first  =  newLine;boolean  quote  =  false;  [BUGGY]  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;  printSep();  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();  if  (len  <=  0)  {          if  (first)  {    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  int  start  =  offset;	[BUG]  [BUGGY]  long  start  =  offset;[CE]  no  suitable  method  found  for  append(CharSequence,long,int)  [CONTEXT]  start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }  pos++;  }    if  (pos  >  start)  {  out.append(value,  start,  pos);  }  }  void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  [BUGGY]  long  start  =  offset;  [BUGGY]  int  pos  =  offset;  int  end  =  offset  +  len;  printSep();  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();  if  (len  <=  0)  {          if  (first)  {  quote  =  true;    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P1_Replace_Type]
[PATCH]  int  start  =  offset;	[BUG]  [BUGGY]  int  start  =  pos;[CE]  cannot  find  symbol  pos  [CONTEXT]  start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }  pos++;  }    if  (pos  >  start)  {  out.append(value,  start,  pos);  }  }  void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  [BUGGY]  int  start  =  pos;  [BUGGY]  int  pos  =  offset;  int  end  =  offset  +  len;  printSep();  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();  if  (len  <=  0)  {          if  (first)  {  quote  =  true;    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P5_Replace_Variable]
[PATCH]  int  start  =  offset;	[BUG]  [BUGGY]  int  pos  =  offset;int  start  =  offset;[CE]  variable  pos  is  already  defined  in  method  printAndEncapsulate(CharSequence,int,int)  [CONTEXT]  start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }  pos++;  }    if  (pos  >  start)  {  out.append(value,  start,  pos);  }  }  void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  [BUGGY]  int  pos  =  offset;int  start  =  offset;  [BUGGY]  int  pos  =  offset;  int  end  =  offset  +  len;  printSep();  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();  if  (len  <=  0)  {          if  (first)  {  quote  =  true;    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  int  start  =  offset;	[BUG]  [BUGGY]  int  end  =  offset  +  len;int  start  =  offset;[CE]  variable  end  is  already  defined  in  method  printAndEncapsulate(CharSequence,int,int)  [CONTEXT]  start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }  pos++;  }    if  (pos  >  start)  {  out.append(value,  start,  pos);  }  }  void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  [BUGGY]  int  end  =  offset  +  len;int  start  =  offset;  [BUGGY]  int  pos  =  offset;  int  end  =  offset  +  len;  printSep();  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();  if  (len  <=  0)  {          if  (first)  {  quote  =  true;    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  int  pos  =  offset;	[BUG]  [BUGGY]  short  pos  =  offset;[CE]  possible  loss  of  precision  [CONTEXT]  }  pos++;  }    if  (pos  >  start)  {  out.append(value,  start,  pos);  }  }  void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  [BUGGY]  short  pos  =  offset;  [BUGGY]  int  end  =  offset  +  len;  printSep();  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();  if  (len  <=  0)  {          if  (first)  {  quote  =  true;  }    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P1_Replace_Type]
[PATCH]  int  pos  =  offset;	[BUG]  [BUGGY]  int  pos  =  start;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  }  pos++;  }    if  (pos  >  start)  {  out.append(value,  start,  pos);  }  }  void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  [BUGGY]  int  pos  =  start;  [BUGGY]  int  end  =  offset  +  len;  printSep();  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();  if  (len  <=  0)  {          if  (first)  {  quote  =  true;  }    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P5_Replace_Variable]
[PATCH]  int  pos  =  offset;	[BUG]  [BUGGY]  int  start  =  offset;int  pos  =  offset;[CE]  variable  start  is  already  defined  in  method  printAndEncapsulate(CharSequence,int,int)  [CONTEXT]  }  pos++;  }    if  (pos  >  start)  {  out.append(value,  start,  pos);  }  }  void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  [BUGGY]  int  start  =  offset;int  pos  =  offset;  [BUGGY]  int  end  =  offset  +  len;  printSep();  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();  if  (len  <=  0)  {          if  (first)  {  quote  =  true;  }    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  int  pos  =  offset;	[BUG]  [BUGGY]  int  end  =  offset  +  len;int  pos  =  offset;[CE]  variable  end  is  already  defined  in  method  printAndEncapsulate(CharSequence,int,int)  [CONTEXT]  }  pos++;  }    if  (pos  >  start)  {  out.append(value,  start,  pos);  }  }  void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  [BUGGY]  int  end  =  offset  +  len;int  pos  =  offset;  [BUGGY]  int  end  =  offset  +  len;  printSep();  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();  if  (len  <=  0)  {          if  (first)  {  quote  =  true;  }    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  int  end  =  offset  +  len;	[BUG]  [BUGGY]  short  end  =  offset  +  len;[CE]  possible  loss  of  precision  [CONTEXT]  pos++;  }    if  (pos  >  start)  {  out.append(value,  start,  pos);  }  }  void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  [BUGGY]  short  end  =  offset  +  len;  [BUGGY]    printSep();  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();  if  (len  <=  0)  {          if  (first)  {  quote  =  true;  }  }  else  {    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P1_Replace_Type]
[PATCH]  int  end  =  offset  +  len;	[BUG]  [BUGGY]  int  end  =  start  +  len;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  pos++;  }    if  (pos  >  start)  {  out.append(value,  start,  pos);  }  }  void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  [BUGGY]  int  end  =  start  +  len;  [BUGGY]    printSep();  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();  if  (len  <=  0)  {          if  (first)  {  quote  =  true;  }  }  else  {    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P5_Replace_Variable]
[PATCH]  int  end  =  offset  +  len;	[BUG]  [BUGGY]  int  end  =  offset  +  start;[FE]  String  index  out  of  range:  -1  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]  pos++;  }    if  (pos  >  start)  {  out.append(value,  start,  pos);  }  }  void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  [BUGGY]  int  end  =  offset  +  start;  [BUGGY]    printSep();  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();  if  (len  <=  0)  {          if  (first)  {  quote  =  true;  }  }  else  {    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P5_Replace_Variable]
[PATCH]  int  end  =  offset  +  len;	[BUG]  [BUGGY]  int  end  =  len  +  offset;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  pos++;  }    if  (pos  >  start)  {  out.append(value,  start,  pos);  }  }  void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  [BUGGY]  int  end  =  len  +  offset;  [BUGGY]    printSep();  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();  if  (len  <=  0)  {          if  (first)  {  quote  =  true;  }  }  else  {    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P5_Replace_Variable]
[PATCH]  int  end  =  offset  +  len;	[BUG]  [BUGGY]  int  pos  =  offset;int  end  =  offset  +  len;[CE]  variable  pos  is  already  defined  in  method  printAndEncapsulate(CharSequence,int,int)  [CONTEXT]  pos++;  }    if  (pos  >  start)  {  out.append(value,  start,  pos);  }  }  void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  [BUGGY]  int  pos  =  offset;int  end  =  offset  +  len;  [BUGGY]    printSep();  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();  if  (len  <=  0)  {          if  (first)  {  quote  =  true;  }  }  else  {    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  int  end  =  offset  +  len;	[BUG]  [BUGGY]  int  start  =  offset;int  end  =  offset  +  len;[CE]  variable  start  is  already  defined  in  method  printAndEncapsulate(CharSequence,int,int)  [CONTEXT]  pos++;  }    if  (pos  >  start)  {  out.append(value,  start,  pos);  }  }  void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  [BUGGY]  int  start  =  offset;int  end  =  offset  +  len;  [BUGGY]    printSep();  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();  if  (len  <=  0)  {          if  (first)  {  quote  =  true;  }  }  else  {    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  printSep  (  )  ;	[BUG]  [BUGGY]  println(  )  ;[FE]  expected:<a[,b,]c>  but  was:<a[  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]  }    if  (pos  >  start)  {  out.append(value,  start,  pos);  }  }  void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;  [BUGGY]  println(  )  ;  [BUGGY]    char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();  if  (len  <=  0)  {          if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);      [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P7_Replace_Invocation]
[PATCH]  printSep  (  )  ;	[BUG]  [BUGGY]  [FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  }    if  (pos  >  start)  {  out.append(value,  start,  pos);  }  }  void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;  [BUGGY]  [BUGGY]    char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();  if  (len  <=  0)  {          if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P14_Delete_Statement]
[PATCH]  printSep  (  )  ;	[BUG]  [BUGGY]  println(  )  ;printSep(  )  ;[FE]  expected:<a[,b,]c>  but  was:<a[  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]  }    if  (pos  >  start)  {  out.append(value,  start,  pos);  }  }  void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;  [BUGGY]  println(  )  ;printSep(  )  ;  [BUGGY]    char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();  if  (len  <=  0)  {          if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);      [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  printSep  (  )  ;	[BUG]  [BUGGY]  print(  value)  ;printSep(  )  ;[CE]  no  suitable  method  found  for  print(CharSequence)  [CONTEXT]  }    if  (pos  >  start)  {  out.append(value,  start,  pos);  }  }  void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;  [BUGGY]  print(  value)  ;printSep(  )  ;  [BUGGY]    char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();  if  (len  <=  0)  {          if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);      [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  char  delim  =  format.getDelimiter  (  )  ;	[BUG]  [BUGGY]  int  delim  =  format.getDelimiter(  )  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]    if  (pos  >  start)  {  out.append(value,  start,  pos);  }  }  void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;  printSep();  [BUGGY]  int  delim  =  format.getDelimiter(  )  ;  [BUGGY]  char  encapsulator  =  format.getEncapsulator();  if  (len  <=  0)  {          if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);    if  (first    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P1_Replace_Type]
[PATCH]  char  delim  =  format.getDelimiter  (  )  ;	[BUG]  [BUGGY]  char  delim  =  format.getEscape(  )  ;[FE]  expected:<[ "x,y "],z>  but  was:<[x,y],z>  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]    if  (pos  >  start)  {  out.append(value,  start,  pos);  }  }  void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;  printSep();  [BUGGY]  char  delim  =  format.getEscape(  )  ;  [BUGGY]  char  encapsulator  =  format.getEncapsulator();  if  (len  <=  0)  {          if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);    if  (first    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P7_Replace_Invocation]
[PATCH]  char  delim  =  format.getDelimiter  (  )  ;	[BUG]  [BUGGY]  char  escape  =  format.getEscape(  )  ;char  delim  =  format.getDelimiter(  )  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]    if  (pos  >  start)  {  out.append(value,  start,  pos);  }  }  void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;  printSep();  [BUGGY]  char  escape  =  format.getEscape(  )  ;char  delim  =  format.getDelimiter(  )  ;  [BUGGY]  char  encapsulator  =  format.getEncapsulator();  if  (len  <=  0)  {          if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);    if  (first    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  char  delim  =  format.getDelimiter  (  )  ;	[BUG]  [BUGGY]  char  encapsulator  =  format.getEncapsulator(  )  ;char  delim  =  format.getDelimiter(  )  ;[CE]  variable  encapsulator  is  already  defined  in  method  printAndEncapsulate(CharSequence,int,int)  [CONTEXT]    if  (pos  >  start)  {  out.append(value,  start,  pos);  }  }  void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;  printSep();  [BUGGY]  char  encapsulator  =  format.getEncapsulator(  )  ;char  delim  =  format.getDelimiter(  )  ;  [BUGGY]  char  encapsulator  =  format.getEncapsulator();  if  (len  <=  0)  {          if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);    if  (first    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  char  delim  =  format.getDelimiter  (  )  ;	[BUG]  [BUGGY]  this.format.validate(  )  ;char  delim  =  format.getDelimiter(  )  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]    if  (pos  >  start)  {  out.append(value,  start,  pos);  }  }  void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;  printSep();  [BUGGY]  this.format.validate(  )  ;char  delim  =  format.getDelimiter(  )  ;  [BUGGY]  char  encapsulator  =  format.getEncapsulator();  if  (len  <=  0)  {          if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);    if  (first    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  char  delim  =  format.getDelimiter  (  )  ;	[BUG]  [BUGGY]  out.append(  format.getDelimiter(  )  )  ;char  delim  =  format.getDelimiter(  )  ;[FE]  expected:<[a,b],c>  but  was:<[,a,,b,],c>  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]    if  (pos  >  start)  {  out.append(value,  start,  pos);  }  }  void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;  printSep();  [BUGGY]  out.append(  format.getDelimiter(  )  )  ;char  delim  =  format.getDelimiter(  )  ;  [BUGGY]  char  encapsulator  =  format.getEncapsulator();  if  (len  <=  0)  {          if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);    if  (first    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  char  encapsulator  =  format.getEncapsulator  (  )  ;	[BUG]  [BUGGY]  int  encapsulator  =  format.getEncapsulator(  )  ;[CE]  no  suitable  method  found  for  append(int)  [CONTEXT]  if  (pos  >  start)  {  out.append(value,  start,  pos);  }  }  void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;  printSep();  char  delim  =  format.getDelimiter();  [BUGGY]  int  encapsulator  =  format.getEncapsulator(  )  ;  [BUGGY]    if  (len  <=  0)  {          if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);    if  (first  &&  (c  <  '0'    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P1_Replace_Type]
[PATCH]  char  encapsulator  =  format.getEncapsulator  (  )  ;	[BUG]  [BUGGY]  char  encapsulator  =  format.isEncapsulating(  )  ;[CE]  incompatible  types  [CONTEXT]  if  (pos  >  start)  {  out.append(value,  start,  pos);  }  }  void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;  printSep();  char  delim  =  format.getDelimiter();  [BUGGY]  char  encapsulator  =  format.isEncapsulating(  )  ;  [BUGGY]    if  (len  <=  0)  {          if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);    if  (first  &&  (c  <  '0'    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P7_Replace_Invocation]
[PATCH]  char  encapsulator  =  format.getEncapsulator  (  )  ;	[BUG]  [BUGGY]  char  delim  =  format.getDelimiter(  )  ;char  encapsulator  =  format.getEncapsulator(  )  ;[CE]  variable  delim  is  already  defined  in  method  printAndEncapsulate(CharSequence,int,int)  [CONTEXT]  if  (pos  >  start)  {  out.append(value,  start,  pos);  }  }  void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;  printSep();  char  delim  =  format.getDelimiter();  [BUGGY]  char  delim  =  format.getDelimiter(  )  ;char  encapsulator  =  format.getEncapsulator(  )  ;  [BUGGY]    if  (len  <=  0)  {          if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);    if  (first  &&  (c  <  '0'    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  char  encapsulator  =  format.getEncapsulator  (  )  ;	[BUG]  [BUGGY]  char  escape  =  format.getEscape(  )  ;char  encapsulator  =  format.getEncapsulator(  )  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  if  (pos  >  start)  {  out.append(value,  start,  pos);  }  }  void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;  printSep();  char  delim  =  format.getDelimiter();  [BUGGY]  char  escape  =  format.getEscape(  )  ;char  encapsulator  =  format.getEncapsulator(  )  ;  [BUGGY]    if  (len  <=  0)  {          if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);    if  (first  &&  (c  <  '0'    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  while  (  pos  <  end  )  {	[BUG]  [BUGGY]  while  (  pos  ==  end)  {[FE]  expected:<[ "x,y "],z>  but  was:<[x,y],z>  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]    if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;    }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  [BUGGY]  while  (  pos  ==  end)  {  [BUGGY]  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);        if  (c  <=  '  ')  {    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P2_Replace_Operator]
[PATCH]  while  (  pos  <  end  )  {	[BUG]  [BUGGY]  while  (  start  <  end)  {[FE]  String  index  out  of  range:  1  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]    if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;    }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  [BUGGY]  while  (  start  <  end)  {  [BUGGY]  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);        if  (c  <=  '  ')  {    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P5_Replace_Variable]
[PATCH]  while  (  pos  <  end  )  {	[BUG]  [BUGGY]  while  (  pos  <  start)  {[FE]  expected:<[ "x,y "],z>  but  was:<[x,y],z>  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]    if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;    }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  [BUGGY]  while  (  pos  <  start)  {  [BUGGY]  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);        if  (c  <=  '  ')  {    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P5_Replace_Variable]
[PATCH]  while  (  pos  <  end  )  {	[BUG]  [BUGGY]  while  (  end  <  pos)  {[FE]  expected:<[ "x,y "],z>  but  was:<[x,y],z>  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]    if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;    }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  [BUGGY]  while  (  end  <  pos)  {  [BUGGY]  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);        if  (c  <=  '  ')  {    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P5_Replace_Variable]
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  (  (  (  c  ==  '\n')  ||  (  c  ==  '\r')  )  ||  (  c  ==  encapsulator)  )  ||  (  c  ==  delim)  )  {      quote  =  true;      break;  }[CE]  illegal  start  of  type  [CONTEXT]    if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;    }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  [BUGGY]  if  (  (  (  (  c  ==  '\n')  ||  (  c  ==  '\r')  )  ||  (  c  ==  encapsulator)  )  ||  (  c  ==  delim)  )  {      quote  =  true;      break;  }  [BUGGY]  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);        if  (c  <=  '  ')  {    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P13_Insert_Block]
[PATCH]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUG]  [BUGGY]  if  (  c  ==  '\n'  &&  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;    }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if  (  c  ==  '\n'  &&  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  [BUGGY]  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);        if  (c  <=  '  ')  {  quote  =  true;  }    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P2_Replace_Operator]
[PATCH]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUG]  [BUGGY]  if  (  c  >=  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {[FE]  expected:<[a,b,c]>  but  was:<[ "a ", "b ", "c "]>  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]  if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;    }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if  (  c  >=  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  [BUGGY]  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);        if  (c  <=  '  ')  {  quote  =  true;  }    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P2_Replace_Operator]
[PATCH]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUG]  [BUGGY]  if  (  c  ==  '\n'  ||  c  !=  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {[FE]  expected:<[a,b,c]>  but  was:<[ "a ", "b ", "c "]>  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]  if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;    }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if  (  c  ==  '\n'  ||  c  !=  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  [BUGGY]  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);        if  (c  <=  '  ')  {  quote  =  true;  }    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P2_Replace_Operator]
[PATCH]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUG]  [BUGGY]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  <=  encapsulator  ||  c  ==  delim)  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;    }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  <=  encapsulator  ||  c  ==  delim)  {  [BUGGY]  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);        if  (c  <=  '  ')  {  quote  =  true;  }    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P2_Replace_Operator]
[PATCH]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUG]  [BUGGY]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  >=  delim)  {[FE]  expected:<[a,b,c]>  but  was:<[ "a ", "b ", "c "]>  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]  if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;    }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  >=  delim)  {  [BUGGY]  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);        if  (c  <=  '  ')  {  quote  =  true;  }    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P2_Replace_Operator]
[PATCH]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUG]  [BUGGY]  if  (  delim  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;    }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if  (  delim  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  [BUGGY]  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);        if  (c  <=  '  ')  {  quote  =  true;  }    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P5_Replace_Variable]
[PATCH]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUG]  [BUGGY]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  delim  ||  c  ==  delim)  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;    }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  delim  ||  c  ==  delim)  {  [BUGGY]  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);        if  (c  <=  '  ')  {  quote  =  true;  }    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P5_Replace_Variable]
[PATCH]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUG]  [BUGGY]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  c)  {[FE]  expected:<[a,b,c]>  but  was:<[ "a ", "b ", "c "]>  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]  if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;    }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  c)  {  [BUGGY]  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);        if  (c  <=  '  ')  {  quote  =  true;  }    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P5_Replace_Variable]
[PATCH]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUG]  [BUGGY]  if  (  delim  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  c)  {[FE]  expected:<[a,b,c]>  but  was:<[ "a ", "b ", "c "]>  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]  if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;    }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if  (  delim  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  c)  {  [BUGGY]  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);        if  (c  <=  '  ')  {  quote  =  true;  }    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P5_Replace_Variable]
[PATCH]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUG]  [BUGGY]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  delim  ||  c  ==  encapsulator)  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;    }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  delim  ||  c  ==  encapsulator)  {  [BUGGY]  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);        if  (c  <=  '  ')  {  quote  =  true;  }    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P5_Replace_Variable]
[PATCH]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUG]  [BUGGY]  if  (  c  ==  '\n')  {[FE]  expected:<[ "x,y "],z>  but  was:<[x,y],z>  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]  if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;    }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if  (  c  ==  '\n')  {  [BUGGY]  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);        if  (c  <=  '  ')  {  quote  =  true;  }    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P6_Replace_Expression]
[PATCH]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUG]  [BUGGY]  if  (  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;    }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if  (  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  [BUGGY]  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);        if  (c  <=  '  ')  {  quote  =  true;  }    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P6_Replace_Expression]
[PATCH]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUG]  [BUGGY]  if  (((c  ==  '\n')  ||(c  ==  '\r')  ||  c  ==  encapsulator))  {[FE]  expected:<[ "x,y "],z>  but  was:<[x,y],z>  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]  if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;    }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if  (((c  ==  '\n')  ||(c  ==  '\r')  ||  c  ==  encapsulator))  {  [BUGGY]  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);        if  (c  <=  '  ')  {  quote  =  true;  }    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P6_Replace_Expression]
[PATCH]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUG]  [BUGGY]  if  ((c  ==  '\n'  ||  c  ==  '\r'))  {[FE]  expected:<[ "x,y "],z>  but  was:<[x,y],z>  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]  if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;    }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if  ((c  ==  '\n'  ||  c  ==  '\r'))  {  [BUGGY]  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);        if  (c  <=  '  ')  {  quote  =  true;  }    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P6_Replace_Expression]
[PATCH]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUG]  [BUGGY]  if  (  c  ==  '\r')  {[FE]  expected:<[ "x,y "],z>  but  was:<[x,y],z>  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]  if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;    }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if  (  c  ==  '\r')  {  [BUGGY]  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);        if  (c  <=  '  ')  {  quote  =  true;  }    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P6_Replace_Expression]
[PATCH]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUG]  [BUGGY]  if  (  c  ==  encapsulator)  {[FE]  expected:<[ "x,y "],z>  but  was:<[x,y],z>  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]  if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;    }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if  (  c  ==  encapsulator)  {  [BUGGY]  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);        if  (c  <=  '  ')  {  quote  =  true;  }    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P6_Replace_Expression]
[PATCH]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUG]  [BUGGY]  if  (  c  ==  delim)  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;    }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if  (  c  ==  delim)  {  [BUGGY]  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);        if  (c  <=  '  ')  {  quote  =  true;  }    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P6_Replace_Expression]
[PATCH]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUG]  [BUGGY]  if  (  c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {[CE]  cannot  find  symbol  escape  [CONTEXT]  if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;    }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if  (  c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {  [BUGGY]  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);        if  (c  <=  '  ')  {  quote  =  true;  }    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P9_Replace_Statement]
[PATCH]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {  quote  =  true;  break;  }	[BUG]  [BUGGY]  quote  =  true;  break;[CE]  illegal  start  of  expression  [CONTEXT]  if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;    }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  quote  =  true;  break;  [BUGGY]    quote  =  true;  break;    pos++;  }  if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);        if  (c  <=  '  ')  {  quote  =  true;    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P15_Unwrap_Block]
[PATCH]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {  quote  =  true;  break;  }	[BUG]  [BUGGY]  [CE]  illegal  start  of  expression  [CONTEXT]  if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;    }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  [BUGGY]      pos++;  }  if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);        if  (c  <=  '  ')  {  quote  =  true;    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P16_Remove_Block]
[PATCH]  quote  =  true;	[BUG]  [BUGGY]  quote  =  false;[FE]  expected:<[ "x,y "],z>  but  was:<[x,y],z>  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;    }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  [BUGGY]  quote  =  false;  [BUGGY]  break;  }  pos++;  }  if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);        if  (c  <=  '  ')  {  quote  =  true;  }  }    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P3_Replace_Literal]
[PATCH]  quote  =  true;	[BUG]  [BUGGY]  newLine  =  true;quote  =  true;[FE]  expected:< "x,y "[,]z>  but  was:< "x,y "[]z>  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;    }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  [BUGGY]  newLine  =  true;quote  =  true;  [BUGGY]  break;  }  pos++;  }  if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);        if  (c  <=  '  ')  {  quote  =  true;  }  }    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  c  =  value.charAt  (  pos  )  ;	[BUG]  [BUGGY]  c  =  value.charAt(  start)  ;[FE]  expected:<[ "x,y "],z>  but  was:<[x,y],z>  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]    if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;    }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  while  (pos  <  end)  {  [BUGGY]  c  =  value.charAt(  start)  ;  [BUGGY]  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);        if  (c  <=  '  ')  {  quote  =  true;    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P5_Replace_Variable]
[PATCH]  c  =  value.charAt  (  pos  )  ;	[BUG]  [BUGGY]  c  =  pos.charAt(  value)  ;[CE]  int  cannot  be  dereferenced  [CONTEXT]    if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;    }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  while  (pos  <  end)  {  [BUGGY]  c  =  pos.charAt(  value)  ;  [BUGGY]  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);        if  (c  <=  '  ')  {  quote  =  true;    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P5_Replace_Variable]
[PATCH]  c  =  value.charAt  (  pos  )  ;	[BUG]  [BUGGY]  c  =  null.charAt(  pos)  ;[CE]  <null>  cannot  be  dereferenced  [CONTEXT]    if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;    }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  while  (pos  <  end)  {  [BUGGY]  c  =  null.charAt(  pos)  ;  [BUGGY]  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);        if  (c  <=  '  ')  {  quote  =  true;    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P8_Replace_Mix]
[PATCH]  c  =  value.charAt  (  pos  )  ;	[BUG]  [BUGGY]  [FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]    if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;    }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  while  (pos  <  end)  {  [BUGGY]  [BUGGY]    if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);        if  (c  <=  '  ')  {    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P14_Delete_Statement]
[PATCH]  c  =  value.charAt  (  pos  )  ;	[BUG]  [BUGGY]  char  c  =  value.charAt(  pos)  ;c  =  value.charAt(  pos)  ;[CE]  variable  c  is  already  defined  in  method  printAndEncapsulate(CharSequence,int,int)  [CONTEXT]    if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;    }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  while  (pos  <  end)  {  [BUGGY]  char  c  =  value.charAt(  pos)  ;c  =  value.charAt(  pos)  ;  [BUGGY]  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);        if  (c  <=  '  ')  {  quote  =  true;    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  c  =  value.charAt  (  pos  )  ;	[BUG]  [BUGGY]  char  c  =  comment.charAt(  i)  ;c  =  value.charAt(  pos)  ;[CE]  variable  c  is  already  defined  in  method  printAndEncapsulate(CharSequence,int,int)  [CONTEXT]    if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;    }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  while  (pos  <  end)  {  [BUGGY]  char  c  =  comment.charAt(  i)  ;c  =  value.charAt(  pos)  ;  [BUGGY]  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);        if  (c  <=  '  ')  {  quote  =  true;    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  if  (  len  <=  0  )  {	[BUG]  [BUGGY]  if  (  len  <  0)  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  }  }  void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;  printSep();  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();  [BUGGY]  if  (  len  <  0)  {  [BUGGY]          if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);    if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P2_Replace_Operator]
[PATCH]  if  (  len  <=  0  )  {	[BUG]  [BUGGY]  if  (  len  <=  5)  {[FE]  expected:<[a],b,c>  but  was:<[ "a "],b,c>  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]  }  }  void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;  printSep();  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();  [BUGGY]  if  (  len  <=  5)  {  [BUGGY]          if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);    if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P3_Replace_Literal]
[PATCH]  if  (  len  <=  0  )  {	[BUG]  [BUGGY]  if  (  pos  <=  0)  {[FE]  expected:<[a],b,c>  but  was:<[ "a "],b,c>  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]  }  }  void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;  printSep();  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();  [BUGGY]  if  (  pos  <=  0)  {  [BUGGY]          if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);    if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P5_Replace_Variable]
[PATCH]  if  (  len  <=  0  )  {	[BUG]  [BUGGY]  if  (  first  &&(((c  <  '0')  ||((c  >  '9')  &&(c  <  'A')))  ||((c  >  'Z')  &&(c  <  'a')))  ||(c  >  'z'))  {[CE]  cannot  find  symbol  c  [CONTEXT]  }  }  void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;  printSep();  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();  [BUGGY]  if  (  first  &&(((c  <  '0')  ||((c  >  '9')  &&(c  <  'A')))  ||((c  >  'Z')  &&(c  <  'a')))  ||(c  >  'z'))  {  [BUGGY]          if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);    if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P6_Replace_Expression]
[PATCH]  if  (  len  <=  0  )  {	[BUG]  [BUGGY]  if  ((((c  <  '0')  ||((c  >  '9')  &&(c  <  'A')))  ||((c  >  'Z')  &&(c  <  'a'))  ||  c  >  'z'))  {[CE]  cannot  find  symbol  c  [CONTEXT]  }  }  void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;  printSep();  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();  [BUGGY]  if  ((((c  <  '0')  ||((c  >  '9')  &&(c  <  'A')))  ||((c  >  'Z')  &&(c  <  'a'))  ||  c  >  'z'))  {  [BUGGY]          if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);    if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P6_Replace_Expression]
[PATCH]  if  (  len  <=  0  )  {	[BUG]  [BUGGY]  if  (((c  <  '0')  ||((c  >  '9')  &&(c  <  'A'))  ||(c  >  'Z')  &&(c  <  'a')))  {[CE]  cannot  find  symbol  c  [CONTEXT]  }  }  void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;  printSep();  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();  [BUGGY]  if  (((c  <  '0')  ||((c  >  '9')  &&(c  <  'A'))  ||(c  >  'Z')  &&(c  <  'a')))  {  [BUGGY]          if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);    if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P6_Replace_Expression]
[PATCH]  if  (  len  <=  0  )  {	[BUG]  [BUGGY]  if  ((c  <  '0'  ||(c  >  '9')  &&(c  <  'A')))  {[CE]  cannot  find  symbol  c  [CONTEXT]  }  }  void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;  printSep();  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();  [BUGGY]  if  ((c  <  '0'  ||(c  >  '9')  &&(c  <  'A')))  {  [BUGGY]          if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);    if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P6_Replace_Expression]
[PATCH]  if  (  len  <=  0  )  {	[BUG]  [BUGGY]  if  (  c  <  '0')  {[CE]  cannot  find  symbol  c  [CONTEXT]  }  }  void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;  printSep();  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();  [BUGGY]  if  (  c  <  '0')  {  [BUGGY]          if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);    if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P6_Replace_Expression]
[PATCH]  if  (  len  <=  0  )  {	[BUG]  [BUGGY]  if  ((c  >  '9'  &&  c  <  'A'))  {[CE]  cannot  find  symbol  c  [CONTEXT]  }  }  void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;  printSep();  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();  [BUGGY]  if  ((c  >  '9'  &&  c  <  'A'))  {  [BUGGY]          if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);    if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P6_Replace_Expression]
[PATCH]  if  (  len  <=  0  )  {	[BUG]  [BUGGY]  if  (  c  >  '9')  {[CE]  cannot  find  symbol  c  [CONTEXT]  }  }  void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;  printSep();  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();  [BUGGY]  if  (  c  >  '9')  {  [BUGGY]          if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);    if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P6_Replace_Expression]
[PATCH]  if  (  len  <=  0  )  {	[BUG]  [BUGGY]  if  (  c  <  'A')  {[CE]  cannot  find  symbol  c  [CONTEXT]  }  }  void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;  printSep();  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();  [BUGGY]  if  (  c  <  'A')  {  [BUGGY]          if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);    if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P6_Replace_Expression]
[PATCH]  if  (  len  <=  0  )  {	[BUG]  [BUGGY]  if  ((c  >  'Z'  &&  c  <  'a'))  {[CE]  cannot  find  symbol  c  [CONTEXT]  }  }  void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;  printSep();  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();  [BUGGY]  if  ((c  >  'Z'  &&  c  <  'a'))  {  [BUGGY]          if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);    if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P6_Replace_Expression]
[PATCH]  if  (  len  <=  0  )  {	[BUG]  [BUGGY]  if  (  c  >  'Z')  {[CE]  cannot  find  symbol  c  [CONTEXT]  }  }  void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;  printSep();  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();  [BUGGY]  if  (  c  >  'Z')  {  [BUGGY]          if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);    if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P6_Replace_Expression]
[PATCH]  if  (  len  <=  0  )  {	[BUG]  [BUGGY]  if  (  c  <  'a')  {[CE]  cannot  find  symbol  c  [CONTEXT]  }  }  void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;  printSep();  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();  [BUGGY]  if  (  c  <  'a')  {  [BUGGY]          if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);    if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P6_Replace_Expression]
[PATCH]  if  (  len  <=  0  )  {	[BUG]  [BUGGY]  if  (  c  >  'z')  {[CE]  cannot  find  symbol  c  [CONTEXT]  }  }  void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;  printSep();  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();  [BUGGY]  if  (  c  >  'z')  {  [BUGGY]          if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);    if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P6_Replace_Expression]
[PATCH]  if  (  len  <=  0  )  {	[BUG]  [BUGGY]  if  (  c  <=  '#')  {[CE]  cannot  find  symbol  c  [CONTEXT]  }  }  void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;  printSep();  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();  [BUGGY]  if  (  c  <=  '#')  {  [BUGGY]          if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);    if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P6_Replace_Expression]
[PATCH]  if  (  len  <=  0  )  {	[BUG]  [BUGGY]  if  (  pos  <  end)  {[FE]  expected:<[a],b,c>  but  was:<[ "a "],b,c>  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]  }  }  void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;  printSep();  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();  [BUGGY]  if  (  pos  <  end)  {  [BUGGY]          if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);    if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P6_Replace_Expression]
[PATCH]  if  (  len  <=  0  )  {	[BUG]  [BUGGY]  if  (((c  ==  '\n')  ||(c  ==  '\r'))  ||(c  ==  encapsulator)  ||  c  ==  delim)  {[CE]  cannot  find  symbol  c  [CONTEXT]  }  }  void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;  printSep();  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();  [BUGGY]  if  (((c  ==  '\n')  ||(c  ==  '\r'))  ||(c  ==  encapsulator)  ||  c  ==  delim)  {  [BUGGY]          if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);    if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P6_Replace_Expression]
[PATCH]  if  (  len  <=  0  )  {	[BUG]  [BUGGY]  if  (((c  ==  '\n')  ||(c  ==  '\r')  ||  c  ==  encapsulator))  {[CE]  cannot  find  symbol  c  [CONTEXT]  }  }  void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;  printSep();  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();  [BUGGY]  if  (((c  ==  '\n')  ||(c  ==  '\r')  ||  c  ==  encapsulator))  {  [BUGGY]          if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);    if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P6_Replace_Expression]
[PATCH]  if  (  len  <=  0  )  {	[BUG]  [BUGGY]  if  ((c  ==  '\n'  ||  c  ==  '\r'))  {[CE]  cannot  find  symbol  c  [CONTEXT]  }  }  void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;  printSep();  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();  [BUGGY]  if  ((c  ==  '\n'  ||  c  ==  '\r'))  {  [BUGGY]          if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);    if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P6_Replace_Expression]
[PATCH]  if  (  len  <=  0  )  {	[BUG]  [BUGGY]  if  (  c  ==  '\n')  {[CE]  cannot  find  symbol  c  [CONTEXT]  }  }  void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;  printSep();  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();  [BUGGY]  if  (  c  ==  '\n')  {  [BUGGY]          if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);    if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P6_Replace_Expression]
[PATCH]  if  (  len  <=  0  )  {	[BUG]  [BUGGY]  if  (  c  ==  '\r')  {[CE]  cannot  find  symbol  c  [CONTEXT]  }  }  void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;  printSep();  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();  [BUGGY]  if  (  c  ==  '\r')  {  [BUGGY]          if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);    if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P6_Replace_Expression]
[PATCH]  if  (  len  <=  0  )  {	[BUG]  [BUGGY]  if  (  c  ==  encapsulator)  {[CE]  cannot  find  symbol  c  [CONTEXT]  }  }  void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;  printSep();  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();  [BUGGY]  if  (  c  ==  encapsulator)  {  [BUGGY]          if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);    if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P6_Replace_Expression]
[PATCH]  if  (  len  <=  0  )  {	[BUG]  [BUGGY]  if  (  c  ==  delim)  {[CE]  cannot  find  symbol  c  [CONTEXT]  }  }  void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;  printSep();  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();  [BUGGY]  if  (  c  ==  delim)  {  [BUGGY]          if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);    if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P6_Replace_Expression]
[PATCH]  if  (  len  <=  0  )  {	[BUG]  [BUGGY]  if  (  end  -  1)  {[CE]  incompatible  types  [CONTEXT]  }  }  void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;  printSep();  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();  [BUGGY]  if  (  end  -  1)  {  [BUGGY]          if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);    if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P6_Replace_Expression]
[PATCH]  if  (  len  <=  0  )  {	[BUG]  [BUGGY]  if  (  c  <=  '  ')  {[CE]  cannot  find  symbol  c  [CONTEXT]  }  }  void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;  printSep();  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();  [BUGGY]  if  (  c  <=  '  ')  {  [BUGGY]          if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);    if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P6_Replace_Expression]
[PATCH]  if  (  len  <=  0  )  {	[BUG]  [BUGGY]  if  (  len  <=  1)  {[FE]  expected:<[a],b,c>  but  was:<[ "a "],b,c>  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]  }  }  void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;  printSep();  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();  [BUGGY]  if  (  len  <=  1)  {  [BUGGY]          if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);    if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P8_Replace_Mix]
[PATCH]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUG]  [BUGGY]  if  (  c  <=  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;    }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if  (  c  <=  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  [BUGGY]  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);        if  (c  <=  '  ')  {  quote  =  true;  }    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P2_Replace_Operator]
[PATCH]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUG]  [BUGGY]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  !=  encapsulator  ||  c  ==  delim)  {[FE]  expected:<[a,b,c]>  but  was:<[ "a ", "b ", "c "]>  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]  if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;    }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  !=  encapsulator  ||  c  ==  delim)  {  [BUGGY]  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);        if  (c  <=  '  ')  {  quote  =  true;  }    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P2_Replace_Operator]
[PATCH]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUG]  [BUGGY]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  <=  delim)  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;    }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  <=  delim)  {  [BUGGY]  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);        if  (c  <=  '  ')  {  quote  =  true;  }    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P2_Replace_Operator]
[PATCH]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUG]  [BUGGY]  if  (  encapsulator  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  c  ||  c  ==  delim)  {[FE]  expected:<[a,b,c]>  but  was:<[ "a ", "b ", "c "]>  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]  if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;    }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if  (  encapsulator  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  c  ||  c  ==  delim)  {  [BUGGY]  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);        if  (c  <=  '  ')  {  quote  =  true;  }    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P5_Replace_Variable]
[PATCH]  if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )	[BUG]  [BUGGY]  if  (  first  ||  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A')  ||  (  c  >  'Z'  &&  c  <  'a')[FE]  expected:<[a],b,c>  but  was:<[ "a "],b,c>  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();  if  (len  <=  0)  {          if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);    [BUGGY]  if  (  first  ||  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A')  ||  (  c  >  'Z'  &&  c  <  'a')  [BUGGY]      ||  (c  >  'z')))  {  quote  =  true;    }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P2_Replace_Operator]
[PATCH]  if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )	[BUG]  [BUGGY]  if  (  first  &&  (  c  <  '0'  &&  (  c  >  '9'  &&  c  <  'A')  ||  (  c  >  'Z'  &&  c  <  'a')[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();  if  (len  <=  0)  {          if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);    [BUGGY]  if  (  first  &&  (  c  <  '0'  &&  (  c  >  '9'  &&  c  <  'A')  ||  (  c  >  'Z'  &&  c  <  'a')  [BUGGY]      ||  (c  >  'z')))  {  quote  =  true;    }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P2_Replace_Operator]
[PATCH]  if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )	[BUG]  [BUGGY]  if  (  first  &&  (  c  <=  '0'  ||  (  c  >  '9'  &&  c  <  'A')  ||  (  c  >  'Z'  &&  c  <  'a')[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();  if  (len  <=  0)  {          if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);    [BUGGY]  if  (  first  &&  (  c  <=  '0'  ||  (  c  >  '9'  &&  c  <  'A')  ||  (  c  >  'Z'  &&  c  <  'a')  [BUGGY]      ||  (c  >  'z')))  {  quote  =  true;    }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P2_Replace_Operator]
[PATCH]  if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )	[BUG]  [BUGGY]  if  (  first  &&  (  c  <  '0'  ||  (  c  >=  '9'  &&  c  <  'A')  ||  (  c  >  'Z'  &&  c  <  'a')[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();  if  (len  <=  0)  {          if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);    [BUGGY]  if  (  first  &&  (  c  <  '0'  ||  (  c  >=  '9'  &&  c  <  'A')  ||  (  c  >  'Z'  &&  c  <  'a')  [BUGGY]      ||  (c  >  'z')))  {  quote  =  true;    }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P2_Replace_Operator]
[PATCH]  if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )	[BUG]  [BUGGY]  if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <=  'A')  ||  (  c  >  'Z'  &&  c  <  'a')[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();  if  (len  <=  0)  {          if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);    [BUGGY]  if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <=  'A')  ||  (  c  >  'Z'  &&  c  <  'a')  [BUGGY]      ||  (c  >  'z')))  {  quote  =  true;    }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P2_Replace_Operator]
[PATCH]  if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )	[BUG]  [BUGGY]  if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A')  ||  (  c  ==  'Z'  &&  c  <  'a')[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();  if  (len  <=  0)  {          if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);    [BUGGY]  if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A')  ||  (  c  ==  'Z'  &&  c  <  'a')  [BUGGY]      ||  (c  >  'z')))  {  quote  =  true;    }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P2_Replace_Operator]
[PATCH]  if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )	[BUG]  [BUGGY]  if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A')  ||  (  c  >  'Z'  &&  c  <=  'a')[FE]  expected:<[a],b,c>  but  was:<[ "a "],b,c>  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();  if  (len  <=  0)  {          if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);    [BUGGY]  if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A')  ||  (  c  >  'Z'  &&  c  <=  'a')  [BUGGY]      ||  (c  >  'z')))  {  quote  =  true;    }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P2_Replace_Operator]
[PATCH]  if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )	[BUG]  [BUGGY]  if  (  first  &&  (  encapsulator  <  '0'  ||  (  c  >  '9'  &&  c  <  'A')  ||  (  c  >  'Z'  &&  c  <  'a')[FE]  expected:<[a],b,c>  but  was:<[ "a "],b,c>  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();  if  (len  <=  0)  {          if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);    [BUGGY]  if  (  first  &&  (  encapsulator  <  '0'  ||  (  c  >  '9'  &&  c  <  'A')  ||  (  c  >  'Z'  &&  c  <  'a')  [BUGGY]      ||  (c  >  'z')))  {  quote  =  true;    }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P5_Replace_Variable]
[PATCH]  if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )	[BUG]  [BUGGY]  if  ((((c  <  '0')  ||((c  >  '9')  &&(c  <  'A')))  ||((c  >  'Z')  &&(c  <  'a'))  ||  c  >  'z'))[CE]  illegal  start  of  expression  [CONTEXT]  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();  if  (len  <=  0)  {          if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);    [BUGGY]  if  ((((c  <  '0')  ||((c  >  '9')  &&(c  <  'A')))  ||((c  >  'Z')  &&(c  <  'a'))  ||  c  >  'z'))  [BUGGY]      ||  (c  >  'z')))  {  quote  =  true;    }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P6_Replace_Expression]
[PATCH]  if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )	[BUG]  [BUGGY]  if  (((c  <  '0')  ||((c  >  '9')  &&(c  <  'A'))  ||(c  >  'Z')  &&(c  <  'a')))[CE]  illegal  start  of  expression  [CONTEXT]  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();  if  (len  <=  0)  {          if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);    [BUGGY]  if  (((c  <  '0')  ||((c  >  '9')  &&(c  <  'A'))  ||(c  >  'Z')  &&(c  <  'a')))  [BUGGY]      ||  (c  >  'z')))  {  quote  =  true;    }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P6_Replace_Expression]
[PATCH]  if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )	[BUG]  [BUGGY]  if  ((c  <  '0'  ||(c  >  '9')  &&(c  <  'A')))[CE]  illegal  start  of  expression  [CONTEXT]  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();  if  (len  <=  0)  {          if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);    [BUGGY]  if  ((c  <  '0'  ||(c  >  '9')  &&(c  <  'A')))  [BUGGY]      ||  (c  >  'z')))  {  quote  =  true;    }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P6_Replace_Expression]
[PATCH]  if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )	[BUG]  [BUGGY]  if  (  c  <  '0')[CE]  illegal  start  of  expression  [CONTEXT]  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();  if  (len  <=  0)  {          if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);    [BUGGY]  if  (  c  <  '0')  [BUGGY]      ||  (c  >  'z')))  {  quote  =  true;    }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P6_Replace_Expression]
[PATCH]  if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )	[BUG]  [BUGGY]  if  ((c  >  '9'  &&  c  <  'A'))[CE]  illegal  start  of  expression  [CONTEXT]  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();  if  (len  <=  0)  {          if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);    [BUGGY]  if  ((c  >  '9'  &&  c  <  'A'))  [BUGGY]      ||  (c  >  'z')))  {  quote  =  true;    }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P6_Replace_Expression]
[PATCH]  if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )	[BUG]  [BUGGY]  if  (  c  >  '9')[CE]  illegal  start  of  expression  [CONTEXT]  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();  if  (len  <=  0)  {          if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);    [BUGGY]  if  (  c  >  '9')  [BUGGY]      ||  (c  >  'z')))  {  quote  =  true;    }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P6_Replace_Expression]
[PATCH]  if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )	[BUG]  [BUGGY]  if  (  c  <  'A')[CE]  illegal  start  of  expression  [CONTEXT]  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();  if  (len  <=  0)  {          if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);    [BUGGY]  if  (  c  <  'A')  [BUGGY]      ||  (c  >  'z')))  {  quote  =  true;    }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P6_Replace_Expression]
[PATCH]  if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )	[BUG]  [BUGGY]  if  ((c  >  'Z'  &&  c  <  'a'))[CE]  illegal  start  of  expression  [CONTEXT]  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();  if  (len  <=  0)  {          if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);    [BUGGY]  if  ((c  >  'Z'  &&  c  <  'a'))  [BUGGY]      ||  (c  >  'z')))  {  quote  =  true;    }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P6_Replace_Expression]
[PATCH]  if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )	[BUG]  [BUGGY]  if  (  c  >  'Z')[CE]  illegal  start  of  expression  [CONTEXT]  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();  if  (len  <=  0)  {          if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);    [BUGGY]  if  (  c  >  'Z')  [BUGGY]      ||  (c  >  'z')))  {  quote  =  true;    }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P6_Replace_Expression]
[PATCH]  if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )	[BUG]  [BUGGY]  if  (  c  <  'a')[CE]  illegal  start  of  expression  [CONTEXT]  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();  if  (len  <=  0)  {          if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);    [BUGGY]  if  (  c  <  'a')  [BUGGY]      ||  (c  >  'z')))  {  quote  =  true;    }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P6_Replace_Expression]
[PATCH]  if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )	[BUG]  [BUGGY]  if  (  c  >  'z')[CE]  illegal  start  of  expression  [CONTEXT]  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();  if  (len  <=  0)  {          if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);    [BUGGY]  if  (  c  >  'z')  [BUGGY]      ||  (c  >  'z')))  {  quote  =  true;    }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P6_Replace_Expression]
[PATCH]  if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )	[BUG]  [BUGGY]  if  (  c  <=  '#')[CE]  illegal  start  of  expression  [CONTEXT]  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();  if  (len  <=  0)  {          if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);    [BUGGY]  if  (  c  <=  '#')  [BUGGY]      ||  (c  >  'z')))  {  quote  =  true;    }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P6_Replace_Expression]
[PATCH]  if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )	[BUG]  [BUGGY]  if  (  pos  <  end)[CE]  illegal  start  of  expression  [CONTEXT]  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();  if  (len  <=  0)  {          if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);    [BUGGY]  if  (  pos  <  end)  [BUGGY]      ||  (c  >  'z')))  {  quote  =  true;    }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P6_Replace_Expression]
[PATCH]  if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )	[BUG]  [BUGGY]  if  (((c  ==  '\n')  ||(c  ==  '\r'))  ||(c  ==  encapsulator)  ||  c  ==  delim)[CE]  illegal  start  of  expression  [CONTEXT]  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();  if  (len  <=  0)  {          if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);    [BUGGY]  if  (((c  ==  '\n')  ||(c  ==  '\r'))  ||(c  ==  encapsulator)  ||  c  ==  delim)  [BUGGY]      ||  (c  >  'z')))  {  quote  =  true;    }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P6_Replace_Expression]
[PATCH]  if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )	[BUG]  [BUGGY]  if  (((c  ==  '\n')  ||(c  ==  '\r')  ||  c  ==  encapsulator))[CE]  illegal  start  of  expression  [CONTEXT]  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();  if  (len  <=  0)  {          if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);    [BUGGY]  if  (((c  ==  '\n')  ||(c  ==  '\r')  ||  c  ==  encapsulator))  [BUGGY]      ||  (c  >  'z')))  {  quote  =  true;    }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P6_Replace_Expression]
[PATCH]  if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )	[BUG]  [BUGGY]  if  ((c  ==  '\n'  ||  c  ==  '\r'))[CE]  illegal  start  of  expression  [CONTEXT]  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();  if  (len  <=  0)  {          if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);    [BUGGY]  if  ((c  ==  '\n'  ||  c  ==  '\r'))  [BUGGY]      ||  (c  >  'z')))  {  quote  =  true;    }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P6_Replace_Expression]
[PATCH]  if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )	[BUG]  [BUGGY]  if  (  c  ==  '\n')[CE]  illegal  start  of  expression  [CONTEXT]  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();  if  (len  <=  0)  {          if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);    [BUGGY]  if  (  c  ==  '\n')  [BUGGY]      ||  (c  >  'z')))  {  quote  =  true;    }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P6_Replace_Expression]
[PATCH]  if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )	[BUG]  [BUGGY]  if  (  c  ==  '\r')[CE]  illegal  start  of  expression  [CONTEXT]  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();  if  (len  <=  0)  {          if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);    [BUGGY]  if  (  c  ==  '\r')  [BUGGY]      ||  (c  >  'z')))  {  quote  =  true;    }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P6_Replace_Expression]
[PATCH]  if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )	[BUG]  [BUGGY]  if  (  c  ==  encapsulator)[CE]  illegal  start  of  expression  [CONTEXT]  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();  if  (len  <=  0)  {          if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);    [BUGGY]  if  (  c  ==  encapsulator)  [BUGGY]      ||  (c  >  'z')))  {  quote  =  true;    }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P6_Replace_Expression]
[PATCH]  if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )	[BUG]  [BUGGY]  if  (  c  ==  delim)[CE]  illegal  start  of  expression  [CONTEXT]  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();  if  (len  <=  0)  {          if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);    [BUGGY]  if  (  c  ==  delim)  [BUGGY]      ||  (c  >  'z')))  {  quote  =  true;    }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P6_Replace_Expression]
[PATCH]  if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )	[BUG]  [BUGGY]  if  (  end  -  1)[CE]  illegal  start  of  expression  [CONTEXT]  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();  if  (len  <=  0)  {          if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);    [BUGGY]  if  (  end  -  1)  [BUGGY]      ||  (c  >  'z')))  {  quote  =  true;    }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P6_Replace_Expression]
[PATCH]  if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )	[BUG]  [BUGGY]  if  (  c  <=  '  ')[CE]  illegal  start  of  expression  [CONTEXT]  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();  if  (len  <=  0)  {          if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);    [BUGGY]  if  (  c  <=  '  ')  [BUGGY]      ||  (c  >  'z')))  {  quote  =  true;    }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P6_Replace_Expression]
[PATCH]  if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )	[BUG]  [BUGGY]  if  (  newLine  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A')  ||  (  c  >  'Z'  &&  c  <  'a')[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();  if  (len  <=  0)  {          if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);    [BUGGY]  if  (  newLine  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A')  ||  (  c  >  'Z'  &&  c  <  'a')  [BUGGY]      ||  (c  >  'z')))  {  quote  =  true;    }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P8_Replace_Mix]
[PATCH]  while  (  pos  <  end  )  {	[BUG]  [BUGGY]  while  (  pos  <=  end)  {[FE]  String  index  out  of  range:  1  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]    if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;    }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  [BUGGY]  while  (  pos  <=  end)  {  [BUGGY]  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);        if  (c  <=  '  ')  {    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P2_Replace_Operator]
[PATCH]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUG]  [BUGGY]  if  (  c  !=  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {[FE]  expected:<[a,b,c]>  but  was:<[ "a ", "b ", "c "]>  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]  if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;    }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if  (  c  !=  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  [BUGGY]  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);        if  (c  <=  '  ')  {  quote  =  true;  }    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P2_Replace_Operator]
[PATCH]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUG]  [BUGGY]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  <  encapsulator  ||  c  ==  delim)  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;    }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  <  encapsulator  ||  c  ==  delim)  {  [BUGGY]  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);        if  (c  <=  '  ')  {  quote  =  true;  }    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P2_Replace_Operator]
[PATCH]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUG]  [BUGGY]  if  (  encapsulator  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;    }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if  (  encapsulator  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  [BUGGY]  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);        if  (c  <=  '  ')  {  quote  =  true;  }    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P5_Replace_Variable]
[PATCH]  }  else  if  (  c  <=  '#'  )  {	[BUG]  [BUGGY]  }  else  if  (  c  >  '#')  {[FE]  expected:<[a,b,c]>  but  was:<[ "a ", "b ", "c "]>  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]    if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);    if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;    [BUGGY]  }  else  if  (  c  >  '#')  {  [BUGGY]        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P2_Replace_Operator]
[PATCH]  }  else  if  (  c  <=  '#'  )  {	[BUG]  [BUGGY]  }  else  if  (  c  <  '#')  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]    if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);    if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;    [BUGGY]  }  else  if  (  c  <  '#')  {  [BUGGY]        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P2_Replace_Operator]
[PATCH]  }  else  if  (  c  <=  '#'  )  {	[BUG]  [BUGGY]  }  else  if  (  delim  <=  '#')  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]    if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);    if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;    [BUGGY]  }  else  if  (  delim  <=  '#')  {  [BUGGY]        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P5_Replace_Variable]
[PATCH]  }  else  if  (  c  <=  '#'  )  {	[BUG]  [BUGGY]  }  else  if  (  pos  <  end)  {[FE]  expected:<[a,b,c]>  but  was:<[ "a ", "b ", "c "]>  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]    if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);    if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;    [BUGGY]  }  else  if  (  pos  <  end)  {  [BUGGY]        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P6_Replace_Expression]
[PATCH]  }  else  if  (  c  <=  '#'  )  {	[BUG]  [BUGGY]  }  else  if  (((c  ==  '\n')  ||(c  ==  '\r'))  ||(c  ==  encapsulator)  ||  c  ==  delim)  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]    if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);    if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;    [BUGGY]  }  else  if  (((c  ==  '\n')  ||(c  ==  '\r'))  ||(c  ==  encapsulator)  ||  c  ==  delim)  {  [BUGGY]        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P6_Replace_Expression]
[PATCH]  }  else  if  (  c  <=  '#'  )  {	[BUG]  [BUGGY]  }  else  if  (((c  ==  '\n')  ||(c  ==  '\r')  ||  c  ==  encapsulator))  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]    if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);    if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;    [BUGGY]  }  else  if  (((c  ==  '\n')  ||(c  ==  '\r')  ||  c  ==  encapsulator))  {  [BUGGY]        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P6_Replace_Expression]
[PATCH]  }  else  if  (  c  <=  '#'  )  {	[BUG]  [BUGGY]  }  else  if  ((c  ==  '\n'  ||  c  ==  '\r'))  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]    if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);    if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;    [BUGGY]  }  else  if  ((c  ==  '\n'  ||  c  ==  '\r'))  {  [BUGGY]        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P6_Replace_Expression]
[PATCH]  }  else  if  (  c  <=  '#'  )  {	[BUG]  [BUGGY]  }  else  if  (  c  ==  '\n')  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]    if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);    if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;    [BUGGY]  }  else  if  (  c  ==  '\n')  {  [BUGGY]        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P6_Replace_Expression]
[PATCH]  }  else  if  (  c  <=  '#'  )  {	[BUG]  [BUGGY]  }  else  if  (  c  ==  '\r')  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]    if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);    if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;    [BUGGY]  }  else  if  (  c  ==  '\r')  {  [BUGGY]        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P6_Replace_Expression]
[PATCH]  }  else  if  (  c  <=  '#'  )  {	[BUG]  [BUGGY]  }  else  if  (  c  ==  encapsulator)  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]    if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);    if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;    [BUGGY]  }  else  if  (  c  ==  encapsulator)  {  [BUGGY]        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P6_Replace_Expression]
[PATCH]  }  else  if  (  c  <=  '#'  )  {	[BUG]  [BUGGY]  }  else  if  (  c  ==  delim)  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]    if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);    if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;    [BUGGY]  }  else  if  (  c  ==  delim)  {  [BUGGY]        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P6_Replace_Expression]
[PATCH]  }  else  if  (  c  <=  '#'  )  {	[BUG]  [BUGGY]  }  else  if  (  end  -  1)  {[CE]  incompatible  types  [CONTEXT]    if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);    if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;    [BUGGY]  }  else  if  (  end  -  1)  {  [BUGGY]        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P6_Replace_Expression]
[PATCH]  }  else  if  (  c  <=  '#'  )  {	[BUG]  [BUGGY]  }  else  if  (  c  <=  '  ')  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]    if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);    if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;    [BUGGY]  }  else  if  (  c  <=  '  ')  {  [BUGGY]        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P6_Replace_Expression]
[PATCH]  }  else  if  (  c  <=  '#'  )  {	[BUG]  [BUGGY]  }  else  {[CE]  'else'  without  'if'  [CONTEXT]    if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);    if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;    [BUGGY]  }  else  {  [BUGGY]        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P6_Replace_Expression]
[PATCH]  }  else  if  (  c  <=  '#'  )  {	[BUG]  [BUGGY]  }  else  if  (  encapsulator  <=  '#')  {[FE]  expected:<[a,b,c]>  but  was:<[ "a ", "b ", "c "]>  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]    if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);    if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;    [BUGGY]  }  else  if  (  encapsulator  <=  '#')  {  [BUGGY]        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P8_Replace_Mix]
[PATCH]  while  (  pos  <  end  )  {	[BUG]  [BUGGY]  while  (  pos  ==  end)  {[FE]  expected:<[ "x,y "],z>  but  was:<[x,y],z>  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]  }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  [BUGGY]  while  (  pos  ==  end)  {  [BUGGY]  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);        if  (c  <=  '  ')  {  quote  =  true;  }  }  }    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P2_Replace_Operator]
[PATCH]  while  (  pos  <  end  )  {	[BUG]  [BUGGY]  while  (  start  <  end)  {[FE]  String  index  out  of  range:  1  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]  }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  [BUGGY]  while  (  start  <  end)  {  [BUGGY]  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);        if  (c  <=  '  ')  {  quote  =  true;  }  }  }    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P5_Replace_Variable]
[PATCH]  while  (  pos  <  end  )  {	[BUG]  [BUGGY]  while  (  pos  <  start)  {[FE]  expected:<[ "x,y "],z>  but  was:<[x,y],z>  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]  }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  [BUGGY]  while  (  pos  <  start)  {  [BUGGY]  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);        if  (c  <=  '  ')  {  quote  =  true;  }  }  }    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P5_Replace_Variable]
[PATCH]  while  (  pos  <  end  )  {	[BUG]  [BUGGY]  while  (  end  <  pos)  {[FE]  expected:<[ "x,y "],z>  but  was:<[x,y],z>  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]  }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  [BUGGY]  while  (  end  <  pos)  {  [BUGGY]  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);        if  (c  <=  '  ')  {  quote  =  true;  }  }  }    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P5_Replace_Variable]
[PATCH]  while  (  pos  <  end  )  {	[BUG]  [BUGGY]  while  (  pos  <  pos)  {[FE]  expected:<[ "x,y "],z>  but  was:<[x,y],z>  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]  }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  [BUGGY]  while  (  pos  <  pos)  {  [BUGGY]  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);        if  (c  <=  '  ')  {  quote  =  true;  }  }  }    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P8_Replace_Mix]
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  (  (  (  c  ==  '\n')  ||  (  c  ==  '\r')  )  ||  (  c  ==  encapsulator)  )  ||  (  c  ==  delim)  )  {      quote  =  true;      break;  }[CE]  illegal  start  of  type  [CONTEXT]  }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  [BUGGY]  if  (  (  (  (  c  ==  '\n')  ||  (  c  ==  '\r')  )  ||  (  c  ==  encapsulator)  )  ||  (  c  ==  delim)  )  {      quote  =  true;      break;  }  [BUGGY]  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);        if  (c  <=  '  ')  {  quote  =  true;  }  }  }    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P13_Insert_Block]
[PATCH]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUG]  [BUGGY]  if  (  c  ==  '\n'  &&  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if  (  c  ==  '\n'  &&  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  [BUGGY]  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);        if  (c  <=  '  ')  {  quote  =  true;  }  }  }    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P2_Replace_Operator]
[PATCH]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUG]  [BUGGY]  if  (  c  <=  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if  (  c  <=  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  [BUGGY]  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);        if  (c  <=  '  ')  {  quote  =  true;  }  }  }    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P2_Replace_Operator]
[PATCH]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUG]  [BUGGY]  if  (  c  ==  '\n'  ||  c  >=  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {[FE]  expected:<[a,b,c]>  but  was:<[ "a ", "b ", "c "]>  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]  }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if  (  c  ==  '\n'  ||  c  >=  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  [BUGGY]  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);        if  (c  <=  '  ')  {  quote  =  true;  }  }  }    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P2_Replace_Operator]
[PATCH]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUG]  [BUGGY]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  <=  encapsulator  ||  c  ==  delim)  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  <=  encapsulator  ||  c  ==  delim)  {  [BUGGY]  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);        if  (c  <=  '  ')  {  quote  =  true;  }  }  }    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P2_Replace_Operator]
[PATCH]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUG]  [BUGGY]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  <  delim)  {[FE]  expected:<[ "x,y "],z>  but  was:<[x,y],z>  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]  }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  <  delim)  {  [BUGGY]  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);        if  (c  <=  '  ')  {  quote  =  true;  }  }  }    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P2_Replace_Operator]
[PATCH]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUG]  [BUGGY]  if  (  encapsulator  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if  (  encapsulator  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  [BUGGY]  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);        if  (c  <=  '  ')  {  quote  =  true;  }  }  }    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P5_Replace_Variable]
[PATCH]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUG]  [BUGGY]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  delim  ||  c  ==  delim)  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  delim  ||  c  ==  delim)  {  [BUGGY]  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);        if  (c  <=  '  ')  {  quote  =  true;  }  }  }    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P5_Replace_Variable]
[PATCH]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUG]  [BUGGY]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  c)  {[FE]  expected:<[a,b,c]>  but  was:<[ "a ", "b ", "c "]>  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]  }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  c)  {  [BUGGY]  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);        if  (c  <=  '  ')  {  quote  =  true;  }  }  }    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P5_Replace_Variable]
[PATCH]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUG]  [BUGGY]  if  (  delim  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  c)  {[FE]  expected:<[a,b,c]>  but  was:<[ "a ", "b ", "c "]>  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]  }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if  (  delim  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  c)  {  [BUGGY]  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);        if  (c  <=  '  ')  {  quote  =  true;  }  }  }    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P5_Replace_Variable]
[PATCH]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUG]  [BUGGY]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  delim  ||  c  ==  encapsulator)  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  delim  ||  c  ==  encapsulator)  {  [BUGGY]  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);        if  (c  <=  '  ')  {  quote  =  true;  }  }  }    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P5_Replace_Variable]
[PATCH]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUG]  [BUGGY]  if  (  c  ==  '\n')  {[FE]  expected:<[ "x,y "],z>  but  was:<[x,y],z>  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]  }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if  (  c  ==  '\n')  {  [BUGGY]  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);        if  (c  <=  '  ')  {  quote  =  true;  }  }  }    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P6_Replace_Expression]
[PATCH]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUG]  [BUGGY]  if  (  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if  (  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  [BUGGY]  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);        if  (c  <=  '  ')  {  quote  =  true;  }  }  }    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P6_Replace_Expression]
[PATCH]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUG]  [BUGGY]  if  (((c  ==  '\n')  ||(c  ==  '\r')  ||  c  ==  encapsulator))  {[FE]  expected:<[ "x,y "],z>  but  was:<[x,y],z>  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]  }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if  (((c  ==  '\n')  ||(c  ==  '\r')  ||  c  ==  encapsulator))  {  [BUGGY]  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);        if  (c  <=  '  ')  {  quote  =  true;  }  }  }    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P6_Replace_Expression]
[PATCH]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUG]  [BUGGY]  if  ((c  ==  '\n'  ||  c  ==  '\r'))  {[FE]  expected:<[ "x,y "],z>  but  was:<[x,y],z>  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]  }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if  ((c  ==  '\n'  ||  c  ==  '\r'))  {  [BUGGY]  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);        if  (c  <=  '  ')  {  quote  =  true;  }  }  }    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P6_Replace_Expression]
[PATCH]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUG]  [BUGGY]  if  (  c  ==  '\r')  {[FE]  expected:<[ "x,y "],z>  but  was:<[x,y],z>  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]  }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if  (  c  ==  '\r')  {  [BUGGY]  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);        if  (c  <=  '  ')  {  quote  =  true;  }  }  }    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P6_Replace_Expression]
[PATCH]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUG]  [BUGGY]  if  (  c  ==  encapsulator)  {[FE]  expected:<[ "x,y "],z>  but  was:<[x,y],z>  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]  }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if  (  c  ==  encapsulator)  {  [BUGGY]  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);        if  (c  <=  '  ')  {  quote  =  true;  }  }  }    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P6_Replace_Expression]
[PATCH]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUG]  [BUGGY]  if  (  c  ==  delim)  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if  (  c  ==  delim)  {  [BUGGY]  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);        if  (c  <=  '  ')  {  quote  =  true;  }  }  }    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P6_Replace_Expression]
[PATCH]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUG]  [BUGGY]  if  (  c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {[CE]  cannot  find  symbol  escape  [CONTEXT]  }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if  (  c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {  [BUGGY]  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);        if  (c  <=  '  ')  {  quote  =  true;  }  }  }    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P9_Replace_Statement]
[PATCH]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {  quote  =  true;  break;  }	[BUG]  [BUGGY]  quote  =  true;  break;[CE]  illegal  start  of  expression  [CONTEXT]  }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  quote  =  true;  break;  [BUGGY]    quote  =  true;  break;    pos++;  }  if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);        if  (c  <=  '  ')  {  quote  =  true;  }  }    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P15_Unwrap_Block]
[PATCH]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {  quote  =  true;  break;  }	[BUG]  [BUGGY]  [CE]  illegal  start  of  expression  [CONTEXT]  }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  [BUGGY]      pos++;  }  if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);        if  (c  <=  '  ')  {  quote  =  true;  }  }    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P16_Remove_Block]
[PATCH]  quote  =  true;	[BUG]  [BUGGY]  quote  =  false;[FE]  expected:<[ "x,y "],z>  but  was:<[x,y],z>  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]  }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  [BUGGY]  quote  =  false;  [BUGGY]  break;  }  pos++;  }  if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);        if  (c  <=  '  ')  {  quote  =  true;  }  }  }    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P3_Replace_Literal]
[PATCH]  quote  =  true;	[BUG]  [BUGGY]  newLine  =  true;quote  =  true;[FE]  expected:< "x,y "[,]z>  but  was:< "x,y "[]z>  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]  }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  [BUGGY]  newLine  =  true;quote  =  true;  [BUGGY]  break;  }  pos++;  }  if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);        if  (c  <=  '  ')  {  quote  =  true;  }  }  }    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  c  =  value.charAt  (  pos  )  ;	[BUG]  [BUGGY]  c  =  value.charAt(  start)  ;[FE]  expected:<[ "x,y "],z>  but  was:<[x,y],z>  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]  }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  while  (pos  <  end)  {  [BUGGY]  c  =  value.charAt(  start)  ;  [BUGGY]  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);        if  (c  <=  '  ')  {  quote  =  true;  }  }  }    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P5_Replace_Variable]
[PATCH]  c  =  value.charAt  (  pos  )  ;	[BUG]  [BUGGY]  c  =  pos.charAt(  value)  ;[CE]  int  cannot  be  dereferenced  [CONTEXT]  }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  while  (pos  <  end)  {  [BUGGY]  c  =  pos.charAt(  value)  ;  [BUGGY]  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);        if  (c  <=  '  ')  {  quote  =  true;  }  }  }    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P5_Replace_Variable]
[PATCH]  c  =  value.charAt  (  pos  )  ;	[BUG]  [BUGGY]  c  =  null.charAt(  pos)  ;[CE]  <null>  cannot  be  dereferenced  [CONTEXT]  }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  while  (pos  <  end)  {  [BUGGY]  c  =  null.charAt(  pos)  ;  [BUGGY]  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);        if  (c  <=  '  ')  {  quote  =  true;  }  }  }    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P8_Replace_Mix]
[PATCH]  c  =  value.charAt  (  pos  )  ;	[BUG]  [BUGGY]  [FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  while  (pos  <  end)  {  [BUGGY]  [BUGGY]    if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);        if  (c  <=  '  ')  {  quote  =  true;  }  }    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P14_Delete_Statement]
[PATCH]  c  =  value.charAt  (  pos  )  ;	[BUG]  [BUGGY]  char  c  =  value.charAt(  pos)  ;c  =  value.charAt(  pos)  ;[CE]  variable  c  is  already  defined  in  method  printAndEncapsulate(CharSequence,int,int)  [CONTEXT]  }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  while  (pos  <  end)  {  [BUGGY]  char  c  =  value.charAt(  pos)  ;c  =  value.charAt(  pos)  ;  [BUGGY]  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);        if  (c  <=  '  ')  {  quote  =  true;  }  }  }    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  c  =  value.charAt  (  pos  )  ;	[BUG]  [BUGGY]  char  c  =  comment.charAt(  i)  ;c  =  value.charAt(  pos)  ;[CE]  variable  c  is  already  defined  in  method  printAndEncapsulate(CharSequence,int,int)  [CONTEXT]  }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  while  (pos  <  end)  {  [BUGGY]  char  c  =  comment.charAt(  i)  ;c  =  value.charAt(  pos)  ;  [BUGGY]  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);        if  (c  <=  '  ')  {  quote  =  true;  }  }  }    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUG]  [BUGGY]  if  (  c  >=  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {[FE]  expected:<[a,b,c]>  but  was:<[ "a ", "b ", "c "]>  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]  }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if  (  c  >=  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  [BUGGY]  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);        if  (c  <=  '  ')  {  quote  =  true;  }  }  }    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P2_Replace_Operator]
[PATCH]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUG]  [BUGGY]  if  (  c  ==  '\n'  ||  c  <  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if  (  c  ==  '\n'  ||  c  <  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  [BUGGY]  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);        if  (c  <=  '  ')  {  quote  =  true;  }  }  }    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P2_Replace_Operator]
[PATCH]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUG]  [BUGGY]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  !=  delim)  {[FE]  expected:<[a,b,c]>  but  was:<[ "a ", "b ", "c "]>  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]  }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  !=  delim)  {  [BUGGY]  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);        if  (c  <=  '  ')  {  quote  =  true;  }  }  }    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P2_Replace_Operator]
[PATCH]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUG]  [BUGGY]  if  (  delim  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if  (  delim  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  [BUGGY]  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);        if  (c  <=  '  ')  {  quote  =  true;  }  }  }    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P5_Replace_Variable]
[PATCH]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUG]  [BUGGY]  if  (  encapsulator  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  c  ||  c  ==  delim)  {[FE]  expected:<[a,b,c]>  but  was:<[ "a ", "b ", "c "]>  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]  }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if  (  encapsulator  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  c  ||  c  ==  delim)  {  [BUGGY]  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);        if  (c  <=  '  ')  {  quote  =  true;  }  }  }    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P5_Replace_Variable]
[PATCH]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUG]  [BUGGY]  if  (  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  c)  {[FE]  expected:<[a,b,c]>  but  was:<[ "a ", "b ", "c "]>  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]  }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if  (  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  c)  {  [BUGGY]  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);        if  (c  <=  '  ')  {  quote  =  true;  }  }  }    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P8_Replace_Mix]
[PATCH]  if  (  !quote  )  {	[BUG]  [BUGGY]  if  (  !newLine)  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }  [BUGGY]  if  (  !newLine)  {  [BUGGY]  pos  =  end  -  1;  c  =  value.charAt(pos);        if  (c  <=  '  ')  {  quote  =  true;  }  }  }    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P5_Replace_Variable]
[PATCH]  if  (  !quote  )  {	[BUG]  [BUGGY]  if  (  c  <=  '  ')  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }  [BUGGY]  if  (  c  <=  '  ')  {  [BUGGY]  pos  =  end  -  1;  c  =  value.charAt(pos);        if  (c  <=  '  ')  {  quote  =  true;  }  }  }    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P6_Replace_Expression]
[PATCH]  if  (  !quote  )  {	[BUG]  [BUGGY]  if  (  newLine)  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }  [BUGGY]  if  (  newLine)  {  [BUGGY]  pos  =  end  -  1;  c  =  value.charAt(pos);        if  (c  <=  '  ')  {  quote  =  true;  }  }  }    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P9_Replace_Statement]
[PATCH]  if  (  !quote  )  {	[BUG]  [BUGGY]  if  (  first)  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }  [BUGGY]  if  (  first)  {  [BUGGY]  pos  =  end  -  1;  c  =  value.charAt(pos);        if  (c  <=  '  ')  {  quote  =  true;  }  }  }    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P9_Replace_Statement]
[PATCH]  if  (  c  <=  '  '  )  {	[BUG]  [BUGGY]  if  (  c  <  '  ')  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);        [BUGGY]  if  (  c  <  '  ')  {  [BUGGY]  quote  =  true;  }  }  }    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P2_Replace_Operator]
[PATCH]  if  (  c  <=  '  '  )  {	[BUG]  [BUGGY]  if  (  encapsulator  <=  '  ')  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);        [BUGGY]  if  (  encapsulator  <=  '  ')  {  [BUGGY]  quote  =  true;  }  }  }    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P5_Replace_Variable]
[PATCH]  if  (  c  <=  '  '  )  {	[BUG]  [BUGGY]  if  (  len  <=  0)  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);        [BUGGY]  if  (  len  <=  0)  {  [BUGGY]  quote  =  true;  }  }  }    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P9_Replace_Statement]
[PATCH]  if  (  c  <=  '  '  )  {	[BUG]  [BUGGY]  if  (  c  ==  '\n')  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);        [BUGGY]  if  (  c  ==  '\n')  {  [BUGGY]  quote  =  true;  }  }  }    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P9_Replace_Statement]
[PATCH]  if  (  c  <=  '  '  )  {  quote  =  true;  }	[BUG]  [BUGGY]  quote  =  true;[CE]  illegal  start  of  expression  [CONTEXT]  }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);        [BUGGY]  quote  =  true;  [BUGGY]    quote  =  true;  }    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P15_Unwrap_Block]
[PATCH]  if  (  c  <=  '  '  )  {  quote  =  true;  }	[BUG]  [BUGGY]  [CE]  illegal  start  of  expression  [CONTEXT]  }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);        [BUGGY]  [BUGGY]      }    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P16_Remove_Block]
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  first)  {      quote  =  true;  }[CE]  illegal  start  of  type  [CONTEXT]  }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);        [BUGGY]  if  (  first)  {      quote  =  true;  }  [BUGGY]  quote  =  true;  }  }  }    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P13_Insert_Block]
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  value  ==  null)  {      value  =   " ";  }[CE]  illegal  start  of  type  [CONTEXT]  }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);        [BUGGY]  if  (  value  ==  null)  {      value  =   " ";  }  [BUGGY]  quote  =  true;  }  }  }    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P13_Insert_Block]
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  c  ==  '\r')  {      c  =  'r';  }[CE]  illegal  start  of  type  [CONTEXT]  }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);        [BUGGY]  if  (  c  ==  '\r')  {      c  =  'r';  }  [BUGGY]  quote  =  true;  }  }  }    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P13_Insert_Block]
[PATCH]  quote  =  true;	[BUG]  [BUGGY]  quote  =  false;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);        if  (c  <=  '  ')  {  [BUGGY]  quote  =  false;  [BUGGY]  }  }  }    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P3_Replace_Literal]
[PATCH]  quote  =  true;	[BUG]  [BUGGY]  newLine  =  true;quote  =  true;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);        if  (c  <=  '  ')  {  [BUGGY]  newLine  =  true;quote  =  true;  [BUGGY]  }  }  }    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  pos  =  end  -  1;	[BUG]  [BUGGY]  pos  =  end  &&  1;[CE]  bad  operand  types  for  binary  operator  '&&'  [CONTEXT]  }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {  [BUGGY]  pos  =  end  &&  1;  [BUGGY]  c  =  value.charAt(pos);        if  (c  <=  '  ')  {  quote  =  true;  }  }  }    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P2_Replace_Operator]
[PATCH]  pos  =  end  -  1;	[BUG]  [BUGGY]  pos  =  end  ;[FE]  String  index  out  of  range:  1  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]  }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {  [BUGGY]  pos  =  end  ;  [BUGGY]  c  =  value.charAt(pos);        if  (c  <=  '  ')  {  quote  =  true;  }  }  }    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P3_Replace_Literal]
[PATCH]  pos  =  end  -  1;	[BUG]  [BUGGY]  pos  =  pos  -  1;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {  [BUGGY]  pos  =  pos  -  1;  [BUGGY]  c  =  value.charAt(pos);        if  (c  <=  '  ')  {  quote  =  true;  }  }  }    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P5_Replace_Variable]
[PATCH]  pos  =  end  -  1;	[BUG]  [BUGGY]  pos  =  end  -  1  %  0;[FE]  /  by  zero  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]  }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {  [BUGGY]  pos  =  end  -  1  %  0;  [BUGGY]  c  =  value.charAt(pos);        if  (c  <=  '  ')  {  quote  =  true;  }  }  }    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P8_Replace_Mix]
[PATCH]  c  =  value.charAt  (  pos  )  ;	[BUG]  [BUGGY]  c  =  value.charAt(  start)  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {  pos  =  end  -  1;  [BUGGY]  c  =  value.charAt(  start)  ;  [BUGGY]        if  (c  <=  '  ')  {  quote  =  true;  }  }  }    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P5_Replace_Variable]
[PATCH]  c  =  value.charAt  (  pos  )  ;	[BUG]  [BUGGY]  c  =  pos.charAt(  value)  ;[CE]  int  cannot  be  dereferenced  [CONTEXT]  }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {  pos  =  end  -  1;  [BUGGY]  c  =  pos.charAt(  value)  ;  [BUGGY]        if  (c  <=  '  ')  {  quote  =  true;  }  }  }    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P5_Replace_Variable]
[PATCH]  c  =  value.charAt  (  pos  )  ;	[BUG]  [BUGGY]  c  =  null.charAt(  pos)  ;[CE]  <null>  cannot  be  dereferenced  [CONTEXT]  }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {  pos  =  end  -  1;  [BUGGY]  c  =  null.charAt(  pos)  ;  [BUGGY]        if  (c  <=  '  ')  {  quote  =  true;  }  }  }    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P8_Replace_Mix]
[PATCH]  c  =  value.charAt  (  pos  )  ;	[BUG]  [BUGGY]  [FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {  pos  =  end  -  1;  [BUGGY]  [BUGGY]          if  (c  <=  '  ')  {  quote  =  true;  }  }    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P14_Delete_Statement]
[PATCH]  c  =  value.charAt  (  pos  )  ;	[BUG]  [BUGGY]  char  c  =  value.charAt(  pos)  ;c  =  value.charAt(  pos)  ;[CE]  variable  c  is  already  defined  in  method  printAndEncapsulate(CharSequence,int,int)  [CONTEXT]  }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {  pos  =  end  -  1;  [BUGGY]  char  c  =  value.charAt(  pos)  ;c  =  value.charAt(  pos)  ;  [BUGGY]        if  (c  <=  '  ')  {  quote  =  true;  }  }  }    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  c  =  value.charAt  (  pos  )  ;	[BUG]  [BUGGY]  char  c  =  comment.charAt(  i)  ;c  =  value.charAt(  pos)  ;[CE]  variable  c  is  already  defined  in  method  printAndEncapsulate(CharSequence,int,int)  [CONTEXT]  }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {  pos  =  end  -  1;  [BUGGY]  char  c  =  comment.charAt(  i)  ;c  =  value.charAt(  pos)  ;  [BUGGY]        if  (c  <=  '  ')  {  quote  =  true;  }  }  }    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  pos  =  end  -  1;	[BUG]  [BUGGY]  pos  =  end  |  1;[FE]  String  index  out  of  range:  1  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]  }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {  [BUGGY]  pos  =  end  |  1;  [BUGGY]  c  =  value.charAt(pos);        if  (c  <=  '  ')  {  quote  =  true;  }  }  }    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P2_Replace_Operator]
[PATCH]  pos  =  end  -  1;	[BUG]  [BUGGY]  pos  =  end  -  len;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {  [BUGGY]  pos  =  end  -  len;  [BUGGY]  c  =  value.charAt(pos);        if  (c  <=  '  ')  {  quote  =  true;  }  }  }    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P3_Replace_Literal]
[PATCH]  pos  =  end  -  1;	[BUG]  [BUGGY]  pos  =  start  -  1;[FE]  String  index  out  of  range:  -1  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]  }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {  [BUGGY]  pos  =  start  -  1;  [BUGGY]  c  =  value.charAt(pos);        if  (c  <=  '  ')  {  quote  =  true;  }  }  }    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P5_Replace_Variable]
[PATCH]  pos  =  end  -  1;	[BUG]  [BUGGY]  pos  =  end  -  0;[FE]  String  index  out  of  range:  1  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]  }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {  [BUGGY]  pos  =  end  -  0;  [BUGGY]  c  =  value.charAt(pos);        if  (c  <=  '  ')  {  quote  =  true;  }  }  }    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P8_Replace_Mix]
[PATCH]  c  =  value.charAt  (  pos  )  ;	[BUG]  [BUGGY]  c  =  value.charAt(  offset)  ;[FE]  expected:<[ "x,y "],z>  but  was:<[x,y],z>  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]  }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  while  (pos  <  end)  {  [BUGGY]  c  =  value.charAt(  offset)  ;  [BUGGY]  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);        if  (c  <=  '  ')  {  quote  =  true;  }  }  }    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P8_Replace_Mix]
[PATCH]  quote  =  true;	[BUG]  [BUGGY]  quote  =  false;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  }  else  {  char  c  =  value.charAt(pos);    if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;    }  else  if  (c  <=  '#')  {        [BUGGY]  quote  =  false;  [BUGGY]  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);        [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P3_Replace_Literal]
[PATCH]  quote  =  true;	[BUG]  [BUGGY]  newLine  =  true;quote  =  true;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  }  else  {  char  c  =  value.charAt(pos);    if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;    }  else  if  (c  <=  '#')  {        [BUGGY]  newLine  =  true;quote  =  true;  [BUGGY]  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);        [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  if  (  !quote  )  {	[BUG]  [BUGGY]  if  (  c  <=  '  ')  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }  [BUGGY]  if  (  c  <=  '  ')  {  [BUGGY]  pos  =  end  -  1;  c  =  value.charAt(pos);        if  (c  <=  '  ')  {  quote  =  true;  }  }  }  }  if  (!quote)  {    out.append(value,  start,  end);    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P6_Replace_Expression]
[PATCH]  if  (  !quote  )  {	[BUG]  [BUGGY]  if  (  quote)  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }  [BUGGY]  if  (  quote)  {  [BUGGY]  pos  =  end  -  1;  c  =  value.charAt(pos);        if  (c  <=  '  ')  {  quote  =  true;  }  }  }  }  if  (!quote)  {    out.append(value,  start,  end);    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P8_Replace_Mix]
[PATCH]  if  (  !quote  )  {	[BUG]  [BUGGY]  if  (  newLine)  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }  [BUGGY]  if  (  newLine)  {  [BUGGY]  pos  =  end  -  1;  c  =  value.charAt(pos);        if  (c  <=  '  ')  {  quote  =  true;  }  }  }  }  if  (!quote)  {    out.append(value,  start,  end);    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P9_Replace_Statement]
[PATCH]  if  (  !quote  )  {	[BUG]  [BUGGY]  if  (  !newLine)  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }  [BUGGY]  if  (  !newLine)  {  [BUGGY]  pos  =  end  -  1;  c  =  value.charAt(pos);        if  (c  <=  '  ')  {  quote  =  true;  }  }  }  }  if  (!quote)  {    out.append(value,  start,  end);    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P9_Replace_Statement]
[PATCH]  if  (  !quote  )  {	[BUG]  [BUGGY]  if  (  first)  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }  [BUGGY]  if  (  first)  {  [BUGGY]  pos  =  end  -  1;  c  =  value.charAt(pos);        if  (c  <=  '  ')  {  quote  =  true;  }  }  }  }  if  (!quote)  {    out.append(value,  start,  end);    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P9_Replace_Statement]
[PATCH]  if  (  c  <=  '  '  )  {	[BUG]  [BUGGY]  if  (  c  <  '  ')  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);        [BUGGY]  if  (  c  <  '  ')  {  [BUGGY]  quote  =  true;  }  }  }  }  if  (!quote)  {    out.append(value,  start,  end);  return;  }    out.append(encapsulator);      [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P2_Replace_Operator]
[PATCH]  if  (  c  <=  '  '  )  {	[BUG]  [BUGGY]  if  (  encapsulator  <=  '  ')  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);        [BUGGY]  if  (  encapsulator  <=  '  ')  {  [BUGGY]  quote  =  true;  }  }  }  }  if  (!quote)  {    out.append(value,  start,  end);  return;  }    out.append(encapsulator);      [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P5_Replace_Variable]
[PATCH]  if  (  c  <=  '  '  )  {	[BUG]  [BUGGY]  if  (  len  <=  0)  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);        [BUGGY]  if  (  len  <=  0)  {  [BUGGY]  quote  =  true;  }  }  }  }  if  (!quote)  {    out.append(value,  start,  end);  return;  }    out.append(encapsulator);      [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P9_Replace_Statement]
[PATCH]  if  (  c  <=  '  '  )  {	[BUG]  [BUGGY]  if  (  c  ==  '\n')  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);        [BUGGY]  if  (  c  ==  '\n')  {  [BUGGY]  quote  =  true;  }  }  }  }  if  (!quote)  {    out.append(value,  start,  end);  return;  }    out.append(encapsulator);      [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P9_Replace_Statement]
[PATCH]  if  (  c  <=  '  '  )  {  quote  =  true;  }	[BUG]  [BUGGY]  quote  =  true;[CE]  illegal  start  of  expression  [CONTEXT]  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);        [BUGGY]  quote  =  true;  [BUGGY]    quote  =  true;  }  }  }  if  (!quote)  {    out.append(value,  start,  end);  return;  }    out.append(encapsulator);    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P15_Unwrap_Block]
[PATCH]  if  (  c  <=  '  '  )  {  quote  =  true;  }	[BUG]  [BUGGY]  [CE]  illegal  start  of  expression  [CONTEXT]  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);        [BUGGY]  [BUGGY]      }  }  }  if  (!quote)  {    out.append(value,  start,  end);  return;  }    out.append(encapsulator);    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P16_Remove_Block]
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  first)  {      quote  =  true;  }[CE]  illegal  start  of  type  [CONTEXT]  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);        [BUGGY]  if  (  first)  {      quote  =  true;  }  [BUGGY]  quote  =  true;  }  }  }  }  if  (!quote)  {    out.append(value,  start,  end);  return;  }    out.append(encapsulator);      [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P13_Insert_Block]
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  value  ==  null)  {      value  =   " ";  }[CE]  illegal  start  of  type  [CONTEXT]  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);        [BUGGY]  if  (  value  ==  null)  {      value  =   " ";  }  [BUGGY]  quote  =  true;  }  }  }  }  if  (!quote)  {    out.append(value,  start,  end);  return;  }    out.append(encapsulator);      [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P13_Insert_Block]
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  c  ==  '\r')  {      c  =  'r';  }[CE]  illegal  start  of  type  [CONTEXT]  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);        [BUGGY]  if  (  c  ==  '\r')  {      c  =  'r';  }  [BUGGY]  quote  =  true;  }  }  }  }  if  (!quote)  {    out.append(value,  start,  end);  return;  }    out.append(encapsulator);      [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P13_Insert_Block]
[PATCH]  quote  =  true;	[BUG]  [BUGGY]  quote  =  false;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);        if  (c  <=  '  ')  {  [BUGGY]  quote  =  false;  [BUGGY]  }  }  }  }  if  (!quote)  {    out.append(value,  start,  end);  return;  }    out.append(encapsulator);        [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P3_Replace_Literal]
[PATCH]  quote  =  true;	[BUG]  [BUGGY]  newLine  =  true;quote  =  true;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);        if  (c  <=  '  ')  {  [BUGGY]  newLine  =  true;quote  =  true;  [BUGGY]  }  }  }  }  if  (!quote)  {    out.append(value,  start,  end);  return;  }    out.append(encapsulator);        [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  pos  =  end  -  1;	[BUG]  [BUGGY]  pos  =  end  ==  1;[CE]  incompatible  types  [CONTEXT]        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {  [BUGGY]  pos  =  end  ==  1;  [BUGGY]  c  =  value.charAt(pos);        if  (c  <=  '  ')  {  quote  =  true;  }  }  }  }  if  (!quote)  {    out.append(value,  start,  end);  return;    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P2_Replace_Operator]
[PATCH]  pos  =  end  -  1;	[BUG]  [BUGGY]  pos  =  end  -  offset;[FE]  String  index  out  of  range:  1  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {  [BUGGY]  pos  =  end  -  offset;  [BUGGY]  c  =  value.charAt(pos);        if  (c  <=  '  ')  {  quote  =  true;  }  }  }  }  if  (!quote)  {    out.append(value,  start,  end);  return;    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P3_Replace_Literal]
[PATCH]  pos  =  end  -  1;	[BUG]  [BUGGY]  pos  =  start  -  1;[FE]  String  index  out  of  range:  -1  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {  [BUGGY]  pos  =  start  -  1;  [BUGGY]  c  =  value.charAt(pos);        if  (c  <=  '  ')  {  quote  =  true;  }  }  }  }  if  (!quote)  {    out.append(value,  start,  end);  return;    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P5_Replace_Variable]
[PATCH]  pos  =  end  -  1;	[BUG]  [BUGGY]  pos  =  end  -  1  -  1;[FE]  String  index  out  of  range:  -1  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {  [BUGGY]  pos  =  end  -  1  -  1;  [BUGGY]  c  =  value.charAt(pos);        if  (c  <=  '  ')  {  quote  =  true;  }  }  }  }  if  (!quote)  {    out.append(value,  start,  end);  return;    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P8_Replace_Mix]
[PATCH]  c  =  value.charAt  (  pos  )  ;	[BUG]  [BUGGY]  c  =  value.charAt(  start)  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]      quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {  pos  =  end  -  1;  [BUGGY]  c  =  value.charAt(  start)  ;  [BUGGY]        if  (c  <=  '  ')  {  quote  =  true;  }  }  }  }  if  (!quote)  {    out.append(value,  start,  end);  return;  }    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P5_Replace_Variable]
[PATCH]  c  =  value.charAt  (  pos  )  ;	[BUG]  [BUGGY]  c  =  pos.charAt(  value)  ;[CE]  int  cannot  be  dereferenced  [CONTEXT]      quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {  pos  =  end  -  1;  [BUGGY]  c  =  pos.charAt(  value)  ;  [BUGGY]        if  (c  <=  '  ')  {  quote  =  true;  }  }  }  }  if  (!quote)  {    out.append(value,  start,  end);  return;  }    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P5_Replace_Variable]
[PATCH]  c  =  value.charAt  (  pos  )  ;	[BUG]  [BUGGY]  c  =  null.charAt(  pos)  ;[CE]  <null>  cannot  be  dereferenced  [CONTEXT]      quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {  pos  =  end  -  1;  [BUGGY]  c  =  null.charAt(  pos)  ;  [BUGGY]        if  (c  <=  '  ')  {  quote  =  true;  }  }  }  }  if  (!quote)  {    out.append(value,  start,  end);  return;  }    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P8_Replace_Mix]
[PATCH]  c  =  value.charAt  (  pos  )  ;	[BUG]  [BUGGY]  c  =  value.charAt(  offset)  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]      quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {  pos  =  end  -  1;  [BUGGY]  c  =  value.charAt(  offset)  ;  [BUGGY]        if  (c  <=  '  ')  {  quote  =  true;  }  }  }  }  if  (!quote)  {    out.append(value,  start,  end);  return;  }    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P5_Replace_Variable]
[PATCH]  c  =  value.charAt  (  pos  )  ;	[BUG]  [BUGGY]  [FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]      quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {  pos  =  end  -  1;  [BUGGY]  [BUGGY]          if  (c  <=  '  ')  {  quote  =  true;  }  }  }  }  if  (!quote)  {    out.append(value,  start,  end);  return;    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P14_Delete_Statement]
[PATCH]  c  =  value.charAt  (  pos  )  ;	[BUG]  [BUGGY]  char  c  =  value.charAt(  pos)  ;c  =  value.charAt(  pos)  ;[CE]  variable  c  is  already  defined  in  method  printAndEncapsulate(CharSequence,int,int)  [CONTEXT]      quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {  pos  =  end  -  1;  [BUGGY]  char  c  =  value.charAt(  pos)  ;c  =  value.charAt(  pos)  ;  [BUGGY]        if  (c  <=  '  ')  {  quote  =  true;  }  }  }  }  if  (!quote)  {    out.append(value,  start,  end);  return;  }    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  c  =  value.charAt  (  pos  )  ;	[BUG]  [BUGGY]  char  c  =  comment.charAt(  i)  ;c  =  value.charAt(  pos)  ;[CE]  variable  c  is  already  defined  in  method  printAndEncapsulate(CharSequence,int,int)  [CONTEXT]      quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {  pos  =  end  -  1;  [BUGGY]  char  c  =  comment.charAt(  i)  ;c  =  value.charAt(  pos)  ;  [BUGGY]        if  (c  <=  '  ')  {  quote  =  true;  }  }  }  }  if  (!quote)  {    out.append(value,  start,  end);  return;  }    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  c  =  value.charAt  (  pos  )  ;	[BUG]  [BUGGY]  c  =  value.charAt(  offset)  ;[FE]  expected:<[ "x,y "],z>  but  was:<[x,y],z>  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]    if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;    }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  while  (pos  <  end)  {  [BUGGY]  c  =  value.charAt(  offset)  ;  [BUGGY]  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);        if  (c  <=  '  ')  {  quote  =  true;    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P5_Replace_Variable]
[PATCH]  pos  =  end  -  1;	[BUG]  [BUGGY]  pos  =  end  <  1;[CE]  incompatible  types  [CONTEXT]        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {  [BUGGY]  pos  =  end  <  1;  [BUGGY]  c  =  value.charAt(pos);        if  (c  <=  '  ')  {  quote  =  true;  }  }  }  }  if  (!quote)  {    out.append(value,  start,  end);  return;    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P2_Replace_Operator]
[PATCH]  pos  =  end  -  1;	[BUG]  [BUGGY]  pos  =  end  ;[FE]  String  index  out  of  range:  1  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {  [BUGGY]  pos  =  end  ;  [BUGGY]  c  =  value.charAt(pos);        if  (c  <=  '  ')  {  quote  =  true;  }  }  }  }  if  (!quote)  {    out.append(value,  start,  end);  return;    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P3_Replace_Literal]
[PATCH]  pos  =  end  -  1;	[BUG]  [BUGGY]  pos  =  pos  -  1;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {  [BUGGY]  pos  =  pos  -  1;  [BUGGY]  c  =  value.charAt(pos);        if  (c  <=  '  ')  {  quote  =  true;  }  }  }  }  if  (!quote)  {    out.append(value,  start,  end);  return;    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P5_Replace_Variable]
[PATCH]  pos  =  end  -  1;	[BUG]  [BUGGY]  pos  =  end  -  1L;[CE]  possible  loss  of  precision  [CONTEXT]        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {  [BUGGY]  pos  =  end  -  1L;  [BUGGY]  c  =  value.charAt(pos);        if  (c  <=  '  ')  {  quote  =  true;  }  }  }  }  if  (!quote)  {    out.append(value,  start,  end);  return;    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P8_Replace_Mix]
[PATCH]  quote  =  true;	[BUG]  [BUGGY]  quote  =  false;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]        if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);    if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  [BUGGY]  quote  =  false;  [BUGGY]    }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P3_Replace_Literal]
[PATCH]  quote  =  true;	[BUG]  [BUGGY]  newLine  =  true;quote  =  true;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]        if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);    if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  [BUGGY]  newLine  =  true;quote  =  true;  [BUGGY]    }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  while  (  pos  <  end  )  {	[BUG]  [BUGGY]  while  (  pos  <=  end)  {[FE]  String  index  out  of  range:  1  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]  }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  [BUGGY]  while  (  pos  <=  end)  {  [BUGGY]  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);        if  (c  <=  '  ')  {  quote  =  true;  }  }  }    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P2_Replace_Operator]
[PATCH]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUG]  [BUGGY]  if  (  c  !=  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {[FE]  expected:<[a,b,c]>  but  was:<[ "a ", "b ", "c "]>  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]  }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if  (  c  !=  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  [BUGGY]  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);        if  (c  <=  '  ')  {  quote  =  true;  }  }  }    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P2_Replace_Operator]
[PATCH]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUG]  [BUGGY]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  c  ||  c  ==  delim)  {[FE]  expected:<[a,b,c]>  but  was:<[ "a ", "b ", "c "]>  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]  }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  c  ||  c  ==  delim)  {  [BUGGY]  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);        if  (c  <=  '  ')  {  quote  =  true;  }  }  }    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P5_Replace_Variable]
[PATCH]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUG]  [BUGGY]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  encapsulator)  {[FE]  expected:<[ "x,y "],z>  but  was:<[x,y],z>  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]  }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  encapsulator)  {  [BUGGY]  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);        if  (c  <=  '  ')  {  quote  =  true;  }  }  }    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P5_Replace_Variable]
[PATCH]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUG]  [BUGGY]  if  (  c  ==  '\n'  ||  c  <=  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if  (  c  ==  '\n'  ||  c  <=  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  [BUGGY]  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);        if  (c  <=  '  ')  {  quote  =  true;  }  }  }    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P2_Replace_Operator]
[PATCH]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUG]  [BUGGY]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  !=  encapsulator  ||  c  ==  delim)  {[FE]  expected:<[a,b,c]>  but  was:<[ "a ", "b ", "c "]>  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]  }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  !=  encapsulator  ||  c  ==  delim)  {  [BUGGY]  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);        if  (c  <=  '  ')  {  quote  =  true;  }  }  }    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P2_Replace_Operator]
[PATCH]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUG]  [BUGGY]  if  (  c  ==  '\r'  ||  c  ==  c  ||  c  ==  delim)  {[FE]  expected:<[a,b,c]>  but  was:<[ "a ", "b ", "c "]>  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]  }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if  (  c  ==  '\r'  ||  c  ==  c  ||  c  ==  delim)  {  [BUGGY]  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);        if  (c  <=  '  ')  {  quote  =  true;  }  }  }    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P8_Replace_Mix]
[PATCH]  if  (  !quote  )  {	[BUG]  [BUGGY]  if  (  quote)  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }  [BUGGY]  if  (  quote)  {  [BUGGY]  pos  =  end  -  1;  c  =  value.charAt(pos);        if  (c  <=  '  ')  {  quote  =  true;  }  }  }    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P8_Replace_Mix]
[PATCH]  pos  =  end  -  1;	[BUG]  [BUGGY]  pos  =  end  >=  1;[CE]  incompatible  types  [CONTEXT]  }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {  [BUGGY]  pos  =  end  >=  1;  [BUGGY]  c  =  value.charAt(pos);        if  (c  <=  '  ')  {  quote  =  true;  }  }  }    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P2_Replace_Operator]
[PATCH]  pos  =  end  -  1;	[BUG]  [BUGGY]  pos  =  end  -  start;[FE]  String  index  out  of  range:  1  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]  }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {  [BUGGY]  pos  =  end  -  start;  [BUGGY]  c  =  value.charAt(pos);        if  (c  <=  '  ')  {  quote  =  true;  }  }  }    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P3_Replace_Literal]
[PATCH]  pos  =  end  -  1;	[BUG]  [BUGGY]  pos  =  end  -  1  *  1;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {  [BUGGY]  pos  =  end  -  1  *  1;  [BUGGY]  c  =  value.charAt(pos);        if  (c  <=  '  ')  {  quote  =  true;  }  }  }    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P8_Replace_Mix]
[PATCH]  c  =  value.charAt  (  pos  )  ;	[BUG]  [BUGGY]  c  =  value.charAt(  offset)  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {  pos  =  end  -  1;  [BUGGY]  c  =  value.charAt(  offset)  ;  [BUGGY]        if  (c  <=  '  ')  {  quote  =  true;  }  }  }    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P5_Replace_Variable]
[PATCH]  if  (  c  <=  '  '  )  {	[BUG]  [BUGGY]  if  (  c  ==  '  ')  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);        [BUGGY]  if  (  c  ==  '  ')  {  [BUGGY]  quote  =  true;  }  }  }    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P2_Replace_Operator]
[PATCH]  pos  =  end  -  1;	[BUG]  [BUGGY]  pos  =  end  -  3;[FE]  String  index  out  of  range:  -2  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]  }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {  [BUGGY]  pos  =  end  -  3;  [BUGGY]  c  =  value.charAt(pos);        if  (c  <=  '  ')  {  quote  =  true;  }  }  }    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P8_Replace_Mix]
[PATCH]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUG]  [BUGGY]  if  (  c  ==  '\n'  ||  c  <=  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;    }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if  (  c  ==  '\n'  ||  c  <=  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  [BUGGY]  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);        if  (c  <=  '  ')  {  quote  =  true;  }    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P2_Replace_Operator]
[PATCH]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUG]  [BUGGY]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  >=  encapsulator  ||  c  ==  delim)  {[FE]  expected:<[a,b,c]>  but  was:<[ "a ", "b ", "c "]>  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]  if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;    }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  >=  encapsulator  ||  c  ==  delim)  {  [BUGGY]  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);        if  (c  <=  '  ')  {  quote  =  true;  }    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P2_Replace_Operator]
[PATCH]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUG]  [BUGGY]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  !=  delim)  {[FE]  expected:<[a,b,c]>  but  was:<[ "a ", "b ", "c "]>  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]  if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;    }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  !=  delim)  {  [BUGGY]  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);        if  (c  <=  '  ')  {  quote  =  true;  }    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P2_Replace_Operator]
[PATCH]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUG]  [BUGGY]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  encapsulator)  {[FE]  expected:<[ "x,y "],z>  but  was:<[x,y],z>  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]  if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;    }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  encapsulator)  {  [BUGGY]  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);        if  (c  <=  '  ')  {  quote  =  true;  }    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P5_Replace_Variable]
[PATCH]  pos  =  end  -  1;	[BUG]  [BUGGY]  pos  =  end  >  1;[CE]  incompatible  types  [CONTEXT]        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {  [BUGGY]  pos  =  end  >  1;  [BUGGY]  c  =  value.charAt(pos);        if  (c  <=  '  ')  {  quote  =  true;  }  }  }  }  if  (!quote)  {    out.append(value,  start,  end);  return;    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P2_Replace_Operator]
[PATCH]  pos  =  end  -  1;	[BUG]  [BUGGY]  pos  =  end  -  1  >>  4;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {  [BUGGY]  pos  =  end  -  1  >>  4;  [BUGGY]  c  =  value.charAt(pos);        if  (c  <=  '  ')  {  quote  =  true;  }  }  }  }  if  (!quote)  {    out.append(value,  start,  end);  return;    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P8_Replace_Mix]
[PATCH]  if  (  c  <=  '  '  )  {	[BUG]  [BUGGY]  if  (  c  >  '  ')  {[FE]  expected:<[a,b,c]>  but  was:<[ "a ", "b ", "c "]>  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);        [BUGGY]  if  (  c  >  '  ')  {  [BUGGY]  quote  =  true;  }  }  }  }  if  (!quote)  {    out.append(value,  start,  end);  return;  }    out.append(encapsulator);      [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P2_Replace_Operator]
[PATCH]  pos  =  end  -  1;	[BUG]  [BUGGY]  pos  =  end  <<  1;[FE]  String  index  out  of  range:  2  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {  [BUGGY]  pos  =  end  <<  1;  [BUGGY]  c  =  value.charAt(pos);        if  (c  <=  '  ')  {  quote  =  true;  }  }  }  }  if  (!quote)  {    out.append(value,  start,  end);  return;    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P2_Replace_Operator]
[PATCH]  pos  =  end  -  1;	[BUG]  [BUGGY]  pos  =  end  -  1  +  4;[FE]  String  index  out  of  range:  4  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {  [BUGGY]  pos  =  end  -  1  +  4;  [BUGGY]  c  =  value.charAt(pos);        if  (c  <=  '  ')  {  quote  =  true;  }  }  }  }  if  (!quote)  {    out.append(value,  start,  end);  return;    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P8_Replace_Mix]
[PATCH]  char  c  =  value.charAt  (  pos  )  ;	[BUG]  [BUGGY]  int  c  =  value.charAt(  pos)  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  printSep();  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();  if  (len  <=  0)  {          if  (first)  {  quote  =  true;  }  }  else  {  [BUGGY]  int  c  =  value.charAt(  pos)  ;  [BUGGY]      if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;    }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P1_Replace_Type]
[PATCH]  char  c  =  value.charAt  (  pos  )  ;	[BUG]  [BUGGY]  char  c  =  value.charAt(  offset)  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  printSep();  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();  if  (len  <=  0)  {          if  (first)  {  quote  =  true;  }  }  else  {  [BUGGY]  char  c  =  value.charAt(  offset)  ;  [BUGGY]      if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;    }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P5_Replace_Variable]
[PATCH]  char  c  =  value.charAt  (  pos  )  ;	[BUG]  [BUGGY]  char  c  =  pos.charAt(  value)  ;[CE]  int  cannot  be  dereferenced  [CONTEXT]  printSep();  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();  if  (len  <=  0)  {          if  (first)  {  quote  =  true;  }  }  else  {  [BUGGY]  char  c  =  pos.charAt(  value)  ;  [BUGGY]      if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;    }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P5_Replace_Variable]
[PATCH]  char  c  =  value.charAt  (  pos  )  ;	[BUG]  [BUGGY]  char  c  =  value.charAt(  start)  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  printSep();  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();  if  (len  <=  0)  {          if  (first)  {  quote  =  true;  }  }  else  {  [BUGGY]  char  c  =  value.charAt(  start)  ;  [BUGGY]      if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;    }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P8_Replace_Mix]
[PATCH]  char  c  =  value.charAt  (  pos  )  ;	[BUG]  [BUGGY]  char  c  =  comment.charAt(  i)  ;char  c  =  value.charAt(  pos)  ;[CE]  cannot  find  symbol  i  [CONTEXT]  printSep();  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();  if  (len  <=  0)  {          if  (first)  {  quote  =  true;  }  }  else  {  [BUGGY]  char  c  =  comment.charAt(  i)  ;char  c  =  value.charAt(  pos)  ;  [BUGGY]      if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;    }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  char  c  =  value.charAt  (  pos  )  ;	[BUG]  [BUGGY]  [FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  printSep();  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();  if  (len  <=  0)  {          if  (first)  {  quote  =  true;  }  }  else  {  [BUGGY]  [BUGGY]      if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;    }  else  if  (c  <=  '#')  {        quote  =  true;    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P14_Delete_Statement]
[PATCH]  char  c  =  value.charAt  (  pos  )  ;	[BUG]  [BUGGY]  c  =  value.charAt(  pos)  ;char  c  =  value.charAt(  pos)  ;[CE]  cannot  find  symbol  c  [CONTEXT]  printSep();  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();  if  (len  <=  0)  {          if  (first)  {  quote  =  true;  }  }  else  {  [BUGGY]  c  =  value.charAt(  pos)  ;char  c  =  value.charAt(  pos)  ;  [BUGGY]      if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;    }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  if  (  first  )  {	[BUG]  [BUGGY]  if  (  quote)  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;  printSep();  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();  if  (len  <=  0)  {          [BUGGY]  if  (  quote)  {  [BUGGY]  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);    if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;    }  else  if  (c  <=  '#')  {      [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P5_Replace_Variable]
[PATCH]  if  (  first  )  {	[BUG]  [BUGGY]  if  (  !quote)  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;  printSep();  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();  if  (len  <=  0)  {          [BUGGY]  if  (  !quote)  {  [BUGGY]  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);    if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;    }  else  if  (c  <=  '#')  {      [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P9_Replace_Statement]
[PATCH]  if  (  first  )  {  quote  =  true;  }	[BUG]  [BUGGY]  quote  =  true;[CE]  illegal  start  of  expression  [CONTEXT]  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;  printSep();  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();  if  (len  <=  0)  {          [BUGGY]  quote  =  true;  [BUGGY]    quote  =  true;  }  else  {  char  c  =  value.charAt(pos);    if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;    }  else  if  (c  <=  '#')  {    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P15_Unwrap_Block]
[PATCH]  if  (  first  )  {  quote  =  true;  }	[BUG]  [BUGGY]  [CE]  illegal  start  of  expression  [CONTEXT]  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;  printSep();  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();  if  (len  <=  0)  {          [BUGGY]  [BUGGY]      }  else  {  char  c  =  value.charAt(pos);    if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;    }  else  if  (c  <=  '#')  {    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P16_Remove_Block]
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  c  <=  '  ')  {      quote  =  true;  }[CE]  illegal  start  of  type  [CONTEXT]  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;  printSep();  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();  if  (len  <=  0)  {          [BUGGY]  if  (  c  <=  '  ')  {      quote  =  true;  }  [BUGGY]  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);    if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;    }  else  if  (c  <=  '#')  {      [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P13_Insert_Block]
[PATCH]  quote  =  true;	[BUG]  [BUGGY]  quote  =  false;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;  printSep();  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();  if  (len  <=  0)  {          if  (first)  {  [BUGGY]  quote  =  false;  [BUGGY]  }  }  else  {  char  c  =  value.charAt(pos);    if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;    }  else  if  (c  <=  '#')  {        [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P3_Replace_Literal]
[PATCH]  quote  =  true;	[BUG]  [BUGGY]  newLine  =  true;quote  =  true;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;  printSep();  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();  if  (len  <=  0)  {          if  (first)  {  [BUGGY]  newLine  =  true;quote  =  true;  [BUGGY]  }  }  else  {  char  c  =  value.charAt(pos);    if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;    }  else  if  (c  <=  '#')  {        [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )	[BUG]  [BUGGY]  if  (  first  &&  (  c  <  '0'  ||  (  c  <  '9'  &&  c  <  'A')  ||  (  c  >  'Z'  &&  c  <  'a')[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();  if  (len  <=  0)  {          if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);    [BUGGY]  if  (  first  &&  (  c  <  '0'  ||  (  c  <  '9'  &&  c  <  'A')  ||  (  c  >  'Z'  &&  c  <  'a')  [BUGGY]      ||  (c  >  'z')))  {  quote  =  true;    }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P2_Replace_Operator]
[PATCH]  if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )	[BUG]  [BUGGY]  if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A')  ||  (  c  >=  'Z'  &&  c  <  'a')[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();  if  (len  <=  0)  {          if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);    [BUGGY]  if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A')  ||  (  c  >=  'Z'  &&  c  <  'a')  [BUGGY]      ||  (c  >  'z')))  {  quote  =  true;    }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P2_Replace_Operator]
[PATCH]  if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )	[BUG]  [BUGGY]  if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A')  ||  (  c  >  'Z'  &&  c  ==  'a')[FE]  expected:<[a],b,c>  but  was:<[ "a "],b,c>  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();  if  (len  <=  0)  {          if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);    [BUGGY]  if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A')  ||  (  c  >  'Z'  &&  c  ==  'a')  [BUGGY]      ||  (c  >  'z')))  {  quote  =  true;    }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P2_Replace_Operator]
[PATCH]  if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )	[BUG]  [BUGGY]  if  (  first  &&  (  c  ==  '0'  ||  (  c  >  '9'  &&  c  <  'A')  ||  (  c  >  'Z'  &&  c  <  'a')[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();  if  (len  <=  0)  {          if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);    [BUGGY]  if  (  first  &&  (  c  ==  '0'  ||  (  c  >  '9'  &&  c  <  'A')  ||  (  c  >  'Z'  &&  c  <  'a')  [BUGGY]      ||  (c  >  'z')))  {  quote  =  true;    }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P2_Replace_Operator]
[PATCH]  if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )	[BUG]  [BUGGY]  if  (  first  &&  (  delim  <  '0'  ||  (  c  >  '9'  &&  c  <  'A')  ||  (  c  >  'Z'  &&  c  <  'a')[FE]  expected:<[a],b,c>  but  was:<[ "a "],b,c>  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();  if  (len  <=  0)  {          if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);    [BUGGY]  if  (  first  &&  (  delim  <  '0'  ||  (  c  >  '9'  &&  c  <  'A')  ||  (  c  >  'Z'  &&  c  <  'a')  [BUGGY]      ||  (c  >  'z')))  {  quote  =  true;    }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P8_Replace_Mix]
[PATCH]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUG]  [BUGGY]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  c  ||  c  ==  delim)  {[FE]  expected:<[a,b,c]>  but  was:<[ "a ", "b ", "c "]>  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]  if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;    }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  c  ||  c  ==  delim)  {  [BUGGY]  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);        if  (c  <=  '  ')  {  quote  =  true;  }    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P5_Replace_Variable]
[PATCH]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUG]  [BUGGY]  if  (  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  encapsulator)  {[FE]  expected:<[ "x,y "],z>  but  was:<[x,y],z>  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]  if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;    }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if  (  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  encapsulator)  {  [BUGGY]  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);        if  (c  <=  '  ')  {  quote  =  true;  }    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P8_Replace_Mix]
[PATCH]  }  else  if  (  c  <=  '#'  )  {	[BUG]  [BUGGY]  }  if  (  delim  <=  '#')  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]    if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);    if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;    [BUGGY]  }  if  (  delim  <=  '#')  {  [BUGGY]        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P8_Replace_Mix]
[PATCH]  while  (  pos  <  end  )  {	[BUG]  [BUGGY]  while  (  pos  >  end)  {[FE]  expected:<[ "x,y "],z>  but  was:<[x,y],z>  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]  }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  [BUGGY]  while  (  pos  >  end)  {  [BUGGY]  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);        if  (c  <=  '  ')  {  quote  =  true;  }  }  }    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P2_Replace_Operator]
[PATCH]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUG]  [BUGGY]  if  (  c  ==  '\n'  ||  c  >  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {[FE]  expected:<[a,b,c]>  but  was:<[ "a ", "b ", "c "]>  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]  }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if  (  c  ==  '\n'  ||  c  >  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  [BUGGY]  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);        if  (c  <=  '  ')  {  quote  =  true;  }  }  }    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P2_Replace_Operator]
[PATCH]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUG]  [BUGGY]  if  (  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  encapsulator)  {[FE]  expected:<[ "x,y "],z>  but  was:<[x,y],z>  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]  }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if  (  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  encapsulator)  {  [BUGGY]  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);        if  (c  <=  '  ')  {  quote  =  true;  }  }  }    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P8_Replace_Mix]
[PATCH]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUG]  [BUGGY]  if  (  c  ==  '\n'  ||  c  !=  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {[FE]  expected:<[a,b,c]>  but  was:<[ "a ", "b ", "c "]>  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]  }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if  (  c  ==  '\n'  ||  c  !=  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  [BUGGY]  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);        if  (c  <=  '  ')  {  quote  =  true;  }  }  }    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P2_Replace_Operator]
[PATCH]  pos  =  end  -  1;	[BUG]  [BUGGY]  pos  =  end  <  1;[CE]  incompatible  types  [CONTEXT]  }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {  [BUGGY]  pos  =  end  <  1;  [BUGGY]  c  =  value.charAt(pos);        if  (c  <=  '  ')  {  quote  =  true;  }  }  }    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P2_Replace_Operator]
[PATCH]  pos  =  end  -  1;	[BUG]  [BUGGY]  pos  =  end  -  2;[FE]  String  index  out  of  range:  -1  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]  }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {  [BUGGY]  pos  =  end  -  2;  [BUGGY]  c  =  value.charAt(pos);        if  (c  <=  '  ')  {  quote  =  true;  }  }  }    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P8_Replace_Mix]
[PATCH]  pos  =  end  -  1;	[BUG]  [BUGGY]  pos  =  end  !=  1;[CE]  incompatible  types  [CONTEXT]        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {  [BUGGY]  pos  =  end  !=  1;  [BUGGY]  c  =  value.charAt(pos);        if  (c  <=  '  ')  {  quote  =  true;  }  }  }  }  if  (!quote)  {    out.append(value,  start,  end);  return;    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P2_Replace_Operator]
[PATCH]  pos  =  end  -  1;	[BUG]  [BUGGY]  pos  =  end  -  start;[FE]  String  index  out  of  range:  1  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {  [BUGGY]  pos  =  end  -  start;  [BUGGY]  c  =  value.charAt(pos);        if  (c  <=  '  ')  {  quote  =  true;  }  }  }  }  if  (!quote)  {    out.append(value,  start,  end);  return;    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P3_Replace_Literal]
[PATCH]  pos  =  end  -  1;	[BUG]  [BUGGY]  pos  =  end  -  4;[FE]  String  index  out  of  range:  -3  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {  [BUGGY]  pos  =  end  -  4;  [BUGGY]  c  =  value.charAt(pos);        if  (c  <=  '  ')  {  quote  =  true;  }  }  }  }  if  (!quote)  {    out.append(value,  start,  end);  return;    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P8_Replace_Mix]
[PATCH]  if  (  c  <=  '  '  )  {	[BUG]  [BUGGY]  if  (  c  ==  '  ')  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);        [BUGGY]  if  (  c  ==  '  ')  {  [BUGGY]  quote  =  true;  }  }  }  }  if  (!quote)  {    out.append(value,  start,  end);  return;  }    out.append(encapsulator);      [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P2_Replace_Operator]
[PATCH]  pos  =  end  -  1;	[BUG]  [BUGGY]  pos  =  end  -  0;[FE]  String  index  out  of  range:  1  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {  [BUGGY]  pos  =  end  -  0;  [BUGGY]  c  =  value.charAt(pos);        if  (c  <=  '  ')  {  quote  =  true;  }  }  }  }  if  (!quote)  {    out.append(value,  start,  end);  return;    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P8_Replace_Mix]
[PATCH]  }  else  if  (  c  <=  '#'  )  {	[BUG]  [BUGGY]  }  else  if  (  c  ==  '#')  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]    if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);    if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;    [BUGGY]  }  else  if  (  c  ==  '#')  {  [BUGGY]        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P2_Replace_Operator]
[PATCH]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUG]  [BUGGY]  if  (  encapsulator  ==  '\n')  {[FE]  expected:<[ "x,y "],z>  but  was:<[x,y],z>  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]  }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if  (  encapsulator  ==  '\n')  {  [BUGGY]  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);        if  (c  <=  '  ')  {  quote  =  true;  }  }  }    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P8_Replace_Mix]
[PATCH]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUG]  [BUGGY]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  >=  encapsulator  ||  c  ==  delim)  {[FE]  expected:<[a,b,c]>  but  was:<[ "a ", "b ", "c "]>  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]  }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  >=  encapsulator  ||  c  ==  delim)  {  [BUGGY]  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);        if  (c  <=  '  ')  {  quote  =  true;  }  }  }    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P2_Replace_Operator]
[PATCH]  pos  =  end  -  1;	[BUG]  [BUGGY]  pos  =  end  -  end;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {  [BUGGY]  pos  =  end  -  end;  [BUGGY]  c  =  value.charAt(pos);        if  (c  <=  '  ')  {  quote  =  true;  }  }  }    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P3_Replace_Literal]
[PATCH]  if  (  c  <=  '  '  )  {	[BUG]  [BUGGY]  if  (  c  >  '  ')  {[FE]  expected:<[a,b,c]>  but  was:<[ "a ", "b ", "c "]>  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]  }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);        [BUGGY]  if  (  c  >  '  ')  {  [BUGGY]  quote  =  true;  }  }  }    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P2_Replace_Operator]
[PATCH]  pos  =  end  -  1;	[BUG]  [BUGGY]  pos  =  end  &  1;[FE]  String  index  out  of  range:  1  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]  }  else  if  (c  <=  '#')  {        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {  [BUGGY]  pos  =  end  &  1;  [BUGGY]  c  =  value.charAt(pos);        if  (c  <=  '  ')  {  quote  =  true;  }  }  }    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P2_Replace_Operator]
[PATCH]  pos  =  end  -  1;	[BUG]  [BUGGY]  pos  =  end  &  1;[FE]  String  index  out  of  range:  1  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {  [BUGGY]  pos  =  end  &  1;  [BUGGY]  c  =  value.charAt(pos);        if  (c  <=  '  ')  {  quote  =  true;  }  }  }  }  if  (!quote)  {    out.append(value,  start,  end);  return;    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P2_Replace_Operator]
[PATCH]  pos  =  end  -  1;	[BUG]  [BUGGY]  pos  =  end  -  pos;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {  [BUGGY]  pos  =  end  -  pos;  [BUGGY]  c  =  value.charAt(pos);        if  (c  <=  '  ')  {  quote  =  true;  }  }  }  }  if  (!quote)  {    out.append(value,  start,  end);  return;    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P3_Replace_Literal]
[PATCH]  pos  =  end  -  1;	[BUG]  [BUGGY]  pos  =  end  -  ;[CE]  illegal  start  of  expression  [CONTEXT]        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {  [BUGGY]  pos  =  end  -  ;  [BUGGY]  c  =  value.charAt(pos);        if  (c  <=  '  ')  {  quote  =  true;  }  }  }  }  if  (!quote)  {    out.append(value,  start,  end);  return;    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P3_Replace_Literal]
[PATCH]  pos  =  end  -  1;	[BUG]  [BUGGY]  pos  =  end  -  3;[FE]  String  index  out  of  range:  -2  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]        quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }  if  (!quote)  {  [BUGGY]  pos  =  end  -  3;  [BUGGY]  c  =  value.charAt(pos);        if  (c  <=  '  ')  {  quote  =  true;  }  }  }  }  if  (!quote)  {    out.append(value,  start,  end);  return;    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P8_Replace_Mix]
[PATCH]  if  (  !quote  )  {	[BUG]  [BUGGY]  if  (  !newLine)  {[FE]  expected:<[ "x,y "],z>  but  was:<[x,y],z>  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]  }  if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);        if  (c  <=  '  ')  {  quote  =  true;  }  }  }  }  [BUGGY]  if  (  !newLine)  {  [BUGGY]    out.append(value,  start,  end);  return;  }    out.append(encapsulator);      while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {        [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P5_Replace_Variable]
[PATCH]  if  (  !quote  )  {	[BUG]  [BUGGY]  if  (  newLine)  {[FE]  expected:<[a,b,c]>  but  was:<[ "a ", "b ", "c "]>  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]  }  if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);        if  (c  <=  '  ')  {  quote  =  true;  }  }  }  }  [BUGGY]  if  (  newLine)  {  [BUGGY]    out.append(value,  start,  end);  return;  }    out.append(encapsulator);      while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {        [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P9_Replace_Statement]
[PATCH]  if  (  !quote  )  {	[BUG]  [BUGGY]  if  (  first)  {[FE]  expected:<a,[b,c]>  but  was:<a,[ "b ", "c "]>  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]  }  if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);        if  (c  <=  '  ')  {  quote  =  true;  }  }  }  }  [BUGGY]  if  (  first)  {  [BUGGY]    out.append(value,  start,  end);  return;  }    out.append(encapsulator);      while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {        [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P9_Replace_Statement]
[PATCH]  if  (  !quote  )  {  out.append  (  value,  start,  end  )  ;  return;  }	[BUG]  [BUGGY]  out.append(value,  start,  end);  return  ;[CE]  illegal  start  of  expression  [CONTEXT]  }  if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);        if  (c  <=  '  ')  {  quote  =  true;  }  }  }  }  [BUGGY]  out.append(value,  start,  end);  return  ;  [BUGGY]    out.append(value,  start,  end);  return  ;        out.append(encapsulator);      while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {      [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P15_Unwrap_Block]
[PATCH]  if  (  !quote  )  {  out.append  (  value,  start,  end  )  ;  return;  }	[BUG]  [BUGGY]  [CE]  illegal  start  of  expression  [CONTEXT]  }  if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);        if  (c  <=  '  ')  {  quote  =  true;  }  }  }  }  [BUGGY]  [BUGGY]          out.append(encapsulator);      while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {      [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P16_Remove_Block]
[PATCH]  out.append  (  value,  start,  end  )  ;	[BUG]  [BUGGY]  out.append(  value,  pos,  end)  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);        if  (c  <=  '  ')  {  quote  =  true;  }  }  }  }  if  (!quote)  {    [BUGGY]  out.append(  value,  pos,  end)  ;  [BUGGY]  return;  }    out.append(encapsulator);      while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {      out.append(value,  start,  pos  +  1);    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P5_Replace_Variable]
[PATCH]  out.append  (  value,  start,  end  )  ;	[BUG]  [BUGGY]  out.append(  value,  start,  pos)  ;[FE]  expected:<[a,b,c]>  but  was:<[,,]>  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]  if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);        if  (c  <=  '  ')  {  quote  =  true;  }  }  }  }  if  (!quote)  {    [BUGGY]  out.append(  value,  start,  pos)  ;  [BUGGY]  return;  }    out.append(encapsulator);      while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {      out.append(value,  start,  pos  +  1);    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P5_Replace_Variable]
[PATCH]  out.append  (  value,  start,  end  )  ;	[BUG]  [BUGGY]  out.append(  start,  end)  ;[CE]  no  suitable  method  found  for  append(int,int)  [CONTEXT]  if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);        if  (c  <=  '  ')  {  quote  =  true;  }  }  }  }  if  (!quote)  {    [BUGGY]  out.append(  start,  end)  ;  [BUGGY]  return;  }    out.append(encapsulator);      while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {      out.append(value,  start,  pos  +  1);    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P5_Replace_Variable]
[PATCH]  out.append  (  value,  start,  end  )  ;	[BUG]  [BUGGY]  out.append(  value,  end)  ;[CE]  no  suitable  method  found  for  append(CharSequence,int)  [CONTEXT]  if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);        if  (c  <=  '  ')  {  quote  =  true;  }  }  }  }  if  (!quote)  {    [BUGGY]  out.append(  value,  end)  ;  [BUGGY]  return;  }    out.append(encapsulator);      while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {      out.append(value,  start,  pos  +  1);    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P5_Replace_Variable]
[PATCH]  out.append  (  value,  start,  end  )  ;	[BUG]  [BUGGY]  out.append(  value,  start)  ;[CE]  no  suitable  method  found  for  append(CharSequence,int)  [CONTEXT]  if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);        if  (c  <=  '  ')  {  quote  =  true;  }  }  }  }  if  (!quote)  {    [BUGGY]  out.append(  value,  start)  ;  [BUGGY]  return;  }    out.append(encapsulator);      while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {      out.append(value,  start,  pos  +  1);    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P5_Replace_Variable]
[PATCH]  out.append  (  value,  start,  end  )  ;	[BUG]  [BUGGY]  out.append(  end,  start,  value)  ;[CE]  no  suitable  method  found  for  append(int,int,CharSequence)  [CONTEXT]  if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);        if  (c  <=  '  ')  {  quote  =  true;  }  }  }  }  if  (!quote)  {    [BUGGY]  out.append(  end,  start,  value)  ;  [BUGGY]  return;  }    out.append(encapsulator);      while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {      out.append(value,  start,  pos  +  1);    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P5_Replace_Variable]
[PATCH]  out.append  (  value,  start,  end  )  ;	[BUG]  [BUGGY]  out.append(  value,  end,  start)  ;[FE]  String  index  out  of  range:  -1  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]  if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);        if  (c  <=  '  ')  {  quote  =  true;  }  }  }  }  if  (!quote)  {    [BUGGY]  out.append(  value,  end,  start)  ;  [BUGGY]  return;  }    out.append(encapsulator);      while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {      out.append(value,  start,  pos  +  1);    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P5_Replace_Variable]
[PATCH]  out.append  (  value,  start,  end  )  ;  return;	[BUG]  [BUGGY]  [FE]  expected:<a[,b,c]>  but  was:<a[ "a ",b "b ",c "c "]>  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]  if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);        if  (c  <=  '  ')  {  quote  =  true;  }  }  }  }  if  (!quote)  {    [BUGGY]  [BUGGY]    }    out.append(encapsulator);      while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {          [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P14_Delete_Statement]
[PATCH]  out.append  (  value,  start,  end  )  ;	[BUG]  [BUGGY]  print(  value,  true)  ;out.append(  value,  start,  end)  ;[CE]  no  suitable  method  found  for  print(CharSequence,boolean)  [CONTEXT]  if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);        if  (c  <=  '  ')  {  quote  =  true;  }  }  }  }  if  (!quote)  {    [BUGGY]  print(  value,  true)  ;out.append(  value,  start,  end)  ;  [BUGGY]  return;  }    out.append(encapsulator);      while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {      out.append(value,  start,  pos  +  1);    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  out.append  (  value,  start,  end  )  ;	[BUG]  [BUGGY]  out.append(  format.getCommentStart(  )  )  ;out.append(  value,  start,  end)  ;[FE]  expected:<[a,b,]c>  but  was:<[  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]  if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);        if  (c  <=  '  ')  {  quote  =  true;  }  }  }  }  if  (!quote)  {    [BUGGY]  out.append(  format.getCommentStart(  )  )  ;out.append(  value,  start,  end)  ;  [BUGGY]  return;  }    out.append(encapsulator);      while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {      out.append(value,  start,  pos  +  1);    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  out.append  (  value,  start,  end  )  ;	[BUG]  [BUGGY]  out.append(  value,  start,  pos)  ;out.append(  value,  start,  end)  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);        if  (c  <=  '  ')  {  quote  =  true;  }  }  }  }  if  (!quote)  {    [BUGGY]  out.append(  value,  start,  pos)  ;out.append(  value,  start,  end)  ;  [BUGGY]  return;  }    out.append(encapsulator);      while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {      out.append(value,  start,  pos  +  1);    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  out.append  (  value,  start,  end  )  ;	[BUG]  [BUGGY]  out.append(  value)  ;out.append(  value,  start,  end)  ;[FE]  expected:<a[,b,]c>  but  was:<a[a,bb,c]c>  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]  if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);        if  (c  <=  '  ')  {  quote  =  true;  }  }  }  }  if  (!quote)  {    [BUGGY]  out.append(  value)  ;out.append(  value,  start,  end)  ;  [BUGGY]  return;  }    out.append(encapsulator);      while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {      out.append(value,  start,  pos  +  1);    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  out.append  (  value,  start,  end  )  ;	[BUG]  [BUGGY]  out.append(  format.getLineSeparator(  )  )  ;out.append(  value,  start,  end)  ;[FE]  expected:<a,[b,]c>  but  was:<a,[  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]  if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);        if  (c  <=  '  ')  {  quote  =  true;  }  }  }  }  if  (!quote)  {    [BUGGY]  out.append(  format.getLineSeparator(  )  )  ;out.append(  value,  start,  end)  ;  [BUGGY]  return;  }    out.append(encapsulator);      while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {      out.append(value,  start,  pos  +  1);    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  out.append  (  value,  start,  end  )  ;	[BUG]  [BUGGY]  out.append(  value,  offset,  offset  +  len)  ;out.append(  value,  start,  end)  ;[FE]  expected:<a[,b,]c>  but  was:<a[a,bb,c]c>  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]  if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);        if  (c  <=  '  ')  {  quote  =  true;  }  }  }  }  if  (!quote)  {    [BUGGY]  out.append(  value,  offset,  offset  +  len)  ;out.append(  value,  start,  end)  ;  [BUGGY]  return;  }    out.append(encapsulator);      while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {      out.append(value,  start,  pos  +  1);    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  out.append  (  value,  start,  end  )  ;	[BUG]  [BUGGY]  out.append(  encapsulator)  ;out.append(  value,  start,  end)  ;[FE]  expected:<[a,b,]c>  but  was:<[ "a, "b, "]c>  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]  if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);        if  (c  <=  '  ')  {  quote  =  true;  }  }  }  }  if  (!quote)  {    [BUGGY]  out.append(  encapsulator)  ;out.append(  value,  start,  end)  ;  [BUGGY]  return;  }    out.append(encapsulator);      while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {      out.append(value,  start,  pos  +  1);    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  out.append  (  value,  start,  end  )  ;	[BUG]  [BUGGY]  printAndEscape(  value,  offset,  len)  ;out.append(  value,  start,  end)  ;[FE]  expected:<[a,b,]c>  but  was:<[,aa,,bb,,c]c>  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]  if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);        if  (c  <=  '  ')  {  quote  =  true;  }  }  }  }  if  (!quote)  {    [BUGGY]  printAndEscape(  value,  offset,  len)  ;out.append(  value,  start,  end)  ;  [BUGGY]  return;  }    out.append(encapsulator);      while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {      out.append(value,  start,  pos  +  1);    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  out.append  (  value,  start,  end  )  ;	[BUG]  [BUGGY]  out.append(  format.getDelimiter(  )  )  ;out.append(  value,  start,  end)  ;[FE]  expected:<[a,b],c>  but  was:<[,a,,b,],c>  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]  if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);        if  (c  <=  '  ')  {  quote  =  true;  }  }  }  }  if  (!quote)  {    [BUGGY]  out.append(  format.getDelimiter(  )  )  ;out.append(  value,  start,  end)  ;  [BUGGY]  return;  }    out.append(encapsulator);      while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {      out.append(value,  start,  pos  +  1);    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  out.append  (  value,  start,  end  )  ;	[BUG]  [BUGGY]  out.append(  value,  start,  pos  +  1)  ;out.append(  value,  start,  end)  ;[FE]  expected:<a[,b,]c>  but  was:<a[a,bb,c]c>  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]  if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);        if  (c  <=  '  ')  {  quote  =  true;  }  }  }  }  if  (!quote)  {    [BUGGY]  out.append(  value,  start,  pos  +  1)  ;out.append(  value,  start,  end)  ;  [BUGGY]  return;  }    out.append(encapsulator);      while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {      out.append(value,  start,  pos  +  1);    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  out.append  (  value,  start,  end  )  ;	[BUG]  [BUGGY]  out.append(  '  ')  ;out.append(  value,  start,  end)  ;[FE]  expected:<a,[b,]c>  but  was:<a,[  b,  ]c>  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]  if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);        if  (c  <=  '  ')  {  quote  =  true;  }  }  }  }  if  (!quote)  {    [BUGGY]  out.append(  '  ')  ;out.append(  value,  start,  end)  ;  [BUGGY]  return;  }    out.append(encapsulator);      while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {      out.append(value,  start,  pos  +  1);    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  out.append  (  value,  start,  end  )  ;	[BUG]  [BUGGY]  out.append(  escape)  ;out.append(  value,  start,  end)  ;[CE]  cannot  find  symbol  escape  [CONTEXT]  if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);        if  (c  <=  '  ')  {  quote  =  true;  }  }  }  }  if  (!quote)  {    [BUGGY]  out.append(  escape)  ;out.append(  value,  start,  end)  ;  [BUGGY]  return;  }    out.append(encapsulator);      while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {      out.append(value,  start,  pos  +  1);    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  out.append  (  value,  start,  end  )  ;	[BUG]  [BUGGY]  [FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);        if  (c  <=  '  ')  {  quote  =  true;  }  }  }  }  if  (!quote)  {    [BUGGY]  [BUGGY]    return;  }    out.append(encapsulator);      while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {          [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P14_Delete_Statement]
[PATCH]  out.append  (  encapsulator  )  ;	[BUG]  [BUGGY]  out.append(  delim)  ;[FE]  expected:<[ "]x,y ",z>  but  was:<[,]x,y ",z>  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]    if  (c  <=  '  ')  {  quote  =  true;  }  }  }  }  if  (!quote)  {    out.append(value,  start,  end);  return;  }    [BUGGY]  out.append(  delim)  ;  [BUGGY]        while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {      out.append(value,  start,  pos  +  1);      start  =  pos;  }  pos++;    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P5_Replace_Variable]
[PATCH]  out.append  (  encapsulator  )  ;	[BUG]  [BUGGY]  [FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]    if  (c  <=  '  ')  {  quote  =  true;  }  }  }  }  if  (!quote)  {    out.append(value,  start,  end);  return;  }    [BUGGY]  [BUGGY]        while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {      out.append(value,  start,  pos  +  1);      start  =  pos;  }    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P14_Delete_Statement]
[PATCH]  out.append  (  encapsulator  )  ;	[BUG]  [BUGGY]  out.append(  value,  start,  end)  ;out.append(  encapsulator)  ;[FE]  expected:<[] "x,y ",z>  but  was:<[x,y] "x,y ",z>  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]    if  (c  <=  '  ')  {  quote  =  true;  }  }  }  }  if  (!quote)  {    out.append(value,  start,  end);  return;  }    [BUGGY]  out.append(  value,  start,  end)  ;out.append(  encapsulator)  ;  [BUGGY]        while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {      out.append(value,  start,  pos  +  1);      start  =  pos;  }  pos++;    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  out.append  (  encapsulator  )  ;	[BUG]  [BUGGY]  out.append(  value,  start,  pos)  ;out.append(  encapsulator)  ;[FE]  expected:<[] "x,y ",z>  but  was:<[x] "x,y ",z>  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]    if  (c  <=  '  ')  {  quote  =  true;  }  }  }  }  if  (!quote)  {    out.append(value,  start,  end);  return;  }    [BUGGY]  out.append(  value,  start,  pos)  ;out.append(  encapsulator)  ;  [BUGGY]        while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {      out.append(value,  start,  pos  +  1);      start  =  pos;  }  pos++;    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  out.append  (  encapsulator  )  ;	[BUG]  [BUGGY]  out.append(  c)  ;out.append(  encapsulator)  ;[CE]  cannot  find  symbol  c  [CONTEXT]    if  (c  <=  '  ')  {  quote  =  true;  }  }  }  }  if  (!quote)  {    out.append(value,  start,  end);  return;  }    [BUGGY]  out.append(  c)  ;out.append(  encapsulator)  ;  [BUGGY]        while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {      out.append(value,  start,  pos  +  1);      start  =  pos;  }  pos++;    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  out.append  (  encapsulator  )  ;	[BUG]  [BUGGY]  out.append(  value)  ;out.append(  encapsulator)  ;[FE]  expected:<[] "x,y ",z>  but  was:<[x,y] "x,y ",z>  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]    if  (c  <=  '  ')  {  quote  =  true;  }  }  }  }  if  (!quote)  {    out.append(value,  start,  end);  return;  }    [BUGGY]  out.append(  value)  ;out.append(  encapsulator)  ;  [BUGGY]        while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {      out.append(value,  start,  pos  +  1);      start  =  pos;  }  pos++;    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  out.append  (  encapsulator  )  ;	[BUG]  [BUGGY]  out.append(  value,  start,  pos  +  1)  ;out.append(  encapsulator)  ;[FE]  expected:<[] "x,y ",z>  but  was:<[x,] "x,y ",z>  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]    if  (c  <=  '  ')  {  quote  =  true;  }  }  }  }  if  (!quote)  {    out.append(value,  start,  end);  return;  }    [BUGGY]  out.append(  value,  start,  pos  +  1)  ;out.append(  encapsulator)  ;  [BUGGY]        while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {      out.append(value,  start,  pos  +  1);      start  =  pos;  }  pos++;    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  out.append  (  encapsulator  )  ;	[BUG]  [BUGGY]  out.append(  '  ')  ;out.append(  encapsulator)  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]    if  (c  <=  '  ')  {  quote  =  true;  }  }  }  }  if  (!quote)  {    out.append(value,  start,  end);  return;  }    [BUGGY]  out.append(  '  ')  ;out.append(  encapsulator)  ;  [BUGGY]        while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {      out.append(value,  start,  pos  +  1);      start  =  pos;  }  pos++;    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  out.append  (  encapsulator  )  ;	[BUG]  [BUGGY]  out.append(  escape)  ;out.append(  encapsulator)  ;[CE]  cannot  find  symbol  escape  [CONTEXT]    if  (c  <=  '  ')  {  quote  =  true;  }  }  }  }  if  (!quote)  {    out.append(value,  start,  end);  return;  }    [BUGGY]  out.append(  escape)  ;out.append(  encapsulator)  ;  [BUGGY]        while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {      out.append(value,  start,  pos  +  1);      start  =  pos;  }  pos++;    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  out.append  (  encapsulator  )  ;	[BUG]  [BUGGY]  if  (  c  ==  encapsulator)  {  out.append(  encapsulator)  ;  }[CE]  cannot  find  symbol  c  [CONTEXT]    if  (c  <=  '  ')  {  quote  =  true;  }  }  }  }  if  (!quote)  {    out.append(value,  start,  end);  return;  }    [BUGGY]  if  (  c  ==  encapsulator)  {  out.append(  encapsulator)  ;  }  [BUGGY]        while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {      out.append(value,  start,  pos  +  1);      start  =  pos;  }  pos++;    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P12_Insert_Condition]
[PATCH]  while  (  pos  <  end  )  {	[BUG]  [BUGGY]  while  (  pos  <=  end)  {[FE]  String  index  out  of  range:  3  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]  }  }  }  if  (!quote)  {    out.append(value,  start,  end);  return;  }    out.append(encapsulator);      [BUGGY]  while  (  pos  <=  end)  {  [BUGGY]  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {      out.append(value,  start,  pos  +  1);      start  =  pos;  }  pos++;  }    out.append(value,  start,  pos);    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P2_Replace_Operator]
[PATCH]  while  (  pos  <  end  )  {	[BUG]  [BUGGY]  while  (  pos  <  pos)  {[FE]  expected:< "x[,y] ",z>  but  was:< "x[] ",z>  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]  }  }  }  if  (!quote)  {    out.append(value,  start,  end);  return;  }    out.append(encapsulator);      [BUGGY]  while  (  pos  <  pos)  {  [BUGGY]  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {      out.append(value,  start,  pos  +  1);      start  =  pos;  }  pos++;  }    out.append(value,  start,  pos);    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P5_Replace_Variable]
[PATCH]  while  (  pos  <  end  )  {	[BUG]  [BUGGY]  while  (  pos  <  start)  {[FE]  expected:< "x[,y] ",z>  but  was:< "x[] ",z>  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]  }  }  }  if  (!quote)  {    out.append(value,  start,  end);  return;  }    out.append(encapsulator);      [BUGGY]  while  (  pos  <  start)  {  [BUGGY]  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {      out.append(value,  start,  pos  +  1);      start  =  pos;  }  pos++;  }    out.append(value,  start,  pos);    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P8_Replace_Mix]
[PATCH]  if  (  c  ==  encapsulator  )  {	[BUG]  [BUGGY]  if  (  c  !=  encapsulator)  {[FE]  expected:< "x,[]y ",z>  but  was:< "x,[,y]y ",z>  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]  }  if  (!quote)  {    out.append(value,  start,  end);  return;  }    out.append(encapsulator);      while  (pos  <  end)  {  char  c  =  value.charAt(pos);  [BUGGY]  if  (  c  !=  encapsulator)  {  [BUGGY]        out.append(value,  start,  pos  +  1);      start  =  pos;  }  pos++;  }    out.append(value,  start,  pos);  out.append(encapsulator);  }    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P2_Replace_Operator]
[PATCH]  if  (  c  ==  encapsulator  )  {	[BUG]  [BUGGY]  if  (  delim  ==  encapsulator)  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  }  if  (!quote)  {    out.append(value,  start,  end);  return;  }    out.append(encapsulator);      while  (pos  <  end)  {  char  c  =  value.charAt(pos);  [BUGGY]  if  (  delim  ==  encapsulator)  {  [BUGGY]        out.append(value,  start,  pos  +  1);      start  =  pos;  }  pos++;  }    out.append(value,  start,  pos);  out.append(encapsulator);  }    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P5_Replace_Variable]
[PATCH]  if  (  c  ==  encapsulator  )  {	[BUG]  [BUGGY]  if  (  c  ==  delim)  {[FE]  expected:< "x,[]y ",z>  but  was:< "x,[,]y ",z>  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]  }  if  (!quote)  {    out.append(value,  start,  end);  return;  }    out.append(encapsulator);      while  (pos  <  end)  {  char  c  =  value.charAt(pos);  [BUGGY]  if  (  c  ==  delim)  {  [BUGGY]        out.append(value,  start,  pos  +  1);      start  =  pos;  }  pos++;  }    out.append(value,  start,  pos);  out.append(encapsulator);  }    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P5_Replace_Variable]
[PATCH]  if  (  c  ==  encapsulator  )  {	[BUG]  [BUGGY]  if  (  encapsulator  ==  c)  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  }  if  (!quote)  {    out.append(value,  start,  end);  return;  }    out.append(encapsulator);      while  (pos  <  end)  {  char  c  =  value.charAt(pos);  [BUGGY]  if  (  encapsulator  ==  c)  {  [BUGGY]        out.append(value,  start,  pos  +  1);      start  =  pos;  }  pos++;  }    out.append(value,  start,  pos);  out.append(encapsulator);  }    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P5_Replace_Variable]
[PATCH]  if  (  c  ==  encapsulator  )  {	[BUG]  [BUGGY]  if  (  pos  +  1)  {[CE]  incompatible  types  [CONTEXT]  }  if  (!quote)  {    out.append(value,  start,  end);  return;  }    out.append(encapsulator);      while  (pos  <  end)  {  char  c  =  value.charAt(pos);  [BUGGY]  if  (  pos  +  1)  {  [BUGGY]        out.append(value,  start,  pos  +  1);      start  =  pos;  }  pos++;  }    out.append(value,  start,  pos);  out.append(encapsulator);  }    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P6_Replace_Expression]
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  pos  >  start)  {      out.append(  value,  start,  pos)  ;  }[CE]  <identifier>  expected  [CONTEXT]  }  if  (!quote)  {    out.append(value,  start,  end);  return;  }    out.append(encapsulator);      while  (pos  <  end)  {  char  c  =  value.charAt(pos);  [BUGGY]  if  (  pos  >  start)  {      out.append(  value,  start,  pos)  ;  }  [BUGGY]        out.append(value,  start,  pos  +  1);      start  =  pos;  }  pos++;  }    out.append(value,  start,  pos);  out.append(encapsulator);  }    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P13_Insert_Block]
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  !quote)  {      out.append(  value,  start,  end)  ;      return  ;  }[CE]  <identifier>  expected  [CONTEXT]  }  if  (!quote)  {    out.append(value,  start,  end);  return;  }    out.append(encapsulator);      while  (pos  <  end)  {  char  c  =  value.charAt(pos);  [BUGGY]  if  (  !quote)  {      out.append(  value,  start,  end)  ;      return  ;  }  [BUGGY]        out.append(value,  start,  pos  +  1);      start  =  pos;  }  pos++;  }    out.append(value,  start,  pos);  out.append(encapsulator);  }    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P13_Insert_Block]
[PATCH]  start  =  pos;	[BUG]  [BUGGY]  start  =  start;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]    out.append(encapsulator);      while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {      out.append(value,  start,  pos  +  1);      [BUGGY]  start  =  start;  [BUGGY]  }  pos++;  }    out.append(value,  start,  pos);  out.append(encapsulator);  }                  [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P5_Replace_Variable]
[PATCH]  start  =  pos;	[BUG]  [BUGGY]  start  =  offset;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]    out.append(encapsulator);      while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {      out.append(value,  start,  pos  +  1);      [BUGGY]  start  =  offset;  [BUGGY]  }  pos++;  }    out.append(value,  start,  pos);  out.append(encapsulator);  }                  [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P8_Replace_Mix]
[PATCH]  start  =  pos;	[BUG]  [BUGGY]  start  =  pos  +  1;start  =  pos;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]    out.append(encapsulator);      while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {      out.append(value,  start,  pos  +  1);      [BUGGY]  start  =  pos  +  1;start  =  pos;  [BUGGY]  }  pos++;  }    out.append(value,  start,  pos);  out.append(encapsulator);  }                  [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  out.append  (  value,  start,  pos  +  1  )  ;	[BUG]  [BUGGY]  out.append(  value,  start,  pos    instanceof    1)  ;[CE]  illegal  start  of  type  [CONTEXT]  out.append(value,  start,  end);  return;  }    out.append(encapsulator);      while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {      [BUGGY]  out.append(  value,  start,  pos    instanceof    1)  ;  [BUGGY]      start  =  pos;  }  pos++;  }    out.append(value,  start,  pos);  out.append(encapsulator);  }            [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P2_Replace_Operator]
[PATCH]  out.append  (  value,  start,  pos  +  1  )  ;	[BUG]  [BUGGY]  out.append(  value,  start,  pos  +  )  ;[CE]  illegal  start  of  expression  [CONTEXT]  out.append(value,  start,  end);  return;  }    out.append(encapsulator);      while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {      [BUGGY]  out.append(  value,  start,  pos  +  )  ;  [BUGGY]      start  =  pos;  }  pos++;  }    out.append(value,  start,  pos);  out.append(encapsulator);  }            [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P3_Replace_Literal]
[PATCH]  out.append  (  value,  start,  pos  +  1  )  ;	[BUG]  [BUGGY]  out.append(  value,  offset,  pos  +  1)  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  out.append(value,  start,  end);  return;  }    out.append(encapsulator);      while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {      [BUGGY]  out.append(  value,  offset,  pos  +  1)  ;  [BUGGY]      start  =  pos;  }  pos++;  }    out.append(value,  start,  pos);  out.append(encapsulator);  }            [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P5_Replace_Variable]
[PATCH]  out.append  (  value,  start,  pos  +  1  )  ;	[BUG]  [BUGGY]  out.append(  value,  start,  offset  +  1)  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  out.append(value,  start,  end);  return;  }    out.append(encapsulator);      while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {      [BUGGY]  out.append(  value,  start,  offset  +  1)  ;  [BUGGY]      start  =  pos;  }  pos++;  }    out.append(value,  start,  pos);  out.append(encapsulator);  }            [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P5_Replace_Variable]
[PATCH]  out.append  (  value,  start,  pos  +  1  )  ;	[BUG]  [BUGGY]  out.append(  start,  pos  +  1)  ;[CE]  no  suitable  method  found  for  append(int,int)  [CONTEXT]  out.append(value,  start,  end);  return;  }    out.append(encapsulator);      while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {      [BUGGY]  out.append(  start,  pos  +  1)  ;  [BUGGY]      start  =  pos;  }  pos++;  }    out.append(value,  start,  pos);  out.append(encapsulator);  }            [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P5_Replace_Variable]
[PATCH]  out.append  (  value,  start,  pos  +  1  )  ;	[BUG]  [BUGGY]  out.append(  value,  pos  +  1)  ;[CE]  no  suitable  method  found  for  append(CharSequence,int)  [CONTEXT]  out.append(value,  start,  end);  return;  }    out.append(encapsulator);      while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {      [BUGGY]  out.append(  value,  pos  +  1)  ;  [BUGGY]      start  =  pos;  }  pos++;  }    out.append(value,  start,  pos);  out.append(encapsulator);  }            [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P5_Replace_Variable]
[PATCH]  out.append  (  value,  start,  pos  +  1  )  ;	[BUG]  [BUGGY]  out.append(  value,  start  +  1)  ;[CE]  no  suitable  method  found  for  append(CharSequence,int)  [CONTEXT]  out.append(value,  start,  end);  return;  }    out.append(encapsulator);      while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {      [BUGGY]  out.append(  value,  start  +  1)  ;  [BUGGY]      start  =  pos;  }  pos++;  }    out.append(value,  start,  pos);  out.append(encapsulator);  }            [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P5_Replace_Variable]
[PATCH]  out.append  (  value,  start,  pos  +  1  )  ;	[BUG]  [BUGGY]  out.append(  value,  pos,  start  +  1)  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  out.append(value,  start,  end);  return;  }    out.append(encapsulator);      while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {      [BUGGY]  out.append(  value,  pos,  start  +  1)  ;  [BUGGY]      start  =  pos;  }  pos++;  }    out.append(value,  start,  pos);  out.append(encapsulator);  }            [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P5_Replace_Variable]
[PATCH]  out.append  (  value,  start,  pos  +  1  )  ;	[BUG]  [BUGGY]  out.append(  value)  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  out.append(value,  start,  end);  return;  }    out.append(encapsulator);      while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {      [BUGGY]  out.append(  value)  ;  [BUGGY]      start  =  pos;  }  pos++;  }    out.append(value,  start,  pos);  out.append(encapsulator);  }            [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P7_Replace_Invocation]
[PATCH]  out.append  (  value,  start,  pos  +  1  )  ;	[BUG]  [BUGGY]  out.append(  value,  pos,  pos  +  1)  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  out.append(value,  start,  end);  return;  }    out.append(encapsulator);      while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {      [BUGGY]  out.append(  value,  pos,  pos  +  1)  ;  [BUGGY]      start  =  pos;  }  pos++;  }    out.append(value,  start,  pos);  out.append(encapsulator);  }            [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P8_Replace_Mix]
[PATCH]  out.append  (  value,  start,  pos  +  1  )  ;	[BUG]  [BUGGY]  [FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  out.append(value,  start,  end);  return;  }    out.append(encapsulator);      while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {      [BUGGY]  [BUGGY]        start  =  pos;  }  pos++;  }    out.append(value,  start,  pos);  out.append(encapsulator);  }          [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P14_Delete_Statement]
[PATCH]  out.append  (  value,  start,  pos  +  1  )  ;	[BUG]  [BUGGY]  out.append(  value,  start,  end)  ;out.append(  value,  start,  pos  +  1)  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  out.append(value,  start,  end);  return;  }    out.append(encapsulator);      while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {      [BUGGY]  out.append(  value,  start,  end)  ;out.append(  value,  start,  pos  +  1)  ;  [BUGGY]      start  =  pos;  }  pos++;  }    out.append(value,  start,  pos);  out.append(encapsulator);  }            [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  out.append  (  value,  start,  pos  +  1  )  ;	[BUG]  [BUGGY]  out.append(  format.getCommentStart(  )  )  ;out.append(  value,  start,  pos  +  1)  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  out.append(value,  start,  end);  return;  }    out.append(encapsulator);      while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {      [BUGGY]  out.append(  format.getCommentStart(  )  )  ;out.append(  value,  start,  pos  +  1)  ;  [BUGGY]      start  =  pos;  }  pos++;  }    out.append(value,  start,  pos);  out.append(encapsulator);  }            [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  out.append  (  value,  start,  pos  +  1  )  ;	[BUG]  [BUGGY]  out.append(  value,  start,  pos)  ;out.append(  value,  start,  pos  +  1)  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  out.append(value,  start,  end);  return;  }    out.append(encapsulator);      while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {      [BUGGY]  out.append(  value,  start,  pos)  ;out.append(  value,  start,  pos  +  1)  ;  [BUGGY]      start  =  pos;  }  pos++;  }    out.append(value,  start,  pos);  out.append(encapsulator);  }            [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  out.append  (  value,  start,  pos  +  1  )  ;	[BUG]  [BUGGY]  out.append(  value)  ;out.append(  value,  start,  pos  +  1)  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  out.append(value,  start,  end);  return;  }    out.append(encapsulator);      while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {      [BUGGY]  out.append(  value)  ;out.append(  value,  start,  pos  +  1)  ;  [BUGGY]      start  =  pos;  }  pos++;  }    out.append(value,  start,  pos);  out.append(encapsulator);  }            [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  out.append  (  value,  start,  pos  +  1  )  ;	[BUG]  [BUGGY]  out.append(  format.getLineSeparator(  )  )  ;out.append(  value,  start,  pos  +  1)  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  out.append(value,  start,  end);  return;  }    out.append(encapsulator);      while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {      [BUGGY]  out.append(  format.getLineSeparator(  )  )  ;out.append(  value,  start,  pos  +  1)  ;  [BUGGY]      start  =  pos;  }  pos++;  }    out.append(value,  start,  pos);  out.append(encapsulator);  }            [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  out.append  (  value,  start,  pos  +  1  )  ;	[BUG]  [BUGGY]  out.append(  value,  offset,  offset  +  len)  ;out.append(  value,  start,  pos  +  1)  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  out.append(value,  start,  end);  return;  }    out.append(encapsulator);      while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {      [BUGGY]  out.append(  value,  offset,  offset  +  len)  ;out.append(  value,  start,  pos  +  1)  ;  [BUGGY]      start  =  pos;  }  pos++;  }    out.append(value,  start,  pos);  out.append(encapsulator);  }            [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  out.append  (  value,  start,  pos  +  1  )  ;	[BUG]  [BUGGY]  out.append(  encapsulator)  ;out.append(  value,  start,  pos  +  1)  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  out.append(value,  start,  end);  return;  }    out.append(encapsulator);      while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {      [BUGGY]  out.append(  encapsulator)  ;out.append(  value,  start,  pos  +  1)  ;  [BUGGY]      start  =  pos;  }  pos++;  }    out.append(value,  start,  pos);  out.append(encapsulator);  }            [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  out.append  (  value,  start,  pos  +  1  )  ;	[BUG]  [BUGGY]  out.append(  escape)  ;out.append(  value,  start,  pos  +  1)  ;[CE]  cannot  find  symbol  escape  [CONTEXT]  out.append(value,  start,  end);  return;  }    out.append(encapsulator);      while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {      [BUGGY]  out.append(  escape)  ;out.append(  value,  start,  pos  +  1)  ;  [BUGGY]      start  =  pos;  }  pos++;  }    out.append(value,  start,  pos);  out.append(encapsulator);  }            [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  char  c  =  value.charAt  (  pos  )  ;	[BUG]  [BUGGY]  String  c  =  value.charAt(  pos)  ;[CE]  incompatible  types  [CONTEXT]  }  }  if  (!quote)  {    out.append(value,  start,  end);  return;  }    out.append(encapsulator);      while  (pos  <  end)  {  [BUGGY]  String  c  =  value.charAt(  pos)  ;  [BUGGY]  if  (c  ==  encapsulator)  {      out.append(value,  start,  pos  +  1);      start  =  pos;  }  pos++;  }    out.append(value,  start,  pos);  out.append(encapsulator);    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P1_Replace_Type]
[PATCH]  char  c  =  value.charAt  (  pos  )  ;	[BUG]  [BUGGY]  char  c  =  value.charAt(  start)  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  }  }  if  (!quote)  {    out.append(value,  start,  end);  return;  }    out.append(encapsulator);      while  (pos  <  end)  {  [BUGGY]  char  c  =  value.charAt(  start)  ;  [BUGGY]  if  (c  ==  encapsulator)  {      out.append(value,  start,  pos  +  1);      start  =  pos;  }  pos++;  }    out.append(value,  start,  pos);  out.append(encapsulator);    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P5_Replace_Variable]
[PATCH]  char  c  =  value.charAt  (  pos  )  ;	[BUG]  [BUGGY]  char  c  =  pos.charAt(  value)  ;[CE]  int  cannot  be  dereferenced  [CONTEXT]  }  }  if  (!quote)  {    out.append(value,  start,  end);  return;  }    out.append(encapsulator);      while  (pos  <  end)  {  [BUGGY]  char  c  =  pos.charAt(  value)  ;  [BUGGY]  if  (c  ==  encapsulator)  {      out.append(value,  start,  pos  +  1);      start  =  pos;  }  pos++;  }    out.append(value,  start,  pos);  out.append(encapsulator);    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P5_Replace_Variable]
[PATCH]  char  c  =  value.charAt  (  pos  )  ;	[BUG]  [BUGGY]  char  c  =  comment.charAt(  i)  ;char  c  =  value.charAt(  pos)  ;[CE]  cannot  find  symbol  i  [CONTEXT]  }  }  if  (!quote)  {    out.append(value,  start,  end);  return;  }    out.append(encapsulator);      while  (pos  <  end)  {  [BUGGY]  char  c  =  comment.charAt(  i)  ;char  c  =  value.charAt(  pos)  ;  [BUGGY]  if  (c  ==  encapsulator)  {      out.append(value,  start,  pos  +  1);      start  =  pos;  }  pos++;  }    out.append(value,  start,  pos);  out.append(encapsulator);    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  char  c  =  value.charAt  (  pos  )  ;	[BUG]  [BUGGY]  char  c  =  value.charAt(  offset)  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  }  }  if  (!quote)  {    out.append(value,  start,  end);  return;  }    out.append(encapsulator);      while  (pos  <  end)  {  [BUGGY]  char  c  =  value.charAt(  offset)  ;  [BUGGY]  if  (c  ==  encapsulator)  {      out.append(value,  start,  pos  +  1);      start  =  pos;  }  pos++;  }    out.append(value,  start,  pos);  out.append(encapsulator);    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P5_Replace_Variable]
[PATCH]  char  c  =  value.charAt  (  pos  )  ;	[BUG]  [BUGGY]  [FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  }  }  if  (!quote)  {    out.append(value,  start,  end);  return;  }    out.append(encapsulator);      while  (pos  <  end)  {  [BUGGY]  [BUGGY]    if  (c  ==  encapsulator)  {      out.append(value,  start,  pos  +  1);      start  =  pos;  }  pos++;  }    out.append(value,  start,  pos);    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P14_Delete_Statement]
[PATCH]  char  c  =  value.charAt  (  pos  )  ;	[BUG]  [BUGGY]  c  =  value.charAt(  pos)  ;char  c  =  value.charAt(  pos)  ;[CE]  cannot  find  symbol  c  [CONTEXT]  }  }  if  (!quote)  {    out.append(value,  start,  end);  return;  }    out.append(encapsulator);      while  (pos  <  end)  {  [BUGGY]  c  =  value.charAt(  pos)  ;char  c  =  value.charAt(  pos)  ;  [BUGGY]  if  (c  ==  encapsulator)  {      out.append(value,  start,  pos  +  1);      start  =  pos;  }  pos++;  }    out.append(value,  start,  pos);  out.append(encapsulator);    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  out.append  (  value,  start,  pos  +  1  )  ;	[BUG]  [BUGGY]  out.append(  value,  start,  pos  |  1)  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  out.append(value,  start,  end);  return;  }    out.append(encapsulator);      while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {      [BUGGY]  out.append(  value,  start,  pos  |  1)  ;  [BUGGY]      start  =  pos;  }  pos++;  }    out.append(value,  start,  pos);  out.append(encapsulator);  }            [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P2_Replace_Operator]
[PATCH]  out.append  (  value,  start,  pos  +  1  )  ;	[BUG]  [BUGGY]  out.append(  value,  start,  pos  +  start)  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  out.append(value,  start,  end);  return;  }    out.append(encapsulator);      while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {      [BUGGY]  out.append(  value,  start,  pos  +  start)  ;  [BUGGY]      start  =  pos;  }  pos++;  }    out.append(value,  start,  pos);  out.append(encapsulator);  }            [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P3_Replace_Literal]
[PATCH]  out.append  (  value,  start,  pos  +  1  )  ;	[BUG]  [BUGGY]  out.append(  start,  value,  pos  +  1)  ;[CE]  no  suitable  method  found  for  append(int,CharSequence,int)  [CONTEXT]  out.append(value,  start,  end);  return;  }    out.append(encapsulator);      while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {      [BUGGY]  out.append(  start,  value,  pos  +  1)  ;  [BUGGY]      start  =  pos;  }  pos++;  }    out.append(value,  start,  pos);  out.append(encapsulator);  }            [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P5_Replace_Variable]
[PATCH]  if  (  c  ==  encapsulator  )  {	[BUG]  [BUGGY]  if  (  c  <=  encapsulator)  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  }  if  (!quote)  {    out.append(value,  start,  end);  return;  }    out.append(encapsulator);      while  (pos  <  end)  {  char  c  =  value.charAt(pos);  [BUGGY]  if  (  c  <=  encapsulator)  {  [BUGGY]        out.append(value,  start,  pos  +  1);      start  =  pos;  }  pos++;  }    out.append(value,  start,  pos);  out.append(encapsulator);  }    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P2_Replace_Operator]
[PATCH]  out.append  (  value,  start,  pos  +  1  )  ;	[BUG]  [BUGGY]  out.append(  value,  start,  pos  ==  1)  ;[CE]  no  suitable  method  found  for  append(CharSequence,int,boolean)  [CONTEXT]  out.append(value,  start,  end);  return;  }    out.append(encapsulator);      while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {      [BUGGY]  out.append(  value,  start,  pos  ==  1)  ;  [BUGGY]      start  =  pos;  }  pos++;  }    out.append(value,  start,  pos);  out.append(encapsulator);  }            [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P2_Replace_Operator]
[PATCH]  out.append  (  value,  start,  pos  +  1  )  ;	[BUG]  [BUGGY]  out.append(  value,  start,  pos  +  offset)  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  out.append(value,  start,  end);  return;  }    out.append(encapsulator);      while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {      [BUGGY]  out.append(  value,  start,  pos  +  offset)  ;  [BUGGY]      start  =  pos;  }  pos++;  }    out.append(value,  start,  pos);  out.append(encapsulator);  }            [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P3_Replace_Literal]
[PATCH]  out.append  (  value,  start,  pos  +  1  )  ;	[BUG]  [BUGGY]  out.append(  value,  start,  start  +  1)  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  out.append(value,  start,  end);  return;  }    out.append(encapsulator);      while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {      [BUGGY]  out.append(  value,  start,  start  +  1)  ;  [BUGGY]      start  =  pos;  }  pos++;  }    out.append(value,  start,  pos);  out.append(encapsulator);  }            [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P5_Replace_Variable]
[PATCH]  char  c  =  value.charAt  (  pos  )  ;	[BUG]  [BUGGY]  int  c  =  value.charAt(  pos)  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  }  }  if  (!quote)  {    out.append(value,  start,  end);  return;  }    out.append(encapsulator);      while  (pos  <  end)  {  [BUGGY]  int  c  =  value.charAt(  pos)  ;  [BUGGY]  if  (c  ==  encapsulator)  {      out.append(value,  start,  pos  +  1);      start  =  pos;  }  pos++;  }    out.append(value,  start,  pos);  out.append(encapsulator);    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P1_Replace_Type]
[PATCH]  out.append  (  value,  start,  pos  +  1  )  ;	[BUG]  [BUGGY]  out.append(  value,  start,  pos  +  end)  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  out.append(value,  start,  end);  return;  }    out.append(encapsulator);      while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {      [BUGGY]  out.append(  value,  start,  pos  +  end)  ;  [BUGGY]      start  =  pos;  }  pos++;  }    out.append(value,  start,  pos);  out.append(encapsulator);  }            [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P3_Replace_Literal]
[PATCH]  out.append  (  value,  start,  pos  +  1  )  ;	[BUG]  [BUGGY]  out.append(  pos,  start,  value  +  1)  ;[CE]  bad  operand  types  for  binary  operator  '+'  [CONTEXT]  out.append(value,  start,  end);  return;  }    out.append(encapsulator);      while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {      [BUGGY]  out.append(  pos,  start,  value  +  1)  ;  [BUGGY]      start  =  pos;  }  pos++;  }    out.append(value,  start,  pos);  out.append(encapsulator);  }            [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P5_Replace_Variable]
[PATCH]  out.append  (  value,  start,  pos  )  ;	[BUG]  [BUGGY]  out.append(  value,  offset,  pos)  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {      out.append(value,  start,  pos  +  1);      start  =  pos;  }  pos++;  }    [BUGGY]  out.append(  value,  offset,  pos)  ;  [BUGGY]  out.append(encapsulator);  }              public  void  print(String  value,  boolean  checkForEscape)  throws  IOException  {  if  (value  ==  null)  {    value  =   " ";  }      [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P5_Replace_Variable]
[PATCH]  out.append  (  value,  start,  pos  )  ;	[BUG]  [BUGGY]  out.append(  value,  start,  offset)  ;[FE]  expected:< "[x,y] ",z>  but  was:< "[] ",z>  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]  while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {      out.append(value,  start,  pos  +  1);      start  =  pos;  }  pos++;  }    [BUGGY]  out.append(  value,  start,  offset)  ;  [BUGGY]  out.append(encapsulator);  }              public  void  print(String  value,  boolean  checkForEscape)  throws  IOException  {  if  (value  ==  null)  {    value  =   " ";  }      [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P5_Replace_Variable]
[PATCH]  out.append  (  value,  start,  pos  )  ;	[BUG]  [BUGGY]  out.append(  start,  pos)  ;[CE]  no  suitable  method  found  for  append(int,int)  [CONTEXT]  while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {      out.append(value,  start,  pos  +  1);      start  =  pos;  }  pos++;  }    [BUGGY]  out.append(  start,  pos)  ;  [BUGGY]  out.append(encapsulator);  }              public  void  print(String  value,  boolean  checkForEscape)  throws  IOException  {  if  (value  ==  null)  {    value  =   " ";  }      [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P5_Replace_Variable]
[PATCH]  out.append  (  value,  start,  pos  )  ;	[BUG]  [BUGGY]  out.append(  value,  pos)  ;[CE]  no  suitable  method  found  for  append(CharSequence,int)  [CONTEXT]  while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {      out.append(value,  start,  pos  +  1);      start  =  pos;  }  pos++;  }    [BUGGY]  out.append(  value,  pos)  ;  [BUGGY]  out.append(encapsulator);  }              public  void  print(String  value,  boolean  checkForEscape)  throws  IOException  {  if  (value  ==  null)  {    value  =   " ";  }      [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P5_Replace_Variable]
[PATCH]  out.append  (  value,  start,  pos  )  ;	[BUG]  [BUGGY]  out.append(  value,  start)  ;[CE]  no  suitable  method  found  for  append(CharSequence,int)  [CONTEXT]  while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {      out.append(value,  start,  pos  +  1);      start  =  pos;  }  pos++;  }    [BUGGY]  out.append(  value,  start)  ;  [BUGGY]  out.append(encapsulator);  }              public  void  print(String  value,  boolean  checkForEscape)  throws  IOException  {  if  (value  ==  null)  {    value  =   " ";  }      [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P5_Replace_Variable]
[PATCH]  out.append  (  value,  start,  pos  )  ;	[BUG]  [BUGGY]  out.append(  start,  value,  pos)  ;[CE]  no  suitable  method  found  for  append(int,CharSequence,int)  [CONTEXT]  while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {      out.append(value,  start,  pos  +  1);      start  =  pos;  }  pos++;  }    [BUGGY]  out.append(  start,  value,  pos)  ;  [BUGGY]  out.append(encapsulator);  }              public  void  print(String  value,  boolean  checkForEscape)  throws  IOException  {  if  (value  ==  null)  {    value  =   " ";  }      [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P5_Replace_Variable]
[PATCH]  out.append  (  value,  start,  pos  )  ;	[BUG]  [BUGGY]  out.append(  value,  pos,  start)  ;[FE]  String  index  out  of  range:  -3  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]  while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {      out.append(value,  start,  pos  +  1);      start  =  pos;  }  pos++;  }    [BUGGY]  out.append(  value,  pos,  start)  ;  [BUGGY]  out.append(encapsulator);  }              public  void  print(String  value,  boolean  checkForEscape)  throws  IOException  {  if  (value  ==  null)  {    value  =   " ";  }      [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P5_Replace_Variable]
[PATCH]  out.append  (  value,  start,  pos  )  ;	[BUG]  [BUGGY]  [FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {      out.append(value,  start,  pos  +  1);      start  =  pos;  }  pos++;  }    [BUGGY]  [BUGGY]    out.append(encapsulator);  }              public  void  print(String  value,  boolean  checkForEscape)  throws  IOException  {  if  (value  ==  null)  {    value  =   " ";  }    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P14_Delete_Statement]
[PATCH]  out.append  (  value,  start,  pos  )  ;	[BUG]  [BUGGY]  out.append(  value,  start,  end)  ;out.append(  value,  start,  pos)  ;[FE]  expected:< "x,y[] ",z>  but  was:< "x,y[x,y] ",z>  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]  while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {      out.append(value,  start,  pos  +  1);      start  =  pos;  }  pos++;  }    [BUGGY]  out.append(  value,  start,  end)  ;out.append(  value,  start,  pos)  ;  [BUGGY]  out.append(encapsulator);  }              public  void  print(String  value,  boolean  checkForEscape)  throws  IOException  {  if  (value  ==  null)  {    value  =   " ";  }      [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  out.append  (  value,  start,  pos  )  ;	[BUG]  [BUGGY]  print(  value,  true)  ;out.append(  value,  start,  pos)  ;[CE]  no  suitable  method  found  for  print(CharSequence,boolean)  [CONTEXT]  while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {      out.append(value,  start,  pos  +  1);      start  =  pos;  }  pos++;  }    [BUGGY]  print(  value,  true)  ;out.append(  value,  start,  pos)  ;  [BUGGY]  out.append(encapsulator);  }              public  void  print(String  value,  boolean  checkForEscape)  throws  IOException  {  if  (value  ==  null)  {    value  =   " ";  }      [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  out.append  (  value,  start,  pos  )  ;	[BUG]  [BUGGY]  out.append(  format.getCommentStart(  )  )  ;out.append(  value,  start,  pos)  ;[FE]  expected:< "[]x,y ",z>  but  was:< "[  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]  while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {      out.append(value,  start,  pos  +  1);      start  =  pos;  }  pos++;  }    [BUGGY]  out.append(  format.getCommentStart(  )  )  ;out.append(  value,  start,  pos)  ;  [BUGGY]  out.append(encapsulator);  }              public  void  print(String  value,  boolean  checkForEscape)  throws  IOException  {  if  (value  ==  null)  {    value  =   " ";  }      [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  out.append  (  value,  start,  pos  )  ;	[BUG]  [BUGGY]  out.append(  value)  ;out.append(  value,  start,  pos)  ;[FE]  expected:< "x,y[] ",z>  but  was:< "x,y[x,y] ",z>  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]  while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {      out.append(value,  start,  pos  +  1);      start  =  pos;  }  pos++;  }    [BUGGY]  out.append(  value)  ;out.append(  value,  start,  pos)  ;  [BUGGY]  out.append(encapsulator);  }              public  void  print(String  value,  boolean  checkForEscape)  throws  IOException  {  if  (value  ==  null)  {    value  =   " ";  }      [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  out.append  (  value,  start,  pos  )  ;	[BUG]  [BUGGY]  out.append(  format.getLineSeparator(  )  )  ;out.append(  value,  start,  pos)  ;[FE]  expected:< "[]x,y ",z>  but  was:< "[  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]  while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {      out.append(value,  start,  pos  +  1);      start  =  pos;  }  pos++;  }    [BUGGY]  out.append(  format.getLineSeparator(  )  )  ;out.append(  value,  start,  pos)  ;  [BUGGY]  out.append(encapsulator);  }              public  void  print(String  value,  boolean  checkForEscape)  throws  IOException  {  if  (value  ==  null)  {    value  =   " ";  }      [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  out.append  (  value,  start,  pos  )  ;	[BUG]  [BUGGY]  out.append(  value,  offset,  offset  +  len)  ;out.append(  value,  start,  pos)  ;[FE]  expected:< "x,y[] ",z>  but  was:< "x,y[x,y] ",z>  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]  while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {      out.append(value,  start,  pos  +  1);      start  =  pos;  }  pos++;  }    [BUGGY]  out.append(  value,  offset,  offset  +  len)  ;out.append(  value,  start,  pos)  ;  [BUGGY]  out.append(encapsulator);  }              public  void  print(String  value,  boolean  checkForEscape)  throws  IOException  {  if  (value  ==  null)  {    value  =   " ";  }      [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  out.append  (  value,  start,  pos  )  ;	[BUG]  [BUGGY]  out.append(  encapsulator)  ;out.append(  value,  start,  pos)  ;[FE]  expected:< "[]x,y ",z>  but  was:< "[ "]x,y ",z>  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]  while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {      out.append(value,  start,  pos  +  1);      start  =  pos;  }  pos++;  }    [BUGGY]  out.append(  encapsulator)  ;out.append(  value,  start,  pos)  ;  [BUGGY]  out.append(encapsulator);  }              public  void  print(String  value,  boolean  checkForEscape)  throws  IOException  {  if  (value  ==  null)  {    value  =   " ";  }      [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  out.append  (  value,  start,  pos  )  ;	[BUG]  [BUGGY]  out.append(  format.getDelimiter(  )  )  ;out.append(  value,  start,  pos)  ;[FE]  expected:< "[]x,y ",z>  but  was:< "[,]x,y ",z>  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]  while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {      out.append(value,  start,  pos  +  1);      start  =  pos;  }  pos++;  }    [BUGGY]  out.append(  format.getDelimiter(  )  )  ;out.append(  value,  start,  pos)  ;  [BUGGY]  out.append(encapsulator);  }              public  void  print(String  value,  boolean  checkForEscape)  throws  IOException  {  if  (value  ==  null)  {    value  =   " ";  }      [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  out.append  (  value,  start,  pos  )  ;	[BUG]  [BUGGY]  out.append(  value,  start,  pos  +  1)  ;out.append(  value,  start,  pos)  ;[FE]  String  index  out  of  range:  4  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]  while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {      out.append(value,  start,  pos  +  1);      start  =  pos;  }  pos++;  }    [BUGGY]  out.append(  value,  start,  pos  +  1)  ;out.append(  value,  start,  pos)  ;  [BUGGY]  out.append(encapsulator);  }              public  void  print(String  value,  boolean  checkForEscape)  throws  IOException  {  if  (value  ==  null)  {    value  =   " ";  }      [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  out.append  (  value,  start,  pos  )  ;	[BUG]  [BUGGY]  out.append(  '  ')  ;out.append(  value,  start,  pos)  ;[FE]  expected:< "[]x,y ",z>  but  was:< "[  ]x,y ",z>  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]  while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {      out.append(value,  start,  pos  +  1);      start  =  pos;  }  pos++;  }    [BUGGY]  out.append(  '  ')  ;out.append(  value,  start,  pos)  ;  [BUGGY]  out.append(encapsulator);  }              public  void  print(String  value,  boolean  checkForEscape)  throws  IOException  {  if  (value  ==  null)  {    value  =   " ";  }      [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  out.append  (  value,  start,  pos  )  ;	[BUG]  [BUGGY]  out.append(  escape)  ;out.append(  value,  start,  pos)  ;[CE]  cannot  find  symbol  escape  [CONTEXT]  while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {      out.append(value,  start,  pos  +  1);      start  =  pos;  }  pos++;  }    [BUGGY]  out.append(  escape)  ;out.append(  value,  start,  pos)  ;  [BUGGY]  out.append(encapsulator);  }              public  void  print(String  value,  boolean  checkForEscape)  throws  IOException  {  if  (value  ==  null)  {    value  =   " ";  }      [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  out.append  (  encapsulator  )  ;	[BUG]  [BUGGY]  out.append(  delim)  ;[FE]  expected:< "x,y[ "],z>  but  was:< "x,y[,],z>  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {      out.append(value,  start,  pos  +  1);      start  =  pos;  }  pos++;  }    out.append(value,  start,  pos);  [BUGGY]  out.append(  delim)  ;  [BUGGY]  }              public  void  print(String  value,  boolean  checkForEscape)  throws  IOException  {  if  (value  ==  null)  {    value  =   " ";  }  if  (!checkForEscape)  {    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P5_Replace_Variable]
[PATCH]  out.append  (  encapsulator  )  ;	[BUG]  [BUGGY]  out.append(  value  ,  len  ,  offset)  ;[FE]  String  index  out  of  range:  -3  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {      out.append(value,  start,  pos  +  1);      start  =  pos;  }  pos++;  }    out.append(value,  start,  pos);  [BUGGY]  out.append(  value  ,  len  ,  offset)  ;  [BUGGY]  }              public  void  print(String  value,  boolean  checkForEscape)  throws  IOException  {  if  (value  ==  null)  {    value  =   " ";  }  if  (!checkForEscape)  {    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P7_Replace_Invocation]
[PATCH]  out.append  (  encapsulator  )  ;	[BUG]  [BUGGY]  [FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {      out.append(value,  start,  pos  +  1);      start  =  pos;  }  pos++;  }    out.append(value,  start,  pos);  [BUGGY]  [BUGGY]    }              public  void  print(String  value,  boolean  checkForEscape)  throws  IOException  {  if  (value  ==  null)  {    value  =   " ";  }      [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P14_Delete_Statement]
[PATCH]  out.append  (  encapsulator  )  ;	[BUG]  [BUGGY]  out.append(  value,  start,  end)  ;out.append(  encapsulator)  ;[FE]  expected:< "x,y[] ",z>  but  was:< "x,y[x,y] ",z>  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {      out.append(value,  start,  pos  +  1);      start  =  pos;  }  pos++;  }    out.append(value,  start,  pos);  [BUGGY]  out.append(  value,  start,  end)  ;out.append(  encapsulator)  ;  [BUGGY]  }              public  void  print(String  value,  boolean  checkForEscape)  throws  IOException  {  if  (value  ==  null)  {    value  =   " ";  }  if  (!checkForEscape)  {    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  out.append  (  encapsulator  )  ;	[BUG]  [BUGGY]  out.append(  value,  start,  pos)  ;out.append(  encapsulator)  ;[FE]  expected:< "x,y[] ",z>  but  was:< "x,y[x,y] ",z>  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {      out.append(value,  start,  pos  +  1);      start  =  pos;  }  pos++;  }    out.append(value,  start,  pos);  [BUGGY]  out.append(  value,  start,  pos)  ;out.append(  encapsulator)  ;  [BUGGY]  }              public  void  print(String  value,  boolean  checkForEscape)  throws  IOException  {  if  (value  ==  null)  {    value  =   " ";  }  if  (!checkForEscape)  {    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  out.append  (  encapsulator  )  ;	[BUG]  [BUGGY]  out.append(  c)  ;out.append(  encapsulator)  ;[CE]  cannot  find  symbol  c  [CONTEXT]  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {      out.append(value,  start,  pos  +  1);      start  =  pos;  }  pos++;  }    out.append(value,  start,  pos);  [BUGGY]  out.append(  c)  ;out.append(  encapsulator)  ;  [BUGGY]  }              public  void  print(String  value,  boolean  checkForEscape)  throws  IOException  {  if  (value  ==  null)  {    value  =   " ";  }  if  (!checkForEscape)  {    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  out.append  (  encapsulator  )  ;	[BUG]  [BUGGY]  out.append(  value)  ;out.append(  encapsulator)  ;[FE]  expected:< "x,y[] ",z>  but  was:< "x,y[x,y] ",z>  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {      out.append(value,  start,  pos  +  1);      start  =  pos;  }  pos++;  }    out.append(value,  start,  pos);  [BUGGY]  out.append(  value)  ;out.append(  encapsulator)  ;  [BUGGY]  }              public  void  print(String  value,  boolean  checkForEscape)  throws  IOException  {  if  (value  ==  null)  {    value  =   " ";  }  if  (!checkForEscape)  {    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  out.append  (  encapsulator  )  ;	[BUG]  [BUGGY]  out.append(  value,  start,  pos  +  1)  ;out.append(  encapsulator)  ;[FE]  String  index  out  of  range:  4  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {      out.append(value,  start,  pos  +  1);      start  =  pos;  }  pos++;  }    out.append(value,  start,  pos);  [BUGGY]  out.append(  value,  start,  pos  +  1)  ;out.append(  encapsulator)  ;  [BUGGY]  }              public  void  print(String  value,  boolean  checkForEscape)  throws  IOException  {  if  (value  ==  null)  {    value  =   " ";  }  if  (!checkForEscape)  {    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  out.append  (  encapsulator  )  ;	[BUG]  [BUGGY]  out.append(  '  ')  ;out.append(  encapsulator)  ;[FE]  expected:< "x,y[] ",z>  but  was:< "x,y[  ] ",z>  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {      out.append(value,  start,  pos  +  1);      start  =  pos;  }  pos++;  }    out.append(value,  start,  pos);  [BUGGY]  out.append(  '  ')  ;out.append(  encapsulator)  ;  [BUGGY]  }              public  void  print(String  value,  boolean  checkForEscape)  throws  IOException  {  if  (value  ==  null)  {    value  =   " ";  }  if  (!checkForEscape)  {    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  out.append  (  encapsulator  )  ;	[BUG]  [BUGGY]  out.append(  escape)  ;out.append(  encapsulator)  ;[CE]  cannot  find  symbol  escape  [CONTEXT]  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {      out.append(value,  start,  pos  +  1);      start  =  pos;  }  pos++;  }    out.append(value,  start,  pos);  [BUGGY]  out.append(  escape)  ;out.append(  encapsulator)  ;  [BUGGY]  }              public  void  print(String  value,  boolean  checkForEscape)  throws  IOException  {  if  (value  ==  null)  {    value  =   " ";  }  if  (!checkForEscape)  {    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  out.append  (  encapsulator  )  ;	[BUG]  [BUGGY]  if  (  c  ==  encapsulator)  {  out.append(  encapsulator)  ;  }[CE]  cannot  find  symbol  c  [CONTEXT]  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {      out.append(value,  start,  pos  +  1);      start  =  pos;  }  pos++;  }    out.append(value,  start,  pos);  [BUGGY]  if  (  c  ==  encapsulator)  {  out.append(  encapsulator)  ;  }  [BUGGY]  }              public  void  print(String  value,  boolean  checkForEscape)  throws  IOException  {  if  (value  ==  null)  {    value  =   " ";  }  if  (!checkForEscape)  {    [CLASS]  CSVPrinter  [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void    CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence  value  char  c  delim  encapsulator  CSVFormat  format  boolean  first  newLine  quote  int  end  len  offset  pos  start  Appendable  out    	[P12_Insert_Condition]
[PATCH]  if  (  value  ==  null  )  {	[BUG]  [BUGGY]  if  (  value  !=  null)  {[FE]  expected:<[a,b,c]>  but  was:<[ " ",,]>  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]  public  void  print(String  value,  boolean  checkForEscape)  throws  IOException  {  [BUGGY]  if  (  value  !=  null)  {  [BUGGY]    value  =   " ";  }  if  (!checkForEscape)  {    printSep();  out.append(value);  }  else  {  print(value,  0,  value.length());  }  }    [CLASS]  CSVPrinter  [METHOD]  print  [RETURN_TYPE]  void    String  value  boolean  checkForEscape  [VARIABLES]  CSVFormat  format  boolean  checkForEscape  first  newLine  quote  String  value  Appendable  out    	[P2_Replace_Operator]
[PATCH]  if  (  value  ==  null  )  {	[BUG]  [BUGGY]  if  (  value  ==  true)  {[CE]  incomparable  types:  String  and  boolean  [CONTEXT]  public  void  print(String  value,  boolean  checkForEscape)  throws  IOException  {  [BUGGY]  if  (  value  ==  true)  {  [BUGGY]    value  =   " ";  }  if  (!checkForEscape)  {    printSep();  out.append(value);  }  else  {  print(value,  0,  value.length());  }  }    [CLASS]  CSVPrinter  [METHOD]  print  [RETURN_TYPE]  void    String  value  boolean  checkForEscape  [VARIABLES]  CSVFormat  format  boolean  checkForEscape  first  newLine  quote  String  value  Appendable  out    	[P8_Replace_Mix]
[PATCH]  if  (  value  ==  null  )  {  value  =   " ";  }	[BUG]  [BUGGY]  value  =   " ";[CE]  illegal  start  of  expression  [CONTEXT]  public  void  print(String  value,  boolean  checkForEscape)  throws  IOException  {  [BUGGY]  value  =   " ";  [BUGGY]    value  =   " ";    if  (!checkForEscape)  {    printSep();  out.append(value);  }  else  {  print(value,  0,  value.length());  }    [CLASS]  CSVPrinter  [METHOD]  print  [RETURN_TYPE]  void    String  value  boolean  checkForEscape  [VARIABLES]  CSVFormat  format  boolean  checkForEscape  first  newLine  quote  String  value  Appendable  out    	[P15_Unwrap_Block]
[PATCH]  if  (  value  ==  null  )  {  value  =   " ";  }	[BUG]  [BUGGY]  [CE]  illegal  start  of  expression  [CONTEXT]  public  void  print(String  value,  boolean  checkForEscape)  throws  IOException  {  [BUGGY]  [BUGGY]        if  (!checkForEscape)  {    printSep();  out.append(value);  }  else  {  print(value,  0,  value.length());  }    [CLASS]  CSVPrinter  [METHOD]  print  [RETURN_TYPE]  void    String  value  boolean  checkForEscape  [VARIABLES]  CSVFormat  format  boolean  checkForEscape  first  newLine  quote  String  value  Appendable  out    	[P16_Remove_Block]
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  c  <=  '  ')  {      quote  =  true;  }[CE]  illegal  start  of  type  [CONTEXT]  public  void  print(String  value,  boolean  checkForEscape)  throws  IOException  {  [BUGGY]  if  (  c  <=  '  ')  {      quote  =  true;  }  [BUGGY]    value  =   " ";  }  if  (!checkForEscape)  {    printSep();  out.append(value);  }  else  {  print(value,  0,  value.length());  }  }    [CLASS]  CSVPrinter  [METHOD]  print  [RETURN_TYPE]  void    String  value  boolean  checkForEscape  [VARIABLES]  CSVFormat  format  boolean  checkForEscape  first  newLine  quote  String  value  Appendable  out    	[P13_Insert_Block]
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  c  ==  '\r')  {      c  =  'r';  }[CE]  illegal  start  of  type  [CONTEXT]  public  void  print(String  value,  boolean  checkForEscape)  throws  IOException  {  [BUGGY]  if  (  c  ==  '\r')  {      c  =  'r';  }  [BUGGY]    value  =   " ";  }  if  (!checkForEscape)  {    printSep();  out.append(value);  }  else  {  print(value,  0,  value.length());  }  }    [CLASS]  CSVPrinter  [METHOD]  print  [RETURN_TYPE]  void    String  value  boolean  checkForEscape  [VARIABLES]  CSVFormat  format  boolean  checkForEscape  first  newLine  quote  String  value  Appendable  out    	[P13_Insert_Block]
[PATCH]  value  =   " ";	[BUG]  [BUGGY]  value  =  value  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  void  print(String  value,  boolean  checkForEscape)  throws  IOException  {  if  (value  ==  null)  {    [BUGGY]  value  =  value  ;  [BUGGY]  }  if  (!checkForEscape)  {    printSep();  out.append(value);  }  else  {  print(value,  0,  value.length());  }  }    [CLASS]  CSVPrinter  [METHOD]  print  [RETURN_TYPE]  void    String  value  boolean  checkForEscape  [VARIABLES]  CSVFormat  format  boolean  checkForEscape  first  newLine  quote  String  value  Appendable  out    	[P8_Replace_Mix]
[PATCH]  if  (  !checkForEscape  )  {	[BUG]  [BUGGY]  if  (  !quote)  {[CE]  cannot  find  symbol  quote  [CONTEXT]  public  void  print(String  value,  boolean  checkForEscape)  throws  IOException  {  if  (value  ==  null)  {    value  =   " ";  }  [BUGGY]  if  (  !quote)  {  [BUGGY]    printSep();  out.append(value);  }  else  {  print(value,  0,  value.length());  }  }    [CLASS]  CSVPrinter  [METHOD]  print  [RETURN_TYPE]  void    String  value  boolean  checkForEscape  [VARIABLES]  CSVFormat  format  boolean  checkForEscape  first  newLine  quote  String  value  Appendable  out    	[P5_Replace_Variable]
[PATCH]  if  (  !checkForEscape  )  {	[BUG]  [BUGGY]  if  (  checkForEscape)  {[FE]  expected:<[ "x,y "],z>  but  was:<[x,y],z>  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]  public  void  print(String  value,  boolean  checkForEscape)  throws  IOException  {  if  (value  ==  null)  {    value  =   " ";  }  [BUGGY]  if  (  checkForEscape)  {  [BUGGY]    printSep();  out.append(value);  }  else  {  print(value,  0,  value.length());  }  }    [CLASS]  CSVPrinter  [METHOD]  print  [RETURN_TYPE]  void    String  value  boolean  checkForEscape  [VARIABLES]  CSVFormat  format  boolean  checkForEscape  first  newLine  quote  String  value  Appendable  out    	[P8_Replace_Mix]
[PATCH]  print  (  value,  0,  value.length  (  )  )  ;	[BUG]  [BUGGY]  print(  value,  -3,  value.length(  )  )  ;[FE]  String  index  out  of  range:  -3  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]  public  void  print(String  value,  boolean  checkForEscape)  throws  IOException  {  if  (value  ==  null)  {    value  =   " ";  }  if  (!checkForEscape)  {    printSep();  out.append(value);  }  else  {  [BUGGY]  print(  value,  -3,  value.length(  )  )  ;  [BUGGY]  }  }    [CLASS]  CSVPrinter  [METHOD]  print  [RETURN_TYPE]  void    String  value  boolean  checkForEscape  [VARIABLES]  CSVFormat  format  boolean  checkForEscape  first  newLine  quote  String  value  Appendable  out    	[P3_Replace_Literal]
[PATCH]  print  (  value,  0,  value.length  (  )  )  ;	[BUG]  [BUGGY]  print(  value,  0,  value.length()  +  8  )  ;[FE]  String  index  out  of  range:  1  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]  public  void  print(String  value,  boolean  checkForEscape)  throws  IOException  {  if  (value  ==  null)  {    value  =   " ";  }  if  (!checkForEscape)  {    printSep();  out.append(value);  }  else  {  [BUGGY]  print(  value,  0,  value.length()  +  8  )  ;  [BUGGY]  }  }    [CLASS]  CSVPrinter  [METHOD]  print  [RETURN_TYPE]  void    String  value  boolean  checkForEscape  [VARIABLES]  CSVFormat  format  boolean  checkForEscape  first  newLine  quote  String  value  Appendable  out    	[P3_Replace_Literal]
[PATCH]  print  (  value,  0,  value.length  (  )  )  ;	[BUG]  [BUGGY]  printAndEscape(  value,  0,  value.length(  )  )  ;[FE]  expected:<[ "x,y "],z>  but  was:<[x  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]  public  void  print(String  value,  boolean  checkForEscape)  throws  IOException  {  if  (value  ==  null)  {    value  =   " ";  }  if  (!checkForEscape)  {    printSep();  out.append(value);  }  else  {  [BUGGY]  printAndEscape(  value,  0,  value.length(  )  )  ;  [BUGGY]  }  }    [CLASS]  CSVPrinter  [METHOD]  print  [RETURN_TYPE]  void    String  value  boolean  checkForEscape  [VARIABLES]  CSVFormat  format  boolean  checkForEscape  first  newLine  quote  String  value  Appendable  out    	[P7_Replace_Invocation]
[PATCH]  print  (  value,  0,  value.length  (  )  )  ;	[BUG]  [BUGGY]  print(  value,  0,  value.charAt(  )  )  ;[CE]  method  charAt  in  class  String  cannot  be  applied  to  given  types;  [CONTEXT]  public  void  print(String  value,  boolean  checkForEscape)  throws  IOException  {  if  (value  ==  null)  {    value  =   " ";  }  if  (!checkForEscape)  {    printSep();  out.append(value);  }  else  {  [BUGGY]  print(  value,  0,  value.charAt(  )  )  ;  [BUGGY]  }  }    [CLASS]  CSVPrinter  [METHOD]  print  [RETURN_TYPE]  void    String  value  boolean  checkForEscape  [VARIABLES]  CSVFormat  format  boolean  checkForEscape  first  newLine  quote  String  value  Appendable  out    	[P7_Replace_Invocation]
[PATCH]  print  (  value,  0,  value.length  (  )  )  ;	[BUG]  [BUGGY]  [FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  void  print(String  value,  boolean  checkForEscape)  throws  IOException  {  if  (value  ==  null)  {    value  =   " ";  }  if  (!checkForEscape)  {    printSep();  out.append(value);  }  else  {  [BUGGY]  [BUGGY]    }    [CLASS]  CSVPrinter  [METHOD]  print  [RETURN_TYPE]  void    String  value  boolean  checkForEscape  [VARIABLES]  CSVFormat  format  boolean  checkForEscape  first  newLine  quote  String  value  Appendable  out    	[P14_Delete_Statement]
[PATCH]  print  (  value,  0,  value.length  (  )  )  ;	[BUG]  [BUGGY]  print(  value,  true)  ;print(  value,  0,  value.length(  )  )  ;[FE]  null  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]  public  void  print(String  value,  boolean  checkForEscape)  throws  IOException  {  if  (value  ==  null)  {    value  =   " ";  }  if  (!checkForEscape)  {    printSep();  out.append(value);  }  else  {  [BUGGY]  print(  value,  true)  ;print(  value,  0,  value.length(  )  )  ;  [BUGGY]  }  }    [CLASS]  CSVPrinter  [METHOD]  print  [RETURN_TYPE]  void    String  value  boolean  checkForEscape  [VARIABLES]  CSVFormat  format  boolean  checkForEscape  first  newLine  quote  String  value  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  print  (  value,  0,  value.length  (  )  )  ;	[BUG]  [BUGGY]  print(  value,  0,  value.length()  -  8  )  ;[FE]  String  index  out  of  range:  -7  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]  public  void  print(String  value,  boolean  checkForEscape)  throws  IOException  {  if  (value  ==  null)  {    value  =   " ";  }  if  (!checkForEscape)  {    printSep();  out.append(value);  }  else  {  [BUGGY]  print(  value,  0,  value.length()  -  8  )  ;  [BUGGY]  }  }    [CLASS]  CSVPrinter  [METHOD]  print  [RETURN_TYPE]  void    String  value  boolean  checkForEscape  [VARIABLES]  CSVFormat  format  boolean  checkForEscape  first  newLine  quote  String  value  Appendable  out    	[P3_Replace_Literal]
[PATCH]  printSep  (  )  ;	[BUG]  [BUGGY]  println(  )  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  void  print(String  value,  boolean  checkForEscape)  throws  IOException  {  if  (value  ==  null)  {    value  =   " ";  }  if  (!checkForEscape)  {    [BUGGY]  println(  )  ;  [BUGGY]  out.append(value);  }  else  {  print(value,  0,  value.length());  }  }    [CLASS]  CSVPrinter  [METHOD]  print  [RETURN_TYPE]  void    String  value  boolean  checkForEscape  [VARIABLES]  CSVFormat  format  boolean  checkForEscape  first  newLine  quote  String  value  Appendable  out    	[P7_Replace_Invocation]
[PATCH]  printSep  (  )  ;	[BUG]  [BUGGY]  [FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  void  print(String  value,  boolean  checkForEscape)  throws  IOException  {  if  (value  ==  null)  {    value  =   " ";  }  if  (!checkForEscape)  {    [BUGGY]  [BUGGY]    out.append(value);  }  else  {  print(value,  0,  value.length());  }    [CLASS]  CSVPrinter  [METHOD]  print  [RETURN_TYPE]  void    String  value  boolean  checkForEscape  [VARIABLES]  CSVFormat  format  boolean  checkForEscape  first  newLine  quote  String  value  Appendable  out    	[P14_Delete_Statement]
[PATCH]  printSep  (  )  ;	[BUG]  [BUGGY]  println(  )  ;printSep(  )  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  void  print(String  value,  boolean  checkForEscape)  throws  IOException  {  if  (value  ==  null)  {    value  =   " ";  }  if  (!checkForEscape)  {    [BUGGY]  println(  )  ;printSep(  )  ;  [BUGGY]  out.append(value);  }  else  {  print(value,  0,  value.length());  }  }    [CLASS]  CSVPrinter  [METHOD]  print  [RETURN_TYPE]  void    String  value  boolean  checkForEscape  [VARIABLES]  CSVFormat  format  boolean  checkForEscape  first  newLine  quote  String  value  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  printSep  (  )  ;	[BUG]  [BUGGY]  print(  value)  ;printSep(  )  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  void  print(String  value,  boolean  checkForEscape)  throws  IOException  {  if  (value  ==  null)  {    value  =   " ";  }  if  (!checkForEscape)  {    [BUGGY]  print(  value)  ;printSep(  )  ;  [BUGGY]  out.append(value);  }  else  {  print(value,  0,  value.length());  }  }    [CLASS]  CSVPrinter  [METHOD]  print  [RETURN_TYPE]  void    String  value  boolean  checkForEscape  [VARIABLES]  CSVFormat  format  boolean  checkForEscape  first  newLine  quote  String  value  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  out.append  (  value  )  ;	[BUG]  [BUGGY]  [FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  void  print(String  value,  boolean  checkForEscape)  throws  IOException  {  if  (value  ==  null)  {    value  =   " ";  }  if  (!checkForEscape)  {    printSep();  [BUGGY]  [BUGGY]    }  else  {  print(value,  0,  value.length());  }    [CLASS]  CSVPrinter  [METHOD]  print  [RETURN_TYPE]  void    String  value  boolean  checkForEscape  [VARIABLES]  CSVFormat  format  boolean  checkForEscape  first  newLine  quote  String  value  Appendable  out    	[P14_Delete_Statement]
[PATCH]  out.append  (  value  )  ;	[BUG]  [BUGGY]  out.append(  value,  start,  end)  ;out.append(  value)  ;[CE]  cannot  find  symbol  start  [CONTEXT]  public  void  print(String  value,  boolean  checkForEscape)  throws  IOException  {  if  (value  ==  null)  {    value  =   " ";  }  if  (!checkForEscape)  {    printSep();  [BUGGY]  out.append(  value,  start,  end)  ;out.append(  value)  ;  [BUGGY]  }  else  {  print(value,  0,  value.length());  }  }    [CLASS]  CSVPrinter  [METHOD]  print  [RETURN_TYPE]  void    String  value  boolean  checkForEscape  [VARIABLES]  CSVFormat  format  boolean  checkForEscape  first  newLine  quote  String  value  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  out.append  (  value  )  ;	[BUG]  [BUGGY]  out.append(  value,  start,  pos)  ;out.append(  value)  ;[CE]  cannot  find  symbol  start  [CONTEXT]  public  void  print(String  value,  boolean  checkForEscape)  throws  IOException  {  if  (value  ==  null)  {    value  =   " ";  }  if  (!checkForEscape)  {    printSep();  [BUGGY]  out.append(  value,  start,  pos)  ;out.append(  value)  ;  [BUGGY]  }  else  {  print(value,  0,  value.length());  }  }    [CLASS]  CSVPrinter  [METHOD]  print  [RETURN_TYPE]  void    String  value  boolean  checkForEscape  [VARIABLES]  CSVFormat  format  boolean  checkForEscape  first  newLine  quote  String  value  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  out.append  (  value  )  ;	[BUG]  [BUGGY]  out.append(  c)  ;out.append(  value)  ;[CE]  cannot  find  symbol  c  [CONTEXT]  public  void  print(String  value,  boolean  checkForEscape)  throws  IOException  {  if  (value  ==  null)  {    value  =   " ";  }  if  (!checkForEscape)  {    printSep();  [BUGGY]  out.append(  c)  ;out.append(  value)  ;  [BUGGY]  }  else  {  print(value,  0,  value.length());  }  }    [CLASS]  CSVPrinter  [METHOD]  print  [RETURN_TYPE]  void    String  value  boolean  checkForEscape  [VARIABLES]  CSVFormat  format  boolean  checkForEscape  first  newLine  quote  String  value  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  out.append  (  value  )  ;	[BUG]  [BUGGY]  print(  value)  ;out.append(  value)  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  void  print(String  value,  boolean  checkForEscape)  throws  IOException  {  if  (value  ==  null)  {    value  =   " ";  }  if  (!checkForEscape)  {    printSep();  [BUGGY]  print(  value)  ;out.append(  value)  ;  [BUGGY]  }  else  {  print(value,  0,  value.length());  }  }    [CLASS]  CSVPrinter  [METHOD]  print  [RETURN_TYPE]  void    String  value  boolean  checkForEscape  [VARIABLES]  CSVFormat  format  boolean  checkForEscape  first  newLine  quote  String  value  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  out.append  (  value  )  ;	[BUG]  [BUGGY]  out.append(  encapsulator)  ;out.append(  value)  ;[CE]  cannot  find  symbol  encapsulator  [CONTEXT]  public  void  print(String  value,  boolean  checkForEscape)  throws  IOException  {  if  (value  ==  null)  {    value  =   " ";  }  if  (!checkForEscape)  {    printSep();  [BUGGY]  out.append(  encapsulator)  ;out.append(  value)  ;  [BUGGY]  }  else  {  print(value,  0,  value.length());  }  }    [CLASS]  CSVPrinter  [METHOD]  print  [RETURN_TYPE]  void    String  value  boolean  checkForEscape  [VARIABLES]  CSVFormat  format  boolean  checkForEscape  first  newLine  quote  String  value  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  out.append  (  value  )  ;	[BUG]  [BUGGY]  out.append(  value,  start,  pos  +  1)  ;out.append(  value)  ;[CE]  cannot  find  symbol  start  [CONTEXT]  public  void  print(String  value,  boolean  checkForEscape)  throws  IOException  {  if  (value  ==  null)  {    value  =   " ";  }  if  (!checkForEscape)  {    printSep();  [BUGGY]  out.append(  value,  start,  pos  +  1)  ;out.append(  value)  ;  [BUGGY]  }  else  {  print(value,  0,  value.length());  }  }    [CLASS]  CSVPrinter  [METHOD]  print  [RETURN_TYPE]  void    String  value  boolean  checkForEscape  [VARIABLES]  CSVFormat  format  boolean  checkForEscape  first  newLine  quote  String  value  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  out.append  (  value  )  ;	[BUG]  [BUGGY]  out.append(  '  ')  ;out.append(  value)  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  void  print(String  value,  boolean  checkForEscape)  throws  IOException  {  if  (value  ==  null)  {    value  =   " ";  }  if  (!checkForEscape)  {    printSep();  [BUGGY]  out.append(  '  ')  ;out.append(  value)  ;  [BUGGY]  }  else  {  print(value,  0,  value.length());  }  }    [CLASS]  CSVPrinter  [METHOD]  print  [RETURN_TYPE]  void    String  value  boolean  checkForEscape  [VARIABLES]  CSVFormat  format  boolean  checkForEscape  first  newLine  quote  String  value  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  out.append  (  value  )  ;	[BUG]  [BUGGY]  out.append(  escape)  ;out.append(  value)  ;[CE]  cannot  find  symbol  escape  [CONTEXT]  public  void  print(String  value,  boolean  checkForEscape)  throws  IOException  {  if  (value  ==  null)  {    value  =   " ";  }  if  (!checkForEscape)  {    printSep();  [BUGGY]  out.append(  escape)  ;out.append(  value)  ;  [BUGGY]  }  else  {  print(value,  0,  value.length());  }  }    [CLASS]  CSVPrinter  [METHOD]  print  [RETURN_TYPE]  void    String  value  boolean  checkForEscape  [VARIABLES]  CSVFormat  format  boolean  checkForEscape  first  newLine  quote  String  value  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  print  (  value,  0,  value.length  (  )  )  ;	[BUG]  [BUGGY]  print(  value,  6,  value.length(  )  )  ;[FE]  String  index  out  of  range:  6  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]  public  void  print(String  value,  boolean  checkForEscape)  throws  IOException  {  if  (value  ==  null)  {    value  =   " ";  }  if  (!checkForEscape)  {    printSep();  out.append(value);  }  else  {  [BUGGY]  print(  value,  6,  value.length(  )  )  ;  [BUGGY]  }  }    [CLASS]  CSVPrinter  [METHOD]  print  [RETURN_TYPE]  void    String  value  boolean  checkForEscape  [VARIABLES]  CSVFormat  format  boolean  checkForEscape  first  newLine  quote  String  value  Appendable  out    	[P3_Replace_Literal]
[PATCH]  print  (  value,  0,  value.length  (  )  )  ;	[BUG]  [BUGGY]  print(  value,  0,  value.length()  +  9  )  ;[FE]  String  index  out  of  range:  1  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]  public  void  print(String  value,  boolean  checkForEscape)  throws  IOException  {  if  (value  ==  null)  {    value  =   " ";  }  if  (!checkForEscape)  {    printSep();  out.append(value);  }  else  {  [BUGGY]  print(  value,  0,  value.length()  +  9  )  ;  [BUGGY]  }  }    [CLASS]  CSVPrinter  [METHOD]  print  [RETURN_TYPE]  void    String  value  boolean  checkForEscape  [VARIABLES]  CSVFormat  format  boolean  checkForEscape  first  newLine  quote  String  value  Appendable  out    	[P3_Replace_Literal]
[PATCH]  print  (  value,  true  )  ;	[BUG]  [BUGGY]  print(  value,  false)  ;[FE]  expected:<[ "x,y "],z>  but  was:<[x,y],z>  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]  public  void  print(String  value)  throws  IOException  {  [BUGGY]  print(  value,  false)  ;  [BUGGY]  }    [CLASS]  CSVPrinter  [METHOD]  print  [RETURN_TYPE]  void    String  value  [VARIABLES]  CSVFormat  format  boolean  checkForEscape  first  newLine  quote  String  value  Appendable  out    	[P3_Replace_Literal]
[PATCH]  print  (  value,  true  )  ;	[BUG]  [BUGGY]  CSVPrinter(  value,  true)  ;[CE]  cannot  find  symbol  [CONTEXT]  public  void  print(String  value)  throws  IOException  {  [BUGGY]  CSVPrinter(  value,  true)  ;  [BUGGY]  }    [CLASS]  CSVPrinter  [METHOD]  print  [RETURN_TYPE]  void    String  value  [VARIABLES]  CSVFormat  format  boolean  checkForEscape  first  newLine  quote  String  value  Appendable  out    	[P7_Replace_Invocation]
[PATCH]  print  (  value,  true  )  ;	[BUG]  [BUGGY]  [FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  void  print(String  value)  throws  IOException  {  [BUGGY]  [BUGGY]      [CLASS]  CSVPrinter  [METHOD]  print  [RETURN_TYPE]  void    String  value  [VARIABLES]  CSVFormat  format  boolean  checkForEscape  first  newLine  quote  String  value  Appendable  out    	[P14_Delete_Statement]
[PATCH]  print  (  value,  true  )  ;	[BUG]  [BUGGY]  out.append(  value,  start,  end)  ;print(  value,  true)  ;[CE]  cannot  find  symbol  start  [CONTEXT]  public  void  print(String  value)  throws  IOException  {  [BUGGY]  out.append(  value,  start,  end)  ;print(  value,  true)  ;  [BUGGY]  }    [CLASS]  CSVPrinter  [METHOD]  print  [RETURN_TYPE]  void    String  value  [VARIABLES]  CSVFormat  format  boolean  checkForEscape  first  newLine  quote  String  value  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  print  (  value,  true  )  ;	[BUG]  [BUGGY]  print(  value,  0,  value.length(  )  )  ;print(  value,  true)  ;[FE]  expected:<a,[b],c>  but  was:<a,[a,b,b,c],c>  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]  public  void  print(String  value)  throws  IOException  {  [BUGGY]  print(  value,  0,  value.length(  )  )  ;print(  value,  true)  ;  [BUGGY]  }    [CLASS]  CSVPrinter  [METHOD]  print  [RETURN_TYPE]  void    String  value  [VARIABLES]  CSVFormat  format  boolean  checkForEscape  first  newLine  quote  String  value  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  print  (  value,  true  )  ;	[BUG]  [BUGGY]  out.append(  value,  start,  pos)  ;print(  value,  true)  ;[CE]  cannot  find  symbol  start  [CONTEXT]  public  void  print(String  value)  throws  IOException  {  [BUGGY]  out.append(  value,  start,  pos)  ;print(  value,  true)  ;  [BUGGY]  }    [CLASS]  CSVPrinter  [METHOD]  print  [RETURN_TYPE]  void    String  value  [VARIABLES]  CSVFormat  format  boolean  checkForEscape  first  newLine  quote  String  value  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  print  (  value,  true  )  ;	[BUG]  [BUGGY]  print(  value)  ;print(  value,  true)  ;[FE]  null  testFormat  assertEquals( "\ "x,y\ ",z ",  format.format( "x,y ",   "z "));  [CONTEXT]  public  void  print(String  value)  throws  IOException  {  [BUGGY]  print(  value)  ;print(  value,  true)  ;  [BUGGY]  }    [CLASS]  CSVPrinter  [METHOD]  print  [RETURN_TYPE]  void    String  value  [VARIABLES]  CSVFormat  format  boolean  checkForEscape  first  newLine  quote  String  value  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  print  (  value,  true  )  ;	[BUG]  [BUGGY]  printAndEscape(  value,  offset,  len)  ;print(  value,  true)  ;[CE]  cannot  find  symbol  offset  [CONTEXT]  public  void  print(String  value)  throws  IOException  {  [BUGGY]  printAndEscape(  value,  offset,  len)  ;print(  value,  true)  ;  [BUGGY]  }    [CLASS]  CSVPrinter  [METHOD]  print  [RETURN_TYPE]  void    String  value  [VARIABLES]  CSVFormat  format  boolean  checkForEscape  first  newLine  quote  String  value  Appendable  out    	[P11_Insert_Donor_Statement]
[PATCH]  private  static  final  String[]  EMPTY_STRING_ARRAY  =  new  String[0];	[BUG]  [BUGGY]  private  static  final  String[]  EMPTY_STRING_ARRAY  =  new  String[4];[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]        public  class  CSVRecord  implements  Serializable,  Iterable<String>  {  [BUGGY]  private  static  final  String[]  EMPTY_STRING_ARRAY  =  new  String[4];  [BUGGY]      private  final  String[]  values;        [CLASS]  CSVRecord    [VARIABLES]  	[P3_Replace_Literal]
[PATCH]  private  static  final  String[]  EMPTY_STRING_ARRAY  =  new  String[0];	[BUG]  [BUGGY]  private  static  final  String[]  EMPTY_STRING_ARRAY  =  new  String[1];[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]        public  class  CSVRecord  implements  Serializable,  Iterable<String>  {  [BUGGY]  private  static  final  String[]  EMPTY_STRING_ARRAY  =  new  String[1];  [BUGGY]      private  final  String[]  values;        [CLASS]  CSVRecord    [VARIABLES]  	[P8_Replace_Mix]
[PATCH]  this.values  =  values  !=  null  ?  values  :  EMPTY_STRING_ARRAY;	[BUG]  [BUGGY]  this.values  =  values  ==  null  ?  values  :  EMPTY_STRING_ARRAY;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  CSVRecord(String[]  values,  Map<String,  Integer>  mapping)  {  [BUGGY]  this.values  =  values  ==  null  ?  values  :  EMPTY_STRING_ARRAY;  [BUGGY]  this.mapping  =  mapping;  }    [CLASS]  CSVRecord  [METHOD]  <init>  [RETURN_TYPE]  Map)    String[]  values  Integer>  mapping  [VARIABLES]  Map  mapping  String[]  EMPTY_STRING_ARRAY  values  boolean    	[P2_Replace_Operator]
[PATCH]  this.values  =  values  !=  null  ?  values  :  EMPTY_STRING_ARRAY;	[BUG]  [BUGGY]  this.values  =  EMPTY_STRING_ARRAY  !=  null  ?  values  :  values;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  CSVRecord(String[]  values,  Map<String,  Integer>  mapping)  {  [BUGGY]  this.values  =  EMPTY_STRING_ARRAY  !=  null  ?  values  :  values;  [BUGGY]  this.mapping  =  mapping;  }    [CLASS]  CSVRecord  [METHOD]  <init>  [RETURN_TYPE]  Map)    String[]  values  Integer>  mapping  [VARIABLES]  Map  mapping  String[]  EMPTY_STRING_ARRAY  values  boolean    	[P5_Replace_Variable]
[PATCH]  this.values  =  values  !=  null  ?  values  :  EMPTY_STRING_ARRAY;	[BUG]  [BUGGY]  this.values  =  EMPTY_STRING_ARRAY;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  CSVRecord(String[]  values,  Map<String,  Integer>  mapping)  {  [BUGGY]  this.values  =  EMPTY_STRING_ARRAY;  [BUGGY]  this.mapping  =  mapping;  }    [CLASS]  CSVRecord  [METHOD]  <init>  [RETURN_TYPE]  Map)    String[]  values  Integer>  mapping  [VARIABLES]  Map  mapping  String[]  EMPTY_STRING_ARRAY  values  boolean    	[P6_Replace_Expression]
[PATCH]  this.values  =  values  !=  null  ?  values  :  EMPTY_STRING_ARRAY;	[BUG]  [BUGGY]  this.values  =  values  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  CSVRecord(String[]  values,  Map<String,  Integer>  mapping)  {  [BUGGY]  this.values  =  values  ;  [BUGGY]  this.mapping  =  mapping;  }    [CLASS]  CSVRecord  [METHOD]  <init>  [RETURN_TYPE]  Map)    String[]  values  Integer>  mapping  [VARIABLES]  Map  mapping  String[]  EMPTY_STRING_ARRAY  values  boolean    	[P6_Replace_Expression]
[PATCH]  this.values  =  values  !=  null  ?  values  :  EMPTY_STRING_ARRAY;	[BUG]  [BUGGY]  this.values  =  values  !=  false  ?  values  :  EMPTY_STRING_ARRAY;[CE]  incomparable  types:  String[]  and  boolean  [CONTEXT]  CSVRecord(String[]  values,  Map<String,  Integer>  mapping)  {  [BUGGY]  this.values  =  values  !=  false  ?  values  :  EMPTY_STRING_ARRAY;  [BUGGY]  this.mapping  =  mapping;  }    [CLASS]  CSVRecord  [METHOD]  <init>  [RETURN_TYPE]  Map)    String[]  values  Integer>  mapping  [VARIABLES]  Map  mapping  String[]  EMPTY_STRING_ARRAY  values  boolean    	[P8_Replace_Mix]
[PATCH]  this.mapping  =  mapping;	[BUG]  [BUGGY]  this.mapping  =  null;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  CSVRecord(String[]  values,  Map<String,  Integer>  mapping)  {  this.values  =  values  !=  null  ?  values  :  EMPTY_STRING_ARRAY;  [BUGGY]  this.mapping  =  null;  [BUGGY]  }    [CLASS]  CSVRecord  [METHOD]  <init>  [RETURN_TYPE]  Map)    String[]  values  Integer>  mapping  [VARIABLES]  Map  mapping  String[]  EMPTY_STRING_ARRAY  values  boolean    	[P8_Replace_Mix]
[PATCH]  return  values[i];	[BUG]  [BUGGY]  return  EMPTY_STRING_ARRAY[i];[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  String  get(int  i)  {  [BUGGY]  return  EMPTY_STRING_ARRAY[i];  [BUGGY]  }    [CLASS]  CSVRecord  [METHOD]  get  [RETURN_TYPE]  String    int  i  [VARIABLES]  String[]  EMPTY_STRING_ARRAY  values  boolean  Map  mapping  int  i    	[P5_Replace_Variable]
[PATCH]  if  (  mapping  ==  null  )  {	[BUG]  [BUGGY]  if  (  mapping  !=  null)  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  String  get(String  name)  {  [BUGGY]  if  (  mapping  !=  null)  {  [BUGGY]  throw  new  IllegalStateException( "No  header  was  specified,  the  record  values  can't  be  accessed  by  name ");  }  Integer  index  =  mapping.get(name);  return  index  !=  null  ?  values[index.intValue()]  :  null;  }    [CLASS]  CSVRecord  [METHOD]  get  [RETURN_TYPE]  String    String  name  [VARIABLES]  Integer  index  String[]  EMPTY_STRING_ARRAY  values  String  name  boolean  Map  mapping    	[P2_Replace_Operator]
[PATCH]  if  (  mapping  ==  null  )  {	[BUG]  [BUGGY]  if  (  null  ==  null)  {[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  String  get(String  name)  {  [BUGGY]  if  (  null  ==  null)  {  [BUGGY]  throw  new  IllegalStateException( "No  header  was  specified,  the  record  values  can't  be  accessed  by  name ");  }  Integer  index  =  mapping.get(name);  return  index  !=  null  ?  values[index.intValue()]  :  null;  }    [CLASS]  CSVRecord  [METHOD]  get  [RETURN_TYPE]  String    String  name  [VARIABLES]  Integer  index  String[]  EMPTY_STRING_ARRAY  values  String  name  boolean  Map  mapping    	[P5_Replace_Variable]
[PATCH]  if  (  mapping  ==  null  )  {	[BUG]  [BUGGY]  if  (  mapping  ==  true)  {[CE]  incomparable  types:  Map<String,Integer>  and  boolean  [CONTEXT]  public  String  get(String  name)  {  [BUGGY]  if  (  mapping  ==  true)  {  [BUGGY]  throw  new  IllegalStateException( "No  header  was  specified,  the  record  values  can't  be  accessed  by  name ");  }  Integer  index  =  mapping.get(name);  return  index  !=  null  ?  values[index.intValue()]  :  null;  }    [CLASS]  CSVRecord  [METHOD]  get  [RETURN_TYPE]  String    String  name  [VARIABLES]  Integer  index  String[]  EMPTY_STRING_ARRAY  values  String  name  boolean  Map  mapping    	[P8_Replace_Mix]
[PATCH]  if  (  mapping  ==  null  )  {  throw  new  IllegalStateException  ( "   ")  ;  }	[BUG]  [BUGGY]  throw  new  java.lang.IllegalStateException( "No  header  was  specified,  the  record  values  can't  be  accessed  by  name ");[CE]  illegal  start  of  expression  [CONTEXT]  public  String  get(String  name)  {  [BUGGY]  throw  new  java.lang.IllegalStateException( "No  header  was  specified,  the  record  values  can't  be  accessed  by  name ");  [BUGGY]    throw  new  java.lang.IllegalStateException( "No  header  was  specified,  the  record  values  can't  be  accessed  by  name ");    Integer  index  =  mapping.get(name);  return  index  !=  null  ?  values[index.intValue()]  :  null;    [CLASS]  CSVRecord  [METHOD]  get  [RETURN_TYPE]  String    String  name  [VARIABLES]  Integer  index  String[]  EMPTY_STRING_ARRAY  values  String  name  boolean  Map  mapping    	[P15_Unwrap_Block]
[PATCH]  if  (  mapping  ==  null  )  {  throw  new  IllegalStateException  ( "   ")  ;  }	[BUG]  [BUGGY]  [CE]  illegal  start  of  expression  [CONTEXT]  public  String  get(String  name)  {  [BUGGY]  [BUGGY]      Integer  index  =  mapping.get(name);  return  index  !=  null  ?  values[index.intValue()]  :  null;    [CLASS]  CSVRecord  [METHOD]  get  [RETURN_TYPE]  String    String  name  [VARIABLES]  Integer  index  String[]  EMPTY_STRING_ARRAY  values  String  name  boolean  Map  mapping    	[P16_Remove_Block]
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  (  mapping)  ==  null)  {      throw  new  IllegalStateException(   "No  header  was  specified,  the  record  values  can't  be  accessed  by  name ")  ;  }[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  String  get(String  name)  {  if  (mapping  ==  null)  {  [BUGGY]  if  (  (  mapping)  ==  null)  {      throw  new  IllegalStateException(   "No  header  was  specified,  the  record  values  can't  be  accessed  by  name ")  ;  }  [BUGGY]  }  Integer  index  =  mapping.get(name);  return  index  !=  null  ?  values[index.intValue()]  :  null;  }    [CLASS]  CSVRecord  [METHOD]  get  [RETURN_TYPE]  String    String  name  [VARIABLES]  Integer  index  String[]  EMPTY_STRING_ARRAY  values  String  name  boolean  Map  mapping    	[P13_Insert_Block]
[PATCH]  Integer  index  =  mapping.get  (  name  )  ;	[BUG]  [BUGGY]  Integer  index  =  name.get(  mapping)  ;[CE]  cannot  find  symbol  [CONTEXT]  public  String  get(String  name)  {  if  (mapping  ==  null)  {  throw  new  IllegalStateException( "No  header  was  specified,  the  record  values  can't  be  accessed  by  name ");  }  [BUGGY]  Integer  index  =  name.get(  mapping)  ;  [BUGGY]    return  index  !=  null  ?  values[index.intValue()]  :  null;  }    [CLASS]  CSVRecord  [METHOD]  get  [RETURN_TYPE]  String    String  name  [VARIABLES]  Integer  index  String[]  EMPTY_STRING_ARRAY  values  String  name  boolean  Map  mapping    	[P5_Replace_Variable]
[PATCH]  Integer  index  =  mapping.get  (  name  )  ;	[BUG]  [BUGGY]  [FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  String  get(String  name)  {  if  (mapping  ==  null)  {  throw  new  IllegalStateException( "No  header  was  specified,  the  record  values  can't  be  accessed  by  name ");  }  [BUGGY]  [BUGGY]    return  index  !=  null  ?  values[index.intValue()]  :  null;    [CLASS]  CSVRecord  [METHOD]  get  [RETURN_TYPE]  String    String  name  [VARIABLES]  Integer  index  String[]  EMPTY_STRING_ARRAY  values  String  name  boolean  Map  mapping    	[P14_Delete_Statement]
[PATCH]  return  index  !=  null  ?  values[index.intValue  (  )  ]  :  null;	[BUG]  [BUGGY]  return  index  ==  null  ?  values[index.intValue(  )  ]  :  null;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  String  get(String  name)  {  if  (mapping  ==  null)  {  throw  new  IllegalStateException( "No  header  was  specified,  the  record  values  can't  be  accessed  by  name ");  }  Integer  index  =  mapping.get(name);  [BUGGY]  return  index  ==  null  ?  values[index.intValue(  )  ]  :  null;  [BUGGY]  }    [CLASS]  CSVRecord  [METHOD]  get  [RETURN_TYPE]  String    String  name  [VARIABLES]  Integer  index  String[]  EMPTY_STRING_ARRAY  values  String  name  boolean  Map  mapping    	[P2_Replace_Operator]
[PATCH]  return  index  !=  null  ?  values[index.intValue  (  )  ]  :  null;	[BUG]  [BUGGY]  return  index  !=  null  ?  EMPTY_STRING_ARRAY[index.intValue(  )  ]  :  null;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  String  get(String  name)  {  if  (mapping  ==  null)  {  throw  new  IllegalStateException( "No  header  was  specified,  the  record  values  can't  be  accessed  by  name ");  }  Integer  index  =  mapping.get(name);  [BUGGY]  return  index  !=  null  ?  EMPTY_STRING_ARRAY[index.intValue(  )  ]  :  null;  [BUGGY]  }    [CLASS]  CSVRecord  [METHOD]  get  [RETURN_TYPE]  String    String  name  [VARIABLES]  Integer  index  String[]  EMPTY_STRING_ARRAY  values  String  name  boolean  Map  mapping    	[P5_Replace_Variable]
[PATCH]  return  index  !=  null  ?  values[index.intValue  (  )  ]  :  null;	[BUG]  [BUGGY]  return  values  !=  null  ?  index[index.intValue(  )  ]  :  null;[CE]  array  required,  but  Integer  found  [CONTEXT]  public  String  get(String  name)  {  if  (mapping  ==  null)  {  throw  new  IllegalStateException( "No  header  was  specified,  the  record  values  can't  be  accessed  by  name ");  }  Integer  index  =  mapping.get(name);  [BUGGY]  return  values  !=  null  ?  index[index.intValue(  )  ]  :  null;  [BUGGY]  }    [CLASS]  CSVRecord  [METHOD]  get  [RETURN_TYPE]  String    String  name  [VARIABLES]  Integer  index  String[]  EMPTY_STRING_ARRAY  values  String  name  boolean  Map  mapping    	[P5_Replace_Variable]
[PATCH]  return  index  !=  null  ?  values[index.intValue  (  )  ]  :  null;	[BUG]  [BUGGY]  return  index  !  =  null;[CE]  ';'  expected  [CONTEXT]  public  String  get(String  name)  {  if  (mapping  ==  null)  {  throw  new  IllegalStateException( "No  header  was  specified,  the  record  values  can't  be  accessed  by  name ");  }  Integer  index  =  mapping.get(name);  [BUGGY]  return  index  !  =  null;  [BUGGY]  }    [CLASS]  CSVRecord  [METHOD]  get  [RETURN_TYPE]  String    String  name  [VARIABLES]  Integer  index  String[]  EMPTY_STRING_ARRAY  values  String  name  boolean  Map  mapping    	[P6_Replace_Expression]
[PATCH]  return  index  !=  null  ?  values[index.intValue  (  )  ]  :  null;	[BUG]  [BUGGY]  return  index  !  =  values[index.intValue(  )  ]  ;[CE]  ';'  expected  [CONTEXT]  public  String  get(String  name)  {  if  (mapping  ==  null)  {  throw  new  IllegalStateException( "No  header  was  specified,  the  record  values  can't  be  accessed  by  name ");  }  Integer  index  =  mapping.get(name);  [BUGGY]  return  index  !  =  values[index.intValue(  )  ]  ;  [BUGGY]  }    [CLASS]  CSVRecord  [METHOD]  get  [RETURN_TYPE]  String    String  name  [VARIABLES]  Integer  index  String[]  EMPTY_STRING_ARRAY  values  String  name  boolean  Map  mapping    	[P6_Replace_Expression]
[PATCH]  return  index  !=  null  ?  values[index.intValue  (  )  ]  :  null;	[BUG]  [BUGGY]  return  index  =  values[index.intValue(  )  ]  ;[CE]  incompatible  types  [CONTEXT]  public  String  get(String  name)  {  if  (mapping  ==  null)  {  throw  new  IllegalStateException( "No  header  was  specified,  the  record  values  can't  be  accessed  by  name ");  }  Integer  index  =  mapping.get(name);  [BUGGY]  return  index  =  values[index.intValue(  )  ]  ;  [BUGGY]  }    [CLASS]  CSVRecord  [METHOD]  get  [RETURN_TYPE]  String    String  name  [VARIABLES]  Integer  index  String[]  EMPTY_STRING_ARRAY  values  String  name  boolean  Map  mapping    	[P8_Replace_Mix]
[PATCH]  return  index  !=  null  ?  values[index.intValue  (  )  ]  :  null;	[BUG]  [BUGGY]  [FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  String  get(String  name)  {  if  (mapping  ==  null)  {  throw  new  IllegalStateException( "No  header  was  specified,  the  record  values  can't  be  accessed  by  name ");  }  Integer  index  =  mapping.get(name);  [BUGGY]  [BUGGY]      [CLASS]  CSVRecord  [METHOD]  get  [RETURN_TYPE]  String    String  name  [VARIABLES]  Integer  index  String[]  EMPTY_STRING_ARRAY  values  String  name  boolean  Map  mapping    	[P14_Delete_Statement]
[PATCH]  return  Arrays.asList  (  values  )  .iterator  (  )  ;	[BUG]  [BUGGY]  return  Arrays.asList(  EMPTY_STRING_ARRAY).iterator(  )  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  Iterator<String>  iterator()  {  [BUGGY]  return  Arrays.asList(  EMPTY_STRING_ARRAY).iterator(  )  ;  [BUGGY]  }    [CLASS]  CSVRecord  [METHOD]  iterator  [RETURN_TYPE]  Iterator    [VARIABLES]  Map  mapping  String[]  EMPTY_STRING_ARRAY  values  boolean    	[P5_Replace_Variable]
[PATCH]  return  Arrays.asList  (  values  )  .iterator  (  )  ;	[BUG]  [BUGGY]  return  Arrays.asList(  values)  .iterator(  )  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  Iterator<String>  iterator()  {  [BUGGY]  return  Arrays.asList(  values)  .iterator(  )  ;  [BUGGY]  }    [CLASS]  CSVRecord  [METHOD]  iterator  [RETURN_TYPE]  Iterator    [VARIABLES]  Map  mapping  String[]  EMPTY_STRING_ARRAY  values  boolean    	[P7_Replace_Invocation]
[PATCH]  return  Arrays.asList  (  values  )  .iterator  (  )  ;	[BUG]  [BUGGY]  [FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  Iterator<String>  iterator()  {  [BUGGY]  [BUGGY]      [CLASS]  CSVRecord  [METHOD]  iterator  [RETURN_TYPE]  Iterator    [VARIABLES]  Map  mapping  String[]  EMPTY_STRING_ARRAY  values  boolean    	[P14_Delete_Statement]
[PATCH]  return  values;	[BUG]  [BUGGY]  return  EMPTY_STRING_ARRAY;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  String[]  values()  {  [BUGGY]  return  EMPTY_STRING_ARRAY;  [BUGGY]  }    [CLASS]  CSVRecord  [METHOD]  values  [RETURN_TYPE]  String[]    [VARIABLES]  Map  mapping  String[]  EMPTY_STRING_ARRAY  values  boolean    	[P5_Replace_Variable]
[PATCH]  return  values.length;	[BUG]  [BUGGY]  return  EMPTY_STRING_ARRAY.length;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  int  size()  {  [BUGGY]  return  EMPTY_STRING_ARRAY.length;  [BUGGY]  }    [CLASS]  CSVRecord  [METHOD]  size  [RETURN_TYPE]  int    [VARIABLES]  Map  mapping  String[]  EMPTY_STRING_ARRAY  values  boolean    	[P5_Replace_Variable]
[PATCH]  return  values.length;	[BUG]  [BUGGY]  return  values;[CE]  incompatible  types  [CONTEXT]  public  int  size()  {  [BUGGY]  return  values;  [BUGGY]  }    [CLASS]  CSVRecord  [METHOD]  size  [RETURN_TYPE]  int    [VARIABLES]  Map  mapping  String[]  EMPTY_STRING_ARRAY  values  boolean    	[P5_Replace_Variable]
[PATCH]  return  values.length;	[BUG]  [BUGGY]  return  values.length.length;[CE]  int  cannot  be  dereferenced  [CONTEXT]  public  int  size()  {  [BUGGY]  return  values.length.length;  [BUGGY]  }    [CLASS]  CSVRecord  [METHOD]  size  [RETURN_TYPE]  int    [VARIABLES]  Map  mapping  String[]  EMPTY_STRING_ARRAY  values  boolean    	[P5_Replace_Variable]
[PATCH]  return  Arrays.toString  (  values  )  ;	[BUG]  [BUGGY]  return  Arrays.toString(  EMPTY_STRING_ARRAY)  ;[FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  String  toString()  {  [BUGGY]  return  Arrays.toString(  EMPTY_STRING_ARRAY)  ;  [BUGGY]  }    [CLASS]  CSVRecord  [METHOD]  toString  [RETURN_TYPE]  String    [VARIABLES]  Map  mapping  String[]  EMPTY_STRING_ARRAY  values  boolean    	[P5_Replace_Variable]
[PATCH]  return  Arrays.toString  (  values  )  ;	[BUG]  [BUGGY]  [FE]  null  testNextToken2  assertTokenEquals(EOF,   " ",  parser.nextToken(new  Token()));  [CONTEXT]  public  String  toString()  {  [BUGGY]  [BUGGY]      [CLASS]  CSVRecord  [METHOD]  toString  [RETURN_TYPE]  String    [VARIABLES]  Map  mapping  String[]  EMPTY_STRING_ARRAY  values  boolean    	[P14_Delete_Statement]
