[REPLACE]  super  (  format,  in  )  ;	[BUGGY]  int  c  =  in  .  read  (  )  ;  [CE]  constructor  Lexer  in  class  Lexer  cannot  be  applied  to  given  types  ;  [CONTEXT]  public  CSVLexer  (  CSVFormat  format  ,  ExtendedBufferedReader  in  )  {  [ATTENTION]  int  c  =  in  .  read  (  )    ;  }    [METHOD]  <init>  [TYPE]  ExtendedBufferedReader)  [PARAMETER]  CSVFormat  format  ExtendedBufferedReader  in  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  ExtendedBufferedReader  in  [TYPE]  CSVFormat  format  
[REPLACE]  int  lastChar  =  in  .  readAgain  (  )  ;	[BUGGY]  int  lastChar  =  in  .  readLine  (  )    ;  [CE]  incompatible  types  [CONTEXT]  Token  nextToken  (  Token  tkn  )  throws  IOException  {    [ATTENTION]  int  lastChar  =  in  .  readLine  (  )  ;              int  c  =  in  .  read  (  )  ;  boolean  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;      if  (  emptyLinesIgnored  )  {  while  (  eol  &&  (  lastChar  =  =  '\n'  ||  lastChar  =  =  '\r'  ||  lastChar  =  =  ExtendedBufferedReader  .  UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {    lastChar  =  c  ;  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;    if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }  }  }    if  (  isEndOfFile  (  lastChar  )  ||  (  !isDelimiter  (  lastChar  )  &&  isEndOfFile  (  c  )  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }    while  (  tkn  .  type  =  =  INVALID  )  {    if  (  surroundingSpacesIgnored  )  {  while  (  isWhitespace  (  c  )  &&  !eol  )  {  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  }  }    if  (  isCommentStart  (  c  )  )  {    in  .  readLine  (  )  ;  tkn  =  nextToken  (  tkn  .  reset  (  )  )  ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  }  else  if  (  eol  )  {      tkn  .  type  =  EORECORD  ;  }  else  if  (  isEncapsulator  (  c  )  )  {    encapsulatedTokenLexer  (  tkn  ,  c  )  ;  }  else  if  (  isEndOfFile  (  c  )  )  {      tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  there  is  data  at  EOF  }  else  {      simpleTokenLexer  (  tkn  ,  c  )  ;  }  }  return  tkn  ;  }    [METHOD]  nextToken  [TYPE]  Token  [PARAMETER]  Token  tkn  [CLASS]  CSVLexer    [TYPE]  boolean  eol  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  lastChar  
[REPLACE]  int  c  =  in  .  read  (  )  ;	[BUGGY]  int  c  =  in  .  readLine  (  )  ;  [CE]  incompatible  types  [CONTEXT]  Token  nextToken  (  Token  tkn  )  throws  IOException  {    int  lastChar  =  in  .  readAgain  (  )  ;              [ATTENTION]  int  c  =  in  .  readLine  (  )    ;  boolean  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;      if  (  emptyLinesIgnored  )  {  while  (  eol  &&  (  lastChar  =  =  '\n'  ||  lastChar  =  =  '\r'  ||  lastChar  =  =  ExtendedBufferedReader  .  UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {    lastChar  =  c  ;  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;    if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }  }  }    if  (  isEndOfFile  (  lastChar  )  ||  (  !isDelimiter  (  lastChar  )  &&  isEndOfFile  (  c  )  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }    while  (  tkn  .  type  =  =  INVALID  )  {    if  (  surroundingSpacesIgnored  )  {  while  (  isWhitespace  (  c  )  &&  !eol  )  {  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  }  }    if  (  isCommentStart  (  c  )  )  {    in  .  readLine  (  )  ;  tkn  =  nextToken  (  tkn  .  reset  (  )  )  ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  }  else  if  (  eol  )  {      tkn  .  type  =  EORECORD  ;  }  else  if  (  isEncapsulator  (  c  )  )  {    encapsulatedTokenLexer  (  tkn  ,  c  )  ;  }  else  if  (  isEndOfFile  (  c  )  )  {      tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  there  is  data  at  EOF  }  else  {      simpleTokenLexer  (  tkn  ,  c  )  ;  }  }  return  tkn  ;  }    [METHOD]  nextToken  [TYPE]  Token  [PARAMETER]  Token  tkn  [CLASS]  CSVLexer    [TYPE]  boolean  eol  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  lastChar  
[ADD]  int  c  =  in  .  read  (  )  ;	[BUGGY]  [CE]  cannot  find  symbol  c  [CONTEXT]  Token  nextToken  (  Token  tkn  )  throws  IOException  {    int  lastChar  =  in  .  readAgain  (  )  ;              [ATTENTION]  boolean  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;      if  (  emptyLinesIgnored  )  {  while  (  eol  &&  (  lastChar  =  =  '\n'  ||  lastChar  =  =  '\r'  ||  lastChar  =  =  ExtendedBufferedReader  .  UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {    lastChar  =  c  ;  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;    if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }  }  }    if  (  isEndOfFile  (  lastChar  )  ||  (  !isDelimiter  (  lastChar  )  &&  isEndOfFile  (  c  )  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }    while  (  tkn  .  type  =  =  INVALID  )  {    if  (  surroundingSpacesIgnored  )  {  while  (  isWhitespace  (  c  )  &&  !eol  )  {  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  }  }    if  (  isCommentStart  (  c  )  )  {    in  .  readLine  (  )  ;  tkn  =  nextToken  (  tkn  .  reset  (  )  )  ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  }  else  if  (  eol  )  {      tkn  .  type  =  EORECORD  ;  }  else  if  (  isEncapsulator  (  c  )  )  {    encapsulatedTokenLexer  (  tkn  ,  c  )  ;  }  else  if  (  isEndOfFile  (  c  )  )  {      tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  there  is  data  at  EOF  }  else  {      simpleTokenLexer  (  tkn  ,  c  )  ;  }  }  return  tkn  ;  }    [METHOD]  nextToken  [TYPE]  Token  [PARAMETER]  Token  tkn  [CLASS]  CSVLexer    [TYPE]  boolean  eol  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  lastChar  
[REPLACE]  boolean  eol  =  isEndOfLine  (  c  )  ;	[BUGGY]  boolean  eol  =  isEndOfLine  (  lastChar  )  ;  [FE]  AssertionFailedError    Token  content  expected:<[a]>  but  was:<[]>  assertTokenEquals(TOKEN  ,   "1 "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "2 "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "3 "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   " "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "b  x "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "c "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "d "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "e "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   " "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  Token  nextToken  (  Token  tkn  )  throws  IOException  {    int  lastChar  =  in  .  readAgain  (  )  ;              int  c  =  in  .  read  (  )  ;  [ATTENTION]  boolean  eol  =  isEndOfLine  (  lastChar  )    ;  c  =  in  .  readAgain  (  )  ;      if  (  emptyLinesIgnored  )  {  while  (  eol  &&  (  lastChar  =  =  '\n'  ||  lastChar  =  =  '\r'  ||  lastChar  =  =  ExtendedBufferedReader  .  UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {    lastChar  =  c  ;  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;    if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }  }  }    if  (  isEndOfFile  (  lastChar  )  ||  (  !isDelimiter  (  lastChar  )  &&  isEndOfFile  (  c  )  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }    while  (  tkn  .  type  =  =  INVALID  )  {    if  (  surroundingSpacesIgnored  )  {  while  (  isWhitespace  (  c  )  &&  !eol  )  {  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  }  }    if  (  isCommentStart  (  c  )  )  {    in  .  readLine  (  )  ;  tkn  =  nextToken  (  tkn  .  reset  (  )  )  ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  }  else  if  (  eol  )  {      tkn  .  type  =  EORECORD  ;  }  else  if  (  isEncapsulator  (  c  )  )  {    encapsulatedTokenLexer  (  tkn  ,  c  )  ;  }  else  if  (  isEndOfFile  (  c  )  )  {      tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  there  is  data  at  EOF  }  else  {      simpleTokenLexer  (  tkn  ,  c  )  ;  }  }  return  tkn  ;  }    [METHOD]  nextToken  [TYPE]  Token  [PARAMETER]  Token  tkn  [CLASS]  CSVLexer    [TYPE]  boolean  eol  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  lastChar  
[REPLACE]  c  =  in  .  readAgain  (  )  ;	[BUGGY]  c  =  in  .  read  (  )  ;    ;  [FE]  AssertionFailedError    Token  content  expected:<[a]bc>  but  was:<[]bc>  assertTokenEquals(TOKEN  ,   "abc "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "def "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "hijk "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "lmnop "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "qrst "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "uv "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "wxy "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "z "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   " "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   " "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  Token  nextToken  (  Token  tkn  )  throws  IOException  {    int  lastChar  =  in  .  readAgain  (  )  ;              int  c  =  in  .  read  (  )  ;  boolean  eol  =  isEndOfLine  (  c  )  ;  [ATTENTION]  c  =  in  .  read  (  )    ;    ;      if  (  emptyLinesIgnored  )  {  while  (  eol  &&  (  lastChar  =  =  '\n'  ||  lastChar  =  =  '\r'  ||  lastChar  =  =  ExtendedBufferedReader  .  UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {    lastChar  =  c  ;  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;    if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }  }  }    if  (  isEndOfFile  (  lastChar  )  ||  (  !isDelimiter  (  lastChar  )  &&  isEndOfFile  (  c  )  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }    while  (  tkn  .  type  =  =  INVALID  )  {    if  (  surroundingSpacesIgnored  )  {  while  (  isWhitespace  (  c  )  &&  !eol  )  {  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  }  }    if  (  isCommentStart  (  c  )  )  {    in  .  readLine  (  )  ;  tkn  =  nextToken  (  tkn  .  reset  (  )  )  ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  }  else  if  (  eol  )  {      tkn  .  type  =  EORECORD  ;  }  else  if  (  isEncapsulator  (  c  )  )  {    encapsulatedTokenLexer  (  tkn  ,  c  )  ;  }  else  if  (  isEndOfFile  (  c  )  )  {      tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  there  is  data  at  EOF  }  else  {      simpleTokenLexer  (  tkn  ,  c  )  ;  }  }  return  tkn  ;  }    [METHOD]  nextToken  [TYPE]  Token  [PARAMETER]  Token  tkn  [CLASS]  CSVLexer    [TYPE]  boolean  eol  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  lastChar  
[REPLACE]  if  (  isEndOfFile  (  c  )  )  {	[BUGGY]  if  (  isEndOfFile  (  lastChar  )  )  {[NO-ERROR]  [CONTEXT]  while  (  eol  &&  (  lastChar  =  =  '\n'  ||  lastChar  =  =  '\r'  ||  lastChar  =  =  ExtendedBufferedReader  .  UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {    lastChar  =  c  ;  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;    [ATTENTION]  if  (  isEndOfFile  (  lastChar  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }  }    [METHOD]  nextToken  [TYPE]  Token  [PARAMETER]  Token  tkn  [CLASS]  CSVLexer    [TYPE]  boolean  eol  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  lastChar  
[REPLACE]  tkn  .  type  =  EOF;	[BUGGY]  tkn  .  type  =  TOKEN  ;    ;  [FE]  AssertionFailedError    Token  type  expected:<EOF>  but  was:<TOKEN>  assertTokenEquals(TOKEN  ,   "1 "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "2 "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "3 "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   " "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "b  x "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "c "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "d "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "e "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   " "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  while  (  eol  &&  (  lastChar  =  =  '\n'  ||  lastChar  =  =  '\r'  ||  lastChar  =  =  ExtendedBufferedReader  .  UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {    lastChar  =  c  ;  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;    if  (  isEndOfFile  (  c  )  )  {  [ATTENTION]  tkn  .  type  =  TOKEN  ;    ;    return  tkn  ;  }  }    [METHOD]  nextToken  [TYPE]  Token  [PARAMETER]  Token  tkn  [CLASS]  CSVLexer    [TYPE]  boolean  eol  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  lastChar  
[REPLACE]  lastChar  =  c;	[BUGGY]  lastChar  =    null  ;  [CE]  incompatible  types  [CONTEXT]  while  (  eol  &&  (  lastChar  =  =  '\n'  ||  lastChar  =  =  '\r'  ||  lastChar  =  =  ExtendedBufferedReader  .  UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {    [ATTENTION]  lastChar  =  null  ;  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;    if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }  }    [METHOD]  nextToken  [TYPE]  Token  [PARAMETER]  Token  tkn  [CLASS]  CSVLexer    [TYPE]  boolean  eol  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  lastChar  
[ADD]  lastChar  =  c;  c  =  in  .  read  (  )  ;	[BUGGY]  [FE]  [CONTEXT]  while  (  eol  &&  (  lastChar  =  =  '\n'  ||  lastChar  =  =  '\r'  ||  lastChar  =  =  ExtendedBufferedReader  .  UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {    [ATTENTION]    eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;    if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }  }    [METHOD]  nextToken  [TYPE]  Token  [PARAMETER]  Token  tkn  [CLASS]  CSVLexer    [TYPE]  boolean  eol  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  lastChar  
[REPLACE]  c  =  in  .  read  (  )  ;	[BUGGY]  c  =  in  .  readAgain  (  )  ;    ;  [FE]  [CONTEXT]  while  (  eol  &&  (  lastChar  =  =  '\n'  ||  lastChar  =  =  '\r'  ||  lastChar  =  =  ExtendedBufferedReader  .  UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {    lastChar  =  c  ;  [ATTENTION]  c  =  in  .  readAgain  (  )    ;    ;  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;    if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }  }    [METHOD]  nextToken  [TYPE]  Token  [PARAMETER]  Token  tkn  [CLASS]  CSVLexer    [TYPE]  boolean  eol  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  lastChar  
[REPLACE]  eol  =  isEndOfLine  (  c  )  ;	[BUGGY]  eol  =    isEndOfLine  (  lastChar  )  ;  [FE]  AssertionFailedError    arrays  first  differed  at  element  [0]  ;  expected:<[w]orld>  but  was:<[]orld>  assertEquals(res.length  ,  records.size())  ;  assertTrue(records.size()  >  0)  ;  assertArrayEquals(res[i]  ,  records.get(i).values())  ;  [CONTEXT]  while  (  eol  &&  (  lastChar  =  =  '\n'  ||  lastChar  =  =  '\r'  ||  lastChar  =  =  ExtendedBufferedReader  .  UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {    lastChar  =  c  ;  c  =  in  .  read  (  )  ;  [ATTENTION]  eol  =  isEndOfLine  (  lastChar  )    ;  c  =  in  .  readAgain  (  )  ;    if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }  }    [METHOD]  nextToken  [TYPE]  Token  [PARAMETER]  Token  tkn  [CLASS]  CSVLexer    [TYPE]  boolean  eol  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  lastChar  
[ADD]  eol  =  isEndOfLine  (  c  )  ;	[BUGGY]  [FE]  AssertionFailedError    expected:<3>  but  was:<5>  assertEquals(3  ,  records.size())  ;  [CONTEXT]  while  (  eol  &&  (  lastChar  =  =  '\n'  ||  lastChar  =  =  '\r'  ||  lastChar  =  =  ExtendedBufferedReader  .  UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {    lastChar  =  c  ;  c  =  in  .  read  (  )  ;  [ATTENTION]  c  =  in  .  readAgain  (  )  ;    if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }  }    [METHOD]  nextToken  [TYPE]  Token  [PARAMETER]  Token  tkn  [CLASS]  CSVLexer    [TYPE]  boolean  eol  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  lastChar  
[REPLACE]  c  =  in  .  readAgain  (  )  ;	[BUGGY]  c  =  in  .  read  (  )  ;    ;  [FE]  AssertionFailedError    arrays  first  differed  at  element  [0]  ;  expected:<[w]orld>  but  was:<[]orld>  assertEquals(res.length  ,  records.size())  ;  assertTrue(records.size()  >  0)  ;  assertArrayEquals(res[i]  ,  records.get(i).values())  ;  [CONTEXT]  while  (  eol  &&  (  lastChar  =  =  '\n'  ||  lastChar  =  =  '\r'  ||  lastChar  =  =  ExtendedBufferedReader  .  UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {    lastChar  =  c  ;  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  [ATTENTION]  c  =  in  .  read  (  )    ;    ;    if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }  }    [METHOD]  nextToken  [TYPE]  Token  [PARAMETER]  Token  tkn  [CLASS]  CSVLexer    [TYPE]  boolean  eol  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  lastChar  
[REPLACE]  if  (  emptyLinesIgnored  )  {	[BUGGY]  if  (  isEscape  (  c  )  )  {[FE]  AssertionFailedError    Token  type  expected:<EOF>  but  was:<EORECORD>  assertTokenEquals(TOKEN  ,   "1 "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "2 "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "3 "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   " "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "b  x "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "c "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "d "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "e "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   " "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  Token  nextToken  (  Token  tkn  )  throws  IOException  {    int  lastChar  =  in  .  readAgain  (  )  ;              int  c  =  in  .  read  (  )  ;  boolean  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;      [ATTENTION]  if  (  isEscape  (  c  )  )  {  while  (  eol  &&  (  lastChar  =  =  '\n'  ||  lastChar  =  =  '\r'  ||  lastChar  =  =  ExtendedBufferedReader  .  UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {    lastChar  =  c  ;  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;    if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }  }  }    if  (  isEndOfFile  (  lastChar  )  ||  (  !isDelimiter  (  lastChar  )  &&  isEndOfFile  (  c  )  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }    while  (  tkn  .  type  =  =  INVALID  )  {    if  (  surroundingSpacesIgnored  )  {  while  (  isWhitespace  (  c  )  &&  !eol  )  {  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  }  }    if  (  isCommentStart  (  c  )  )  {    in  .  readLine  (  )  ;  tkn  =  nextToken  (  tkn  .  reset  (  )  )  ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  }  else  if  (  eol  )  {      tkn  .  type  =  EORECORD  ;  }  else  if  (  isEncapsulator  (  c  )  )  {    encapsulatedTokenLexer  (  tkn  ,  c  )  ;  }  else  if  (  isEndOfFile  (  c  )  )  {      tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  there  is  data  at  EOF  }  else  {      simpleTokenLexer  (  tkn  ,  c  )  ;  }  }  return  tkn  ;  }    [METHOD]  nextToken  [TYPE]  Token  [PARAMETER]  Token  tkn  [CLASS]  CSVLexer    [TYPE]  boolean  eol  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  lastChar  
[REPLACE]  while  (  eol  &&  (  lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader  .  UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {	[BUGGY]  while  (  eol  ;  [CE]  ')'  expected  [CONTEXT]  Token  nextToken  (  Token  tkn  )  throws  IOException  {    int  lastChar  =  in  .  readAgain  (  )  ;              int  c  =  in  .  read  (  )  ;  boolean  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;      if  (  emptyLinesIgnored  )  {  [ATTENTION]  while  (  eol  ;      lastChar  =  c  ;  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;    if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }  }  }    if  (  isEndOfFile  (  lastChar  )  ||  (  !isDelimiter  (  lastChar  )  &&  isEndOfFile  (  c  )  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }    while  (  tkn  .  type  =  =  INVALID  )  {    if  (  surroundingSpacesIgnored  )  {  while  (  isWhitespace  (  c  )  &&  !eol  )  {  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  }  }    if  (  isCommentStart  (  c  )  )  {    in  .  readLine  (  )  ;  tkn  =  nextToken  (  tkn  .  reset  (  )  )  ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  }  else  if  (  eol  )  {      tkn  .  type  =  EORECORD  ;  }  else  if  (  isEncapsulator  (  c  )  )  {    encapsulatedTokenLexer  (  tkn  ,  c  )  ;  }  else  if  (  isEndOfFile  (  c  )  )  {      tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  there  is  data  at  EOF  }  else  {      simpleTokenLexer  (  tkn  ,  c  )  ;  }  }  return  tkn  ;  }    [METHOD]  nextToken  [TYPE]  Token  [PARAMETER]  Token  tkn  [CLASS]  CSVLexer    [TYPE]  boolean  eol  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  lastChar  
[REPLACE]  if  (  isEndOfFile  (  c  )  )  {	[BUGGY]  if  (  isEscape  (  c  )  )  {[NO-ERROR]  [CONTEXT]  while  (  eol  &&  (  lastChar  =  =  '\n'  ||  lastChar  =  =  '\r'  ||  lastChar  =  =  ExtendedBufferedReader  .  UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {    lastChar  =  c  ;  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;    [ATTENTION]  if  (  isEscape  (  c  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }  }    [METHOD]  nextToken  [TYPE]  Token  [PARAMETER]  Token  tkn  [CLASS]  CSVLexer    [TYPE]  boolean  eol  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  lastChar  
[ADD]  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;	[BUGGY]  [FE]  [CONTEXT]  while  (  eol  &&  (  lastChar  =  =  '\n'  ||  lastChar  =  =  '\r'  ||  lastChar  =  =  ExtendedBufferedReader  .  UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {    lastChar  =  c  ;  [ATTENTION]    c  =  in  .  readAgain  (  )  ;    if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }  }    [METHOD]  nextToken  [TYPE]  Token  [PARAMETER]  Token  tkn  [CLASS]  CSVLexer    [TYPE]  boolean  eol  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  lastChar  
[ADD]  c  =  in  .  readAgain  (  )  ;	[BUGGY]  [NO-ERROR]  [CONTEXT]  while  (  eol  &&  (  lastChar  =  =  '\n'  ||  lastChar  =  =  '\r'  ||  lastChar  =  =  ExtendedBufferedReader  .  UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {    lastChar  =  c  ;  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  [ATTENTION]    if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }  }    [METHOD]  nextToken  [TYPE]  Token  [PARAMETER]  Token  tkn  [CLASS]  CSVLexer    [TYPE]  boolean  eol  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  lastChar  
[ADD]  tkn  .  type  =  EOF;	[BUGGY]  [FE]  AssertionFailedError    Token  type  expected:<EOF>  but  was:<INVALID>  assertTokenEquals(TOKEN  ,   "1 "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "2 "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "3 "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   " "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "b  x "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "c "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "d "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "e "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   " "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  while  (  eol  &&  (  lastChar  =  =  '\n'  ||  lastChar  =  =  '\r'  ||  lastChar  =  =  ExtendedBufferedReader  .  UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {    lastChar  =  c  ;  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;    if  (  isEndOfFile  (  c  )  )  {  [ATTENTION]    return  tkn  ;  }  }    [METHOD]  nextToken  [TYPE]  Token  [PARAMETER]  Token  tkn  [CLASS]  CSVLexer    [TYPE]  boolean  eol  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  lastChar  
[REPLACE]  if  (  isEndOfFile  (  c  )  )  {	[BUGGY]  if  (  isEscape  (  c  )  )  {[NO-ERROR]  [CONTEXT]  Token  nextToken  (  Token  tkn  )  throws  IOException  {    int  lastChar  =  in  .  readAgain  (  )  ;              int  c  =  in  .  read  (  )  ;  boolean  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;      if  (  emptyLinesIgnored  )  {  while  (  eol  &&  (  lastChar  =  =  '\n'  ||  lastChar  =  =  '\r'  ||  lastChar  =  =  ExtendedBufferedReader  .  UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {    lastChar  =  c  ;  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;    [ATTENTION]  if  (  isEscape  (  c  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }  }  }    if  (  isEndOfFile  (  lastChar  )  ||  (  !isDelimiter  (  lastChar  )  &&  isEndOfFile  (  c  )  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }    while  (  tkn  .  type  =  =  INVALID  )  {    if  (  surroundingSpacesIgnored  )  {  while  (  isWhitespace  (  c  )  &&  !eol  )  {  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  }  }    if  (  isCommentStart  (  c  )  )  {    in  .  readLine  (  )  ;  tkn  =  nextToken  (  tkn  .  reset  (  )  )  ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  }  else  if  (  eol  )  {      tkn  .  type  =  EORECORD  ;  }  else  if  (  isEncapsulator  (  c  )  )  {    encapsulatedTokenLexer  (  tkn  ,  c  )  ;  }  else  if  (  isEndOfFile  (  c  )  )  {      tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  there  is  data  at  EOF  }  else  {      simpleTokenLexer  (  tkn  ,  c  )  ;  }  }  return  tkn  ;  }    [METHOD]  nextToken  [TYPE]  Token  [PARAMETER]  Token  tkn  [CLASS]  CSVLexer    [TYPE]  boolean  eol  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  lastChar  
[REPLACE]  tkn  .  type  =  EOF;	[BUGGY]  tkn  .  type  =  TOKEN  ;    ;  [FE]  AssertionFailedError    Token  type  expected:<EOF>  but  was:<TOKEN>  assertTokenEquals(TOKEN  ,   "1 "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "2 "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "3 "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   " "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "b  x "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "c "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "d "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "e "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   " "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  Token  nextToken  (  Token  tkn  )  throws  IOException  {    int  lastChar  =  in  .  readAgain  (  )  ;              int  c  =  in  .  read  (  )  ;  boolean  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;      if  (  emptyLinesIgnored  )  {  while  (  eol  &&  (  lastChar  =  =  '\n'  ||  lastChar  =  =  '\r'  ||  lastChar  =  =  ExtendedBufferedReader  .  UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {    lastChar  =  c  ;  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;    if  (  isEndOfFile  (  c  )  )  {  [ATTENTION]  tkn  .  type  =  TOKEN  ;    ;    return  tkn  ;  }  }  }    if  (  isEndOfFile  (  lastChar  )  ||  (  !isDelimiter  (  lastChar  )  &&  isEndOfFile  (  c  )  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }    while  (  tkn  .  type  =  =  INVALID  )  {    if  (  surroundingSpacesIgnored  )  {  while  (  isWhitespace  (  c  )  &&  !eol  )  {  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  }  }    if  (  isCommentStart  (  c  )  )  {    in  .  readLine  (  )  ;  tkn  =  nextToken  (  tkn  .  reset  (  )  )  ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  }  else  if  (  eol  )  {      tkn  .  type  =  EORECORD  ;  }  else  if  (  isEncapsulator  (  c  )  )  {    encapsulatedTokenLexer  (  tkn  ,  c  )  ;  }  else  if  (  isEndOfFile  (  c  )  )  {      tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  there  is  data  at  EOF  }  else  {      simpleTokenLexer  (  tkn  ,  c  )  ;  }  }  return  tkn  ;  }    [METHOD]  nextToken  [TYPE]  Token  [PARAMETER]  Token  tkn  [CLASS]  CSVLexer    [TYPE]  boolean  eol  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  lastChar  
[ADD]  tkn  .  type  =  EOF;	[BUGGY]  [FE]  AssertionFailedError    Token  type  expected:<EOF>  but  was:<INVALID>  assertTokenEquals(TOKEN  ,   "1 "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "2 "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "3 "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   " "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "b  x "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "c "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "d "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "e "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   " "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  Token  nextToken  (  Token  tkn  )  throws  IOException  {    int  lastChar  =  in  .  readAgain  (  )  ;              int  c  =  in  .  read  (  )  ;  boolean  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;      if  (  emptyLinesIgnored  )  {  while  (  eol  &&  (  lastChar  =  =  '\n'  ||  lastChar  =  =  '\r'  ||  lastChar  =  =  ExtendedBufferedReader  .  UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {    lastChar  =  c  ;  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;    if  (  isEndOfFile  (  c  )  )  {  [ATTENTION]    return  tkn  ;  }  }  }    if  (  isEndOfFile  (  lastChar  )  ||  (  !isDelimiter  (  lastChar  )  &&  isEndOfFile  (  c  )  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }    while  (  tkn  .  type  =  =  INVALID  )  {    if  (  surroundingSpacesIgnored  )  {  while  (  isWhitespace  (  c  )  &&  !eol  )  {  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  }  }    if  (  isCommentStart  (  c  )  )  {    in  .  readLine  (  )  ;  tkn  =  nextToken  (  tkn  .  reset  (  )  )  ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  }  else  if  (  eol  )  {      tkn  .  type  =  EORECORD  ;  }  else  if  (  isEncapsulator  (  c  )  )  {    encapsulatedTokenLexer  (  tkn  ,  c  )  ;  }  else  if  (  isEndOfFile  (  c  )  )  {      tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  there  is  data  at  EOF  }  else  {      simpleTokenLexer  (  tkn  ,  c  )  ;  }  }  return  tkn  ;  }    [METHOD]  nextToken  [TYPE]  Token  [PARAMETER]  Token  tkn  [CLASS]  CSVLexer    [TYPE]  boolean  eol  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  lastChar  
[REPLACE]  lastChar  =  c;	[BUGGY]  lastChar  =    null  ;  [CE]  incompatible  types  [CONTEXT]  Token  nextToken  (  Token  tkn  )  throws  IOException  {    int  lastChar  =  in  .  readAgain  (  )  ;              int  c  =  in  .  read  (  )  ;  boolean  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;      if  (  emptyLinesIgnored  )  {  while  (  eol  &&  (  lastChar  =  =  '\n'  ||  lastChar  =  =  '\r'  ||  lastChar  =  =  ExtendedBufferedReader  .  UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {    [ATTENTION]  lastChar  =  null  ;  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;    if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }  }  }    if  (  isEndOfFile  (  lastChar  )  ||  (  !isDelimiter  (  lastChar  )  &&  isEndOfFile  (  c  )  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }    while  (  tkn  .  type  =  =  INVALID  )  {    if  (  surroundingSpacesIgnored  )  {  while  (  isWhitespace  (  c  )  &&  !eol  )  {  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  }  }    if  (  isCommentStart  (  c  )  )  {    in  .  readLine  (  )  ;  tkn  =  nextToken  (  tkn  .  reset  (  )  )  ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  }  else  if  (  eol  )  {      tkn  .  type  =  EORECORD  ;  }  else  if  (  isEncapsulator  (  c  )  )  {    encapsulatedTokenLexer  (  tkn  ,  c  )  ;  }  else  if  (  isEndOfFile  (  c  )  )  {      tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  there  is  data  at  EOF  }  else  {      simpleTokenLexer  (  tkn  ,  c  )  ;  }  }  return  tkn  ;  }    [METHOD]  nextToken  [TYPE]  Token  [PARAMETER]  Token  tkn  [CLASS]  CSVLexer    [TYPE]  boolean  eol  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  lastChar  
[REPLACE]  c  =  in  .  read  (  )  ;	[BUGGY]  c  =  in  .  readAgain  (  )  ;    ;  [FE]  [CONTEXT]  Token  nextToken  (  Token  tkn  )  throws  IOException  {    int  lastChar  =  in  .  readAgain  (  )  ;              int  c  =  in  .  read  (  )  ;  boolean  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;      if  (  emptyLinesIgnored  )  {  while  (  eol  &&  (  lastChar  =  =  '\n'  ||  lastChar  =  =  '\r'  ||  lastChar  =  =  ExtendedBufferedReader  .  UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {    lastChar  =  c  ;  [ATTENTION]  c  =  in  .  readAgain  (  )    ;    ;  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;    if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }  }  }    if  (  isEndOfFile  (  lastChar  )  ||  (  !isDelimiter  (  lastChar  )  &&  isEndOfFile  (  c  )  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }    while  (  tkn  .  type  =  =  INVALID  )  {    if  (  surroundingSpacesIgnored  )  {  while  (  isWhitespace  (  c  )  &&  !eol  )  {  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  }  }    if  (  isCommentStart  (  c  )  )  {    in  .  readLine  (  )  ;  tkn  =  nextToken  (  tkn  .  reset  (  )  )  ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  }  else  if  (  eol  )  {      tkn  .  type  =  EORECORD  ;  }  else  if  (  isEncapsulator  (  c  )  )  {    encapsulatedTokenLexer  (  tkn  ,  c  )  ;  }  else  if  (  isEndOfFile  (  c  )  )  {      tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  there  is  data  at  EOF  }  else  {      simpleTokenLexer  (  tkn  ,  c  )  ;  }  }  return  tkn  ;  }    [METHOD]  nextToken  [TYPE]  Token  [PARAMETER]  Token  tkn  [CLASS]  CSVLexer    [TYPE]  boolean  eol  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  lastChar  
[REPLACE]  eol  =  isEndOfLine  (  c  )  ;	[BUGGY]  eol  =    isEndOfLine  (  lastChar  )  ;  [FE]  AssertionFailedError    arrays  first  differed  at  element  [0]  ;  expected:<[w]orld>  but  was:<[]orld>  assertEquals(res.length  ,  records.size())  ;  assertTrue(records.size()  >  0)  ;  assertArrayEquals(res[i]  ,  records.get(i).values())  ;  [CONTEXT]  Token  nextToken  (  Token  tkn  )  throws  IOException  {    int  lastChar  =  in  .  readAgain  (  )  ;              int  c  =  in  .  read  (  )  ;  boolean  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;      if  (  emptyLinesIgnored  )  {  while  (  eol  &&  (  lastChar  =  =  '\n'  ||  lastChar  =  =  '\r'  ||  lastChar  =  =  ExtendedBufferedReader  .  UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {    lastChar  =  c  ;  c  =  in  .  read  (  )  ;  [ATTENTION]  eol  =  isEndOfLine  (  lastChar  )    ;  c  =  in  .  readAgain  (  )  ;    if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }  }  }    if  (  isEndOfFile  (  lastChar  )  ||  (  !isDelimiter  (  lastChar  )  &&  isEndOfFile  (  c  )  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }    while  (  tkn  .  type  =  =  INVALID  )  {    if  (  surroundingSpacesIgnored  )  {  while  (  isWhitespace  (  c  )  &&  !eol  )  {  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  }  }    if  (  isCommentStart  (  c  )  )  {    in  .  readLine  (  )  ;  tkn  =  nextToken  (  tkn  .  reset  (  )  )  ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  }  else  if  (  eol  )  {      tkn  .  type  =  EORECORD  ;  }  else  if  (  isEncapsulator  (  c  )  )  {    encapsulatedTokenLexer  (  tkn  ,  c  )  ;  }  else  if  (  isEndOfFile  (  c  )  )  {      tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  there  is  data  at  EOF  }  else  {      simpleTokenLexer  (  tkn  ,  c  )  ;  }  }  return  tkn  ;  }    [METHOD]  nextToken  [TYPE]  Token  [PARAMETER]  Token  tkn  [CLASS]  CSVLexer    [TYPE]  boolean  eol  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  lastChar  
[ADD]  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;	[BUGGY]  [FE]  AssertionFailedError    expected:<3>  but  was:<5>  assertEquals(3  ,  records.size())  ;  [CONTEXT]  Token  nextToken  (  Token  tkn  )  throws  IOException  {    int  lastChar  =  in  .  readAgain  (  )  ;              int  c  =  in  .  read  (  )  ;  boolean  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;      if  (  emptyLinesIgnored  )  {  while  (  eol  &&  (  lastChar  =  =  '\n'  ||  lastChar  =  =  '\r'  ||  lastChar  =  =  ExtendedBufferedReader  .  UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {    lastChar  =  c  ;  c  =  in  .  read  (  )  ;  [ATTENTION]      if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }  }  }    if  (  isEndOfFile  (  lastChar  )  ||  (  !isDelimiter  (  lastChar  )  &&  isEndOfFile  (  c  )  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }    while  (  tkn  .  type  =  =  INVALID  )  {    if  (  surroundingSpacesIgnored  )  {  while  (  isWhitespace  (  c  )  &&  !eol  )  {  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  }  }    if  (  isCommentStart  (  c  )  )  {    in  .  readLine  (  )  ;  tkn  =  nextToken  (  tkn  .  reset  (  )  )  ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  }  else  if  (  eol  )  {      tkn  .  type  =  EORECORD  ;  }  else  if  (  isEncapsulator  (  c  )  )  {    encapsulatedTokenLexer  (  tkn  ,  c  )  ;  }  else  if  (  isEndOfFile  (  c  )  )  {      tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  there  is  data  at  EOF  }  else  {      simpleTokenLexer  (  tkn  ,  c  )  ;  }  }  return  tkn  ;  }    [METHOD]  nextToken  [TYPE]  Token  [PARAMETER]  Token  tkn  [CLASS]  CSVLexer    [TYPE]  boolean  eol  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  lastChar  
[REPLACE]  c  =  in  .  readAgain  (  )  ;	[BUGGY]  c  =  in  .  read  (  )  ;    ;  [FE]  AssertionFailedError    arrays  first  differed  at  element  [0]  ;  expected:<[w]orld>  but  was:<[]orld>  assertEquals(res.length  ,  records.size())  ;  assertTrue(records.size()  >  0)  ;  assertArrayEquals(res[i]  ,  records.get(i).values())  ;  [CONTEXT]  Token  nextToken  (  Token  tkn  )  throws  IOException  {    int  lastChar  =  in  .  readAgain  (  )  ;              int  c  =  in  .  read  (  )  ;  boolean  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;      if  (  emptyLinesIgnored  )  {  while  (  eol  &&  (  lastChar  =  =  '\n'  ||  lastChar  =  =  '\r'  ||  lastChar  =  =  ExtendedBufferedReader  .  UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {    lastChar  =  c  ;  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  [ATTENTION]  c  =  in  .  read  (  )    ;    ;    if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }  }  }    if  (  isEndOfFile  (  lastChar  )  ||  (  !isDelimiter  (  lastChar  )  &&  isEndOfFile  (  c  )  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }    while  (  tkn  .  type  =  =  INVALID  )  {    if  (  surroundingSpacesIgnored  )  {  while  (  isWhitespace  (  c  )  &&  !eol  )  {  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  }  }    if  (  isCommentStart  (  c  )  )  {    in  .  readLine  (  )  ;  tkn  =  nextToken  (  tkn  .  reset  (  )  )  ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  }  else  if  (  eol  )  {      tkn  .  type  =  EORECORD  ;  }  else  if  (  isEncapsulator  (  c  )  )  {    encapsulatedTokenLexer  (  tkn  ,  c  )  ;  }  else  if  (  isEndOfFile  (  c  )  )  {      tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  there  is  data  at  EOF  }  else  {      simpleTokenLexer  (  tkn  ,  c  )  ;  }  }  return  tkn  ;  }    [METHOD]  nextToken  [TYPE]  Token  [PARAMETER]  Token  tkn  [CLASS]  CSVLexer    [TYPE]  boolean  eol  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  lastChar  
[REPLACE]  if  (  isEndOfFile  (  c  )  )  {	[BUGGY]  if  (  isEndOfFile  (  lastChar  )  )  {[NO-ERROR]  [CONTEXT]  Token  nextToken  (  Token  tkn  )  throws  IOException  {    int  lastChar  =  in  .  readAgain  (  )  ;              int  c  =  in  .  read  (  )  ;  boolean  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;      if  (  emptyLinesIgnored  )  {  while  (  eol  &&  (  lastChar  =  =  '\n'  ||  lastChar  =  =  '\r'  ||  lastChar  =  =  ExtendedBufferedReader  .  UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {    lastChar  =  c  ;  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;    [ATTENTION]  if  (  isEndOfFile  (  lastChar  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }  }  }    if  (  isEndOfFile  (  lastChar  )  ||  (  !isDelimiter  (  lastChar  )  &&  isEndOfFile  (  c  )  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }    while  (  tkn  .  type  =  =  INVALID  )  {    if  (  surroundingSpacesIgnored  )  {  while  (  isWhitespace  (  c  )  &&  !eol  )  {  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  }  }    if  (  isCommentStart  (  c  )  )  {    in  .  readLine  (  )  ;  tkn  =  nextToken  (  tkn  .  reset  (  )  )  ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  }  else  if  (  eol  )  {      tkn  .  type  =  EORECORD  ;  }  else  if  (  isEncapsulator  (  c  )  )  {    encapsulatedTokenLexer  (  tkn  ,  c  )  ;  }  else  if  (  isEndOfFile  (  c  )  )  {      tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  there  is  data  at  EOF  }  else  {      simpleTokenLexer  (  tkn  ,  c  )  ;  }  }  return  tkn  ;  }    [METHOD]  nextToken  [TYPE]  Token  [PARAMETER]  Token  tkn  [CLASS]  CSVLexer    [TYPE]  boolean  eol  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  lastChar  
[REPLACE]  if  (  isEndOfFile  (  lastChar  )  ||  (  !isDelimiter  (  lastChar  )  &&  isEndOfFile  (  c  )  )  )  {	[BUGGY]  if  (  isEndOfFile  (  lastChar  )  ||  (  isDelimiter  (  lastChar  )  &&  isEndOfFile  (  c  )  )  )  {[FE]  null  assertEquals(CSVFormat.DISABLED  ,  format.getCommentStart())  ;  assertTrue(records.size()  >  0)  ;  assertTrue(CSVPrinterTest.equals(res  ,  records))  ;  assertTrue(CSVPrinterTest.equals(res_comments  ,  records))  ;  [CONTEXT]  Token  nextToken  (  Token  tkn  )  throws  IOException  {    int  lastChar  =  in  .  readAgain  (  )  ;              int  c  =  in  .  read  (  )  ;  boolean  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;      if  (  emptyLinesIgnored  )  {  while  (  eol  &&  (  lastChar  =  =  '\n'  ||  lastChar  =  =  '\r'  ||  lastChar  =  =  ExtendedBufferedReader  .  UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {    lastChar  =  c  ;  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;    if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }  }  }    [ATTENTION]  if  (  isEndOfFile  (  lastChar  )  ||  (  isDelimiter  (  lastChar  )  &&  isEndOfFile  (  c  )  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }    while  (  tkn  .  type  =  =  INVALID  )  {    if  (  surroundingSpacesIgnored  )  {  while  (  isWhitespace  (  c  )  &&  !eol  )  {  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  }  }    if  (  isCommentStart  (  c  )  )  {    in  .  readLine  (  )  ;  tkn  =  nextToken  (  tkn  .  reset  (  )  )  ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  }  else  if  (  eol  )  {      tkn  .  type  =  EORECORD  ;  }  else  if  (  isEncapsulator  (  c  )  )  {    encapsulatedTokenLexer  (  tkn  ,  c  )  ;  }  else  if  (  isEndOfFile  (  c  )  )  {      tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  there  is  data  at  EOF  }  else  {      simpleTokenLexer  (  tkn  ,  c  )  ;  }  }  return  tkn  ;  }    [METHOD]  nextToken  [TYPE]  Token  [PARAMETER]  Token  tkn  [CLASS]  CSVLexer    [TYPE]  boolean  eol  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  lastChar  
[REMOVE]  	[BUGGY]  if  (  isEndOfFile  (  c  )  )  {      tkn  .  type  =  EOF  ;      return  tkn  ;  }[NO-ERROR]  [CONTEXT]  Token  nextToken  (  Token  tkn  )  throws  IOException  {    int  lastChar  =  in  .  readAgain  (  )  ;              int  c  =  in  .  read  (  )  ;  boolean  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;      if  (  emptyLinesIgnored  )  {  while  (  eol  &&  (  lastChar  =  =  '\n'  ||  lastChar  =  =  '\r'  ||  lastChar  =  =  ExtendedBufferedReader  .  UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {    lastChar  =  c  ;  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;    if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }  }  }    [ATTENTION]  if  (  isEndOfFile  (  lastChar  )  ||  (  !isDelimiter  (  lastChar  )  &&  isEndOfFile  (  c  )  )  )  {  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  return  tkn  ;  }tkn  .  type  =  EOF  ;    return  tkn  ;  }    while  (  tkn  .  type  =  =  INVALID  )  {    if  (  surroundingSpacesIgnored  )  {  while  (  isWhitespace  (  c  )  &&  !eol  )  {  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  }  }    if  (  isCommentStart  (  c  )  )  {    in  .  readLine  (  )  ;  tkn  =  nextToken  (  tkn  .  reset  (  )  )  ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  }  else  if  (  eol  )  {      tkn  .  type  =  EORECORD  ;  }  else  if  (  isEncapsulator  (  c  )  )  {    encapsulatedTokenLexer  (  tkn  ,  c  )  ;  }  else  if  (  isEndOfFile  (  c  )  )  {      tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  there  is  data  at  EOF  }  else  {      simpleTokenLexer  (  tkn  ,  c  )  ;  }  }  return  tkn  ;      [METHOD]  nextToken  [TYPE]  Token  [PARAMETER]  Token  tkn  [CLASS]  CSVLexer    [TYPE]  boolean  eol  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  lastChar  
[REPLACE]  tkn  .  type  =  EOF;	[BUGGY]  tkn  .  type  =  TOKEN  ;    ;  [FE]  [CONTEXT]  Token  nextToken  (  Token  tkn  )  throws  IOException  {    int  lastChar  =  in  .  readAgain  (  )  ;              int  c  =  in  .  read  (  )  ;  boolean  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;      if  (  emptyLinesIgnored  )  {  while  (  eol  &&  (  lastChar  =  =  '\n'  ||  lastChar  =  =  '\r'  ||  lastChar  =  =  ExtendedBufferedReader  .  UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {    lastChar  =  c  ;  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;    if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }  }  }    if  (  isEndOfFile  (  lastChar  )  ||  (  !isDelimiter  (  lastChar  )  &&  isEndOfFile  (  c  )  )  )  {  [ATTENTION]  tkn  .  type  =  TOKEN  ;    ;    return  tkn  ;  }    while  (  tkn  .  type  =  =  INVALID  )  {    if  (  surroundingSpacesIgnored  )  {  while  (  isWhitespace  (  c  )  &&  !eol  )  {  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  }  }    if  (  isCommentStart  (  c  )  )  {    in  .  readLine  (  )  ;  tkn  =  nextToken  (  tkn  .  reset  (  )  )  ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  }  else  if  (  eol  )  {      tkn  .  type  =  EORECORD  ;  }  else  if  (  isEncapsulator  (  c  )  )  {    encapsulatedTokenLexer  (  tkn  ,  c  )  ;  }  else  if  (  isEndOfFile  (  c  )  )  {      tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  there  is  data  at  EOF  }  else  {      simpleTokenLexer  (  tkn  ,  c  )  ;  }  }  return  tkn  ;  }    [METHOD]  nextToken  [TYPE]  Token  [PARAMETER]  Token  tkn  [CLASS]  CSVLexer    [TYPE]  boolean  eol  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  lastChar  
[REPLACE]  while  (  tkn  .  type  ==  INVALID  )  {	[BUGGY]  while  (  tkn  .  type  &&  INVALID  )  {[CE]  bad  operand  types  for  binary  operator  '&&'  [CONTEXT]  Token  nextToken  (  Token  tkn  )  throws  IOException  {    int  lastChar  =  in  .  readAgain  (  )  ;              int  c  =  in  .  read  (  )  ;  boolean  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;      if  (  emptyLinesIgnored  )  {  while  (  eol  &&  (  lastChar  =  =  '\n'  ||  lastChar  =  =  '\r'  ||  lastChar  =  =  ExtendedBufferedReader  .  UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {    lastChar  =  c  ;  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;    if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }  }  }    if  (  isEndOfFile  (  lastChar  )  ||  (  !isDelimiter  (  lastChar  )  &&  isEndOfFile  (  c  )  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }    [ATTENTION]  while  (  tkn  .  type&&INVALID  )  {    if  (  surroundingSpacesIgnored  )  {  while  (  isWhitespace  (  c  )  &&  !eol  )  {  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  }  }    if  (  isCommentStart  (  c  )  )  {    in  .  readLine  (  )  ;  tkn  =  nextToken  (  tkn  .  reset  (  )  )  ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  }  else  if  (  eol  )  {      tkn  .  type  =  EORECORD  ;  }  else  if  (  isEncapsulator  (  c  )  )  {    encapsulatedTokenLexer  (  tkn  ,  c  )  ;  }  else  if  (  isEndOfFile  (  c  )  )  {      tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  there  is  data  at  EOF  }  else  {      simpleTokenLexer  (  tkn  ,  c  )  ;  }  }  return  tkn  ;  }    [METHOD]  nextToken  [TYPE]  Token  [PARAMETER]  Token  tkn  [CLASS]  CSVLexer    [TYPE]  boolean  eol  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  lastChar  
[ADD]  while  (  tkn  .  type  ==  INVALID  )  {  if  (  surroundingSpacesIgnored  )  {	[BUGGY]  [CE]  illegal  start  of  type  [CONTEXT]  Token  nextToken  (  Token  tkn  )  throws  IOException  {    int  lastChar  =  in  .  readAgain  (  )  ;              int  c  =  in  .  read  (  )  ;  boolean  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;      if  (  emptyLinesIgnored  )  {  while  (  eol  &&  (  lastChar  =  =  '\n'  ||  lastChar  =  =  '\r'  ||  lastChar  =  =  ExtendedBufferedReader  .  UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {    lastChar  =  c  ;  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;    if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }  }  }    if  (  isEndOfFile  (  lastChar  )  ||  (  !isDelimiter  (  lastChar  )  &&  isEndOfFile  (  c  )  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }    [ATTENTION]    while  (  isWhitespace  (  c  )  &&  !eol  )  {  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  }  }    if  (  isCommentStart  (  c  )  )  {    in  .  readLine  (  )  ;  tkn  =  nextToken  (  tkn  .  reset  (  )  )  ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  }  else  if  (  eol  )  {      tkn  .  type  =  EORECORD  ;  }  else  if  (  isEncapsulator  (  c  )  )  {    encapsulatedTokenLexer  (  tkn  ,  c  )  ;  }  else  if  (  isEndOfFile  (  c  )  )  {      tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  there  is  data  at  EOF  }  else  {      simpleTokenLexer  (  tkn  ,  c  )  ;  }  }  return  tkn  ;  }    [METHOD]  nextToken  [TYPE]  Token  [PARAMETER]  Token  tkn  [CLASS]  CSVLexer    [TYPE]  boolean  eol  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  lastChar  
[REPLACE]  while  (  isWhitespace  (  c  )  &&  !eol  )  {	[BUGGY]  while  (  isWhitespace  (  c  )    ;  [CE]  ')'  expected  [CONTEXT]  Token  nextToken  (  Token  tkn  )  throws  IOException  {    int  lastChar  =  in  .  readAgain  (  )  ;              int  c  =  in  .  read  (  )  ;  boolean  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;      if  (  emptyLinesIgnored  )  {  while  (  eol  &&  (  lastChar  =  =  '\n'  ||  lastChar  =  =  '\r'  ||  lastChar  =  =  ExtendedBufferedReader  .  UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {    lastChar  =  c  ;  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;    if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }  }  }    if  (  isEndOfFile  (  lastChar  )  ||  (  !isDelimiter  (  lastChar  )  &&  isEndOfFile  (  c  )  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }    while  (  tkn  .  type  =  =  INVALID  )  {    if  (  surroundingSpacesIgnored  )  {  [ATTENTION]  while  (  isWhitespace  (  c  )  ;  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  }  }    if  (  isCommentStart  (  c  )  )  {    in  .  readLine  (  )  ;  tkn  =  nextToken  (  tkn  .  reset  (  )  )  ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  }  else  if  (  eol  )  {      tkn  .  type  =  EORECORD  ;  }  else  if  (  isEncapsulator  (  c  )  )  {    encapsulatedTokenLexer  (  tkn  ,  c  )  ;  }  else  if  (  isEndOfFile  (  c  )  )  {      tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  there  is  data  at  EOF  }  else  {      simpleTokenLexer  (  tkn  ,  c  )  ;  }  }  return  tkn  ;  }    [METHOD]  nextToken  [TYPE]  Token  [PARAMETER]  Token  tkn  [CLASS]  CSVLexer    [TYPE]  boolean  eol  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  lastChar  
[REPLACE]  c  =  in  .  read  (  )  ;	[BUGGY]  c  =  in  .  readAgain  (  )  ;    ;  [FE]  [CONTEXT]  Token  nextToken  (  Token  tkn  )  throws  IOException  {    int  lastChar  =  in  .  readAgain  (  )  ;              int  c  =  in  .  read  (  )  ;  boolean  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;      if  (  emptyLinesIgnored  )  {  while  (  eol  &&  (  lastChar  =  =  '\n'  ||  lastChar  =  =  '\r'  ||  lastChar  =  =  ExtendedBufferedReader  .  UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {    lastChar  =  c  ;  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;    if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }  }  }    if  (  isEndOfFile  (  lastChar  )  ||  (  !isDelimiter  (  lastChar  )  &&  isEndOfFile  (  c  )  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }    while  (  tkn  .  type  =  =  INVALID  )  {    if  (  surroundingSpacesIgnored  )  {  while  (  isWhitespace  (  c  )  &&  !eol  )  {  [ATTENTION]  c  =  in  .  readAgain  (  )    ;    ;  eol  =  isEndOfLine  (  c  )  ;  }  }    if  (  isCommentStart  (  c  )  )  {    in  .  readLine  (  )  ;  tkn  =  nextToken  (  tkn  .  reset  (  )  )  ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  }  else  if  (  eol  )  {      tkn  .  type  =  EORECORD  ;  }  else  if  (  isEncapsulator  (  c  )  )  {    encapsulatedTokenLexer  (  tkn  ,  c  )  ;  }  else  if  (  isEndOfFile  (  c  )  )  {      tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  there  is  data  at  EOF  }  else  {      simpleTokenLexer  (  tkn  ,  c  )  ;  }  }  return  tkn  ;  }    [METHOD]  nextToken  [TYPE]  Token  [PARAMETER]  Token  tkn  [CLASS]  CSVLexer    [TYPE]  boolean  eol  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  lastChar  
[ADD]  c  =  in  .  read  (  )  ;	[BUGGY]  [FE]  [CONTEXT]  Token  nextToken  (  Token  tkn  )  throws  IOException  {    int  lastChar  =  in  .  readAgain  (  )  ;              int  c  =  in  .  read  (  )  ;  boolean  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;      if  (  emptyLinesIgnored  )  {  while  (  eol  &&  (  lastChar  =  =  '\n'  ||  lastChar  =  =  '\r'  ||  lastChar  =  =  ExtendedBufferedReader  .  UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {    lastChar  =  c  ;  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;    if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }  }  }    if  (  isEndOfFile  (  lastChar  )  ||  (  !isDelimiter  (  lastChar  )  &&  isEndOfFile  (  c  )  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }    while  (  tkn  .  type  =  =  INVALID  )  {    if  (  surroundingSpacesIgnored  )  {  while  (  isWhitespace  (  c  )  &&  !eol  )  {  [ATTENTION]  eol  =  isEndOfLine  (  c  )  ;  }  }    if  (  isCommentStart  (  c  )  )  {    in  .  readLine  (  )  ;  tkn  =  nextToken  (  tkn  .  reset  (  )  )  ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  }  else  if  (  eol  )  {      tkn  .  type  =  EORECORD  ;  }  else  if  (  isEncapsulator  (  c  )  )  {    encapsulatedTokenLexer  (  tkn  ,  c  )  ;  }  else  if  (  isEndOfFile  (  c  )  )  {      tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  there  is  data  at  EOF  }  else  {      simpleTokenLexer  (  tkn  ,  c  )  ;  }  }  return  tkn  ;  }    [METHOD]  nextToken  [TYPE]  Token  [PARAMETER]  Token  tkn  [CLASS]  CSVLexer    [TYPE]  boolean  eol  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  lastChar  
[REPLACE]  eol  =  isEndOfLine  (  c  )  ;	[BUGGY]  eol  =    isEndOfLine  (  null  )  ;  [CE]  method  isEndOfLine  in  class  Lexer  cannot  be  applied  to  given  types  ;  [CONTEXT]  Token  nextToken  (  Token  tkn  )  throws  IOException  {    int  lastChar  =  in  .  readAgain  (  )  ;              int  c  =  in  .  read  (  )  ;  boolean  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;      if  (  emptyLinesIgnored  )  {  while  (  eol  &&  (  lastChar  =  =  '\n'  ||  lastChar  =  =  '\r'  ||  lastChar  =  =  ExtendedBufferedReader  .  UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {    lastChar  =  c  ;  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;    if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }  }  }    if  (  isEndOfFile  (  lastChar  )  ||  (  !isDelimiter  (  lastChar  )  &&  isEndOfFile  (  c  )  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }    while  (  tkn  .  type  =  =  INVALID  )  {    if  (  surroundingSpacesIgnored  )  {  while  (  isWhitespace  (  c  )  &&  !eol  )  {  c  =  in  .  read  (  )  ;  [ATTENTION]  eol  =  isEndOfLine  (  null  )    ;  }  }    if  (  isCommentStart  (  c  )  )  {    in  .  readLine  (  )  ;  tkn  =  nextToken  (  tkn  .  reset  (  )  )  ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  }  else  if  (  eol  )  {      tkn  .  type  =  EORECORD  ;  }  else  if  (  isEncapsulator  (  c  )  )  {    encapsulatedTokenLexer  (  tkn  ,  c  )  ;  }  else  if  (  isEndOfFile  (  c  )  )  {      tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  there  is  data  at  EOF  }  else  {      simpleTokenLexer  (  tkn  ,  c  )  ;  }  }  return  tkn  ;  }    [METHOD]  nextToken  [TYPE]  Token  [PARAMETER]  Token  tkn  [CLASS]  CSVLexer    [TYPE]  boolean  eol  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  lastChar  
[REPLACE]  if  (  surroundingSpacesIgnored  )  {	[BUGGY]  if  (  isEscape  (  c  )  )  {[FE]  AssertionFailedError    Token  content  expected:<[]hijk>  but  was:<[  ]hijk>  assertTokenEquals(TOKEN  ,   "abc "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "def "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "hijk "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "lmnop "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "qrst "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "uv "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "wxy "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "z "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   " "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   " "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  Token  nextToken  (  Token  tkn  )  throws  IOException  {    int  lastChar  =  in  .  readAgain  (  )  ;              int  c  =  in  .  read  (  )  ;  boolean  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;      if  (  emptyLinesIgnored  )  {  while  (  eol  &&  (  lastChar  =  =  '\n'  ||  lastChar  =  =  '\r'  ||  lastChar  =  =  ExtendedBufferedReader  .  UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {    lastChar  =  c  ;  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;    if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }  }  }    if  (  isEndOfFile  (  lastChar  )  ||  (  !isDelimiter  (  lastChar  )  &&  isEndOfFile  (  c  )  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }    while  (  tkn  .  type  =  =  INVALID  )  {    [ATTENTION]  if  (  isEscape  (  c  )  )  {  while  (  isWhitespace  (  c  )  &&  !eol  )  {  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  }  }    if  (  isCommentStart  (  c  )  )  {    in  .  readLine  (  )  ;  tkn  =  nextToken  (  tkn  .  reset  (  )  )  ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  }  else  if  (  eol  )  {      tkn  .  type  =  EORECORD  ;  }  else  if  (  isEncapsulator  (  c  )  )  {    encapsulatedTokenLexer  (  tkn  ,  c  )  ;  }  else  if  (  isEndOfFile  (  c  )  )  {      tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  there  is  data  at  EOF  }  else  {      simpleTokenLexer  (  tkn  ,  c  )  ;  }  }  return  tkn  ;  }    [METHOD]  nextToken  [TYPE]  Token  [PARAMETER]  Token  tkn  [CLASS]  CSVLexer    [TYPE]  boolean  eol  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  lastChar  
[REPLACE]  while  (  isWhitespace  (  c  )  &&  !eol  )  {	[BUGGY]  while  (  isWhitespace  (  c  )    >  =    false  )  {[CE]  bad  operand  types  for  binary  operator  '>  =  '  [CONTEXT]  Token  nextToken  (  Token  tkn  )  throws  IOException  {    int  lastChar  =  in  .  readAgain  (  )  ;              int  c  =  in  .  read  (  )  ;  boolean  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;      if  (  emptyLinesIgnored  )  {  while  (  eol  &&  (  lastChar  =  =  '\n'  ||  lastChar  =  =  '\r'  ||  lastChar  =  =  ExtendedBufferedReader  .  UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {    lastChar  =  c  ;  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;    if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }  }  }    if  (  isEndOfFile  (  lastChar  )  ||  (  !isDelimiter  (  lastChar  )  &&  isEndOfFile  (  c  )  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }    while  (  tkn  .  type  =  =  INVALID  )  {    if  (  surroundingSpacesIgnored  )  {  [ATTENTION]  while  (  isWhitespace  (  c  )  >  =  false  )  {  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  }  }    if  (  isCommentStart  (  c  )  )  {    in  .  readLine  (  )  ;  tkn  =  nextToken  (  tkn  .  reset  (  )  )  ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  }  else  if  (  eol  )  {      tkn  .  type  =  EORECORD  ;  }  else  if  (  isEncapsulator  (  c  )  )  {    encapsulatedTokenLexer  (  tkn  ,  c  )  ;  }  else  if  (  isEndOfFile  (  c  )  )  {      tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  there  is  data  at  EOF  }  else  {      simpleTokenLexer  (  tkn  ,  c  )  ;  }  }  return  tkn  ;  }    [METHOD]  nextToken  [TYPE]  Token  [PARAMETER]  Token  tkn  [CLASS]  CSVLexer    [TYPE]  boolean  eol  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  lastChar  
[REPLACE]  eol  =  isEndOfLine  (  c  )  ;	[BUGGY]  eol  =    isEndOfLine  (  lastChar  )  ;  [FE]  array  lengths  differed  ,  expected.length  =  3  actual.length  =  1  assertArrayEquals(re  ,  parser.getRecord().values())  ;  assertNull(parser.getRecord())  ;  assertEquals(0  ,  parser.getLineNumber())  ;  assertNotNull(parser.getRecord())  ;  assertEquals(1  ,  parser.getLineNumber())  ;  assertEquals(2  ,  parser.getLineNumber())  ;  [CONTEXT]  Token  nextToken  (  Token  tkn  )  throws  IOException  {    int  lastChar  =  in  .  readAgain  (  )  ;              int  c  =  in  .  read  (  )  ;  boolean  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;      if  (  emptyLinesIgnored  )  {  while  (  eol  &&  (  lastChar  =  =  '\n'  ||  lastChar  =  =  '\r'  ||  lastChar  =  =  ExtendedBufferedReader  .  UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {    lastChar  =  c  ;  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;    if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }  }  }    if  (  isEndOfFile  (  lastChar  )  ||  (  !isDelimiter  (  lastChar  )  &&  isEndOfFile  (  c  )  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }    while  (  tkn  .  type  =  =  INVALID  )  {    if  (  surroundingSpacesIgnored  )  {  while  (  isWhitespace  (  c  )  &&  !eol  )  {  c  =  in  .  read  (  )  ;  [ATTENTION]  eol  =  isEndOfLine  (  lastChar  )    ;  }  }    if  (  isCommentStart  (  c  )  )  {    in  .  readLine  (  )  ;  tkn  =  nextToken  (  tkn  .  reset  (  )  )  ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  }  else  if  (  eol  )  {      tkn  .  type  =  EORECORD  ;  }  else  if  (  isEncapsulator  (  c  )  )  {    encapsulatedTokenLexer  (  tkn  ,  c  )  ;  }  else  if  (  isEndOfFile  (  c  )  )  {      tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  there  is  data  at  EOF  }  else  {      simpleTokenLexer  (  tkn  ,  c  )  ;  }  }  return  tkn  ;  }    [METHOD]  nextToken  [TYPE]  Token  [PARAMETER]  Token  tkn  [CLASS]  CSVLexer    [TYPE]  boolean  eol  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  lastChar  
[REPLACE]  if  (  isCommentStart  (  c  )  )  {	[BUGGY]  if  (  isCommentStart  (  lastChar  )  )  {[FE]  AssertionFailedError    Token  content  expected:<[]>  but  was:<[#foo]>  assertTokenEquals(TOKEN  ,   "1 "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "2 "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "3 "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   " "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "b  x "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "c "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "d "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "e "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   " "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  Token  nextToken  (  Token  tkn  )  throws  IOException  {    int  lastChar  =  in  .  readAgain  (  )  ;              int  c  =  in  .  read  (  )  ;  boolean  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;      if  (  emptyLinesIgnored  )  {  while  (  eol  &&  (  lastChar  =  =  '\n'  ||  lastChar  =  =  '\r'  ||  lastChar  =  =  ExtendedBufferedReader  .  UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {    lastChar  =  c  ;  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;    if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }  }  }    if  (  isEndOfFile  (  lastChar  )  ||  (  !isDelimiter  (  lastChar  )  &&  isEndOfFile  (  c  )  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }    while  (  tkn  .  type  =  =  INVALID  )  {    if  (  surroundingSpacesIgnored  )  {  while  (  isWhitespace  (  c  )  &&  !eol  )  {  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  }  }    [ATTENTION]  if  (  isCommentStart  (  lastChar  )  )  {    in  .  readLine  (  )  ;  tkn  =  nextToken  (  tkn  .  reset  (  )  )  ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  }  else  if  (  eol  )  {      tkn  .  type  =  EORECORD  ;  }  else  if  (  isEncapsulator  (  c  )  )  {    encapsulatedTokenLexer  (  tkn  ,  c  )  ;  }  else  if  (  isEndOfFile  (  c  )  )  {      tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  there  is  data  at  EOF  }  else  {      simpleTokenLexer  (  tkn  ,  c  )  ;  }  }  return  tkn  ;  }    [METHOD]  nextToken  [TYPE]  Token  [PARAMETER]  Token  tkn  [CLASS]  CSVLexer    [TYPE]  boolean  eol  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  lastChar  
[REPLACE]  }  else  if  (  isDelimiter  (  c  )  )  {	[BUGGY]    else  {[CE]  'else'  without  'if'  [CONTEXT]  Token  nextToken  (  Token  tkn  )  throws  IOException  {    int  lastChar  =  in  .  readAgain  (  )  ;              int  c  =  in  .  read  (  )  ;  boolean  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;      if  (  emptyLinesIgnored  )  {  while  (  eol  &&  (  lastChar  =  =  '\n'  ||  lastChar  =  =  '\r'  ||  lastChar  =  =  ExtendedBufferedReader  .  UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {    lastChar  =  c  ;  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;    if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }  }  }    if  (  isEndOfFile  (  lastChar  )  ||  (  !isDelimiter  (  lastChar  )  &&  isEndOfFile  (  c  )  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }    while  (  tkn  .  type  =  =  INVALID  )  {    if  (  surroundingSpacesIgnored  )  {  while  (  isWhitespace  (  c  )  &&  !eol  )  {  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  }  }    if  (  isCommentStart  (  c  )  )  {    in  .  readLine  (  )  ;  tkn  =  nextToken  (  tkn  .  reset  (  )  )  ;  [ATTENTION]  }else  {    tkn  .  type  =  TOKEN  ;  }  else  if  (  eol  )  {      tkn  .  type  =  EORECORD  ;  }  else  if  (  isEncapsulator  (  c  )  )  {    encapsulatedTokenLexer  (  tkn  ,  c  )  ;  }  else  if  (  isEndOfFile  (  c  )  )  {      tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  there  is  data  at  EOF  }  else  {      simpleTokenLexer  (  tkn  ,  c  )  ;  }  }  return  tkn  ;  }    [METHOD]  nextToken  [TYPE]  Token  [PARAMETER]  Token  tkn  [CLASS]  CSVLexer    [TYPE]  boolean  eol  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  lastChar  
[ADD]  else  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN;  }  else  if  (  eol  )  {	[BUGGY]    tkn  .  type  =  TOKEN  ;  [CE]  'else'  without  'if'  [CONTEXT]  Token  nextToken  (  Token  tkn  )  throws  IOException  {    int  lastChar  =  in  .  readAgain  (  )  ;              int  c  =  in  .  read  (  )  ;  boolean  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;      if  (  emptyLinesIgnored  )  {  while  (  eol  &&  (  lastChar  =  =  '\n'  ||  lastChar  =  =  '\r'  ||  lastChar  =  =  ExtendedBufferedReader  .  UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {    lastChar  =  c  ;  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;    if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }  }  }    if  (  isEndOfFile  (  lastChar  )  ||  (  !isDelimiter  (  lastChar  )  &&  isEndOfFile  (  c  )  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }    while  (  tkn  .  type  =  =  INVALID  )  {    if  (  surroundingSpacesIgnored  )  {  while  (  isWhitespace  (  c  )  &&  !eol  )  {  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  }  }    if  (  isCommentStart  (  c  )  )  {    in  .  readLine  (  )  ;  tkn  =  nextToken  (  tkn  .  reset  (  )  )  ;  [ATTENTION]  }  tkn  .  type  =  TOKEN  ;          tkn  .  type  =  EORECORD  ;  }  else  if  (  isEncapsulator  (  c  )  )  {    encapsulatedTokenLexer  (  tkn  ,  c  )  ;  }  else  if  (  isEndOfFile  (  c  )  )  {      tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  there  is  data  at  EOF  }  else  {      simpleTokenLexer  (  tkn  ,  c  )  ;  }  }  return  tkn  ;  }    [METHOD]  nextToken  [TYPE]  Token  [PARAMETER]  Token  tkn  [CLASS]  CSVLexer    [TYPE]  boolean  eol  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  lastChar  
[REPLACE]  }  else  if  (  eol  )  {	[BUGGY]    if  (  eol  )  {[FE]  AssertionFailedError    Token  type  expected:<EORECORD>  but  was:<TOKEN>  assertTokenEquals(TOKEN  ,   "1 "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "2 "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "3 "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   " "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "b  x "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "c "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "d "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "e "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   " "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  Token  nextToken  (  Token  tkn  )  throws  IOException  {    int  lastChar  =  in  .  readAgain  (  )  ;              int  c  =  in  .  read  (  )  ;  boolean  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;      if  (  emptyLinesIgnored  )  {  while  (  eol  &&  (  lastChar  =  =  '\n'  ||  lastChar  =  =  '\r'  ||  lastChar  =  =  ExtendedBufferedReader  .  UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {    lastChar  =  c  ;  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;    if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }  }  }    if  (  isEndOfFile  (  lastChar  )  ||  (  !isDelimiter  (  lastChar  )  &&  isEndOfFile  (  c  )  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }    while  (  tkn  .  type  =  =  INVALID  )  {    if  (  surroundingSpacesIgnored  )  {  while  (  isWhitespace  (  c  )  &&  !eol  )  {  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  }  }    if  (  isCommentStart  (  c  )  )  {    in  .  readLine  (  )  ;  tkn  =  nextToken  (  tkn  .  reset  (  )  )  ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  [ATTENTION]  }if  (  eol  )  {      tkn  .  type  =  EORECORD  ;  }  else  if  (  isEncapsulator  (  c  )  )  {    encapsulatedTokenLexer  (  tkn  ,  c  )  ;  }  else  if  (  isEndOfFile  (  c  )  )  {      tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  there  is  data  at  EOF  }  else  {      simpleTokenLexer  (  tkn  ,  c  )  ;  }  }  return  tkn  ;  }    [METHOD]  nextToken  [TYPE]  Token  [PARAMETER]  Token  tkn  [CLASS]  CSVLexer    [TYPE]  boolean  eol  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  lastChar  
[REPLACE]  }  else  if  (  isEncapsulator  (  c  )  )  {	[BUGGY]    if  (  isEncapsulator  (  c  )  )  {[FE]  AssertionFailedError    Token  type  expected:<EORECORD>  but  was:<TOKEN>  assertTokenEquals(TOKEN  ,   "1 "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "2 "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "3 "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   " "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "b  x "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "c "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "d "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "e "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   " "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  Token  nextToken  (  Token  tkn  )  throws  IOException  {    int  lastChar  =  in  .  readAgain  (  )  ;              int  c  =  in  .  read  (  )  ;  boolean  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;      if  (  emptyLinesIgnored  )  {  while  (  eol  &&  (  lastChar  =  =  '\n'  ||  lastChar  =  =  '\r'  ||  lastChar  =  =  ExtendedBufferedReader  .  UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {    lastChar  =  c  ;  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;    if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }  }  }    if  (  isEndOfFile  (  lastChar  )  ||  (  !isDelimiter  (  lastChar  )  &&  isEndOfFile  (  c  )  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }    while  (  tkn  .  type  =  =  INVALID  )  {    if  (  surroundingSpacesIgnored  )  {  while  (  isWhitespace  (  c  )  &&  !eol  )  {  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  }  }    if  (  isCommentStart  (  c  )  )  {    in  .  readLine  (  )  ;  tkn  =  nextToken  (  tkn  .  reset  (  )  )  ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  }  else  if  (  eol  )  {      tkn  .  type  =  EORECORD  ;  [ATTENTION]  }if  (  isEncapsulator  (  c  )  )  {    encapsulatedTokenLexer  (  tkn  ,  c  )  ;  }  else  if  (  isEndOfFile  (  c  )  )  {      tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  there  is  data  at  EOF  }  else  {      simpleTokenLexer  (  tkn  ,  c  )  ;  }  }  return  tkn  ;  }    [METHOD]  nextToken  [TYPE]  Token  [PARAMETER]  Token  tkn  [CLASS]  CSVLexer    [TYPE]  boolean  eol  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  lastChar  
[ADD]  else  if  (  isEncapsulator  (  c  )  )  {  encapsulatedTokenLexer  (  tkn,  c  )  ;  }  else  if  (  isEndOfFile  (  c  )  )  {	[BUGGY]    encapsulatedTokenLexer  (  tkn  ,  c  )  ;  [CE]  'else'  without  'if'  [CONTEXT]  Token  nextToken  (  Token  tkn  )  throws  IOException  {    int  lastChar  =  in  .  readAgain  (  )  ;              int  c  =  in  .  read  (  )  ;  boolean  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;      if  (  emptyLinesIgnored  )  {  while  (  eol  &&  (  lastChar  =  =  '\n'  ||  lastChar  =  =  '\r'  ||  lastChar  =  =  ExtendedBufferedReader  .  UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {    lastChar  =  c  ;  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;    if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }  }  }    if  (  isEndOfFile  (  lastChar  )  ||  (  !isDelimiter  (  lastChar  )  &&  isEndOfFile  (  c  )  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }    while  (  tkn  .  type  =  =  INVALID  )  {    if  (  surroundingSpacesIgnored  )  {  while  (  isWhitespace  (  c  )  &&  !eol  )  {  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  }  }    if  (  isCommentStart  (  c  )  )  {    in  .  readLine  (  )  ;  tkn  =  nextToken  (  tkn  .  reset  (  )  )  ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  }  else  if  (  eol  )  {      tkn  .  type  =  EORECORD  ;  [ATTENTION]  }  encapsulatedTokenLexer  (  tkn  ,  c  )    ;          tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  there  is  data  at  EOF  }  else  {      simpleTokenLexer  (  tkn  ,  c  )  ;  }  }  return  tkn  ;  }    [METHOD]  nextToken  [TYPE]  Token  [PARAMETER]  Token  tkn  [CLASS]  CSVLexer    [TYPE]  boolean  eol  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  lastChar  
[REPLACE]  }  else  if  (  isEndOfFile  (  c  )  )  {	[BUGGY]    else  {[CE]  'else'  without  'if'  [CONTEXT]  Token  nextToken  (  Token  tkn  )  throws  IOException  {    int  lastChar  =  in  .  readAgain  (  )  ;              int  c  =  in  .  read  (  )  ;  boolean  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;      if  (  emptyLinesIgnored  )  {  while  (  eol  &&  (  lastChar  =  =  '\n'  ||  lastChar  =  =  '\r'  ||  lastChar  =  =  ExtendedBufferedReader  .  UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {    lastChar  =  c  ;  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;    if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }  }  }    if  (  isEndOfFile  (  lastChar  )  ||  (  !isDelimiter  (  lastChar  )  &&  isEndOfFile  (  c  )  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }    while  (  tkn  .  type  =  =  INVALID  )  {    if  (  surroundingSpacesIgnored  )  {  while  (  isWhitespace  (  c  )  &&  !eol  )  {  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  }  }    if  (  isCommentStart  (  c  )  )  {    in  .  readLine  (  )  ;  tkn  =  nextToken  (  tkn  .  reset  (  )  )  ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  }  else  if  (  eol  )  {      tkn  .  type  =  EORECORD  ;  }  else  if  (  isEncapsulator  (  c  )  )  {    encapsulatedTokenLexer  (  tkn  ,  c  )  ;  [ATTENTION]  }else  {      tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  there  is  data  at  EOF  }  else  {      simpleTokenLexer  (  tkn  ,  c  )  ;  }  }  return  tkn  ;  }    [METHOD]  nextToken  [TYPE]  Token  [PARAMETER]  Token  tkn  [CLASS]  CSVLexer    [TYPE]  boolean  eol  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  lastChar  
[ADD]  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF;  tkn  .  isReady  =  true;	[BUGGY]    tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  [CE]  'else'  without  'if'  [CONTEXT]  Token  nextToken  (  Token  tkn  )  throws  IOException  {    int  lastChar  =  in  .  readAgain  (  )  ;              int  c  =  in  .  read  (  )  ;  boolean  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;      if  (  emptyLinesIgnored  )  {  while  (  eol  &&  (  lastChar  =  =  '\n'  ||  lastChar  =  =  '\r'  ||  lastChar  =  =  ExtendedBufferedReader  .  UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {    lastChar  =  c  ;  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;    if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }  }  }    if  (  isEndOfFile  (  lastChar  )  ||  (  !isDelimiter  (  lastChar  )  &&  isEndOfFile  (  c  )  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }    while  (  tkn  .  type  =  =  INVALID  )  {    if  (  surroundingSpacesIgnored  )  {  while  (  isWhitespace  (  c  )  &&  !eol  )  {  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  }  }    if  (  isCommentStart  (  c  )  )  {    in  .  readLine  (  )  ;  tkn  =  nextToken  (  tkn  .  reset  (  )  )  ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  }  else  if  (  eol  )  {      tkn  .  type  =  EORECORD  ;  }  else  if  (  isEncapsulator  (  c  )  )  {    encapsulatedTokenLexer  (  tkn  ,  c  )  ;  [ATTENTION]  }  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;        }  else  {      simpleTokenLexer  (  tkn  ,  c  )  ;  }  }  return  tkn  ;  }    [METHOD]  nextToken  [TYPE]  Token  [PARAMETER]  Token  tkn  [CLASS]  CSVLexer    [TYPE]  boolean  eol  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  lastChar  
[REPLACE]  simpleTokenLexer  (  tkn,  c  )  ;	[BUGGY]  tkn  =  nextToken  (  tkn  .  reset  (  )  )  ;  [FE]  AssertionFailedError    Token  content  expected:<[abc]>  but  was:<[]>  assertTokenEquals(TOKEN  ,   "abc "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "def "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "hijk "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "lmnop "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "qrst "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "uv "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "wxy "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "z "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   " "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   " "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  }  else  if  (  isEndOfFile  (  c  )  )  {      tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  there  is  data  at  EOF  }  else  {      [ATTENTION]  tkn  =  nextToken  (  tkn  .  reset  (  )  )    ;  }    [METHOD]  nextToken  [TYPE]  Token  [PARAMETER]  Token  tkn  [CLASS]  CSVLexer    [TYPE]  boolean  eol  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  lastChar  
[ADD]  simpleTokenLexer  (  tkn,  c  )  ;	[BUGGY]  [FE]  [CONTEXT]  }  else  if  (  isEndOfFile  (  c  )  )  {      tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  there  is  data  at  EOF  }  else  {      [ATTENTION]  }    [METHOD]  nextToken  [TYPE]  Token  [PARAMETER]  Token  tkn  [CLASS]  CSVLexer    [TYPE]  boolean  eol  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  lastChar  
[REPLACE]  tkn  .  type  =  EOF;	[BUGGY]  tkn  .  type  =  TOKEN  ;    ;  [FE]  AssertionFailedError    Token  type  expected:<EOF>  but  was:<TOKEN>  assertTokenEquals(TOKEN  ,   "abc "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "def "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "hijk "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "lmnop "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "qrst "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "uv "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "wxy "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "z "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   " "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   " "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  Token  nextToken  (  Token  tkn  )  throws  IOException  {    int  lastChar  =  in  .  readAgain  (  )  ;              int  c  =  in  .  read  (  )  ;  boolean  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;      if  (  emptyLinesIgnored  )  {  while  (  eol  &&  (  lastChar  =  =  '\n'  ||  lastChar  =  =  '\r'  ||  lastChar  =  =  ExtendedBufferedReader  .  UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {    lastChar  =  c  ;  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;    if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }  }  }    if  (  isEndOfFile  (  lastChar  )  ||  (  !isDelimiter  (  lastChar  )  &&  isEndOfFile  (  c  )  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }    while  (  tkn  .  type  =  =  INVALID  )  {    if  (  surroundingSpacesIgnored  )  {  while  (  isWhitespace  (  c  )  &&  !eol  )  {  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  }  }    if  (  isCommentStart  (  c  )  )  {    in  .  readLine  (  )  ;  tkn  =  nextToken  (  tkn  .  reset  (  )  )  ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  }  else  if  (  eol  )  {      tkn  .  type  =  EORECORD  ;  }  else  if  (  isEncapsulator  (  c  )  )  {    encapsulatedTokenLexer  (  tkn  ,  c  )  ;  }  else  if  (  isEndOfFile  (  c  )  )  {      [ATTENTION]  tkn  .  type  =  TOKEN  ;    ;  tkn  .  isReady  =  true  ;  //  there  is  data  at  EOF  }  else  {      simpleTokenLexer  (  tkn  ,  c  )  ;  }  }  return  tkn  ;  }    [METHOD]  nextToken  [TYPE]  Token  [PARAMETER]  Token  tkn  [CLASS]  CSVLexer    [TYPE]  boolean  eol  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  lastChar  
[REPLACE]  tkn  .  isReady  =  true;	[BUGGY]  tkn  .  isReady  =  false  ;  [FE]  array  lengths  differed  ,  expected.length  =  2  actual.length  =  1  assertEquals(res.length  ,  records.size())  ;  assertTrue(records.size()  >  0)  ;  assertArrayEquals(res[i]  ,  records.get(i).values())  ;  [CONTEXT]  Token  nextToken  (  Token  tkn  )  throws  IOException  {    int  lastChar  =  in  .  readAgain  (  )  ;              int  c  =  in  .  read  (  )  ;  boolean  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;      if  (  emptyLinesIgnored  )  {  while  (  eol  &&  (  lastChar  =  =  '\n'  ||  lastChar  =  =  '\r'  ||  lastChar  =  =  ExtendedBufferedReader  .  UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {    lastChar  =  c  ;  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;    if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }  }  }    if  (  isEndOfFile  (  lastChar  )  ||  (  !isDelimiter  (  lastChar  )  &&  isEndOfFile  (  c  )  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }    while  (  tkn  .  type  =  =  INVALID  )  {    if  (  surroundingSpacesIgnored  )  {  while  (  isWhitespace  (  c  )  &&  !eol  )  {  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  }  }    if  (  isCommentStart  (  c  )  )  {    in  .  readLine  (  )  ;  tkn  =  nextToken  (  tkn  .  reset  (  )  )  ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  }  else  if  (  eol  )  {      tkn  .  type  =  EORECORD  ;  }  else  if  (  isEncapsulator  (  c  )  )  {    encapsulatedTokenLexer  (  tkn  ,  c  )  ;  }  else  if  (  isEndOfFile  (  c  )  )  {      tkn  .  type  =  EOF  ;  [ATTENTION]  tkn  .  isReady  =  false  ;  }  else  {      simpleTokenLexer  (  tkn  ,  c  )  ;  }  }  return  tkn  ;  }    [METHOD]  nextToken  [TYPE]  Token  [PARAMETER]  Token  tkn  [CLASS]  CSVLexer    [TYPE]  boolean  eol  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  lastChar  
[ADD]  tkn  .  isReady  =  true;	[BUGGY]  [FE]  array  lengths  differed  ,  expected.length  =  2  actual.length  =  1  assertEquals(res.length  ,  records.size())  ;  assertTrue(records.size()  >  0)  ;  assertArrayEquals(res[i]  ,  records.get(i).values())  ;  [CONTEXT]  Token  nextToken  (  Token  tkn  )  throws  IOException  {    int  lastChar  =  in  .  readAgain  (  )  ;              int  c  =  in  .  read  (  )  ;  boolean  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;      if  (  emptyLinesIgnored  )  {  while  (  eol  &&  (  lastChar  =  =  '\n'  ||  lastChar  =  =  '\r'  ||  lastChar  =  =  ExtendedBufferedReader  .  UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {    lastChar  =  c  ;  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;    if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }  }  }    if  (  isEndOfFile  (  lastChar  )  ||  (  !isDelimiter  (  lastChar  )  &&  isEndOfFile  (  c  )  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }    while  (  tkn  .  type  =  =  INVALID  )  {    if  (  surroundingSpacesIgnored  )  {  while  (  isWhitespace  (  c  )  &&  !eol  )  {  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  }  }    if  (  isCommentStart  (  c  )  )  {    in  .  readLine  (  )  ;  tkn  =  nextToken  (  tkn  .  reset  (  )  )  ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  }  else  if  (  eol  )  {      tkn  .  type  =  EORECORD  ;  }  else  if  (  isEncapsulator  (  c  )  )  {    encapsulatedTokenLexer  (  tkn  ,  c  )  ;  }  else  if  (  isEndOfFile  (  c  )  )  {      tkn  .  type  =  EOF  ;  [ATTENTION]  }  else  {      simpleTokenLexer  (  tkn  ,  c  )  ;  }  }  return  tkn  ;  }    [METHOD]  nextToken  [TYPE]  Token  [PARAMETER]  Token  tkn  [CLASS]  CSVLexer    [TYPE]  boolean  eol  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  lastChar  
[REPLACE]  encapsulatedTokenLexer  (  tkn,  c  )  ;	[BUGGY]  encapsulatedTokenLexer  (  tkn  ,  lastChar  )  ;  [NO-ERROR]  [CONTEXT]  Token  nextToken  (  Token  tkn  )  throws  IOException  {    int  lastChar  =  in  .  readAgain  (  )  ;              int  c  =  in  .  read  (  )  ;  boolean  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;      if  (  emptyLinesIgnored  )  {  while  (  eol  &&  (  lastChar  =  =  '\n'  ||  lastChar  =  =  '\r'  ||  lastChar  =  =  ExtendedBufferedReader  .  UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {    lastChar  =  c  ;  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;    if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }  }  }    if  (  isEndOfFile  (  lastChar  )  ||  (  !isDelimiter  (  lastChar  )  &&  isEndOfFile  (  c  )  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }    while  (  tkn  .  type  =  =  INVALID  )  {    if  (  surroundingSpacesIgnored  )  {  while  (  isWhitespace  (  c  )  &&  !eol  )  {  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  }  }    if  (  isCommentStart  (  c  )  )  {    in  .  readLine  (  )  ;  tkn  =  nextToken  (  tkn  .  reset  (  )  )  ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  }  else  if  (  eol  )  {      tkn  .  type  =  EORECORD  ;  }  else  if  (  isEncapsulator  (  c  )  )  {    [ATTENTION]  encapsulatedTokenLexer  (  tkn  ,  lastChar  )    ;  }  else  if  (  isEndOfFile  (  c  )  )  {      tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  there  is  data  at  EOF  }  else  {      simpleTokenLexer  (  tkn  ,  c  )  ;  }  }  return  tkn  ;  }    [METHOD]  nextToken  [TYPE]  Token  [PARAMETER]  Token  tkn  [CLASS]  CSVLexer    [TYPE]  boolean  eol  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  lastChar  
[REMOVE]  	[BUGGY]  if  (  isEncapsulator  (  c  )  )  {      encapsulatedTokenLexer  (  tkn  ,  c  )  ;  }else      if  (  isEndOfFile  (  c  )  )  {          tkn  .  type  =  EOF  ;          tkn  .  isReady  =  true  ;      }else  {          simpleTokenLexer  (  tkn  ,  c  )  ;      }[NO-ERROR]  [CONTEXT]  Token  nextToken  (  Token  tkn  )  throws  IOException  {    int  lastChar  =  in  .  readAgain  (  )  ;              int  c  =  in  .  read  (  )  ;  boolean  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;      if  (  emptyLinesIgnored  )  {  while  (  eol  &&  (  lastChar  =  =  '\n'  ||  lastChar  =  =  '\r'  ||  lastChar  =  =  ExtendedBufferedReader  .  UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {    lastChar  =  c  ;  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;    if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }  }  }    if  (  isEndOfFile  (  lastChar  )  ||  (  !isDelimiter  (  lastChar  )  &&  isEndOfFile  (  c  )  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }    while  (  tkn  .  type  =  =  INVALID  )  {    if  (  surroundingSpacesIgnored  )  {  while  (  isWhitespace  (  c  )  &&  !eol  )  {  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  }  }    if  (  isCommentStart  (  c  )  )  {    in  .  readLine  (  )  ;  tkn  =  nextToken  (  tkn  .  reset  (  )  )  ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  }  else  if  (  eol  )  {      tkn  .  type  =  EORECORD  ;  }  else  if  (  isEncapsulator  (  c  )  )  {    encapsulatedTokenLexer  (  tkn  ,  c  )  ;  [ATTENTION]  }  else  if  (  isEndOfFile  (  c  )  )  {  if  (  isEncapsulator  (  c  )  )  {  encapsulatedTokenLexer  (  tkn  ,  c  )    ;  }else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  }else  {  simpleTokenLexer  (  tkn  ,  c  )    ;  }//  end  of  file  return  EOF  (  )    tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  there  is  data  at  EOF  }  else  {      simpleTokenLexer  (  tkn  ,  c  )  ;  }  }  return  tkn  ;      [METHOD]  nextToken  [TYPE]  Token  [PARAMETER]  Token  tkn  [CLASS]  CSVLexer    [TYPE]  boolean  eol  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  lastChar  
[REPLACE]  simpleTokenLexer  (  tkn,  c  )  ;	[BUGGY]  simpleTokenLexer  (  tkn  ,  lastChar  )  ;  [FE]  AssertionFailedError    Token  content  expected:<[a]bc>  but  was:<[  assertTokenEquals(TOKEN  ,   "abc "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "def "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "hijk "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "lmnop "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "qrst "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "uv "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "wxy "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "z "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   " "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   " "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  }  else  if  (  isEndOfFile  (  c  )  )  {      tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  there  is  data  at  EOF  }  else  {      [ATTENTION]  simpleTokenLexer  (  tkn  ,  lastChar  )    ;  }    [METHOD]  nextToken  [TYPE]  Token  [PARAMETER]  Token  tkn  [CLASS]  CSVLexer    [TYPE]  boolean  eol  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  lastChar  
[REPLACE]  tkn  .  type  =  EORECORD;	[BUGGY]  tkn  .  type    =  null  ;  [FE]  AssertionFailedError    Token  type  expected:<EORECORD>  but  was:<null>  assertTokenEquals(TOKEN  ,   "1 "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "2 "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "3 "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   " "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "b  x "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "c "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "d "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "e "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   " "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  Token  nextToken  (  Token  tkn  )  throws  IOException  {    int  lastChar  =  in  .  readAgain  (  )  ;              int  c  =  in  .  read  (  )  ;  boolean  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;      if  (  emptyLinesIgnored  )  {  while  (  eol  &&  (  lastChar  =  =  '\n'  ||  lastChar  =  =  '\r'  ||  lastChar  =  =  ExtendedBufferedReader  .  UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {    lastChar  =  c  ;  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;    if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }  }  }    if  (  isEndOfFile  (  lastChar  )  ||  (  !isDelimiter  (  lastChar  )  &&  isEndOfFile  (  c  )  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }    while  (  tkn  .  type  =  =  INVALID  )  {    if  (  surroundingSpacesIgnored  )  {  while  (  isWhitespace  (  c  )  &&  !eol  )  {  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  }  }    if  (  isCommentStart  (  c  )  )  {    in  .  readLine  (  )  ;  tkn  =  nextToken  (  tkn  .  reset  (  )  )  ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  }  else  if  (  eol  )  {      [ATTENTION]  tkn  .  type  =  null  ;  }  else  if  (  isEncapsulator  (  c  )  )  {    encapsulatedTokenLexer  (  tkn  ,  c  )  ;  }  else  if  (  isEndOfFile  (  c  )  )  {      tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  there  is  data  at  EOF  }  else  {      simpleTokenLexer  (  tkn  ,  c  )  ;  }  }  return  tkn  ;  }    [METHOD]  nextToken  [TYPE]  Token  [PARAMETER]  Token  tkn  [CLASS]  CSVLexer    [TYPE]  boolean  eol  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  lastChar  
[REPLACE]  }  else  if  (  isEncapsulator  (  c  )  )  {	[BUGGY]    else  {[CE]  'else'  without  'if'  [CONTEXT]  Token  nextToken  (  Token  tkn  )  throws  IOException  {    int  lastChar  =  in  .  readAgain  (  )  ;              int  c  =  in  .  read  (  )  ;  boolean  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;      if  (  emptyLinesIgnored  )  {  while  (  eol  &&  (  lastChar  =  =  '\n'  ||  lastChar  =  =  '\r'  ||  lastChar  =  =  ExtendedBufferedReader  .  UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {    lastChar  =  c  ;  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;    if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }  }  }    if  (  isEndOfFile  (  lastChar  )  ||  (  !isDelimiter  (  lastChar  )  &&  isEndOfFile  (  c  )  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }    while  (  tkn  .  type  =  =  INVALID  )  {    if  (  surroundingSpacesIgnored  )  {  while  (  isWhitespace  (  c  )  &&  !eol  )  {  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  }  }    if  (  isCommentStart  (  c  )  )  {    in  .  readLine  (  )  ;  tkn  =  nextToken  (  tkn  .  reset  (  )  )  ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  }  else  if  (  eol  )  {      tkn  .  type  =  EORECORD  ;  [ATTENTION]  }else  {    encapsulatedTokenLexer  (  tkn  ,  c  )  ;  }  else  if  (  isEndOfFile  (  c  )  )  {      tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  there  is  data  at  EOF  }  else  {      simpleTokenLexer  (  tkn  ,  c  )  ;  }  }  return  tkn  ;  }    [METHOD]  nextToken  [TYPE]  Token  [PARAMETER]  Token  tkn  [CLASS]  CSVLexer    [TYPE]  boolean  eol  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  lastChar  
[ADD]  tkn  .  type  =  EOF;	[BUGGY]  [FE]  [CONTEXT]  Token  nextToken  (  Token  tkn  )  throws  IOException  {    int  lastChar  =  in  .  readAgain  (  )  ;              int  c  =  in  .  read  (  )  ;  boolean  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;      if  (  emptyLinesIgnored  )  {  while  (  eol  &&  (  lastChar  =  =  '\n'  ||  lastChar  =  =  '\r'  ||  lastChar  =  =  ExtendedBufferedReader  .  UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {    lastChar  =  c  ;  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;    if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }  }  }    if  (  isEndOfFile  (  lastChar  )  ||  (  !isDelimiter  (  lastChar  )  &&  isEndOfFile  (  c  )  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }    while  (  tkn  .  type  =  =  INVALID  )  {    if  (  surroundingSpacesIgnored  )  {  while  (  isWhitespace  (  c  )  &&  !eol  )  {  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  }  }    if  (  isCommentStart  (  c  )  )  {    in  .  readLine  (  )  ;  tkn  =  nextToken  (  tkn  .  reset  (  )  )  ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  }  else  if  (  eol  )  {      tkn  .  type  =  EORECORD  ;  }  else  if  (  isEncapsulator  (  c  )  )  {    encapsulatedTokenLexer  (  tkn  ,  c  )  ;  }  else  if  (  isEndOfFile  (  c  )  )  {      [ATTENTION]  tkn  .  isReady  =  true  ;  //  there  is  data  at  EOF  }  else  {      simpleTokenLexer  (  tkn  ,  c  )  ;  }  }  return  tkn  ;  }    [METHOD]  nextToken  [TYPE]  Token  [PARAMETER]  Token  tkn  [CLASS]  CSVLexer    [TYPE]  boolean  eol  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  lastChar  
[REPLACE]  encapsulatedTokenLexer  (  tkn,  c  )  ;	[BUGGY]  if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {[CE]  illegal  start  of  expression  [CONTEXT]  Token  nextToken  (  Token  tkn  )  throws  IOException  {    int  lastChar  =  in  .  readAgain  (  )  ;              int  c  =  in  .  read  (  )  ;  boolean  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;      if  (  emptyLinesIgnored  )  {  while  (  eol  &&  (  lastChar  =  =  '\n'  ||  lastChar  =  =  '\r'  ||  lastChar  =  =  ExtendedBufferedReader  .  UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {    lastChar  =  c  ;  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;    if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }  }  }    if  (  isEndOfFile  (  lastChar  )  ||  (  !isDelimiter  (  lastChar  )  &&  isEndOfFile  (  c  )  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }    while  (  tkn  .  type  =  =  INVALID  )  {    if  (  surroundingSpacesIgnored  )  {  while  (  isWhitespace  (  c  )  &&  !eol  )  {  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  }  }    if  (  isCommentStart  (  c  )  )  {    in  .  readLine  (  )  ;  tkn  =  nextToken  (  tkn  .  reset  (  )  )  ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  }  else  if  (  eol  )  {      tkn  .  type  =  EORECORD  ;  }  else  if  (  isEncapsulator  (  c  )  )  {    [ATTENTION]  if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {  }  else  if  (  isEndOfFile  (  c  )  )  {      tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  there  is  data  at  EOF  }  else  {      simpleTokenLexer  (  tkn  ,  c  )  ;  }  }  return  tkn  ;  }    [METHOD]  nextToken  [TYPE]  Token  [PARAMETER]  Token  tkn  [CLASS]  CSVLexer    [TYPE]  boolean  eol  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  lastChar  
[ADD]  encapsulatedTokenLexer  (  tkn,  c  )  ;	[BUGGY]  [FE]  [CONTEXT]  Token  nextToken  (  Token  tkn  )  throws  IOException  {    int  lastChar  =  in  .  readAgain  (  )  ;              int  c  =  in  .  read  (  )  ;  boolean  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;      if  (  emptyLinesIgnored  )  {  while  (  eol  &&  (  lastChar  =  =  '\n'  ||  lastChar  =  =  '\r'  ||  lastChar  =  =  ExtendedBufferedReader  .  UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {    lastChar  =  c  ;  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;    if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }  }  }    if  (  isEndOfFile  (  lastChar  )  ||  (  !isDelimiter  (  lastChar  )  &&  isEndOfFile  (  c  )  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }    while  (  tkn  .  type  =  =  INVALID  )  {    if  (  surroundingSpacesIgnored  )  {  while  (  isWhitespace  (  c  )  &&  !eol  )  {  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  }  }    if  (  isCommentStart  (  c  )  )  {    in  .  readLine  (  )  ;  tkn  =  nextToken  (  tkn  .  reset  (  )  )  ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  }  else  if  (  eol  )  {      tkn  .  type  =  EORECORD  ;  }  else  if  (  isEncapsulator  (  c  )  )  {    [ATTENTION]  }  else  if  (  isEndOfFile  (  c  )  )  {      tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  there  is  data  at  EOF  }  else  {      simpleTokenLexer  (  tkn  ,  c  )  ;  }  }  return  tkn  ;  }    [METHOD]  nextToken  [TYPE]  Token  [PARAMETER]  Token  tkn  [CLASS]  CSVLexer    [TYPE]  boolean  eol  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  lastChar  
[REPLACE]  }  else  if  (  isEndOfFile  (  c  )  )  {	[BUGGY]    if  (  isEndOfFile  (  lastChar  )  )  {[FE]  AssertionFailedError    Token  type  expected:<EORECORD>  but  was:<TOKEN>  assertTokenEquals(TOKEN  ,   "1 "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "2 "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "3 "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   " "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "b  x "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "c "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "d "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "e "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   " "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  Token  nextToken  (  Token  tkn  )  throws  IOException  {    int  lastChar  =  in  .  readAgain  (  )  ;              int  c  =  in  .  read  (  )  ;  boolean  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;      if  (  emptyLinesIgnored  )  {  while  (  eol  &&  (  lastChar  =  =  '\n'  ||  lastChar  =  =  '\r'  ||  lastChar  =  =  ExtendedBufferedReader  .  UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {    lastChar  =  c  ;  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;    if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }  }  }    if  (  isEndOfFile  (  lastChar  )  ||  (  !isDelimiter  (  lastChar  )  &&  isEndOfFile  (  c  )  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }    while  (  tkn  .  type  =  =  INVALID  )  {    if  (  surroundingSpacesIgnored  )  {  while  (  isWhitespace  (  c  )  &&  !eol  )  {  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  }  }    if  (  isCommentStart  (  c  )  )  {    in  .  readLine  (  )  ;  tkn  =  nextToken  (  tkn  .  reset  (  )  )  ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  }  else  if  (  eol  )  {      tkn  .  type  =  EORECORD  ;  }  else  if  (  isEncapsulator  (  c  )  )  {    encapsulatedTokenLexer  (  tkn  ,  c  )  ;  [ATTENTION]  }if  (  isEndOfFile  (  lastChar  )  )  {      tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  there  is  data  at  EOF  }  else  {      simpleTokenLexer  (  tkn  ,  c  )  ;  }  }  return  tkn  ;  }    [METHOD]  nextToken  [TYPE]  Token  [PARAMETER]  Token  tkn  [CLASS]  CSVLexer    [TYPE]  boolean  eol  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  lastChar  
[ADD]  tkn  .  type  =  EOF;  tkn  .  isReady  =  true;	[BUGGY]  [FE]  [CONTEXT]  Token  nextToken  (  Token  tkn  )  throws  IOException  {    int  lastChar  =  in  .  readAgain  (  )  ;              int  c  =  in  .  read  (  )  ;  boolean  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;      if  (  emptyLinesIgnored  )  {  while  (  eol  &&  (  lastChar  =  =  '\n'  ||  lastChar  =  =  '\r'  ||  lastChar  =  =  ExtendedBufferedReader  .  UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {    lastChar  =  c  ;  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;    if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }  }  }    if  (  isEndOfFile  (  lastChar  )  ||  (  !isDelimiter  (  lastChar  )  &&  isEndOfFile  (  c  )  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }    while  (  tkn  .  type  =  =  INVALID  )  {    if  (  surroundingSpacesIgnored  )  {  while  (  isWhitespace  (  c  )  &&  !eol  )  {  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  }  }    if  (  isCommentStart  (  c  )  )  {    in  .  readLine  (  )  ;  tkn  =  nextToken  (  tkn  .  reset  (  )  )  ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  }  else  if  (  eol  )  {      tkn  .  type  =  EORECORD  ;  }  else  if  (  isEncapsulator  (  c  )  )  {    encapsulatedTokenLexer  (  tkn  ,  c  )  ;  }  else  if  (  isEndOfFile  (  c  )  )  {      [ATTENTION]    }  else  {      simpleTokenLexer  (  tkn  ,  c  )  ;  }  }  return  tkn  ;  }    [METHOD]  nextToken  [TYPE]  Token  [PARAMETER]  Token  tkn  [CLASS]  CSVLexer    [TYPE]  boolean  eol  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  lastChar  
[REPLACE]  tkn  .  type  =  TOKEN;	[BUGGY]  tkn  .  type  =  EOF  ;    ;  [FE]  AssertionFailedError    Token  type  expected:<TOKEN>  but  was:<EOF>  assertTokenEquals(TOKEN  ,   "abc "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "def "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "hijk "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "lmnop "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "qrst "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "uv "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "wxy "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "z "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   " "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   " "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  Token  nextToken  (  Token  tkn  )  throws  IOException  {    int  lastChar  =  in  .  readAgain  (  )  ;              int  c  =  in  .  read  (  )  ;  boolean  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;      if  (  emptyLinesIgnored  )  {  while  (  eol  &&  (  lastChar  =  =  '\n'  ||  lastChar  =  =  '\r'  ||  lastChar  =  =  ExtendedBufferedReader  .  UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {    lastChar  =  c  ;  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;    if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }  }  }    if  (  isEndOfFile  (  lastChar  )  ||  (  !isDelimiter  (  lastChar  )  &&  isEndOfFile  (  c  )  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }    while  (  tkn  .  type  =  =  INVALID  )  {    if  (  surroundingSpacesIgnored  )  {  while  (  isWhitespace  (  c  )  &&  !eol  )  {  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  }  }    if  (  isCommentStart  (  c  )  )  {    in  .  readLine  (  )  ;  tkn  =  nextToken  (  tkn  .  reset  (  )  )  ;  }  else  if  (  isDelimiter  (  c  )  )  {    [ATTENTION]  tkn  .  type  =  EOF  ;    ;  }  else  if  (  eol  )  {      tkn  .  type  =  EORECORD  ;  }  else  if  (  isEncapsulator  (  c  )  )  {    encapsulatedTokenLexer  (  tkn  ,  c  )  ;  }  else  if  (  isEndOfFile  (  c  )  )  {      tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  there  is  data  at  EOF  }  else  {      simpleTokenLexer  (  tkn  ,  c  )  ;  }  }  return  tkn  ;  }    [METHOD]  nextToken  [TYPE]  Token  [PARAMETER]  Token  tkn  [CLASS]  CSVLexer    [TYPE]  boolean  eol  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  lastChar  
[REPLACE]  }  else  if  (  eol  )  {	[BUGGY]    else  {[CE]  'else'  without  'if'  [CONTEXT]  Token  nextToken  (  Token  tkn  )  throws  IOException  {    int  lastChar  =  in  .  readAgain  (  )  ;              int  c  =  in  .  read  (  )  ;  boolean  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;      if  (  emptyLinesIgnored  )  {  while  (  eol  &&  (  lastChar  =  =  '\n'  ||  lastChar  =  =  '\r'  ||  lastChar  =  =  ExtendedBufferedReader  .  UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {    lastChar  =  c  ;  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;    if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }  }  }    if  (  isEndOfFile  (  lastChar  )  ||  (  !isDelimiter  (  lastChar  )  &&  isEndOfFile  (  c  )  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }    while  (  tkn  .  type  =  =  INVALID  )  {    if  (  surroundingSpacesIgnored  )  {  while  (  isWhitespace  (  c  )  &&  !eol  )  {  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  }  }    if  (  isCommentStart  (  c  )  )  {    in  .  readLine  (  )  ;  tkn  =  nextToken  (  tkn  .  reset  (  )  )  ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  [ATTENTION]  }else  {      tkn  .  type  =  EORECORD  ;  }  else  if  (  isEncapsulator  (  c  )  )  {    encapsulatedTokenLexer  (  tkn  ,  c  )  ;  }  else  if  (  isEndOfFile  (  c  )  )  {      tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  there  is  data  at  EOF  }  else  {      simpleTokenLexer  (  tkn  ,  c  )  ;  }  }  return  tkn  ;  }    [METHOD]  nextToken  [TYPE]  Token  [PARAMETER]  Token  tkn  [CLASS]  CSVLexer    [TYPE]  boolean  eol  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  lastChar  
[REPLACE]  }  else  if  (  isEncapsulator  (  c  )  )  {	[BUGGY]    if  (  isEncapsulator  (  lastChar  )  )  {[FE]  AssertionFailedError    Token  type  expected:<EORECORD>  but  was:<TOKEN>  assertTokenEquals(TOKEN  ,   "1 "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "2 "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "3 "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   " "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "b  x "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "c "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "d "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "e "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   " "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  Token  nextToken  (  Token  tkn  )  throws  IOException  {    int  lastChar  =  in  .  readAgain  (  )  ;              int  c  =  in  .  read  (  )  ;  boolean  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;      if  (  emptyLinesIgnored  )  {  while  (  eol  &&  (  lastChar  =  =  '\n'  ||  lastChar  =  =  '\r'  ||  lastChar  =  =  ExtendedBufferedReader  .  UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {    lastChar  =  c  ;  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;    if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }  }  }    if  (  isEndOfFile  (  lastChar  )  ||  (  !isDelimiter  (  lastChar  )  &&  isEndOfFile  (  c  )  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }    while  (  tkn  .  type  =  =  INVALID  )  {    if  (  surroundingSpacesIgnored  )  {  while  (  isWhitespace  (  c  )  &&  !eol  )  {  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  }  }    if  (  isCommentStart  (  c  )  )  {    in  .  readLine  (  )  ;  tkn  =  nextToken  (  tkn  .  reset  (  )  )  ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  }  else  if  (  eol  )  {      tkn  .  type  =  EORECORD  ;  [ATTENTION]  }if  (  isEncapsulator  (  lastChar  )  )  {    encapsulatedTokenLexer  (  tkn  ,  c  )  ;  }  else  if  (  isEndOfFile  (  c  )  )  {      tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  there  is  data  at  EOF  }  else  {      simpleTokenLexer  (  tkn  ,  c  )  ;  }  }  return  tkn  ;  }    [METHOD]  nextToken  [TYPE]  Token  [PARAMETER]  Token  tkn  [CLASS]  CSVLexer    [TYPE]  boolean  eol  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  lastChar  
[REPLACE]  }  else  if  (  isEndOfFile  (  c  )  )  {	[BUGGY]    if  (  isEndOfFile  (  c  )  )  {[FE]  AssertionFailedError    Token  type  expected:<EORECORD>  but  was:<TOKEN>  assertTokenEquals(TOKEN  ,   "1 "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "2 "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "3 "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   " "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "b  x "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "c "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "d "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "e "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   " "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  Token  nextToken  (  Token  tkn  )  throws  IOException  {    int  lastChar  =  in  .  readAgain  (  )  ;              int  c  =  in  .  read  (  )  ;  boolean  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;      if  (  emptyLinesIgnored  )  {  while  (  eol  &&  (  lastChar  =  =  '\n'  ||  lastChar  =  =  '\r'  ||  lastChar  =  =  ExtendedBufferedReader  .  UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {    lastChar  =  c  ;  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;    if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }  }  }    if  (  isEndOfFile  (  lastChar  )  ||  (  !isDelimiter  (  lastChar  )  &&  isEndOfFile  (  c  )  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }    while  (  tkn  .  type  =  =  INVALID  )  {    if  (  surroundingSpacesIgnored  )  {  while  (  isWhitespace  (  c  )  &&  !eol  )  {  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  }  }    if  (  isCommentStart  (  c  )  )  {    in  .  readLine  (  )  ;  tkn  =  nextToken  (  tkn  .  reset  (  )  )  ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  }  else  if  (  eol  )  {      tkn  .  type  =  EORECORD  ;  }  else  if  (  isEncapsulator  (  c  )  )  {    encapsulatedTokenLexer  (  tkn  ,  c  )  ;  [ATTENTION]  }if  (  isEndOfFile  (  c  )  )  {      tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  there  is  data  at  EOF  }  else  {      simpleTokenLexer  (  tkn  ,  c  )  ;  }  }  return  tkn  ;  }    [METHOD]  nextToken  [TYPE]  Token  [PARAMETER]  Token  tkn  [CLASS]  CSVLexer    [TYPE]  boolean  eol  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  lastChar  
[REPLACE]  tkn  .  type  =  EORECORD;	[BUGGY]  tkn  .  type    =    tkn  .  type  ;  [FE]  [CONTEXT]  Token  nextToken  (  Token  tkn  )  throws  IOException  {    int  lastChar  =  in  .  readAgain  (  )  ;              int  c  =  in  .  read  (  )  ;  boolean  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;      if  (  emptyLinesIgnored  )  {  while  (  eol  &&  (  lastChar  =  =  '\n'  ||  lastChar  =  =  '\r'  ||  lastChar  =  =  ExtendedBufferedReader  .  UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {    lastChar  =  c  ;  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;    if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }  }  }    if  (  isEndOfFile  (  lastChar  )  ||  (  !isDelimiter  (  lastChar  )  &&  isEndOfFile  (  c  )  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }    while  (  tkn  .  type  =  =  INVALID  )  {    if  (  surroundingSpacesIgnored  )  {  while  (  isWhitespace  (  c  )  &&  !eol  )  {  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  }  }    if  (  isCommentStart  (  c  )  )  {    in  .  readLine  (  )  ;  tkn  =  nextToken  (  tkn  .  reset  (  )  )  ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  }  else  if  (  eol  )  {      [ATTENTION]  tkn  .  type  =  tkn  .  type  ;  }  else  if  (  isEncapsulator  (  c  )  )  {    encapsulatedTokenLexer  (  tkn  ,  c  )  ;  }  else  if  (  isEndOfFile  (  c  )  )  {      tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  there  is  data  at  EOF  }  else  {      simpleTokenLexer  (  tkn  ,  c  )  ;  }  }  return  tkn  ;  }    [METHOD]  nextToken  [TYPE]  Token  [PARAMETER]  Token  tkn  [CLASS]  CSVLexer    [TYPE]  boolean  eol  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  lastChar  
[REMOVE]  	[BUGGY]  super  (  format  ,  in  )  ;  [CE]  call  to  super  must  be  first  statement  in  constructor  [CONTEXT]  }  else  if  (  isEndOfFile  (  c  )  )  {      tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  there  is  data  at  EOF  }  else  {      [ATTENTION]  simpleTokenLexer  (  tkn  ,  c  )  ;      [METHOD]  nextToken  [TYPE]  Token  [PARAMETER]  Token  tkn  [CLASS]  CSVLexer    [TYPE]  boolean  eol  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  lastChar  
[REPLACE]  }  else  if  (  isEndOfFile  (  c  )  )  {	[BUGGY]  else  if  (  isDelimiter  (  c  )  )  {[NO-ERROR]  [CONTEXT]  Token  nextToken  (  Token  tkn  )  throws  IOException  {    int  lastChar  =  in  .  readAgain  (  )  ;              int  c  =  in  .  read  (  )  ;  boolean  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;      if  (  emptyLinesIgnored  )  {  while  (  eol  &&  (  lastChar  =  =  '\n'  ||  lastChar  =  =  '\r'  ||  lastChar  =  =  ExtendedBufferedReader  .  UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {    lastChar  =  c  ;  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;    if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }  }  }    if  (  isEndOfFile  (  lastChar  )  ||  (  !isDelimiter  (  lastChar  )  &&  isEndOfFile  (  c  )  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }    while  (  tkn  .  type  =  =  INVALID  )  {    if  (  surroundingSpacesIgnored  )  {  while  (  isWhitespace  (  c  )  &&  !eol  )  {  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  }  }    if  (  isCommentStart  (  c  )  )  {    in  .  readLine  (  )  ;  tkn  =  nextToken  (  tkn  .  reset  (  )  )  ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  }  else  if  (  eol  )  {      tkn  .  type  =  EORECORD  ;  }  else  if  (  isEncapsulator  (  c  )  )  {    encapsulatedTokenLexer  (  tkn  ,  c  )  ;  [ATTENTION]  }  else  if  (  isDelimiter  (  c  )  )  {      tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  there  is  data  at  EOF  }  else  {      simpleTokenLexer  (  tkn  ,  c  )  ;  }  }  return  tkn  ;  }    [METHOD]  nextToken  [TYPE]  Token  [PARAMETER]  Token  tkn  [CLASS]  CSVLexer    [TYPE]  boolean  eol  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  lastChar  
[REPLACE]  tkn  =  nextToken  (  tkn  .  reset  (  )  )  ;	[BUGGY]  tkn  =    nextToken  (  null  .  reset  (  )  )  ;  [CE]  <null>  cannot  be  dereferenced  [CONTEXT]  Token  nextToken  (  Token  tkn  )  throws  IOException  {    int  lastChar  =  in  .  readAgain  (  )  ;              int  c  =  in  .  read  (  )  ;  boolean  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;      if  (  emptyLinesIgnored  )  {  while  (  eol  &&  (  lastChar  =  =  '\n'  ||  lastChar  =  =  '\r'  ||  lastChar  =  =  ExtendedBufferedReader  .  UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {    lastChar  =  c  ;  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;    if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }  }  }    if  (  isEndOfFile  (  lastChar  )  ||  (  !isDelimiter  (  lastChar  )  &&  isEndOfFile  (  c  )  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }    while  (  tkn  .  type  =  =  INVALID  )  {    if  (  surroundingSpacesIgnored  )  {  while  (  isWhitespace  (  c  )  &&  !eol  )  {  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  }  }    if  (  isCommentStart  (  c  )  )  {    in  .  readLine  (  )  ;  [ATTENTION]  tkn  =  nextToken  (  null  .  reset  (  )  )    ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  }  else  if  (  eol  )  {      tkn  .  type  =  EORECORD  ;  }  else  if  (  isEncapsulator  (  c  )  )  {    encapsulatedTokenLexer  (  tkn  ,  c  )  ;  }  else  if  (  isEndOfFile  (  c  )  )  {      tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  there  is  data  at  EOF  }  else  {      simpleTokenLexer  (  tkn  ,  c  )  ;  }  }  return  tkn  ;  }    [METHOD]  nextToken  [TYPE]  Token  [PARAMETER]  Token  tkn  [CLASS]  CSVLexer    [TYPE]  boolean  eol  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  lastChar  
[REPLACE]  }  else  if  (  isDelimiter  (  c  )  )  {	[BUGGY]    if  (  isDelimiter  (  c  )  )  {[FE]  AssertionFailedError    Token  type  expected:<EORECORD>  but  was:<TOKEN>  assertTokenEquals(TOKEN  ,   "1 "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "2 "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "3 "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   " "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "b  x "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "c "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "d "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "e "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   " "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  Token  nextToken  (  Token  tkn  )  throws  IOException  {    int  lastChar  =  in  .  readAgain  (  )  ;              int  c  =  in  .  read  (  )  ;  boolean  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;      if  (  emptyLinesIgnored  )  {  while  (  eol  &&  (  lastChar  =  =  '\n'  ||  lastChar  =  =  '\r'  ||  lastChar  =  =  ExtendedBufferedReader  .  UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {    lastChar  =  c  ;  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;    if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }  }  }    if  (  isEndOfFile  (  lastChar  )  ||  (  !isDelimiter  (  lastChar  )  &&  isEndOfFile  (  c  )  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }    while  (  tkn  .  type  =  =  INVALID  )  {    if  (  surroundingSpacesIgnored  )  {  while  (  isWhitespace  (  c  )  &&  !eol  )  {  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  }  }    if  (  isCommentStart  (  c  )  )  {    in  .  readLine  (  )  ;  tkn  =  nextToken  (  tkn  .  reset  (  )  )  ;  [ATTENTION]  }if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  }  else  if  (  eol  )  {      tkn  .  type  =  EORECORD  ;  }  else  if  (  isEncapsulator  (  c  )  )  {    encapsulatedTokenLexer  (  tkn  ,  c  )  ;  }  else  if  (  isEndOfFile  (  c  )  )  {      tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  there  is  data  at  EOF  }  else  {      simpleTokenLexer  (  tkn  ,  c  )  ;  }  }  return  tkn  ;  }    [METHOD]  nextToken  [TYPE]  Token  [PARAMETER]  Token  tkn  [CLASS]  CSVLexer    [TYPE]  boolean  eol  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  lastChar  
[REPLACE]  }  else  if  (  eol  )  {	[BUGGY]    if  (  false  )  {[FE]  AssertionFailedError    Token  type  expected:<EORECORD>  but  was:<TOKEN>  assertTokenEquals(TOKEN  ,   "1 "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "2 "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "3 "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   " "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "b  x "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "c "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "d "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "e "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   " "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  Token  nextToken  (  Token  tkn  )  throws  IOException  {    int  lastChar  =  in  .  readAgain  (  )  ;              int  c  =  in  .  read  (  )  ;  boolean  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;      if  (  emptyLinesIgnored  )  {  while  (  eol  &&  (  lastChar  =  =  '\n'  ||  lastChar  =  =  '\r'  ||  lastChar  =  =  ExtendedBufferedReader  .  UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {    lastChar  =  c  ;  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;    if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }  }  }    if  (  isEndOfFile  (  lastChar  )  ||  (  !isDelimiter  (  lastChar  )  &&  isEndOfFile  (  c  )  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }    while  (  tkn  .  type  =  =  INVALID  )  {    if  (  surroundingSpacesIgnored  )  {  while  (  isWhitespace  (  c  )  &&  !eol  )  {  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  }  }    if  (  isCommentStart  (  c  )  )  {    in  .  readLine  (  )  ;  tkn  =  nextToken  (  tkn  .  reset  (  )  )  ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  [ATTENTION]  }if  (  false  )  {      tkn  .  type  =  EORECORD  ;  }  else  if  (  isEncapsulator  (  c  )  )  {    encapsulatedTokenLexer  (  tkn  ,  c  )  ;  }  else  if  (  isEndOfFile  (  c  )  )  {      tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  there  is  data  at  EOF  }  else  {      simpleTokenLexer  (  tkn  ,  c  )  ;  }  }  return  tkn  ;  }    [METHOD]  nextToken  [TYPE]  Token  [PARAMETER]  Token  tkn  [CLASS]  CSVLexer    [TYPE]  boolean  eol  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  lastChar  
[ADD]  else  if  (  eol  )  {  tkn  .  type  =  EORECORD;	[BUGGY]    tkn  .  type  =  EORECORD  ;  [CE]  'else'  without  'if'  [CONTEXT]  Token  nextToken  (  Token  tkn  )  throws  IOException  {    int  lastChar  =  in  .  readAgain  (  )  ;              int  c  =  in  .  read  (  )  ;  boolean  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;      if  (  emptyLinesIgnored  )  {  while  (  eol  &&  (  lastChar  =  =  '\n'  ||  lastChar  =  =  '\r'  ||  lastChar  =  =  ExtendedBufferedReader  .  UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {    lastChar  =  c  ;  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;    if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }  }  }    if  (  isEndOfFile  (  lastChar  )  ||  (  !isDelimiter  (  lastChar  )  &&  isEndOfFile  (  c  )  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }    while  (  tkn  .  type  =  =  INVALID  )  {    if  (  surroundingSpacesIgnored  )  {  while  (  isWhitespace  (  c  )  &&  !eol  )  {  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  }  }    if  (  isCommentStart  (  c  )  )  {    in  .  readLine  (  )  ;  tkn  =  nextToken  (  tkn  .  reset  (  )  )  ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  [ATTENTION]  }  tkn  .  type  =  EORECORD  ;      }  else  if  (  isEncapsulator  (  c  )  )  {    encapsulatedTokenLexer  (  tkn  ,  c  )  ;  }  else  if  (  isEndOfFile  (  c  )  )  {      tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  there  is  data  at  EOF  }  else  {      simpleTokenLexer  (  tkn  ,  c  )  ;  }  }  return  tkn  ;  }    [METHOD]  nextToken  [TYPE]  Token  [PARAMETER]  Token  tkn  [CLASS]  CSVLexer    [TYPE]  boolean  eol  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  lastChar  
[REPLACE]  tkn  .  type  =  EORECORD;	[BUGGY]  tkn  .  type  ;  [CE]  not  a  statement  [CONTEXT]  Token  nextToken  (  Token  tkn  )  throws  IOException  {    int  lastChar  =  in  .  readAgain  (  )  ;              int  c  =  in  .  read  (  )  ;  boolean  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;      if  (  emptyLinesIgnored  )  {  while  (  eol  &&  (  lastChar  =  =  '\n'  ||  lastChar  =  =  '\r'  ||  lastChar  =  =  ExtendedBufferedReader  .  UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {    lastChar  =  c  ;  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;    if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }  }  }    if  (  isEndOfFile  (  lastChar  )  ||  (  !isDelimiter  (  lastChar  )  &&  isEndOfFile  (  c  )  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }    while  (  tkn  .  type  =  =  INVALID  )  {    if  (  surroundingSpacesIgnored  )  {  while  (  isWhitespace  (  c  )  &&  !eol  )  {  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  }  }    if  (  isCommentStart  (  c  )  )  {    in  .  readLine  (  )  ;  tkn  =  nextToken  (  tkn  .  reset  (  )  )  ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  }  else  if  (  eol  )  {      [ATTENTION]  tkn  .  type  ;  }  else  if  (  isEncapsulator  (  c  )  )  {    encapsulatedTokenLexer  (  tkn  ,  c  )  ;  }  else  if  (  isEndOfFile  (  c  )  )  {      tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  there  is  data  at  EOF  }  else  {      simpleTokenLexer  (  tkn  ,  c  )  ;  }  }  return  tkn  ;  }    [METHOD]  nextToken  [TYPE]  Token  [PARAMETER]  Token  tkn  [CLASS]  CSVLexer    [TYPE]  boolean  eol  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  lastChar  
[REPLACE]  }  else  if  (  isEncapsulator  (  c  )  )  {	[BUGGY]  else  if  (  isEncapsulator  (  lastChar  )  )  {[FE]  AssertionFailedError    Token  content  expected:<[foo]>  but  was:<[ "foo "]>  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "  foo "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "  foo   "  ,  parser.nextToken(new  Token()))  ;  //      assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "b "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  Token  nextToken  (  Token  tkn  )  throws  IOException  {    int  lastChar  =  in  .  readAgain  (  )  ;              int  c  =  in  .  read  (  )  ;  boolean  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;      if  (  emptyLinesIgnored  )  {  while  (  eol  &&  (  lastChar  =  =  '\n'  ||  lastChar  =  =  '\r'  ||  lastChar  =  =  ExtendedBufferedReader  .  UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {    lastChar  =  c  ;  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;    if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }  }  }    if  (  isEndOfFile  (  lastChar  )  ||  (  !isDelimiter  (  lastChar  )  &&  isEndOfFile  (  c  )  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }    while  (  tkn  .  type  =  =  INVALID  )  {    if  (  surroundingSpacesIgnored  )  {  while  (  isWhitespace  (  c  )  &&  !eol  )  {  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  }  }    if  (  isCommentStart  (  c  )  )  {    in  .  readLine  (  )  ;  tkn  =  nextToken  (  tkn  .  reset  (  )  )  ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  }  else  if  (  eol  )  {      tkn  .  type  =  EORECORD  ;  [ATTENTION]  }  else  if  (  isEncapsulator  (  lastChar  )  )  {    encapsulatedTokenLexer  (  tkn  ,  c  )  ;  }  else  if  (  isEndOfFile  (  c  )  )  {      tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  there  is  data  at  EOF  }  else  {      simpleTokenLexer  (  tkn  ,  c  )  ;  }  }  return  tkn  ;  }    [METHOD]  nextToken  [TYPE]  Token  [PARAMETER]  Token  tkn  [CLASS]  CSVLexer    [TYPE]  boolean  eol  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  lastChar  
[REPLACE]  }  else  if  (  isEndOfFile  (  c  )  )  {	[BUGGY]  else  if  (  isEndOfFile  (  lastChar  )  )  {[NO-ERROR]  [CONTEXT]  Token  nextToken  (  Token  tkn  )  throws  IOException  {    int  lastChar  =  in  .  readAgain  (  )  ;              int  c  =  in  .  read  (  )  ;  boolean  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;      if  (  emptyLinesIgnored  )  {  while  (  eol  &&  (  lastChar  =  =  '\n'  ||  lastChar  =  =  '\r'  ||  lastChar  =  =  ExtendedBufferedReader  .  UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {    lastChar  =  c  ;  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;    if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }  }  }    if  (  isEndOfFile  (  lastChar  )  ||  (  !isDelimiter  (  lastChar  )  &&  isEndOfFile  (  c  )  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }    while  (  tkn  .  type  =  =  INVALID  )  {    if  (  surroundingSpacesIgnored  )  {  while  (  isWhitespace  (  c  )  &&  !eol  )  {  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  }  }    if  (  isCommentStart  (  c  )  )  {    in  .  readLine  (  )  ;  tkn  =  nextToken  (  tkn  .  reset  (  )  )  ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  }  else  if  (  eol  )  {      tkn  .  type  =  EORECORD  ;  }  else  if  (  isEncapsulator  (  c  )  )  {    encapsulatedTokenLexer  (  tkn  ,  c  )  ;  [ATTENTION]  }  else  if  (  isEndOfFile  (  lastChar  )  )  {      tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  there  is  data  at  EOF  }  else  {      simpleTokenLexer  (  tkn  ,  c  )  ;  }  }  return  tkn  ;  }    [METHOD]  nextToken  [TYPE]  Token  [PARAMETER]  Token  tkn  [CLASS]  CSVLexer    [TYPE]  boolean  eol  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  lastChar  
[ADD]  tkn  .  type  =  EOF;  tkn  .  isReady  =  true;	[BUGGY]  tkn  .  isReady  =  true  ;  [FE]  [CONTEXT]  Token  nextToken  (  Token  tkn  )  throws  IOException  {    int  lastChar  =  in  .  readAgain  (  )  ;              int  c  =  in  .  read  (  )  ;  boolean  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;      if  (  emptyLinesIgnored  )  {  while  (  eol  &&  (  lastChar  =  =  '\n'  ||  lastChar  =  =  '\r'  ||  lastChar  =  =  ExtendedBufferedReader  .  UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {    lastChar  =  c  ;  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;    if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }  }  }    if  (  isEndOfFile  (  lastChar  )  ||  (  !isDelimiter  (  lastChar  )  &&  isEndOfFile  (  c  )  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }    while  (  tkn  .  type  =  =  INVALID  )  {    if  (  surroundingSpacesIgnored  )  {  while  (  isWhitespace  (  c  )  &&  !eol  )  {  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  }  }    if  (  isCommentStart  (  c  )  )  {    in  .  readLine  (  )  ;  tkn  =  nextToken  (  tkn  .  reset  (  )  )  ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  }  else  if  (  eol  )  {      tkn  .  type  =  EORECORD  ;  }  else  if  (  isEncapsulator  (  c  )  )  {    encapsulatedTokenLexer  (  tkn  ,  c  )  ;  }  else  if  (  isEndOfFile  (  c  )  )  {      [ATTENTION]  tkn  .  isReady  =  true  ;    }  else  {      simpleTokenLexer  (  tkn  ,  c  )  ;  }  }  return  tkn  ;  }    [METHOD]  nextToken  [TYPE]  Token  [PARAMETER]  Token  tkn  [CLASS]  CSVLexer    [TYPE]  boolean  eol  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  lastChar  
[ADD]  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;	[BUGGY]  [FE]  [CONTEXT]  Token  nextToken  (  Token  tkn  )  throws  IOException  {    int  lastChar  =  in  .  readAgain  (  )  ;              int  c  =  in  .  read  (  )  ;  boolean  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;      if  (  emptyLinesIgnored  )  {  while  (  eol  &&  (  lastChar  =  =  '\n'  ||  lastChar  =  =  '\r'  ||  lastChar  =  =  ExtendedBufferedReader  .  UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {    lastChar  =  c  ;  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;    if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }  }  }    if  (  isEndOfFile  (  lastChar  )  ||  (  !isDelimiter  (  lastChar  )  &&  isEndOfFile  (  c  )  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }    while  (  tkn  .  type  =  =  INVALID  )  {    if  (  surroundingSpacesIgnored  )  {  while  (  isWhitespace  (  c  )  &&  !eol  )  {  [ATTENTION]    }  }    if  (  isCommentStart  (  c  )  )  {    in  .  readLine  (  )  ;  tkn  =  nextToken  (  tkn  .  reset  (  )  )  ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  }  else  if  (  eol  )  {      tkn  .  type  =  EORECORD  ;  }  else  if  (  isEncapsulator  (  c  )  )  {    encapsulatedTokenLexer  (  tkn  ,  c  )  ;  }  else  if  (  isEndOfFile  (  c  )  )  {      tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  there  is  data  at  EOF  }  else  {      simpleTokenLexer  (  tkn  ,  c  )  ;  }  }  return  tkn  ;  }    [METHOD]  nextToken  [TYPE]  Token  [PARAMETER]  Token  tkn  [CLASS]  CSVLexer    [TYPE]  boolean  eol  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  lastChar  
[ADD]  eol  =  isEndOfLine  (  c  )  ;	[BUGGY]  [NO-ERROR]  [CONTEXT]  Token  nextToken  (  Token  tkn  )  throws  IOException  {    int  lastChar  =  in  .  readAgain  (  )  ;              int  c  =  in  .  read  (  )  ;  boolean  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;      if  (  emptyLinesIgnored  )  {  while  (  eol  &&  (  lastChar  =  =  '\n'  ||  lastChar  =  =  '\r'  ||  lastChar  =  =  ExtendedBufferedReader  .  UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {    lastChar  =  c  ;  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;    if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }  }  }    if  (  isEndOfFile  (  lastChar  )  ||  (  !isDelimiter  (  lastChar  )  &&  isEndOfFile  (  c  )  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }    while  (  tkn  .  type  =  =  INVALID  )  {    if  (  surroundingSpacesIgnored  )  {  while  (  isWhitespace  (  c  )  &&  !eol  )  {  c  =  in  .  read  (  )  ;  [ATTENTION]  }  }    if  (  isCommentStart  (  c  )  )  {    in  .  readLine  (  )  ;  tkn  =  nextToken  (  tkn  .  reset  (  )  )  ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  }  else  if  (  eol  )  {      tkn  .  type  =  EORECORD  ;  }  else  if  (  isEncapsulator  (  c  )  )  {    encapsulatedTokenLexer  (  tkn  ,  c  )  ;  }  else  if  (  isEndOfFile  (  c  )  )  {      tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  there  is  data  at  EOF  }  else  {      simpleTokenLexer  (  tkn  ,  c  )  ;  }  }  return  tkn  ;  }    [METHOD]  nextToken  [TYPE]  Token  [PARAMETER]  Token  tkn  [CLASS]  CSVLexer    [TYPE]  boolean  eol  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  lastChar  
[REPLACE]  while  (  isWhitespace  (  c  )  &&  !eol  )  {	[BUGGY]  while  (  isWhitespace  (  c  )  ||  !eol  )  {[FE]  [CONTEXT]  Token  nextToken  (  Token  tkn  )  throws  IOException  {    int  lastChar  =  in  .  readAgain  (  )  ;              int  c  =  in  .  read  (  )  ;  boolean  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;      if  (  emptyLinesIgnored  )  {  while  (  eol  &&  (  lastChar  =  =  '\n'  ||  lastChar  =  =  '\r'  ||  lastChar  =  =  ExtendedBufferedReader  .  UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {    lastChar  =  c  ;  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;    if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }  }  }    if  (  isEndOfFile  (  lastChar  )  ||  (  !isDelimiter  (  lastChar  )  &&  isEndOfFile  (  c  )  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }    while  (  tkn  .  type  =  =  INVALID  )  {    if  (  surroundingSpacesIgnored  )  {  [ATTENTION]  while  (  isWhitespace  (  c  )  ||  !eol  )  {  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  }  }    if  (  isCommentStart  (  c  )  )  {    in  .  readLine  (  )  ;  tkn  =  nextToken  (  tkn  .  reset  (  )  )  ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  }  else  if  (  eol  )  {      tkn  .  type  =  EORECORD  ;  }  else  if  (  isEncapsulator  (  c  )  )  {    encapsulatedTokenLexer  (  tkn  ,  c  )  ;  }  else  if  (  isEndOfFile  (  c  )  )  {      tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  there  is  data  at  EOF  }  else  {      simpleTokenLexer  (  tkn  ,  c  )  ;  }  }  return  tkn  ;  }    [METHOD]  nextToken  [TYPE]  Token  [PARAMETER]  Token  tkn  [CLASS]  CSVLexer    [TYPE]  boolean  eol  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  lastChar  
[ADD]  while  (  isWhitespace  (  c  )  &&  !eol  )  {  c  =  in  .  read  (  )  ;	[BUGGY]  [CE]  illegal  start  of  type  [CONTEXT]  Token  nextToken  (  Token  tkn  )  throws  IOException  {    int  lastChar  =  in  .  readAgain  (  )  ;              int  c  =  in  .  read  (  )  ;  boolean  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;      if  (  emptyLinesIgnored  )  {  while  (  eol  &&  (  lastChar  =  =  '\n'  ||  lastChar  =  =  '\r'  ||  lastChar  =  =  ExtendedBufferedReader  .  UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {    lastChar  =  c  ;  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;    if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }  }  }    if  (  isEndOfFile  (  lastChar  )  ||  (  !isDelimiter  (  lastChar  )  &&  isEndOfFile  (  c  )  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }    while  (  tkn  .  type  =  =  INVALID  )  {    if  (  surroundingSpacesIgnored  )  {  [ATTENTION]    eol  =  isEndOfLine  (  c  )  ;  }  }    if  (  isCommentStart  (  c  )  )  {    in  .  readLine  (  )  ;  tkn  =  nextToken  (  tkn  .  reset  (  )  )  ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  }  else  if  (  eol  )  {      tkn  .  type  =  EORECORD  ;  }  else  if  (  isEncapsulator  (  c  )  )  {    encapsulatedTokenLexer  (  tkn  ,  c  )  ;  }  else  if  (  isEndOfFile  (  c  )  )  {      tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  there  is  data  at  EOF  }  else  {      simpleTokenLexer  (  tkn  ,  c  )  ;  }  }  return  tkn  ;  }    [METHOD]  nextToken  [TYPE]  Token  [PARAMETER]  Token  tkn  [CLASS]  CSVLexer    [TYPE]  boolean  eol  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  lastChar  
[ADD]  if  (  surroundingSpacesIgnored  )  {  while  (  isWhitespace  (  c  )  &&  !eol  )  {  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  }	[BUGGY]  [CE]  illegal  start  of  type  [CONTEXT]  Token  nextToken  (  Token  tkn  )  throws  IOException  {    int  lastChar  =  in  .  readAgain  (  )  ;              int  c  =  in  .  read  (  )  ;  boolean  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;      if  (  emptyLinesIgnored  )  {  while  (  eol  &&  (  lastChar  =  =  '\n'  ||  lastChar  =  =  '\r'  ||  lastChar  =  =  ExtendedBufferedReader  .  UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {    lastChar  =  c  ;  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;    if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }  }  }    if  (  isEndOfFile  (  lastChar  )  ||  (  !isDelimiter  (  lastChar  )  &&  isEndOfFile  (  c  )  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }    while  (  tkn  .  type  =  =  INVALID  )  {    [ATTENTION]      }    if  (  isCommentStart  (  c  )  )  {    in  .  readLine  (  )  ;  tkn  =  nextToken  (  tkn  .  reset  (  )  )  ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  }  else  if  (  eol  )  {      tkn  .  type  =  EORECORD  ;  }  else  if  (  isEncapsulator  (  c  )  )  {    encapsulatedTokenLexer  (  tkn  ,  c  )  ;  }  else  if  (  isEndOfFile  (  c  )  )  {      tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  there  is  data  at  EOF  }  else  {      simpleTokenLexer  (  tkn  ,  c  )  ;  }  }  return  tkn  ;  }    [METHOD]  nextToken  [TYPE]  Token  [PARAMETER]  Token  tkn  [CLASS]  CSVLexer    [TYPE]  boolean  eol  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  lastChar  
[REPLACE]  if  (  isCommentStart  (  c  )  )  {	[BUGGY]  if  (  isEscape  (  c  )  )  {[FE]  AssertionFailedError    Token  content  expected:<[]>  but  was:<[#foo]>  assertTokenEquals(TOKEN  ,   "1 "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "2 "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "3 "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   " "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "b  x "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "c "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "d "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "e "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   " "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  Token  nextToken  (  Token  tkn  )  throws  IOException  {    int  lastChar  =  in  .  readAgain  (  )  ;              int  c  =  in  .  read  (  )  ;  boolean  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;      if  (  emptyLinesIgnored  )  {  while  (  eol  &&  (  lastChar  =  =  '\n'  ||  lastChar  =  =  '\r'  ||  lastChar  =  =  ExtendedBufferedReader  .  UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {    lastChar  =  c  ;  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;    if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }  }  }    if  (  isEndOfFile  (  lastChar  )  ||  (  !isDelimiter  (  lastChar  )  &&  isEndOfFile  (  c  )  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }    while  (  tkn  .  type  =  =  INVALID  )  {    if  (  surroundingSpacesIgnored  )  {  while  (  isWhitespace  (  c  )  &&  !eol  )  {  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  }  }    [ATTENTION]  if  (  isEscape  (  c  )  )  {    in  .  readLine  (  )  ;  tkn  =  nextToken  (  tkn  .  reset  (  )  )  ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  }  else  if  (  eol  )  {      tkn  .  type  =  EORECORD  ;  }  else  if  (  isEncapsulator  (  c  )  )  {    encapsulatedTokenLexer  (  tkn  ,  c  )  ;  }  else  if  (  isEndOfFile  (  c  )  )  {      tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  there  is  data  at  EOF  }  else  {      simpleTokenLexer  (  tkn  ,  c  )  ;  }  }  return  tkn  ;  }    [METHOD]  nextToken  [TYPE]  Token  [PARAMETER]  Token  tkn  [CLASS]  CSVLexer    [TYPE]  boolean  eol  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  lastChar  
[REPLACE]  }  else  if  (  isDelimiter  (  c  )  )  {	[BUGGY]    if  (  isDelimiter  (  lastChar  )  )  {[FE]  AssertionFailedError    Token  content  expected:<[def]>  but  was:<[]>  assertTokenEquals(TOKEN  ,   "abc "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "def "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "hijk "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "lmnop "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "qrst "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "uv "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "wxy "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "z "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   " "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   " "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  Token  nextToken  (  Token  tkn  )  throws  IOException  {    int  lastChar  =  in  .  readAgain  (  )  ;              int  c  =  in  .  read  (  )  ;  boolean  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;      if  (  emptyLinesIgnored  )  {  while  (  eol  &&  (  lastChar  =  =  '\n'  ||  lastChar  =  =  '\r'  ||  lastChar  =  =  ExtendedBufferedReader  .  UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {    lastChar  =  c  ;  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;    if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }  }  }    if  (  isEndOfFile  (  lastChar  )  ||  (  !isDelimiter  (  lastChar  )  &&  isEndOfFile  (  c  )  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }    while  (  tkn  .  type  =  =  INVALID  )  {    if  (  surroundingSpacesIgnored  )  {  while  (  isWhitespace  (  c  )  &&  !eol  )  {  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  }  }    if  (  isCommentStart  (  c  )  )  {    in  .  readLine  (  )  ;  tkn  =  nextToken  (  tkn  .  reset  (  )  )  ;  [ATTENTION]  }if  (  isDelimiter  (  lastChar  )  )  {    tkn  .  type  =  TOKEN  ;  }  else  if  (  eol  )  {      tkn  .  type  =  EORECORD  ;  }  else  if  (  isEncapsulator  (  c  )  )  {    encapsulatedTokenLexer  (  tkn  ,  c  )  ;  }  else  if  (  isEndOfFile  (  c  )  )  {      tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  there  is  data  at  EOF  }  else  {      simpleTokenLexer  (  tkn  ,  c  )  ;  }  }  return  tkn  ;  }    [METHOD]  nextToken  [TYPE]  Token  [PARAMETER]  Token  tkn  [CLASS]  CSVLexer    [TYPE]  boolean  eol  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  lastChar  
[REMOVE]  	[BUGGY]  if  (  isDelimiter  (  c  )  )  {      tkn  .  type  =  TOKEN  ;  }else      if  (  eol  )  {          tkn  .  type  =  EORECORD  ;      }else          if  (  isEncapsulator  (  c  )  )  {              encapsulatedTokenLexer  (  tkn  ,  c  )  ;          }else              if  (  isEndOfFile  (  c  )  )  {                  tkn  .  type  =  EOF  ;                  tkn  .  isReady  =  true  ;              }else  {                  simpleTokenLexer  (  tkn  ,  c  )  ;              }[NO-ERROR]  [CONTEXT]  Token  nextToken  (  Token  tkn  )  throws  IOException  {    int  lastChar  =  in  .  readAgain  (  )  ;              int  c  =  in  .  read  (  )  ;  boolean  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;      if  (  emptyLinesIgnored  )  {  while  (  eol  &&  (  lastChar  =  =  '\n'  ||  lastChar  =  =  '\r'  ||  lastChar  =  =  ExtendedBufferedReader  .  UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {    lastChar  =  c  ;  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;    if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }  }  }    if  (  isEndOfFile  (  lastChar  )  ||  (  !isDelimiter  (  lastChar  )  &&  isEndOfFile  (  c  )  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }    while  (  tkn  .  type  =  =  INVALID  )  {    if  (  surroundingSpacesIgnored  )  {  while  (  isWhitespace  (  c  )  &&  !eol  )  {  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  }  }    if  (  isCommentStart  (  c  )  )  {    in  .  readLine  (  )  ;  tkn  =  nextToken  (  tkn  .  reset  (  )  )  ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  [ATTENTION]  }  else  if  (  eol  )  {  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  }else  if  (  eol  )  {  tkn  .  type  =  EORECORD  ;  }else  if  (  isEncapsulator  (  c  )  )  {  encapsulatedTokenLexer  (  tkn  ,  c  )    ;  }else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  }else  {  simpleTokenLexer  (  tkn  ,  c  )    ;  }//  empty  token  return  EORECORD  (   " "  )    tkn  .  type  =  EORECORD  ;  }  else  if  (  isEncapsulator  (  c  )  )  {    encapsulatedTokenLexer  (  tkn  ,  c  )  ;  }  else  if  (  isEndOfFile  (  c  )  )  {      tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  there  is  data  at  EOF  }  else  {      simpleTokenLexer  (  tkn  ,  c  )  ;  }  }  return  tkn  ;      [METHOD]  nextToken  [TYPE]  Token  [PARAMETER]  Token  tkn  [CLASS]  CSVLexer    [TYPE]  boolean  eol  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  lastChar  
[ADD]  tkn  .  type  =  EORECORD;	[BUGGY]  [FE]  [CONTEXT]  Token  nextToken  (  Token  tkn  )  throws  IOException  {    int  lastChar  =  in  .  readAgain  (  )  ;              int  c  =  in  .  read  (  )  ;  boolean  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;      if  (  emptyLinesIgnored  )  {  while  (  eol  &&  (  lastChar  =  =  '\n'  ||  lastChar  =  =  '\r'  ||  lastChar  =  =  ExtendedBufferedReader  .  UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {    lastChar  =  c  ;  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;    if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }  }  }    if  (  isEndOfFile  (  lastChar  )  ||  (  !isDelimiter  (  lastChar  )  &&  isEndOfFile  (  c  )  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }    while  (  tkn  .  type  =  =  INVALID  )  {    if  (  surroundingSpacesIgnored  )  {  while  (  isWhitespace  (  c  )  &&  !eol  )  {  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  }  }    if  (  isCommentStart  (  c  )  )  {    in  .  readLine  (  )  ;  tkn  =  nextToken  (  tkn  .  reset  (  )  )  ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  }  else  if  (  eol  )  {      [ATTENTION]  }  else  if  (  isEncapsulator  (  c  )  )  {    encapsulatedTokenLexer  (  tkn  ,  c  )  ;  }  else  if  (  isEndOfFile  (  c  )  )  {      tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  there  is  data  at  EOF  }  else  {      simpleTokenLexer  (  tkn  ,  c  )  ;  }  }  return  tkn  ;  }    [METHOD]  nextToken  [TYPE]  Token  [PARAMETER]  Token  tkn  [CLASS]  CSVLexer    [TYPE]  boolean  eol  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  lastChar  
[ADD]  tkn  =  nextToken  (  tkn  .  reset  (  )  )  ;	[BUGGY]  [FE]  [CONTEXT]  Token  nextToken  (  Token  tkn  )  throws  IOException  {    int  lastChar  =  in  .  readAgain  (  )  ;              int  c  =  in  .  read  (  )  ;  boolean  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;      if  (  emptyLinesIgnored  )  {  while  (  eol  &&  (  lastChar  =  =  '\n'  ||  lastChar  =  =  '\r'  ||  lastChar  =  =  ExtendedBufferedReader  .  UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {    lastChar  =  c  ;  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;    if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }  }  }    if  (  isEndOfFile  (  lastChar  )  ||  (  !isDelimiter  (  lastChar  )  &&  isEndOfFile  (  c  )  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }    while  (  tkn  .  type  =  =  INVALID  )  {    if  (  surroundingSpacesIgnored  )  {  while  (  isWhitespace  (  c  )  &&  !eol  )  {  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  }  }    if  (  isCommentStart  (  c  )  )  {    in  .  readLine  (  )  ;  [ATTENTION]  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  }  else  if  (  eol  )  {      tkn  .  type  =  EORECORD  ;  }  else  if  (  isEncapsulator  (  c  )  )  {    encapsulatedTokenLexer  (  tkn  ,  c  )  ;  }  else  if  (  isEndOfFile  (  c  )  )  {      tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  there  is  data  at  EOF  }  else  {      simpleTokenLexer  (  tkn  ,  c  )  ;  }  }  return  tkn  ;  }    [METHOD]  nextToken  [TYPE]  Token  [PARAMETER]  Token  tkn  [CLASS]  CSVLexer    [TYPE]  boolean  eol  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  lastChar  
[REPLACE]  }  else  if  (  isDelimiter  (  c  )  )  {	[BUGGY]  else  if  (  isEndOfFile  (  c  )  )  {[FE]  AssertionFailedError    Token  type  expected:<EOF>  but  was:<TOKEN>  assertTokenEquals(TOKEN  ,   "abc "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "def "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "hijk "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "lmnop "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "qrst "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "uv "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "wxy "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "z "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   " "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   " "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  Token  nextToken  (  Token  tkn  )  throws  IOException  {    int  lastChar  =  in  .  readAgain  (  )  ;              int  c  =  in  .  read  (  )  ;  boolean  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;      if  (  emptyLinesIgnored  )  {  while  (  eol  &&  (  lastChar  =  =  '\n'  ||  lastChar  =  =  '\r'  ||  lastChar  =  =  ExtendedBufferedReader  .  UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {    lastChar  =  c  ;  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;    if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }  }  }    if  (  isEndOfFile  (  lastChar  )  ||  (  !isDelimiter  (  lastChar  )  &&  isEndOfFile  (  c  )  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }    while  (  tkn  .  type  =  =  INVALID  )  {    if  (  surroundingSpacesIgnored  )  {  while  (  isWhitespace  (  c  )  &&  !eol  )  {  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  }  }    if  (  isCommentStart  (  c  )  )  {    in  .  readLine  (  )  ;  tkn  =  nextToken  (  tkn  .  reset  (  )  )  ;  [ATTENTION]  }  else  if  (  isEndOfFile  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  }  else  if  (  eol  )  {      tkn  .  type  =  EORECORD  ;  }  else  if  (  isEncapsulator  (  c  )  )  {    encapsulatedTokenLexer  (  tkn  ,  c  )  ;  }  else  if  (  isEndOfFile  (  c  )  )  {      tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  there  is  data  at  EOF  }  else  {      simpleTokenLexer  (  tkn  ,  c  )  ;  }  }  return  tkn  ;  }    [METHOD]  nextToken  [TYPE]  Token  [PARAMETER]  Token  tkn  [CLASS]  CSVLexer    [TYPE]  boolean  eol  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  lastChar  
[REMOVE]  	[BUGGY]  if  (  eol  )  {      tkn  .  type  =  EORECORD  ;  }else      if  (  isEncapsulator  (  c  )  )  {          encapsulatedTokenLexer  (  tkn  ,  c  )  ;      }else          if  (  isEndOfFile  (  c  )  )  {              tkn  .  type  =  EOF  ;              tkn  .  isReady  =  true  ;          }else  {              simpleTokenLexer  (  tkn  ,  c  )  ;          }[NO-ERROR]  [CONTEXT]  Token  nextToken  (  Token  tkn  )  throws  IOException  {    int  lastChar  =  in  .  readAgain  (  )  ;              int  c  =  in  .  read  (  )  ;  boolean  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;      if  (  emptyLinesIgnored  )  {  while  (  eol  &&  (  lastChar  =  =  '\n'  ||  lastChar  =  =  '\r'  ||  lastChar  =  =  ExtendedBufferedReader  .  UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {    lastChar  =  c  ;  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;    if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }  }  }    if  (  isEndOfFile  (  lastChar  )  ||  (  !isDelimiter  (  lastChar  )  &&  isEndOfFile  (  c  )  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }    while  (  tkn  .  type  =  =  INVALID  )  {    if  (  surroundingSpacesIgnored  )  {  while  (  isWhitespace  (  c  )  &&  !eol  )  {  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  }  }    if  (  isCommentStart  (  c  )  )  {    in  .  readLine  (  )  ;  tkn  =  nextToken  (  tkn  .  reset  (  )  )  ;  [ATTENTION]  }  else  if  (  isDelimiter  (  c  )  )  {  if  (  eol  )  {  tkn  .  type  =  EORECORD  ;  }else  if  (  isEncapsulator  (  c  )  )  {  encapsulatedTokenLexer  (  tkn  ,  c  )    ;  }else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  }else  {  simpleTokenLexer  (  tkn  ,  c  )    ;  }//  empty  token  return  TOKEN  (   " "  )  tkn  .  type  =  TOKEN  ;  }  else  if  (  eol  )  {      tkn  .  type  =  EORECORD  ;  }  else  if  (  isEncapsulator  (  c  )  )  {    encapsulatedTokenLexer  (  tkn  ,  c  )  ;  }  else  if  (  isEndOfFile  (  c  )  )  {      tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  there  is  data  at  EOF  }  else  {      simpleTokenLexer  (  tkn  ,  c  )  ;  }  }  return  tkn  ;      [METHOD]  nextToken  [TYPE]  Token  [PARAMETER]  Token  tkn  [CLASS]  CSVLexer    [TYPE]  boolean  eol  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  lastChar  
[REPLACE]  }  else  if  (  isEncapsulator  (  c  )  )  {	[BUGGY]  else  if  (  isEndOfFile  (  c  )  )  {[FE]  (startline  0)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,   "abc "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "def "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "hijk "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "lmnop "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "qrst "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "uv "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "wxy "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "z "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   " "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   " "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  Token  nextToken  (  Token  tkn  )  throws  IOException  {    int  lastChar  =  in  .  readAgain  (  )  ;              int  c  =  in  .  read  (  )  ;  boolean  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;      if  (  emptyLinesIgnored  )  {  while  (  eol  &&  (  lastChar  =  =  '\n'  ||  lastChar  =  =  '\r'  ||  lastChar  =  =  ExtendedBufferedReader  .  UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {    lastChar  =  c  ;  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;    if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }  }  }    if  (  isEndOfFile  (  lastChar  )  ||  (  !isDelimiter  (  lastChar  )  &&  isEndOfFile  (  c  )  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }    while  (  tkn  .  type  =  =  INVALID  )  {    if  (  surroundingSpacesIgnored  )  {  while  (  isWhitespace  (  c  )  &&  !eol  )  {  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  }  }    if  (  isCommentStart  (  c  )  )  {    in  .  readLine  (  )  ;  tkn  =  nextToken  (  tkn  .  reset  (  )  )  ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  }  else  if  (  eol  )  {      tkn  .  type  =  EORECORD  ;  [ATTENTION]  }  else  if  (  isEndOfFile  (  c  )  )  {    encapsulatedTokenLexer  (  tkn  ,  c  )  ;  }  else  if  (  isEndOfFile  (  c  )  )  {      tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  there  is  data  at  EOF  }  else  {      simpleTokenLexer  (  tkn  ,  c  )  ;  }  }  return  tkn  ;  }    [METHOD]  nextToken  [TYPE]  Token  [PARAMETER]  Token  tkn  [CLASS]  CSVLexer    [TYPE]  boolean  eol  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  lastChar  
[REPLACE]  while  (  true  )  {	[BUGGY]  while  (  false  )  {[CE]  unreachable  statement  [CONTEXT]  private  Token  simpleTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {  [ATTENTION]  while  (  false  )  {  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  break  ;  }  else  if  (  isEndOfFile  (  c  )  )  {    tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  break  ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  break  ;  }  else  if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  {  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  c  =  in  .  read  (  )  ;  }  if  (  surroundingSpacesIgnored  )  {  trimTrailingSpaces  (  tkn  .  content  )  ;  }  return  tkn  ;  }    [METHOD]  simpleTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  
[REPLACE]  if  (  isEndOfLine  (  c  )  )  {	[BUGGY]  if  (  isEscape  (  c  )  )  {[FE]  AssertionFailedError    Token  type  expected:<EORECORD>  but  was:<TOKEN>  assertTokenEquals(TOKEN  ,   "1 "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "2 "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "3 "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   " "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "b  x "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "c "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "d "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "e "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   " "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  private  Token  simpleTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {  while  (  true  )  {  [ATTENTION]  if  (  isEscape  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  break  ;  }  else  if  (  isEndOfFile  (  c  )  )  {    tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  break  ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  break  ;  }  else  if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  {  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  c  =  in  .  read  (  )  ;  }  if  (  surroundingSpacesIgnored  )  {  trimTrailingSpaces  (  tkn  .  content  )  ;  }  return  tkn  ;  }    [METHOD]  simpleTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  
[REPLACE]  }  else  if  (  isEndOfFile  (  c  )  )  {	[BUGGY]    if  (  isEndOfFile  (  c  )  )  {[NO-ERROR]  [CONTEXT]  private  Token  simpleTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {  while  (  true  )  {  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  break  ;  [ATTENTION]  }if  (  isEndOfFile  (  c  )  )  {    tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  break  ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  break  ;  }  else  if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  {  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  c  =  in  .  read  (  )  ;  }  if  (  surroundingSpacesIgnored  )  {  trimTrailingSpaces  (  tkn  .  content  )  ;  }  return  tkn  ;  }    [METHOD]  simpleTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  
[REPLACE]  }  else  if  (  isDelimiter  (  c  )  )  {	[BUGGY]    if  (  isDelimiter  (  c  )  )  {[NO-ERROR]  [CONTEXT]  private  Token  simpleTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {  while  (  true  )  {  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  break  ;  }  else  if  (  isEndOfFile  (  c  )  )  {    tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  break  ;  [ATTENTION]  }if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  break  ;  }  else  if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  {  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  c  =  in  .  read  (  )  ;  }  if  (  surroundingSpacesIgnored  )  {  trimTrailingSpaces  (  tkn  .  content  )  ;  }  return  tkn  ;  }    [METHOD]  simpleTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  
[REMOVE]  	[BUGGY]  if  (  isEncapsulator  (  c  )  )  {      encapsulatedTokenLexer  (  tkn  ,  c  )  ;  }else      if  (  isEndOfFile  (  c  )  )  {          tkn  .  type  =  EOF  ;          tkn  .  isReady  =  true  ;      }else  {          simpleTokenLexer  (  tkn  ,  c  )  ;      }[FE]  null  assertTokenEquals(TOKEN  ,   "abc "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "def "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "hijk "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "lmnop "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "qrst "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "uv "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "wxy "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "z "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   " "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   " "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  private  Token  simpleTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {  while  (  true  )  {  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  break  ;  }  else  if  (  isEndOfFile  (  c  )  )  {    tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  break  ;  [ATTENTION]  }  else  if  (  isDelimiter  (  c  )  )  {  if  (  isEncapsulator  (  c  )  )  {  encapsulatedTokenLexer  (  tkn  ,  c  )    ;  }else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  }else  {  simpleTokenLexer  (  tkn  ,  c  )    ;  }//  end  of  token  tkn  .  type  =  TOKEN  ;  break  ;  }  else  if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  {  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  c  =  in  .  read  (  )  ;  }  if  (  surroundingSpacesIgnored  )  {  trimTrailingSpaces  (  tkn  .  content  )  ;  }  return  tkn  ;      [METHOD]  simpleTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  
[REPLACE]  }  else  if  (  isEscape  (  c  )  )  {	[BUGGY]    if  (  isEscape  (  c  )  )  {[NO-ERROR]  [CONTEXT]  private  Token  simpleTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {  while  (  true  )  {  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  break  ;  }  else  if  (  isEndOfFile  (  c  )  )  {    tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  break  ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  break  ;  [ATTENTION]  }if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  {  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  c  =  in  .  read  (  )  ;  }  if  (  surroundingSpacesIgnored  )  {  trimTrailingSpaces  (  tkn  .  content  )  ;  }  return  tkn  ;  }    [METHOD]  simpleTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  
[REPLACE]  tkn  .  content  .  append  (  (  char  )  c  )  ;	[BUGGY]  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  [FE]  AssertionFailedError    Token  content  expected:<[abc]>  but  was:<[  assertTokenEquals(TOKEN  ,   "abc "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "def "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "hijk "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "lmnop "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "qrst "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "uv "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "wxy "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "z "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   " "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   " "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  }  else  if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  {  [ATTENTION]  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )    ;  }    [METHOD]  simpleTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  
[ADD]  tkn  .  content  .  append  (  (  char  )  c  )  ;	[BUGGY]  [FE]  AssertionFailedError    Token  content  expected:<[abc]>  but  was:<[]>  assertTokenEquals(TOKEN  ,   "abc "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "def "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "hijk "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "lmnop "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "qrst "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "uv "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "wxy "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "z "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   " "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   " "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  }  else  if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  {  [ATTENTION]  }    [METHOD]  simpleTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  
[REPLACE]  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;	[BUGGY]  tkn  .  content  .  append  (  (  char  )  c  )  ;  [FE]  null  assertTrue(records.size()  >  0)  ;  assertTrue(CSVPrinterTest.equals(res  ,  records))  ;  [CONTEXT]  private  Token  simpleTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {  while  (  true  )  {  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  break  ;  }  else  if  (  isEndOfFile  (  c  )  )  {    tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  break  ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  break  ;  }  else  if  (  isEscape  (  c  )  )  {  [ATTENTION]  tkn  .  content  .  append  (  (  char  )  c  )    ;  }  else  {  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  c  =  in  .  read  (  )  ;  }  if  (  surroundingSpacesIgnored  )  {  trimTrailingSpaces  (  tkn  .  content  )  ;  }  return  tkn  ;  }    [METHOD]  simpleTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  
[REPLACE]  tkn  .  type  =  TOKEN;	[BUGGY]  tkn  .  type  =  EOF  ;    ;  [FE]  AssertionFailedError    Token  type  expected:<TOKEN>  but  was:<EOF>  assertTokenEquals(TOKEN  ,   "abc "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "def "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "hijk "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "lmnop "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "qrst "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "uv "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "wxy "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "z "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   " "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   " "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  private  Token  simpleTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {  while  (  true  )  {  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  break  ;  }  else  if  (  isEndOfFile  (  c  )  )  {    tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  break  ;  }  else  if  (  isDelimiter  (  c  )  )  {    [ATTENTION]  tkn  .  type  =  EOF  ;    ;  break  ;  }  else  if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  {  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  c  =  in  .  read  (  )  ;  }  if  (  surroundingSpacesIgnored  )  {  trimTrailingSpaces  (  tkn  .  content  )  ;  }  return  tkn  ;  }    [METHOD]  simpleTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  
[REPLACE]  }  else  if  (  isEscape  (  c  )  )  {	[BUGGY]    else  {[CE]  'else'  without  'if'  [CONTEXT]  private  Token  simpleTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {  while  (  true  )  {  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  break  ;  }  else  if  (  isEndOfFile  (  c  )  )  {    tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  break  ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  break  ;  [ATTENTION]  }else  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  {  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  c  =  in  .  read  (  )  ;  }  if  (  surroundingSpacesIgnored  )  {  trimTrailingSpaces  (  tkn  .  content  )  ;  }  return  tkn  ;  }    [METHOD]  simpleTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  
[ADD]  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;	[BUGGY]  [FE]  null  assertTrue(records.size()  >  0)  ;  assertTrue(CSVPrinterTest.equals(res  ,  records))  ;  [CONTEXT]  private  Token  simpleTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {  while  (  true  )  {  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  break  ;  }  else  if  (  isEndOfFile  (  c  )  )  {    tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  break  ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  break  ;  }  else  if  (  isEscape  (  c  )  )  {  [ATTENTION]  }  else  {  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  c  =  in  .  read  (  )  ;  }  if  (  surroundingSpacesIgnored  )  {  trimTrailingSpaces  (  tkn  .  content  )  ;  }  return  tkn  ;  }    [METHOD]  simpleTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  
[REPLACE]  tkn  .  type  =  EOF;	[BUGGY]  tkn  .  type  =  TOKEN  ;    ;  [FE]  AssertionFailedError    Token  type  expected:<EOF>  but  was:<TOKEN>  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "  foo "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "  foo   "  ,  parser.nextToken(new  Token()))  ;  //      assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "b "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  private  Token  simpleTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {  while  (  true  )  {  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  break  ;  }  else  if  (  isEndOfFile  (  c  )  )  {    [ATTENTION]  tkn  .  type  =  TOKEN  ;    ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  break  ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  break  ;  }  else  if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  {  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  c  =  in  .  read  (  )  ;  }  if  (  surroundingSpacesIgnored  )  {  trimTrailingSpaces  (  tkn  .  content  )  ;  }  return  tkn  ;  }    [METHOD]  simpleTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  
[REPLACE]  tkn  .  isReady  =  true;	[BUGGY]  tkn  .  isReady  =  false  ;  [FE]  null  assertEquals(0  ,  parser.getLineNumber())  ;  assertNotNull(parser.getRecord())  ;  assertEquals(1  ,  parser.getLineNumber())  ;  assertEquals(2  ,  parser.getLineNumber())  ;  assertNull(parser.getRecord())  ;  [CONTEXT]  private  Token  simpleTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {  while  (  true  )  {  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  break  ;  }  else  if  (  isEndOfFile  (  c  )  )  {    tkn  .  type  =  EOF  ;  [ATTENTION]  tkn  .  isReady  =  false  ;  break  ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  break  ;  }  else  if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  {  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  c  =  in  .  read  (  )  ;  }  if  (  surroundingSpacesIgnored  )  {  trimTrailingSpaces  (  tkn  .  content  )  ;  }  return  tkn  ;  }    [METHOD]  simpleTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  
[REPLACE]  tkn  .  type  =  EORECORD;	[BUGGY]  tkn  .  type    =  null  ;  [FE]  AssertionFailedError    Token  type  expected:<EORECORD>  but  was:<null>  assertTokenEquals(TOKEN  ,   "1 "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "2 "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "3 "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   " "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "b  x "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "c "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "d "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "e "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   " "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  private  Token  simpleTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {  while  (  true  )  {  if  (  isEndOfLine  (  c  )  )  {    [ATTENTION]  tkn  .  type  =  null  ;  break  ;  }  else  if  (  isEndOfFile  (  c  )  )  {    tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  break  ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  break  ;  }  else  if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  {  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  c  =  in  .  read  (  )  ;  }  if  (  surroundingSpacesIgnored  )  {  trimTrailingSpaces  (  tkn  .  content  )  ;  }  return  tkn  ;  }    [METHOD]  simpleTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  
[REPLACE]  }  else  if  (  isEndOfFile  (  c  )  )  {	[BUGGY]    else  {[CE]  'else'  without  'if'  [CONTEXT]  private  Token  simpleTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {  while  (  true  )  {  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  break  ;  [ATTENTION]  }else  {    tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  break  ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  break  ;  }  else  if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  {  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  c  =  in  .  read  (  )  ;  }  if  (  surroundingSpacesIgnored  )  {  trimTrailingSpaces  (  tkn  .  content  )  ;  }  return  tkn  ;  }    [METHOD]  simpleTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  
[ADD]  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF;  tkn  .  isReady  =  true;  break;	[BUGGY]    tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  break  ;  [CE]  'else'  without  'if'  [CONTEXT]  private  Token  simpleTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {  while  (  true  )  {  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  break  ;  [ATTENTION]  }  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  break  ;      }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  break  ;  }  else  if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  {  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  c  =  in  .  read  (  )  ;  }  if  (  surroundingSpacesIgnored  )  {  trimTrailingSpaces  (  tkn  .  content  )  ;  }  return  tkn  ;  }    [METHOD]  simpleTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  
[REPLACE]  }  else  if  (  isDelimiter  (  c  )  )  {	[BUGGY]    else  {[CE]  'else'  without  'if'  [CONTEXT]  private  Token  simpleTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {  while  (  true  )  {  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  break  ;  }  else  if  (  isEndOfFile  (  c  )  )  {    tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  break  ;  [ATTENTION]  }else  {    tkn  .  type  =  TOKEN  ;  break  ;  }  else  if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  {  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  c  =  in  .  read  (  )  ;  }  if  (  surroundingSpacesIgnored  )  {  trimTrailingSpaces  (  tkn  .  content  )  ;  }  return  tkn  ;  }    [METHOD]  simpleTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  
[REMOVE]  	[BUGGY]  int  c  =  in  .  read  (  )  ;  [CE]  variable  c  is  already  defined  in  method  simpleTokenLexer(Token  ,  int)  [CONTEXT]  private  Token  simpleTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {  while  (  true  )  {  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  break  ;  }  else  if  (  isEndOfFile  (  c  )  )  {    tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  break  ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  break  ;  }  else  if  (  isEscape  (  c  )  )  {  [ATTENTION]  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;    int  c  =  in  .  read  (  )    ;  }  else  {  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  c  =  in  .  read  (  )  ;  }  if  (  surroundingSpacesIgnored  )  {  trimTrailingSpaces  (  tkn  .  content  )  ;  }  return  tkn  ;      [METHOD]  simpleTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  
[REPLACE]  tkn  .  type  =  EORECORD;	[BUGGY]  tkn  .  type    =    tkn  .  type  ;  [FE]  AssertionFailedError    Token  type  expected:<EORECORD>  but  was:<TOKEN>  assertTokenEquals(TOKEN  ,   "1 "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "2 "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "3 "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   " "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "b  x "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "c "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "d "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "e "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   " "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  private  Token  simpleTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {  while  (  true  )  {  if  (  isEndOfLine  (  c  )  )  {    [ATTENTION]  tkn  .  type  =  tkn  .  type  ;  break  ;  }  else  if  (  isEndOfFile  (  c  )  )  {    tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  break  ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  break  ;  }  else  if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  {  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  c  =  in  .  read  (  )  ;  }  if  (  surroundingSpacesIgnored  )  {  trimTrailingSpaces  (  tkn  .  content  )  ;  }  return  tkn  ;  }    [METHOD]  simpleTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  
[ADD]  tkn  .  type  =  EORECORD;	[BUGGY]  [FE]  AssertionFailedError    Token  type  expected:<EORECORD>  but  was:<TOKEN>  assertTokenEquals(TOKEN  ,   "1 "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "2 "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "3 "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   " "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "b  x "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "c "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "d "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "e "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   " "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  private  Token  simpleTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {  while  (  true  )  {  if  (  isEndOfLine  (  c  )  )  {    [ATTENTION]  break  ;  }  else  if  (  isEndOfFile  (  c  )  )  {    tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  break  ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  break  ;  }  else  if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  {  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  c  =  in  .  read  (  )  ;  }  if  (  surroundingSpacesIgnored  )  {  trimTrailingSpaces  (  tkn  .  content  )  ;  }  return  tkn  ;  }    [METHOD]  simpleTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  
[ADD]  tkn  .  isReady  =  true;	[BUGGY]  [FE]  null  assertEquals(0  ,  parser.getLineNumber())  ;  assertNotNull(parser.getRecord())  ;  assertEquals(1  ,  parser.getLineNumber())  ;  assertEquals(2  ,  parser.getLineNumber())  ;  assertNull(parser.getRecord())  ;  [CONTEXT]  private  Token  simpleTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {  while  (  true  )  {  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  break  ;  }  else  if  (  isEndOfFile  (  c  )  )  {    tkn  .  type  =  EOF  ;  [ATTENTION]  break  ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  break  ;  }  else  if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  {  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  c  =  in  .  read  (  )  ;  }  if  (  surroundingSpacesIgnored  )  {  trimTrailingSpaces  (  tkn  .  content  )  ;  }  return  tkn  ;  }    [METHOD]  simpleTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  
[REPLACE]  c  =  in  .  read  (  )  ;	[BUGGY]  c  =  in  .  readAgain  (  )  ;    ;  [FE]  [CONTEXT]  private  Token  simpleTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {  while  (  true  )  {  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  break  ;  }  else  if  (  isEndOfFile  (  c  )  )  {    tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  break  ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  break  ;  }  else  if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  {  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  [ATTENTION]  c  =  in  .  readAgain  (  )    ;    ;  }  if  (  surroundingSpacesIgnored  )  {  trimTrailingSpaces  (  tkn  .  content  )  ;  }  return  tkn  ;  }    [METHOD]  simpleTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  
[REMOVE]  	[BUGGY]  if  (  eol  )  {      tkn  .  type  =  EORECORD  ;  }else      if  (  isEncapsulator  (  c  )  )  {          encapsulatedTokenLexer  (  tkn  ,  c  )  ;      }else          if  (  isEndOfFile  (  c  )  )  {              tkn  .  type  =  EOF  ;              tkn  .  isReady  =  true  ;          }else  {              simpleTokenLexer  (  tkn  ,  c  )  ;          }[CE]  cannot  find  symbol  eol  [CONTEXT]  private  Token  simpleTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {  while  (  true  )  {  [ATTENTION]  if  (  isEndOfLine  (  c  )  )  {  if  (  eol  )  {  tkn  .  type  =  EORECORD  ;  }else  if  (  isEncapsulator  (  c  )  )  {  encapsulatedTokenLexer  (  tkn  ,  c  )    ;  }else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  }else  {  simpleTokenLexer  (  tkn  ,  c  )    ;  }//  end  of  record  tkn  .  type  =  EORECORD  ;  break  ;  }  else  if  (  isEndOfFile  (  c  )  )  {    tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  break  ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  break  ;  }  else  if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  {  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  c  =  in  .  read  (  )  ;  }  if  (  surroundingSpacesIgnored  )  {  trimTrailingSpaces  (  tkn  .  content  )  ;  }  return  tkn  ;      [METHOD]  simpleTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  
[REPLACE]  }  else  if  (  isEndOfFile  (  c  )  )  {	[BUGGY]  else  if  (  isDelimiter  (  c  )  )  {[FE]  [CONTEXT]  private  Token  simpleTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {  while  (  true  )  {  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  break  ;  [ATTENTION]  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  break  ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  break  ;  }  else  if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  {  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  c  =  in  .  read  (  )  ;  }  if  (  surroundingSpacesIgnored  )  {  trimTrailingSpaces  (  tkn  .  content  )  ;  }  return  tkn  ;  }    [METHOD]  simpleTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  
[REMOVE]  	[BUGGY]  if  (  isDelimiter  (  c  )  )  {      tkn  .  type  =  TOKEN  ;      break  ;  }else      if  (  isEscape  (  c  )  )  {          append  (  (  (  char  )    (  readEscape  (  c  )  )  )  )  ;      }else  {          append  (  (  (  char  )    (  c  )  )  )  ;      }[CE]  cannot  find  symbol  [CONTEXT]  private  Token  simpleTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {  while  (  true  )  {  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  break  ;  }  else  if  (  isEndOfFile  (  c  )  )  {    tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  break  ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  break  ;  [ATTENTION]  }  else  if  (  isEscape  (  c  )  )  {  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  break  ;  }else  if  (  isEscape  (  c  )  )  {  append  (  (  (  char  )    (  readEscape  (  c  )  )  )  )    ;  }else  {  append  (  (  (  char  )    (  c  )  )  )    ;  }tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  {  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  c  =  in  .  read  (  )  ;  }  if  (  surroundingSpacesIgnored  )  {  trimTrailingSpaces  (  tkn  .  content  )  ;  }  return  tkn  ;      [METHOD]  simpleTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  
[ADD]  tkn  .  type  =  TOKEN;	[BUGGY]  [FE]  AssertionFailedError    Token  type  expected:<TOKEN>  but  was:<EOF>  assertTokenEquals(TOKEN  ,   "abc "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "def "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "hijk "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "lmnop "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "qrst "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "uv "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "wxy "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "z "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   " "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   " "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  private  Token  simpleTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {  while  (  true  )  {  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  break  ;  }  else  if  (  isEndOfFile  (  c  )  )  {    tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  break  ;  }  else  if  (  isDelimiter  (  c  )  )  {    [ATTENTION]  break  ;  }  else  if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  {  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  c  =  in  .  read  (  )  ;  }  if  (  surroundingSpacesIgnored  )  {  trimTrailingSpaces  (  tkn  .  content  )  ;  }  return  tkn  ;  }    [METHOD]  simpleTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  
[ADD]  else  if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  {  tkn  .  content  .  append  (  (  char  )  c  )  ;  }	[BUGGY]    tkn  .  content  .  append  (  (  char  )  c  )  ;  [FE]  null  assertTrue(records.size()  >  0)  ;  assertTrue(CSVPrinterTest.equals(res  ,  records))  ;  [CONTEXT]  private  Token  simpleTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {  while  (  true  )  {  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  break  ;  }  else  if  (  isEndOfFile  (  c  )  )  {    tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  break  ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  break  ;  [ATTENTION]  }  tkn  .  content  .  append  (  (  char  )  c  )    ;        c  =  in  .  read  (  )  ;  }  if  (  surroundingSpacesIgnored  )  {  trimTrailingSpaces  (  tkn  .  content  )  ;  }  return  tkn  ;  }    [METHOD]  simpleTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  
[ADD]  else  if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  {  tkn  .  content  .  append  (  (  char  )  c  )  ;  }	[BUGGY]    tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  [FE]  AssertionFailedError    Token  content  expected:<[abc]>  but  was:<[  assertTokenEquals(TOKEN  ,   "abc "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "def "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "hijk "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "lmnop "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "qrst "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "uv "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "wxy "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "z "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   " "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   " "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  private  Token  simpleTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {  while  (  true  )  {  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  break  ;  }  else  if  (  isEndOfFile  (  c  )  )  {    tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  break  ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  break  ;  [ATTENTION]  }  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )    ;  tkn  .  content  .  append  (  (  char  )  c  )    ;        c  =  in  .  read  (  )  ;  }  if  (  surroundingSpacesIgnored  )  {  trimTrailingSpaces  (  tkn  .  content  )  ;  }  return  tkn  ;  }    [METHOD]  simpleTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  
[ADD]  else  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN;  break;	[BUGGY]    tkn  .  type  =  TOKEN  ;  break  ;  [CE]  'else'  without  'if'  [CONTEXT]  private  Token  simpleTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {  while  (  true  )  {  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  break  ;  }  else  if  (  isEndOfFile  (  c  )  )  {    tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  break  ;  [ATTENTION]  }  tkn  .  type  =  TOKEN  ;  break  ;      }  else  if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  {  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  c  =  in  .  read  (  )  ;  }  if  (  surroundingSpacesIgnored  )  {  trimTrailingSpaces  (  tkn  .  content  )  ;  }  return  tkn  ;  }    [METHOD]  simpleTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  
[ADD]  tkn  .  type  =  EOF;  tkn  .  isReady  =  true;	[BUGGY]  tkn  .  isReady  =  true  ;  [FE]  [CONTEXT]  private  Token  simpleTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {  while  (  true  )  {  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  break  ;  }  else  if  (  isEndOfFile  (  c  )  )  {    [ATTENTION]  tkn  .  isReady  =  true  ;    break  ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  break  ;  }  else  if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  {  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  c  =  in  .  read  (  )  ;  }  if  (  surroundingSpacesIgnored  )  {  trimTrailingSpaces  (  tkn  .  content  )  ;  }  return  tkn  ;  }    [METHOD]  simpleTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  
[REPLACE]  }  else  if  (  isEscape  (  c  )  )  {	[BUGGY]  if  (  isEscape  (  c  )  )  {[CE]  illegal  start  of  expression  [CONTEXT]  private  Token  simpleTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {  while  (  true  )  {  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  break  ;  }  else  if  (  isEndOfFile  (  c  )  )  {    tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  break  ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  break  ;  [ATTENTION]  if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  {  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  c  =  in  .  read  (  )  ;  }  if  (  surroundingSpacesIgnored  )  {  trimTrailingSpaces  (  tkn  .  content  )  ;  }  return  tkn  ;  }    [METHOD]  simpleTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  
[ADD]  tkn  .  isReady  =  true;  break;	[BUGGY]  [FE]  [CONTEXT]  private  Token  simpleTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {  while  (  true  )  {  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  break  ;  }  else  if  (  isEndOfFile  (  c  )  )  {    tkn  .  type  =  EOF  ;  [ATTENTION]    }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  break  ;  }  else  if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  {  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  c  =  in  .  read  (  )  ;  }  if  (  surroundingSpacesIgnored  )  {  trimTrailingSpaces  (  tkn  .  content  )  ;  }  return  tkn  ;  }    [METHOD]  simpleTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  
[REPLACE]  if  (  surroundingSpacesIgnored  )  {	[BUGGY]  if  (  isEscape  (  c  )  )  {[FE]  AssertionFailedError    Token  content  expected:<uv[]>  but  was:<uv[  ]>  assertTokenEquals(TOKEN  ,   "abc "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "def "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "hijk "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "lmnop "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "qrst "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "uv "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "wxy "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "z "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   " "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   " "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  private  Token  simpleTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {  while  (  true  )  {  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  break  ;  }  else  if  (  isEndOfFile  (  c  )  )  {    tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  break  ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  break  ;  }  else  if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  {  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  c  =  in  .  read  (  )  ;  }  [ATTENTION]  if  (  isEscape  (  c  )  )  {  trimTrailingSpaces  (  tkn  .  content  )  ;  }  return  tkn  ;  }    [METHOD]  simpleTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  
[REPLACE]  trimTrailingSpaces  (  tkn  .  content  )  ;	[BUGGY]  simpleTokenLexer  (  tkn  ,  c  )  ;  [FE]  null  assertTokenEquals(TOKEN  ,   "abc "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "def "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "hijk "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "lmnop "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "qrst "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "uv "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "wxy "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "z "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   " "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   " "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  private  Token  simpleTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {  while  (  true  )  {  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  break  ;  }  else  if  (  isEndOfFile  (  c  )  )  {    tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  break  ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  break  ;  }  else  if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  {  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  c  =  in  .  read  (  )  ;  }  if  (  surroundingSpacesIgnored  )  {  [ATTENTION]  simpleTokenLexer  (  tkn  ,  c  )    ;  }  return  tkn  ;  }    [METHOD]  simpleTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  
[ADD]  trimTrailingSpaces  (  tkn  .  content  )  ;	[BUGGY]  [FE]  AssertionFailedError    Token  content  expected:<uv[]>  but  was:<uv[  ]>  assertTokenEquals(TOKEN  ,   "abc "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "def "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "hijk "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "lmnop "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "qrst "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "uv "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "wxy "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "z "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   " "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   " "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  private  Token  simpleTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {  while  (  true  )  {  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  break  ;  }  else  if  (  isEndOfFile  (  c  )  )  {    tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  break  ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  break  ;  }  else  if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  {  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  c  =  in  .  read  (  )  ;  }  if  (  surroundingSpacesIgnored  )  {  [ATTENTION]  }  return  tkn  ;  }    [METHOD]  simpleTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  
[REPLACE]  int  startLineNumber  =  getLineNumber  (  )  ;	[BUGGY]  int  lastChar  =  in  .  readAgain  (  )  ;  [CE]  cannot  find  symbol  startLineNumber  [CONTEXT]  private  Token  encapsulatedTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {    [ATTENTION]  int  lastChar  =  in  .  readAgain  (  )    ;      while  (  true  )  {  c  =  in  .  read  (  )  ;    if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  if  (  isEncapsulator  (  c  )  )  {  if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (   "  (  line   "  +  getLineNumber  (  )  +   "  )  invalid  char  between  encapsulated  token  and  delimiter "  )  ;  }  }  }  }  else  if  (  isEndOfFile  (  c  )  )  {    throw  new  IOException  (   "  (  startline   "  +  startLineNumber  +   "  )  EOF  reached  before  encapsulated  token  finished "  )  ;  }  else  {    tkn  .  content  .  append  (  (  char  )  c  )  ;  }  }  }    [METHOD]  encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber  
[ADD]  int  startLineNumber  =  getLineNumber  (  )  ;	[BUGGY]  [CE]  cannot  find  symbol  startLineNumber  [CONTEXT]  private  Token  encapsulatedTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {    [ATTENTION]      while  (  true  )  {  c  =  in  .  read  (  )  ;    if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  if  (  isEncapsulator  (  c  )  )  {  if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (   "  (  line   "  +  getLineNumber  (  )  +   "  )  invalid  char  between  encapsulated  token  and  delimiter "  )  ;  }  }  }  }  else  if  (  isEndOfFile  (  c  )  )  {    throw  new  IOException  (   "  (  startline   "  +  startLineNumber  +   "  )  EOF  reached  before  encapsulated  token  finished "  )  ;  }  else  {    tkn  .  content  .  append  (  (  char  )  c  )  ;  }  }  }    [METHOD]  encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber  
[ADD]  while  (  true  )  {  c  =  in  .  read  (  )  ;	[BUGGY]  [CE]  class  ,  interface  ,  or  enum  expected  [CONTEXT]  private  Token  encapsulatedTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {    int  startLineNumber  =  getLineNumber  (  )  ;      [ATTENTION]    if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  if  (  isEncapsulator  (  c  )  )  {  if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (   "  (  line   "  +  getLineNumber  (  )  +   "  )  invalid  char  between  encapsulated  token  and  delimiter "  )  ;  }  }  }  }  else  if  (  isEndOfFile  (  c  )  )  {    throw  new  IOException  (   "  (  startline   "  +  startLineNumber  +   "  )  EOF  reached  before  encapsulated  token  finished "  )  ;  }  else  {    tkn  .  content  .  append  (  (  char  )  c  )  ;  }  }  }    [METHOD]  encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber  
[REPLACE]  while  (  true  )  {	[BUGGY]  while  (  false  )  {[CE]  unreachable  statement  [CONTEXT]  private  Token  encapsulatedTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {    int  startLineNumber  =  getLineNumber  (  )  ;      while  (  true  )  {  c  =  in  .  read  (  )  ;    if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  if  (  isEncapsulator  (  c  )  )  {  if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    [ATTENTION]  while  (  false  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (   "  (  line   "  +  getLineNumber  (  )  +   "  )  invalid  char  between  encapsulated  token  and  delimiter "  )  ;  }  }  }  }  else  if  (  isEndOfFile  (  c  )  )  {    throw  new  IOException  (   "  (  startline   "  +  startLineNumber  +   "  )  EOF  reached  before  encapsulated  token  finished "  )  ;  }  else  {    tkn  .  content  .  append  (  (  char  )  c  )  ;  }  }  }    [METHOD]  encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber  
[REPLACE]  if  (  isDelimiter  (  c  )  )  {	[BUGGY]  if  (  isEscape  (  c  )  )  {[FE]  (line  0)  invalid  char  between  encapsulated  token  and  delimiter  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "  foo "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "  foo   "  ,  parser.nextToken(new  Token()))  ;  //      assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "b "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  private  Token  encapsulatedTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {    int  startLineNumber  =  getLineNumber  (  )  ;      while  (  true  )  {  c  =  in  .  read  (  )  ;    if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  if  (  isEncapsulator  (  c  )  )  {  if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  [ATTENTION]  if  (  isEscape  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (   "  (  line   "  +  getLineNumber  (  )  +   "  )  invalid  char  between  encapsulated  token  and  delimiter "  )  ;  }  }  }  }  else  if  (  isEndOfFile  (  c  )  )  {    throw  new  IOException  (   "  (  startline   "  +  startLineNumber  +   "  )  EOF  reached  before  encapsulated  token  finished "  )  ;  }  else  {    tkn  .  content  .  append  (  (  char  )  c  )  ;  }  }  }    [METHOD]  encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber  
[REPLACE]  }  else  if  (  isEndOfFile  (  c  )  )  {	[BUGGY]    if  (  isEndOfFile  (  c  )  )  {[NO-ERROR]  [CONTEXT]  private  Token  encapsulatedTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {    int  startLineNumber  =  getLineNumber  (  )  ;      while  (  true  )  {  c  =  in  .  read  (  )  ;    if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  if  (  isEncapsulator  (  c  )  )  {  if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  [ATTENTION]  }if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (   "  (  line   "  +  getLineNumber  (  )  +   "  )  invalid  char  between  encapsulated  token  and  delimiter "  )  ;  }  }  }  }  else  if  (  isEndOfFile  (  c  )  )  {    throw  new  IOException  (   "  (  startline   "  +  startLineNumber  +   "  )  EOF  reached  before  encapsulated  token  finished "  )  ;  }  else  {    tkn  .  content  .  append  (  (  char  )  c  )  ;  }  }  }    [METHOD]  encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber  
[ADD]  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF;  tkn  .  isReady  =  true;  return  tkn;	[BUGGY]    tkn  .  isReady  =  true  ;  return  tkn  ;  [CE]  'else'  without  'if'  [CONTEXT]  private  Token  encapsulatedTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {    int  startLineNumber  =  getLineNumber  (  )  ;      while  (  true  )  {  c  =  in  .  read  (  )  ;    if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  if  (  isEncapsulator  (  c  )  )  {  if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  [ATTENTION]  }  tkn  .  isReady  =  true  ;  return  tkn  ;      }  else  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (   "  (  line   "  +  getLineNumber  (  )  +   "  )  invalid  char  between  encapsulated  token  and  delimiter "  )  ;  }  }  }  }  else  if  (  isEndOfFile  (  c  )  )  {    throw  new  IOException  (   "  (  startline   "  +  startLineNumber  +   "  )  EOF  reached  before  encapsulated  token  finished "  )  ;  }  else  {    tkn  .  content  .  append  (  (  char  )  c  )  ;  }  }  }    [METHOD]  encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber  
[REPLACE]  }  else  if  (  isEndOfLine  (  c  )  )  {	[BUGGY]    else  {[CE]  'else'  without  'if'  [CONTEXT]  private  Token  encapsulatedTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {    int  startLineNumber  =  getLineNumber  (  )  ;      while  (  true  )  {  c  =  in  .  read  (  )  ;    if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  if  (  isEncapsulator  (  c  )  )  {  if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  [ATTENTION]  }else  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (   "  (  line   "  +  getLineNumber  (  )  +   "  )  invalid  char  between  encapsulated  token  and  delimiter "  )  ;  }  }  }  }  else  if  (  isEndOfFile  (  c  )  )  {    throw  new  IOException  (   "  (  startline   "  +  startLineNumber  +   "  )  EOF  reached  before  encapsulated  token  finished "  )  ;  }  else  {    tkn  .  content  .  append  (  (  char  )  c  )  ;  }  }  }    [METHOD]  encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber  
[REPLACE]  }  else  if  (  !isWhitespace  (  c  )  )  {	[BUGGY]    if  (  isWhitespace  (  c  )  )  {[FE]  (line  2)  invalid  char  between  encapsulated  token  and  delimiter  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "  foo "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "  foo   "  ,  parser.nextToken(new  Token()))  ;  //      assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "b "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  private  Token  encapsulatedTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {    int  startLineNumber  =  getLineNumber  (  )  ;      while  (  true  )  {  c  =  in  .  read  (  )  ;    if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  if  (  isEncapsulator  (  c  )  )  {  if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  [ATTENTION]  }if  (  isWhitespace  (  c  )  )  {    throw  new  IOException  (   "  (  line   "  +  getLineNumber  (  )  +   "  )  invalid  char  between  encapsulated  token  and  delimiter "  )  ;  }  }  }  }  else  if  (  isEndOfFile  (  c  )  )  {    throw  new  IOException  (   "  (  startline   "  +  startLineNumber  +   "  )  EOF  reached  before  encapsulated  token  finished "  )  ;  }  else  {    tkn  .  content  .  append  (  (  char  )  c  )  ;  }  }  }    [METHOD]  encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber  
[ADD]  else  if  (  !isWhitespace  (  c  )  )  {  throw  new  IOException  ( "   ")  ;  }	[BUGGY]  [NO-ERROR]  [CONTEXT]  private  Token  encapsulatedTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {    int  startLineNumber  =  getLineNumber  (  )  ;      while  (  true  )  {  c  =  in  .  read  (  )  ;    if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  if  (  isEncapsulator  (  c  )  )  {  if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  [ATTENTION]  }    }  }  }  else  if  (  isEndOfFile  (  c  )  )  {    throw  new  IOException  (   "  (  startline   "  +  startLineNumber  +   "  )  EOF  reached  before  encapsulated  token  finished "  )  ;  }  else  {    tkn  .  content  .  append  (  (  char  )  c  )  ;  }  }  }    [METHOD]  encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber  
[REPLACE]  throw  new  IOException  ( "   ")  ;	[BUGGY]  return  ;  [CE]  missing  return  value  [CONTEXT]  private  Token  encapsulatedTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {    int  startLineNumber  =  getLineNumber  (  )  ;      while  (  true  )  {  c  =  in  .  read  (  )  ;    if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  if  (  isEncapsulator  (  c  )  )  {  if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    [ATTENTION]  return  ;  }  }  }  }  else  if  (  isEndOfFile  (  c  )  )  {    throw  new  IOException  (   "  (  startline   "  +  startLineNumber  +   "  )  EOF  reached  before  encapsulated  token  finished "  )  ;  }  else  {    tkn  .  content  .  append  (  (  char  )  c  )  ;  }  }  }    [METHOD]  encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber  
[ADD]  throw  new  IOException  ( "   ")  ;	[BUGGY]  [NO-ERROR]  [CONTEXT]  private  Token  encapsulatedTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {    int  startLineNumber  =  getLineNumber  (  )  ;      while  (  true  )  {  c  =  in  .  read  (  )  ;    if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  if  (  isEncapsulator  (  c  )  )  {  if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    [ATTENTION]  }  }  }  }  else  if  (  isEndOfFile  (  c  )  )  {    throw  new  IOException  (   "  (  startline   "  +  startLineNumber  +   "  )  EOF  reached  before  encapsulated  token  finished "  )  ;  }  else  {    tkn  .  content  .  append  (  (  char  )  c  )  ;  }  }  }    [METHOD]  encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber  
[REPLACE]  throw  new  IOException  ( "   ")  ;	[BUGGY]  eol  =  isEndOfLine  (  c  )  ;  [CE]  cannot  find  symbol  eol  [CONTEXT]  private  Token  encapsulatedTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {    int  startLineNumber  =  getLineNumber  (  )  ;      while  (  true  )  {  c  =  in  .  read  (  )  ;    if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  if  (  isEncapsulator  (  c  )  )  {  if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    [ATTENTION]  eol  =  isEndOfLine  (  c  )    ;  }  }  }  }  else  if  (  isEndOfFile  (  c  )  )  {    throw  new  IOException  (   "  (  startline   "  +  startLineNumber  +   "  )  EOF  reached  before  encapsulated  token  finished "  )  ;  }  else  {    tkn  .  content  .  append  (  (  char  )  c  )  ;  }  }  }    [METHOD]  encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber  
[REPLACE]  tkn  .  type  =  EORECORD;	[BUGGY]  tkn  .  type  ;  [CE]  not  a  statement  [CONTEXT]  private  Token  encapsulatedTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {    int  startLineNumber  =  getLineNumber  (  )  ;      while  (  true  )  {  c  =  in  .  read  (  )  ;    if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  if  (  isEncapsulator  (  c  )  )  {  if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    [ATTENTION]  tkn  .  type  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (   "  (  line   "  +  getLineNumber  (  )  +   "  )  invalid  char  between  encapsulated  token  and  delimiter "  )  ;  }  }  }  }  else  if  (  isEndOfFile  (  c  )  )  {    throw  new  IOException  (   "  (  startline   "  +  startLineNumber  +   "  )  EOF  reached  before  encapsulated  token  finished "  )  ;  }  else  {    tkn  .  content  .  append  (  (  char  )  c  )  ;  }  }  }    [METHOD]  encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber  
[REPLACE]  tkn  .  type  =  EORECORD;	[BUGGY]  tkn  .  type    =    tkn  .  type  ;  [FE]  AssertionFailedError    Token  type  expected:<EORECORD>  but  was:<EOF>  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo\n "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "foo\n  baar  ,  ,  ,   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "\n\t  \n "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  private  Token  encapsulatedTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {    int  startLineNumber  =  getLineNumber  (  )  ;      while  (  true  )  {  c  =  in  .  read  (  )  ;    if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  if  (  isEncapsulator  (  c  )  )  {  if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    [ATTENTION]  tkn  .  type  =  tkn  .  type  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (   "  (  line   "  +  getLineNumber  (  )  +   "  )  invalid  char  between  encapsulated  token  and  delimiter "  )  ;  }  }  }  }  else  if  (  isEndOfFile  (  c  )  )  {    throw  new  IOException  (   "  (  startline   "  +  startLineNumber  +   "  )  EOF  reached  before  encapsulated  token  finished "  )  ;  }  else  {    tkn  .  content  .  append  (  (  char  )  c  )  ;  }  }  }    [METHOD]  encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber  
[REPLACE]  tkn  .  type  =  EOF;	[BUGGY]  tkn  .  type  =  TOKEN  ;    ;  [FE]  AssertionFailedError    Token  type  expected:<EOF>  but  was:<TOKEN>  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo\n "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "foo\n  baar  ,  ,  ,   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "\n\t  \n "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  private  Token  encapsulatedTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {    int  startLineNumber  =  getLineNumber  (  )  ;      while  (  true  )  {  c  =  in  .  read  (  )  ;    if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  if  (  isEncapsulator  (  c  )  )  {  if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  [ATTENTION]  tkn  .  type  =  TOKEN  ;    ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (   "  (  line   "  +  getLineNumber  (  )  +   "  )  invalid  char  between  encapsulated  token  and  delimiter "  )  ;  }  }  }  }  else  if  (  isEndOfFile  (  c  )  )  {    throw  new  IOException  (   "  (  startline   "  +  startLineNumber  +   "  )  EOF  reached  before  encapsulated  token  finished "  )  ;  }  else  {    tkn  .  content  .  append  (  (  char  )  c  )  ;  }  }  }    [METHOD]  encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber  
[REPLACE]  tkn  .  isReady  =  true;	[BUGGY]  tkn  .  isReady  =  false  ;  [FE]  array  lengths  differed  ,  expected.length  =  2  actual.length  =  1  assertEquals(res.length  ,  records.size())  ;  assertTrue(records.size()  >  0)  ;  assertArrayEquals(res[i]  ,  records.get(i).values())  ;  [CONTEXT]  private  Token  encapsulatedTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {    int  startLineNumber  =  getLineNumber  (  )  ;      while  (  true  )  {  c  =  in  .  read  (  )  ;    if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  if  (  isEncapsulator  (  c  )  )  {  if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  [ATTENTION]  tkn  .  isReady  =  false  ;  return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (   "  (  line   "  +  getLineNumber  (  )  +   "  )  invalid  char  between  encapsulated  token  and  delimiter "  )  ;  }  }  }  }  else  if  (  isEndOfFile  (  c  )  )  {    throw  new  IOException  (   "  (  startline   "  +  startLineNumber  +   "  )  EOF  reached  before  encapsulated  token  finished "  )  ;  }  else  {    tkn  .  content  .  append  (  (  char  )  c  )  ;  }  }  }    [METHOD]  encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber  
[REPLACE]  }  else  if  (  isEndOfLine  (  c  )  )  {	[BUGGY]    if  (  isEndOfLine  (  c  )  )  {[NO-ERROR]  [CONTEXT]  private  Token  encapsulatedTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {    int  startLineNumber  =  getLineNumber  (  )  ;      while  (  true  )  {  c  =  in  .  read  (  )  ;    if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  if  (  isEncapsulator  (  c  )  )  {  if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  [ATTENTION]  }if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (   "  (  line   "  +  getLineNumber  (  )  +   "  )  invalid  char  between  encapsulated  token  and  delimiter "  )  ;  }  }  }  }  else  if  (  isEndOfFile  (  c  )  )  {    throw  new  IOException  (   "  (  startline   "  +  startLineNumber  +   "  )  EOF  reached  before  encapsulated  token  finished "  )  ;  }  else  {    tkn  .  content  .  append  (  (  char  )  c  )  ;  }  }  }    [METHOD]  encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber  
[REPLACE]  }  else  if  (  !isWhitespace  (  c  )  )  {	[BUGGY]    else  {[FE]  (line  2)  invalid  char  between  encapsulated  token  and  delimiter  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "  foo "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "  foo   "  ,  parser.nextToken(new  Token()))  ;  //      assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "b "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  private  Token  encapsulatedTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {    int  startLineNumber  =  getLineNumber  (  )  ;      while  (  true  )  {  c  =  in  .  read  (  )  ;    if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  if  (  isEncapsulator  (  c  )  )  {  if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  [ATTENTION]  }else  {    throw  new  IOException  (   "  (  line   "  +  getLineNumber  (  )  +   "  )  invalid  char  between  encapsulated  token  and  delimiter "  )  ;  }  }  }  }  else  if  (  isEndOfFile  (  c  )  )  {    throw  new  IOException  (   "  (  startline   "  +  startLineNumber  +   "  )  EOF  reached  before  encapsulated  token  finished "  )  ;  }  else  {    tkn  .  content  .  append  (  (  char  )  c  )  ;  }  }  }    [METHOD]  encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber  
[REPLACE]  tkn  .  type  =  EORECORD;	[BUGGY]  tkn  .  type    =  null  ;  [FE]  AssertionFailedError    Token  type  expected:<EORECORD>  but  was:<null>  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo\n "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "foo\n  baar  ,  ,  ,   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "\n\t  \n "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  private  Token  encapsulatedTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {    int  startLineNumber  =  getLineNumber  (  )  ;      while  (  true  )  {  c  =  in  .  read  (  )  ;    if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  if  (  isEncapsulator  (  c  )  )  {  if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    [ATTENTION]  tkn  .  type  =  null  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (   "  (  line   "  +  getLineNumber  (  )  +   "  )  invalid  char  between  encapsulated  token  and  delimiter "  )  ;  }  }  }  }  else  if  (  isEndOfFile  (  c  )  )  {    throw  new  IOException  (   "  (  startline   "  +  startLineNumber  +   "  )  EOF  reached  before  encapsulated  token  finished "  )  ;  }  else  {    tkn  .  content  .  append  (  (  char  )  c  )  ;  }  }  }    [METHOD]  encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber  
[REPLACE]  tkn  .  type  =  TOKEN;	[BUGGY]  tkn  .  type  =  EOF  ;    ;  [FE]  AssertionFailedError    Token  type  expected:<TOKEN>  but  was:<EOF>  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "  foo "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "  foo   "  ,  parser.nextToken(new  Token()))  ;  //      assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "b "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  private  Token  encapsulatedTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {    int  startLineNumber  =  getLineNumber  (  )  ;      while  (  true  )  {  c  =  in  .  read  (  )  ;    if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  if  (  isEncapsulator  (  c  )  )  {  if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  [ATTENTION]  tkn  .  type  =  EOF  ;    ;  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (   "  (  line   "  +  getLineNumber  (  )  +   "  )  invalid  char  between  encapsulated  token  and  delimiter "  )  ;  }  }  }  }  else  if  (  isEndOfFile  (  c  )  )  {    throw  new  IOException  (   "  (  startline   "  +  startLineNumber  +   "  )  EOF  reached  before  encapsulated  token  finished "  )  ;  }  else  {    tkn  .  content  .  append  (  (  char  )  c  )  ;  }  }  }    [METHOD]  encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber  
[REPLACE]  }  else  if  (  isEndOfFile  (  c  )  )  {	[BUGGY]  else  if  (  isDelimiter  (  c  )  )  {[FE]  (line  6)  invalid  char  between  encapsulated  token  and  delimiter  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo\n "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "foo\n  baar  ,  ,  ,   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "\n\t  \n "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  private  Token  encapsulatedTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {    int  startLineNumber  =  getLineNumber  (  )  ;      while  (  true  )  {  c  =  in  .  read  (  )  ;    if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  if  (  isEncapsulator  (  c  )  )  {  if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  [ATTENTION]  }  else  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (   "  (  line   "  +  getLineNumber  (  )  +   "  )  invalid  char  between  encapsulated  token  and  delimiter "  )  ;  }  }  }  }  else  if  (  isEndOfFile  (  c  )  )  {    throw  new  IOException  (   "  (  startline   "  +  startLineNumber  +   "  )  EOF  reached  before  encapsulated  token  finished "  )  ;  }  else  {    tkn  .  content  .  append  (  (  char  )  c  )  ;  }  }  }    [METHOD]  encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber  
[ADD]  tkn  .  type  =  EORECORD;  return  tkn;	[BUGGY]  [FE]  (line  4)  invalid  char  between  encapsulated  token  and  delimiter  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo\n "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "foo\n  baar  ,  ,  ,   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "\n\t  \n "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  private  Token  encapsulatedTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {    int  startLineNumber  =  getLineNumber  (  )  ;      while  (  true  )  {  c  =  in  .  read  (  )  ;    if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  if  (  isEncapsulator  (  c  )  )  {  if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    [ATTENTION]    }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (   "  (  line   "  +  getLineNumber  (  )  +   "  )  invalid  char  between  encapsulated  token  and  delimiter "  )  ;  }  }  }  }  else  if  (  isEndOfFile  (  c  )  )  {    throw  new  IOException  (   "  (  startline   "  +  startLineNumber  +   "  )  EOF  reached  before  encapsulated  token  finished "  )  ;  }  else  {    tkn  .  content  .  append  (  (  char  )  c  )  ;  }  }  }    [METHOD]  encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber  
[ADD]  else  if  (  isEndOfLine  (  c  )  )  {  tkn  .  type  =  EORECORD;  return  tkn;	[BUGGY]    tkn  .  type  =  EORECORD  ;  return  tkn  ;  [CE]  'else'  without  'if'  [CONTEXT]  private  Token  encapsulatedTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {    int  startLineNumber  =  getLineNumber  (  )  ;      while  (  true  )  {  c  =  in  .  read  (  )  ;    if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  if  (  isEncapsulator  (  c  )  )  {  if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  [ATTENTION]  }  tkn  .  type  =  EORECORD  ;  return  tkn  ;      }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (   "  (  line   "  +  getLineNumber  (  )  +   "  )  invalid  char  between  encapsulated  token  and  delimiter "  )  ;  }  }  }  }  else  if  (  isEndOfFile  (  c  )  )  {    throw  new  IOException  (   "  (  startline   "  +  startLineNumber  +   "  )  EOF  reached  before  encapsulated  token  finished "  )  ;  }  else  {    tkn  .  content  .  append  (  (  char  )  c  )  ;  }  }  }    [METHOD]  encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber  
[REPLACE]  c  =  in  .  read  (  )  ;	[BUGGY]  c  =  in  .  readAgain  (  )  ;    ;  [FE]  (line  0)  invalid  char  between  encapsulated  token  and  delimiter  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "  foo "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "  foo   "  ,  parser.nextToken(new  Token()))  ;  //      assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "b "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  private  Token  encapsulatedTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {    int  startLineNumber  =  getLineNumber  (  )  ;      while  (  true  )  {  c  =  in  .  read  (  )  ;    if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  if  (  isEncapsulator  (  c  )  )  {  if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  [ATTENTION]  c  =  in  .  readAgain  (  )    ;    ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (   "  (  line   "  +  getLineNumber  (  )  +   "  )  invalid  char  between  encapsulated  token  and  delimiter "  )  ;  }  }  }  }  else  if  (  isEndOfFile  (  c  )  )  {    throw  new  IOException  (   "  (  startline   "  +  startLineNumber  +   "  )  EOF  reached  before  encapsulated  token  finished "  )  ;  }  else  {    tkn  .  content  .  append  (  (  char  )  c  )  ;  }  }  }    [METHOD]  encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber  
[REPLACE]  if  (  isEscape  (  c  )  )  {	[BUGGY]  if  (  isDelimiter  (  c  )  )  {[FE]  Token  content  expected:<foo  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo\n "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "foo\n  baar  ,  ,  ,   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "\n\t  \n "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  private  Token  encapsulatedTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {    int  startLineNumber  =  getLineNumber  (  )  ;      while  (  true  )  {  c  =  in  .  read  (  )  ;    [ATTENTION]  if  (  isDelimiter  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  if  (  isEncapsulator  (  c  )  )  {  if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (   "  (  line   "  +  getLineNumber  (  )  +   "  )  invalid  char  between  encapsulated  token  and  delimiter "  )  ;  }  }  }  }  else  if  (  isEndOfFile  (  c  )  )  {    throw  new  IOException  (   "  (  startline   "  +  startLineNumber  +   "  )  EOF  reached  before  encapsulated  token  finished "  )  ;  }  else  {    tkn  .  content  .  append  (  (  char  )  c  )  ;  }  }  }    [METHOD]  encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber  
[ADD]  if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  if  (  isEncapsulator  (  c  )  )  {  if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {	[BUGGY]  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  [CE]  'else'  without  'if'  [CONTEXT]  private  Token  encapsulatedTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {    int  startLineNumber  =  getLineNumber  (  )  ;      while  (  true  )  {  c  =  in  .  read  (  )  ;    [ATTENTION]  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )    ;        c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (   "  (  line   "  +  getLineNumber  (  )  +   "  )  invalid  char  between  encapsulated  token  and  delimiter "  )  ;  }  }  }  }  else  if  (  isEndOfFile  (  c  )  )  {    throw  new  IOException  (   "  (  startline   "  +  startLineNumber  +   "  )  EOF  reached  before  encapsulated  token  finished "  )  ;  }  else  {    tkn  .  content  .  append  (  (  char  )  c  )  ;  }  }  }    [METHOD]  encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber  
[ADD]  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN;  return  tkn;  }  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF;	[BUGGY]  tkn  .  type  =  TOKEN  ;  return  tkn  ;  tkn  .  type  =  EOF  ;  [CE]  'else'  without  'if'  [CONTEXT]  private  Token  encapsulatedTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {    int  startLineNumber  =  getLineNumber  (  )  ;      while  (  true  )  {  c  =  in  .  read  (  )  ;    if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  if  (  isEncapsulator  (  c  )  )  {  if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  [ATTENTION]  tkn  .  type  =  TOKEN  ;  return  tkn  ;  tkn  .  type  =  EOF  ;      tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (   "  (  line   "  +  getLineNumber  (  )  +   "  )  invalid  char  between  encapsulated  token  and  delimiter "  )  ;  }  }  }  }  else  if  (  isEndOfFile  (  c  )  )  {    throw  new  IOException  (   "  (  startline   "  +  startLineNumber  +   "  )  EOF  reached  before  encapsulated  token  finished "  )  ;  }  else  {    tkn  .  content  .  append  (  (  char  )  c  )  ;  }  }  }    [METHOD]  encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber  
[ADD]  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF;  tkn  .  isReady  =  true;  return  tkn;	[BUGGY]    tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  return  tkn  ;  [CE]  'else'  without  'if'  [CONTEXT]  private  Token  encapsulatedTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {    int  startLineNumber  =  getLineNumber  (  )  ;      while  (  true  )  {  c  =  in  .  read  (  )  ;    if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  if  (  isEncapsulator  (  c  )  )  {  if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  [ATTENTION]  }  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  return  tkn  ;      }  else  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (   "  (  line   "  +  getLineNumber  (  )  +   "  )  invalid  char  between  encapsulated  token  and  delimiter "  )  ;  }  }  }  }  else  if  (  isEndOfFile  (  c  )  )  {    throw  new  IOException  (   "  (  startline   "  +  startLineNumber  +   "  )  EOF  reached  before  encapsulated  token  finished "  )  ;  }  else  {    tkn  .  content  .  append  (  (  char  )  c  )  ;  }  }  }    [METHOD]  encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber  
[REPLACE]  }  else  if  (  !isWhitespace  (  c  )  )  {	[BUGGY]  else  if  (  isWhitespace  (  c  )  )  {[FE]  (line  2)  invalid  char  between  encapsulated  token  and  delimiter  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "  foo "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "  foo   "  ,  parser.nextToken(new  Token()))  ;  //      assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "b "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  private  Token  encapsulatedTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {    int  startLineNumber  =  getLineNumber  (  )  ;      while  (  true  )  {  c  =  in  .  read  (  )  ;    if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  if  (  isEncapsulator  (  c  )  )  {  if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  [ATTENTION]  }  else  if  (  isWhitespace  (  c  )  )  {    throw  new  IOException  (   "  (  line   "  +  getLineNumber  (  )  +   "  )  invalid  char  between  encapsulated  token  and  delimiter "  )  ;  }  }  }  }  else  if  (  isEndOfFile  (  c  )  )  {    throw  new  IOException  (   "  (  startline   "  +  startLineNumber  +   "  )  EOF  reached  before  encapsulated  token  finished "  )  ;  }  else  {    tkn  .  content  .  append  (  (  char  )  c  )  ;  }  }  }    [METHOD]  encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber  
[ADD]  tkn  .  type  =  EORECORD;	[BUGGY]  [FE]  AssertionFailedError    Token  type  expected:<EORECORD>  but  was:<EOF>  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo\n "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "foo\n  baar  ,  ,  ,   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "\n\t  \n "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  private  Token  encapsulatedTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {    int  startLineNumber  =  getLineNumber  (  )  ;      while  (  true  )  {  c  =  in  .  read  (  )  ;    if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  if  (  isEncapsulator  (  c  )  )  {  if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    [ATTENTION]  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (   "  (  line   "  +  getLineNumber  (  )  +   "  )  invalid  char  between  encapsulated  token  and  delimiter "  )  ;  }  }  }  }  else  if  (  isEndOfFile  (  c  )  )  {    throw  new  IOException  (   "  (  startline   "  +  startLineNumber  +   "  )  EOF  reached  before  encapsulated  token  finished "  )  ;  }  else  {    tkn  .  content  .  append  (  (  char  )  c  )  ;  }  }  }    [METHOD]  encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber  
[ADD]  tkn  .  type  =  TOKEN;  return  tkn;	[BUGGY]  return  tkn  ;  [FE]  (line  1)  invalid  char  between  encapsulated  token  and  delimiter  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "  foo "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "  foo   "  ,  parser.nextToken(new  Token()))  ;  //      assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "b "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  private  Token  encapsulatedTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {    int  startLineNumber  =  getLineNumber  (  )  ;      while  (  true  )  {  c  =  in  .  read  (  )  ;    if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  if  (  isEncapsulator  (  c  )  )  {  if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  [ATTENTION]  return  tkn  ;    }  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (   "  (  line   "  +  getLineNumber  (  )  +   "  )  invalid  char  between  encapsulated  token  and  delimiter "  )  ;  }  }  }  }  else  if  (  isEndOfFile  (  c  )  )  {    throw  new  IOException  (   "  (  startline   "  +  startLineNumber  +   "  )  EOF  reached  before  encapsulated  token  finished "  )  ;  }  else  {    tkn  .  content  .  append  (  (  char  )  c  )  ;  }  }  }    [METHOD]  encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber  
[REMOVE]  	[BUGGY]  int  c  =  in  .  read  (  )  ;  [CE]  variable  c  is  already  defined  in  method  encapsulatedTokenLexer(Token  ,  int)  [CONTEXT]  private  Token  encapsulatedTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {    int  startLineNumber  =  getLineNumber  (  )  ;      while  (  true  )  {  c  =  in  .  read  (  )  ;    if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  if  (  isEncapsulator  (  c  )  )  {  if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    [ATTENTION]  throw  new  IOException  (   "  (  line   "  +  getLineNumber  (  )  +   "  )  invalid  char  between  encapsulated  token  and  delimiter "  )  ;    int  c  =  in  .  read  (  )    ;  }  }  }  }  else  if  (  isEndOfFile  (  c  )  )  {    throw  new  IOException  (   "  (  startline   "  +  startLineNumber  +   "  )  EOF  reached  before  encapsulated  token  finished "  )  ;  }  else  {    tkn  .  content  .  append  (  (  char  )  c  )  ;  }  }    [METHOD]  encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber  
[REPLACE]  }  else  if  (  isEncapsulator  (  c  )  )  {	[BUGGY]    if  (  isEncapsulator  (  c  )  )  {[FE]  AssertionFailedError    arrays  first  differed  at  element  [0]  ;  expected:<'[]>  but  was:<'[/]>  assertEquals(res.length  ,  records.size())  ;  assertTrue(records.size()  >  0)  ;  assertArrayEquals(res[i]  ,  records.get(i).values())  ;  assertTrue(CSVPrinterTest.equals(res  ,  records))  ;  [CONTEXT]  private  Token  encapsulatedTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {    int  startLineNumber  =  getLineNumber  (  )  ;      while  (  true  )  {  c  =  in  .  read  (  )  ;    if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  [ATTENTION]  }if  (  isEncapsulator  (  c  )  )  {  if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (   "  (  line   "  +  getLineNumber  (  )  +   "  )  invalid  char  between  encapsulated  token  and  delimiter "  )  ;  }  }  }  }  else  if  (  isEndOfFile  (  c  )  )  {    throw  new  IOException  (   "  (  startline   "  +  startLineNumber  +   "  )  EOF  reached  before  encapsulated  token  finished "  )  ;  }  else  {    tkn  .  content  .  append  (  (  char  )  c  )  ;  }  }  }    [METHOD]  encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber  
[REPLACE]  }  else  if  (  isEndOfFile  (  c  )  )  {	[BUGGY]    else  {[CE]  'else'  without  'if'  [CONTEXT]  private  Token  encapsulatedTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {    int  startLineNumber  =  getLineNumber  (  )  ;      while  (  true  )  {  c  =  in  .  read  (  )  ;    if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  if  (  isEncapsulator  (  c  )  )  {  if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (   "  (  line   "  +  getLineNumber  (  )  +   "  )  invalid  char  between  encapsulated  token  and  delimiter "  )  ;  }  }  }  [ATTENTION]  }else  {    throw  new  IOException  (   "  (  startline   "  +  startLineNumber  +   "  )  EOF  reached  before  encapsulated  token  finished "  )  ;  }  else  {    tkn  .  content  .  append  (  (  char  )  c  )  ;  }  }  }    [METHOD]  encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber  
[REPLACE]  tkn  .  content  .  append  (  (  char  )  c  )  ;	[BUGGY]  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  [FE]  (line  1)  invalid  char  between  encapsulated  token  and  delimiter  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "  foo "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "  foo   "  ,  parser.nextToken(new  Token()))  ;  //      assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "b "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  }  else  if  (  isEndOfFile  (  c  )  )  {    throw  new  IOException  (   "  (  startline   "  +  startLineNumber  +   "  )  EOF  reached  before  encapsulated  token  finished "  )  ;  }  else  {    [ATTENTION]  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )    ;  }    [METHOD]  encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber  
[REPLACE]  throw  new  IOException  ( "   ")  ;	[BUGGY]  return  ;  [CE]  missing  return  value  [CONTEXT]  private  Token  encapsulatedTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {    int  startLineNumber  =  getLineNumber  (  )  ;      while  (  true  )  {  c  =  in  .  read  (  )  ;    if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  if  (  isEncapsulator  (  c  )  )  {  if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (   "  (  line   "  +  getLineNumber  (  )  +   "  )  invalid  char  between  encapsulated  token  and  delimiter "  )  ;  }  }  }  }  else  if  (  isEndOfFile  (  c  )  )  {    [ATTENTION]  return  ;  }  else  {    tkn  .  content  .  append  (  (  char  )  c  )  ;  }  }  }    [METHOD]  encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber  
[REPLACE]  }  else  if  (  isEndOfLine  (  c  )  )  {	[BUGGY]  else  if  (  isDelimiter  (  c  )  )  {[FE]  (line  4)  invalid  char  between  encapsulated  token  and  delimiter  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo\n "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "foo\n  baar  ,  ,  ,   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "\n\t  \n "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  private  Token  encapsulatedTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {    int  startLineNumber  =  getLineNumber  (  )  ;      while  (  true  )  {  c  =  in  .  read  (  )  ;    if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  if  (  isEncapsulator  (  c  )  )  {  if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  [ATTENTION]  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (   "  (  line   "  +  getLineNumber  (  )  +   "  )  invalid  char  between  encapsulated  token  and  delimiter "  )  ;  }  }  }  }  else  if  (  isEndOfFile  (  c  )  )  {    throw  new  IOException  (   "  (  startline   "  +  startLineNumber  +   "  )  EOF  reached  before  encapsulated  token  finished "  )  ;  }  else  {    tkn  .  content  .  append  (  (  char  )  c  )  ;  }  }  }    [METHOD]  encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber  
[ADD]  tkn  .  type  =  EORECORD;  return  tkn;	[BUGGY]  return  tkn  ;  [FE]  AssertionFailedError    Token  type  expected:<EORECORD>  but  was:<EOF>  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo\n "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "foo\n  baar  ,  ,  ,   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "\n\t  \n "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  private  Token  encapsulatedTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {    int  startLineNumber  =  getLineNumber  (  )  ;      while  (  true  )  {  c  =  in  .  read  (  )  ;    if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  if  (  isEncapsulator  (  c  )  )  {  if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    [ATTENTION]  return  tkn  ;    }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (   "  (  line   "  +  getLineNumber  (  )  +   "  )  invalid  char  between  encapsulated  token  and  delimiter "  )  ;  }  }  }  }  else  if  (  isEndOfFile  (  c  )  )  {    throw  new  IOException  (   "  (  startline   "  +  startLineNumber  +   "  )  EOF  reached  before  encapsulated  token  finished "  )  ;  }  else  {    tkn  .  content  .  append  (  (  char  )  c  )  ;  }  }  }    [METHOD]  encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber  
[ADD]  tkn  .  type  =  TOKEN;	[BUGGY]  [FE]  (line  1)  invalid  char  between  encapsulated  token  and  delimiter  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "  foo "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "  foo   "  ,  parser.nextToken(new  Token()))  ;  //      assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "b "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  private  Token  encapsulatedTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {    int  startLineNumber  =  getLineNumber  (  )  ;      while  (  true  )  {  c  =  in  .  read  (  )  ;    if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  if  (  isEncapsulator  (  c  )  )  {  if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  [ATTENTION]  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (   "  (  line   "  +  getLineNumber  (  )  +   "  )  invalid  char  between  encapsulated  token  and  delimiter "  )  ;  }  }  }  }  else  if  (  isEndOfFile  (  c  )  )  {    throw  new  IOException  (   "  (  startline   "  +  startLineNumber  +   "  )  EOF  reached  before  encapsulated  token  finished "  )  ;  }  else  {    tkn  .  content  .  append  (  (  char  )  c  )  ;  }  }  }    [METHOD]  encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber  
[REPLACE]  }  else  if  (  isEndOfFile  (  c  )  )  {	[BUGGY]    else  {[CE]  'else'  without  'if'  [CONTEXT]  private  Token  encapsulatedTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {    int  startLineNumber  =  getLineNumber  (  )  ;      while  (  true  )  {  c  =  in  .  read  (  )  ;    if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  if  (  isEncapsulator  (  c  )  )  {  if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  [ATTENTION]  }else  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (   "  (  line   "  +  getLineNumber  (  )  +   "  )  invalid  char  between  encapsulated  token  and  delimiter "  )  ;  }  }  }  }  else  if  (  isEndOfFile  (  c  )  )  {    throw  new  IOException  (   "  (  startline   "  +  startLineNumber  +   "  )  EOF  reached  before  encapsulated  token  finished "  )  ;  }  else  {    tkn  .  content  .  append  (  (  char  )  c  )  ;  }  }  }    [METHOD]  encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber  
[ADD]  tkn  .  isReady  =  true;	[BUGGY]  [FE]  array  lengths  differed  ,  expected.length  =  2  actual.length  =  1  assertEquals(res.length  ,  records.size())  ;  assertTrue(records.size()  >  0)  ;  assertArrayEquals(res[i]  ,  records.get(i).values())  ;  [CONTEXT]  private  Token  encapsulatedTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {    int  startLineNumber  =  getLineNumber  (  )  ;      while  (  true  )  {  c  =  in  .  read  (  )  ;    if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  if  (  isEncapsulator  (  c  )  )  {  if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  [ATTENTION]  return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (   "  (  line   "  +  getLineNumber  (  )  +   "  )  invalid  char  between  encapsulated  token  and  delimiter "  )  ;  }  }  }  }  else  if  (  isEndOfFile  (  c  )  )  {    throw  new  IOException  (   "  (  startline   "  +  startLineNumber  +   "  )  EOF  reached  before  encapsulated  token  finished "  )  ;  }  else  {    tkn  .  content  .  append  (  (  char  )  c  )  ;  }  }  }    [METHOD]  encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber  
[ADD]  c  =  in  .  read  (  )  ;	[BUGGY]  [FE]  (line  0)  invalid  char  between  encapsulated  token  and  delimiter  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "  foo "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "  foo   "  ,  parser.nextToken(new  Token()))  ;  //      assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "b "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  private  Token  encapsulatedTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {    int  startLineNumber  =  getLineNumber  (  )  ;      while  (  true  )  {  c  =  in  .  read  (  )  ;    if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  if  (  isEncapsulator  (  c  )  )  {  if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  [ATTENTION]  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (   "  (  line   "  +  getLineNumber  (  )  +   "  )  invalid  char  between  encapsulated  token  and  delimiter "  )  ;  }  }  }  }  else  if  (  isEndOfFile  (  c  )  )  {    throw  new  IOException  (   "  (  startline   "  +  startLineNumber  +   "  )  EOF  reached  before  encapsulated  token  finished "  )  ;  }  else  {    tkn  .  content  .  append  (  (  char  )  c  )  ;  }  }  }    [METHOD]  encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber  
[ADD]  tkn  .  type  =  EOF;  tkn  .  isReady  =  true;	[BUGGY]  [FE]  (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo\n "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "foo\n  baar  ,  ,  ,   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "\n\t  \n "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  private  Token  encapsulatedTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {    int  startLineNumber  =  getLineNumber  (  )  ;      while  (  true  )  {  c  =  in  .  read  (  )  ;    if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  if  (  isEncapsulator  (  c  )  )  {  if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  [ATTENTION]    return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (   "  (  line   "  +  getLineNumber  (  )  +   "  )  invalid  char  between  encapsulated  token  and  delimiter "  )  ;  }  }  }  }  else  if  (  isEndOfFile  (  c  )  )  {    throw  new  IOException  (   "  (  startline   "  +  startLineNumber  +   "  )  EOF  reached  before  encapsulated  token  finished "  )  ;  }  else  {    tkn  .  content  .  append  (  (  char  )  c  )  ;  }  }  }    [METHOD]  encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber  
[ADD]  tkn  .  isReady  =  true;  return  tkn;	[BUGGY]  [FE]  [CONTEXT]  private  Token  encapsulatedTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {    int  startLineNumber  =  getLineNumber  (  )  ;      while  (  true  )  {  c  =  in  .  read  (  )  ;    if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  if  (  isEncapsulator  (  c  )  )  {  if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  [ATTENTION]    }  else  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (   "  (  line   "  +  getLineNumber  (  )  +   "  )  invalid  char  between  encapsulated  token  and  delimiter "  )  ;  }  }  }  }  else  if  (  isEndOfFile  (  c  )  )  {    throw  new  IOException  (   "  (  startline   "  +  startLineNumber  +   "  )  EOF  reached  before  encapsulated  token  finished "  )  ;  }  else  {    tkn  .  content  .  append  (  (  char  )  c  )  ;  }  }  }    [METHOD]  encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber  
[REPLACE]  if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {	[BUGGY]  if  (  isEscape  (  c  )  )  {[FE]  (line  0)  invalid  char  between  encapsulated  token  and  delimiter  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b  and  '  more\n "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  private  Token  encapsulatedTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {    int  startLineNumber  =  getLineNumber  (  )  ;      while  (  true  )  {  c  =  in  .  read  (  )  ;    if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  if  (  isEncapsulator  (  c  )  )  {  [ATTENTION]  if  (  isEscape  (  c  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (   "  (  line   "  +  getLineNumber  (  )  +   "  )  invalid  char  between  encapsulated  token  and  delimiter "  )  ;  }  }  }  }  else  if  (  isEndOfFile  (  c  )  )  {    throw  new  IOException  (   "  (  startline   "  +  startLineNumber  +   "  )  EOF  reached  before  encapsulated  token  finished "  )  ;  }  else  {    tkn  .  content  .  append  (  (  char  )  c  )  ;  }  }  }    [METHOD]  encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber  
[ADD]  if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {  c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;	[BUGGY]  [CE]  'else'  without  'if'  [CONTEXT]  private  Token  encapsulatedTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {    int  startLineNumber  =  getLineNumber  (  )  ;      while  (  true  )  {  c  =  in  .  read  (  )  ;    if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  if  (  isEncapsulator  (  c  )  )  {  [ATTENTION]      }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (   "  (  line   "  +  getLineNumber  (  )  +   "  )  invalid  char  between  encapsulated  token  and  delimiter "  )  ;  }  }  }  }  else  if  (  isEndOfFile  (  c  )  )  {    throw  new  IOException  (   "  (  startline   "  +  startLineNumber  +   "  )  EOF  reached  before  encapsulated  token  finished "  )  ;  }  else  {    tkn  .  content  .  append  (  (  char  )  c  )  ;  }  }  }    [METHOD]  encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber  
[REPLACE]  while  (  true  )  {	[BUGGY]  while  (  false  )  {[CE]  unreachable  statement  [CONTEXT]  if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    [ATTENTION]  while  (  false  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (   "  (  line   "  +  getLineNumber  (  )  +   "  )  invalid  char  between  encapsulated  token  and  delimiter "  )  ;  }  }  }    [METHOD]  encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber  
[REPLACE]  if  (  isDelimiter  (  c  )  )  {	[BUGGY]  if  (  isEscape  (  c  )  )  {[FE]  (line  0)  invalid  char  between  encapsulated  token  and  delimiter  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "  foo "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "  foo   "  ,  parser.nextToken(new  Token()))  ;  //      assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "b "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  [ATTENTION]  if  (  isEscape  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (   "  (  line   "  +  getLineNumber  (  )  +   "  )  invalid  char  between  encapsulated  token  and  delimiter "  )  ;  }  }  }    [METHOD]  encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber  
[ADD]  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN;  return  tkn;  }  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF;	[BUGGY]  tkn  .  type  =  TOKEN  ;  return  tkn  ;  tkn  .  type  =  EOF  ;  [CE]  'else'  without  'if'  [CONTEXT]  if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  [ATTENTION]  tkn  .  type  =  TOKEN  ;  return  tkn  ;  tkn  .  type  =  EOF  ;      tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (   "  (  line   "  +  getLineNumber  (  )  +   "  )  invalid  char  between  encapsulated  token  and  delimiter "  )  ;  }  }  }    [METHOD]  encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber  
[REPLACE]  }  else  if  (  isEndOfFile  (  c  )  )  {	[BUGGY]    if  (  isEndOfFile  (  c  )  )  {[NO-ERROR]  [CONTEXT]  if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  [ATTENTION]  }if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (   "  (  line   "  +  getLineNumber  (  )  +   "  )  invalid  char  between  encapsulated  token  and  delimiter "  )  ;  }  }  }    [METHOD]  encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber  
[REPLACE]  }  else  if  (  isEndOfLine  (  c  )  )  {	[BUGGY]    else  {[CE]  'else'  without  'if'  [CONTEXT]  if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  [ATTENTION]  }else  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (   "  (  line   "  +  getLineNumber  (  )  +   "  )  invalid  char  between  encapsulated  token  and  delimiter "  )  ;  }  }  }    [METHOD]  encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber  
[REPLACE]  }  else  if  (  !isWhitespace  (  c  )  )  {	[BUGGY]  else  if  (  isWhitespace  (  c  )  )  {[FE]  (line  2)  invalid  char  between  encapsulated  token  and  delimiter  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "  foo "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "  foo   "  ,  parser.nextToken(new  Token()))  ;  //      assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "b "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  [ATTENTION]  }  else  if  (  isWhitespace  (  c  )  )  {    throw  new  IOException  (   "  (  line   "  +  getLineNumber  (  )  +   "  )  invalid  char  between  encapsulated  token  and  delimiter "  )  ;  }  }  }    [METHOD]  encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber  
[REPLACE]  throw  new  IOException  ( "   ")  ;	[BUGGY]  return  ;  [CE]  missing  return  value  [CONTEXT]  if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    [ATTENTION]  return  ;  }  }  }    [METHOD]  encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber  
[ADD]  throw  new  IOException  ( "   ")  ;	[BUGGY]  [NO-ERROR]  [CONTEXT]  if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    [ATTENTION]  }  }  }    [METHOD]  encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber  
[REPLACE]  throw  new  IOException  ( "   ")  ;	[BUGGY]  eol  =  isEndOfLine  (  c  )  ;  [CE]  cannot  find  symbol  eol  [CONTEXT]  if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    [ATTENTION]  eol  =  isEndOfLine  (  c  )    ;  }  }  }    [METHOD]  encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber  
[REPLACE]  tkn  .  type  =  EORECORD;	[BUGGY]  tkn  .  type    =    tkn  .  type  ;  [FE]  AssertionFailedError    Token  type  expected:<EORECORD>  but  was:<EOF>  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo\n "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "foo\n  baar  ,  ,  ,   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "\n\t  \n "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    [ATTENTION]  tkn  .  type  =  tkn  .  type  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (   "  (  line   "  +  getLineNumber  (  )  +   "  )  invalid  char  between  encapsulated  token  and  delimiter "  )  ;  }  }  }    [METHOD]  encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber  
[REPLACE]  }  else  if  (  !isWhitespace  (  c  )  )  {	[BUGGY]    else  {[FE]  (line  2)  invalid  char  between  encapsulated  token  and  delimiter  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "  foo "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "  foo   "  ,  parser.nextToken(new  Token()))  ;  //      assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "b "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  [ATTENTION]  }else  {    throw  new  IOException  (   "  (  line   "  +  getLineNumber  (  )  +   "  )  invalid  char  between  encapsulated  token  and  delimiter "  )  ;  }  }  }    [METHOD]  encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber  
[REPLACE]  tkn  .  type  =  EORECORD;	[BUGGY]  tkn  .  type  ;  [CE]  not  a  statement  [CONTEXT]  if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    [ATTENTION]  tkn  .  type  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (   "  (  line   "  +  getLineNumber  (  )  +   "  )  invalid  char  between  encapsulated  token  and  delimiter "  )  ;  }  }  }    [METHOD]  encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber  
[REPLACE]  tkn  .  type  =  EOF;	[BUGGY]  tkn  .  type  =  TOKEN  ;    ;  [FE]  AssertionFailedError    Token  type  expected:<EOF>  but  was:<TOKEN>  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo\n "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "foo\n  baar  ,  ,  ,   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "\n\t  \n "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  [ATTENTION]  tkn  .  type  =  TOKEN  ;    ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (   "  (  line   "  +  getLineNumber  (  )  +   "  )  invalid  char  between  encapsulated  token  and  delimiter "  )  ;  }  }  }    [METHOD]  encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber  
[REPLACE]  tkn  .  isReady  =  true;	[BUGGY]  tkn  .  isReady  =  false  ;  [FE]  array  lengths  differed  ,  expected.length  =  2  actual.length  =  1  assertEquals(res.length  ,  records.size())  ;  assertTrue(records.size()  >  0)  ;  assertArrayEquals(res[i]  ,  records.get(i).values())  ;  [CONTEXT]  if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  [ATTENTION]  tkn  .  isReady  =  false  ;  return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (   "  (  line   "  +  getLineNumber  (  )  +   "  )  invalid  char  between  encapsulated  token  and  delimiter "  )  ;  }  }  }    [METHOD]  encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber  
[REPLACE]  }  else  if  (  isEndOfLine  (  c  )  )  {	[BUGGY]  else  if  (  isDelimiter  (  c  )  )  {[FE]  (line  4)  invalid  char  between  encapsulated  token  and  delimiter  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo\n "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "foo\n  baar  ,  ,  ,   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "\n\t  \n "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  [ATTENTION]  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (   "  (  line   "  +  getLineNumber  (  )  +   "  )  invalid  char  between  encapsulated  token  and  delimiter "  )  ;  }  }  }    [METHOD]  encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber  
[ADD]  else  if  (  isEndOfLine  (  c  )  )  {  tkn  .  type  =  EORECORD;  return  tkn;	[BUGGY]    tkn  .  type  =  EORECORD  ;  return  tkn  ;  [CE]  'else'  without  'if'  [CONTEXT]  if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  [ATTENTION]  }  tkn  .  type  =  EORECORD  ;  return  tkn  ;      }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (   "  (  line   "  +  getLineNumber  (  )  +   "  )  invalid  char  between  encapsulated  token  and  delimiter "  )  ;  }  }  }    [METHOD]  encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber  
[ADD]  tkn  .  type  =  EORECORD;	[BUGGY]  [FE]  AssertionFailedError    Token  type  expected:<EORECORD>  but  was:<EOF>  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo\n "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "foo\n  baar  ,  ,  ,   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "\n\t  \n "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    [ATTENTION]  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (   "  (  line   "  +  getLineNumber  (  )  +   "  )  invalid  char  between  encapsulated  token  and  delimiter "  )  ;  }  }  }    [METHOD]  encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber  
[REPLACE]  tkn  .  type  =  TOKEN;	[BUGGY]  tkn  .  type  =  EOF  ;    ;  [FE]  AssertionFailedError    Token  type  expected:<TOKEN>  but  was:<EOF>  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "  foo "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "  foo   "  ,  parser.nextToken(new  Token()))  ;  //      assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "b "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  [ATTENTION]  tkn  .  type  =  EOF  ;    ;  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (   "  (  line   "  +  getLineNumber  (  )  +   "  )  invalid  char  between  encapsulated  token  and  delimiter "  )  ;  }  }  }    [METHOD]  encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber  
[REPLACE]  }  else  if  (  isEndOfFile  (  c  )  )  {	[BUGGY]    else  {[CE]  'else'  without  'if'  [CONTEXT]  if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  [ATTENTION]  }else  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (   "  (  line   "  +  getLineNumber  (  )  +   "  )  invalid  char  between  encapsulated  token  and  delimiter "  )  ;  }  }  }    [METHOD]  encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber  
[ADD]  tkn  .  type  =  EORECORD;  return  tkn;	[BUGGY]  [FE]  (line  4)  invalid  char  between  encapsulated  token  and  delimiter  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo\n "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "foo\n  baar  ,  ,  ,   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "\n\t  \n "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    [ATTENTION]    }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (   "  (  line   "  +  getLineNumber  (  )  +   "  )  invalid  char  between  encapsulated  token  and  delimiter "  )  ;  }  }  }    [METHOD]  encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber  
[REPLACE]  }  else  if  (  !isWhitespace  (  c  )  )  {	[BUGGY]    if  (  isWhitespace  (  c  )  )  {[FE]  (line  2)  invalid  char  between  encapsulated  token  and  delimiter  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "  foo "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "  foo   "  ,  parser.nextToken(new  Token()))  ;  //      assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "b "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  [ATTENTION]  }if  (  isWhitespace  (  c  )  )  {    throw  new  IOException  (   "  (  line   "  +  getLineNumber  (  )  +   "  )  invalid  char  between  encapsulated  token  and  delimiter "  )  ;  }  }  }    [METHOD]  encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber  
[ADD]  else  if  (  !isWhitespace  (  c  )  )  {  throw  new  IOException  ( "   ")  ;  }	[BUGGY]  [NO-ERROR]  [CONTEXT]  if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  [ATTENTION]  }    }  }    [METHOD]  encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber  
[REPLACE]  tkn  .  type  =  EORECORD;	[BUGGY]  tkn  .  type    =  null  ;  [FE]  AssertionFailedError    Token  type  expected:<EORECORD>  but  was:<null>  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo\n "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "foo\n  baar  ,  ,  ,   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "\n\t  \n "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    [ATTENTION]  tkn  .  type  =  null  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (   "  (  line   "  +  getLineNumber  (  )  +   "  )  invalid  char  between  encapsulated  token  and  delimiter "  )  ;  }  }  }    [METHOD]  encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber  
[REPLACE]  c  =  in  .  read  (  )  ;	[BUGGY]  c  =  in  .  readAgain  (  )  ;    ;  [FE]  (line  0)  invalid  char  between  encapsulated  token  and  delimiter  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "  foo "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "  foo   "  ,  parser.nextToken(new  Token()))  ;  //      assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "b "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  [ATTENTION]  c  =  in  .  readAgain  (  )    ;    ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (   "  (  line   "  +  getLineNumber  (  )  +   "  )  invalid  char  between  encapsulated  token  and  delimiter "  )  ;  }  }  }    [METHOD]  encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber  
[ADD]  tkn  .  isReady  =  true;  return  tkn;	[BUGGY]  [FE]  [CONTEXT]  if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  [ATTENTION]    }  else  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (   "  (  line   "  +  getLineNumber  (  )  +   "  )  invalid  char  between  encapsulated  token  and  delimiter "  )  ;  }  }  }    [METHOD]  encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber  
[REPLACE]  }  else  if  (  isEndOfFile  (  c  )  )  {	[BUGGY]  else  if  (  isDelimiter  (  c  )  )  {[FE]  (line  6)  invalid  char  between  encapsulated  token  and  delimiter  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo\n "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "foo\n  baar  ,  ,  ,   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "\n\t  \n "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  [ATTENTION]  }  else  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (   "  (  line   "  +  getLineNumber  (  )  +   "  )  invalid  char  between  encapsulated  token  and  delimiter "  )  ;  }  }  }    [METHOD]  encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber  
[ADD]  tkn  .  type  =  EOF;	[BUGGY]  [FE]  (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo\n "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "foo\n  baar  ,  ,  ,   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "\n\t  \n "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  [ATTENTION]  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (   "  (  line   "  +  getLineNumber  (  )  +   "  )  invalid  char  between  encapsulated  token  and  delimiter "  )  ;  }  }  }    [METHOD]  encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber  
[REPLACE]  }  else  if  (  isEndOfLine  (  c  )  )  {	[BUGGY]    if  (  isEndOfLine  (  c  )  )  {[NO-ERROR]  [CONTEXT]  if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  [ATTENTION]  }if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (   "  (  line   "  +  getLineNumber  (  )  +   "  )  invalid  char  between  encapsulated  token  and  delimiter "  )  ;  }  }  }    [METHOD]  encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber  
[ADD]  tkn  .  type  =  TOKEN;	[BUGGY]  [FE]  (line  1)  invalid  char  between  encapsulated  token  and  delimiter  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "  foo "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "  foo   "  ,  parser.nextToken(new  Token()))  ;  //      assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "b "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  [ATTENTION]  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (   "  (  line   "  +  getLineNumber  (  )  +   "  )  invalid  char  between  encapsulated  token  and  delimiter "  )  ;  }  }  }    [METHOD]  encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber  
[REPLACE]  c  =  in  .  read  (  )  ;	[BUGGY]  c  =  in  .  readAgain  (  )  ;    ;  [FE]  (line  0)  invalid  char  between  encapsulated  token  and  delimiter  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b  and  '  more\n "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  private  Token  encapsulatedTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {    int  startLineNumber  =  getLineNumber  (  )  ;      while  (  true  )  {  c  =  in  .  read  (  )  ;    if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  if  (  isEncapsulator  (  c  )  )  {  if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    [ATTENTION]  c  =  in  .  readAgain  (  )    ;    ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (   "  (  line   "  +  getLineNumber  (  )  +   "  )  invalid  char  between  encapsulated  token  and  delimiter "  )  ;  }  }  }  }  else  if  (  isEndOfFile  (  c  )  )  {    throw  new  IOException  (   "  (  startline   "  +  startLineNumber  +   "  )  EOF  reached  before  encapsulated  token  finished "  )  ;  }  else  {    tkn  .  content  .  append  (  (  char  )  c  )  ;  }  }  }    [METHOD]  encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber  
[ADD]  tkn  .  type  =  EOF;	[BUGGY]  [FE]  (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo\n "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "foo\n  baar  ,  ,  ,   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "\n\t  \n "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  private  Token  encapsulatedTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {    int  startLineNumber  =  getLineNumber  (  )  ;      while  (  true  )  {  c  =  in  .  read  (  )  ;    if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  if  (  isEncapsulator  (  c  )  )  {  if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  [ATTENTION]  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (   "  (  line   "  +  getLineNumber  (  )  +   "  )  invalid  char  between  encapsulated  token  and  delimiter "  )  ;  }  }  }  }  else  if  (  isEndOfFile  (  c  )  )  {    throw  new  IOException  (   "  (  startline   "  +  startLineNumber  +   "  )  EOF  reached  before  encapsulated  token  finished "  )  ;  }  else  {    tkn  .  content  .  append  (  (  char  )  c  )  ;  }  }  }    [METHOD]  encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber  
[REMOVE]  	[BUGGY]  if  (  eol  )  {      tkn  .  type  =  EORECORD  ;  }else      if  (  isEncapsulator  (  c  )  )  {          encapsulatedTokenLexer  (  tkn  ,  c  )  ;      }else          if  (  isEndOfFile  (  c  )  )  {              tkn  .  type  =  EOF  ;              tkn  .  isReady  =  true  ;          }else  {              simpleTokenLexer  (  tkn  ,  c  )  ;          }[CE]  cannot  find  symbol  eol  [CONTEXT]  private  Token  encapsulatedTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {    int  startLineNumber  =  getLineNumber  (  )  ;      while  (  true  )  {  c  =  in  .  read  (  )  ;    if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  if  (  isEncapsulator  (  c  )  )  {  if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  [ATTENTION]  }  else  if  (  isEndOfFile  (  c  )  )  {  if  (  eol  )  {  tkn  .  type  =  EORECORD  ;  }else  if  (  isEncapsulator  (  c  )  )  {  encapsulatedTokenLexer  (  tkn  ,  c  )    ;  }else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  }else  {  simpleTokenLexer  (  tkn  ,  c  )    ;  }tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (   "  (  line   "  +  getLineNumber  (  )  +   "  )  invalid  char  between  encapsulated  token  and  delimiter "  )  ;  }  }  }  }  else  if  (  isEndOfFile  (  c  )  )  {    throw  new  IOException  (   "  (  startline   "  +  startLineNumber  +   "  )  EOF  reached  before  encapsulated  token  finished "  )  ;  }  else  {    tkn  .  content  .  append  (  (  char  )  c  )  ;  }  }    [METHOD]  encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber  
[REMOVE]  	[BUGGY]  if  (  isEndOfFile  (  c  )  )  {      tkn  .  type  =  EOF  ;      tkn  .  isReady  =  true  ;      return  tkn  ;  }else      if  (  isEndOfLine  (  c  )  )  {          tkn  .  type  =  EORECORD  ;          return  tkn  ;      }else          if  (  !  (  isWhitespace  (  c  )  )  )  {              throw  new  IOException  (  (  (   "  (  line   "  +  (  getLineNumber  (  )  )  )  +   "  )  invalid  char  between  encapsulated  token  and  delimiter "  )  )  ;          }[NO-ERROR]  [CONTEXT]  private  Token  encapsulatedTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {    int  startLineNumber  =  getLineNumber  (  )  ;      while  (  true  )  {  c  =  in  .  read  (  )  ;    if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  if  (  isEncapsulator  (  c  )  )  {  if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  [ATTENTION]  }  else  if  (  !isWhitespace  (  c  )  )  {  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  return  tkn  ;  }else  if  (  isEndOfLine  (  c  )  )  {  tkn  .  type  =  EORECORD  ;  return  tkn  ;  }else  if  (  !  (  isWhitespace  (  c  )  )  )  {  throw  new  IOException  (  (  (   "  (  line   "  +  (  getLineNumber  (  )  )  )  +   "  )  invalid  char  between  encapsulated  token  and  delimiter "  )  )    ;  }//  error  invalid  char  between  token  and  next  delimiter  throw  new  IOException  (   "  (  line   "  +  getLineNumber  (  )  +   "  )  invalid  char  between  encapsulated  token  and  delimiter "  )  ;  }  }  }  }  else  if  (  isEndOfFile  (  c  )  )  {    throw  new  IOException  (   "  (  startline   "  +  startLineNumber  +   "  )  EOF  reached  before  encapsulated  token  finished "  )  ;  }  else  {    tkn  .  content  .  append  (  (  char  )  c  )  ;  }  }    [METHOD]  encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber  
[ADD]  tkn  .  type  =  TOKEN;  return  tkn;	[BUGGY]  [FE]  (line  0)  invalid  char  between  encapsulated  token  and  delimiter  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "  foo "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "  foo   "  ,  parser.nextToken(new  Token()))  ;  //      assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "b "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  [ATTENTION]    }  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (   "  (  line   "  +  getLineNumber  (  )  +   "  )  invalid  char  between  encapsulated  token  and  delimiter "  )  ;  }  }  }    [METHOD]  encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber  
[ADD]  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF;  tkn  .  isReady  =  true;  return  tkn;	[BUGGY]    tkn  .  isReady  =  true  ;  return  tkn  ;  [CE]  'else'  without  'if'  [CONTEXT]  if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  [ATTENTION]  }  tkn  .  isReady  =  true  ;  return  tkn  ;      }  else  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (   "  (  line   "  +  getLineNumber  (  )  +   "  )  invalid  char  between  encapsulated  token  and  delimiter "  )  ;  }  }  }    [METHOD]  encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber  
[ADD]  tkn  .  isReady  =  true;	[BUGGY]  [FE]  array  lengths  differed  ,  expected.length  =  2  actual.length  =  1  assertEquals(res.length  ,  records.size())  ;  assertTrue(records.size()  >  0)  ;  assertArrayEquals(res[i]  ,  records.get(i).values())  ;  [CONTEXT]  if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  [ATTENTION]  return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (   "  (  line   "  +  getLineNumber  (  )  +   "  )  invalid  char  between  encapsulated  token  and  delimiter "  )  ;  }  }  }    [METHOD]  encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber  
[ADD]  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN;  return  tkn;  }  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF;	[BUGGY]  [CE]  'else'  without  'if'  [CONTEXT]  if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  [ATTENTION]      tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (   "  (  line   "  +  getLineNumber  (  )  +   "  )  invalid  char  between  encapsulated  token  and  delimiter "  )  ;  }  }  }    [METHOD]  encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber  
[REMOVE]  	[BUGGY]  if  (  isDelimiter  (  c  )  )  {      tkn  .  type  =  TOKEN  ;      break  ;  }else      if  (  isEscape  (  c  )  )  {          append  (  (  (  char  )    (  readEscape  (  c  )  )  )  )  ;      }else  {          append  (  (  (  char  )    (  c  )  )  )  ;      }[CE]  cannot  find  symbol  [CONTEXT]  if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  [ATTENTION]  }  else  if  (  isEndOfLine  (  c  )  )  {  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  break  ;  }else  if  (  isEscape  (  c  )  )  {  append  (  (  (  char  )    (  readEscape  (  c  )  )  )  )    ;  }else  {  append  (  (  (  char  )    (  c  )  )  )    ;  }//  ok  eo  token  reached  tkn  .  type  =  EORECORD  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (   "  (  line   "  +  getLineNumber  (  )  +   "  )  invalid  char  between  encapsulated  token  and  delimiter "  )  ;  }  }    [METHOD]  encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber  
[REMOVE]  	[BUGGY]  if  (  isEndOfFile  (  c  )  )  {      tkn  .  type  =  EOF  ;      tkn  .  isReady  =  true  ;      return  tkn  ;  }else      if  (  isEndOfLine  (  c  )  )  {          tkn  .  type  =  EORECORD  ;          return  tkn  ;      }else          if  (  !  (  isWhitespace  (  c  )  )  )  {              throw  new  IOException  (  (  (   "  (  line   "  +  (  getLineNumber  (  )  )  )  +   "  )  invalid  char  between  encapsulated  token  and  delimiter "  )  )  ;          }[NO-ERROR]  [CONTEXT]  if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  [ATTENTION]  }  else  if  (  !isWhitespace  (  c  )  )  {  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  return  tkn  ;  }else  if  (  isEndOfLine  (  c  )  )  {  tkn  .  type  =  EORECORD  ;  return  tkn  ;  }else  if  (  !  (  isWhitespace  (  c  )  )  )  {  throw  new  IOException  (  (  (   "  (  line   "  +  (  getLineNumber  (  )  )  )  +   "  )  invalid  char  between  encapsulated  token  and  delimiter "  )  )    ;  }//  error  invalid  char  between  token  and  next  delimiter  throw  new  IOException  (   "  (  line   "  +  getLineNumber  (  )  +   "  )  invalid  char  between  encapsulated  token  and  delimiter "  )  ;  }  }    [METHOD]  encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber  
[ADD]  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF;  tkn  .  isReady  =  true;  return  tkn;	[BUGGY]    tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  return  tkn  ;  [CE]  'else'  without  'if'  [CONTEXT]  if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  [ATTENTION]  }  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  return  tkn  ;      }  else  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (   "  (  line   "  +  getLineNumber  (  )  +   "  )  invalid  char  between  encapsulated  token  and  delimiter "  )  ;  }  }  }    [METHOD]  encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber  
[REMOVE]  	[BUGGY]  int  c  =  in  .  read  (  )  ;  [CE]  variable  c  is  already  defined  in  method  encapsulatedTokenLexer(Token  ,  int)  [CONTEXT]  if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    [ATTENTION]  throw  new  IOException  (   "  (  line   "  +  getLineNumber  (  )  +   "  )  invalid  char  between  encapsulated  token  and  delimiter "  )  ;    int  c  =  in  .  read  (  )    ;  }  }    [METHOD]  encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber  
[ADD]  tkn  .  type  =  EOF;  tkn  .  isReady  =  true;	[BUGGY]  [FE]  (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo\n "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "foo\n  baar  ,  ,  ,   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "\n\t  \n "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  [ATTENTION]    return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (   "  (  line   "  +  getLineNumber  (  )  +   "  )  invalid  char  between  encapsulated  token  and  delimiter "  )  ;  }  }  }    [METHOD]  encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber  
[ADD]  tkn  .  type  =  EOF;  tkn  .  isReady  =  true;	[BUGGY]  tkn  .  isReady  =  true  ;  [FE]  (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo\n "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "foo\n  baar  ,  ,  ,   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "\n\t  \n "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  [ATTENTION]  tkn  .  isReady  =  true  ;    return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (   "  (  line   "  +  getLineNumber  (  )  +   "  )  invalid  char  between  encapsulated  token  and  delimiter "  )  ;  }  }  }    [METHOD]  encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber  
[ADD]  c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;	[BUGGY]  tkn  .  content  .  append  (  (  char  )  c  )  ;  [FE]  (line  0)  invalid  char  between  encapsulated  token  and  delimiter  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b  and  '  more\n "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  private  Token  encapsulatedTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {    int  startLineNumber  =  getLineNumber  (  )  ;      while  (  true  )  {  c  =  in  .  read  (  )  ;    if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  if  (  isEncapsulator  (  c  )  )  {  if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    [ATTENTION]  tkn  .  content  .  append  (  (  char  )  c  )    ;    }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (   "  (  line   "  +  getLineNumber  (  )  +   "  )  invalid  char  between  encapsulated  token  and  delimiter "  )  ;  }  }  }  }  else  if  (  isEndOfFile  (  c  )  )  {    throw  new  IOException  (   "  (  startline   "  +  startLineNumber  +   "  )  EOF  reached  before  encapsulated  token  finished "  )  ;  }  else  {    tkn  .  content  .  append  (  (  char  )  c  )  ;  }  }  }    [METHOD]  encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber  
[REPLACE]  }  else  if  (  isEndOfFile  (  c  )  )  {	[BUGGY]    if  (  isEndOfFile  (  c  )  )  {[FE]  Token  content  expected:<b  and  '[]  more  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b  and  '  more\n "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  private  Token  encapsulatedTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {    int  startLineNumber  =  getLineNumber  (  )  ;      while  (  true  )  {  c  =  in  .  read  (  )  ;    if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  if  (  isEncapsulator  (  c  )  )  {  if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (   "  (  line   "  +  getLineNumber  (  )  +   "  )  invalid  char  between  encapsulated  token  and  delimiter "  )  ;  }  }  }  [ATTENTION]  }if  (  isEndOfFile  (  c  )  )  {    throw  new  IOException  (   "  (  startline   "  +  startLineNumber  +   "  )  EOF  reached  before  encapsulated  token  finished "  )  ;  }  else  {    tkn  .  content  .  append  (  (  char  )  c  )  ;  }  }  }    [METHOD]  encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber  
[ADD]  tkn  .  content  .  append  (  (  char  )  c  )  ;	[BUGGY]  [FE]  AssertionFailedError    Token  content  expected:<[foo]>  but  was:<[]>  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "  foo "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "  foo   "  ,  parser.nextToken(new  Token()))  ;  //      assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "b "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  }  else  if  (  isEndOfFile  (  c  )  )  {    throw  new  IOException  (   "  (  startline   "  +  startLineNumber  +   "  )  EOF  reached  before  encapsulated  token  finished "  )  ;  }  else  {    [ATTENTION]  }    [METHOD]  encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber  
[REPLACE]  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;	[BUGGY]  tkn  .  content  .  append  (  (  char  )  c  )  ;  [FE]  (line  3)  invalid  char  between  encapsulated  token  and  delimiter  assertEquals(res.length  ,  records.size())  ;  assertTrue(records.size()  >  0)  ;  assertArrayEquals(res[i]  ,  records.get(i).values())  ;  assertTrue(CSVPrinterTest.equals(res  ,  records))  ;  [CONTEXT]  private  Token  encapsulatedTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {    int  startLineNumber  =  getLineNumber  (  )  ;      while  (  true  )  {  c  =  in  .  read  (  )  ;    if  (  isEscape  (  c  )  )  {  [ATTENTION]  tkn  .  content  .  append  (  (  char  )  c  )    ;  }  else  if  (  isEncapsulator  (  c  )  )  {  if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (   "  (  line   "  +  getLineNumber  (  )  +   "  )  invalid  char  between  encapsulated  token  and  delimiter "  )  ;  }  }  }  }  else  if  (  isEndOfFile  (  c  )  )  {    throw  new  IOException  (   "  (  startline   "  +  startLineNumber  +   "  )  EOF  reached  before  encapsulated  token  finished "  )  ;  }  else  {    tkn  .  content  .  append  (  (  char  )  c  )  ;  }  }  }    [METHOD]  encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber  
[REPLACE]  }  else  if  (  isEncapsulator  (  c  )  )  {	[BUGGY]    else  {[CE]  'else'  without  'if'  [CONTEXT]  private  Token  encapsulatedTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {    int  startLineNumber  =  getLineNumber  (  )  ;      while  (  true  )  {  c  =  in  .  read  (  )  ;    if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  [ATTENTION]  }else  {  if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (   "  (  line   "  +  getLineNumber  (  )  +   "  )  invalid  char  between  encapsulated  token  and  delimiter "  )  ;  }  }  }  }  else  if  (  isEndOfFile  (  c  )  )  {    throw  new  IOException  (   "  (  startline   "  +  startLineNumber  +   "  )  EOF  reached  before  encapsulated  token  finished "  )  ;  }  else  {    tkn  .  content  .  append  (  (  char  )  c  )  ;  }  }  }    [METHOD]  encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber  
[REPLACE]  }  else  if  (  isEndOfFile  (  c  )  )  {	[BUGGY]  else  if  (  isDelimiter  (  c  )  )  {[FE]  (startline  2)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo\n "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "foo\n  baar  ,  ,  ,   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "\n\t  \n "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  private  Token  encapsulatedTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {    int  startLineNumber  =  getLineNumber  (  )  ;      while  (  true  )  {  c  =  in  .  read  (  )  ;    if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  if  (  isEncapsulator  (  c  )  )  {  if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (   "  (  line   "  +  getLineNumber  (  )  +   "  )  invalid  char  between  encapsulated  token  and  delimiter "  )  ;  }  }  }  [ATTENTION]  }  else  if  (  isDelimiter  (  c  )  )  {    throw  new  IOException  (   "  (  startline   "  +  startLineNumber  +   "  )  EOF  reached  before  encapsulated  token  finished "  )  ;  }  else  {    tkn  .  content  .  append  (  (  char  )  c  )  ;  }  }  }    [METHOD]  encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber  
[ADD]  else  if  (  isEndOfFile  (  c  )  )  {  throw  new  IOException  ( "   ")  ;  }  else  {	[BUGGY]  [CE]  class  ,  interface  ,  or  enum  expected  [CONTEXT]  private  Token  encapsulatedTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {    int  startLineNumber  =  getLineNumber  (  )  ;      while  (  true  )  {  c  =  in  .  read  (  )  ;    if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  if  (  isEncapsulator  (  c  )  )  {  if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (   "  (  line   "  +  getLineNumber  (  )  +   "  )  invalid  char  between  encapsulated  token  and  delimiter "  )  ;  }  }  }  [ATTENTION]  }      tkn  .  content  .  append  (  (  char  )  c  )  ;  }  }  }    [METHOD]  encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber  
[REMOVE]  	[BUGGY]  if  (  eol  )  {      tkn  .  type  =  EORECORD  ;  }else      if  (  isEncapsulator  (  c  )  )  {          encapsulatedTokenLexer  (  tkn  ,  c  )  ;      }else          if  (  isEndOfFile  (  c  )  )  {              tkn  .  type  =  EOF  ;              tkn  .  isReady  =  true  ;          }else  {              simpleTokenLexer  (  tkn  ,  c  )  ;          }[CE]  cannot  find  symbol  eol  [CONTEXT]  if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  [ATTENTION]  }  else  if  (  isEndOfFile  (  c  )  )  {  if  (  eol  )  {  tkn  .  type  =  EORECORD  ;  }else  if  (  isEncapsulator  (  c  )  )  {  encapsulatedTokenLexer  (  tkn  ,  c  )    ;  }else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  }else  {  simpleTokenLexer  (  tkn  ,  c  )    ;  }tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (   "  (  line   "  +  getLineNumber  (  )  +   "  )  invalid  char  between  encapsulated  token  and  delimiter "  )  ;  }  }    [METHOD]  encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber  
[ADD]  tkn  .  type  =  EORECORD;  return  tkn;	[BUGGY]  return  tkn  ;  [FE]  AssertionFailedError    Token  type  expected:<EORECORD>  but  was:<EOF>  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo\n "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "foo\n  baar  ,  ,  ,   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "\n\t  \n "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    [ATTENTION]  return  tkn  ;    }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (   "  (  line   "  +  getLineNumber  (  )  +   "  )  invalid  char  between  encapsulated  token  and  delimiter "  )  ;  }  }  }    [METHOD]  encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber  
[ADD]  c  =  in  .  read  (  )  ;	[BUGGY]  [FE]  (line  0)  invalid  char  between  encapsulated  token  and  delimiter  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b  and  '  more\n "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  private  Token  encapsulatedTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {    int  startLineNumber  =  getLineNumber  (  )  ;      while  (  true  )  {  c  =  in  .  read  (  )  ;    if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  if  (  isEncapsulator  (  c  )  )  {  if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    [ATTENTION]  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (   "  (  line   "  +  getLineNumber  (  )  +   "  )  invalid  char  between  encapsulated  token  and  delimiter "  )  ;  }  }  }  }  else  if  (  isEndOfFile  (  c  )  )  {    throw  new  IOException  (   "  (  startline   "  +  startLineNumber  +   "  )  EOF  reached  before  encapsulated  token  finished "  )  ;  }  else  {    tkn  .  content  .  append  (  (  char  )  c  )  ;  }  }  }    [METHOD]  encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber  
[REMOVE]  	[BUGGY]  if  (  isDelimiter  (  c  )  )  {      tkn  .  type  =  TOKEN  ;      break  ;  }else      if  (  isEscape  (  c  )  )  {          append  (  (  (  char  )    (  readEscape  (  c  )  )  )  )  ;      }else  {          append  (  (  (  char  )    (  c  )  )  )  ;      }[CE]  cannot  find  symbol  [CONTEXT]  private  Token  encapsulatedTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {    int  startLineNumber  =  getLineNumber  (  )  ;      while  (  true  )  {  c  =  in  .  read  (  )  ;    if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  if  (  isEncapsulator  (  c  )  )  {  if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  [ATTENTION]  }  else  if  (  isEndOfLine  (  c  )  )  {  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  break  ;  }else  if  (  isEscape  (  c  )  )  {  append  (  (  (  char  )    (  readEscape  (  c  )  )  )  )    ;  }else  {  append  (  (  (  char  )    (  c  )  )  )    ;  }//  ok  eo  token  reached  tkn  .  type  =  EORECORD  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (   "  (  line   "  +  getLineNumber  (  )  +   "  )  invalid  char  between  encapsulated  token  and  delimiter "  )  ;  }  }  }  }  else  if  (  isEndOfFile  (  c  )  )  {    throw  new  IOException  (   "  (  startline   "  +  startLineNumber  +   "  )  EOF  reached  before  encapsulated  token  finished "  )  ;  }  else  {    tkn  .  content  .  append  (  (  char  )  c  )  ;  }  }    [METHOD]  encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber  
[ADD]  c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;	[BUGGY]  [FE]  (line  0)  invalid  char  between  encapsulated  token  and  delimiter  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b  and  '  more\n "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  private  Token  encapsulatedTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {    int  startLineNumber  =  getLineNumber  (  )  ;      while  (  true  )  {  c  =  in  .  read  (  )  ;    if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  if  (  isEncapsulator  (  c  )  )  {  if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    [ATTENTION]    }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (   "  (  line   "  +  getLineNumber  (  )  +   "  )  invalid  char  between  encapsulated  token  and  delimiter "  )  ;  }  }  }  }  else  if  (  isEndOfFile  (  c  )  )  {    throw  new  IOException  (   "  (  startline   "  +  startLineNumber  +   "  )  EOF  reached  before  encapsulated  token  finished "  )  ;  }  else  {    tkn  .  content  .  append  (  (  char  )  c  )  ;  }  }  }    [METHOD]  encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber  
[ADD]  tkn  .  isReady  =  true;  return  tkn;	[BUGGY]  return  tkn  ;  [FE]  array  lengths  differed  ,  expected.length  =  2  actual.length  =  1  assertEquals(res.length  ,  records.size())  ;  assertTrue(records.size()  >  0)  ;  assertArrayEquals(res[i]  ,  records.get(i).values())  ;  [CONTEXT]  if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  [ATTENTION]  return  tkn  ;    }  else  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (   "  (  line   "  +  getLineNumber  (  )  +   "  )  invalid  char  between  encapsulated  token  and  delimiter "  )  ;  }  }  }    [METHOD]  encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber  
[REPLACE]  c  =  in  .  read  (  )  ;	[BUGGY]  c  =  in  .  readAgain  (  )  ;    ;  [FE]  (line  0)  invalid  char  between  encapsulated  token  and  delimiter  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "  foo "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "  foo   "  ,  parser.nextToken(new  Token()))  ;  //      assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "b "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  private  Token  encapsulatedTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {    int  startLineNumber  =  getLineNumber  (  )  ;      while  (  true  )  {  [ATTENTION]  c  =  in  .  readAgain  (  )    ;    ;    if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  if  (  isEncapsulator  (  c  )  )  {  if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (   "  (  line   "  +  getLineNumber  (  )  +   "  )  invalid  char  between  encapsulated  token  and  delimiter "  )  ;  }  }  }  }  else  if  (  isEndOfFile  (  c  )  )  {    throw  new  IOException  (   "  (  startline   "  +  startLineNumber  +   "  )  EOF  reached  before  encapsulated  token  finished "  )  ;  }  else  {    tkn  .  content  .  append  (  (  char  )  c  )  ;  }  }  }    [METHOD]  encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber  
[ADD]  c  =  in  .  read  (  )  ;	[BUGGY]  [FE]  (line  0)  invalid  char  between  encapsulated  token  and  delimiter  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "  foo "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "  foo   "  ,  parser.nextToken(new  Token()))  ;  //      assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "b "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  private  Token  encapsulatedTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {    int  startLineNumber  =  getLineNumber  (  )  ;      while  (  true  )  {  [ATTENTION]    if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  if  (  isEncapsulator  (  c  )  )  {  if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (   "  (  line   "  +  getLineNumber  (  )  +   "  )  invalid  char  between  encapsulated  token  and  delimiter "  )  ;  }  }  }  }  else  if  (  isEndOfFile  (  c  )  )  {    throw  new  IOException  (   "  (  startline   "  +  startLineNumber  +   "  )  EOF  reached  before  encapsulated  token  finished "  )  ;  }  else  {    tkn  .  content  .  append  (  (  char  )  c  )  ;  }  }  }    [METHOD]  encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber  
[ADD]  throw  new  IOException  ( "   ")  ;	[BUGGY]  [NO-ERROR]  [CONTEXT]  private  Token  encapsulatedTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {    int  startLineNumber  =  getLineNumber  (  )  ;      while  (  true  )  {  c  =  in  .  read  (  )  ;    if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  if  (  isEncapsulator  (  c  )  )  {  if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (   "  (  line   "  +  getLineNumber  (  )  +   "  )  invalid  char  between  encapsulated  token  and  delimiter "  )  ;  }  }  }  }  else  if  (  isEndOfFile  (  c  )  )  {    [ATTENTION]  }  else  {    tkn  .  content  .  append  (  (  char  )  c  )  ;  }  }  }    [METHOD]  encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber  
[REMOVE]  	[BUGGY]  if  (  eol  )  {      tkn  .  type  =  EORECORD  ;  }else      if  (  isEncapsulator  (  c  )  )  {          encapsulatedTokenLexer  (  tkn  ,  c  )  ;      }else          if  (  isEndOfFile  (  c  )  )  {              tkn  .  type  =  EOF  ;              tkn  .  isReady  =  true  ;          }else  {              simpleTokenLexer  (  tkn  ,  c  )  ;          }[CE]  cannot  find  symbol  eol  [CONTEXT]  private  Token  encapsulatedTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {    int  startLineNumber  =  getLineNumber  (  )  ;      while  (  true  )  {  c  =  in  .  read  (  )  ;    if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  if  (  isEncapsulator  (  c  )  )  {  if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  [ATTENTION]  if  (  isDelimiter  (  c  )  )  {  if  (  eol  )  {  tkn  .  type  =  EORECORD  ;  }else  if  (  isEncapsulator  (  c  )  )  {  encapsulatedTokenLexer  (  tkn  ,  c  )    ;  }else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  }else  {  simpleTokenLexer  (  tkn  ,  c  )    ;  }tkn  .  type  =  TOKEN  ;  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (   "  (  line   "  +  getLineNumber  (  )  +   "  )  invalid  char  between  encapsulated  token  and  delimiter "  )  ;  }  }  }  }  else  if  (  isEndOfFile  (  c  )  )  {    throw  new  IOException  (   "  (  startline   "  +  startLineNumber  +   "  )  EOF  reached  before  encapsulated  token  finished "  )  ;  }  else  {    tkn  .  content  .  append  (  (  char  )  c  )  ;  }  }    [METHOD]  encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber  
[REPLACE]  }  else  if  (  isEncapsulator  (  c  )  )  {	[BUGGY]  else  if  (  isEndOfFile  (  c  )  )  {[FE]  AssertionFailedError    Token  type  expected:<TOKEN>  but  was:<EOF>  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "  foo "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "  foo   "  ,  parser.nextToken(new  Token()))  ;  //      assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "b "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  private  Token  encapsulatedTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {    int  startLineNumber  =  getLineNumber  (  )  ;      while  (  true  )  {  c  =  in  .  read  (  )  ;    if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  [ATTENTION]  }  else  if  (  isEndOfFile  (  c  )  )  {  if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (   "  (  line   "  +  getLineNumber  (  )  +   "  )  invalid  char  between  encapsulated  token  and  delimiter "  )  ;  }  }  }  }  else  if  (  isEndOfFile  (  c  )  )  {    throw  new  IOException  (   "  (  startline   "  +  startLineNumber  +   "  )  EOF  reached  before  encapsulated  token  finished "  )  ;  }  else  {    tkn  .  content  .  append  (  (  char  )  c  )  ;  }  }  }    [METHOD]  encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber  
[ADD]  while  (  true  )  {  c  =  in  .  read  (  )  ;	[BUGGY]  [CE]  'else'  without  'if'  [CONTEXT]  private  Token  encapsulatedTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {    int  startLineNumber  =  getLineNumber  (  )  ;      while  (  true  )  {  c  =  in  .  read  (  )  ;    if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  if  (  isEncapsulator  (  c  )  )  {  if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    [ATTENTION]    if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (   "  (  line   "  +  getLineNumber  (  )  +   "  )  invalid  char  between  encapsulated  token  and  delimiter "  )  ;  }  }  }  }  else  if  (  isEndOfFile  (  c  )  )  {    throw  new  IOException  (   "  (  startline   "  +  startLineNumber  +   "  )  EOF  reached  before  encapsulated  token  finished "  )  ;  }  else  {    tkn  .  content  .  append  (  (  char  )  c  )  ;  }  }  }    [METHOD]  encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber  
[ADD]  while  (  true  )  {  c  =  in  .  read  (  )  ;	[BUGGY]  [CE]  'else'  without  'if'  [CONTEXT]  if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    [ATTENTION]    if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (   "  (  line   "  +  getLineNumber  (  )  +   "  )  invalid  char  between  encapsulated  token  and  delimiter "  )  ;  }  }  }    [METHOD]  encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber  
[ADD]  c  =  in  .  read  (  )  ;	[BUGGY]  [FE]  (line  0)  invalid  char  between  encapsulated  token  and  delimiter  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "  foo "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "  foo   "  ,  parser.nextToken(new  Token()))  ;  //      assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "b "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  [ATTENTION]  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (   "  (  line   "  +  getLineNumber  (  )  +   "  )  invalid  char  between  encapsulated  token  and  delimiter "  )  ;  }  }  }    [METHOD]  encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber  
[ADD]  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN;  return  tkn;  }  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF;	[BUGGY]  [CE]  'else'  without  'if'  [CONTEXT]  private  Token  encapsulatedTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {    int  startLineNumber  =  getLineNumber  (  )  ;      while  (  true  )  {  c  =  in  .  read  (  )  ;    if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  if  (  isEncapsulator  (  c  )  )  {  if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  [ATTENTION]      tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (   "  (  line   "  +  getLineNumber  (  )  +   "  )  invalid  char  between  encapsulated  token  and  delimiter "  )  ;  }  }  }  }  else  if  (  isEndOfFile  (  c  )  )  {    throw  new  IOException  (   "  (  startline   "  +  startLineNumber  +   "  )  EOF  reached  before  encapsulated  token  finished "  )  ;  }  else  {    tkn  .  content  .  append  (  (  char  )  c  )  ;  }  }  }    [METHOD]  encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber  
[ADD]  tkn  .  type  =  TOKEN;  return  tkn;	[BUGGY]  [FE]  (line  0)  invalid  char  between  encapsulated  token  and  delimiter  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "  foo "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "  foo   "  ,  parser.nextToken(new  Token()))  ;  //      assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "b "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  private  Token  encapsulatedTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {    int  startLineNumber  =  getLineNumber  (  )  ;      while  (  true  )  {  c  =  in  .  read  (  )  ;    if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  if  (  isEncapsulator  (  c  )  )  {  if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  [ATTENTION]    }  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (   "  (  line   "  +  getLineNumber  (  )  +   "  )  invalid  char  between  encapsulated  token  and  delimiter "  )  ;  }  }  }  }  else  if  (  isEndOfFile  (  c  )  )  {    throw  new  IOException  (   "  (  startline   "  +  startLineNumber  +   "  )  EOF  reached  before  encapsulated  token  finished "  )  ;  }  else  {    tkn  .  content  .  append  (  (  char  )  c  )  ;  }  }  }    [METHOD]  encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber  
[ADD]  tkn  .  type  =  TOKEN;  return  tkn;	[BUGGY]  return  tkn  ;  [FE]  (line  1)  invalid  char  between  encapsulated  token  and  delimiter  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "  foo "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "  foo   "  ,  parser.nextToken(new  Token()))  ;  //      assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "b "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  [ATTENTION]  return  tkn  ;    }  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (   "  (  line   "  +  getLineNumber  (  )  +   "  )  invalid  char  between  encapsulated  token  and  delimiter "  )  ;  }  }  }    [METHOD]  encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber  
[ADD]  tkn  .  type  =  EOF;  tkn  .  isReady  =  true;	[BUGGY]  tkn  .  isReady  =  true  ;  [FE]  (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo\n "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "foo\n  baar  ,  ,  ,   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "\n\t  \n "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  private  Token  encapsulatedTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {    int  startLineNumber  =  getLineNumber  (  )  ;      while  (  true  )  {  c  =  in  .  read  (  )  ;    if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  if  (  isEncapsulator  (  c  )  )  {  if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  [ATTENTION]  tkn  .  isReady  =  true  ;    return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (   "  (  line   "  +  getLineNumber  (  )  +   "  )  invalid  char  between  encapsulated  token  and  delimiter "  )  ;  }  }  }  }  else  if  (  isEndOfFile  (  c  )  )  {    throw  new  IOException  (   "  (  startline   "  +  startLineNumber  +   "  )  EOF  reached  before  encapsulated  token  finished "  )  ;  }  else  {    tkn  .  content  .  append  (  (  char  )  c  )  ;  }  }  }    [METHOD]  encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber  
[REPLACE]  private  final  List<String>  record  =  new  ArrayList<String>  (  )  ;	[BUGGY]  private  List<String>  record  =  new  ArrayList<String>  (  )  ;  [FE]  (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo\n "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "foo\n  baar  ,  ,  ,   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "\n\t  \n "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]      [CLASS]  CSVParser  1  
[REPLACE]  private  final  Token  reusableToken  =  new  Token  (  )  ;	[BUGGY]  private  final  Token  reusableToken  ;  [CE]  variable  reusableToken  might  not  have  been  initialized  [CONTEXT]      [CLASS]  CSVParser  1  
[REPLACE]  this  (  input,  CSVFormat  .  DEFAULT  )  ;	[BUGGY]  while  (  (  rec  =  getRecord  (  )  )  !  =  null  )  {  records  .  add  (  rec  )  ;  [CE]  illegal  start  of  expression  [CONTEXT]  public  CSVParser  (  Reader  input  )  throws  IOException  {  [ATTENTION]  while  (  (  rec  =  getRecord  (  )  )  !  =  null  )  {  records  .  add  (  rec  )    ;  }    [METHOD]  <init>  [TYPE]  Reader)  [PARAMETER]  Reader  input  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  boolean  false  true  [TYPE]  Reader  input  [TYPE]  List  record  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  [TYPE]  Map  headerMapping  
[REPLACE]  format  .  validate  (  )  ;	[BUGGY]  format  .  getHeader  (  )    ;  [FE]  (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo\n "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "foo\n  baar  ,  ,  ,   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "\n\t  \n "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  public  CSVParser  (  Reader  input  ,  CSVFormat  format  )  throws  IOException  {  [ATTENTION]  format  .  getHeader  (  )  ;    this  .  lexer  =  new  CSVLexer  (  format  ,  new  ExtendedBufferedReader  (  input  )  )  ;    this  .  headerMapping  =  initializeHeader  (  format  )  ;  }    [METHOD]  <init>  [TYPE]  CSVFormat)  [PARAMETER]  Reader  input  CSVFormat  format  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  boolean  false  true  [TYPE]  Reader  input  [TYPE]  List  record  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  [TYPE]  CSVFormat  format  [TYPE]  Map  headerMapping  
[REPLACE]  this  .  lexer  =  new  CSVLexer  (  format,  new  ExtendedBufferedReader  (  input  )  )  ;	[BUGGY]  this  .  lexer  =    new  CSVLexer  (  null  ,  new  ExtendedBufferedReader  (  input  )  )  ;  [FE]  (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo\n "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "foo\n  baar  ,  ,  ,   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "\n\t  \n "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  public  CSVParser  (  Reader  input  ,  CSVFormat  format  )  throws  IOException  {  format  .  validate  (  )  ;    [ATTENTION]  this  .  lexer  =  new  CSVLexer  (  null  ,  new  ExtendedBufferedReader  (  input  )  )    ;    this  .  headerMapping  =  initializeHeader  (  format  )  ;  }    [METHOD]  <init>  [TYPE]  CSVFormat)  [PARAMETER]  Reader  input  CSVFormat  format  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  boolean  false  true  [TYPE]  Reader  input  [TYPE]  List  record  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  [TYPE]  CSVFormat  format  [TYPE]  Map  headerMapping  
[REPLACE]  this  .  headerMapping  =  initializeHeader  (  format  )  ;	[BUGGY]  this  .  headerMapping  =    initializeHeader  (  null  )  ;  [FE]  (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo\n "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "foo\n  baar  ,  ,  ,   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "\n\t  \n "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  public  CSVParser  (  Reader  input  ,  CSVFormat  format  )  throws  IOException  {  format  .  validate  (  )  ;    this  .  lexer  =  new  CSVLexer  (  format  ,  new  ExtendedBufferedReader  (  input  )  )  ;    [ATTENTION]  this  .  headerMapping  =  initializeHeader  (  null  )    ;  }    [METHOD]  <init>  [TYPE]  CSVFormat)  [PARAMETER]  Reader  input  CSVFormat  format  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  boolean  false  true  [TYPE]  Reader  input  [TYPE]  List  record  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  [TYPE]  CSVFormat  format  [TYPE]  Map  headerMapping  
[ADD]  this  .  headerMapping  =  initializeHeader  (  format  )  ;  }	[BUGGY]  [CE]  illegal  start  of  expression  [CONTEXT]  public  CSVParser  (  Reader  input  ,  CSVFormat  format  )  throws  IOException  {  format  .  validate  (  )  ;    this  .  lexer  =  new  CSVLexer  (  format  ,  new  ExtendedBufferedReader  (  input  )  )  ;    [ATTENTION]      [METHOD]  <init>  [TYPE]  CSVFormat)  [PARAMETER]  Reader  input  CSVFormat  format  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  boolean  false  true  [TYPE]  Reader  input  [TYPE]  List  record  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  [TYPE]  CSVFormat  format  [TYPE]  Map  headerMapping  
[REPLACE]  this  (  new  StringReader  (  input  )  ,  format  )  ;	[BUGGY]  this  .  headerMapping  =  initializeHeader  (  format  )  ;  [CE]  variable  lexer  might  not  have  been  initialized  [CONTEXT]  public  CSVParser  (  String  input  ,  CSVFormat  format  )  throws  IOException{  [ATTENTION]  this  .  headerMapping  =  initializeHeader  (  format  )    ;  }    [METHOD]  <init>  [TYPE]  CSVFormat)  [PARAMETER]  String  input  CSVFormat  format  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  boolean  false  true  [TYPE]  List  record  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  [TYPE]  CSVFormat  format  [TYPE]  String  input  [TYPE]  Map  headerMapping  
[REMOVE]  	[BUGGY]  while  (  (  rec  =  getRecord  (  )  )  !  =  null  )  {  records  .  add  (  rec  )  ;  [CE]  illegal  start  of  expression  [CONTEXT]  public  CSVParser  (  String  input  ,  CSVFormat  format  )  throws  IOException{  [ATTENTION]  this  (  new  StringReader  (  input  )  ,  format  )  ;      [METHOD]  <init>  [TYPE]  CSVFormat)  [PARAMETER]  String  input  CSVFormat  format  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  boolean  false  true  [TYPE]  List  record  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  [TYPE]  CSVFormat  format  [TYPE]  String  input  [TYPE]  Map  headerMapping  
[REPLACE]  List<CSVRecord>  records  =  new  ArrayList<CSVRecord>  (  )  ;	[BUGGY]  CSVRecord  rec  =  getRecord  (  )  ;  [CE]  variable  rec  is  already  defined  in  method  getRecords()  [CONTEXT]  public  List<CSVRecord>  getRecords  (  )  throws  IOException  {  [ATTENTION]  CSVRecord  rec  =  getRecord  (  )    ;  CSVRecord  rec  ;  while  (  (  rec  =  getRecord  (  )  )  !  =  null  )  {  records  .  add  (  rec  )  ;  }  return  records  ;  }    [METHOD]  getRecords  [TYPE]  List  [PARAMETER]  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  rec  [TYPE]  boolean  false  true  [TYPE]  Map  headerMapping  
[REPLACE]  CSVRecord  rec;	[BUGGY]  CSVRecord  rec  =  getRecord  (  )  ;  [FE]  (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo\n "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "foo\n  baar  ,  ,  ,   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "\n\t  \n "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  public  List<CSVRecord>  getRecords  (  )  throws  IOException  {  List<CSVRecord>  records  =  new  ArrayList<CSVRecord>  (  )  ;  [ATTENTION]  CSVRecord  rec  =  getRecord  (  )    ;  while  (  (  rec  =  getRecord  (  )  )  !  =  null  )  {  records  .  add  (  rec  )  ;  }  return  records  ;  }    [METHOD]  getRecords  [TYPE]  List  [PARAMETER]  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  rec  [TYPE]  boolean  false  true  [TYPE]  Map  headerMapping  
[ADD]  CSVRecord  rec;	[BUGGY]  [CE]  cannot  find  symbol  rec  [CONTEXT]  public  List<CSVRecord>  getRecords  (  )  throws  IOException  {  List<CSVRecord>  records  =  new  ArrayList<CSVRecord>  (  )  ;  [ATTENTION]  while  (  (  rec  =  getRecord  (  )  )  !  =  null  )  {  records  .  add  (  rec  )  ;  }  return  records  ;  }    [METHOD]  getRecords  [TYPE]  List  [PARAMETER]  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  rec  [TYPE]  boolean  false  true  [TYPE]  Map  headerMapping  
[REPLACE]  while  (  (  rec  =  getRecord  (  )  )  !=  null  )  {	[BUGGY]  while  (  (  rec  =  getRecord  (  )  )    =  =  null  )  {[FE]  (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo\n "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "foo\n  baar  ,  ,  ,   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "\n\t  \n "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  public  List<CSVRecord>  getRecords  (  )  throws  IOException  {  List<CSVRecord>  records  =  new  ArrayList<CSVRecord>  (  )  ;  CSVRecord  rec  ;  [ATTENTION]  while  (  (  rec  =  getRecord  (  )  )  =  =  null  )  {  records  .  add  (  rec  )  ;  }  return  records  ;  }    [METHOD]  getRecords  [TYPE]  List  [PARAMETER]  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  rec  [TYPE]  boolean  false  true  [TYPE]  Map  headerMapping  
[ADD]  while  (  (  rec  =  getRecord  (  )  )  !=  null  )  {  records  .  add  (  rec  )  ;	[BUGGY]  [CE]  illegal  start  of  type  [CONTEXT]  public  List<CSVRecord>  getRecords  (  )  throws  IOException  {  List<CSVRecord>  records  =  new  ArrayList<CSVRecord>  (  )  ;  CSVRecord  rec  ;  [ATTENTION]    }  return  records  ;  }    [METHOD]  getRecords  [TYPE]  List  [PARAMETER]  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  rec  [TYPE]  boolean  false  true  [TYPE]  Map  headerMapping  
[REPLACE]  records  .  add  (  rec  )  ;	[BUGGY]  records  .  add  (  current  )  ;  [CE]  cannot  find  symbol  current  [CONTEXT]  public  List<CSVRecord>  getRecords  (  )  throws  IOException  {  List<CSVRecord>  records  =  new  ArrayList<CSVRecord>  (  )  ;  CSVRecord  rec  ;  while  (  (  rec  =  getRecord  (  )  )  !  =  null  )  {  [ATTENTION]  records  .  add  (  current  )    ;  }  return  records  ;  }    [METHOD]  getRecords  [TYPE]  List  [PARAMETER]  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  rec  [TYPE]  boolean  false  true  [TYPE]  Map  headerMapping  
[REPLACE]  while  (  (  rec  =  getRecord  (  )  )  !=  null  )  {	[BUGGY]  while  (  (  rec    =    while  (  (  rec  ;  [CE]  illegal  start  of  expression  [CONTEXT]  public  List<CSVRecord>  getRecords  (  )  throws  IOException  {  List<CSVRecord>  records  =  new  ArrayList<CSVRecord>  (  )  ;  CSVRecord  rec  ;  [ATTENTION]  while  (  (  rec  =  while  (  (  rec  ;  records  .  add  (  rec  )  ;  }  return  records  ;  }    [METHOD]  getRecords  [TYPE]  List  [PARAMETER]  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  rec  [TYPE]  boolean  false  true  [TYPE]  Map  headerMapping  
[REPLACE]  return  records;	[BUGGY]  return  null  ;  [FE]  (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo\n "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "foo\n  baar  ,  ,  ,   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "\n\t  \n "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  public  List<CSVRecord>  getRecords  (  )  throws  IOException  {  List<CSVRecord>  records  =  new  ArrayList<CSVRecord>  (  )  ;  CSVRecord  rec  ;  while  (  (  rec  =  getRecord  (  )  )  !  =  null  )  {  records  .  add  (  rec  )  ;  }  [ATTENTION]  return  null  ;  }    [METHOD]  getRecords  [TYPE]  List  [PARAMETER]  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  rec  [TYPE]  boolean  false  true  [TYPE]  Map  headerMapping  
[REPLACE]  CSVRecord  result  =  new  CSVRecord  (  null,  headerMapping  )  ;	[BUGGY]  CSVRecord  result  =  new  CSVRecord  (  true  ,  headerMapping  )  ;  [CE]  constructor  CSVRecord  in  class  CSVRecord  cannot  be  applied  to  given  types  ;  [CONTEXT]  CSVRecord  getRecord  (  )  throws  IOException  {  [ATTENTION]  CSVRecord  result  =  new  CSVRecord  (  true  ,  headerMapping  )    ;  record  .  clear  (  )  ;  do  {  reusableToken  .  reset  (  )  ;  lexer  .  nextToken  (  reusableToken  )  ;  switch  (  reusableToken  .  type  )  {  case  TOKEN:  record  .  add  (  reusableToken  .  content  .  toString  (  )  )  ;  break  ;  case  EORECORD:  record  .  add  (  reusableToken  .  content  .  toString  (  )  )  ;  break  ;  case  EOF:  if  (  reusableToken  .  isReady  )  {  record  .  add  (  reusableToken  .  content  .  toString  (  )  )  ;  }  else  {  result  =  null  ;  }  break  ;  case  INVALID:  throw  new  IOException  (   "  (  line   "  +  getLineNumber  (  )  +   "  )  invalid  parse  sequence "  )  ;  }  }  while  (  reusableToken  .  type  =  =  TOKEN  )  ;    if  (  !record  .  isEmpty  (  )  )  {  result  =  new  CSVRecord  (  record  .  toArray  (  new  String[record  .  size  (  )  ]  )  ,  headerMapping  )  ;  }  return  result  ;  }    [METHOD]  getRecord  [TYPE]  CSVRecord  [PARAMETER]  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  rec  result  [TYPE]  boolean  false  true  [TYPE]  Map  headerMapping  
[ADD]  CSVRecord  result  =  new  CSVRecord  (  null,  headerMapping  )  ;	[BUGGY]  [CE]  cannot  find  symbol  result  [CONTEXT]  CSVRecord  getRecord  (  )  throws  IOException  {  [ATTENTION]  record  .  clear  (  )  ;  do  {  reusableToken  .  reset  (  )  ;  lexer  .  nextToken  (  reusableToken  )  ;  switch  (  reusableToken  .  type  )  {  case  TOKEN:  record  .  add  (  reusableToken  .  content  .  toString  (  )  )  ;  break  ;  case  EORECORD:  record  .  add  (  reusableToken  .  content  .  toString  (  )  )  ;  break  ;  case  EOF:  if  (  reusableToken  .  isReady  )  {  record  .  add  (  reusableToken  .  content  .  toString  (  )  )  ;  }  else  {  result  =  null  ;  }  break  ;  case  INVALID:  throw  new  IOException  (   "  (  line   "  +  getLineNumber  (  )  +   "  )  invalid  parse  sequence "  )  ;  }  }  while  (  reusableToken  .  type  =  =  TOKEN  )  ;    if  (  !record  .  isEmpty  (  )  )  {  result  =  new  CSVRecord  (  record  .  toArray  (  new  String[record  .  size  (  )  ]  )  ,  headerMapping  )  ;  }  return  result  ;  }    [METHOD]  getRecord  [TYPE]  CSVRecord  [PARAMETER]  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  rec  result  [TYPE]  boolean  false  true  [TYPE]  Map  headerMapping  
[REPLACE]  record  .  clear  (  )  ;	[BUGGY]  record  .  isEmpty  (  )    ;  [FE]  [CONTEXT]  CSVRecord  getRecord  (  )  throws  IOException  {  CSVRecord  result  =  new  CSVRecord  (  null  ,  headerMapping  )  ;  [ATTENTION]  record  .  isEmpty  (  )  ;  do  {  reusableToken  .  reset  (  )  ;  lexer  .  nextToken  (  reusableToken  )  ;  switch  (  reusableToken  .  type  )  {  case  TOKEN:  record  .  add  (  reusableToken  .  content  .  toString  (  )  )  ;  break  ;  case  EORECORD:  record  .  add  (  reusableToken  .  content  .  toString  (  )  )  ;  break  ;  case  EOF:  if  (  reusableToken  .  isReady  )  {  record  .  add  (  reusableToken  .  content  .  toString  (  )  )  ;  }  else  {  result  =  null  ;  }  break  ;  case  INVALID:  throw  new  IOException  (   "  (  line   "  +  getLineNumber  (  )  +   "  )  invalid  parse  sequence "  )  ;  }  }  while  (  reusableToken  .  type  =  =  TOKEN  )  ;    if  (  !record  .  isEmpty  (  )  )  {  result  =  new  CSVRecord  (  record  .  toArray  (  new  String[record  .  size  (  )  ]  )  ,  headerMapping  )  ;  }  return  result  ;  }    [METHOD]  getRecord  [TYPE]  CSVRecord  [PARAMETER]  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  rec  result  [TYPE]  boolean  false  true  [TYPE]  Map  headerMapping  
[REPLACE]  if  (  reusableToken  .  isReady  )  {	[BUGGY]  if  (  format  .  getHeader  (  )  !  =  null  )  {[CE]  cannot  find  symbol  format  [CONTEXT]  CSVRecord  getRecord  (  )  throws  IOException  {  CSVRecord  result  =  new  CSVRecord  (  null  ,  headerMapping  )  ;  record  .  clear  (  )  ;  do  {  reusableToken  .  reset  (  )  ;  lexer  .  nextToken  (  reusableToken  )  ;  switch  (  reusableToken  .  type  )  {  case  TOKEN:  record  .  add  (  reusableToken  .  content  .  toString  (  )  )  ;  break  ;  case  EORECORD:  record  .  add  (  reusableToken  .  content  .  toString  (  )  )  ;  break  ;  case  EOF:  [ATTENTION]  if  (  format  .  getHeader  (  )  !  =  null  )  {  record  .  add  (  reusableToken  .  content  .  toString  (  )  )  ;  }  else  {  result  =  null  ;  }  break  ;  case  INVALID:  throw  new  IOException  (   "  (  line   "  +  getLineNumber  (  )  +   "  )  invalid  parse  sequence "  )  ;  }  }  while  (  reusableToken  .  type  =  =  TOKEN  )  ;    if  (  !record  .  isEmpty  (  )  )  {  result  =  new  CSVRecord  (  record  .  toArray  (  new  String[record  .  size  (  )  ]  )  ,  headerMapping  )  ;  }  return  result  ;  }    [METHOD]  getRecord  [TYPE]  CSVRecord  [PARAMETER]  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  rec  result  [TYPE]  boolean  false  true  [TYPE]  Map  headerMapping  
[REPLACE]  result  =  null;	[BUGGY]  result  =  false  ;  [CE]  incompatible  types  [CONTEXT]  if  (  reusableToken  .  isReady  )  {  record  .  add  (  reusableToken  .  content  .  toString  (  )  )  ;  }  else  {  [ATTENTION]  result  =  false  ;  }    [METHOD]  getRecord  [TYPE]  CSVRecord  [PARAMETER]  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  rec  result  [TYPE]  boolean  false  true  [TYPE]  Map  headerMapping  
[ADD]  result  =  null;	[BUGGY]  [FE]  [CONTEXT]  if  (  reusableToken  .  isReady  )  {  record  .  add  (  reusableToken  .  content  .  toString  (  )  )  ;  }  else  {  [ATTENTION]  }    [METHOD]  getRecord  [TYPE]  CSVRecord  [PARAMETER]  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  rec  result  [TYPE]  boolean  false  true  [TYPE]  Map  headerMapping  
[REPLACE]  record  .  add  (  reusableToken  .  content  .  toString  (  )  )  ;	[BUGGY]  record  .  toArray  (  reusableToken  .  content  .  toString  (  )  )  ;  [CE]  no  suitable  method  found  for  toArray(String)  [CONTEXT]  CSVRecord  getRecord  (  )  throws  IOException  {  CSVRecord  result  =  new  CSVRecord  (  null  ,  headerMapping  )  ;  record  .  clear  (  )  ;  do  {  reusableToken  .  reset  (  )  ;  lexer  .  nextToken  (  reusableToken  )  ;  switch  (  reusableToken  .  type  )  {  case  TOKEN:  record  .  add  (  reusableToken  .  content  .  toString  (  )  )  ;  break  ;  case  EORECORD:  record  .  add  (  reusableToken  .  content  .  toString  (  )  )  ;  break  ;  case  EOF:  if  (  reusableToken  .  isReady  )  {  [ATTENTION]  record  .  toArray  (  reusableToken  .  content  .  toString  (  )  )    ;  }  else  {  result  =  null  ;  }  break  ;  case  INVALID:  throw  new  IOException  (   "  (  line   "  +  getLineNumber  (  )  +   "  )  invalid  parse  sequence "  )  ;  }  }  while  (  reusableToken  .  type  =  =  TOKEN  )  ;    if  (  !record  .  isEmpty  (  )  )  {  result  =  new  CSVRecord  (  record  .  toArray  (  new  String[record  .  size  (  )  ]  )  ,  headerMapping  )  ;  }  return  result  ;  }    [METHOD]  getRecord  [TYPE]  CSVRecord  [PARAMETER]  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  rec  result  [TYPE]  boolean  false  true  [TYPE]  Map  headerMapping  
[REPLACE]  record  .  add  (  reusableToken  .  content  .  toString  (  )  )  ;	[BUGGY]  record  .  add  (  reusableToken  .  content  .  getRecord  (  )  )  ;  [CE]  cannot  find  symbol  [CONTEXT]  CSVRecord  getRecord  (  )  throws  IOException  {  CSVRecord  result  =  new  CSVRecord  (  null  ,  headerMapping  )  ;  record  .  clear  (  )  ;  do  {  reusableToken  .  reset  (  )  ;  lexer  .  nextToken  (  reusableToken  )  ;  switch  (  reusableToken  .  type  )  {  case  TOKEN:  record  .  add  (  reusableToken  .  content  .  toString  (  )  )  ;  break  ;  case  EORECORD:  record  .  add  (  reusableToken  .  content  .  toString  (  )  )  ;  break  ;  case  EOF:  if  (  reusableToken  .  isReady  )  {  [ATTENTION]  record  .  add  (  reusableToken  .  content  .  getRecord  (  )  )    ;  }  else  {  result  =  null  ;  }  break  ;  case  INVALID:  throw  new  IOException  (   "  (  line   "  +  getLineNumber  (  )  +   "  )  invalid  parse  sequence "  )  ;  }  }  while  (  reusableToken  .  type  =  =  TOKEN  )  ;    if  (  !record  .  isEmpty  (  )  )  {  result  =  new  CSVRecord  (  record  .  toArray  (  new  String[record  .  size  (  )  ]  )  ,  headerMapping  )  ;  }  return  result  ;  }    [METHOD]  getRecord  [TYPE]  CSVRecord  [PARAMETER]  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  rec  result  [TYPE]  boolean  false  true  [TYPE]  Map  headerMapping  
[REPLACE]  result  =  null;	[BUGGY]  result  =  true  ;  [CE]  incompatible  types  [CONTEXT]  CSVRecord  getRecord  (  )  throws  IOException  {  CSVRecord  result  =  new  CSVRecord  (  null  ,  headerMapping  )  ;  record  .  clear  (  )  ;  do  {  reusableToken  .  reset  (  )  ;  lexer  .  nextToken  (  reusableToken  )  ;  switch  (  reusableToken  .  type  )  {  case  TOKEN:  record  .  add  (  reusableToken  .  content  .  toString  (  )  )  ;  break  ;  case  EORECORD:  record  .  add  (  reusableToken  .  content  .  toString  (  )  )  ;  break  ;  case  EOF:  if  (  reusableToken  .  isReady  )  {  record  .  add  (  reusableToken  .  content  .  toString  (  )  )  ;  }  else  {  [ATTENTION]  result  =  true  ;  }  break  ;  case  INVALID:  throw  new  IOException  (   "  (  line   "  +  getLineNumber  (  )  +   "  )  invalid  parse  sequence "  )  ;  }  }  while  (  reusableToken  .  type  =  =  TOKEN  )  ;    if  (  !record  .  isEmpty  (  )  )  {  result  =  new  CSVRecord  (  record  .  toArray  (  new  String[record  .  size  (  )  ]  )  ,  headerMapping  )  ;  }  return  result  ;  }    [METHOD]  getRecord  [TYPE]  CSVRecord  [PARAMETER]  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  rec  result  [TYPE]  boolean  false  true  [TYPE]  Map  headerMapping  
[REPLACE]  throw  new  IOException  ( "   ")  ;	[BUGGY]  throw  new  UnsupportedOperationException  ( "   ")    ;    ;  [CE]  unreachable  statement  [CONTEXT]  CSVRecord  getRecord  (  )  throws  IOException  {  CSVRecord  result  =  new  CSVRecord  (  null  ,  headerMapping  )  ;  record  .  clear  (  )  ;  do  {  reusableToken  .  reset  (  )  ;  lexer  .  nextToken  (  reusableToken  )  ;  switch  (  reusableToken  .  type  )  {  case  TOKEN:  record  .  add  (  reusableToken  .  content  .  toString  (  )  )  ;  break  ;  case  EORECORD:  record  .  add  (  reusableToken  .  content  .  toString  (  )  )  ;  break  ;  case  EOF:  if  (  reusableToken  .  isReady  )  {  record  .  add  (  reusableToken  .  content  .  toString  (  )  )  ;  }  else  {  result  =  null  ;  }  break  ;  case  INVALID:  [ATTENTION]  throw  new  UnsupportedOperationException  (   "   "  )  ;    ;  }  }  while  (  reusableToken  .  type  =  =  TOKEN  )  ;    if  (  !record  .  isEmpty  (  )  )  {  result  =  new  CSVRecord  (  record  .  toArray  (  new  String[record  .  size  (  )  ]  )  ,  headerMapping  )  ;  }  return  result  ;  }    [METHOD]  getRecord  [TYPE]  CSVRecord  [PARAMETER]  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  rec  result  [TYPE]  boolean  false  true  [TYPE]  Map  headerMapping  
[REPLACE]  if  (  !record  .  isEmpty  (  )  )  {	[BUGGY]  if  (  record  .  isEmpty  (  )  )  {[FE]  [CONTEXT]  CSVRecord  getRecord  (  )  throws  IOException  {  CSVRecord  result  =  new  CSVRecord  (  null  ,  headerMapping  )  ;  record  .  clear  (  )  ;  do  {  reusableToken  .  reset  (  )  ;  lexer  .  nextToken  (  reusableToken  )  ;  switch  (  reusableToken  .  type  )  {  case  TOKEN:  record  .  add  (  reusableToken  .  content  .  toString  (  )  )  ;  break  ;  case  EORECORD:  record  .  add  (  reusableToken  .  content  .  toString  (  )  )  ;  break  ;  case  EOF:  if  (  reusableToken  .  isReady  )  {  record  .  add  (  reusableToken  .  content  .  toString  (  )  )  ;  }  else  {  result  =  null  ;  }  break  ;  case  INVALID:  throw  new  IOException  (   "  (  line   "  +  getLineNumber  (  )  +   "  )  invalid  parse  sequence "  )  ;  }  }  while  (  reusableToken  .  type  =  =  TOKEN  )  ;    [ATTENTION]  if  (  record  .  isEmpty  (  )  )  {  result  =  new  CSVRecord  (  record  .  toArray  (  new  String[record  .  size  (  )  ]  )  ,  headerMapping  )  ;  }  return  result  ;  }    [METHOD]  getRecord  [TYPE]  CSVRecord  [PARAMETER]  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  rec  result  [TYPE]  boolean  false  true  [TYPE]  Map  headerMapping  
[ADD]  if  (  !record  .  isEmpty  (  )  )  {  result  =  new  CSVRecord  (  record  .  toArray  (  new  String[record  .  size  (  )  ]  )  ,  headerMapping  )  ;  }	[BUGGY]  [FE]  (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo\n "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "foo\n  baar  ,  ,  ,   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "\n\t  \n "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  CSVRecord  getRecord  (  )  throws  IOException  {  CSVRecord  result  =  new  CSVRecord  (  null  ,  headerMapping  )  ;  record  .  clear  (  )  ;  do  {  reusableToken  .  reset  (  )  ;  lexer  .  nextToken  (  reusableToken  )  ;  switch  (  reusableToken  .  type  )  {  case  TOKEN:  record  .  add  (  reusableToken  .  content  .  toString  (  )  )  ;  break  ;  case  EORECORD:  record  .  add  (  reusableToken  .  content  .  toString  (  )  )  ;  break  ;  case  EOF:  if  (  reusableToken  .  isReady  )  {  record  .  add  (  reusableToken  .  content  .  toString  (  )  )  ;  }  else  {  result  =  null  ;  }  break  ;  case  INVALID:  throw  new  IOException  (   "  (  line   "  +  getLineNumber  (  )  +   "  )  invalid  parse  sequence "  )  ;  }  }  while  (  reusableToken  .  type  =  =  TOKEN  )  ;    [ATTENTION]    return  result  ;  }    [METHOD]  getRecord  [TYPE]  CSVRecord  [PARAMETER]  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  rec  result  [TYPE]  boolean  false  true  [TYPE]  Map  headerMapping  
[REPLACE]  result  =  new  CSVRecord  (  record  .  toArray  (  new  String[record  .  size  (  )  ]  )  ,  headerMapping  )  ;	[BUGGY]  result  ;  [CE]  not  a  statement  [CONTEXT]  CSVRecord  getRecord  (  )  throws  IOException  {  CSVRecord  result  =  new  CSVRecord  (  null  ,  headerMapping  )  ;  record  .  clear  (  )  ;  do  {  reusableToken  .  reset  (  )  ;  lexer  .  nextToken  (  reusableToken  )  ;  switch  (  reusableToken  .  type  )  {  case  TOKEN:  record  .  add  (  reusableToken  .  content  .  toString  (  )  )  ;  break  ;  case  EORECORD:  record  .  add  (  reusableToken  .  content  .  toString  (  )  )  ;  break  ;  case  EOF:  if  (  reusableToken  .  isReady  )  {  record  .  add  (  reusableToken  .  content  .  toString  (  )  )  ;  }  else  {  result  =  null  ;  }  break  ;  case  INVALID:  throw  new  IOException  (   "  (  line   "  +  getLineNumber  (  )  +   "  )  invalid  parse  sequence "  )  ;  }  }  while  (  reusableToken  .  type  =  =  TOKEN  )  ;    if  (  !record  .  isEmpty  (  )  )  {  [ATTENTION]  result  ;  }  return  result  ;  }    [METHOD]  getRecord  [TYPE]  CSVRecord  [PARAMETER]  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  rec  result  [TYPE]  boolean  false  true  [TYPE]  Map  headerMapping  
[REPLACE]  result  =  new  CSVRecord  (  record  .  toArray  (  new  String[record  .  size  (  )  ]  )  ,  headerMapping  )  ;	[BUGGY]  result    =  null  ;  [FE]  (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo\n "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "foo\n  baar  ,  ,  ,   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "\n\t  \n "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  CSVRecord  getRecord  (  )  throws  IOException  {  CSVRecord  result  =  new  CSVRecord  (  null  ,  headerMapping  )  ;  record  .  clear  (  )  ;  do  {  reusableToken  .  reset  (  )  ;  lexer  .  nextToken  (  reusableToken  )  ;  switch  (  reusableToken  .  type  )  {  case  TOKEN:  record  .  add  (  reusableToken  .  content  .  toString  (  )  )  ;  break  ;  case  EORECORD:  record  .  add  (  reusableToken  .  content  .  toString  (  )  )  ;  break  ;  case  EOF:  if  (  reusableToken  .  isReady  )  {  record  .  add  (  reusableToken  .  content  .  toString  (  )  )  ;  }  else  {  result  =  null  ;  }  break  ;  case  INVALID:  throw  new  IOException  (   "  (  line   "  +  getLineNumber  (  )  +   "  )  invalid  parse  sequence "  )  ;  }  }  while  (  reusableToken  .  type  =  =  TOKEN  )  ;    if  (  !record  .  isEmpty  (  )  )  {  [ATTENTION]  result  =  null  ;  }  return  result  ;  }    [METHOD]  getRecord  [TYPE]  CSVRecord  [PARAMETER]  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  rec  result  [TYPE]  boolean  false  true  [TYPE]  Map  headerMapping  
[REPLACE]  return  result;	[BUGGY]  return  rec  ;  [CE]  cannot  find  symbol  rec  [CONTEXT]  CSVRecord  getRecord  (  )  throws  IOException  {  CSVRecord  result  =  new  CSVRecord  (  null  ,  headerMapping  )  ;  record  .  clear  (  )  ;  do  {  reusableToken  .  reset  (  )  ;  lexer  .  nextToken  (  reusableToken  )  ;  switch  (  reusableToken  .  type  )  {  case  TOKEN:  record  .  add  (  reusableToken  .  content  .  toString  (  )  )  ;  break  ;  case  EORECORD:  record  .  add  (  reusableToken  .  content  .  toString  (  )  )  ;  break  ;  case  EOF:  if  (  reusableToken  .  isReady  )  {  record  .  add  (  reusableToken  .  content  .  toString  (  )  )  ;  }  else  {  result  =  null  ;  }  break  ;  case  INVALID:  throw  new  IOException  (   "  (  line   "  +  getLineNumber  (  )  +   "  )  invalid  parse  sequence "  )  ;  }  }  while  (  reusableToken  .  type  =  =  TOKEN  )  ;    if  (  !record  .  isEmpty  (  )  )  {  result  =  new  CSVRecord  (  record  .  toArray  (  new  String[record  .  size  (  )  ]  )  ,  headerMapping  )  ;  }  [ATTENTION]  return  rec  ;  }    [METHOD]  getRecord  [TYPE]  CSVRecord  [PARAMETER]  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  rec  result  [TYPE]  boolean  false  true  [TYPE]  Map  headerMapping  
[REPLACE]  Map<String,  Integer>  hdrMap  =  null;	[BUGGY]  Map<String  ,  Integer>  hdrMap  =  false  ;  [CE]  incompatible  types  [CONTEXT]  private  Map<String  ,  Integer>  initializeHeader  (  CSVFormat  format  )  throws  IOException  {  [ATTENTION]  Map<String  ,  Integer>  hdrMap  =  false  ;  if  (  format  .  getHeader  (  )  !  =  null  )  {  hdrMap  =  new  HashMap<String  ,  Integer>  (  )  ;    String[]  header  =  null  ;  if  (  format  .  getHeader  (  )  .  length  =  =  0  )  {    CSVRecord  rec  =  getRecord  (  )  ;  if  (  rec  !  =  null  )  {  header  =  rec  .  values  (  )  ;  }  }  else  {  header  =  format  .  getHeader  (  )  ;  }    if  (  header  !  =  null  )  {  for  (  int  i  =  0  ;  i  <  header  .  length  ;  i++  )  {  hdrMap  .  put  (  header[i]  ,  Integer  .  valueOf  (  i  )  )  ;  }  }  }  return  hdrMap  ;  }    [METHOD]  initializeHeader  [TYPE]  Map  [PARAMETER]  CSVFormat  format  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  boolean  false  true  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  rec  result  [TYPE]  CSVFormat  format  [TYPE]  String[]  header  [TYPE]  Map  hdrMap  headerMapping  [TYPE]  int  i  
[REPLACE]  if  (  format  .  getHeader  (  )  !=  null  )  {	[BUGGY]  if  (  format  .  validate  (  )    =  =  null  )  {[CE]  'void'  type  not  allowed  here  [CONTEXT]  private  Map<String  ,  Integer>  initializeHeader  (  CSVFormat  format  )  throws  IOException  {  Map<String  ,  Integer>  hdrMap  =  null  ;  [ATTENTION]  if  (  format  .  validate  (  )  =  =  null  )  {  hdrMap  =  new  HashMap<String  ,  Integer>  (  )  ;    String[]  header  =  null  ;  if  (  format  .  getHeader  (  )  .  length  =  =  0  )  {    CSVRecord  rec  =  getRecord  (  )  ;  if  (  rec  !  =  null  )  {  header  =  rec  .  values  (  )  ;  }  }  else  {  header  =  format  .  getHeader  (  )  ;  }    if  (  header  !  =  null  )  {  for  (  int  i  =  0  ;  i  <  header  .  length  ;  i++  )  {  hdrMap  .  put  (  header[i]  ,  Integer  .  valueOf  (  i  )  )  ;  }  }  }  return  hdrMap  ;  }    [METHOD]  initializeHeader  [TYPE]  Map  [PARAMETER]  CSVFormat  format  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  boolean  false  true  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  rec  result  [TYPE]  CSVFormat  format  [TYPE]  String[]  header  [TYPE]  Map  hdrMap  headerMapping  [TYPE]  int  i  
[ADD]  if  (  format  .  getHeader  (  )  !=  null  )  {  hdrMap  =  new  HashMap<String,  Integer>  (  )  ;  String[]  header  =  null;	[BUGGY]  [CE]  illegal  start  of  type  [CONTEXT]  private  Map<String  ,  Integer>  initializeHeader  (  CSVFormat  format  )  throws  IOException  {  Map<String  ,  Integer>  hdrMap  =  null  ;  [ATTENTION]      if  (  format  .  getHeader  (  )  .  length  =  =  0  )  {    CSVRecord  rec  =  getRecord  (  )  ;  if  (  rec  !  =  null  )  {  header  =  rec  .  values  (  )  ;  }  }  else  {  header  =  format  .  getHeader  (  )  ;  }    if  (  header  !  =  null  )  {  for  (  int  i  =  0  ;  i  <  header  .  length  ;  i++  )  {  hdrMap  .  put  (  header[i]  ,  Integer  .  valueOf  (  i  )  )  ;  }  }  }  return  hdrMap  ;  }    [METHOD]  initializeHeader  [TYPE]  Map  [PARAMETER]  CSVFormat  format  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  boolean  false  true  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  rec  result  [TYPE]  CSVFormat  format  [TYPE]  String[]  header  [TYPE]  Map  hdrMap  headerMapping  [TYPE]  int  i  
[REPLACE]  if  (  format  .  getHeader  (  )    .  length  ==  0  )  {	[BUGGY]  if  (  format  .  getHeader  (  )  .  length  +  2  =  =  0  )  {[FE]  (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo\n "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "foo\n  baar  ,  ,  ,   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "\n\t  \n "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  private  Map<String  ,  Integer>  initializeHeader  (  CSVFormat  format  )  throws  IOException  {  Map<String  ,  Integer>  hdrMap  =  null  ;  if  (  format  .  getHeader  (  )  !  =  null  )  {  hdrMap  =  new  HashMap<String  ,  Integer>  (  )  ;    String[]  header  =  null  ;  [ATTENTION]  if  (  format  .  getHeader  (  )    .  length  +  2  =  =  0  )  {    CSVRecord  rec  =  getRecord  (  )  ;  if  (  rec  !  =  null  )  {  header  =  rec  .  values  (  )  ;  }  }  else  {  header  =  format  .  getHeader  (  )  ;  }    if  (  header  !  =  null  )  {  for  (  int  i  =  0  ;  i  <  header  .  length  ;  i++  )  {  hdrMap  .  put  (  header[i]  ,  Integer  .  valueOf  (  i  )  )  ;  }  }  }  return  hdrMap  ;  }    [METHOD]  initializeHeader  [TYPE]  Map  [PARAMETER]  CSVFormat  format  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  boolean  false  true  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  rec  result  [TYPE]  CSVFormat  format  [TYPE]  String[]  header  [TYPE]  Map  hdrMap  headerMapping  [TYPE]  int  i  
[REPLACE]  header  =  format  .  getHeader  (  )  ;	[BUGGY]  header  =    null  .  getHeader  (  )  ;  [CE]  <null>  cannot  be  dereferenced  [CONTEXT]  private  Map<String  ,  Integer>  initializeHeader  (  CSVFormat  format  )  throws  IOException  {  Map<String  ,  Integer>  hdrMap  =  null  ;  if  (  format  .  getHeader  (  )  !  =  null  )  {  hdrMap  =  new  HashMap<String  ,  Integer>  (  )  ;    String[]  header  =  null  ;  if  (  format  .  getHeader  (  )  .  length  =  =  0  )  {    CSVRecord  rec  =  getRecord  (  )  ;  if  (  rec  !  =  null  )  {  header  =  rec  .  values  (  )  ;  }  }  else  {  [ATTENTION]  header  =  null  .  getHeader  (  )    ;  }    if  (  header  !  =  null  )  {  for  (  int  i  =  0  ;  i  <  header  .  length  ;  i++  )  {  hdrMap  .  put  (  header[i]  ,  Integer  .  valueOf  (  i  )  )  ;  }  }  }  return  hdrMap  ;  }    [METHOD]  initializeHeader  [TYPE]  Map  [PARAMETER]  CSVFormat  format  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  boolean  false  true  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  rec  result  [TYPE]  CSVFormat  format  [TYPE]  String[]  header  [TYPE]  Map  hdrMap  headerMapping  [TYPE]  int  i  
[REPLACE]  if  (  rec  !=  null  )  {	[BUGGY]  if  (  rec  =  =  true  )  {[CE]  incomparable  types:  CSVRecord  and  boolean  [CONTEXT]  private  Map<String  ,  Integer>  initializeHeader  (  CSVFormat  format  )  throws  IOException  {  Map<String  ,  Integer>  hdrMap  =  null  ;  if  (  format  .  getHeader  (  )  !  =  null  )  {  hdrMap  =  new  HashMap<String  ,  Integer>  (  )  ;    String[]  header  =  null  ;  if  (  format  .  getHeader  (  )  .  length  =  =  0  )  {    CSVRecord  rec  =  getRecord  (  )  ;  [ATTENTION]  if  (  rec  =  =  true  )  {  header  =  rec  .  values  (  )  ;  }  }  else  {  header  =  format  .  getHeader  (  )  ;  }    if  (  header  !  =  null  )  {  for  (  int  i  =  0  ;  i  <  header  .  length  ;  i++  )  {  hdrMap  .  put  (  header[i]  ,  Integer  .  valueOf  (  i  )  )  ;  }  }  }  return  hdrMap  ;  }    [METHOD]  initializeHeader  [TYPE]  Map  [PARAMETER]  CSVFormat  format  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  boolean  false  true  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  rec  result  [TYPE]  CSVFormat  format  [TYPE]  String[]  header  [TYPE]  Map  hdrMap  headerMapping  [TYPE]  int  i  
[REPLACE]  header  =  rec  .  values  (  )  ;	[BUGGY]  header  =    null  .  values  (  )  ;  [CE]  <null>  cannot  be  dereferenced  [CONTEXT]  private  Map<String  ,  Integer>  initializeHeader  (  CSVFormat  format  )  throws  IOException  {  Map<String  ,  Integer>  hdrMap  =  null  ;  if  (  format  .  getHeader  (  )  !  =  null  )  {  hdrMap  =  new  HashMap<String  ,  Integer>  (  )  ;    String[]  header  =  null  ;  if  (  format  .  getHeader  (  )  .  length  =  =  0  )  {    CSVRecord  rec  =  getRecord  (  )  ;  if  (  rec  !  =  null  )  {  [ATTENTION]  header  =  null  .  values  (  )    ;  }  }  else  {  header  =  format  .  getHeader  (  )  ;  }    if  (  header  !  =  null  )  {  for  (  int  i  =  0  ;  i  <  header  .  length  ;  i++  )  {  hdrMap  .  put  (  header[i]  ,  Integer  .  valueOf  (  i  )  )  ;  }  }  }  return  hdrMap  ;  }    [METHOD]  initializeHeader  [TYPE]  Map  [PARAMETER]  CSVFormat  format  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  boolean  false  true  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  rec  result  [TYPE]  CSVFormat  format  [TYPE]  String[]  header  [TYPE]  Map  hdrMap  headerMapping  [TYPE]  int  i  
[REPLACE]  header  =  rec  .  values  (  )  ;	[BUGGY]  header  =    result  .  values  (  )  ;  [CE]  cannot  find  symbol  result  [CONTEXT]  private  Map<String  ,  Integer>  initializeHeader  (  CSVFormat  format  )  throws  IOException  {  Map<String  ,  Integer>  hdrMap  =  null  ;  if  (  format  .  getHeader  (  )  !  =  null  )  {  hdrMap  =  new  HashMap<String  ,  Integer>  (  )  ;    String[]  header  =  null  ;  if  (  format  .  getHeader  (  )  .  length  =  =  0  )  {    CSVRecord  rec  =  getRecord  (  )  ;  if  (  rec  !  =  null  )  {  [ATTENTION]  header  =  result  .  values  (  )    ;  }  }  else  {  header  =  format  .  getHeader  (  )  ;  }    if  (  header  !  =  null  )  {  for  (  int  i  =  0  ;  i  <  header  .  length  ;  i++  )  {  hdrMap  .  put  (  header[i]  ,  Integer  .  valueOf  (  i  )  )  ;  }  }  }  return  hdrMap  ;  }    [METHOD]  initializeHeader  [TYPE]  Map  [PARAMETER]  CSVFormat  format  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  boolean  false  true  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  rec  result  [TYPE]  CSVFormat  format  [TYPE]  String[]  header  [TYPE]  Map  hdrMap  headerMapping  [TYPE]  int  i  
[REPLACE]  CSVRecord  rec  =  getRecord  (  )  ;	[BUGGY]  CSVRecord  result  =  new  CSVRecord  (  null  ,  headerMapping  )  ;  [CE]  cannot  find  symbol  rec  [CONTEXT]  private  Map<String  ,  Integer>  initializeHeader  (  CSVFormat  format  )  throws  IOException  {  Map<String  ,  Integer>  hdrMap  =  null  ;  if  (  format  .  getHeader  (  )  !  =  null  )  {  hdrMap  =  new  HashMap<String  ,  Integer>  (  )  ;    String[]  header  =  null  ;  if  (  format  .  getHeader  (  )  .  length  =  =  0  )  {    [ATTENTION]  CSVRecord  result  =  new  CSVRecord  (  null  ,  headerMapping  )    ;  if  (  rec  !  =  null  )  {  header  =  rec  .  values  (  )  ;  }  }  else  {  header  =  format  .  getHeader  (  )  ;  }    if  (  header  !  =  null  )  {  for  (  int  i  =  0  ;  i  <  header  .  length  ;  i++  )  {  hdrMap  .  put  (  header[i]  ,  Integer  .  valueOf  (  i  )  )  ;  }  }  }  return  hdrMap  ;  }    [METHOD]  initializeHeader  [TYPE]  Map  [PARAMETER]  CSVFormat  format  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  boolean  false  true  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  rec  result  [TYPE]  CSVFormat  format  [TYPE]  String[]  header  [TYPE]  Map  hdrMap  headerMapping  [TYPE]  int  i  
[REPLACE]  if  (  rec  !=  null  )  {	[BUGGY]  if  (result  =  =  null  )  {[CE]  cannot  find  symbol  result  [CONTEXT]  private  Map<String  ,  Integer>  initializeHeader  (  CSVFormat  format  )  throws  IOException  {  Map<String  ,  Integer>  hdrMap  =  null  ;  if  (  format  .  getHeader  (  )  !  =  null  )  {  hdrMap  =  new  HashMap<String  ,  Integer>  (  )  ;    String[]  header  =  null  ;  if  (  format  .  getHeader  (  )  .  length  =  =  0  )  {    CSVRecord  rec  =  getRecord  (  )  ;  [ATTENTION]  if  (  result  =  =  null  )  {  header  =  rec  .  values  (  )  ;  }  }  else  {  header  =  format  .  getHeader  (  )  ;  }    if  (  header  !  =  null  )  {  for  (  int  i  =  0  ;  i  <  header  .  length  ;  i++  )  {  hdrMap  .  put  (  header[i]  ,  Integer  .  valueOf  (  i  )  )  ;  }  }  }  return  hdrMap  ;  }    [METHOD]  initializeHeader  [TYPE]  Map  [PARAMETER]  CSVFormat  format  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  boolean  false  true  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  rec  result  [TYPE]  CSVFormat  format  [TYPE]  String[]  header  [TYPE]  Map  hdrMap  headerMapping  [TYPE]  int  i  
[REPLACE]  if  (  header  !=  null  )  {	[BUGGY]  if  (  header  =  =  null  )  {[FE]  (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo\n "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "foo\n  baar  ,  ,  ,   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "\n\t  \n "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  private  Map<String  ,  Integer>  initializeHeader  (  CSVFormat  format  )  throws  IOException  {  Map<String  ,  Integer>  hdrMap  =  null  ;  if  (  format  .  getHeader  (  )  !  =  null  )  {  hdrMap  =  new  HashMap<String  ,  Integer>  (  )  ;    String[]  header  =  null  ;  if  (  format  .  getHeader  (  )  .  length  =  =  0  )  {    CSVRecord  rec  =  getRecord  (  )  ;  if  (  rec  !  =  null  )  {  header  =  rec  .  values  (  )  ;  }  }  else  {  header  =  format  .  getHeader  (  )  ;  }    [ATTENTION]  if  (  header  =  =  null  )  {  for  (  int  i  =  0  ;  i  <  header  .  length  ;  i++  )  {  hdrMap  .  put  (  header[i]  ,  Integer  .  valueOf  (  i  )  )  ;  }  }  }  return  hdrMap  ;  }    [METHOD]  initializeHeader  [TYPE]  Map  [PARAMETER]  CSVFormat  format  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  boolean  false  true  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  rec  result  [TYPE]  CSVFormat  format  [TYPE]  String[]  header  [TYPE]  Map  hdrMap  headerMapping  [TYPE]  int  i  
[REPLACE]  for  (  int  i  =  0;  i  <  header  .  length;  i++  )  {	[BUGGY]  for  (  int  i  =  0  ;  i  <  header  .  length  %  0  .  5  ;  i++  )  {[CE]  '  ;  '  expected  [CONTEXT]  private  Map<String  ,  Integer>  initializeHeader  (  CSVFormat  format  )  throws  IOException  {  Map<String  ,  Integer>  hdrMap  =  null  ;  if  (  format  .  getHeader  (  )  !  =  null  )  {  hdrMap  =  new  HashMap<String  ,  Integer>  (  )  ;    String[]  header  =  null  ;  if  (  format  .  getHeader  (  )  .  length  =  =  0  )  {    CSVRecord  rec  =  getRecord  (  )  ;  if  (  rec  !  =  null  )  {  header  =  rec  .  values  (  )  ;  }  }  else  {  header  =  format  .  getHeader  (  )  ;  }    if  (  header  !  =  null  )  {  [ATTENTION]  for  (  int  i  =  0  ;  i  <  header  .  length  %0  .  5  ;  i++  )  {  hdrMap  .  put  (  header[i]  ,  Integer  .  valueOf  (  i  )  )  ;  }  }  }  return  hdrMap  ;  }    [METHOD]  initializeHeader  [TYPE]  Map  [PARAMETER]  CSVFormat  format  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  boolean  false  true  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  rec  result  [TYPE]  CSVFormat  format  [TYPE]  String[]  header  [TYPE]  Map  hdrMap  headerMapping  [TYPE]  int  i  
[ADD]  for  (  int  i  =  0;  i  <  header  .  length;  i++  )  {  hdrMap  .  put  (  header[i],  Integer  .  valueOf  (  i  )  )  ;  }	[BUGGY]  [FE]  (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo\n "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "foo\n  baar  ,  ,  ,   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "\n\t  \n "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  private  Map<String  ,  Integer>  initializeHeader  (  CSVFormat  format  )  throws  IOException  {  Map<String  ,  Integer>  hdrMap  =  null  ;  if  (  format  .  getHeader  (  )  !  =  null  )  {  hdrMap  =  new  HashMap<String  ,  Integer>  (  )  ;    String[]  header  =  null  ;  if  (  format  .  getHeader  (  )  .  length  =  =  0  )  {    CSVRecord  rec  =  getRecord  (  )  ;  if  (  rec  !  =  null  )  {  header  =  rec  .  values  (  )  ;  }  }  else  {  header  =  format  .  getHeader  (  )  ;  }    if  (  header  !  =  null  )  {  [ATTENTION]    }  }  return  hdrMap  ;  }    [METHOD]  initializeHeader  [TYPE]  Map  [PARAMETER]  CSVFormat  format  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  boolean  false  true  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  rec  result  [TYPE]  CSVFormat  format  [TYPE]  String[]  header  [TYPE]  Map  hdrMap  headerMapping  [TYPE]  int  i  
[REPLACE]  hdrMap  .  put  (  header[i],  Integer  .  valueOf  (  i  )  )  ;	[BUGGY]  hdrMap  .  put  (  header[i]  ,    i    )  ;  [FE]  (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo\n "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "foo\n  baar  ,  ,  ,   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "\n\t  \n "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  private  Map<String  ,  Integer>  initializeHeader  (  CSVFormat  format  )  throws  IOException  {  Map<String  ,  Integer>  hdrMap  =  null  ;  if  (  format  .  getHeader  (  )  !  =  null  )  {  hdrMap  =  new  HashMap<String  ,  Integer>  (  )  ;    String[]  header  =  null  ;  if  (  format  .  getHeader  (  )  .  length  =  =  0  )  {    CSVRecord  rec  =  getRecord  (  )  ;  if  (  rec  !  =  null  )  {  header  =  rec  .  values  (  )  ;  }  }  else  {  header  =  format  .  getHeader  (  )  ;  }    if  (  header  !  =  null  )  {  for  (  int  i  =  0  ;  i  <  header  .  length  ;  i++  )  {  [ATTENTION]  hdrMap  .  put  (  header[i]  ,  i  )    ;  }  }  }  return  hdrMap  ;  }    [METHOD]  initializeHeader  [TYPE]  Map  [PARAMETER]  CSVFormat  format  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  boolean  false  true  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  rec  result  [TYPE]  CSVFormat  format  [TYPE]  String[]  header  [TYPE]  Map  hdrMap  headerMapping  [TYPE]  int  i  
[REPLACE]  for  (  int  i  =  0;  i  <  header  .  length;  i++  )  {	[BUGGY]  for  (  int  i  =  0  ;  i  <  header  .  length  ;  i++  )  {[FE]  (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo\n "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "foo\n  baar  ,  ,  ,   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "\n\t  \n "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  private  Map<String  ,  Integer>  initializeHeader  (  CSVFormat  format  )  throws  IOException  {  Map<String  ,  Integer>  hdrMap  =  null  ;  if  (  format  .  getHeader  (  )  !  =  null  )  {  hdrMap  =  new  HashMap<String  ,  Integer>  (  )  ;    String[]  header  =  null  ;  if  (  format  .  getHeader  (  )  .  length  =  =  0  )  {    CSVRecord  rec  =  getRecord  (  )  ;  if  (  rec  !  =  null  )  {  header  =  rec  .  values  (  )  ;  }  }  else  {  header  =  format  .  getHeader  (  )  ;  }    if  (  header  !  =  null  )  {  [ATTENTION]  for  (  int  i  =  0  ;  i  <  header  .  length  ;  i++  )  {  hdrMap  .  put  (  header[i]  ,  Integer  .  valueOf  (  i  )  )  ;  }  }  }  return  hdrMap  ;  }    [METHOD]  initializeHeader  [TYPE]  Map  [PARAMETER]  CSVFormat  format  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  boolean  false  true  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  rec  result  [TYPE]  CSVFormat  format  [TYPE]  String[]  header  [TYPE]  Map  hdrMap  headerMapping  [TYPE]  int  i  
[REPLACE]  for  (  int  i  =  0;  i  <  header  .  length;  i++  )  {	[BUGGY]  for  (  int  i  =  0  ;  i  <  header  .  length  +  2  ;  i++  )  {[FE]  (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo\n "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "foo\n  baar  ,  ,  ,   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "\n\t  \n "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  private  Map<String  ,  Integer>  initializeHeader  (  CSVFormat  format  )  throws  IOException  {  Map<String  ,  Integer>  hdrMap  =  null  ;  if  (  format  .  getHeader  (  )  !  =  null  )  {  hdrMap  =  new  HashMap<String  ,  Integer>  (  )  ;    String[]  header  =  null  ;  if  (  format  .  getHeader  (  )  .  length  =  =  0  )  {    CSVRecord  rec  =  getRecord  (  )  ;  if  (  rec  !  =  null  )  {  header  =  rec  .  values  (  )  ;  }  }  else  {  header  =  format  .  getHeader  (  )  ;  }    if  (  header  !  =  null  )  {  [ATTENTION]  for  (  int  i  =  0  ;  i  <  header  .  length  +  2  ;  i++  )  {  hdrMap  .  put  (  header[i]  ,  Integer  .  valueOf  (  i  )  )  ;  }  }  }  return  hdrMap  ;  }    [METHOD]  initializeHeader  [TYPE]  Map  [PARAMETER]  CSVFormat  format  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  boolean  false  true  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  rec  result  [TYPE]  CSVFormat  format  [TYPE]  String[]  header  [TYPE]  Map  hdrMap  headerMapping  [TYPE]  int  i  
[REPLACE]  hdrMap  =  new  HashMap<String,  Integer>  (  )  ;	[BUGGY]  hdrMap  ;  [CE]  not  a  statement  [CONTEXT]  private  Map<String  ,  Integer>  initializeHeader  (  CSVFormat  format  )  throws  IOException  {  Map<String  ,  Integer>  hdrMap  =  null  ;  if  (  format  .  getHeader  (  )  !  =  null  )  {  [ATTENTION]  hdrMap  ;    String[]  header  =  null  ;  if  (  format  .  getHeader  (  )  .  length  =  =  0  )  {    CSVRecord  rec  =  getRecord  (  )  ;  if  (  rec  !  =  null  )  {  header  =  rec  .  values  (  )  ;  }  }  else  {  header  =  format  .  getHeader  (  )  ;  }    if  (  header  !  =  null  )  {  for  (  int  i  =  0  ;  i  <  header  .  length  ;  i++  )  {  hdrMap  .  put  (  header[i]  ,  Integer  .  valueOf  (  i  )  )  ;  }  }  }  return  hdrMap  ;  }    [METHOD]  initializeHeader  [TYPE]  Map  [PARAMETER]  CSVFormat  format  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  boolean  false  true  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  rec  result  [TYPE]  CSVFormat  format  [TYPE]  String[]  header  [TYPE]  Map  hdrMap  headerMapping  [TYPE]  int  i  
[ADD]  header  =  rec  .  values  (  )  ;	[BUGGY]  [FE]  (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo\n "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "foo\n  baar  ,  ,  ,   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "\n\t  \n "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  private  Map<String  ,  Integer>  initializeHeader  (  CSVFormat  format  )  throws  IOException  {  Map<String  ,  Integer>  hdrMap  =  null  ;  if  (  format  .  getHeader  (  )  !  =  null  )  {  hdrMap  =  new  HashMap<String  ,  Integer>  (  )  ;    String[]  header  =  null  ;  if  (  format  .  getHeader  (  )  .  length  =  =  0  )  {    CSVRecord  rec  =  getRecord  (  )  ;  if  (  rec  !  =  null  )  {  [ATTENTION]  }  }  else  {  header  =  format  .  getHeader  (  )  ;  }    if  (  header  !  =  null  )  {  for  (  int  i  =  0  ;  i  <  header  .  length  ;  i++  )  {  hdrMap  .  put  (  header[i]  ,  Integer  .  valueOf  (  i  )  )  ;  }  }  }  return  hdrMap  ;  }    [METHOD]  initializeHeader  [TYPE]  Map  [PARAMETER]  CSVFormat  format  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  boolean  false  true  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  rec  result  [TYPE]  CSVFormat  format  [TYPE]  String[]  header  [TYPE]  Map  hdrMap  headerMapping  [TYPE]  int  i  
[REPLACE]  String[]  header  =  null;	[BUGGY]  String[]  header  =  false  ;  [CE]  incompatible  types  [CONTEXT]  private  Map<String  ,  Integer>  initializeHeader  (  CSVFormat  format  )  throws  IOException  {  Map<String  ,  Integer>  hdrMap  =  null  ;  if  (  format  .  getHeader  (  )  !  =  null  )  {  hdrMap  =  new  HashMap<String  ,  Integer>  (  )  ;    [ATTENTION]  String[]  header  =  false  ;  if  (  format  .  getHeader  (  )  .  length  =  =  0  )  {    CSVRecord  rec  =  getRecord  (  )  ;  if  (  rec  !  =  null  )  {  header  =  rec  .  values  (  )  ;  }  }  else  {  header  =  format  .  getHeader  (  )  ;  }    if  (  header  !  =  null  )  {  for  (  int  i  =  0  ;  i  <  header  .  length  ;  i++  )  {  hdrMap  .  put  (  header[i]  ,  Integer  .  valueOf  (  i  )  )  ;  }  }  }  return  hdrMap  ;  }    [METHOD]  initializeHeader  [TYPE]  Map  [PARAMETER]  CSVFormat  format  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  boolean  false  true  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  rec  result  [TYPE]  CSVFormat  format  [TYPE]  String[]  header  [TYPE]  Map  hdrMap  headerMapping  [TYPE]  int  i  
[ADD]  String[]  header  =  null;	[BUGGY]  [CE]  cannot  find  symbol  header  [CONTEXT]  private  Map<String  ,  Integer>  initializeHeader  (  CSVFormat  format  )  throws  IOException  {  Map<String  ,  Integer>  hdrMap  =  null  ;  if  (  format  .  getHeader  (  )  !  =  null  )  {  hdrMap  =  new  HashMap<String  ,  Integer>  (  )  ;    [ATTENTION]  if  (  format  .  getHeader  (  )  .  length  =  =  0  )  {    CSVRecord  rec  =  getRecord  (  )  ;  if  (  rec  !  =  null  )  {  header  =  rec  .  values  (  )  ;  }  }  else  {  header  =  format  .  getHeader  (  )  ;  }    if  (  header  !  =  null  )  {  for  (  int  i  =  0  ;  i  <  header  .  length  ;  i++  )  {  hdrMap  .  put  (  header[i]  ,  Integer  .  valueOf  (  i  )  )  ;  }  }  }  return  hdrMap  ;  }    [METHOD]  initializeHeader  [TYPE]  Map  [PARAMETER]  CSVFormat  format  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  boolean  false  true  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  rec  result  [TYPE]  CSVFormat  format  [TYPE]  String[]  header  [TYPE]  Map  hdrMap  headerMapping  [TYPE]  int  i  
[ADD]  CSVRecord  rec  =  getRecord  (  )  ;	[BUGGY]  [CE]  cannot  find  symbol  rec  [CONTEXT]  private  Map<String  ,  Integer>  initializeHeader  (  CSVFormat  format  )  throws  IOException  {  Map<String  ,  Integer>  hdrMap  =  null  ;  if  (  format  .  getHeader  (  )  !  =  null  )  {  hdrMap  =  new  HashMap<String  ,  Integer>  (  )  ;    String[]  header  =  null  ;  if  (  format  .  getHeader  (  )  .  length  =  =  0  )  {    [ATTENTION]  if  (  rec  !  =  null  )  {  header  =  rec  .  values  (  )  ;  }  }  else  {  header  =  format  .  getHeader  (  )  ;  }    if  (  header  !  =  null  )  {  for  (  int  i  =  0  ;  i  <  header  .  length  ;  i++  )  {  hdrMap  .  put  (  header[i]  ,  Integer  .  valueOf  (  i  )  )  ;  }  }  }  return  hdrMap  ;  }    [METHOD]  initializeHeader  [TYPE]  Map  [PARAMETER]  CSVFormat  format  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  boolean  false  true  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  rec  result  [TYPE]  CSVFormat  format  [TYPE]  String[]  header  [TYPE]  Map  hdrMap  headerMapping  [TYPE]  int  i  
[REPLACE]  if  (  format  .  getHeader  (  )    .  length  ==  0  )  {	[BUGGY]  if  (  format  .  getHeader  (  )  .  length  %  2  =  =  0  )  {[FE]  (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo\n "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "foo\n  baar  ,  ,  ,   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "\n\t  \n "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  private  Map<String  ,  Integer>  initializeHeader  (  CSVFormat  format  )  throws  IOException  {  Map<String  ,  Integer>  hdrMap  =  null  ;  if  (  format  .  getHeader  (  )  !  =  null  )  {  hdrMap  =  new  HashMap<String  ,  Integer>  (  )  ;    String[]  header  =  null  ;  [ATTENTION]  if  (  format  .  getHeader  (  )    .  length  %2  =  =  0  )  {    CSVRecord  rec  =  getRecord  (  )  ;  if  (  rec  !  =  null  )  {  header  =  rec  .  values  (  )  ;  }  }  else  {  header  =  format  .  getHeader  (  )  ;  }    if  (  header  !  =  null  )  {  for  (  int  i  =  0  ;  i  <  header  .  length  ;  i++  )  {  hdrMap  .  put  (  header[i]  ,  Integer  .  valueOf  (  i  )  )  ;  }  }  }  return  hdrMap  ;  }    [METHOD]  initializeHeader  [TYPE]  Map  [PARAMETER]  CSVFormat  format  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  boolean  false  true  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  rec  result  [TYPE]  CSVFormat  format  [TYPE]  String[]  header  [TYPE]  Map  hdrMap  headerMapping  [TYPE]  int  i  
[ADD]  header  =  format  .  getHeader  (  )  ;  }	[BUGGY]  [CE]  illegal  start  of  expression  [CONTEXT]  private  Map<String  ,  Integer>  initializeHeader  (  CSVFormat  format  )  throws  IOException  {  Map<String  ,  Integer>  hdrMap  =  null  ;  if  (  format  .  getHeader  (  )  !  =  null  )  {  hdrMap  =  new  HashMap<String  ,  Integer>  (  )  ;    String[]  header  =  null  ;  if  (  format  .  getHeader  (  )  .  length  =  =  0  )  {    CSVRecord  rec  =  getRecord  (  )  ;  if  (  rec  !  =  null  )  {  header  =  rec  .  values  (  )  ;  }  }  else  {  [ATTENTION]      if  (  header  !  =  null  )  {  for  (  int  i  =  0  ;  i  <  header  .  length  ;  i++  )  {  hdrMap  .  put  (  header[i]  ,  Integer  .  valueOf  (  i  )  )  ;  }  }  }  return  hdrMap  ;  }    [METHOD]  initializeHeader  [TYPE]  Map  [PARAMETER]  CSVFormat  format  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  boolean  false  true  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  rec  result  [TYPE]  CSVFormat  format  [TYPE]  String[]  header  [TYPE]  Map  hdrMap  headerMapping  [TYPE]  int  i  
[REPLACE]  if  (  rec  !=  null  )  {	[BUGGY]  if  (  rec  =  =  null  )  {[FE]  (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo\n "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "foo\n  baar  ,  ,  ,   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "\n\t  \n "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  private  Map<String  ,  Integer>  initializeHeader  (  CSVFormat  format  )  throws  IOException  {  Map<String  ,  Integer>  hdrMap  =  null  ;  if  (  format  .  getHeader  (  )  !  =  null  )  {  hdrMap  =  new  HashMap<String  ,  Integer>  (  )  ;    String[]  header  =  null  ;  if  (  format  .  getHeader  (  )  .  length  =  =  0  )  {    CSVRecord  rec  =  getRecord  (  )  ;  [ATTENTION]  if  (  rec  =  =  null  )  {  header  =  rec  .  values  (  )  ;  }  }  else  {  header  =  format  .  getHeader  (  )  ;  }    if  (  header  !  =  null  )  {  for  (  int  i  =  0  ;  i  <  header  .  length  ;  i++  )  {  hdrMap  .  put  (  header[i]  ,  Integer  .  valueOf  (  i  )  )  ;  }  }  }  return  hdrMap  ;  }    [METHOD]  initializeHeader  [TYPE]  Map  [PARAMETER]  CSVFormat  format  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  boolean  false  true  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  rec  result  [TYPE]  CSVFormat  format  [TYPE]  String[]  header  [TYPE]  Map  hdrMap  headerMapping  [TYPE]  int  i  
[REPLACE]  for  (  int  i  =  0;  i  <  header  .  length;  i++  )  {	[BUGGY]  for  (  int  i  =  0  ;  i  <  header  .  length  *  0  .  5  ;  i++  )  {[FE]  (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo\n "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "foo\n  baar  ,  ,  ,   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "\n\t  \n "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  private  Map<String  ,  Integer>  initializeHeader  (  CSVFormat  format  )  throws  IOException  {  Map<String  ,  Integer>  hdrMap  =  null  ;  if  (  format  .  getHeader  (  )  !  =  null  )  {  hdrMap  =  new  HashMap<String  ,  Integer>  (  )  ;    String[]  header  =  null  ;  if  (  format  .  getHeader  (  )  .  length  =  =  0  )  {    CSVRecord  rec  =  getRecord  (  )  ;  if  (  rec  !  =  null  )  {  header  =  rec  .  values  (  )  ;  }  }  else  {  header  =  format  .  getHeader  (  )  ;  }    if  (  header  !  =  null  )  {  [ATTENTION]  for  (  int  i  =  0  ;  i  <  header  .  length  *0  .  5  ;  i++  )  {  hdrMap  .  put  (  header[i]  ,  Integer  .  valueOf  (  i  )  )  ;  }  }  }  return  hdrMap  ;  }    [METHOD]  initializeHeader  [TYPE]  Map  [PARAMETER]  CSVFormat  format  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  boolean  false  true  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  rec  result  [TYPE]  CSVFormat  format  [TYPE]  String[]  header  [TYPE]  Map  hdrMap  headerMapping  [TYPE]  int  i  
[ADD]  hdrMap  .  put  (  header[i],  Integer  .  valueOf  (  i  )  )  ;	[BUGGY]  [FE]  (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo\n "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "foo\n  baar  ,  ,  ,   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "\n\t  \n "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  private  Map<String  ,  Integer>  initializeHeader  (  CSVFormat  format  )  throws  IOException  {  Map<String  ,  Integer>  hdrMap  =  null  ;  if  (  format  .  getHeader  (  )  !  =  null  )  {  hdrMap  =  new  HashMap<String  ,  Integer>  (  )  ;    String[]  header  =  null  ;  if  (  format  .  getHeader  (  )  .  length  =  =  0  )  {    CSVRecord  rec  =  getRecord  (  )  ;  if  (  rec  !  =  null  )  {  header  =  rec  .  values  (  )  ;  }  }  else  {  header  =  format  .  getHeader  (  )  ;  }    if  (  header  !  =  null  )  {  for  (  int  i  =  0  ;  i  <  header  .  length  ;  i++  )  {  [ATTENTION]  }  }  }  return  hdrMap  ;  }    [METHOD]  initializeHeader  [TYPE]  Map  [PARAMETER]  CSVFormat  format  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  boolean  false  true  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  rec  result  [TYPE]  CSVFormat  format  [TYPE]  String[]  header  [TYPE]  Map  hdrMap  headerMapping  [TYPE]  int  i  
[REPLACE]  for  (  int  i  =  0;  i  <  header  .  length;  i++  )  {	[BUGGY]  for  (  int  i  =  0  ;  i  <  header  .  length  (  )  ;  i++  )  {[CE]  cannot  find  symbol  [CONTEXT]  private  Map<String  ,  Integer>  initializeHeader  (  CSVFormat  format  )  throws  IOException  {  Map<String  ,  Integer>  hdrMap  =  null  ;  if  (  format  .  getHeader  (  )  !  =  null  )  {  hdrMap  =  new  HashMap<String  ,  Integer>  (  )  ;    String[]  header  =  null  ;  if  (  format  .  getHeader  (  )  .  length  =  =  0  )  {    CSVRecord  rec  =  getRecord  (  )  ;  if  (  rec  !  =  null  )  {  header  =  rec  .  values  (  )  ;  }  }  else  {  header  =  format  .  getHeader  (  )  ;  }    if  (  header  !  =  null  )  {  [ATTENTION]  for  (  int  i  =  0  ;  i  <  header  .  length  (  )    ;  i++  )  {  hdrMap  .  put  (  header[i]  ,  Integer  .  valueOf  (  i  )  )  ;  }  }  }  return  hdrMap  ;  }    [METHOD]  initializeHeader  [TYPE]  Map  [PARAMETER]  CSVFormat  format  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  boolean  false  true  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  rec  result  [TYPE]  CSVFormat  format  [TYPE]  String[]  header  [TYPE]  Map  hdrMap  headerMapping  [TYPE]  int  i  
[REMOVE]  	[BUGGY]  header  =  rec  .  values  (  )  ;  [CE]  cannot  find  symbol  rec  [CONTEXT]  private  Map<String  ,  Integer>  initializeHeader  (  CSVFormat  format  )  throws  IOException  {  Map<String  ,  Integer>  hdrMap  =  null  ;  if  (  format  .  getHeader  (  )  !  =  null  )  {  hdrMap  =  new  HashMap<String  ,  Integer>  (  )  ;    String[]  header  =  null  ;  if  (  format  .  getHeader  (  )  .  length  =  =  0  )  {    CSVRecord  rec  =  getRecord  (  )  ;  if  (  rec  !  =  null  )  {  header  =  rec  .  values  (  )  ;  }  }  else  {  header  =  format  .  getHeader  (  )  ;  }    if  (  header  !  =  null  )  {  for  (  int  i  =  0  ;  i  <  header  .  length  ;  i++  )  {  [ATTENTION]  hdrMap  .  put  (  header[i]  ,  Integer  .  valueOf  (  i  )  )  ;    header  =  rec  .  values  (  )    ;  }  }  }  return  hdrMap  ;      [METHOD]  initializeHeader  [TYPE]  Map  [PARAMETER]  CSVFormat  format  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  boolean  false  true  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  rec  result  [TYPE]  CSVFormat  format  [TYPE]  String[]  header  [TYPE]  Map  hdrMap  headerMapping  [TYPE]  int  i  
[REPLACE]  hdrMap  =  new  HashMap<String,  Integer>  (  )  ;	[BUGGY]  hdrMap    =  null  ;  [FE]  (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo\n "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "foo\n  baar  ,  ,  ,   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "\n\t  \n "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  private  Map<String  ,  Integer>  initializeHeader  (  CSVFormat  format  )  throws  IOException  {  Map<String  ,  Integer>  hdrMap  =  null  ;  if  (  format  .  getHeader  (  )  !  =  null  )  {  [ATTENTION]  hdrMap  =  null  ;    String[]  header  =  null  ;  if  (  format  .  getHeader  (  )  .  length  =  =  0  )  {    CSVRecord  rec  =  getRecord  (  )  ;  if  (  rec  !  =  null  )  {  header  =  rec  .  values  (  )  ;  }  }  else  {  header  =  format  .  getHeader  (  )  ;  }    if  (  header  !  =  null  )  {  for  (  int  i  =  0  ;  i  <  header  .  length  ;  i++  )  {  hdrMap  .  put  (  header[i]  ,  Integer  .  valueOf  (  i  )  )  ;  }  }  }  return  hdrMap  ;  }    [METHOD]  initializeHeader  [TYPE]  Map  [PARAMETER]  CSVFormat  format  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  boolean  false  true  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  rec  result  [TYPE]  CSVFormat  format  [TYPE]  String[]  header  [TYPE]  Map  hdrMap  headerMapping  [TYPE]  int  i  
[REPLACE]  String[]  header  =  null;	[BUGGY]  String[]  header  =  this  ;  [CE]  incompatible  types  [CONTEXT]  private  Map<String  ,  Integer>  initializeHeader  (  CSVFormat  format  )  throws  IOException  {  Map<String  ,  Integer>  hdrMap  =  null  ;  if  (  format  .  getHeader  (  )  !  =  null  )  {  hdrMap  =  new  HashMap<String  ,  Integer>  (  )  ;    [ATTENTION]  String[]  header  =  this  ;  if  (  format  .  getHeader  (  )  .  length  =  =  0  )  {    CSVRecord  rec  =  getRecord  (  )  ;  if  (  rec  !  =  null  )  {  header  =  rec  .  values  (  )  ;  }  }  else  {  header  =  format  .  getHeader  (  )  ;  }    if  (  header  !  =  null  )  {  for  (  int  i  =  0  ;  i  <  header  .  length  ;  i++  )  {  hdrMap  .  put  (  header[i]  ,  Integer  .  valueOf  (  i  )  )  ;  }  }  }  return  hdrMap  ;  }    [METHOD]  initializeHeader  [TYPE]  Map  [PARAMETER]  CSVFormat  format  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  boolean  false  true  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  rec  result  [TYPE]  CSVFormat  format  [TYPE]  String[]  header  [TYPE]  Map  hdrMap  headerMapping  [TYPE]  int  i  
[REPLACE]  return  hdrMap;	[BUGGY]  return  null  ;  [FE]  (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo\n "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "foo\n  baar  ,  ,  ,   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "\n\t  \n "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  private  Map<String  ,  Integer>  initializeHeader  (  CSVFormat  format  )  throws  IOException  {  Map<String  ,  Integer>  hdrMap  =  null  ;  if  (  format  .  getHeader  (  )  !  =  null  )  {  hdrMap  =  new  HashMap<String  ,  Integer>  (  )  ;    String[]  header  =  null  ;  if  (  format  .  getHeader  (  )  .  length  =  =  0  )  {    CSVRecord  rec  =  getRecord  (  )  ;  if  (  rec  !  =  null  )  {  header  =  rec  .  values  (  )  ;  }  }  else  {  header  =  format  .  getHeader  (  )  ;  }    if  (  header  !  =  null  )  {  for  (  int  i  =  0  ;  i  <  header  .  length  ;  i++  )  {  hdrMap  .  put  (  header[i]  ,  Integer  .  valueOf  (  i  )  )  ;  }  }  }  [ATTENTION]  return  null  ;  }    [METHOD]  initializeHeader  [TYPE]  Map  [PARAMETER]  CSVFormat  format  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  boolean  false  true  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  rec  result  [TYPE]  CSVFormat  format  [TYPE]  String[]  header  [TYPE]  Map  hdrMap  headerMapping  [TYPE]  int  i  
[REPLACE]  if  (  current  ==  null  )  {	[BUGGY]  if  (  current  !  =  this  )  {[CE]  incomparable  types:  CSVRecord  and  <anonymous  Iterator<CSVRecord>>  [CONTEXT]  public  Iterator<CSVRecord>  iterator  (  )  {  return  new  Iterator<CSVRecord>  (  )  {  private  CSVRecord  current  ;    public  boolean  hasNext  (  )  {  [ATTENTION]  if  (  current  !  =  this  )  {  current  =  getNextRecord  (  )  ;  }  return  current  !  =  null  ;  }  public  CSVRecord  next  (  )  {  CSVRecord  next  =  current  ;  current  =  null  ;    if  (  next  =  =  null  )  {    next  =  getNextRecord  (  )  ;  if  (  next  =  =  null  )  {  throw  new  NoSuchElementException  (   "No  more  CSV  records  available "  )  ;  }  }  return  next  ;  }  private  CSVRecord  getNextRecord  (  )  {  try  {  return  getRecord  (  )  ;  }  catch  (  IOException  e  )  {  throw  new  RuntimeException  (  e  )  ;  }  }  public  void  remove  (  )  {  throw  new  UnsupportedOperationException  (  )  ;  }  }  ;  }    [METHOD]  iterator  [TYPE]  Iterator  [PARAMETER]  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  boolean  false  true  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  next  rec  result  [TYPE]  IOException  e  [TYPE]  Map  hdrMap  headerMapping  
[ADD]  if  (  current  ==  null  )  {  current  =  getNextRecord  (  )  ;  }	[BUGGY]  current  =  getNextRecord  (  )  ;  [FE]  (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo\n "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "foo\n  baar  ,  ,  ,   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "\n\t  \n "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  public  Iterator<CSVRecord>  iterator  (  )  {  return  new  Iterator<CSVRecord>  (  )  {  private  CSVRecord  current  ;    public  boolean  hasNext  (  )  {  [ATTENTION]  current  =  getNextRecord  (  )    ;      return  current  !  =  null  ;  }  public  CSVRecord  next  (  )  {  CSVRecord  next  =  current  ;  current  =  null  ;    if  (  next  =  =  null  )  {    next  =  getNextRecord  (  )  ;  if  (  next  =  =  null  )  {  throw  new  NoSuchElementException  (   "No  more  CSV  records  available "  )  ;  }  }  return  next  ;  }  private  CSVRecord  getNextRecord  (  )  {  try  {  return  getRecord  (  )  ;  }  catch  (  IOException  e  )  {  throw  new  RuntimeException  (  e  )  ;  }  }  public  void  remove  (  )  {  throw  new  UnsupportedOperationException  (  )  ;  }  }  ;  }    [METHOD]  iterator  [TYPE]  Iterator  [PARAMETER]  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  boolean  false  true  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  next  rec  result  [TYPE]  IOException  e  [TYPE]  Map  hdrMap  headerMapping  
[REPLACE]  current  =  getNextRecord  (  )  ;	[BUGGY]  next  =  getNextRecord  (  )  ;    ;  [CE]  cannot  find  symbol  next  [CONTEXT]  public  Iterator<CSVRecord>  iterator  (  )  {  return  new  Iterator<CSVRecord>  (  )  {  private  CSVRecord  current  ;    public  boolean  hasNext  (  )  {  if  (  current  =  =  null  )  {  [ATTENTION]  next  =  getNextRecord  (  )    ;    ;  }  return  current  !  =  null  ;  }  public  CSVRecord  next  (  )  {  CSVRecord  next  =  current  ;  current  =  null  ;    if  (  next  =  =  null  )  {    next  =  getNextRecord  (  )  ;  if  (  next  =  =  null  )  {  throw  new  NoSuchElementException  (   "No  more  CSV  records  available "  )  ;  }  }  return  next  ;  }  private  CSVRecord  getNextRecord  (  )  {  try  {  return  getRecord  (  )  ;  }  catch  (  IOException  e  )  {  throw  new  RuntimeException  (  e  )  ;  }  }  public  void  remove  (  )  {  throw  new  UnsupportedOperationException  (  )  ;  }  }  ;  }    [METHOD]  iterator  [TYPE]  Iterator  [PARAMETER]  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  boolean  false  true  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  next  rec  result  [TYPE]  IOException  e  [TYPE]  Map  hdrMap  headerMapping  
[REPLACE]  if  (  next  ==  null  )  {	[BUGGY]  if  (  next  !  =  null  )  {[FE]  (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo\n "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "foo\n  baar  ,  ,  ,   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "\n\t  \n "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  public  Iterator<CSVRecord>  iterator  (  )  {  return  new  Iterator<CSVRecord>  (  )  {  private  CSVRecord  current  ;    public  boolean  hasNext  (  )  {  if  (  current  =  =  null  )  {  current  =  getNextRecord  (  )  ;  }  return  current  !  =  null  ;  }  public  CSVRecord  next  (  )  {  CSVRecord  next  =  current  ;  current  =  null  ;    [ATTENTION]  if  (  next  !  =  null  )  {    next  =  getNextRecord  (  )  ;  if  (  next  =  =  null  )  {  throw  new  NoSuchElementException  (   "No  more  CSV  records  available "  )  ;  }  }  return  next  ;  }  private  CSVRecord  getNextRecord  (  )  {  try  {  return  getRecord  (  )  ;  }  catch  (  IOException  e  )  {  throw  new  RuntimeException  (  e  )  ;  }  }  public  void  remove  (  )  {  throw  new  UnsupportedOperationException  (  )  ;  }  }  ;  }    [METHOD]  iterator  [TYPE]  Iterator  [PARAMETER]  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  boolean  false  true  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  next  rec  result  [TYPE]  IOException  e  [TYPE]  Map  hdrMap  headerMapping  
[REPLACE]  if  (  next  ==  null  )  {	[BUGGY]  if  (  next  !  =  null  )  {[FE]  (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo\n "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "foo\n  baar  ,  ,  ,   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "\n\t  \n "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  public  Iterator<CSVRecord>  iterator  (  )  {  return  new  Iterator<CSVRecord>  (  )  {  private  CSVRecord  current  ;    public  boolean  hasNext  (  )  {  if  (  current  =  =  null  )  {  current  =  getNextRecord  (  )  ;  }  return  current  !  =  null  ;  }  public  CSVRecord  next  (  )  {  CSVRecord  next  =  current  ;  current  =  null  ;    if  (  next  =  =  null  )  {    next  =  getNextRecord  (  )  ;  [ATTENTION]  if  (  next  !  =  null  )  {  throw  new  NoSuchElementException  (   "No  more  CSV  records  available "  )  ;  }  }  return  next  ;  }  private  CSVRecord  getNextRecord  (  )  {  try  {  return  getRecord  (  )  ;  }  catch  (  IOException  e  )  {  throw  new  RuntimeException  (  e  )  ;  }  }  public  void  remove  (  )  {  throw  new  UnsupportedOperationException  (  )  ;  }  }  ;  }    [METHOD]  iterator  [TYPE]  Iterator  [PARAMETER]  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  boolean  false  true  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  next  rec  result  [TYPE]  IOException  e  [TYPE]  Map  hdrMap  headerMapping  
[REPLACE]  throw  new  NoSuchElementException  ( "   ")  ;	[BUGGY]  throw  new  UnsupportedOperationException  ( "   ")    ;    ;  [CE]  unreachable  statement  [CONTEXT]  public  Iterator<CSVRecord>  iterator  (  )  {  return  new  Iterator<CSVRecord>  (  )  {  private  CSVRecord  current  ;    public  boolean  hasNext  (  )  {  if  (  current  =  =  null  )  {  current  =  getNextRecord  (  )  ;  }  return  current  !  =  null  ;  }  public  CSVRecord  next  (  )  {  CSVRecord  next  =  current  ;  current  =  null  ;    if  (  next  =  =  null  )  {    next  =  getNextRecord  (  )  ;  if  (  next  =  =  null  )  {  [ATTENTION]  throw  new  UnsupportedOperationException  (   "   "  )  ;    ;  }  }  return  next  ;  }  private  CSVRecord  getNextRecord  (  )  {  try  {  return  getRecord  (  )  ;  }  catch  (  IOException  e  )  {  throw  new  RuntimeException  (  e  )  ;  }  }  public  void  remove  (  )  {  throw  new  UnsupportedOperationException  (  )  ;  }  }  ;  }    [METHOD]  iterator  [TYPE]  Iterator  [PARAMETER]  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  boolean  false  true  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  next  rec  result  [TYPE]  IOException  e  [TYPE]  Map  hdrMap  headerMapping  
[REPLACE]  next  =  getNextRecord  (  )  ;	[BUGGY]  current  =  getNextRecord  (  )  ;    ;  [FE]  (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo\n "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "foo\n  baar  ,  ,  ,   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "\n\t  \n "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  public  Iterator<CSVRecord>  iterator  (  )  {  return  new  Iterator<CSVRecord>  (  )  {  private  CSVRecord  current  ;    public  boolean  hasNext  (  )  {  if  (  current  =  =  null  )  {  current  =  getNextRecord  (  )  ;  }  return  current  !  =  null  ;  }  public  CSVRecord  next  (  )  {  CSVRecord  next  =  current  ;  current  =  null  ;    if  (  next  =  =  null  )  {    [ATTENTION]  current  =  getNextRecord  (  )    ;    ;  if  (  next  =  =  null  )  {  throw  new  NoSuchElementException  (   "No  more  CSV  records  available "  )  ;  }  }  return  next  ;  }  private  CSVRecord  getNextRecord  (  )  {  try  {  return  getRecord  (  )  ;  }  catch  (  IOException  e  )  {  throw  new  RuntimeException  (  e  )  ;  }  }  public  void  remove  (  )  {  throw  new  UnsupportedOperationException  (  )  ;  }  }  ;  }    [METHOD]  iterator  [TYPE]  Iterator  [PARAMETER]  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  boolean  false  true  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  next  rec  result  [TYPE]  IOException  e  [TYPE]  Map  hdrMap  headerMapping  
[REPLACE]  if  (  next  ==  null  )  {	[BUGGY]  if  (  result  !  =  false  )  {[CE]  cannot  find  symbol  result  [CONTEXT]  public  Iterator<CSVRecord>  iterator  (  )  {  return  new  Iterator<CSVRecord>  (  )  {  private  CSVRecord  current  ;    public  boolean  hasNext  (  )  {  if  (  current  =  =  null  )  {  current  =  getNextRecord  (  )  ;  }  return  current  !  =  null  ;  }  public  CSVRecord  next  (  )  {  CSVRecord  next  =  current  ;  current  =  null  ;    if  (  next  =  =  null  )  {    next  =  getNextRecord  (  )  ;  [ATTENTION]  if  (  result  !  =  false  )  {  throw  new  NoSuchElementException  (   "No  more  CSV  records  available "  )  ;  }  }  return  next  ;  }  private  CSVRecord  getNextRecord  (  )  {  try  {  return  getRecord  (  )  ;  }  catch  (  IOException  e  )  {  throw  new  RuntimeException  (  e  )  ;  }  }  public  void  remove  (  )  {  throw  new  UnsupportedOperationException  (  )  ;  }  }  ;  }    [METHOD]  iterator  [TYPE]  Iterator  [PARAMETER]  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  boolean  false  true  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  next  rec  result  [TYPE]  IOException  e  [TYPE]  Map  hdrMap  headerMapping  
[REPLACE]  throw  new  NoSuchElementException  ( "   ")  ;	[BUGGY]  return  ;  [CE]  missing  return  value  [CONTEXT]  public  Iterator<CSVRecord>  iterator  (  )  {  return  new  Iterator<CSVRecord>  (  )  {  private  CSVRecord  current  ;    public  boolean  hasNext  (  )  {  if  (  current  =  =  null  )  {  current  =  getNextRecord  (  )  ;  }  return  current  !  =  null  ;  }  public  CSVRecord  next  (  )  {  CSVRecord  next  =  current  ;  current  =  null  ;    if  (  next  =  =  null  )  {    next  =  getNextRecord  (  )  ;  if  (  next  =  =  null  )  {  [ATTENTION]  return  ;  }  }  return  next  ;  }  private  CSVRecord  getNextRecord  (  )  {  try  {  return  getRecord  (  )  ;  }  catch  (  IOException  e  )  {  throw  new  RuntimeException  (  e  )  ;  }  }  public  void  remove  (  )  {  throw  new  UnsupportedOperationException  (  )  ;  }  }  ;  }    [METHOD]  iterator  [TYPE]  Iterator  [PARAMETER]  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  boolean  false  true  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  next  rec  result  [TYPE]  IOException  e  [TYPE]  Map  hdrMap  headerMapping  
[ADD]  try  {  return  getRecord  (  )  ;  }  catch  (  IOException  e  )  {  throw  new  RuntimeException  ( "   ")  ;  }	[BUGGY]  return  getRecord  (  )  ;  [CE]  unreported  exception  IOException  ;  must  be  caught  or  declared  to  be  thrown  [CONTEXT]  public  Iterator<CSVRecord>  iterator  (  )  {  return  new  Iterator<CSVRecord>  (  )  {  private  CSVRecord  current  ;    public  boolean  hasNext  (  )  {  if  (  current  =  =  null  )  {  current  =  getNextRecord  (  )  ;  }  return  current  !  =  null  ;  }  public  CSVRecord  next  (  )  {  CSVRecord  next  =  current  ;  current  =  null  ;    if  (  next  =  =  null  )  {    next  =  getNextRecord  (  )  ;  if  (  next  =  =  null  )  {  throw  new  NoSuchElementException  (   "No  more  CSV  records  available "  )  ;  }  }  return  next  ;  }  private  CSVRecord  getNextRecord  (  )  {  [ATTENTION]  return  getRecord  (  )    ;      }  public  void  remove  (  )  {  throw  new  UnsupportedOperationException  (  )  ;  }  }  ;  }    [METHOD]  iterator  [TYPE]  Iterator  [PARAMETER]  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  boolean  false  true  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  next  rec  result  [TYPE]  IOException  e  [TYPE]  Map  hdrMap  headerMapping  
[REPLACE]  return  getRecord  (  )  ;	[BUGGY]  return  lexer  .  getLineNumber  (  )  ;  [CE]  incompatible  types  [CONTEXT]  public  Iterator<CSVRecord>  iterator  (  )  {  return  new  Iterator<CSVRecord>  (  )  {  private  CSVRecord  current  ;    public  boolean  hasNext  (  )  {  if  (  current  =  =  null  )  {  current  =  getNextRecord  (  )  ;  }  return  current  !  =  null  ;  }  public  CSVRecord  next  (  )  {  CSVRecord  next  =  current  ;  current  =  null  ;    if  (  next  =  =  null  )  {    next  =  getNextRecord  (  )  ;  if  (  next  =  =  null  )  {  throw  new  NoSuchElementException  (   "No  more  CSV  records  available "  )  ;  }  }  return  next  ;  }  private  CSVRecord  getNextRecord  (  )  {  try  {  [ATTENTION]  return  lexer  .  getLineNumber  (  )    ;  }  catch  (  IOException  e  )  {  throw  new  RuntimeException  (  e  )  ;  }  }  public  void  remove  (  )  {  throw  new  UnsupportedOperationException  (  )  ;  }  }  ;  }    [METHOD]  iterator  [TYPE]  Iterator  [PARAMETER]  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  boolean  false  true  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  next  rec  result  [TYPE]  IOException  e  [TYPE]  Map  hdrMap  headerMapping  
[REPLACE]  current  =  null;	[BUGGY]  current  =  false  ;  [CE]  incompatible  types  [CONTEXT]  public  Iterator<CSVRecord>  iterator  (  )  {  return  new  Iterator<CSVRecord>  (  )  {  private  CSVRecord  current  ;    public  boolean  hasNext  (  )  {  if  (  current  =  =  null  )  {  current  =  getNextRecord  (  )  ;  }  return  current  !  =  null  ;  }  public  CSVRecord  next  (  )  {  CSVRecord  next  =  current  ;  [ATTENTION]  current  =  false  ;    if  (  next  =  =  null  )  {    next  =  getNextRecord  (  )  ;  if  (  next  =  =  null  )  {  throw  new  NoSuchElementException  (   "No  more  CSV  records  available "  )  ;  }  }  return  next  ;  }  private  CSVRecord  getNextRecord  (  )  {  try  {  return  getRecord  (  )  ;  }  catch  (  IOException  e  )  {  throw  new  RuntimeException  (  e  )  ;  }  }  public  void  remove  (  )  {  throw  new  UnsupportedOperationException  (  )  ;  }  }  ;  }    [METHOD]  iterator  [TYPE]  Iterator  [PARAMETER]  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  boolean  false  true  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  next  rec  result  [TYPE]  IOException  e  [TYPE]  Map  hdrMap  headerMapping  
[ADD]  next  =  getNextRecord  (  )  ;	[BUGGY]  [FE]  (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo\n "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "foo\n  baar  ,  ,  ,   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "\n\t  \n "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  public  Iterator<CSVRecord>  iterator  (  )  {  return  new  Iterator<CSVRecord>  (  )  {  private  CSVRecord  current  ;    public  boolean  hasNext  (  )  {  if  (  current  =  =  null  )  {  current  =  getNextRecord  (  )  ;  }  return  current  !  =  null  ;  }  public  CSVRecord  next  (  )  {  CSVRecord  next  =  current  ;  current  =  null  ;    if  (  next  =  =  null  )  {    [ATTENTION]  if  (  next  =  =  null  )  {  throw  new  NoSuchElementException  (   "No  more  CSV  records  available "  )  ;  }  }  return  next  ;  }  private  CSVRecord  getNextRecord  (  )  {  try  {  return  getRecord  (  )  ;  }  catch  (  IOException  e  )  {  throw  new  RuntimeException  (  e  )  ;  }  }  public  void  remove  (  )  {  throw  new  UnsupportedOperationException  (  )  ;  }  }  ;  }    [METHOD]  iterator  [TYPE]  Iterator  [PARAMETER]  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  boolean  false  true  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  next  rec  result  [TYPE]  IOException  e  [TYPE]  Map  hdrMap  headerMapping  
[REPLACE]  return  new  Iterator<CSVRecord>  (  )  {	[BUGGY]  return  false  ;  [CE]  illegal  start  of  expression  [CONTEXT]  public  Iterator<CSVRecord>  iterator  (  )  {  [ATTENTION]  return  false  ;  private  CSVRecord  current  ;    public  boolean  hasNext  (  )  {  if  (  current  =  =  null  )  {  current  =  getNextRecord  (  )  ;  }  return  current  !  =  null  ;  }  public  CSVRecord  next  (  )  {  CSVRecord  next  =  current  ;  current  =  null  ;    if  (  next  =  =  null  )  {    next  =  getNextRecord  (  )  ;  if  (  next  =  =  null  )  {  throw  new  NoSuchElementException  (   "No  more  CSV  records  available "  )  ;  }  }  return  next  ;  }  private  CSVRecord  getNextRecord  (  )  {  try  {  return  getRecord  (  )  ;  }  catch  (  IOException  e  )  {  throw  new  RuntimeException  (  e  )  ;  }  }  public  void  remove  (  )  {  throw  new  UnsupportedOperationException  (  )  ;  }  }  ;  }    [METHOD]  iterator  [TYPE]  Iterator  [PARAMETER]  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  boolean  false  true  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  next  rec  result  [TYPE]  IOException  e  [TYPE]  Map  hdrMap  headerMapping  
[REPLACE]  return  current  !=  null;	[BUGGY]  return  false  ;  [FE]  (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo\n "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "foo\n  baar  ,  ,  ,   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "\n\t  \n "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  public  Iterator<CSVRecord>  iterator  (  )  {  return  new  Iterator<CSVRecord>  (  )  {  private  CSVRecord  current  ;    public  boolean  hasNext  (  )  {  if  (  current  =  =  null  )  {  current  =  getNextRecord  (  )  ;  }  [ATTENTION]  return  false  ;  }  public  CSVRecord  next  (  )  {  CSVRecord  next  =  current  ;  current  =  null  ;    if  (  next  =  =  null  )  {    next  =  getNextRecord  (  )  ;  if  (  next  =  =  null  )  {  throw  new  NoSuchElementException  (   "No  more  CSV  records  available "  )  ;  }  }  return  next  ;  }  private  CSVRecord  getNextRecord  (  )  {  try  {  return  getRecord  (  )  ;  }  catch  (  IOException  e  )  {  throw  new  RuntimeException  (  e  )  ;  }  }  public  void  remove  (  )  {  throw  new  UnsupportedOperationException  (  )  ;  }  }  ;  }    [METHOD]  iterator  [TYPE]  Iterator  [PARAMETER]  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  boolean  false  true  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  next  rec  result  [TYPE]  IOException  e  [TYPE]  Map  hdrMap  headerMapping  
[REPLACE]  return  next;	[BUGGY]  return  result  ;  [CE]  cannot  find  symbol  result  [CONTEXT]  public  Iterator<CSVRecord>  iterator  (  )  {  return  new  Iterator<CSVRecord>  (  )  {  private  CSVRecord  current  ;    public  boolean  hasNext  (  )  {  if  (  current  =  =  null  )  {  current  =  getNextRecord  (  )  ;  }  return  current  !  =  null  ;  }  public  CSVRecord  next  (  )  {  CSVRecord  next  =  current  ;  current  =  null  ;    if  (  next  =  =  null  )  {    next  =  getNextRecord  (  )  ;  if  (  next  =  =  null  )  {  throw  new  NoSuchElementException  (   "No  more  CSV  records  available "  )  ;  }  }  [ATTENTION]  return  result  ;  }  private  CSVRecord  getNextRecord  (  )  {  try  {  return  getRecord  (  )  ;  }  catch  (  IOException  e  )  {  throw  new  RuntimeException  (  e  )  ;  }  }  public  void  remove  (  )  {  throw  new  UnsupportedOperationException  (  )  ;  }  }  ;  }    [METHOD]  iterator  [TYPE]  Iterator  [PARAMETER]  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  boolean  false  true  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  next  rec  result  [TYPE]  IOException  e  [TYPE]  Map  hdrMap  headerMapping  
[REPLACE]  CSVRecord  next  =  current;	[BUGGY]  CSVRecord  result  =  new  CSVRecord  (  null  ,  headerMapping  )  ;  [CE]  cannot  find  symbol  next  [CONTEXT]  public  Iterator<CSVRecord>  iterator  (  )  {  return  new  Iterator<CSVRecord>  (  )  {  private  CSVRecord  current  ;    public  boolean  hasNext  (  )  {  if  (  current  =  =  null  )  {  current  =  getNextRecord  (  )  ;  }  return  current  !  =  null  ;  }  public  CSVRecord  next  (  )  {  [ATTENTION]  CSVRecord  result  =  new  CSVRecord  (  null  ,  headerMapping  )    ;  current  =  null  ;    if  (  next  =  =  null  )  {    next  =  getNextRecord  (  )  ;  if  (  next  =  =  null  )  {  throw  new  NoSuchElementException  (   "No  more  CSV  records  available "  )  ;  }  }  return  next  ;  }  private  CSVRecord  getNextRecord  (  )  {  try  {  return  getRecord  (  )  ;  }  catch  (  IOException  e  )  {  throw  new  RuntimeException  (  e  )  ;  }  }  public  void  remove  (  )  {  throw  new  UnsupportedOperationException  (  )  ;  }  }  ;  }    [METHOD]  iterator  [TYPE]  Iterator  [PARAMETER]  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  boolean  false  true  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  next  rec  result  [TYPE]  IOException  e  [TYPE]  Map  hdrMap  headerMapping  
[ADD]  CSVRecord  next  =  current;	[BUGGY]  [CE]  cannot  find  symbol  next  [CONTEXT]  public  Iterator<CSVRecord>  iterator  (  )  {  return  new  Iterator<CSVRecord>  (  )  {  private  CSVRecord  current  ;    public  boolean  hasNext  (  )  {  if  (  current  =  =  null  )  {  current  =  getNextRecord  (  )  ;  }  return  current  !  =  null  ;  }  public  CSVRecord  next  (  )  {  [ATTENTION]  current  =  null  ;    if  (  next  =  =  null  )  {    next  =  getNextRecord  (  )  ;  if  (  next  =  =  null  )  {  throw  new  NoSuchElementException  (   "No  more  CSV  records  available "  )  ;  }  }  return  next  ;  }  private  CSVRecord  getNextRecord  (  )  {  try  {  return  getRecord  (  )  ;  }  catch  (  IOException  e  )  {  throw  new  RuntimeException  (  e  )  ;  }  }  public  void  remove  (  )  {  throw  new  UnsupportedOperationException  (  )  ;  }  }  ;  }    [METHOD]  iterator  [TYPE]  Iterator  [PARAMETER]  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  boolean  false  true  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  next  rec  result  [TYPE]  IOException  e  [TYPE]  Map  hdrMap  headerMapping  
[REPLACE]  throw  new  RuntimeException  ( "   ")  ;	[BUGGY]  throw  new  UnsupportedOperationException  ( "   ")    ;    ;  [CE]  unreachable  statement  [CONTEXT]  public  Iterator<CSVRecord>  iterator  (  )  {  return  new  Iterator<CSVRecord>  (  )  {  private  CSVRecord  current  ;    public  boolean  hasNext  (  )  {  if  (  current  =  =  null  )  {  current  =  getNextRecord  (  )  ;  }  return  current  !  =  null  ;  }  public  CSVRecord  next  (  )  {  CSVRecord  next  =  current  ;  current  =  null  ;    if  (  next  =  =  null  )  {    next  =  getNextRecord  (  )  ;  if  (  next  =  =  null  )  {  throw  new  NoSuchElementException  (   "No  more  CSV  records  available "  )  ;  }  }  return  next  ;  }  private  CSVRecord  getNextRecord  (  )  {  try  {  return  getRecord  (  )  ;  }  catch  (  IOException  e  )  {  [ATTENTION]  throw  new  UnsupportedOperationException  (   "   "  )  ;    ;  }  }  public  void  remove  (  )  {  throw  new  UnsupportedOperationException  (  )  ;  }  }  ;  }    [METHOD]  iterator  [TYPE]  Iterator  [PARAMETER]  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  boolean  false  true  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  next  rec  result  [TYPE]  IOException  e  [TYPE]  Map  hdrMap  headerMapping  
[REPLACE]  throw  new  UnsupportedOperationException  ( "   ")  ;	[BUGGY]  return  ;  [FE]  (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo\n "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "foo\n  baar  ,  ,  ,   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "\n\t  \n "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  public  Iterator<CSVRecord>  iterator  (  )  {  return  new  Iterator<CSVRecord>  (  )  {  private  CSVRecord  current  ;    public  boolean  hasNext  (  )  {  if  (  current  =  =  null  )  {  current  =  getNextRecord  (  )  ;  }  return  current  !  =  null  ;  }  public  CSVRecord  next  (  )  {  CSVRecord  next  =  current  ;  current  =  null  ;    if  (  next  =  =  null  )  {    next  =  getNextRecord  (  )  ;  if  (  next  =  =  null  )  {  throw  new  NoSuchElementException  (   "No  more  CSV  records  available "  )  ;  }  }  return  next  ;  }  private  CSVRecord  getNextRecord  (  )  {  try  {  return  getRecord  (  )  ;  }  catch  (  IOException  e  )  {  throw  new  RuntimeException  (  e  )  ;  }  }  public  void  remove  (  )  {  [ATTENTION]  return  ;  }  }  ;  }    [METHOD]  iterator  [TYPE]  Iterator  [PARAMETER]  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  boolean  false  true  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  next  rec  result  [TYPE]  IOException  e  [TYPE]  Map  hdrMap  headerMapping  
[REPLACE]  if  (  current  ==  null  )  {	[BUGGY]  if  (result  !  =  null  )  {[CE]  cannot  find  symbol  result  [CONTEXT]  public  boolean  hasNext  (  )  {  [ATTENTION]  if  (  result  !  =  null  )  {  current  =  getNextRecord  (  )  ;  }  return  current  !  =  null  ;  }    [METHOD]  hasNext  [TYPE]  boolean  [PARAMETER]  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  next  rec  result  [TYPE]  boolean  false  true  [TYPE]  Map  hdrMap  headerMapping  
[REPLACE]  current  =  getNextRecord  (  )  ;	[BUGGY]  next  =  getNextRecord  (  )  ;    ;  [CE]  cannot  find  symbol  next  [CONTEXT]  public  boolean  hasNext  (  )  {  if  (  current  =  =  null  )  {  [ATTENTION]  next  =  getNextRecord  (  )    ;    ;  }  return  current  !  =  null  ;  }    [METHOD]  hasNext  [TYPE]  boolean  [PARAMETER]  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  next  rec  result  [TYPE]  boolean  false  true  [TYPE]  Map  hdrMap  headerMapping  
[ADD]  current  =  getNextRecord  (  )  ;	[BUGGY]  [FE]  (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo\n "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "foo\n  baar  ,  ,  ,   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "\n\t  \n "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  public  boolean  hasNext  (  )  {  if  (  current  =  =  null  )  {  [ATTENTION]  }  return  current  !  =  null  ;  }    [METHOD]  hasNext  [TYPE]  boolean  [PARAMETER]  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  next  rec  result  [TYPE]  boolean  false  true  [TYPE]  Map  hdrMap  headerMapping  
[REPLACE]  return  current  !=  null;	[BUGGY]  returnresult  ;  [CE]  not  a  statement  [CONTEXT]  public  boolean  hasNext  (  )  {  if  (  current  =  =  null  )  {  current  =  getNextRecord  (  )  ;  }  [ATTENTION]  returnresult  ;  }    [METHOD]  hasNext  [TYPE]  boolean  [PARAMETER]  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  next  rec  result  [TYPE]  boolean  false  true  [TYPE]  Map  hdrMap  headerMapping  
[REPLACE]  CSVRecord  next  =  current;	[BUGGY]  CSVRecord  result  =  new  CSVRecord  (  null  ,  headerMapping  )  ;  [CE]  cannot  find  symbol  next  [CONTEXT]  public  CSVRecord  next  (  )  {  [ATTENTION]  CSVRecord  result  =  new  CSVRecord  (  null  ,  headerMapping  )    ;  current  =  null  ;    if  (  next  =  =  null  )  {    next  =  getNextRecord  (  )  ;  if  (  next  =  =  null  )  {  throw  new  NoSuchElementException  (   "No  more  CSV  records  available "  )  ;  }  }  return  next  ;  }    [METHOD]  next  [TYPE]  CSVRecord  [PARAMETER]  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  next  rec  result  [TYPE]  boolean  false  true  [TYPE]  Map  hdrMap  headerMapping  
[REPLACE]  current  =  null;	[BUGGY]  current  =  false  ;  [CE]  incompatible  types  [CONTEXT]  public  CSVRecord  next  (  )  {  CSVRecord  next  =  current  ;  [ATTENTION]  current  =  false  ;    if  (  next  =  =  null  )  {    next  =  getNextRecord  (  )  ;  if  (  next  =  =  null  )  {  throw  new  NoSuchElementException  (   "No  more  CSV  records  available "  )  ;  }  }  return  next  ;  }    [METHOD]  next  [TYPE]  CSVRecord  [PARAMETER]  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  next  rec  result  [TYPE]  boolean  false  true  [TYPE]  Map  hdrMap  headerMapping  
[ADD]  current  =  null;	[BUGGY]  [FE]  (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo\n "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "foo\n  baar  ,  ,  ,   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "\n\t  \n "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  public  CSVRecord  next  (  )  {  CSVRecord  next  =  current  ;  [ATTENTION]    if  (  next  =  =  null  )  {    next  =  getNextRecord  (  )  ;  if  (  next  =  =  null  )  {  throw  new  NoSuchElementException  (   "No  more  CSV  records  available "  )  ;  }  }  return  next  ;  }    [METHOD]  next  [TYPE]  CSVRecord  [PARAMETER]  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  next  rec  result  [TYPE]  boolean  false  true  [TYPE]  Map  hdrMap  headerMapping  
[REPLACE]  if  (  next  ==  null  )  {	[BUGGY]  if  (  next  !  =  result  )  {[CE]  cannot  find  symbol  result  [CONTEXT]  public  CSVRecord  next  (  )  {  CSVRecord  next  =  current  ;  current  =  null  ;    [ATTENTION]  if  (  next  !  =  result  )  {    next  =  getNextRecord  (  )  ;  if  (  next  =  =  null  )  {  throw  new  NoSuchElementException  (   "No  more  CSV  records  available "  )  ;  }  }  return  next  ;  }    [METHOD]  next  [TYPE]  CSVRecord  [PARAMETER]  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  next  rec  result  [TYPE]  boolean  false  true  [TYPE]  Map  hdrMap  headerMapping  
[REPLACE]  if  (  next  ==  null  )  {	[BUGGY]  if  (  next  !  =  true  )  {[CE]  incomparable  types:  CSVRecord  and  boolean  [CONTEXT]  public  CSVRecord  next  (  )  {  CSVRecord  next  =  current  ;  current  =  null  ;    if  (  next  =  =  null  )  {    next  =  getNextRecord  (  )  ;  [ATTENTION]  if  (  next  !  =  true  )  {  throw  new  NoSuchElementException  (   "No  more  CSV  records  available "  )  ;  }  }  return  next  ;  }    [METHOD]  next  [TYPE]  CSVRecord  [PARAMETER]  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  next  rec  result  [TYPE]  boolean  false  true  [TYPE]  Map  hdrMap  headerMapping  
[REPLACE]  throw  new  NoSuchElementException  ( "   ")  ;	[BUGGY]  return  ;  [CE]  missing  return  value  [CONTEXT]  public  CSVRecord  next  (  )  {  CSVRecord  next  =  current  ;  current  =  null  ;    if  (  next  =  =  null  )  {    next  =  getNextRecord  (  )  ;  if  (  next  =  =  null  )  {  [ATTENTION]  return  ;  }  }  return  next  ;  }    [METHOD]  next  [TYPE]  CSVRecord  [PARAMETER]  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  next  rec  result  [TYPE]  boolean  false  true  [TYPE]  Map  hdrMap  headerMapping  
[REPLACE]  next  =  getNextRecord  (  )  ;	[BUGGY]  current  =  getNextRecord  (  )  ;    ;  [FE]  (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo\n "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "foo\n  baar  ,  ,  ,   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "\n\t  \n "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  public  CSVRecord  next  (  )  {  CSVRecord  next  =  current  ;  current  =  null  ;    if  (  next  =  =  null  )  {    [ATTENTION]  current  =  getNextRecord  (  )    ;    ;  if  (  next  =  =  null  )  {  throw  new  NoSuchElementException  (   "No  more  CSV  records  available "  )  ;  }  }  return  next  ;  }    [METHOD]  next  [TYPE]  CSVRecord  [PARAMETER]  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  next  rec  result  [TYPE]  boolean  false  true  [TYPE]  Map  hdrMap  headerMapping  
[ADD]  next  =  getNextRecord  (  )  ;	[BUGGY]  [FE]  (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo\n "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "foo\n  baar  ,  ,  ,   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "\n\t  \n "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  public  CSVRecord  next  (  )  {  CSVRecord  next  =  current  ;  current  =  null  ;    if  (  next  =  =  null  )  {    [ATTENTION]  if  (  next  =  =  null  )  {  throw  new  NoSuchElementException  (   "No  more  CSV  records  available "  )  ;  }  }  return  next  ;  }    [METHOD]  next  [TYPE]  CSVRecord  [PARAMETER]  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  next  rec  result  [TYPE]  boolean  false  true  [TYPE]  Map  hdrMap  headerMapping  
[REPLACE]  throw  new  NoSuchElementException  ( "   ")  ;	[BUGGY]  throw  new  UnsupportedOperationException  ( "   ")    ;    ;  [CE]  unreachable  statement  [CONTEXT]  public  CSVRecord  next  (  )  {  CSVRecord  next  =  current  ;  current  =  null  ;    if  (  next  =  =  null  )  {    next  =  getNextRecord  (  )  ;  if  (  next  =  =  null  )  {  [ATTENTION]  throw  new  UnsupportedOperationException  (   "   "  )  ;    ;  }  }  return  next  ;  }    [METHOD]  next  [TYPE]  CSVRecord  [PARAMETER]  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  next  rec  result  [TYPE]  boolean  false  true  [TYPE]  Map  hdrMap  headerMapping  
[REPLACE]  if  (  next  ==  null  )  {	[BUGGY]  if  (  next  !  =  null  )  {[FE]  (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo\n "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "foo\n  baar  ,  ,  ,   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "\n\t  \n "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  public  CSVRecord  next  (  )  {  CSVRecord  next  =  current  ;  current  =  null  ;    if  (  next  =  =  null  )  {    next  =  getNextRecord  (  )  ;  [ATTENTION]  if  (  next  !  =  null  )  {  throw  new  NoSuchElementException  (   "No  more  CSV  records  available "  )  ;  }  }  return  next  ;  }    [METHOD]  next  [TYPE]  CSVRecord  [PARAMETER]  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  next  rec  result  [TYPE]  boolean  false  true  [TYPE]  Map  hdrMap  headerMapping  
[ADD]  if  (  next  ==  null  )  {  throw  new  NoSuchElementException  ( "   ")  ;  }	[BUGGY]  [FE]  (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo\n "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "foo\n  baar  ,  ,  ,   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "\n\t  \n "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  public  CSVRecord  next  (  )  {  CSVRecord  next  =  current  ;  current  =  null  ;    if  (  next  =  =  null  )  {    next  =  getNextRecord  (  )  ;  [ATTENTION]    }  return  next  ;  }    [METHOD]  next  [TYPE]  CSVRecord  [PARAMETER]  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  next  rec  result  [TYPE]  boolean  false  true  [TYPE]  Map  hdrMap  headerMapping  
[ADD]  throw  new  NoSuchElementException  ( "   ")  ;	[BUGGY]  [FE]  (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo\n "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "foo\n  baar  ,  ,  ,   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "\n\t  \n "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  public  CSVRecord  next  (  )  {  CSVRecord  next  =  current  ;  current  =  null  ;    if  (  next  =  =  null  )  {    next  =  getNextRecord  (  )  ;  if  (  next  =  =  null  )  {  [ATTENTION]  }  }  return  next  ;  }    [METHOD]  next  [TYPE]  CSVRecord  [PARAMETER]  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  next  rec  result  [TYPE]  boolean  false  true  [TYPE]  Map  hdrMap  headerMapping  
[REPLACE]  return  next;	[BUGGY]  return  result  ;  [CE]  cannot  find  symbol  result  [CONTEXT]  public  CSVRecord  next  (  )  {  CSVRecord  next  =  current  ;  current  =  null  ;    if  (  next  =  =  null  )  {    next  =  getNextRecord  (  )  ;  if  (  next  =  =  null  )  {  throw  new  NoSuchElementException  (   "No  more  CSV  records  available "  )  ;  }  }  [ATTENTION]  return  result  ;  }    [METHOD]  next  [TYPE]  CSVRecord  [PARAMETER]  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  next  rec  result  [TYPE]  boolean  false  true  [TYPE]  Map  hdrMap  headerMapping  
[ADD]  try  {  return  getRecord  (  )  ;  }  catch  (  IOException  e  )  {  throw  new  RuntimeException  ( "   ")  ;  }	[BUGGY]  return  getRecord  (  )  ;  [CE]  unreported  exception  IOException  ;  must  be  caught  or  declared  to  be  thrown  [CONTEXT]  private  CSVRecord  getNextRecord  (  )  {  [ATTENTION]  return  getRecord  (  )    ;      }    [METHOD]  getNextRecord  [TYPE]  CSVRecord  [PARAMETER]  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  boolean  false  true  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  next  rec  result  [TYPE]  IOException  e  [TYPE]  Map  hdrMap  headerMapping  
[REPLACE]  return  getRecord  (  )  ;	[BUGGY]  return  lexer  .  getLineNumber  (  )  ;  [CE]  incompatible  types  [CONTEXT]  private  CSVRecord  getNextRecord  (  )  {  try  {  [ATTENTION]  return  lexer  .  getLineNumber  (  )    ;  }  catch  (  IOException  e  )  {  throw  new  RuntimeException  (  e  )  ;  }  }    [METHOD]  getNextRecord  [TYPE]  CSVRecord  [PARAMETER]  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  boolean  false  true  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  next  rec  result  [TYPE]  IOException  e  [TYPE]  Map  hdrMap  headerMapping  
[REPLACE]  throw  new  RuntimeException  ( "   ")  ;	[BUGGY]  return  ;  [CE]  missing  return  value  [CONTEXT]  private  CSVRecord  getNextRecord  (  )  {  try  {  return  getRecord  (  )  ;  }  catch  (  IOException  e  )  {  [ATTENTION]  return  ;  }  }    [METHOD]  getNextRecord  [TYPE]  CSVRecord  [PARAMETER]  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  boolean  false  true  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  next  rec  result  [TYPE]  IOException  e  [TYPE]  Map  hdrMap  headerMapping  
[REPLACE]  throw  new  UnsupportedOperationException  ( "   ")  ;	[BUGGY]  throw  new  RuntimeException  ( "   ")    ;    ;  [CE]  unreachable  statement  [CONTEXT]  public  void  remove  (  )  {  [ATTENTION]  throw  new  RuntimeException  (   "   "  )  ;    ;  }    [METHOD]  remove  [TYPE]  void  [PARAMETER]  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  next  rec  result  [TYPE]  boolean  false  true  [TYPE]  Map  hdrMap  headerMapping  
[REPLACE]  return  lexer  .  getLineNumber  (  )  ;	[BUGGY]  return  hdrMap  ;  [CE]  cannot  find  symbol  hdrMap  [CONTEXT]  public  int  getLineNumber  (  )  {  [ATTENTION]  return  hdrMap  ;  }    [METHOD]  getLineNumber  [TYPE]  int  [PARAMETER]  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  next  rec  result  [TYPE]  boolean  false  true  [TYPE]  Map  hdrMap  headerMapping  
[REPLACE]  if  (  current  ==  null  )  {	[BUGGY]  if  (  current  !  =  null  )  {[FE]  (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo\n "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "foo\n  baar  ,  ,  ,   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "\n\t  \n "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  public  boolean  hasNext  (  )  {  [ATTENTION]  if  (  current  !  =  null  )  {  current  =  getNextRecord  (  )  ;  }  return  current  !  =  null  ;  }    [METHOD]  hasNext  [TYPE]  boolean  [PARAMETER]  [CLASS]  1    [TYPE]  CSVRecord  current  [TYPE]  boolean  false  true  
[REPLACE]  current  =  getNextRecord  (  )  ;	[BUGGY]  next  =  getNextRecord  (  )  ;    ;  [CE]  cannot  find  symbol  next  [CONTEXT]  public  boolean  hasNext  (  )  {  if  (  current  =  =  null  )  {  [ATTENTION]  next  =  getNextRecord  (  )    ;    ;  }  return  current  !  =  null  ;  }    [METHOD]  hasNext  [TYPE]  boolean  [PARAMETER]  [CLASS]  1    [TYPE]  CSVRecord  current  [TYPE]  boolean  false  true  
[REPLACE]  return  current  !=  null;	[BUGGY]  return  current  ;  [CE]  incompatible  types  [CONTEXT]  public  boolean  hasNext  (  )  {  if  (  current  =  =  null  )  {  current  =  getNextRecord  (  )  ;  }  [ATTENTION]  return  current  ;  }    [METHOD]  hasNext  [TYPE]  boolean  [PARAMETER]  [CLASS]  1    [TYPE]  CSVRecord  current  [TYPE]  boolean  false  true  
[REPLACE]  current  =  null;	[BUGGY]  current  =  this  ;  [CE]  incompatible  types  [CONTEXT]  public  CSVRecord  next  (  )  {  CSVRecord  next  =  current  ;  [ATTENTION]  current  =  this  ;    if  (  next  =  =  null  )  {    next  =  getNextRecord  (  )  ;  if  (  next  =  =  null  )  {  throw  new  NoSuchElementException  (   "No  more  CSV  records  available "  )  ;  }  }  return  next  ;  }    [METHOD]  next  [TYPE]  CSVRecord  [PARAMETER]  [CLASS]  1    [TYPE]  CSVRecord  current  next  [TYPE]  boolean  false  true  
[REPLACE]  if  (  next  ==  null  )  {	[BUGGY]  if  (  next  !  =  null  )  {[FE]  (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo\n "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "foo\n  baar  ,  ,  ,   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "\n\t  \n "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  public  CSVRecord  next  (  )  {  CSVRecord  next  =  current  ;  current  =  null  ;    [ATTENTION]  if  (  next  !  =  null  )  {    next  =  getNextRecord  (  )  ;  if  (  next  =  =  null  )  {  throw  new  NoSuchElementException  (   "No  more  CSV  records  available "  )  ;  }  }  return  next  ;  }    [METHOD]  next  [TYPE]  CSVRecord  [PARAMETER]  [CLASS]  1    [TYPE]  CSVRecord  current  next  [TYPE]  boolean  false  true  
[REPLACE]  if  (  next  ==  null  )  {	[BUGGY]  if  (current  !  =  null  )  {[FE]  (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo\n "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "foo\n  baar  ,  ,  ,   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "\n\t  \n "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  public  CSVRecord  next  (  )  {  CSVRecord  next  =  current  ;  current  =  null  ;    if  (  next  =  =  null  )  {    next  =  getNextRecord  (  )  ;  [ATTENTION]  if  (  current  !  =  null  )  {  throw  new  NoSuchElementException  (   "No  more  CSV  records  available "  )  ;  }  }  return  next  ;  }    [METHOD]  next  [TYPE]  CSVRecord  [PARAMETER]  [CLASS]  1    [TYPE]  CSVRecord  current  next  [TYPE]  boolean  false  true  
[REPLACE]  throw  new  NoSuchElementException  ( "   ")  ;	[BUGGY]  throw  new  UnsupportedOperationException  ( "   ")    ;    ;  [CE]  unreachable  statement  [CONTEXT]  public  CSVRecord  next  (  )  {  CSVRecord  next  =  current  ;  current  =  null  ;    if  (  next  =  =  null  )  {    next  =  getNextRecord  (  )  ;  if  (  next  =  =  null  )  {  [ATTENTION]  throw  new  UnsupportedOperationException  (   "   "  )  ;    ;  }  }  return  next  ;  }    [METHOD]  next  [TYPE]  CSVRecord  [PARAMETER]  [CLASS]  1    [TYPE]  CSVRecord  current  next  [TYPE]  boolean  false  true  
[REPLACE]  next  =  getNextRecord  (  )  ;	[BUGGY]  current  =  getNextRecord  (  )  ;    ;  [FE]  (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo\n "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "foo\n  baar  ,  ,  ,   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "\n\t  \n "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  public  CSVRecord  next  (  )  {  CSVRecord  next  =  current  ;  current  =  null  ;    if  (  next  =  =  null  )  {    [ATTENTION]  current  =  getNextRecord  (  )    ;    ;  if  (  next  =  =  null  )  {  throw  new  NoSuchElementException  (   "No  more  CSV  records  available "  )  ;  }  }  return  next  ;  }    [METHOD]  next  [TYPE]  CSVRecord  [PARAMETER]  [CLASS]  1    [TYPE]  CSVRecord  current  next  [TYPE]  boolean  false  true  
[REPLACE]  if  (  next  ==  null  )  {	[BUGGY]  if  (  current  !  =  null  )  {[FE]  (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo\n "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "foo\n  baar  ,  ,  ,   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "\n\t  \n "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  public  CSVRecord  next  (  )  {  CSVRecord  next  =  current  ;  current  =  null  ;    if  (  next  =  =  null  )  {    next  =  getNextRecord  (  )  ;  [ATTENTION]  if  (  current  !  =  null  )  {  throw  new  NoSuchElementException  (   "No  more  CSV  records  available "  )  ;  }  }  return  next  ;  }    [METHOD]  next  [TYPE]  CSVRecord  [PARAMETER]  [CLASS]  1    [TYPE]  CSVRecord  current  next  [TYPE]  boolean  false  true  
[ADD]  if  (  next  ==  null  )  {  throw  new  NoSuchElementException  ( "   ")  ;  }	[BUGGY]  [FE]  (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo\n "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "foo\n  baar  ,  ,  ,   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "\n\t  \n "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  public  CSVRecord  next  (  )  {  CSVRecord  next  =  current  ;  current  =  null  ;    if  (  next  =  =  null  )  {    next  =  getNextRecord  (  )  ;  [ATTENTION]    }  return  next  ;  }    [METHOD]  next  [TYPE]  CSVRecord  [PARAMETER]  [CLASS]  1    [TYPE]  CSVRecord  current  next  [TYPE]  boolean  false  true  
[ADD]  throw  new  NoSuchElementException  ( "   ")  ;	[BUGGY]  [FE]  (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo\n "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "foo\n  baar  ,  ,  ,   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "\n\t  \n "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  public  CSVRecord  next  (  )  {  CSVRecord  next  =  current  ;  current  =  null  ;    if  (  next  =  =  null  )  {    next  =  getNextRecord  (  )  ;  if  (  next  =  =  null  )  {  [ATTENTION]  }  }  return  next  ;  }    [METHOD]  next  [TYPE]  CSVRecord  [PARAMETER]  [CLASS]  1    [TYPE]  CSVRecord  current  next  [TYPE]  boolean  false  true  
[REPLACE]  throw  new  NoSuchElementException  ( "   ")  ;	[BUGGY]  return  ;  [CE]  missing  return  value  [CONTEXT]  public  CSVRecord  next  (  )  {  CSVRecord  next  =  current  ;  current  =  null  ;    if  (  next  =  =  null  )  {    next  =  getNextRecord  (  )  ;  if  (  next  =  =  null  )  {  [ATTENTION]  return  ;  }  }  return  next  ;  }    [METHOD]  next  [TYPE]  CSVRecord  [PARAMETER]  [CLASS]  1    [TYPE]  CSVRecord  current  next  [TYPE]  boolean  false  true  
[REPLACE]  return  next;	[BUGGY]  return  current  ;  [FE]  (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo\n "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "foo\n  baar  ,  ,  ,   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "\n\t  \n "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  public  CSVRecord  next  (  )  {  CSVRecord  next  =  current  ;  current  =  null  ;    if  (  next  =  =  null  )  {    next  =  getNextRecord  (  )  ;  if  (  next  =  =  null  )  {  throw  new  NoSuchElementException  (   "No  more  CSV  records  available "  )  ;  }  }  [ATTENTION]  return  current  ;  }    [METHOD]  next  [TYPE]  CSVRecord  [PARAMETER]  [CLASS]  1    [TYPE]  CSVRecord  current  next  [TYPE]  boolean  false  true  
[ADD]  try  {  return  getRecord  (  )  ;  }  catch  (  IOException  e  )  {  throw  new  RuntimeException  ( "   ")  ;  }	[BUGGY]  return  getRecord  (  )  ;  [CE]  unreported  exception  IOException  ;  must  be  caught  or  declared  to  be  thrown  [CONTEXT]  private  CSVRecord  getNextRecord  (  )  {  [ATTENTION]  return  getRecord  (  )    ;      }    [METHOD]  getNextRecord  [TYPE]  CSVRecord  [PARAMETER]  [CLASS]  1    [TYPE]  CSVRecord  current  next  [TYPE]  IOException  e  [TYPE]  boolean  false  true  
[REPLACE]  return  getRecord  (  )  ;	[BUGGY]  return  next  ;  [CE]  cannot  find  symbol  next  [CONTEXT]  private  CSVRecord  getNextRecord  (  )  {  try  {  [ATTENTION]  return  next  ;  }  catch  (  IOException  e  )  {  throw  new  RuntimeException  (  e  )  ;  }  }    [METHOD]  getNextRecord  [TYPE]  CSVRecord  [PARAMETER]  [CLASS]  1    [TYPE]  CSVRecord  current  next  [TYPE]  IOException  e  [TYPE]  boolean  false  true  
[REPLACE]  throw  new  RuntimeException  ( "   ")  ;	[BUGGY]  throw  new  UnsupportedOperationException  ( "   ")    ;    ;  [CE]  unreachable  statement  [CONTEXT]  private  CSVRecord  getNextRecord  (  )  {  try  {  return  getRecord  (  )  ;  }  catch  (  IOException  e  )  {  [ATTENTION]  throw  new  UnsupportedOperationException  (   "   "  )  ;    ;  }  }    [METHOD]  getNextRecord  [TYPE]  CSVRecord  [PARAMETER]  [CLASS]  1    [TYPE]  CSVRecord  current  next  [TYPE]  IOException  e  [TYPE]  boolean  false  true  
[REPLACE]  throw  new  UnsupportedOperationException  ( "   ")  ;	[BUGGY]  throw  new  RuntimeException  ( "   ")    ;    ;  [CE]  unreachable  statement  [CONTEXT]  public  void  remove  (  )  {  [ATTENTION]  throw  new  RuntimeException  (   "   "  )  ;    ;  }    [METHOD]  remove  [TYPE]  void  [PARAMETER]  [CLASS]  1    [TYPE]  CSVRecord  current  next  [TYPE]  boolean  false  true  
[REPLACE]  private  final  CSVFormat  format;	[BUGGY]  private  CSVFormat  format  ;  [FE]  (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo\n "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "foo\n  baar  ,  ,  ,   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "\n\t  \n "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]      [CLASS]  CSVPrinter  
[REPLACE]  private  boolean  newLine  =  true;	[BUGGY]  private  boolean  newLine  =  false  ;  [FE]  AssertionFailedError    expected:<[]a  ,  b  ,  c>  but  was:<[  ,  ]a  ,  b  ,  c>  assertEquals( " "  ,  format.format())  ;  assertEquals( "a  ,  b  ,  c "  ,  format.format( "a "  ,   "b "  ,   "c "))  ;  assertEquals( "\ "x  ,  y\ "  ,  z "  ,  format.format( "x  ,  y "  ,   "z "))  ;  [CONTEXT]      [CLASS]  CSVPrinter  
[REPLACE]  this  .  out  =  out;	[BUGGY]  this  .  out  =    null  ;  [FE]  null  assertEquals( " "  ,  format.format())  ;  assertEquals( "a  ,  b  ,  c "  ,  format.format( "a "  ,   "b "  ,   "c "))  ;  assertEquals( "\ "x  ,  y\ "  ,  z "  ,  format.format( "x  ,  y "  ,   "z "))  ;  [CONTEXT]  public  CSVPrinter  (  Appendable  out  ,  CSVFormat  format  )  {  [ATTENTION]  this  .  out  =  null  ;  this  .  format  =  format  =  =  null  ?  CSVFormat  .  DEFAULT  :  format  ;    this  .  format  .  validate  (  )  ;  }    [METHOD]  <init>  [TYPE]  CSVFormat)  [PARAMETER]  Appendable  out  CSVFormat  format  [CLASS]  CSVPrinter    [TYPE]  CSVFormat  format  [TYPE]  boolean  false  newLine  true  [TYPE]  Appendable  out  
[REPLACE]  this  .  format  =  format  ==  null  ?  CSVFormat  .  DEFAULT  :  format;	[BUGGY]  this  .  format    =    CSVFormat  .  DEFAULT  ;  [FE]  (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo\n "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "foo\n  baar  ,  ,  ,   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "\n\t  \n "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  public  CSVPrinter  (  Appendable  out  ,  CSVFormat  format  )  {  this  .  out  =  out  ;  [ATTENTION]  this  .  format  =  CSVFormat  .  DEFAULT  ;    this  .  format  .  validate  (  )  ;  }    [METHOD]  <init>  [TYPE]  CSVFormat)  [PARAMETER]  Appendable  out  CSVFormat  format  [CLASS]  CSVPrinter    [TYPE]  CSVFormat  format  [TYPE]  boolean  false  newLine  true  [TYPE]  Appendable  out  
[REPLACE]  this  .  format  .  validate  (  )  ;	[BUGGY]  this  .  format  .  getEscape  (  )  ;  [FE]  (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo\n "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "foo\n  baar  ,  ,  ,   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "\n\t  \n "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  public  CSVPrinter  (  Appendable  out  ,  CSVFormat  format  )  {  this  .  out  =  out  ;  this  .  format  =  format  =  =  null  ?  CSVFormat  .  DEFAULT  :  format  ;    [ATTENTION]  this  .  format  .  getEscape  (  )    ;  }    [METHOD]  <init>  [TYPE]  CSVFormat)  [PARAMETER]  Appendable  out  CSVFormat  format  [CLASS]  CSVPrinter    [TYPE]  CSVFormat  format  [TYPE]  boolean  false  newLine  true  [TYPE]  Appendable  out  
[REPLACE]  out  .  append  (  format  .  getLineSeparator  (  )  )  ;	[BUGGY]  out  .  append  (  format  .  getEncapsulator  (  )    )  ;  [FE]  AssertionFailedError    expected:<[]>  but  was:<[ "]>  assertEquals( " "  ,  format.format())  ;  assertEquals( "a  ,  b  ,  c "  ,  format.format( "a "  ,   "b "  ,   "c "))  ;  assertEquals( "\ "x  ,  y\ "  ,  z "  ,  format.format( "x  ,  y "  ,   "z "))  ;  [CONTEXT]  public  void  println  (  )  throws  IOException  {  [ATTENTION]  out  .  append  (  format  .  getEncapsulator  (  )    )    ;  newLine  =  true  ;  }    [METHOD]  println  [TYPE]  void  [PARAMETER]  [CLASS]  CSVPrinter    [TYPE]  CSVFormat  format  [TYPE]  boolean  false  newLine  true  [TYPE]  Appendable  out  
[REPLACE]  newLine  =  true;	[BUGGY]  newLine  =  false  ;  [FE]  (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo\n "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "foo\n  baar  ,  ,  ,   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "\n\t  \n "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  public  void  println  (  )  throws  IOException  {  out  .  append  (  format  .  getLineSeparator  (  )  )  ;  [ATTENTION]  newLine  =  false  ;  }    [METHOD]  println  [TYPE]  void  [PARAMETER]  [CLASS]  CSVPrinter    [TYPE]  CSVFormat  format  [TYPE]  boolean  false  newLine  true  [TYPE]  Appendable  out  
[ADD]  newLine  =  true;	[BUGGY]  [FE]  (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo\n "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "foo\n  baar  ,  ,  ,   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "\n\t  \n "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  public  void  println  (  )  throws  IOException  {  out  .  append  (  format  .  getLineSeparator  (  )  )  ;  [ATTENTION]  }    [METHOD]  println  [TYPE]  void  [PARAMETER]  [CLASS]  CSVPrinter    [TYPE]  CSVFormat  format  [TYPE]  boolean  false  newLine  true  [TYPE]  Appendable  out  
[REPLACE]  if  (  out  instanceof  Flushable  )  {	[BUGGY]  if  (  !  out  instanceof  Flushable  )  {[CE]  bad  operand  type  Appendable  for  unary  operator  '!'  [CONTEXT]  public  void  flush  (  )  throws  IOException  {  [ATTENTION]  if  (  !  out  instanceof  Flushable  )  {  (  (  Flushable  )  out  )  .  flush  (  )  ;  }  }    [METHOD]  flush  [TYPE]  void  [PARAMETER]  [CLASS]  CSVPrinter    [TYPE]  CSVFormat  format  [TYPE]  boolean  false  newLine  true  [TYPE]  Appendable  out  
[ADD]  if  (  out  instanceof  Flushable  )  {  (  (  Flushable  )  out  )    .  flush  (  )  ;  }	[BUGGY]  (  (  Flushable  )  out  )  .  flush  (  )  ;  [FE]  (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo\n "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "foo\n  baar  ,  ,  ,   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "\n\t  \n "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  public  void  flush  (  )  throws  IOException  {  [ATTENTION]  (  (  Flushable  )  out  )    .  flush  (  )    ;    }    [METHOD]  flush  [TYPE]  void  [PARAMETER]  [CLASS]  CSVPrinter    [TYPE]  CSVFormat  format  [TYPE]  boolean  false  newLine  true  [TYPE]  Appendable  out  
[REPLACE]  (  (  Flushable  )  out  )    .  flush  (  )  ;	[BUGGY]  if  (  !format  .  isCommentingEnabled  (  )  )  {  return  ;  [CE]  illegal  start  of  expression  [CONTEXT]  public  void  flush  (  )  throws  IOException  {  if  (  out  instanceof  Flushable  )  {  [ATTENTION]  if  (  !format  .  isCommentingEnabled  (  )  )  {  return  ;  }  }    [METHOD]  flush  [TYPE]  void  [PARAMETER]  [CLASS]  CSVPrinter    [TYPE]  CSVFormat  format  [TYPE]  boolean  false  newLine  true  [TYPE]  Appendable  out  
[REPLACE]  for  (  String  value  :  values  )  {	[BUGGY]  for  (  String  value  :  values  )  {  print  (  value  )  ;  [FE]  AssertionFailedError    expected:<a  ,  [b]  ,  c>  but  was:<a  ,  [a  ,  b  ,  b  ,  c]  ,  c>  assertEquals( " "  ,  format.format())  ;  assertEquals( "a  ,  b  ,  c "  ,  format.format( "a "  ,   "b "  ,   "c "))  ;  assertEquals( "\ "x  ,  y\ "  ,  z "  ,  format.format( "x  ,  y "  ,   "z "))  ;  [CONTEXT]  public  void  println  (  String  .  .  .  values  )  throws  IOException  {  [ATTENTION]  for  (  String  value  :  values  )  {  print  (  value  )    ;  print  (  value  )  ;  }  println  (  )  ;  }    [METHOD]  println  [TYPE]  void  [PARAMETER]  values  [CLASS]  CSVPrinter    [TYPE]  CSVFormat  format  [TYPE]  boolean  false  newLine  true  [TYPE]  String[]  values  [TYPE]  String  value  [TYPE]  Appendable  out  
[REPLACE]  println  (  )  ;	[BUGGY]  out  .  append  (  '  '  )  ;  [FE]  (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo\n "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "foo\n  baar  ,  ,  ,   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "\n\t  \n "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  public  void  println  (  String  .  .  .  values  )  throws  IOException  {  for  (  String  value  :  values  )  {  print  (  value  )  ;  }  [ATTENTION]  out  .  append  (  '  '  )    ;  }    [METHOD]  println  [TYPE]  void  [PARAMETER]  values  [CLASS]  CSVPrinter    [TYPE]  CSVFormat  format  [TYPE]  boolean  false  newLine  true  [TYPE]  String[]  values  [TYPE]  String  value  [TYPE]  Appendable  out  
[REPLACE]  if  (  !format  .  isCommentingEnabled  (  )  )  {	[BUGGY]  if  (  !format  .  getCommentStart  (  )    )  {[CE]  bad  operand  type  char  for  unary  operator  '!'  [CONTEXT]  public  void  printComment  (  String  comment  )  throws  IOException  {  [ATTENTION]  if  (  !format  .  getCommentStart  (  )    )  {  return  ;  }  if  (  !newLine  )  {  println  (  )  ;  }  out  .  append  (  format  .  getCommentStart  (  )  )  ;  out  .  append  (  '  '  )  ;  for  (  int  i  =  0  ;  i  <  comment  .  length  (  )  ;  i++  )  {  char  c  =  comment  .  charAt  (  i  )  ;  switch  (  c  )  {  case  '\r':  if  (  i  +  1  <  comment  .  length  (  )  &&  comment  .  charAt  (  i  +  1  )    =  =  '\n'  )  {  i++  ;  }    case  '\n':  println  (  )  ;  out  .  append  (  format  .  getCommentStart  (  )  )  ;  out  .  append  (  '  '  )  ;  break  ;  default:  out  .  append  (  c  )  ;  break  ;  }  }  println  (  )  ;  }    [METHOD]  printComment  [TYPE]  void  [PARAMETER]  String  comment  [CLASS]  CSVPrinter    [TYPE]  char  c  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  newLine  true  [TYPE]  String  comment  [TYPE]  int  i  [TYPE]  Appendable  out  
[REPLACE]  if  (  !newLine  )  {	[BUGGY]  if  (  newLine  )  {[FE]  (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo\n "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "foo\n  baar  ,  ,  ,   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "\n\t  \n "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  public  void  printComment  (  String  comment  )  throws  IOException  {  if  (  !format  .  isCommentingEnabled  (  )  )  {  return  ;  }  [ATTENTION]  if  (  newLine  )  {  println  (  )  ;  }  out  .  append  (  format  .  getCommentStart  (  )  )  ;  out  .  append  (  '  '  )  ;  for  (  int  i  =  0  ;  i  <  comment  .  length  (  )  ;  i++  )  {  char  c  =  comment  .  charAt  (  i  )  ;  switch  (  c  )  {  case  '\r':  if  (  i  +  1  <  comment  .  length  (  )  &&  comment  .  charAt  (  i  +  1  )    =  =  '\n'  )  {  i++  ;  }    case  '\n':  println  (  )  ;  out  .  append  (  format  .  getCommentStart  (  )  )  ;  out  .  append  (  '  '  )  ;  break  ;  default:  out  .  append  (  c  )  ;  break  ;  }  }  println  (  )  ;  }    [METHOD]  printComment  [TYPE]  void  [PARAMETER]  String  comment  [CLASS]  CSVPrinter    [TYPE]  char  c  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  newLine  true  [TYPE]  String  comment  [TYPE]  int  i  [TYPE]  Appendable  out  
[REPLACE]  println  (  )  ;	[BUGGY]  out  .  append  (  '  '  )  ;  [FE]  (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo\n "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "foo\n  baar  ,  ,  ,   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "\n\t  \n "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  public  void  printComment  (  String  comment  )  throws  IOException  {  if  (  !format  .  isCommentingEnabled  (  )  )  {  return  ;  }  if  (  !newLine  )  {  [ATTENTION]  out  .  append  (  '  '  )    ;  }  out  .  append  (  format  .  getCommentStart  (  )  )  ;  out  .  append  (  '  '  )  ;  for  (  int  i  =  0  ;  i  <  comment  .  length  (  )  ;  i++  )  {  char  c  =  comment  .  charAt  (  i  )  ;  switch  (  c  )  {  case  '\r':  if  (  i  +  1  <  comment  .  length  (  )  &&  comment  .  charAt  (  i  +  1  )    =  =  '\n'  )  {  i++  ;  }    case  '\n':  println  (  )  ;  out  .  append  (  format  .  getCommentStart  (  )  )  ;  out  .  append  (  '  '  )  ;  break  ;  default:  out  .  append  (  c  )  ;  break  ;  }  }  println  (  )  ;  }    [METHOD]  printComment  [TYPE]  void  [PARAMETER]  String  comment  [CLASS]  CSVPrinter    [TYPE]  char  c  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  newLine  true  [TYPE]  String  comment  [TYPE]  int  i  [TYPE]  Appendable  out  
[ADD]  println  (  )  ;	[BUGGY]  [FE]  (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo\n "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "foo\n  baar  ,  ,  ,   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "\n\t  \n "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  public  void  printComment  (  String  comment  )  throws  IOException  {  if  (  !format  .  isCommentingEnabled  (  )  )  {  return  ;  }  if  (  !newLine  )  {  [ATTENTION]  }  out  .  append  (  format  .  getCommentStart  (  )  )  ;  out  .  append  (  '  '  )  ;  for  (  int  i  =  0  ;  i  <  comment  .  length  (  )  ;  i++  )  {  char  c  =  comment  .  charAt  (  i  )  ;  switch  (  c  )  {  case  '\r':  if  (  i  +  1  <  comment  .  length  (  )  &&  comment  .  charAt  (  i  +  1  )    =  =  '\n'  )  {  i++  ;  }    case  '\n':  println  (  )  ;  out  .  append  (  format  .  getCommentStart  (  )  )  ;  out  .  append  (  '  '  )  ;  break  ;  default:  out  .  append  (  c  )  ;  break  ;  }  }  println  (  )  ;  }    [METHOD]  printComment  [TYPE]  void  [PARAMETER]  String  comment  [CLASS]  CSVPrinter    [TYPE]  char  c  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  newLine  true  [TYPE]  String  comment  [TYPE]  int  i  [TYPE]  Appendable  out  
[REPLACE]  out  .  append  (  format  .  getCommentStart  (  )  )  ;	[BUGGY]  out  .  append  (  null  ,  i  ,  i  )    ;  [CE]  cannot  find  symbol  i  [CONTEXT]  public  void  printComment  (  String  comment  )  throws  IOException  {  if  (  !format  .  isCommentingEnabled  (  )  )  {  return  ;  }  if  (  !newLine  )  {  println  (  )  ;  }  [ATTENTION]  out  .  append  (  null  ,  i  ,  i  )  ;  out  .  append  (  '  '  )  ;  for  (  int  i  =  0  ;  i  <  comment  .  length  (  )  ;  i++  )  {  char  c  =  comment  .  charAt  (  i  )  ;  switch  (  c  )  {  case  '\r':  if  (  i  +  1  <  comment  .  length  (  )  &&  comment  .  charAt  (  i  +  1  )    =  =  '\n'  )  {  i++  ;  }    case  '\n':  println  (  )  ;  out  .  append  (  format  .  getCommentStart  (  )  )  ;  out  .  append  (  '  '  )  ;  break  ;  default:  out  .  append  (  c  )  ;  break  ;  }  }  println  (  )  ;  }    [METHOD]  printComment  [TYPE]  void  [PARAMETER]  String  comment  [CLASS]  CSVPrinter    [TYPE]  char  c  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  newLine  true  [TYPE]  String  comment  [TYPE]  int  i  [TYPE]  Appendable  out  
[REPLACE]  out  .  append  (  format  .  getCommentStart  (  )  )  ;	[BUGGY]  out  .  append  (  format  .  getEscape  (  )  )  ;  [FE]  (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo\n "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "foo\n  baar  ,  ,  ,   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "\n\t  \n "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  public  void  printComment  (  String  comment  )  throws  IOException  {  if  (  !format  .  isCommentingEnabled  (  )  )  {  return  ;  }  if  (  !newLine  )  {  println  (  )  ;  }  [ATTENTION]  out  .  append  (  format  .  getEscape  (  )  )    ;  out  .  append  (  '  '  )  ;  for  (  int  i  =  0  ;  i  <  comment  .  length  (  )  ;  i++  )  {  char  c  =  comment  .  charAt  (  i  )  ;  switch  (  c  )  {  case  '\r':  if  (  i  +  1  <  comment  .  length  (  )  &&  comment  .  charAt  (  i  +  1  )    =  =  '\n'  )  {  i++  ;  }    case  '\n':  println  (  )  ;  out  .  append  (  format  .  getCommentStart  (  )  )  ;  out  .  append  (  '  '  )  ;  break  ;  default:  out  .  append  (  c  )  ;  break  ;  }  }  println  (  )  ;  }    [METHOD]  printComment  [TYPE]  void  [PARAMETER]  String  comment  [CLASS]  CSVPrinter    [TYPE]  char  c  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  newLine  true  [TYPE]  String  comment  [TYPE]  int  i  [TYPE]  Appendable  out  
[REPLACE]  out  .  append  (  '  '  )  ;	[BUGGY]  out  .  append  (  null  ,  i  ,  i  )    ;  [CE]  cannot  find  symbol  i  [CONTEXT]  public  void  printComment  (  String  comment  )  throws  IOException  {  if  (  !format  .  isCommentingEnabled  (  )  )  {  return  ;  }  if  (  !newLine  )  {  println  (  )  ;  }  out  .  append  (  format  .  getCommentStart  (  )  )  ;  [ATTENTION]  out  .  append  (  null  ,  i  ,  i  )  ;  for  (  int  i  =  0  ;  i  <  comment  .  length  (  )  ;  i++  )  {  char  c  =  comment  .  charAt  (  i  )  ;  switch  (  c  )  {  case  '\r':  if  (  i  +  1  <  comment  .  length  (  )  &&  comment  .  charAt  (  i  +  1  )    =  =  '\n'  )  {  i++  ;  }    case  '\n':  println  (  )  ;  out  .  append  (  format  .  getCommentStart  (  )  )  ;  out  .  append  (  '  '  )  ;  break  ;  default:  out  .  append  (  c  )  ;  break  ;  }  }  println  (  )  ;  }    [METHOD]  printComment  [TYPE]  void  [PARAMETER]  String  comment  [CLASS]  CSVPrinter    [TYPE]  char  c  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  newLine  true  [TYPE]  String  comment  [TYPE]  int  i  [TYPE]  Appendable  out  
[REMOVE]  	[BUGGY]  out  .  append  (  encapsulator  )  ;  [CE]  cannot  find  symbol  encapsulator  [CONTEXT]  public  void  printComment  (  String  comment  )  throws  IOException  {  if  (  !format  .  isCommentingEnabled  (  )  )  {  return  ;  }  if  (  !newLine  )  {  println  (  )  ;  }  out  .  append  (  format  .  getCommentStart  (  )  )  ;  [ATTENTION]  out  .  append  (  '  '  )  ;    out  .  append  (  encapsulator  )    ;  for  (  int  i  =  0  ;  i  <  comment  .  length  (  )  ;  i++  )  {  char  c  =  comment  .  charAt  (  i  )  ;  switch  (  c  )  {  case  '\r':  if  (  i  +  1  <  comment  .  length  (  )  &&  comment  .  charAt  (  i  +  1  )    =  =  '\n'  )  {  i++  ;  }    case  '\n':  println  (  )  ;  out  .  append  (  format  .  getCommentStart  (  )  )  ;  out  .  append  (  '  '  )  ;  break  ;  default:  out  .  append  (  c  )  ;  break  ;  }  }  println  (  )  ;      [METHOD]  printComment  [TYPE]  void  [PARAMETER]  String  comment  [CLASS]  CSVPrinter    [TYPE]  char  c  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  newLine  true  [TYPE]  String  comment  [TYPE]  int  i  [TYPE]  Appendable  out  
[REPLACE]  if  (  i  +  1  <  comment  .  length  (  )  &&  comment  .  charAt  (  i  +  1  )  ==  '\n'  )  {	[BUGGY]  if  (  i  +  0  <  comment  .  length  (  )  -  2  &&  comment  .  charAt  (  i  +  0  )    =  =  '\n'  )  {[FE]  (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo\n "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "foo\n  baar  ,  ,  ,   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "\n\t  \n "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  public  void  printComment  (  String  comment  )  throws  IOException  {  if  (  !format  .  isCommentingEnabled  (  )  )  {  return  ;  }  if  (  !newLine  )  {  println  (  )  ;  }  out  .  append  (  format  .  getCommentStart  (  )  )  ;  out  .  append  (  '  '  )  ;  for  (  int  i  =  0  ;  i  <  comment  .  length  (  )  ;  i++  )  {  char  c  =  comment  .  charAt  (  i  )  ;  switch  (  c  )  {  case  '\r':  [ATTENTION]  if  (  i  +  0<  comment  .  length  (  )  -  2  &&  comment  .  charAt  (  i  +  0  )  =  =  '\n'  )  {  i++  ;  }    case  '\n':  println  (  )  ;  out  .  append  (  format  .  getCommentStart  (  )  )  ;  out  .  append  (  '  '  )  ;  break  ;  default:  out  .  append  (  c  )  ;  break  ;  }  }  println  (  )  ;  }    [METHOD]  printComment  [TYPE]  void  [PARAMETER]  String  comment  [CLASS]  CSVPrinter    [TYPE]  char  c  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  newLine  true  [TYPE]  String  comment  [TYPE]  int  i  [TYPE]  Appendable  out  
[ADD]  if  (  i  +  1  <  comment  .  length  (  )  &&  comment  .  charAt  (  i  +  1  )  ==  '\n'  )  {  i++;  }	[BUGGY]  i++  ;  [FE]  (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo\n "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "foo\n  baar  ,  ,  ,   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "\n\t  \n "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  public  void  printComment  (  String  comment  )  throws  IOException  {  if  (  !format  .  isCommentingEnabled  (  )  )  {  return  ;  }  if  (  !newLine  )  {  println  (  )  ;  }  out  .  append  (  format  .  getCommentStart  (  )  )  ;  out  .  append  (  '  '  )  ;  for  (  int  i  =  0  ;  i  <  comment  .  length  (  )  ;  i++  )  {  char  c  =  comment  .  charAt  (  i  )  ;  switch  (  c  )  {  case  '\r':  [ATTENTION]  i++  ;      case  '\n':  println  (  )  ;  out  .  append  (  format  .  getCommentStart  (  )  )  ;  out  .  append  (  '  '  )  ;  break  ;  default:  out  .  append  (  c  )  ;  break  ;  }  }  println  (  )  ;  }    [METHOD]  printComment  [TYPE]  void  [PARAMETER]  String  comment  [CLASS]  CSVPrinter    [TYPE]  char  c  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  newLine  true  [TYPE]  String  comment  [TYPE]  int  i  [TYPE]  Appendable  out  
[REPLACE]  for  (  int  i  =  0;  i  <  comment  .  length  (  )  ;  i++  )  {	[BUGGY]  for  (  int  i  =  0  ;  i  <  comment  .  length  (  )  /  2  ;  i++  )  {[FE]  (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo\n "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "foo\n  baar  ,  ,  ,   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "\n\t  \n "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  public  void  printComment  (  String  comment  )  throws  IOException  {  if  (  !format  .  isCommentingEnabled  (  )  )  {  return  ;  }  if  (  !newLine  )  {  println  (  )  ;  }  out  .  append  (  format  .  getCommentStart  (  )  )  ;  out  .  append  (  '  '  )  ;  [ATTENTION]  for  (  int  i  =  0  ;  i  <  comment  .  length  (  )  /2  ;  i++  )  {  char  c  =  comment  .  charAt  (  i  )  ;  switch  (  c  )  {  case  '\r':  if  (  i  +  1  <  comment  .  length  (  )  &&  comment  .  charAt  (  i  +  1  )    =  =  '\n'  )  {  i++  ;  }    case  '\n':  println  (  )  ;  out  .  append  (  format  .  getCommentStart  (  )  )  ;  out  .  append  (  '  '  )  ;  break  ;  default:  out  .  append  (  c  )  ;  break  ;  }  }  println  (  )  ;  }    [METHOD]  printComment  [TYPE]  void  [PARAMETER]  String  comment  [CLASS]  CSVPrinter    [TYPE]  char  c  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  newLine  true  [TYPE]  String  comment  [TYPE]  int  i  [TYPE]  Appendable  out  
[REPLACE]  if  (  i  +  1  <  comment  .  length  (  )  &&  comment  .  charAt  (  i  +  1  )  ==  '\n'  )  {	[BUGGY]  if  (  i  +  1  <  comment  .  charAt  (  )  +  2  )  {[CE]  method  charAt  in  class  String  cannot  be  applied  to  given  types  ;  [CONTEXT]  public  void  printComment  (  String  comment  )  throws  IOException  {  if  (  !format  .  isCommentingEnabled  (  )  )  {  return  ;  }  if  (  !newLine  )  {  println  (  )  ;  }  out  .  append  (  format  .  getCommentStart  (  )  )  ;  out  .  append  (  '  '  )  ;  for  (  int  i  =  0  ;  i  <  comment  .  length  (  )  ;  i++  )  {  char  c  =  comment  .  charAt  (  i  )  ;  switch  (  c  )  {  case  '\r':  [ATTENTION]  if  (  i  +  1  <  comment  .  charAt  (  )  +  2  )  {  i++  ;  }    case  '\n':  println  (  )  ;  out  .  append  (  format  .  getCommentStart  (  )  )  ;  out  .  append  (  '  '  )  ;  break  ;  default:  out  .  append  (  c  )  ;  break  ;  }  }  println  (  )  ;  }    [METHOD]  printComment  [TYPE]  void  [PARAMETER]  String  comment  [CLASS]  CSVPrinter    [TYPE]  char  c  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  newLine  true  [TYPE]  String  comment  [TYPE]  int  i  [TYPE]  Appendable  out  
[ADD]  if  (  i  +  1  <  comment  .  length  (  )  &&  comment  .  charAt  (  i  +  1  )  ==  '\n'  )  {  i++;  }	[BUGGY]  [FE]  (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo\n "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "foo\n  baar  ,  ,  ,   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "\n\t  \n "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  public  void  printComment  (  String  comment  )  throws  IOException  {  if  (  !format  .  isCommentingEnabled  (  )  )  {  return  ;  }  if  (  !newLine  )  {  println  (  )  ;  }  out  .  append  (  format  .  getCommentStart  (  )  )  ;  out  .  append  (  '  '  )  ;  for  (  int  i  =  0  ;  i  <  comment  .  length  (  )  ;  i++  )  {  char  c  =  comment  .  charAt  (  i  )  ;  switch  (  c  )  {  case  '\r':  [ATTENTION]      case  '\n':  println  (  )  ;  out  .  append  (  format  .  getCommentStart  (  )  )  ;  out  .  append  (  '  '  )  ;  break  ;  default:  out  .  append  (  c  )  ;  break  ;  }  }  println  (  )  ;  }    [METHOD]  printComment  [TYPE]  void  [PARAMETER]  String  comment  [CLASS]  CSVPrinter    [TYPE]  char  c  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  newLine  true  [TYPE]  String  comment  [TYPE]  int  i  [TYPE]  Appendable  out  
[REPLACE]  char  c  =  comment  .  charAt  (  i  )  ;	[BUGGY]  char  delim  =  format  .  getDelimiter  (  )  ;  [CE]  cannot  find  symbol  c  [CONTEXT]  public  void  printComment  (  String  comment  )  throws  IOException  {  if  (  !format  .  isCommentingEnabled  (  )  )  {  return  ;  }  if  (  !newLine  )  {  println  (  )  ;  }  out  .  append  (  format  .  getCommentStart  (  )  )  ;  out  .  append  (  '  '  )  ;  for  (  int  i  =  0  ;  i  <  comment  .  length  (  )  ;  i++  )  {  [ATTENTION]  char  delim  =  format  .  getDelimiter  (  )    ;  switch  (  c  )  {  case  '\r':  if  (  i  +  1  <  comment  .  length  (  )  &&  comment  .  charAt  (  i  +  1  )    =  =  '\n'  )  {  i++  ;  }    case  '\n':  println  (  )  ;  out  .  append  (  format  .  getCommentStart  (  )  )  ;  out  .  append  (  '  '  )  ;  break  ;  default:  out  .  append  (  c  )  ;  break  ;  }  }  println  (  )  ;  }    [METHOD]  printComment  [TYPE]  void  [PARAMETER]  String  comment  [CLASS]  CSVPrinter    [TYPE]  char  c  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  newLine  true  [TYPE]  String  comment  [TYPE]  int  i  [TYPE]  Appendable  out  
[REPLACE]  for  (  int  i  =  0;  i  <  comment  .  length  (  )  ;  i++  )  {	[BUGGY]  for  (  int  i  =  0  ;  i  <  comment  .  length  (  )  ;  i++  )  {[FE]  (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo\n "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "foo\n  baar  ,  ,  ,   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "\n\t  \n "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  public  void  printComment  (  String  comment  )  throws  IOException  {  if  (  !format  .  isCommentingEnabled  (  )  )  {  return  ;  }  if  (  !newLine  )  {  println  (  )  ;  }  out  .  append  (  format  .  getCommentStart  (  )  )  ;  out  .  append  (  '  '  )  ;  [ATTENTION]  for  (  int  i  =  0  ;  i  <  comment  .  length  (  )    ;  i++  )  {  char  c  =  comment  .  charAt  (  i  )  ;  switch  (  c  )  {  case  '\r':  if  (  i  +  1  <  comment  .  length  (  )  &&  comment  .  charAt  (  i  +  1  )    =  =  '\n'  )  {  i++  ;  }    case  '\n':  println  (  )  ;  out  .  append  (  format  .  getCommentStart  (  )  )  ;  out  .  append  (  '  '  )  ;  break  ;  default:  out  .  append  (  c  )  ;  break  ;  }  }  println  (  )  ;  }    [METHOD]  printComment  [TYPE]  void  [PARAMETER]  String  comment  [CLASS]  CSVPrinter    [TYPE]  char  c  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  newLine  true  [TYPE]  String  comment  [TYPE]  int  i  [TYPE]  Appendable  out  
[REPLACE]  println  (  )  ;	[BUGGY]  out  .  append  (  '  '  )  ;  [FE]  (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo\n "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "foo\n  baar  ,  ,  ,   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "\n\t  \n "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  public  void  printComment  (  String  comment  )  throws  IOException  {  if  (  !format  .  isCommentingEnabled  (  )  )  {  return  ;  }  if  (  !newLine  )  {  println  (  )  ;  }  out  .  append  (  format  .  getCommentStart  (  )  )  ;  out  .  append  (  '  '  )  ;  for  (  int  i  =  0  ;  i  <  comment  .  length  (  )  ;  i++  )  {  char  c  =  comment  .  charAt  (  i  )  ;  switch  (  c  )  {  case  '\r':  if  (  i  +  1  <  comment  .  length  (  )  &&  comment  .  charAt  (  i  +  1  )    =  =  '\n'  )  {  i++  ;  }    case  '\n':  println  (  )  ;  out  .  append  (  format  .  getCommentStart  (  )  )  ;  out  .  append  (  '  '  )  ;  break  ;  default:  out  .  append  (  c  )  ;  break  ;  }  }  [ATTENTION]  out  .  append  (  '  '  )    ;  }    [METHOD]  printComment  [TYPE]  void  [PARAMETER]  String  comment  [CLASS]  CSVPrinter    [TYPE]  char  c  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  newLine  true  [TYPE]  String  comment  [TYPE]  int  i  [TYPE]  Appendable  out  
[ADD]  println  (  )  ;	[BUGGY]  [FE]  (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo\n "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "foo\n  baar  ,  ,  ,   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "\n\t  \n "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  public  void  printComment  (  String  comment  )  throws  IOException  {  if  (  !format  .  isCommentingEnabled  (  )  )  {  return  ;  }  if  (  !newLine  )  {  println  (  )  ;  }  out  .  append  (  format  .  getCommentStart  (  )  )  ;  out  .  append  (  '  '  )  ;  for  (  int  i  =  0  ;  i  <  comment  .  length  (  )  ;  i++  )  {  char  c  =  comment  .  charAt  (  i  )  ;  switch  (  c  )  {  case  '\r':  if  (  i  +  1  <  comment  .  length  (  )  &&  comment  .  charAt  (  i  +  1  )    =  =  '\n'  )  {  i++  ;  }    case  '\n':  println  (  )  ;  out  .  append  (  format  .  getCommentStart  (  )  )  ;  out  .  append  (  '  '  )  ;  break  ;  default:  out  .  append  (  c  )  ;  break  ;  }  }  [ATTENTION]  }    [METHOD]  printComment  [TYPE]  void  [PARAMETER]  String  comment  [CLASS]  CSVPrinter    [TYPE]  char  c  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  newLine  true  [TYPE]  String  comment  [TYPE]  int  i  [TYPE]  Appendable  out  
[REPLACE]  if  (  format  .  isEncapsulating  (  )  )  {	[BUGGY]  if  (  newLine  )  {[FE]  (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo\n "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "foo\n  baar  ,  ,  ,   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "\n\t  \n "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  private  void  print  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  [ATTENTION]  if  (  newLine  )  {  printAndEncapsulate  (  value  ,  offset  ,  len  )  ;  }  else  if  (  format  .  isEscaping  (  )  )  {  printAndEscape  (  value  ,  offset  ,  len  )  ;  }  else  {  printSep  (  )  ;  out  .  append  (  value  ,  offset  ,  offset  +  len  )  ;  }  }    [METHOD]  print  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  newLine  true  [TYPE]  int  len  offset  [TYPE]  Appendable  out  
[REPLACE]  }  else  if  (  format  .  isEscaping  (  )  )  {	[BUGGY]    else  {[CE]  'else'  without  'if'  [CONTEXT]  private  void  print  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  if  (  format  .  isEncapsulating  (  )  )  {  printAndEncapsulate  (  value  ,  offset  ,  len  )  ;  [ATTENTION]  }else  {  printAndEscape  (  value  ,  offset  ,  len  )  ;  }  else  {  printSep  (  )  ;  out  .  append  (  value  ,  offset  ,  offset  +  len  )  ;  }  }    [METHOD]  print  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  newLine  true  [TYPE]  int  len  offset  [TYPE]  Appendable  out  
[REPLACE]  printSep  (  )  ;	[BUGGY]  out  .  append  (  '  '  )  ;  [FE]  (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo\n "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "foo\n  baar  ,  ,  ,   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "\n\t  \n "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  private  void  print  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  if  (  format  .  isEncapsulating  (  )  )  {  printAndEncapsulate  (  value  ,  offset  ,  len  )  ;  }  else  if  (  format  .  isEscaping  (  )  )  {  printAndEscape  (  value  ,  offset  ,  len  )  ;  }  else  {  [ATTENTION]  out  .  append  (  '  '  )    ;  out  .  append  (  value  ,  offset  ,  offset  +  len  )  ;  }  }    [METHOD]  print  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  newLine  true  [TYPE]  int  len  offset  [TYPE]  Appendable  out  
[REPLACE]  out  .  append  (  value,  offset,  offset  +  len  )  ;	[BUGGY]  out  .  append  (  value  ,  offset  ,  offset  >  offset  )  ;  [CE]  no  suitable  method  found  for  append(CharSequence  ,  int  ,  boolean)  [CONTEXT]  private  void  print  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  if  (  format  .  isEncapsulating  (  )  )  {  printAndEncapsulate  (  value  ,  offset  ,  len  )  ;  }  else  if  (  format  .  isEscaping  (  )  )  {  printAndEscape  (  value  ,  offset  ,  len  )  ;  }  else  {  printSep  (  )  ;  [ATTENTION]  out  .  append  (  value  ,  offset  ,  offset>offset  )    ;  }  }    [METHOD]  print  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  newLine  true  [TYPE]  int  len  offset  [TYPE]  Appendable  out  
[REPLACE]  printAndEscape  (  value,  offset,  len  )  ;	[BUGGY]  printAndEncapsulate  (  value  ,  offset  ,  len  )  ;  [FE]  (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo\n "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "foo\n  baar  ,  ,  ,   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "\n\t  \n "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  private  void  print  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  if  (  format  .  isEncapsulating  (  )  )  {  printAndEncapsulate  (  value  ,  offset  ,  len  )  ;  }  else  if  (  format  .  isEscaping  (  )  )  {  [ATTENTION]  printAndEncapsulate  (  value  ,  offset  ,  len  )    ;  }  else  {  printSep  (  )  ;  out  .  append  (  value  ,  offset  ,  offset  +  len  )  ;  }  }    [METHOD]  print  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  newLine  true  [TYPE]  int  len  offset  [TYPE]  Appendable  out  
[REPLACE]  printAndEncapsulate  (  value,  offset,  len  )  ;	[BUGGY]  printAndEscape  (  value  ,  offset  ,  len  )  ;  [FE]  AssertionFailedError    expected:<[ "x  ,  y "]  ,  z>  but  was:<[x  assertEquals( " "  ,  format.format())  ;  assertEquals( "a  ,  b  ,  c "  ,  format.format( "a "  ,   "b "  ,   "c "))  ;  assertEquals( "\ "x  ,  y\ "  ,  z "  ,  format.format( "x  ,  y "  ,   "z "))  ;  [CONTEXT]  private  void  print  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  if  (  format  .  isEncapsulating  (  )  )  {  [ATTENTION]  printAndEscape  (  value  ,  offset  ,  len  )    ;  }  else  if  (  format  .  isEscaping  (  )  )  {  printAndEscape  (  value  ,  offset  ,  len  )  ;  }  else  {  printSep  (  )  ;  out  .  append  (  value  ,  offset  ,  offset  +  len  )  ;  }  }    [METHOD]  print  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  newLine  true  [TYPE]  int  len  offset  [TYPE]  Appendable  out  
[REPLACE]  }  else  if  (  format  .  isEscaping  (  )  )  {	[BUGGY]    if  (  format  .  isEscaping  (  )  )  {[FE]  AssertionFailedError    expected:<a  ,  [b]  ,  c>  but  was:<a  ,  [a  ,  b  ,  b  ,  c]  ,  c>  assertEquals( " "  ,  format.format())  ;  assertEquals( "a  ,  b  ,  c "  ,  format.format( "a "  ,   "b "  ,   "c "))  ;  assertEquals( "\ "x  ,  y\ "  ,  z "  ,  format.format( "x  ,  y "  ,   "z "))  ;  [CONTEXT]  private  void  print  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  if  (  format  .  isEncapsulating  (  )  )  {  printAndEncapsulate  (  value  ,  offset  ,  len  )  ;  [ATTENTION]  }if  (  format  .  isEscaping  (  )  )  {  printAndEscape  (  value  ,  offset  ,  len  )  ;  }  else  {  printSep  (  )  ;  out  .  append  (  value  ,  offset  ,  offset  +  len  )  ;  }  }    [METHOD]  print  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  newLine  true  [TYPE]  int  len  offset  [TYPE]  Appendable  out  
[ADD]  printSep  (  )  ;	[BUGGY]  [FE]  (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo\n "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "foo\n  baar  ,  ,  ,   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "\n\t  \n "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  private  void  print  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  if  (  format  .  isEncapsulating  (  )  )  {  printAndEncapsulate  (  value  ,  offset  ,  len  )  ;  }  else  if  (  format  .  isEscaping  (  )  )  {  printAndEscape  (  value  ,  offset  ,  len  )  ;  }  else  {  [ATTENTION]  out  .  append  (  value  ,  offset  ,  offset  +  len  )  ;  }  }    [METHOD]  print  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  newLine  true  [TYPE]  int  len  offset  [TYPE]  Appendable  out  
[REPLACE]  out  .  append  (  value,  offset,  offset  +  len  )  ;	[BUGGY]  out  .  append  (  value  ,  offset  ,  offset  >  len  )  ;  [CE]  no  suitable  method  found  for  append(CharSequence  ,  int  ,  boolean)  [CONTEXT]  private  void  print  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  if  (  format  .  isEncapsulating  (  )  )  {  printAndEncapsulate  (  value  ,  offset  ,  len  )  ;  }  else  if  (  format  .  isEscaping  (  )  )  {  printAndEscape  (  value  ,  offset  ,  len  )  ;  }  else  {  printSep  (  )  ;  [ATTENTION]  out  .  append  (  value  ,  offset  ,  offset>len  )    ;  }  }    [METHOD]  print  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  newLine  true  [TYPE]  int  len  offset  [TYPE]  Appendable  out  
[REPLACE]  if  (  newLine  )  {	[BUGGY]  if  (  !newLine  )  {[FE]  AssertionFailedError    expected:<[]a  ,  b  ,  c>  but  was:<[  ,  ]a  ,  b  ,  c>  assertEquals( " "  ,  format.format())  ;  assertEquals( "a  ,  b  ,  c "  ,  format.format( "a "  ,   "b "  ,   "c "))  ;  assertEquals( "\ "x  ,  y\ "  ,  z "  ,  format.format( "x  ,  y "  ,   "z "))  ;  [CONTEXT]  void  printSep  (  )  throws  IOException  {  [ATTENTION]  if  (  !newLine  )  {  newLine  =  false  ;  }  else  {  out  .  append  (  format  .  getDelimiter  (  )  )  ;  }  }    [METHOD]  printSep  [TYPE]  void  [PARAMETER]  [CLASS]  CSVPrinter    [TYPE]  CSVFormat  format  [TYPE]  boolean  false  newLine  true  [TYPE]  Appendable  out  
[REPLACE]  out  .  append  (  format  .  getDelimiter  (  )  )  ;	[BUGGY]  out  .  append  (  format  .  getEscape  (  )    )  ;  [FE]  AssertionFailedError    expected:<a[  ,  b  ,  ]c>  but  was:<a[  assertEquals( " "  ,  format.format())  ;  assertEquals( "a  ,  b  ,  c "  ,  format.format( "a "  ,   "b "  ,   "c "))  ;  assertEquals( "\ "x  ,  y\ "  ,  z "  ,  format.format( "x  ,  y "  ,   "z "))  ;  [CONTEXT]  void  printSep  (  )  throws  IOException  {  if  (  newLine  )  {  newLine  =  false  ;  }  else  {  [ATTENTION]  out  .  append  (  format  .  getEscape  (  )    )    ;  }  }    [METHOD]  printSep  [TYPE]  void  [PARAMETER]  [CLASS]  CSVPrinter    [TYPE]  CSVFormat  format  [TYPE]  boolean  false  newLine  true  [TYPE]  Appendable  out  
[REPLACE]  out  .  append  (  format  .  getDelimiter  (  )  )  ;	[BUGGY]  out  .  append  (  format  .  getEscape  (  )  )  ;  [FE]  AssertionFailedError    expected:<a[  ,  b  ,  ]c>  but  was:<a[  assertEquals( " "  ,  format.format())  ;  assertEquals( "a  ,  b  ,  c "  ,  format.format( "a "  ,   "b "  ,   "c "))  ;  assertEquals( "\ "x  ,  y\ "  ,  z "  ,  format.format( "x  ,  y "  ,   "z "))  ;  [CONTEXT]  void  printSep  (  )  throws  IOException  {  if  (  newLine  )  {  newLine  =  false  ;  }  else  {  [ATTENTION]  out  .  append  (  format  .  getEscape  (  )  )    ;  }  }    [METHOD]  printSep  [TYPE]  void  [PARAMETER]  [CLASS]  CSVPrinter    [TYPE]  CSVFormat  format  [TYPE]  boolean  false  newLine  true  [TYPE]  Appendable  out  
[ADD]  out  .  append  (  format  .  getDelimiter  (  )  )  ;  }	[BUGGY]  [CE]  illegal  start  of  expression  [CONTEXT]  void  printSep  (  )  throws  IOException  {  if  (  newLine  )  {  newLine  =  false  ;  }  else  {  [ATTENTION]    }    [METHOD]  printSep  [TYPE]  void  [PARAMETER]  [CLASS]  CSVPrinter    [TYPE]  CSVFormat  format  [TYPE]  boolean  false  newLine  true  [TYPE]  Appendable  out  
[REPLACE]  newLine  =  false;	[BUGGY]  newLine  =  true  ;  [FE]  AssertionFailedError    expected:<a[  ,  b  ,  ]c>  but  was:<a[b]c>  assertEquals( " "  ,  format.format())  ;  assertEquals( "a  ,  b  ,  c "  ,  format.format( "a "  ,   "b "  ,   "c "))  ;  assertEquals( "\ "x  ,  y\ "  ,  z "  ,  format.format( "x  ,  y "  ,   "z "))  ;  [CONTEXT]  void  printSep  (  )  throws  IOException  {  if  (  newLine  )  {  [ATTENTION]  newLine  =  true  ;  }  else  {  out  .  append  (  format  .  getDelimiter  (  )  )  ;  }  }    [METHOD]  printSep  [TYPE]  void  [PARAMETER]  [CLASS]  CSVPrinter    [TYPE]  CSVFormat  format  [TYPE]  boolean  false  newLine  true  [TYPE]  Appendable  out  
[REPLACE]  int  start  =  offset;	[BUGGY]  int  start  =  start  ;  [CE]  variable  start  might  not  have  been  initialized  [CONTEXT]  void  printAndEscape  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  [ATTENTION]  int  start  =  start  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  escape  =  format  .  getEscape  (  )  ;    while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\r'  ||  c  =  =  '\n'  ||  c  =  =  delim  ||  c  =  =  escape  )  {    if  (  pos  >  start  )  {  out  .  append  (  value  ,  start  ,  pos  )  ;  }  if  (  c  =  =  '\n'  )  {  c  =  'n'  ;  }  else  if  (  c  =  =  '\r'  )  {  c  =  'r'  ;  }  out  .  append  (  escape  )  ;  out  .  append  (  c  )  ;    start  =  pos  +  1  ;  //  start  on  the  current  char  after  this  one  }  pos++  ;  }    if  (  pos  >  start  )  {  out  .  append  (  value  ,  start  ,  pos  )  ;  }  }    [METHOD]  printAndEscape  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  escape  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  newLine  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out  
[REPLACE]  int  pos  =  offset;	[BUGGY]  int  pos  =  start  ;  [FE]  (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo\n "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "foo\n  baar  ,  ,  ,   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "\n\t  \n "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  void  printAndEscape  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  int  start  =  offset  ;  [ATTENTION]  int  pos  =  start  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  escape  =  format  .  getEscape  (  )  ;    while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\r'  ||  c  =  =  '\n'  ||  c  =  =  delim  ||  c  =  =  escape  )  {    if  (  pos  >  start  )  {  out  .  append  (  value  ,  start  ,  pos  )  ;  }  if  (  c  =  =  '\n'  )  {  c  =  'n'  ;  }  else  if  (  c  =  =  '\r'  )  {  c  =  'r'  ;  }  out  .  append  (  escape  )  ;  out  .  append  (  c  )  ;    start  =  pos  +  1  ;  //  start  on  the  current  char  after  this  one  }  pos++  ;  }    if  (  pos  >  start  )  {  out  .  append  (  value  ,  start  ,  pos  )  ;  }  }    [METHOD]  printAndEscape  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  escape  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  newLine  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out  
[REPLACE]  int  end  =  offset  +  len;	[BUGGY]  int  end  =  offset  !  =    len  ;  [CE]  incompatible  types  [CONTEXT]  void  printAndEscape  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  int  start  =  offset  ;  int  pos  =  offset  ;  [ATTENTION]  int  end  =  offset!  =  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  escape  =  format  .  getEscape  (  )  ;    while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\r'  ||  c  =  =  '\n'  ||  c  =  =  delim  ||  c  =  =  escape  )  {    if  (  pos  >  start  )  {  out  .  append  (  value  ,  start  ,  pos  )  ;  }  if  (  c  =  =  '\n'  )  {  c  =  'n'  ;  }  else  if  (  c  =  =  '\r'  )  {  c  =  'r'  ;  }  out  .  append  (  escape  )  ;  out  .  append  (  c  )  ;    start  =  pos  +  1  ;  //  start  on  the  current  char  after  this  one  }  pos++  ;  }    if  (  pos  >  start  )  {  out  .  append  (  value  ,  start  ,  pos  )  ;  }  }    [METHOD]  printAndEscape  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  escape  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  newLine  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out  
[REPLACE]  printSep  (  )  ;	[BUGGY]  out  .  append  (  '  '  )  ;  [FE]  (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo\n "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "foo\n  baar  ,  ,  ,   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "\n\t  \n "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  void  printAndEscape  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    [ATTENTION]  out  .  append  (  '  '  )    ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  escape  =  format  .  getEscape  (  )  ;    while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\r'  ||  c  =  =  '\n'  ||  c  =  =  delim  ||  c  =  =  escape  )  {    if  (  pos  >  start  )  {  out  .  append  (  value  ,  start  ,  pos  )  ;  }  if  (  c  =  =  '\n'  )  {  c  =  'n'  ;  }  else  if  (  c  =  =  '\r'  )  {  c  =  'r'  ;  }  out  .  append  (  escape  )  ;  out  .  append  (  c  )  ;    start  =  pos  +  1  ;  //  start  on  the  current  char  after  this  one  }  pos++  ;  }    if  (  pos  >  start  )  {  out  .  append  (  value  ,  start  ,  pos  )  ;  }  }    [METHOD]  printAndEscape  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  escape  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  newLine  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out  
[ADD]  printSep  (  )  ;	[BUGGY]  [FE]  (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo\n "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "foo\n  baar  ,  ,  ,   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "\n\t  \n "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  void  printAndEscape  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    [ATTENTION]    char  delim  =  format  .  getDelimiter  (  )  ;  char  escape  =  format  .  getEscape  (  )  ;    while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\r'  ||  c  =  =  '\n'  ||  c  =  =  delim  ||  c  =  =  escape  )  {    if  (  pos  >  start  )  {  out  .  append  (  value  ,  start  ,  pos  )  ;  }  if  (  c  =  =  '\n'  )  {  c  =  'n'  ;  }  else  if  (  c  =  =  '\r'  )  {  c  =  'r'  ;  }  out  .  append  (  escape  )  ;  out  .  append  (  c  )  ;    start  =  pos  +  1  ;  //  start  on  the  current  char  after  this  one  }  pos++  ;  }    if  (  pos  >  start  )  {  out  .  append  (  value  ,  start  ,  pos  )  ;  }  }    [METHOD]  printAndEscape  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  escape  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  newLine  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out  
[REPLACE]  char  delim  =  format  .  getDelimiter  (  )  ;	[BUGGY]  char  delim  =  format  .  getEscape  (  )    ;  [FE]  (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo\n "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "foo\n  baar  ,  ,  ,   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "\n\t  \n "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  void  printAndEscape  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    [ATTENTION]  char  delim  =  format  .  getEscape  (  )  ;  char  escape  =  format  .  getEscape  (  )  ;    while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\r'  ||  c  =  =  '\n'  ||  c  =  =  delim  ||  c  =  =  escape  )  {    if  (  pos  >  start  )  {  out  .  append  (  value  ,  start  ,  pos  )  ;  }  if  (  c  =  =  '\n'  )  {  c  =  'n'  ;  }  else  if  (  c  =  =  '\r'  )  {  c  =  'r'  ;  }  out  .  append  (  escape  )  ;  out  .  append  (  c  )  ;    start  =  pos  +  1  ;  //  start  on  the  current  char  after  this  one  }  pos++  ;  }    if  (  pos  >  start  )  {  out  .  append  (  value  ,  start  ,  pos  )  ;  }  }    [METHOD]  printAndEscape  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  escape  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  newLine  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out  
[REPLACE]  char  escape  =  format  .  getEscape  (  )  ;	[BUGGY]  char  escape  =  format  .  getEncapsulator  (  )    ;  [FE]  (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo\n "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "foo\n  baar  ,  ,  ,   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "\n\t  \n "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  void  printAndEscape  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  [ATTENTION]  char  escape  =  format  .  getEncapsulator  (  )  ;    while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\r'  ||  c  =  =  '\n'  ||  c  =  =  delim  ||  c  =  =  escape  )  {    if  (  pos  >  start  )  {  out  .  append  (  value  ,  start  ,  pos  )  ;  }  if  (  c  =  =  '\n'  )  {  c  =  'n'  ;  }  else  if  (  c  =  =  '\r'  )  {  c  =  'r'  ;  }  out  .  append  (  escape  )  ;  out  .  append  (  c  )  ;    start  =  pos  +  1  ;  //  start  on  the  current  char  after  this  one  }  pos++  ;  }    if  (  pos  >  start  )  {  out  .  append  (  value  ,  start  ,  pos  )  ;  }  }    [METHOD]  printAndEscape  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  escape  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  newLine  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out  
[REPLACE]  while  (  pos  <  end  )  {	[BUGGY]  while  (  pos    =  =    end  )  {[FE]  (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo\n "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "foo\n  baar  ,  ,  ,   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "\n\t  \n "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  void  printAndEscape  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  escape  =  format  .  getEscape  (  )  ;    [ATTENTION]  while  (  pos  =  =  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\r'  ||  c  =  =  '\n'  ||  c  =  =  delim  ||  c  =  =  escape  )  {    if  (  pos  >  start  )  {  out  .  append  (  value  ,  start  ,  pos  )  ;  }  if  (  c  =  =  '\n'  )  {  c  =  'n'  ;  }  else  if  (  c  =  =  '\r'  )  {  c  =  'r'  ;  }  out  .  append  (  escape  )  ;  out  .  append  (  c  )  ;    start  =  pos  +  1  ;  //  start  on  the  current  char  after  this  one  }  pos++  ;  }    if  (  pos  >  start  )  {  out  .  append  (  value  ,  start  ,  pos  )  ;  }  }    [METHOD]  printAndEscape  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  escape  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  newLine  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out  
[ADD]  while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;	[BUGGY]  [CE]  illegal  start  of  type  [CONTEXT]  void  printAndEscape  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  escape  =  format  .  getEscape  (  )  ;    [ATTENTION]    if  (  c  =  =  '\r'  ||  c  =  =  '\n'  ||  c  =  =  delim  ||  c  =  =  escape  )  {    if  (  pos  >  start  )  {  out  .  append  (  value  ,  start  ,  pos  )  ;  }  if  (  c  =  =  '\n'  )  {  c  =  'n'  ;  }  else  if  (  c  =  =  '\r'  )  {  c  =  'r'  ;  }  out  .  append  (  escape  )  ;  out  .  append  (  c  )  ;    start  =  pos  +  1  ;  //  start  on  the  current  char  after  this  one  }  pos++  ;  }    if  (  pos  >  start  )  {  out  .  append  (  value  ,  start  ,  pos  )  ;  }  }    [METHOD]  printAndEscape  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  escape  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  newLine  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out  
[REPLACE]  if  (  c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape  )  {	[BUGGY]  if  (  c  =  =  '\n'  &&  c  =  =  delim  &&true  )  {[FE]  (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo\n "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "foo\n  baar  ,  ,  ,   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "\n\t  \n "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  void  printAndEscape  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  escape  =  format  .  getEscape  (  )  ;    while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  [ATTENTION]  if  (  c  =  =  '\n'  &&  c  =  =  delim  &&true  )  {    if  (  pos  >  start  )  {  out  .  append  (  value  ,  start  ,  pos  )  ;  }  if  (  c  =  =  '\n'  )  {  c  =  'n'  ;  }  else  if  (  c  =  =  '\r'  )  {  c  =  'r'  ;  }  out  .  append  (  escape  )  ;  out  .  append  (  c  )  ;    start  =  pos  +  1  ;  //  start  on  the  current  char  after  this  one  }  pos++  ;  }    if  (  pos  >  start  )  {  out  .  append  (  value  ,  start  ,  pos  )  ;  }  }    [METHOD]  printAndEscape  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  escape  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  newLine  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out  
[REPLACE]  if  (  pos  >  start  )  {	[BUGGY]  if  (  pos  <  offset  )  {[FE]  (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo\n "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "foo\n  baar  ,  ,  ,   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "\n\t  \n "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  void  printAndEscape  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  escape  =  format  .  getEscape  (  )  ;    while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\r'  ||  c  =  =  '\n'  ||  c  =  =  delim  ||  c  =  =  escape  )  {    [ATTENTION]  if  (  pos<  offset  )  {  out  .  append  (  value  ,  start  ,  pos  )  ;  }  if  (  c  =  =  '\n'  )  {  c  =  'n'  ;  }  else  if  (  c  =  =  '\r'  )  {  c  =  'r'  ;  }  out  .  append  (  escape  )  ;  out  .  append  (  c  )  ;    start  =  pos  +  1  ;  //  start  on  the  current  char  after  this  one  }  pos++  ;  }    if  (  pos  >  start  )  {  out  .  append  (  value  ,  start  ,  pos  )  ;  }  }    [METHOD]  printAndEscape  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  escape  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  newLine  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out  
[REPLACE]  out  .  append  (  value,  start,  pos  )  ;	[BUGGY]  out  .  append  (  value  )    ;  [FE]  (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo\n "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "foo\n  baar  ,  ,  ,   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "\n\t  \n "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  void  printAndEscape  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  escape  =  format  .  getEscape  (  )  ;    while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\r'  ||  c  =  =  '\n'  ||  c  =  =  delim  ||  c  =  =  escape  )  {    if  (  pos  >  start  )  {  [ATTENTION]  out  .  append  (  value  )  ;  }  if  (  c  =  =  '\n'  )  {  c  =  'n'  ;  }  else  if  (  c  =  =  '\r'  )  {  c  =  'r'  ;  }  out  .  append  (  escape  )  ;  out  .  append  (  c  )  ;    start  =  pos  +  1  ;  //  start  on  the  current  char  after  this  one  }  pos++  ;  }    if  (  pos  >  start  )  {  out  .  append  (  value  ,  start  ,  pos  )  ;  }  }    [METHOD]  printAndEscape  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  escape  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  newLine  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out  
[ADD]  out  .  append  (  value,  start,  pos  )  ;	[BUGGY]  [FE]  (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo\n "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "foo\n  baar  ,  ,  ,   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "\n\t  \n "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  void  printAndEscape  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  escape  =  format  .  getEscape  (  )  ;    while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\r'  ||  c  =  =  '\n'  ||  c  =  =  delim  ||  c  =  =  escape  )  {    if  (  pos  >  start  )  {  [ATTENTION]  }  if  (  c  =  =  '\n'  )  {  c  =  'n'  ;  }  else  if  (  c  =  =  '\r'  )  {  c  =  'r'  ;  }  out  .  append  (  escape  )  ;  out  .  append  (  c  )  ;    start  =  pos  +  1  ;  //  start  on  the  current  char  after  this  one  }  pos++  ;  }    if  (  pos  >  start  )  {  out  .  append  (  value  ,  start  ,  pos  )  ;  }  }    [METHOD]  printAndEscape  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  escape  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  newLine  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out  
[REPLACE]  if  (  c  ==  '\n'  )  {	[BUGGY]  if  (  c  ||  '\n'  )  {[CE]  bad  operand  types  for  binary  operator  '||'  [CONTEXT]  void  printAndEscape  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  escape  =  format  .  getEscape  (  )  ;    while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\r'  ||  c  =  =  '\n'  ||  c  =  =  delim  ||  c  =  =  escape  )  {    if  (  pos  >  start  )  {  out  .  append  (  value  ,  start  ,  pos  )  ;  }  [ATTENTION]  if  (  c||'\n'  )  {  c  =  'n'  ;  }  else  if  (  c  =  =  '\r'  )  {  c  =  'r'  ;  }  out  .  append  (  escape  )  ;  out  .  append  (  c  )  ;    start  =  pos  +  1  ;  //  start  on  the  current  char  after  this  one  }  pos++  ;  }    if  (  pos  >  start  )  {  out  .  append  (  value  ,  start  ,  pos  )  ;  }  }    [METHOD]  printAndEscape  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  escape  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  newLine  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out  
[ADD]  if  (  c  ==  '\n'  )  {  c  =  'n';  }  else  if  (  c  ==  '\r'  )  {  c  =  'r';  }	[BUGGY]  c  =  'n'  ;  c  =  'r'  ;  [FE]  (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo\n "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "foo\n  baar  ,  ,  ,   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "\n\t  \n "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  void  printAndEscape  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  escape  =  format  .  getEscape  (  )  ;    while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\r'  ||  c  =  =  '\n'  ||  c  =  =  delim  ||  c  =  =  escape  )  {    if  (  pos  >  start  )  {  out  .  append  (  value  ,  start  ,  pos  )  ;  }  [ATTENTION]  c  =  'n'  ;  c  =  'r'  ;        out  .  append  (  escape  )  ;  out  .  append  (  c  )  ;    start  =  pos  +  1  ;  //  start  on  the  current  char  after  this  one  }  pos++  ;  }    if  (  pos  >  start  )  {  out  .  append  (  value  ,  start  ,  pos  )  ;  }  }    [METHOD]  printAndEscape  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  escape  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  newLine  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out  
[REPLACE]  }  else  if  (  c  ==  '\r'  )  {	[BUGGY]    if  (  c  ||  '\r'  )  {[CE]  bad  operand  types  for  binary  operator  '||'  [CONTEXT]  void  printAndEscape  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  escape  =  format  .  getEscape  (  )  ;    while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\r'  ||  c  =  =  '\n'  ||  c  =  =  delim  ||  c  =  =  escape  )  {    if  (  pos  >  start  )  {  out  .  append  (  value  ,  start  ,  pos  )  ;  }  if  (  c  =  =  '\n'  )  {  c  =  'n'  ;  [ATTENTION]  }if  (  c||'\r'  )  {  c  =  'r'  ;  }  out  .  append  (  escape  )  ;  out  .  append  (  c  )  ;    start  =  pos  +  1  ;  //  start  on  the  current  char  after  this  one  }  pos++  ;  }    if  (  pos  >  start  )  {  out  .  append  (  value  ,  start  ,  pos  )  ;  }  }    [METHOD]  printAndEscape  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  escape  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  newLine  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out  
[REPLACE]  c  =  'r';	[BUGGY]  c  =  'n'  ;    ;  [FE]  (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo\n "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "foo\n  baar  ,  ,  ,   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "\n\t  \n "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  void  printAndEscape  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  escape  =  format  .  getEscape  (  )  ;    while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\r'  ||  c  =  =  '\n'  ||  c  =  =  delim  ||  c  =  =  escape  )  {    if  (  pos  >  start  )  {  out  .  append  (  value  ,  start  ,  pos  )  ;  }  if  (  c  =  =  '\n'  )  {  c  =  'n'  ;  }  else  if  (  c  =  =  '\r'  )  {  [ATTENTION]  c  =  'n'  ;    ;  }  out  .  append  (  escape  )  ;  out  .  append  (  c  )  ;    start  =  pos  +  1  ;  //  start  on  the  current  char  after  this  one  }  pos++  ;  }    if  (  pos  >  start  )  {  out  .  append  (  value  ,  start  ,  pos  )  ;  }  }    [METHOD]  printAndEscape  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  escape  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  newLine  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out  
[REPLACE]  c  =  'n';	[BUGGY]  c  =  'r'  ;    ;  [FE]  (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo\n "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "foo\n  baar  ,  ,  ,   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "\n\t  \n "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  void  printAndEscape  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  escape  =  format  .  getEscape  (  )  ;    while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\r'  ||  c  =  =  '\n'  ||  c  =  =  delim  ||  c  =  =  escape  )  {    if  (  pos  >  start  )  {  out  .  append  (  value  ,  start  ,  pos  )  ;  }  if  (  c  =  =  '\n'  )  {  [ATTENTION]  c  =  'r'  ;    ;  }  else  if  (  c  =  =  '\r'  )  {  c  =  'r'  ;  }  out  .  append  (  escape  )  ;  out  .  append  (  c  )  ;    start  =  pos  +  1  ;  //  start  on  the  current  char  after  this  one  }  pos++  ;  }    if  (  pos  >  start  )  {  out  .  append  (  value  ,  start  ,  pos  )  ;  }  }    [METHOD]  printAndEscape  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  escape  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  newLine  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out  
[REPLACE]  }  else  if  (  c  ==  '\r'  )  {	[BUGGY]    else  {[FE]  (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo\n "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "foo\n  baar  ,  ,  ,   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "\n\t  \n "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  void  printAndEscape  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  escape  =  format  .  getEscape  (  )  ;    while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\r'  ||  c  =  =  '\n'  ||  c  =  =  delim  ||  c  =  =  escape  )  {    if  (  pos  >  start  )  {  out  .  append  (  value  ,  start  ,  pos  )  ;  }  if  (  c  =  =  '\n'  )  {  c  =  'n'  ;  [ATTENTION]  }else  {  c  =  'r'  ;  }  out  .  append  (  escape  )  ;  out  .  append  (  c  )  ;    start  =  pos  +  1  ;  //  start  on  the  current  char  after  this  one  }  pos++  ;  }    if  (  pos  >  start  )  {  out  .  append  (  value  ,  start  ,  pos  )  ;  }  }    [METHOD]  printAndEscape  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  escape  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  newLine  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out  
[REPLACE]  start  =  pos  +  1;	[BUGGY]  start  =  pos  !  =    2  ;  [CE]  incompatible  types  [CONTEXT]  void  printAndEscape  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  escape  =  format  .  getEscape  (  )  ;    while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\r'  ||  c  =  =  '\n'  ||  c  =  =  delim  ||  c  =  =  escape  )  {    if  (  pos  >  start  )  {  out  .  append  (  value  ,  start  ,  pos  )  ;  }  if  (  c  =  =  '\n'  )  {  c  =  'n'  ;  }  else  if  (  c  =  =  '\r'  )  {  c  =  'r'  ;  }  out  .  append  (  escape  )  ;  out  .  append  (  c  )  ;    [ATTENTION]  start  =  pos!  =  2  ;  }  pos++  ;  }    if  (  pos  >  start  )  {  out  .  append  (  value  ,  start  ,  pos  )  ;  }  }    [METHOD]  printAndEscape  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  escape  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  newLine  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out  
[REPLACE]  if  (  pos  >  start  )  {	[BUGGY]  if  (  pos  >  =  offset  )  {[FE]  (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo\n "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "foo\n  baar  ,  ,  ,   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "\n\t  \n "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  void  printAndEscape  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  escape  =  format  .  getEscape  (  )  ;    while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\r'  ||  c  =  =  '\n'  ||  c  =  =  delim  ||  c  =  =  escape  )  {    [ATTENTION]  if  (  pos>  =  offset  )  {  out  .  append  (  value  ,  start  ,  pos  )  ;  }  if  (  c  =  =  '\n'  )  {  c  =  'n'  ;  }  else  if  (  c  =  =  '\r'  )  {  c  =  'r'  ;  }  out  .  append  (  escape  )  ;  out  .  append  (  c  )  ;    start  =  pos  +  1  ;  //  start  on  the  current  char  after  this  one  }  pos++  ;  }    if  (  pos  >  start  )  {  out  .  append  (  value  ,  start  ,  pos  )  ;  }  }    [METHOD]  printAndEscape  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  escape  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  newLine  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out  
[REPLACE]  out  .  append  (  value,  start,  pos  )  ;	[BUGGY]  out  .  append  (  value  ,  offset  ,  pos  )  ;  [FE]  (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo\n "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "foo\n  baar  ,  ,  ,   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "\n\t  \n "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  void  printAndEscape  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  escape  =  format  .  getEscape  (  )  ;    while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\r'  ||  c  =  =  '\n'  ||  c  =  =  delim  ||  c  =  =  escape  )  {    if  (  pos  >  start  )  {  [ATTENTION]  out  .  append  (  value  ,  offset  ,  pos  )    ;  }  if  (  c  =  =  '\n'  )  {  c  =  'n'  ;  }  else  if  (  c  =  =  '\r'  )  {  c  =  'r'  ;  }  out  .  append  (  escape  )  ;  out  .  append  (  c  )  ;    start  =  pos  +  1  ;  //  start  on  the  current  char  after  this  one  }  pos++  ;  }    if  (  pos  >  start  )  {  out  .  append  (  value  ,  start  ,  pos  )  ;  }  }    [METHOD]  printAndEscape  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  escape  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  newLine  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out  
[ADD]  if  (  c  ==  '\n'  )  {  c  =  'n';  }  else  if  (  c  ==  '\r'  )  {  c  =  'r';  }	[BUGGY]  [FE]  (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo\n "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "foo\n  baar  ,  ,  ,   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "\n\t  \n "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  void  printAndEscape  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  escape  =  format  .  getEscape  (  )  ;    while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\r'  ||  c  =  =  '\n'  ||  c  =  =  delim  ||  c  =  =  escape  )  {    if  (  pos  >  start  )  {  out  .  append  (  value  ,  start  ,  pos  )  ;  }  [ATTENTION]        out  .  append  (  escape  )  ;  out  .  append  (  c  )  ;    start  =  pos  +  1  ;  //  start  on  the  current  char  after  this  one  }  pos++  ;  }    if  (  pos  >  start  )  {  out  .  append  (  value  ,  start  ,  pos  )  ;  }  }    [METHOD]  printAndEscape  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  escape  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  newLine  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out  
[ADD]  else  if  (  c  ==  '\r'  )  {  c  =  'r';  }	[BUGGY]    c  =  'r'  ;  [FE]  (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo\n "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "foo\n  baar  ,  ,  ,   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "\n\t  \n "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  void  printAndEscape  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  escape  =  format  .  getEscape  (  )  ;    while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\r'  ||  c  =  =  '\n'  ||  c  =  =  delim  ||  c  =  =  escape  )  {    if  (  pos  >  start  )  {  out  .  append  (  value  ,  start  ,  pos  )  ;  }  if  (  c  =  =  '\n'  )  {  c  =  'n'  ;  [ATTENTION]  }  c  =  'r'  ;      out  .  append  (  escape  )  ;  out  .  append  (  c  )  ;    start  =  pos  +  1  ;  //  start  on  the  current  char  after  this  one  }  pos++  ;  }    if  (  pos  >  start  )  {  out  .  append  (  value  ,  start  ,  pos  )  ;  }  }    [METHOD]  printAndEscape  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  escape  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  newLine  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out  
[ADD]  c  =  'r';	[BUGGY]  [FE]  (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo\n "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "foo\n  baar  ,  ,  ,   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "\n\t  \n "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  void  printAndEscape  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  escape  =  format  .  getEscape  (  )  ;    while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\r'  ||  c  =  =  '\n'  ||  c  =  =  delim  ||  c  =  =  escape  )  {    if  (  pos  >  start  )  {  out  .  append  (  value  ,  start  ,  pos  )  ;  }  if  (  c  =  =  '\n'  )  {  c  =  'n'  ;  }  else  if  (  c  =  =  '\r'  )  {  [ATTENTION]  }  out  .  append  (  escape  )  ;  out  .  append  (  c  )  ;    start  =  pos  +  1  ;  //  start  on  the  current  char  after  this  one  }  pos++  ;  }    if  (  pos  >  start  )  {  out  .  append  (  value  ,  start  ,  pos  )  ;  }  }    [METHOD]  printAndEscape  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  escape  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  newLine  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out  
[REPLACE]  }  else  if  (  c  ==  '\r'  )  {	[BUGGY]  else  if  (  c  &&  '\r'  )  {[CE]  bad  operand  types  for  binary  operator  '&&'  [CONTEXT]  void  printAndEscape  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  escape  =  format  .  getEscape  (  )  ;    while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\r'  ||  c  =  =  '\n'  ||  c  =  =  delim  ||  c  =  =  escape  )  {    if  (  pos  >  start  )  {  out  .  append  (  value  ,  start  ,  pos  )  ;  }  if  (  c  =  =  '\n'  )  {  c  =  'n'  ;  [ATTENTION]  }  else  if  (  c&&'\r'  )  {  c  =  'r'  ;  }  out  .  append  (  escape  )  ;  out  .  append  (  c  )  ;    start  =  pos  +  1  ;  //  start  on  the  current  char  after  this  one  }  pos++  ;  }    if  (  pos  >  start  )  {  out  .  append  (  value  ,  start  ,  pos  )  ;  }  }    [METHOD]  printAndEscape  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  escape  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  newLine  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out  
[REPLACE]  start  =  pos  +  1;	[BUGGY]  start  =  offset  +  1  ;  [FE]  (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo\n "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "foo\n  baar  ,  ,  ,   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "\n\t  \n "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  void  printAndEscape  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  escape  =  format  .  getEscape  (  )  ;    while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\r'  ||  c  =  =  '\n'  ||  c  =  =  delim  ||  c  =  =  escape  )  {    if  (  pos  >  start  )  {  out  .  append  (  value  ,  start  ,  pos  )  ;  }  if  (  c  =  =  '\n'  )  {  c  =  'n'  ;  }  else  if  (  c  =  =  '\r'  )  {  c  =  'r'  ;  }  out  .  append  (  escape  )  ;  out  .  append  (  c  )  ;    [ATTENTION]  start  =  offset  +  1  ;  }  pos++  ;  }    if  (  pos  >  start  )  {  out  .  append  (  value  ,  start  ,  pos  )  ;  }  }    [METHOD]  printAndEscape  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  escape  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  newLine  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out  
[REPLACE]  char  c  =  value  .  charAt  (  pos  )  ;	[BUGGY]  char  c  =  value  .  charAt  (  offset  )  ;  [FE]  (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo\n "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "foo\n  baar  ,  ,  ,   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "\n\t  \n "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  void  printAndEscape  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  escape  =  format  .  getEscape  (  )  ;    while  (  pos  <  end  )  {  [ATTENTION]  char  c  =  value  .  charAt  (  offset  )    ;  if  (  c  =  =  '\r'  ||  c  =  =  '\n'  ||  c  =  =  delim  ||  c  =  =  escape  )  {    if  (  pos  >  start  )  {  out  .  append  (  value  ,  start  ,  pos  )  ;  }  if  (  c  =  =  '\n'  )  {  c  =  'n'  ;  }  else  if  (  c  =  =  '\r'  )  {  c  =  'r'  ;  }  out  .  append  (  escape  )  ;  out  .  append  (  c  )  ;    start  =  pos  +  1  ;  //  start  on  the  current  char  after  this  one  }  pos++  ;  }    if  (  pos  >  start  )  {  out  .  append  (  value  ,  start  ,  pos  )  ;  }  }    [METHOD]  printAndEscape  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  escape  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  newLine  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out  
[REPLACE]  if  (  c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape  )  {	[BUGGY]  if  (  c  =  =  '\r'  )  {[FE]  (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo\n "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "foo\n  baar  ,  ,  ,   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "\n\t  \n "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  void  printAndEscape  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  escape  =  format  .  getEscape  (  )  ;    while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  [ATTENTION]  if  (  c  =  =  '\r'  )  {    if  (  pos  >  start  )  {  out  .  append  (  value  ,  start  ,  pos  )  ;  }  if  (  c  =  =  '\n'  )  {  c  =  'n'  ;  }  else  if  (  c  =  =  '\r'  )  {  c  =  'r'  ;  }  out  .  append  (  escape  )  ;  out  .  append  (  c  )  ;    start  =  pos  +  1  ;  //  start  on  the  current  char  after  this  one  }  pos++  ;  }    if  (  pos  >  start  )  {  out  .  append  (  value  ,  start  ,  pos  )  ;  }  }    [METHOD]  printAndEscape  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  escape  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  newLine  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out  
[ADD]  if  (  c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape  )  {  if  (  pos  >  start  )  {  out  .  append  (  value,  start,  pos  )  ;  }	[BUGGY]  [CE]  illegal  start  of  type  [CONTEXT]  void  printAndEscape  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  escape  =  format  .  getEscape  (  )  ;    while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  [ATTENTION]      if  (  c  =  =  '\n'  )  {  c  =  'n'  ;  }  else  if  (  c  =  =  '\r'  )  {  c  =  'r'  ;  }  out  .  append  (  escape  )  ;  out  .  append  (  c  )  ;    start  =  pos  +  1  ;  //  start  on  the  current  char  after  this  one  }  pos++  ;  }    if  (  pos  >  start  )  {  out  .  append  (  value  ,  start  ,  pos  )  ;  }  }    [METHOD]  printAndEscape  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  escape  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  newLine  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out  
[REPLACE]  if  (  pos  >  start  )  {	[BUGGY]  if  (  pos  <  start  )  {[FE]  (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo\n "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "foo\n  baar  ,  ,  ,   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "\n\t  \n "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  void  printAndEscape  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  escape  =  format  .  getEscape  (  )  ;    while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\r'  ||  c  =  =  '\n'  ||  c  =  =  delim  ||  c  =  =  escape  )  {    [ATTENTION]  if  (  pos<start  )  {  out  .  append  (  value  ,  start  ,  pos  )  ;  }  if  (  c  =  =  '\n'  )  {  c  =  'n'  ;  }  else  if  (  c  =  =  '\r'  )  {  c  =  'r'  ;  }  out  .  append  (  escape  )  ;  out  .  append  (  c  )  ;    start  =  pos  +  1  ;  //  start  on  the  current  char  after  this  one  }  pos++  ;  }    if  (  pos  >  start  )  {  out  .  append  (  value  ,  start  ,  pos  )  ;  }  }    [METHOD]  printAndEscape  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  escape  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  newLine  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out  
[REMOVE]  	[BUGGY]  if  (  c  =  =  encapsulator  )  {      out  .  append  (  value  ,  start  ,    (  pos  +  1  )  )  ;      start  =  pos  ;  }[CE]  cannot  find  symbol  encapsulator  [CONTEXT]  void  printAndEscape  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  escape  =  format  .  getEscape  (  )  ;    while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\r'  ||  c  =  =  '\n'  ||  c  =  =  delim  ||  c  =  =  escape  )  {    [ATTENTION]  if  (  pos  >  start  )  {  if  (  c  =  =  encapsulator  )  {  out  .  append  (  value  ,  start  ,  (  pos  +  1  )  )    ;  start  =  pos  ;  }out  .  append  (  value  ,  start  ,  pos  )  ;  }  if  (  c  =  =  '\n'  )  {  c  =  'n'  ;  }  else  if  (  c  =  =  '\r'  )  {  c  =  'r'  ;  }  out  .  append  (  escape  )  ;  out  .  append  (  c  )  ;    start  =  pos  +  1  ;  //  start  on  the  current  char  after  this  one  }  pos++  ;  }    if  (  pos  >  start  )  {  out  .  append  (  value  ,  start  ,  pos  )  ;  }    [METHOD]  printAndEscape  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  escape  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  newLine  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out  
[REPLACE]  if  (  c  ==  '\n'  )  {	[BUGGY]  if  (  escape  !  =    '\n'  )  {[FE]  (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo\n "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "foo\n  baar  ,  ,  ,   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "\n\t  \n "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  void  printAndEscape  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  escape  =  format  .  getEscape  (  )  ;    while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\r'  ||  c  =  =  '\n'  ||  c  =  =  delim  ||  c  =  =  escape  )  {    if  (  pos  >  start  )  {  out  .  append  (  value  ,  start  ,  pos  )  ;  }  [ATTENTION]  if  (  escape!  =  '\n'  )  {  c  =  'n'  ;  }  else  if  (  c  =  =  '\r'  )  {  c  =  'r'  ;  }  out  .  append  (  escape  )  ;  out  .  append  (  c  )  ;    start  =  pos  +  1  ;  //  start  on  the  current  char  after  this  one  }  pos++  ;  }    if  (  pos  >  start  )  {  out  .  append  (  value  ,  start  ,  pos  )  ;  }  }    [METHOD]  printAndEscape  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  escape  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  newLine  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out  
[ADD]  c  =  'n';	[BUGGY]  [FE]  (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo\n "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "foo\n  baar  ,  ,  ,   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "\n\t  \n "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  void  printAndEscape  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  escape  =  format  .  getEscape  (  )  ;    while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\r'  ||  c  =  =  '\n'  ||  c  =  =  delim  ||  c  =  =  escape  )  {    if  (  pos  >  start  )  {  out  .  append  (  value  ,  start  ,  pos  )  ;  }  if  (  c  =  =  '\n'  )  {  [ATTENTION]  }  else  if  (  c  =  =  '\r'  )  {  c  =  'r'  ;  }  out  .  append  (  escape  )  ;  out  .  append  (  c  )  ;    start  =  pos  +  1  ;  //  start  on  the  current  char  after  this  one  }  pos++  ;  }    if  (  pos  >  start  )  {  out  .  append  (  value  ,  start  ,  pos  )  ;  }  }    [METHOD]  printAndEscape  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  escape  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  newLine  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out  
[REPLACE]  start  =  pos  +  1;	[BUGGY]  start  =  pos  +offset  ;  [FE]  (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo\n "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "foo\n  baar  ,  ,  ,   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "\n\t  \n "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  void  printAndEscape  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  escape  =  format  .  getEscape  (  )  ;    while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\r'  ||  c  =  =  '\n'  ||  c  =  =  delim  ||  c  =  =  escape  )  {    if  (  pos  >  start  )  {  out  .  append  (  value  ,  start  ,  pos  )  ;  }  if  (  c  =  =  '\n'  )  {  c  =  'n'  ;  }  else  if  (  c  =  =  '\r'  )  {  c  =  'r'  ;  }  out  .  append  (  escape  )  ;  out  .  append  (  c  )  ;    [ATTENTION]  start  =  pos  +offset  ;  }  pos++  ;  }    if  (  pos  >  start  )  {  out  .  append  (  value  ,  start  ,  pos  )  ;  }  }    [METHOD]  printAndEscape  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  escape  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  newLine  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out  
[REPLACE]  if  (  pos  >  start  )  {	[BUGGY]  if  (  pos    =  =    start  )  {[FE]  (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo\n "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "foo\n  baar  ,  ,  ,   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "\n\t  \n "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  void  printAndEscape  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  escape  =  format  .  getEscape  (  )  ;    while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\r'  ||  c  =  =  '\n'  ||  c  =  =  delim  ||  c  =  =  escape  )  {    [ATTENTION]  if  (  pos  =  =  start  )  {  out  .  append  (  value  ,  start  ,  pos  )  ;  }  if  (  c  =  =  '\n'  )  {  c  =  'n'  ;  }  else  if  (  c  =  =  '\r'  )  {  c  =  'r'  ;  }  out  .  append  (  escape  )  ;  out  .  append  (  c  )  ;    start  =  pos  +  1  ;  //  start  on  the  current  char  after  this  one  }  pos++  ;  }    if  (  pos  >  start  )  {  out  .  append  (  value  ,  start  ,  pos  )  ;  }  }    [METHOD]  printAndEscape  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  escape  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  newLine  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out  
[REPLACE]  out  .  append  (  value,  start,  pos  )  ;	[BUGGY]  out  .  append  (  value  ,  start  ,  offset  )  ;  [FE]  (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo\n "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "foo\n  baar  ,  ,  ,   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "\n\t  \n "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  void  printAndEscape  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  escape  =  format  .  getEscape  (  )  ;    while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\r'  ||  c  =  =  '\n'  ||  c  =  =  delim  ||  c  =  =  escape  )  {    if  (  pos  >  start  )  {  [ATTENTION]  out  .  append  (  value  ,  start  ,  offset  )    ;  }  if  (  c  =  =  '\n'  )  {  c  =  'n'  ;  }  else  if  (  c  =  =  '\r'  )  {  c  =  'r'  ;  }  out  .  append  (  escape  )  ;  out  .  append  (  c  )  ;    start  =  pos  +  1  ;  //  start  on  the  current  char  after  this  one  }  pos++  ;  }    if  (  pos  >  start  )  {  out  .  append  (  value  ,  start  ,  pos  )  ;  }  }    [METHOD]  printAndEscape  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  escape  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  newLine  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out  
[REPLACE]  if  (  c  ==  '\n'  )  {	[BUGGY]  if  (escape  ||  '\n'  )  {[CE]  bad  operand  types  for  binary  operator  '||'  [CONTEXT]  void  printAndEscape  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  escape  =  format  .  getEscape  (  )  ;    while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\r'  ||  c  =  =  '\n'  ||  c  =  =  delim  ||  c  =  =  escape  )  {    if  (  pos  >  start  )  {  out  .  append  (  value  ,  start  ,  pos  )  ;  }  [ATTENTION]  if  (  escape||'\n'  )  {  c  =  'n'  ;  }  else  if  (  c  =  =  '\r'  )  {  c  =  'r'  ;  }  out  .  append  (  escape  )  ;  out  .  append  (  c  )  ;    start  =  pos  +  1  ;  //  start  on  the  current  char  after  this  one  }  pos++  ;  }    if  (  pos  >  start  )  {  out  .  append  (  value  ,  start  ,  pos  )  ;  }  }    [METHOD]  printAndEscape  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  escape  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  newLine  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out  
[REPLACE]  }  else  if  (  c  ==  '\r'  )  {	[BUGGY]    if  (escape  !  =    '\r'  )  {[FE]  (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo\n "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "foo\n  baar  ,  ,  ,   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "\n\t  \n "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  void  printAndEscape  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  escape  =  format  .  getEscape  (  )  ;    while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\r'  ||  c  =  =  '\n'  ||  c  =  =  delim  ||  c  =  =  escape  )  {    if  (  pos  >  start  )  {  out  .  append  (  value  ,  start  ,  pos  )  ;  }  if  (  c  =  =  '\n'  )  {  c  =  'n'  ;  [ATTENTION]  }if  (  escape!  =  '\r'  )  {  c  =  'r'  ;  }  out  .  append  (  escape  )  ;  out  .  append  (  c  )  ;    start  =  pos  +  1  ;  //  start  on  the  current  char  after  this  one  }  pos++  ;  }    if  (  pos  >  start  )  {  out  .  append  (  value  ,  start  ,  pos  )  ;  }  }    [METHOD]  printAndEscape  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  escape  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  newLine  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out  
[REPLACE]  start  =  pos  +  1;	[BUGGY]  start  =  pos  ;    ;  [FE]  (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo\n "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "foo\n  baar  ,  ,  ,   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "\n\t  \n "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  void  printAndEscape  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  escape  =  format  .  getEscape  (  )  ;    while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\r'  ||  c  =  =  '\n'  ||  c  =  =  delim  ||  c  =  =  escape  )  {    if  (  pos  >  start  )  {  out  .  append  (  value  ,  start  ,  pos  )  ;  }  if  (  c  =  =  '\n'  )  {  c  =  'n'  ;  }  else  if  (  c  =  =  '\r'  )  {  c  =  'r'  ;  }  out  .  append  (  escape  )  ;  out  .  append  (  c  )  ;    [ATTENTION]  start  =  pos  ;    ;  }  pos++  ;  }    if  (  pos  >  start  )  {  out  .  append  (  value  ,  start  ,  pos  )  ;  }  }    [METHOD]  printAndEscape  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  escape  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  newLine  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out  
[REPLACE]  char  c  =  value  .  charAt  (  pos  )  ;	[BUGGY]  for  (  String  value  :  values  )  {  print  (  value  )  ;  [CE]  illegal  start  of  expression  [CONTEXT]  void  printAndEscape  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  escape  =  format  .  getEscape  (  )  ;    while  (  pos  <  end  )  {  [ATTENTION]  for  (  String  value  :  values  )  {  print  (  value  )    ;  if  (  c  =  =  '\r'  ||  c  =  =  '\n'  ||  c  =  =  delim  ||  c  =  =  escape  )  {    if  (  pos  >  start  )  {  out  .  append  (  value  ,  start  ,  pos  )  ;  }  if  (  c  =  =  '\n'  )  {  c  =  'n'  ;  }  else  if  (  c  =  =  '\r'  )  {  c  =  'r'  ;  }  out  .  append  (  escape  )  ;  out  .  append  (  c  )  ;    start  =  pos  +  1  ;  //  start  on  the  current  char  after  this  one  }  pos++  ;  }    if  (  pos  >  start  )  {  out  .  append  (  value  ,  start  ,  pos  )  ;  }  }    [METHOD]  printAndEscape  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  escape  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  newLine  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out  
[ADD]  char  c  =  value  .  charAt  (  pos  )  ;	[BUGGY]  [CE]  cannot  find  symbol  c  [CONTEXT]  void  printAndEscape  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  escape  =  format  .  getEscape  (  )  ;    while  (  pos  <  end  )  {  [ATTENTION]  if  (  c  =  =  '\r'  ||  c  =  =  '\n'  ||  c  =  =  delim  ||  c  =  =  escape  )  {    if  (  pos  >  start  )  {  out  .  append  (  value  ,  start  ,  pos  )  ;  }  if  (  c  =  =  '\n'  )  {  c  =  'n'  ;  }  else  if  (  c  =  =  '\r'  )  {  c  =  'r'  ;  }  out  .  append  (  escape  )  ;  out  .  append  (  c  )  ;    start  =  pos  +  1  ;  //  start  on  the  current  char  after  this  one  }  pos++  ;  }    if  (  pos  >  start  )  {  out  .  append  (  value  ,  start  ,  pos  )  ;  }  }    [METHOD]  printAndEscape  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  escape  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  newLine  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out  
[REPLACE]  if  (  pos  >  start  )  {	[BUGGY]  if  (offset    =  =    start  )  {[FE]  (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo\n "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "foo\n  baar  ,  ,  ,   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "\n\t  \n "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  void  printAndEscape  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  escape  =  format  .  getEscape  (  )  ;    while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\r'  ||  c  =  =  '\n'  ||  c  =  =  delim  ||  c  =  =  escape  )  {    if  (  pos  >  start  )  {  out  .  append  (  value  ,  start  ,  pos  )  ;  }  if  (  c  =  =  '\n'  )  {  c  =  'n'  ;  }  else  if  (  c  =  =  '\r'  )  {  c  =  'r'  ;  }  out  .  append  (  escape  )  ;  out  .  append  (  c  )  ;    start  =  pos  +  1  ;  //  start  on  the  current  char  after  this  one  }  pos++  ;  }    [ATTENTION]  if  (  offset  =  =  start  )  {  out  .  append  (  value  ,  start  ,  pos  )  ;  }  }    [METHOD]  printAndEscape  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  escape  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  newLine  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out  
[REPLACE]  out  .  append  (  value,  start,  pos  )  ;	[BUGGY]  out  .  append  (  value  ,  start  ,  end  )  ;  [FE]  (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo\n "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "foo\n  baar  ,  ,  ,   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "\n\t  \n "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  void  printAndEscape  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  escape  =  format  .  getEscape  (  )  ;    while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\r'  ||  c  =  =  '\n'  ||  c  =  =  delim  ||  c  =  =  escape  )  {    if  (  pos  >  start  )  {  out  .  append  (  value  ,  start  ,  pos  )  ;  }  if  (  c  =  =  '\n'  )  {  c  =  'n'  ;  }  else  if  (  c  =  =  '\r'  )  {  c  =  'r'  ;  }  out  .  append  (  escape  )  ;  out  .  append  (  c  )  ;    start  =  pos  +  1  ;  //  start  on  the  current  char  after  this  one  }  pos++  ;  }    if  (  pos  >  start  )  {  [ATTENTION]  out  .  append  (  value  ,  start  ,  end  )    ;  }  }    [METHOD]  printAndEscape  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  escape  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  newLine  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out  
[ADD]  out  .  append  (  value,  start,  pos  )  ;	[BUGGY]  [FE]  (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo\n "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "foo\n  baar  ,  ,  ,   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "\n\t  \n "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  void  printAndEscape  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  escape  =  format  .  getEscape  (  )  ;    while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\r'  ||  c  =  =  '\n'  ||  c  =  =  delim  ||  c  =  =  escape  )  {    if  (  pos  >  start  )  {  out  .  append  (  value  ,  start  ,  pos  )  ;  }  if  (  c  =  =  '\n'  )  {  c  =  'n'  ;  }  else  if  (  c  =  =  '\r'  )  {  c  =  'r'  ;  }  out  .  append  (  escape  )  ;  out  .  append  (  c  )  ;    start  =  pos  +  1  ;  //  start  on  the  current  char  after  this  one  }  pos++  ;  }    if  (  pos  >  start  )  {  [ATTENTION]  }  }    [METHOD]  printAndEscape  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  escape  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  newLine  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out  
[REPLACE]  boolean  first  =  newLine;	[BUGGY]  boolean  quote  =  false  ;  [CE]  variable  quote  is  already  defined  in  method  printAndEncapsulate(CharSequence  ,  int  ,  int)  [CONTEXT]  void  printAndEncapsulate  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  [ATTENTION]  boolean  quote  =  false  ;  boolean  quote  =  false  ;  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  encapsulator  =  format  .  getEncapsulator  (  )  ;    if  (  len  <  =  0  )  {          if  (  first  )  {  quote  =  true  ;  }  }  else  {  char  c  =  value  .  charAt  (  pos  )  ;      if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )  ||  (  c  >  'z'  )  )  )  {  quote  =  true  ;    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }  }  if  (  !quote  )  {    out  .  append  (  value  ,  start  ,  end  )  ;  return  ;  }    out  .  append  (  encapsulator  )  ;        while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  encapsulator  )  {      out  .  append  (  value  ,  start  ,  pos  +  1  )  ;      start  =  pos  ;  }  pos++  ;  }    out  .  append  (  value  ,  start  ,  pos  )  ;  out  .  append  (  encapsulator  )  ;  }    [METHOD]  printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out  
[REPLACE]  boolean  quote  =  false;	[BUGGY]  boolean  quote  =  true  ;  [FE]  AssertionFailedError    expected:<[a  ,  b  ,  c]>  but  was:<[ "a "  ,   "b "  ,   "c "]>  assertEquals( " "  ,  format.format())  ;  assertEquals( "a  ,  b  ,  c "  ,  format.format( "a "  ,   "b "  ,   "c "))  ;  assertEquals( "\ "x  ,  y\ "  ,  z "  ,  format.format( "x  ,  y "  ,   "z "))  ;  [CONTEXT]  void  printAndEncapsulate  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  boolean  first  =  newLine  ;  //  is  this  the  first  value  on  this  line?  [ATTENTION]  boolean  quote  =  true  ;  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  encapsulator  =  format  .  getEncapsulator  (  )  ;    if  (  len  <  =  0  )  {          if  (  first  )  {  quote  =  true  ;  }  }  else  {  char  c  =  value  .  charAt  (  pos  )  ;      if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )  ||  (  c  >  'z'  )  )  )  {  quote  =  true  ;    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }  }  if  (  !quote  )  {    out  .  append  (  value  ,  start  ,  end  )  ;  return  ;  }    out  .  append  (  encapsulator  )  ;        while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  encapsulator  )  {      out  .  append  (  value  ,  start  ,  pos  +  1  )  ;      start  =  pos  ;  }  pos++  ;  }    out  .  append  (  value  ,  start  ,  pos  )  ;  out  .  append  (  encapsulator  )  ;  }    [METHOD]  printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out  
[REPLACE]  int  start  =  offset;	[BUGGY]  int  pos  =  offset  ;  [CE]  variable  pos  is  already  defined  in  method  printAndEncapsulate(CharSequence  ,  int  ,  int)  [CONTEXT]  void  printAndEncapsulate  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  boolean  first  =  newLine  ;  //  is  this  the  first  value  on  this  line?  boolean  quote  =  false  ;  [ATTENTION]  int  pos  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  encapsulator  =  format  .  getEncapsulator  (  )  ;    if  (  len  <  =  0  )  {          if  (  first  )  {  quote  =  true  ;  }  }  else  {  char  c  =  value  .  charAt  (  pos  )  ;      if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )  ||  (  c  >  'z'  )  )  )  {  quote  =  true  ;    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }  }  if  (  !quote  )  {    out  .  append  (  value  ,  start  ,  end  )  ;  return  ;  }    out  .  append  (  encapsulator  )  ;        while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  encapsulator  )  {      out  .  append  (  value  ,  start  ,  pos  +  1  )  ;      start  =  pos  ;  }  pos++  ;  }    out  .  append  (  value  ,  start  ,  pos  )  ;  out  .  append  (  encapsulator  )  ;  }    [METHOD]  printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out  
[REPLACE]  int  pos  =  offset;	[BUGGY]  int  pos  =  start  ;  [FE]  (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo\n "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "foo\n  baar  ,  ,  ,   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "\n\t  \n "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  void  printAndEncapsulate  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  boolean  first  =  newLine  ;  //  is  this  the  first  value  on  this  line?  boolean  quote  =  false  ;  int  start  =  offset  ;  [ATTENTION]  int  pos  =  start  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  encapsulator  =  format  .  getEncapsulator  (  )  ;    if  (  len  <  =  0  )  {          if  (  first  )  {  quote  =  true  ;  }  }  else  {  char  c  =  value  .  charAt  (  pos  )  ;      if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )  ||  (  c  >  'z'  )  )  )  {  quote  =  true  ;    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }  }  if  (  !quote  )  {    out  .  append  (  value  ,  start  ,  end  )  ;  return  ;  }    out  .  append  (  encapsulator  )  ;        while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  encapsulator  )  {      out  .  append  (  value  ,  start  ,  pos  +  1  )  ;      start  =  pos  ;  }  pos++  ;  }    out  .  append  (  value  ,  start  ,  pos  )  ;  out  .  append  (  encapsulator  )  ;  }    [METHOD]  printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out  
[REPLACE]  int  end  =  offset  +  len;	[BUGGY]  int  end  =  start  +start  ;  [FE]  String  index  out  of  range:  -1  assertEquals( " "  ,  format.format())  ;  assertEquals( "a  ,  b  ,  c "  ,  format.format( "a "  ,   "b "  ,   "c "))  ;  assertEquals( "\ "x  ,  y\ "  ,  z "  ,  format.format( "x  ,  y "  ,   "z "))  ;  [CONTEXT]  void  printAndEncapsulate  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  boolean  first  =  newLine  ;  //  is  this  the  first  value  on  this  line?  boolean  quote  =  false  ;  int  start  =  offset  ;  int  pos  =  offset  ;  [ATTENTION]  int  end  =  start  +start  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  encapsulator  =  format  .  getEncapsulator  (  )  ;    if  (  len  <  =  0  )  {          if  (  first  )  {  quote  =  true  ;  }  }  else  {  char  c  =  value  .  charAt  (  pos  )  ;      if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )  ||  (  c  >  'z'  )  )  )  {  quote  =  true  ;    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }  }  if  (  !quote  )  {    out  .  append  (  value  ,  start  ,  end  )  ;  return  ;  }    out  .  append  (  encapsulator  )  ;        while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  encapsulator  )  {      out  .  append  (  value  ,  start  ,  pos  +  1  )  ;      start  =  pos  ;  }  pos++  ;  }    out  .  append  (  value  ,  start  ,  pos  )  ;  out  .  append  (  encapsulator  )  ;  }    [METHOD]  printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out  
[REPLACE]  printSep  (  )  ;	[BUGGY]  out  .  append  (  '  '  )  ;  [FE]  AssertionFailedError    expected:<a[  ,  b  ,  ]c>  but  was:<a[  b  ]c>  assertEquals( " "  ,  format.format())  ;  assertEquals( "a  ,  b  ,  c "  ,  format.format( "a "  ,   "b "  ,   "c "))  ;  assertEquals( "\ "x  ,  y\ "  ,  z "  ,  format.format( "x  ,  y "  ,   "z "))  ;  [CONTEXT]  void  printAndEncapsulate  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  boolean  first  =  newLine  ;  //  is  this  the  first  value  on  this  line?  boolean  quote  =  false  ;  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    [ATTENTION]  out  .  append  (  '  '  )    ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  encapsulator  =  format  .  getEncapsulator  (  )  ;    if  (  len  <  =  0  )  {          if  (  first  )  {  quote  =  true  ;  }  }  else  {  char  c  =  value  .  charAt  (  pos  )  ;      if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )  ||  (  c  >  'z'  )  )  )  {  quote  =  true  ;    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }  }  if  (  !quote  )  {    out  .  append  (  value  ,  start  ,  end  )  ;  return  ;  }    out  .  append  (  encapsulator  )  ;        while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  encapsulator  )  {      out  .  append  (  value  ,  start  ,  pos  +  1  )  ;      start  =  pos  ;  }  pos++  ;  }    out  .  append  (  value  ,  start  ,  pos  )  ;  out  .  append  (  encapsulator  )  ;  }    [METHOD]  printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out  
[REPLACE]  char  delim  =  format  .  getDelimiter  (  )  ;	[BUGGY]  char  delim  =  format  .  getEscape  (  )  ;  [FE]  AssertionFailedError    expected:<[ "x  ,  y "]  ,  z>  but  was:<[x  ,  y]  ,  z>  assertEquals( " "  ,  format.format())  ;  assertEquals( "a  ,  b  ,  c "  ,  format.format( "a "  ,   "b "  ,   "c "))  ;  assertEquals( "\ "x  ,  y\ "  ,  z "  ,  format.format( "x  ,  y "  ,   "z "))  ;  [CONTEXT]  void  printAndEncapsulate  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  boolean  first  =  newLine  ;  //  is  this  the  first  value  on  this  line?  boolean  quote  =  false  ;  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    [ATTENTION]  char  delim  =  format  .  getEscape  (  )    ;  char  encapsulator  =  format  .  getEncapsulator  (  )  ;    if  (  len  <  =  0  )  {          if  (  first  )  {  quote  =  true  ;  }  }  else  {  char  c  =  value  .  charAt  (  pos  )  ;      if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )  ||  (  c  >  'z'  )  )  )  {  quote  =  true  ;    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }  }  if  (  !quote  )  {    out  .  append  (  value  ,  start  ,  end  )  ;  return  ;  }    out  .  append  (  encapsulator  )  ;        while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  encapsulator  )  {      out  .  append  (  value  ,  start  ,  pos  +  1  )  ;      start  =  pos  ;  }  pos++  ;  }    out  .  append  (  value  ,  start  ,  pos  )  ;  out  .  append  (  encapsulator  )  ;  }    [METHOD]  printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out  
[REPLACE]  char  encapsulator  =  format  .  getEncapsulator  (  )  ;	[BUGGY]  char  encapsulator  =  format  .  isEncapsulating  (  )  ;  [CE]  incompatible  types  [CONTEXT]  void  printAndEncapsulate  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  boolean  first  =  newLine  ;  //  is  this  the  first  value  on  this  line?  boolean  quote  =  false  ;  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  [ATTENTION]  char  encapsulator  =  format  .  isEncapsulating  (  )    ;    if  (  len  <  =  0  )  {          if  (  first  )  {  quote  =  true  ;  }  }  else  {  char  c  =  value  .  charAt  (  pos  )  ;      if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )  ||  (  c  >  'z'  )  )  )  {  quote  =  true  ;    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }  }  if  (  !quote  )  {    out  .  append  (  value  ,  start  ,  end  )  ;  return  ;  }    out  .  append  (  encapsulator  )  ;        while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  encapsulator  )  {      out  .  append  (  value  ,  start  ,  pos  +  1  )  ;      start  =  pos  ;  }  pos++  ;  }    out  .  append  (  value  ,  start  ,  pos  )  ;  out  .  append  (  encapsulator  )  ;  }    [METHOD]  printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out  
[REPLACE]  while  (  pos  <  end  )  {	[BUGGY]  while  (  pos    =  =    end  )  {[FE]  AssertionFailedError    expected:<[ "x  ,  y "]  ,  z>  but  was:<[x  ,  y]  ,  z>  assertEquals( " "  ,  format.format())  ;  assertEquals( "a  ,  b  ,  c "  ,  format.format( "a "  ,   "b "  ,   "c "))  ;  assertEquals( "\ "x  ,  y\ "  ,  z "  ,  format.format( "x  ,  y "  ,   "z "))  ;  [CONTEXT]  void  printAndEncapsulate  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  boolean  first  =  newLine  ;  //  is  this  the  first  value  on  this  line?  boolean  quote  =  false  ;  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  encapsulator  =  format  .  getEncapsulator  (  )  ;    if  (  len  <  =  0  )  {          if  (  first  )  {  quote  =  true  ;  }  }  else  {  char  c  =  value  .  charAt  (  pos  )  ;      if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )  ||  (  c  >  'z'  )  )  )  {  quote  =  true  ;    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  [ATTENTION]  while  (  pos  =  =  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }  }  if  (  !quote  )  {    out  .  append  (  value  ,  start  ,  end  )  ;  return  ;  }    out  .  append  (  encapsulator  )  ;        while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  encapsulator  )  {      out  .  append  (  value  ,  start  ,  pos  +  1  )  ;      start  =  pos  ;  }  pos++  ;  }    out  .  append  (  value  ,  start  ,  pos  )  ;  out  .  append  (  encapsulator  )  ;  }    [METHOD]  printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out  
[ADD]  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;	[BUGGY]  [CE]  illegal  start  of  type  [CONTEXT]  void  printAndEncapsulate  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  boolean  first  =  newLine  ;  //  is  this  the  first  value  on  this  line?  boolean  quote  =  false  ;  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  encapsulator  =  format  .  getEncapsulator  (  )  ;    if  (  len  <  =  0  )  {          if  (  first  )  {  quote  =  true  ;  }  }  else  {  char  c  =  value  .  charAt  (  pos  )  ;      if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )  ||  (  c  >  'z'  )  )  )  {  quote  =  true  ;    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  [ATTENTION]    if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }  }  if  (  !quote  )  {    out  .  append  (  value  ,  start  ,  end  )  ;  return  ;  }    out  .  append  (  encapsulator  )  ;        while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  encapsulator  )  {      out  .  append  (  value  ,  start  ,  pos  +  1  )  ;      start  =  pos  ;  }  pos++  ;  }    out  .  append  (  value  ,  start  ,  pos  )  ;  out  .  append  (  encapsulator  )  ;  }    [METHOD]  printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out  
[REPLACE]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUGGY]  if  (  c  =  =  '\n'  )  {[FE]  AssertionFailedError    expected:<[ "x  ,  y "]  ,  z>  but  was:<[x  ,  y]  ,  z>  assertEquals( " "  ,  format.format())  ;  assertEquals( "a  ,  b  ,  c "  ,  format.format( "a "  ,   "b "  ,   "c "))  ;  assertEquals( "\ "x  ,  y\ "  ,  z "  ,  format.format( "x  ,  y "  ,   "z "))  ;  [CONTEXT]  void  printAndEncapsulate  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  boolean  first  =  newLine  ;  //  is  this  the  first  value  on  this  line?  boolean  quote  =  false  ;  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  encapsulator  =  format  .  getEncapsulator  (  )  ;    if  (  len  <  =  0  )  {          if  (  first  )  {  quote  =  true  ;  }  }  else  {  char  c  =  value  .  charAt  (  pos  )  ;      if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )  ||  (  c  >  'z'  )  )  )  {  quote  =  true  ;    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  [ATTENTION]  if  (  c  =  =  '\n'  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }  }  if  (  !quote  )  {    out  .  append  (  value  ,  start  ,  end  )  ;  return  ;  }    out  .  append  (  encapsulator  )  ;        while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  encapsulator  )  {      out  .  append  (  value  ,  start  ,  pos  +  1  )  ;      start  =  pos  ;  }  pos++  ;  }    out  .  append  (  value  ,  start  ,  pos  )  ;  out  .  append  (  encapsulator  )  ;  }    [METHOD]  printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out  
[ADD]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {  quote  =  true;  break;  }	[BUGGY]  quote  =  true  ;  break  ;  [CE]  unreachable  statement  [CONTEXT]  void  printAndEncapsulate  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  boolean  first  =  newLine  ;  //  is  this  the  first  value  on  this  line?  boolean  quote  =  false  ;  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  encapsulator  =  format  .  getEncapsulator  (  )  ;    if  (  len  <  =  0  )  {          if  (  first  )  {  quote  =  true  ;  }  }  else  {  char  c  =  value  .  charAt  (  pos  )  ;      if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )  ||  (  c  >  'z'  )  )  )  {  quote  =  true  ;    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  [ATTENTION]  quote  =  true  ;  break  ;      pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }  }  if  (  !quote  )  {    out  .  append  (  value  ,  start  ,  end  )  ;  return  ;  }    out  .  append  (  encapsulator  )  ;        while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  encapsulator  )  {      out  .  append  (  value  ,  start  ,  pos  +  1  )  ;      start  =  pos  ;  }  pos++  ;  }    out  .  append  (  value  ,  start  ,  pos  )  ;  out  .  append  (  encapsulator  )  ;  }    [METHOD]  printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out  
[REPLACE]  quote  =  true;	[BUGGY]  quote  =  false  ;  [FE]  AssertionFailedError    expected:<[ "x  ,  y "]  ,  z>  but  was:<[x  ,  y]  ,  z>  assertEquals( " "  ,  format.format())  ;  assertEquals( "a  ,  b  ,  c "  ,  format.format( "a "  ,   "b "  ,   "c "))  ;  assertEquals( "\ "x  ,  y\ "  ,  z "  ,  format.format( "x  ,  y "  ,   "z "))  ;  [CONTEXT]  void  printAndEncapsulate  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  boolean  first  =  newLine  ;  //  is  this  the  first  value  on  this  line?  boolean  quote  =  false  ;  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  encapsulator  =  format  .  getEncapsulator  (  )  ;    if  (  len  <  =  0  )  {          if  (  first  )  {  quote  =  true  ;  }  }  else  {  char  c  =  value  .  charAt  (  pos  )  ;      if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )  ||  (  c  >  'z'  )  )  )  {  quote  =  true  ;    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  [ATTENTION]  quote  =  false  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }  }  if  (  !quote  )  {    out  .  append  (  value  ,  start  ,  end  )  ;  return  ;  }    out  .  append  (  encapsulator  )  ;        while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  encapsulator  )  {      out  .  append  (  value  ,  start  ,  pos  +  1  )  ;      start  =  pos  ;  }  pos++  ;  }    out  .  append  (  value  ,  start  ,  pos  )  ;  out  .  append  (  encapsulator  )  ;  }    [METHOD]  printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out  
[REPLACE]  c  =  value  .  charAt  (  pos  )  ;	[BUGGY]  c  =    null  .  charAt  (  pos  )  ;  [CE]  <null>  cannot  be  dereferenced  [CONTEXT]  void  printAndEncapsulate  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  boolean  first  =  newLine  ;  //  is  this  the  first  value  on  this  line?  boolean  quote  =  false  ;  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  encapsulator  =  format  .  getEncapsulator  (  )  ;    if  (  len  <  =  0  )  {          if  (  first  )  {  quote  =  true  ;  }  }  else  {  char  c  =  value  .  charAt  (  pos  )  ;      if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )  ||  (  c  >  'z'  )  )  )  {  quote  =  true  ;    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  [ATTENTION]  c  =  null  .  charAt  (  pos  )    ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }  }  if  (  !quote  )  {    out  .  append  (  value  ,  start  ,  end  )  ;  return  ;  }    out  .  append  (  encapsulator  )  ;        while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  encapsulator  )  {      out  .  append  (  value  ,  start  ,  pos  +  1  )  ;      start  =  pos  ;  }  pos++  ;  }    out  .  append  (  value  ,  start  ,  pos  )  ;  out  .  append  (  encapsulator  )  ;  }    [METHOD]  printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out  
[ADD]  c  =  value  .  charAt  (  pos  )  ;	[BUGGY]  [FE]  AssertionFailedError    expected:<[ "x  ,  y "]  ,  z>  but  was:<[x  ,  y]  ,  z>  assertEquals( " "  ,  format.format())  ;  assertEquals( "a  ,  b  ,  c "  ,  format.format( "a "  ,   "b "  ,   "c "))  ;  assertEquals( "\ "x  ,  y\ "  ,  z "  ,  format.format( "x  ,  y "  ,   "z "))  ;  [CONTEXT]  void  printAndEncapsulate  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  boolean  first  =  newLine  ;  //  is  this  the  first  value  on  this  line?  boolean  quote  =  false  ;  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  encapsulator  =  format  .  getEncapsulator  (  )  ;    if  (  len  <  =  0  )  {          if  (  first  )  {  quote  =  true  ;  }  }  else  {  char  c  =  value  .  charAt  (  pos  )  ;      if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )  ||  (  c  >  'z'  )  )  )  {  quote  =  true  ;    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  [ATTENTION]  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }  }  if  (  !quote  )  {    out  .  append  (  value  ,  start  ,  end  )  ;  return  ;  }    out  .  append  (  encapsulator  )  ;        while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  encapsulator  )  {      out  .  append  (  value  ,  start  ,  pos  +  1  )  ;      start  =  pos  ;  }  pos++  ;  }    out  .  append  (  value  ,  start  ,  pos  )  ;  out  .  append  (  encapsulator  )  ;  }    [METHOD]  printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out  
[ADD]  quote  =  true;  break;	[BUGGY]  [FE]  AssertionFailedError    expected:<[ "x  ,  y "]  ,  z>  but  was:<[x  ,  y]  ,  z>  assertEquals( " "  ,  format.format())  ;  assertEquals( "a  ,  b  ,  c "  ,  format.format( "a "  ,   "b "  ,   "c "))  ;  assertEquals( "\ "x  ,  y\ "  ,  z "  ,  format.format( "x  ,  y "  ,   "z "))  ;  [CONTEXT]  void  printAndEncapsulate  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  boolean  first  =  newLine  ;  //  is  this  the  first  value  on  this  line?  boolean  quote  =  false  ;  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  encapsulator  =  format  .  getEncapsulator  (  )  ;    if  (  len  <  =  0  )  {          if  (  first  )  {  quote  =  true  ;  }  }  else  {  char  c  =  value  .  charAt  (  pos  )  ;      if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )  ||  (  c  >  'z'  )  )  )  {  quote  =  true  ;    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  [ATTENTION]    }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }  }  if  (  !quote  )  {    out  .  append  (  value  ,  start  ,  end  )  ;  return  ;  }    out  .  append  (  encapsulator  )  ;        while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  encapsulator  )  {      out  .  append  (  value  ,  start  ,  pos  +  1  )  ;      start  =  pos  ;  }  pos++  ;  }    out  .  append  (  value  ,  start  ,  pos  )  ;  out  .  append  (  encapsulator  )  ;  }    [METHOD]  printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out  
[REPLACE]  if  (  len  <=  0  )  {	[BUGGY]  if  (offset  !  =    0  )  {[FE]  (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo\n "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "foo\n  baar  ,  ,  ,   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "\n\t  \n "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  void  printAndEncapsulate  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  boolean  first  =  newLine  ;  //  is  this  the  first  value  on  this  line?  boolean  quote  =  false  ;  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  encapsulator  =  format  .  getEncapsulator  (  )  ;    [ATTENTION]  if  (  offset!  =  0  )  {          if  (  first  )  {  quote  =  true  ;  }  }  else  {  char  c  =  value  .  charAt  (  pos  )  ;      if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )  ||  (  c  >  'z'  )  )  )  {  quote  =  true  ;    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }  }  if  (  !quote  )  {    out  .  append  (  value  ,  start  ,  end  )  ;  return  ;  }    out  .  append  (  encapsulator  )  ;        while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  encapsulator  )  {      out  .  append  (  value  ,  start  ,  pos  +  1  )  ;      start  =  pos  ;  }  pos++  ;  }    out  .  append  (  value  ,  start  ,  pos  )  ;  out  .  append  (  encapsulator  )  ;  }    [METHOD]  printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out  
[ADD]  if  (  len  <=  0  )  {	[BUGGY]  [CE]  illegal  start  of  type  [CONTEXT]  void  printAndEncapsulate  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  boolean  first  =  newLine  ;  //  is  this  the  first  value  on  this  line?  boolean  quote  =  false  ;  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  encapsulator  =  format  .  getEncapsulator  (  )  ;    [ATTENTION]          if  (  first  )  {  quote  =  true  ;  }  }  else  {  char  c  =  value  .  charAt  (  pos  )  ;      if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )  ||  (  c  >  'z'  )  )  )  {  quote  =  true  ;    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }  }  if  (  !quote  )  {    out  .  append  (  value  ,  start  ,  end  )  ;  return  ;  }    out  .  append  (  encapsulator  )  ;        while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  encapsulator  )  {      out  .  append  (  value  ,  start  ,  pos  +  1  )  ;      start  =  pos  ;  }  pos++  ;  }    out  .  append  (  value  ,  start  ,  pos  )  ;  out  .  append  (  encapsulator  )  ;  }    [METHOD]  printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out  
[REPLACE]  while  (  pos  <  end  )  {	[BUGGY]  while  (  pos  !  =    end  )  {[FE]  (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo\n "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "foo\n  baar  ,  ,  ,   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "\n\t  \n "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  if  (  len  <  =  0  )  {          if  (  first  )  {  quote  =  true  ;  }  }  else  {  char  c  =  value  .  charAt  (  pos  )  ;      if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )  ||  (  c  >  'z'  )  )  )  {  quote  =  true  ;    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  [ATTENTION]  while  (  pos!  =  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }  }    [METHOD]  printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out  
[REPLACE]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUGGY]  if  (  c  =  =  '\n'  &&  c  =  =  '\r'  &&  c  =  =  encapsulator  &&  c  =  =  delim  )  {[FE]  AssertionFailedError    expected:<[ "x  ,  y "]  ,  z>  but  was:<[x  ,  y]  ,  z>  assertEquals( " "  ,  format.format())  ;  assertEquals( "a  ,  b  ,  c "  ,  format.format( "a "  ,   "b "  ,   "c "))  ;  assertEquals( "\ "x  ,  y\ "  ,  z "  ,  format.format( "x  ,  y "  ,   "z "))  ;  [CONTEXT]  if  (  len  <  =  0  )  {          if  (  first  )  {  quote  =  true  ;  }  }  else  {  char  c  =  value  .  charAt  (  pos  )  ;      if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )  ||  (  c  >  'z'  )  )  )  {  quote  =  true  ;    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  [ATTENTION]  if  (  c  =  =  '\n'  &&  c  =  =  '\r'  &&  c  =  =  encapsulator  &&  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }  }    [METHOD]  printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out  
[ADD]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {  quote  =  true;  break;  }	[BUGGY]  quote  =  true  ;  break  ;  [CE]  unreachable  statement  [CONTEXT]  if  (  len  <  =  0  )  {          if  (  first  )  {  quote  =  true  ;  }  }  else  {  char  c  =  value  .  charAt  (  pos  )  ;      if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )  ||  (  c  >  'z'  )  )  )  {  quote  =  true  ;    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  [ATTENTION]  quote  =  true  ;  break  ;      pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }  }    [METHOD]  printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out  
[REPLACE]  quote  =  true;	[BUGGY]  quote  =  false  ;  [FE]  AssertionFailedError    expected:<[ "x  ,  y "]  ,  z>  but  was:<[x  ,  y]  ,  z>  assertEquals( " "  ,  format.format())  ;  assertEquals( "a  ,  b  ,  c "  ,  format.format( "a "  ,   "b "  ,   "c "))  ;  assertEquals( "\ "x  ,  y\ "  ,  z "  ,  format.format( "x  ,  y "  ,   "z "))  ;  [CONTEXT]  if  (  len  <  =  0  )  {          if  (  first  )  {  quote  =  true  ;  }  }  else  {  char  c  =  value  .  charAt  (  pos  )  ;      if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )  ||  (  c  >  'z'  )  )  )  {  quote  =  true  ;    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  [ATTENTION]  quote  =  false  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }  }    [METHOD]  printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out  
[ADD]  quote  =  true;	[BUGGY]  [FE]  AssertionFailedError    expected:<[ "x  ,  y "]  ,  z>  but  was:<[x  ,  y]  ,  z>  assertEquals( " "  ,  format.format())  ;  assertEquals( "a  ,  b  ,  c "  ,  format.format( "a "  ,   "b "  ,   "c "))  ;  assertEquals( "\ "x  ,  y\ "  ,  z "  ,  format.format( "x  ,  y "  ,   "z "))  ;  [CONTEXT]  if  (  len  <  =  0  )  {          if  (  first  )  {  quote  =  true  ;  }  }  else  {  char  c  =  value  .  charAt  (  pos  )  ;      if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )  ||  (  c  >  'z'  )  )  )  {  quote  =  true  ;    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  [ATTENTION]  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }  }    [METHOD]  printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out  
[REPLACE]  c  =  value  .  charAt  (  pos  )  ;	[BUGGY]  c  =    null  .  charAt  (  pos  )  ;  [CE]  <null>  cannot  be  dereferenced  [CONTEXT]  if  (  len  <  =  0  )  {          if  (  first  )  {  quote  =  true  ;  }  }  else  {  char  c  =  value  .  charAt  (  pos  )  ;      if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )  ||  (  c  >  'z'  )  )  )  {  quote  =  true  ;    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  [ATTENTION]  c  =  null  .  charAt  (  pos  )    ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }  }    [METHOD]  printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out  
[ADD]  quote  =  true;  break;	[BUGGY]  [FE]  AssertionFailedError    expected:<[ "x  ,  y "]  ,  z>  but  was:<[x  ,  y]  ,  z>  assertEquals( " "  ,  format.format())  ;  assertEquals( "a  ,  b  ,  c "  ,  format.format( "a "  ,   "b "  ,   "c "))  ;  assertEquals( "\ "x  ,  y\ "  ,  z "  ,  format.format( "x  ,  y "  ,   "z "))  ;  [CONTEXT]  if  (  len  <  =  0  )  {          if  (  first  )  {  quote  =  true  ;  }  }  else  {  char  c  =  value  .  charAt  (  pos  )  ;      if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )  ||  (  c  >  'z'  )  )  )  {  quote  =  true  ;    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  [ATTENTION]    }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }  }    [METHOD]  printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out  
[REPLACE]  if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )	[BUGGY]  if  (  first  ||  (  c  <  '0'  ||  (  c  >  '9'  ||  c  <  'A'  )  ||  (  c  >  'Z'  ||  c  <  'a'  )[FE]  AssertionFailedError    expected:<[a  ,  b  ,  c]>  but  was:<[ "a "  ,   "b "  ,   "c "]>  assertEquals( " "  ,  format.format())  ;  assertEquals( "a  ,  b  ,  c "  ,  format.format( "a "  ,   "b "  ,   "c "))  ;  assertEquals( "\ "x  ,  y\ "  ,  z "  ,  format.format( "x  ,  y "  ,   "z "))  ;  [CONTEXT]  if  (  len  <  =  0  )  {          if  (  first  )  {  quote  =  true  ;  }  }  else  {  char  c  =  value  .  charAt  (  pos  )  ;      [ATTENTION]  if  (  first  ||  (  c  <  '0'  ||  (  c  >  '9'  ||  c  <  'A'  )  ||  (  c  >  'Z'  ||  c  <  'a'  )      ||  (  c  >  'z'  )  )  )  {  quote  =  true  ;    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }  }    [METHOD]  printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out  
[REPLACE]  while  (  pos  <  end  )  {	[BUGGY]  while  (offset  >  =    end  )  {[FE]  AssertionFailedError    expected:<[ "x  ,  y "]  ,  z>  but  was:<[x  ,  y]  ,  z>  assertEquals( " "  ,  format.format())  ;  assertEquals( "a  ,  b  ,  c "  ,  format.format( "a "  ,   "b "  ,   "c "))  ;  assertEquals( "\ "x  ,  y\ "  ,  z "  ,  format.format( "x  ,  y "  ,   "z "))  ;  [CONTEXT]  if  (  len  <  =  0  )  {          if  (  first  )  {  quote  =  true  ;  }  }  else  {  char  c  =  value  .  charAt  (  pos  )  ;      if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )  ||  (  c  >  'z'  )  )  )  {  quote  =  true  ;    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  [ATTENTION]  while  (  offset>  =  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }  }    [METHOD]  printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out  
[ADD]  c  =  value  .  charAt  (  pos  )  ;	[BUGGY]  [FE]  AssertionFailedError    expected:<[ "x  ,  y "]  ,  z>  but  was:<[x  ,  y]  ,  z>  assertEquals( " "  ,  format.format())  ;  assertEquals( "a  ,  b  ,  c "  ,  format.format( "a "  ,   "b "  ,   "c "))  ;  assertEquals( "\ "x  ,  y\ "  ,  z "  ,  format.format( "x  ,  y "  ,   "z "))  ;  [CONTEXT]  if  (  len  <  =  0  )  {          if  (  first  )  {  quote  =  true  ;  }  }  else  {  char  c  =  value  .  charAt  (  pos  )  ;      if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )  ||  (  c  >  'z'  )  )  )  {  quote  =  true  ;    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  [ATTENTION]  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }  }    [METHOD]  printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out  
[REPLACE]  }  else  if  (  c  <=  '#'  )  {	[BUGGY]    if  (  c  >  =    '#'  )  {[FE]  AssertionFailedError    expected:<[a  ,  b  ,  c]>  but  was:<[ "a "  ,   "b "  ,   "c "]>  assertEquals( " "  ,  format.format())  ;  assertEquals( "a  ,  b  ,  c "  ,  format.format( "a "  ,   "b "  ,   "c "))  ;  assertEquals( "\ "x  ,  y\ "  ,  z "  ,  format.format( "x  ,  y "  ,   "z "))  ;  [CONTEXT]  if  (  len  <  =  0  )  {          if  (  first  )  {  quote  =  true  ;  }  }  else  {  char  c  =  value  .  charAt  (  pos  )  ;      if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )  ||  (  c  >  'z'  )  )  )  {  quote  =  true  ;    [ATTENTION]  }if  (  c>  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }  }    [METHOD]  printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out  
[REPLACE]  while  (  pos  <  end  )  {	[BUGGY]  while  (offset  <  =    end  )  {[FE]  String  index  out  of  range:  1  assertEquals( " "  ,  format.format())  ;  assertEquals( "a  ,  b  ,  c "  ,  format.format( "a "  ,   "b "  ,   "c "))  ;  assertEquals( "\ "x  ,  y\ "  ,  z "  ,  format.format( "x  ,  y "  ,   "z "))  ;  [CONTEXT]  }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  [ATTENTION]  while  (  offset<  =  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }    [METHOD]  printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out  
[REPLACE]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUGGY]  if  (  c  =  =  '\n'  )  {[FE]  AssertionFailedError    expected:<[ "x  ,  y "]  ,  z>  but  was:<[x  ,  y]  ,  z>  assertEquals( " "  ,  format.format())  ;  assertEquals( "a  ,  b  ,  c "  ,  format.format( "a "  ,   "b "  ,   "c "))  ;  assertEquals( "\ "x  ,  y\ "  ,  z "  ,  format.format( "x  ,  y "  ,   "z "))  ;  [CONTEXT]  }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  [ATTENTION]  if  (  c  =  =  '\n'  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }    [METHOD]  printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out  
[REPLACE]  quote  =  true;	[BUGGY]  quote  =  false  ;  [FE]  AssertionFailedError    expected:<[ "x  ,  y "]  ,  z>  but  was:<[x  ,  y]  ,  z>  assertEquals( " "  ,  format.format())  ;  assertEquals( "a  ,  b  ,  c "  ,  format.format( "a "  ,   "b "  ,   "c "))  ;  assertEquals( "\ "x  ,  y\ "  ,  z "  ,  format.format( "x  ,  y "  ,   "z "))  ;  [CONTEXT]  }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  [ATTENTION]  quote  =  false  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }    [METHOD]  printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out  
[REPLACE]  c  =  value  .  charAt  (  pos  )  ;	[BUGGY]  c  =    null  .  charAt  (  pos  )  ;  [CE]  <null>  cannot  be  dereferenced  [CONTEXT]  }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  [ATTENTION]  c  =  null  .  charAt  (  pos  )    ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }    [METHOD]  printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out  
[REPLACE]  if  (  !quote  )  {	[BUGGY]  if  (  quote  )  {[FE]  (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo\n "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "foo\n  baar  ,  ,  ,   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "\n\t  \n "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  [ATTENTION]  if  (  quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }    [METHOD]  printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out  
[ADD]  if  (  !quote  )  {  pos  =  end  -  1;  c  =  value  .  charAt  (  pos  )  ;	[BUGGY]  [CE]  illegal  start  of  type  [CONTEXT]  }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  [ATTENTION]          if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }    [METHOD]  printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out  
[REPLACE]  if  (  c  <=  '  '  )  {	[BUGGY]  if  (  encapsulator  <  '  '  )  {[FE]  (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo\n "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "foo\n  baar  ,  ,  ,   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "\n\t  \n "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        [ATTENTION]  if  (  encapsulator<'  '  )  {  quote  =  true  ;  }  }  }    [METHOD]  printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out  
[REPLACE]  quote  =  true;	[BUGGY]  quote  =  false  ;  [FE]  (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo\n "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "foo\n  baar  ,  ,  ,   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "\n\t  \n "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  [ATTENTION]  quote  =  false  ;  }  }  }    [METHOD]  printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out  
[REPLACE]  pos  =  end  -  1;	[BUGGY]  pos  =  len  -  1  ;  [FE]  (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo\n "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "foo\n  baar  ,  ,  ,   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "\n\t  \n "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  [ATTENTION]  pos  =  len  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }    [METHOD]  printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out  
[REPLACE]  c  =  value  .  charAt  (  pos  )  ;	[BUGGY]  c  =    null  .  charAt  (  pos  )  ;  [CE]  <null>  cannot  be  dereferenced  [CONTEXT]  }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  [ATTENTION]  c  =  null  .  charAt  (  pos  )    ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }    [METHOD]  printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out  
[ADD]  quote  =  true;	[BUGGY]  [FE]  (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo\n "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "foo\n  baar  ,  ,  ,   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "\n\t  \n "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  [ATTENTION]  }  }  }    [METHOD]  printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out  
[REPLACE]  if  (  c  <=  '  '  )  {	[BUGGY]  if  (  c    =  =  encapsulator  )  {[FE]  (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo\n "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "foo\n  baar  ,  ,  ,   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "\n\t  \n "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        [ATTENTION]  if  (  c  =  =  encapsulator  )  {  quote  =  true  ;  }  }  }    [METHOD]  printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out  
[ADD]  if  (  c  <=  '  '  )  {  quote  =  true;  }	[BUGGY]  quote  =  true  ;  [FE]  AssertionFailedError    expected:<[a  ,  b  ,  c]>  but  was:<[ "a "  ,   "b "  ,   "c "]>  assertEquals( " "  ,  format.format())  ;  assertEquals( "a  ,  b  ,  c "  ,  format.format( "a "  ,   "b "  ,   "c "))  ;  assertEquals( "\ "x  ,  y\ "  ,  z "  ,  format.format( "x  ,  y "  ,   "z "))  ;  [CONTEXT]  }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        [ATTENTION]  quote  =  true  ;    }  }    [METHOD]  printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out  
[REPLACE]  pos  =  end  -  1;	[BUGGY]  pos  =  len  -  1  /  1  ;  [FE]  (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo\n "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "foo\n  baar  ,  ,  ,   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "\n\t  \n "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  [ATTENTION]  pos  =  len  -  1  /  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }    [METHOD]  printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out  
[ADD]  c  =  value  .  charAt  (  pos  )  ;	[BUGGY]  [FE]  (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo\n "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "foo\n  baar  ,  ,  ,   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "\n\t  \n "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  [ATTENTION]        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }    [METHOD]  printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out  
[REPLACE]  quote  =  true;	[BUGGY]  quote  =  false  ;  [FE]  (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo\n "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "foo\n  baar  ,  ,  ,   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "\n\t  \n "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  if  (  len  <  =  0  )  {          if  (  first  )  {  quote  =  true  ;  }  }  else  {  char  c  =  value  .  charAt  (  pos  )  ;      if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )  ||  (  c  >  'z'  )  )  )  {  quote  =  true  ;    }  else  if  (  c  <  =  '#'  )  {        [ATTENTION]  quote  =  false  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }  }    [METHOD]  printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out  
[REPLACE]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUGGY]  if  (  c  =  =  '\r'  &&  c  =  =  encapsulator  &&  c  =  =  delim  )  {[FE]  AssertionFailedError    expected:<[ "x  ,  y "]  ,  z>  but  was:<[x  ,  y]  ,  z>  assertEquals( " "  ,  format.format())  ;  assertEquals( "a  ,  b  ,  c "  ,  format.format( "a "  ,   "b "  ,   "c "))  ;  assertEquals( "\ "x  ,  y\ "  ,  z "  ,  format.format( "x  ,  y "  ,   "z "))  ;  [CONTEXT]  if  (  len  <  =  0  )  {          if  (  first  )  {  quote  =  true  ;  }  }  else  {  char  c  =  value  .  charAt  (  pos  )  ;      if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )  ||  (  c  >  'z'  )  )  )  {  quote  =  true  ;    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  [ATTENTION]  if  (  c  =  =  '\r'  &&  c  =  =  encapsulator  &&  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }  }    [METHOD]  printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out  
[REPLACE]  if  (  !quote  )  {	[BUGGY]  if  (  quote  )  {[FE]  (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo\n "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "foo\n  baar  ,  ,  ,   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "\n\t  \n "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  if  (  len  <  =  0  )  {          if  (  first  )  {  quote  =  true  ;  }  }  else  {  char  c  =  value  .  charAt  (  pos  )  ;      if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )  ||  (  c  >  'z'  )  )  )  {  quote  =  true  ;    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  [ATTENTION]  if  (  quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }  }    [METHOD]  printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out  
[REPLACE]  if  (  c  <=  '  '  )  {	[BUGGY]  if  (  encapsulator    =  =    '  '  )  {[FE]  (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo\n "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "foo\n  baar  ,  ,  ,   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "\n\t  \n "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  if  (  len  <  =  0  )  {          if  (  first  )  {  quote  =  true  ;  }  }  else  {  char  c  =  value  .  charAt  (  pos  )  ;      if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )  ||  (  c  >  'z'  )  )  )  {  quote  =  true  ;    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        [ATTENTION]  if  (  encapsulator  =  =  '  '  )  {  quote  =  true  ;  }  }  }  }    [METHOD]  printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out  
[REPLACE]  quote  =  true;	[BUGGY]  quote  =  false  ;  [FE]  (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo\n "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "foo\n  baar  ,  ,  ,   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "\n\t  \n "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  if  (  len  <  =  0  )  {          if  (  first  )  {  quote  =  true  ;  }  }  else  {  char  c  =  value  .  charAt  (  pos  )  ;      if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )  ||  (  c  >  'z'  )  )  )  {  quote  =  true  ;    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  [ATTENTION]  quote  =  false  ;  }  }  }  }    [METHOD]  printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out  
[REPLACE]  pos  =  end  -  1;	[BUGGY]  pos  =  end  -len  ;  [FE]  (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo\n "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "foo\n  baar  ,  ,  ,   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "\n\t  \n "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  if  (  len  <  =  0  )  {          if  (  first  )  {  quote  =  true  ;  }  }  else  {  char  c  =  value  .  charAt  (  pos  )  ;      if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )  ||  (  c  >  'z'  )  )  )  {  quote  =  true  ;    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  [ATTENTION]  pos  =  end  -len  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }  }    [METHOD]  printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out  
[ADD]  pos  =  end  -  1;	[BUGGY]  [FE]  String  index  out  of  range:  1  assertEquals( " "  ,  format.format())  ;  assertEquals( "a  ,  b  ,  c "  ,  format.format( "a "  ,   "b "  ,   "c "))  ;  assertEquals( "\ "x  ,  y\ "  ,  z "  ,  format.format( "x  ,  y "  ,   "z "))  ;  [CONTEXT]  if  (  len  <  =  0  )  {          if  (  first  )  {  quote  =  true  ;  }  }  else  {  char  c  =  value  .  charAt  (  pos  )  ;      if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )  ||  (  c  >  'z'  )  )  )  {  quote  =  true  ;    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  [ATTENTION]  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }  }    [METHOD]  printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out  
[REPLACE]  c  =  value  .  charAt  (  pos  )  ;	[BUGGY]  c  =    null  .  charAt  (  pos  )  ;  [CE]  <null>  cannot  be  dereferenced  [CONTEXT]  if  (  len  <  =  0  )  {          if  (  first  )  {  quote  =  true  ;  }  }  else  {  char  c  =  value  .  charAt  (  pos  )  ;      if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )  ||  (  c  >  'z'  )  )  )  {  quote  =  true  ;    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  [ATTENTION]  c  =  null  .  charAt  (  pos  )    ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }  }    [METHOD]  printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out  
[ADD]  c  =  value  .  charAt  (  pos  )  ;	[BUGGY]  [FE]  (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo\n "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "foo\n  baar  ,  ,  ,   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "\n\t  \n "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  if  (  len  <  =  0  )  {          if  (  first  )  {  quote  =  true  ;  }  }  else  {  char  c  =  value  .  charAt  (  pos  )  ;      if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )  ||  (  c  >  'z'  )  )  )  {  quote  =  true  ;    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  [ATTENTION]        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }  }    [METHOD]  printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out  
[REPLACE]  if  (  c  <=  '  '  )  {	[BUGGY]  if  (  c  !  =    '  '  )  {[FE]  AssertionFailedError    expected:<[a  ,  b  ,  c]>  but  was:<[ "a "  ,   "b "  ,   "c "]>  assertEquals( " "  ,  format.format())  ;  assertEquals( "a  ,  b  ,  c "  ,  format.format( "a "  ,   "b "  ,   "c "))  ;  assertEquals( "\ "x  ,  y\ "  ,  z "  ,  format.format( "x  ,  y "  ,   "z "))  ;  [CONTEXT]  if  (  len  <  =  0  )  {          if  (  first  )  {  quote  =  true  ;  }  }  else  {  char  c  =  value  .  charAt  (  pos  )  ;      if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )  ||  (  c  >  'z'  )  )  )  {  quote  =  true  ;    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        [ATTENTION]  if  (  c!  =  '  '  )  {  quote  =  true  ;  }  }  }  }    [METHOD]  printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out  
[ADD]  quote  =  true;  break;	[BUGGY]  break  ;  [FE]  AssertionFailedError    expected:<[ "x  ,  y "]  ,  z>  but  was:<[x  ,  y]  ,  z>  assertEquals( " "  ,  format.format())  ;  assertEquals( "a  ,  b  ,  c "  ,  format.format( "a "  ,   "b "  ,   "c "))  ;  assertEquals( "\ "x  ,  y\ "  ,  z "  ,  format.format( "x  ,  y "  ,   "z "))  ;  [CONTEXT]  if  (  len  <  =  0  )  {          if  (  first  )  {  quote  =  true  ;  }  }  else  {  char  c  =  value  .  charAt  (  pos  )  ;      if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )  ||  (  c  >  'z'  )  )  )  {  quote  =  true  ;    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  [ATTENTION]  break  ;    }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }  }    [METHOD]  printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out  
[REPLACE]  pos  =  end  -  1;	[BUGGY]  pos  =  len  -  1  ;  [FE]  (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo\n "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "foo\n  baar  ,  ,  ,   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "\n\t  \n "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  if  (  len  <  =  0  )  {          if  (  first  )  {  quote  =  true  ;  }  }  else  {  char  c  =  value  .  charAt  (  pos  )  ;      if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )  ||  (  c  >  'z'  )  )  )  {  quote  =  true  ;    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  [ATTENTION]  pos  =  len  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }  }    [METHOD]  printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out  
[REPLACE]  quote  =  true;	[BUGGY]  quote  =  false  ;  [FE]  (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo\n "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "foo\n  baar  ,  ,  ,   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "\n\t  \n "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )  ||  (  c  >  'z'  )  )  )  {  [ATTENTION]  quote  =  false  ;    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }    [METHOD]  printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out  
[REPLACE]  }  else  if  (  c  <=  '#'  )  {	[BUGGY]    else  {[CE]  'else'  without  'if'  [CONTEXT]  if  (  len  <  =  0  )  {          if  (  first  )  {  quote  =  true  ;  }  }  else  {  char  c  =  value  .  charAt  (  pos  )  ;      if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )  ||  (  c  >  'z'  )  )  )  {  quote  =  true  ;    [ATTENTION]  }else  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }  }    [METHOD]  printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out  
[REPLACE]  while  (  pos  <  end  )  {	[BUGGY]  while  (offset  <  =    len  )  {[FE]  String  index  out  of  range:  1  assertEquals( " "  ,  format.format())  ;  assertEquals( "a  ,  b  ,  c "  ,  format.format( "a "  ,   "b "  ,   "c "))  ;  assertEquals( "\ "x  ,  y\ "  ,  z "  ,  format.format( "x  ,  y "  ,   "z "))  ;  [CONTEXT]  }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  [ATTENTION]  while  (  offset<  =  len  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }    [METHOD]  printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out  
[REPLACE]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUGGY]  if  (  c  =  =  '\r'  &&  c  =  =  encapsulator  &&  c  =  =  delim  )  {[FE]  AssertionFailedError    expected:<[ "x  ,  y "]  ,  z>  but  was:<[x  ,  y]  ,  z>  assertEquals( " "  ,  format.format())  ;  assertEquals( "a  ,  b  ,  c "  ,  format.format( "a "  ,   "b "  ,   "c "))  ;  assertEquals( "\ "x  ,  y\ "  ,  z "  ,  format.format( "x  ,  y "  ,   "z "))  ;  [CONTEXT]  }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  [ATTENTION]  if  (  c  =  =  '\r'  &&  c  =  =  encapsulator  &&  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }    [METHOD]  printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out  
[ADD]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {  quote  =  true;  break;  }	[BUGGY]  [FE]  AssertionFailedError    expected:<[ "x  ,  y "]  ,  z>  but  was:<[x  ,  y]  ,  z>  assertEquals( " "  ,  format.format())  ;  assertEquals( "a  ,  b  ,  c "  ,  format.format( "a "  ,   "b "  ,   "c "))  ;  assertEquals( "\ "x  ,  y\ "  ,  z "  ,  format.format( "x  ,  y "  ,   "z "))  ;  [CONTEXT]  }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  [ATTENTION]      pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }    [METHOD]  printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out  
[ADD]  quote  =  true;  break;	[BUGGY]  [FE]  AssertionFailedError    expected:<[ "x  ,  y "]  ,  z>  but  was:<[x  ,  y]  ,  z>  assertEquals( " "  ,  format.format())  ;  assertEquals( "a  ,  b  ,  c "  ,  format.format( "a "  ,   "b "  ,   "c "))  ;  assertEquals( "\ "x  ,  y\ "  ,  z "  ,  format.format( "x  ,  y "  ,   "z "))  ;  [CONTEXT]  }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  [ATTENTION]    }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }    [METHOD]  printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out  
[REPLACE]  if  (  c  <=  '  '  )  {	[BUGGY]  if  (  encapsulator  >  =  encapsulator  )  {[FE]  AssertionFailedError    expected:<[a  ,  b  ,  c]>  but  was:<[ "a "  ,   "b "  ,   "c "]>  assertEquals( " "  ,  format.format())  ;  assertEquals( "a  ,  b  ,  c "  ,  format.format( "a "  ,   "b "  ,   "c "))  ;  assertEquals( "\ "x  ,  y\ "  ,  z "  ,  format.format( "x  ,  y "  ,   "z "))  ;  [CONTEXT]  }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        [ATTENTION]  if  (  encapsulator>  =  encapsulator  )  {  quote  =  true  ;  }  }  }    [METHOD]  printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out  
[REPLACE]  pos  =  end  -  1;	[BUGGY]  pos  =  end    =  =    1  ;  [CE]  incompatible  types  [CONTEXT]  }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  [ATTENTION]  pos  =  end  =  =  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }    [METHOD]  printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out  
[REPLACE]  if  (  c  <=  '  '  )  {	[BUGGY]  if  (  encapsulator  >  encapsulator  )  {[FE]  (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo\n "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "foo\n  baar  ,  ,  ,   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "\n\t  \n "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        [ATTENTION]  if  (  encapsulator>  encapsulator  )  {  quote  =  true  ;  }  }  }    [METHOD]  printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out  
[ADD]  c  =  value  .  charAt  (  pos  )  ;	[BUGGY]  [FE]  AssertionFailedError    expected:<[ "x  ,  y "]  ,  z>  but  was:<[x  ,  y]  ,  z>  assertEquals( " "  ,  format.format())  ;  assertEquals( "a  ,  b  ,  c "  ,  format.format( "a "  ,   "b "  ,   "c "))  ;  assertEquals( "\ "x  ,  y\ "  ,  z "  ,  format.format( "x  ,  y "  ,   "z "))  ;  [CONTEXT]  }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  [ATTENTION]  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }    [METHOD]  printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out  
[REPLACE]  pos  =  end  -  1;	[BUGGY]  pos  =  end  -len  ;  [FE]  (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo\n "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "foo\n  baar  ,  ,  ,   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "\n\t  \n "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  [ATTENTION]  pos  =  end  -len  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }    [METHOD]  printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out  
[REPLACE]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUGGY]  if  (  c  =  =  '\n'  )  {[FE]  AssertionFailedError    expected:<[ "x  ,  y "]  ,  z>  but  was:<[x  ,  y]  ,  z>  assertEquals( " "  ,  format.format())  ;  assertEquals( "a  ,  b  ,  c "  ,  format.format( "a "  ,   "b "  ,   "c "))  ;  assertEquals( "\ "x  ,  y\ "  ,  z "  ,  format.format( "x  ,  y "  ,   "z "))  ;  [CONTEXT]  if  (  len  <  =  0  )  {          if  (  first  )  {  quote  =  true  ;  }  }  else  {  char  c  =  value  .  charAt  (  pos  )  ;      if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )  ||  (  c  >  'z'  )  )  )  {  quote  =  true  ;    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  [ATTENTION]  if  (  c  =  =  '\n'  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }  }    [METHOD]  printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out  
[REMOVE]  	[BUGGY]  if  (  c  =  =  '\n'  )  {      c  =  'n'  ;  }else      if  (  c  =  =  '\r'  )  {          c  =  'r'  ;      }[FE]  (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo\n "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "foo\n  baar  ,  ,  ,   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "\n\t  \n "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  if  (  len  <  =  0  )  {          if  (  first  )  {  quote  =  true  ;  }  }  else  {  char  c  =  value  .  charAt  (  pos  )  ;      if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )  ||  (  c  >  'z'  )  )  )  {  quote  =  true  ;    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  [ATTENTION]  if  (  !quote  )  {  if  (  c  =  =  '\n'  )  {  c  =  'n'  ;  }else  if  (  c  =  =  '\r'  )  {  c  =  'r'  ;  }pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }    [METHOD]  printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out  
[REMOVE]  	[BUGGY]  if  (  first  )  {      quote  =  true  ;  }[FE]  (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo\n "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "foo\n  baar  ,  ,  ,   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "\n\t  \n "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  if  (  len  <  =  0  )  {          if  (  first  )  {  quote  =  true  ;  }  }  else  {  char  c  =  value  .  charAt  (  pos  )  ;      if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )  ||  (  c  >  'z'  )  )  )  {  quote  =  true  ;    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        [ATTENTION]  if  (  c  <  =  '  '  )  {  if  (  first  )  {  quote  =  true  ;  }quote  =  true  ;  }  }  }    [METHOD]  printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out  
[REPLACE]  pos  =  end  -  1;	[BUGGY]  pos  =  len  -  1  ;  [FE]  (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo\n "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "foo\n  baar  ,  ,  ,   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "\n\t  \n "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  if  (  len  <  =  0  )  {          if  (  first  )  {  quote  =  true  ;  }  }  else  {  char  c  =  value  .  charAt  (  pos  )  ;      if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )  ||  (  c  >  'z'  )  )  )  {  quote  =  true  ;    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  [ATTENTION]  pos  =  len  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }  }    [METHOD]  printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out  
[REPLACE]  if  (  c  <=  '  '  )  {	[BUGGY]  if  (  c    =  =    '  '  )  {[FE]  (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo\n "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "foo\n  baar  ,  ,  ,   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "\n\t  \n "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  if  (  len  <  =  0  )  {          if  (  first  )  {  quote  =  true  ;  }  }  else  {  char  c  =  value  .  charAt  (  pos  )  ;      if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )  ||  (  c  >  'z'  )  )  )  {  quote  =  true  ;    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        [ATTENTION]  if  (  c  =  =  '  '  )  {  quote  =  true  ;  }  }  }  }    [METHOD]  printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out  
[ADD]  if  (  c  <=  '  '  )  {  quote  =  true;  }	[BUGGY]  [FE]  (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo\n "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "foo\n  baar  ,  ,  ,   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "\n\t  \n "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  if  (  len  <  =  0  )  {          if  (  first  )  {  quote  =  true  ;  }  }  else  {  char  c  =  value  .  charAt  (  pos  )  ;      if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )  ||  (  c  >  'z'  )  )  )  {  quote  =  true  ;    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        [ATTENTION]    }  }  }    [METHOD]  printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out  
[ADD]  quote  =  true;	[BUGGY]  [FE]  (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo\n "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "foo\n  baar  ,  ,  ,   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "\n\t  \n "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  if  (  len  <  =  0  )  {          if  (  first  )  {  quote  =  true  ;  }  }  else  {  char  c  =  value  .  charAt  (  pos  )  ;      if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )  ||  (  c  >  'z'  )  )  )  {  quote  =  true  ;    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  [ATTENTION]  }  }  }  }    [METHOD]  printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out  
[REPLACE]  quote  =  true;	[BUGGY]  quote  =  false  ;  [FE]  (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo\n "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "foo\n  baar  ,  ,  ,   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "\n\t  \n "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  if  (  len  <  =  0  )  {          if  (  first  )  {  quote  =  true  ;  }  }  else  {  char  c  =  value  .  charAt  (  pos  )  ;      if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )  ||  (  c  >  'z'  )  )  )  {  [ATTENTION]  quote  =  false  ;    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }  }    [METHOD]  printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out  
[ADD]  quote  =  true;	[BUGGY]  [FE]  (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo\n "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "foo\n  baar  ,  ,  ,   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "\n\t  \n "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  if  (  len  <  =  0  )  {          if  (  first  )  {  quote  =  true  ;  }  }  else  {  char  c  =  value  .  charAt  (  pos  )  ;      if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )  ||  (  c  >  'z'  )  )  )  {  quote  =  true  ;    }  else  if  (  c  <  =  '#'  )  {        [ATTENTION]  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }  }    [METHOD]  printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out  
[REPLACE]  char  c  =  value  .  charAt  (  pos  )  ;	[BUGGY]  for  (  String  value  :  values  )  {  print  (  value  )  ;  [CE]  illegal  start  of  expression  [CONTEXT]  if  (  len  <  =  0  )  {          if  (  first  )  {  quote  =  true  ;  }  }  else  {  [ATTENTION]  for  (  String  value  :  values  )  {  print  (  value  )    ;      if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )  ||  (  c  >  'z'  )  )  )  {  quote  =  true  ;    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }  }    [METHOD]  printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out  
[REPLACE]  if  (  first  )  {	[BUGGY]  if  (  true  )  {[FE]  (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo\n "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "foo\n  baar  ,  ,  ,   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "\n\t  \n "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  void  printAndEncapsulate  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  boolean  first  =  newLine  ;  //  is  this  the  first  value  on  this  line?  boolean  quote  =  false  ;  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  encapsulator  =  format  .  getEncapsulator  (  )  ;    if  (  len  <  =  0  )  {          [ATTENTION]  if  (  true  )  {  quote  =  true  ;  }  }  else  {  char  c  =  value  .  charAt  (  pos  )  ;      if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )  ||  (  c  >  'z'  )  )  )  {  quote  =  true  ;    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }  }  if  (  !quote  )  {    out  .  append  (  value  ,  start  ,  end  )  ;  return  ;  }    out  .  append  (  encapsulator  )  ;        while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  encapsulator  )  {      out  .  append  (  value  ,  start  ,  pos  +  1  )  ;      start  =  pos  ;  }  pos++  ;  }    out  .  append  (  value  ,  start  ,  pos  )  ;  out  .  append  (  encapsulator  )  ;  }    [METHOD]  printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out  
[REMOVE]  	[BUGGY]  if  (  c  <  =  '  '  )  {      quote  =  true  ;  }[CE]  cannot  find  symbol  c  [CONTEXT]  void  printAndEncapsulate  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  boolean  first  =  newLine  ;  //  is  this  the  first  value  on  this  line?  boolean  quote  =  false  ;  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  encapsulator  =  format  .  getEncapsulator  (  )  ;    if  (  len  <  =  0  )  {          [ATTENTION]  if  (  first  )  {  if  (  c  <  =  '  '  )  {  quote  =  true  ;  }quote  =  true  ;  }  }  else  {  char  c  =  value  .  charAt  (  pos  )  ;      if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )  ||  (  c  >  'z'  )  )  )  {  quote  =  true  ;    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }  }  if  (  !quote  )  {    out  .  append  (  value  ,  start  ,  end  )  ;  return  ;  }    out  .  append  (  encapsulator  )  ;        while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  encapsulator  )  {      out  .  append  (  value  ,  start  ,  pos  +  1  )  ;      start  =  pos  ;  }  pos++  ;  }    out  .  append  (  value  ,  start  ,  pos  )  ;  out  .  append  (  encapsulator  )  ;      [METHOD]  printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out  
[REPLACE]  quote  =  true;	[BUGGY]  quote  =  false  ;  [FE]  (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo\n "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "foo\n  baar  ,  ,  ,   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "\n\t  \n "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  void  printAndEncapsulate  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  boolean  first  =  newLine  ;  //  is  this  the  first  value  on  this  line?  boolean  quote  =  false  ;  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  encapsulator  =  format  .  getEncapsulator  (  )  ;    if  (  len  <  =  0  )  {          if  (  first  )  {  [ATTENTION]  quote  =  false  ;  }  }  else  {  char  c  =  value  .  charAt  (  pos  )  ;      if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )  ||  (  c  >  'z'  )  )  )  {  quote  =  true  ;    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }  }  if  (  !quote  )  {    out  .  append  (  value  ,  start  ,  end  )  ;  return  ;  }    out  .  append  (  encapsulator  )  ;        while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  encapsulator  )  {      out  .  append  (  value  ,  start  ,  pos  +  1  )  ;      start  =  pos  ;  }  pos++  ;  }    out  .  append  (  value  ,  start  ,  pos  )  ;  out  .  append  (  encapsulator  )  ;  }    [METHOD]  printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out  
[ADD]  quote  =  true;	[BUGGY]  [FE]  (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo\n "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "foo\n  baar  ,  ,  ,   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "\n\t  \n "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  void  printAndEncapsulate  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  boolean  first  =  newLine  ;  //  is  this  the  first  value  on  this  line?  boolean  quote  =  false  ;  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  encapsulator  =  format  .  getEncapsulator  (  )  ;    if  (  len  <  =  0  )  {          if  (  first  )  {  [ATTENTION]  }  }  else  {  char  c  =  value  .  charAt  (  pos  )  ;      if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )  ||  (  c  >  'z'  )  )  )  {  quote  =  true  ;    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }  }  if  (  !quote  )  {    out  .  append  (  value  ,  start  ,  end  )  ;  return  ;  }    out  .  append  (  encapsulator  )  ;        while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  encapsulator  )  {      out  .  append  (  value  ,  start  ,  pos  +  1  )  ;      start  =  pos  ;  }  pos++  ;  }    out  .  append  (  value  ,  start  ,  pos  )  ;  out  .  append  (  encapsulator  )  ;  }    [METHOD]  printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out  
[REPLACE]  if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )	[BUGGY]  if  (  first  ||  (  c  <  '0'  ||  (  c  >  '9'  ||  c  <  'A'  )  ||  (  c  >  'Z'  ||  c  <  'a'  )[FE]  AssertionFailedError    expected:<[a  ,  b  ,  c]>  but  was:<[ "a "  ,   "b "  ,   "c "]>  assertEquals( " "  ,  format.format())  ;  assertEquals( "a  ,  b  ,  c "  ,  format.format( "a "  ,   "b "  ,   "c "))  ;  assertEquals( "\ "x  ,  y\ "  ,  z "  ,  format.format( "x  ,  y "  ,   "z "))  ;  [CONTEXT]  void  printAndEncapsulate  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  boolean  first  =  newLine  ;  //  is  this  the  first  value  on  this  line?  boolean  quote  =  false  ;  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  encapsulator  =  format  .  getEncapsulator  (  )  ;    if  (  len  <  =  0  )  {          if  (  first  )  {  quote  =  true  ;  }  }  else  {  char  c  =  value  .  charAt  (  pos  )  ;      [ATTENTION]  if  (  first  ||  (  c  <  '0'  ||  (  c  >  '9'  ||  c  <  'A'  )  ||  (  c  >  'Z'  ||  c  <  'a'  )      ||  (  c  >  'z'  )  )  )  {  quote  =  true  ;    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }  }  if  (  !quote  )  {    out  .  append  (  value  ,  start  ,  end  )  ;  return  ;  }    out  .  append  (  encapsulator  )  ;        while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  encapsulator  )  {      out  .  append  (  value  ,  start  ,  pos  +  1  )  ;      start  =  pos  ;  }  pos++  ;  }    out  .  append  (  value  ,  start  ,  pos  )  ;  out  .  append  (  encapsulator  )  ;  }    [METHOD]  printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out  
[REPLACE]  while  (  pos  <  end  )  {	[BUGGY]  while  (  pos  !  =    end  )  {[FE]  (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo\n "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "foo\n  baar  ,  ,  ,   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "\n\t  \n "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  void  printAndEncapsulate  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  boolean  first  =  newLine  ;  //  is  this  the  first  value  on  this  line?  boolean  quote  =  false  ;  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  encapsulator  =  format  .  getEncapsulator  (  )  ;    if  (  len  <  =  0  )  {          if  (  first  )  {  quote  =  true  ;  }  }  else  {  char  c  =  value  .  charAt  (  pos  )  ;      if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )  ||  (  c  >  'z'  )  )  )  {  quote  =  true  ;    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  [ATTENTION]  while  (  pos!  =  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }  }  if  (  !quote  )  {    out  .  append  (  value  ,  start  ,  end  )  ;  return  ;  }    out  .  append  (  encapsulator  )  ;        while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  encapsulator  )  {      out  .  append  (  value  ,  start  ,  pos  +  1  )  ;      start  =  pos  ;  }  pos++  ;  }    out  .  append  (  value  ,  start  ,  pos  )  ;  out  .  append  (  encapsulator  )  ;  }    [METHOD]  printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out  
[REPLACE]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUGGY]  if  (  c  =  =  '\r'  &&  c  =  =  encapsulator  &&  c  =  =  delim  )  {[FE]  AssertionFailedError    expected:<[ "x  ,  y "]  ,  z>  but  was:<[x  ,  y]  ,  z>  assertEquals( " "  ,  format.format())  ;  assertEquals( "a  ,  b  ,  c "  ,  format.format( "a "  ,   "b "  ,   "c "))  ;  assertEquals( "\ "x  ,  y\ "  ,  z "  ,  format.format( "x  ,  y "  ,   "z "))  ;  [CONTEXT]  void  printAndEncapsulate  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  boolean  first  =  newLine  ;  //  is  this  the  first  value  on  this  line?  boolean  quote  =  false  ;  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  encapsulator  =  format  .  getEncapsulator  (  )  ;    if  (  len  <  =  0  )  {          if  (  first  )  {  quote  =  true  ;  }  }  else  {  char  c  =  value  .  charAt  (  pos  )  ;      if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )  ||  (  c  >  'z'  )  )  )  {  quote  =  true  ;    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  [ATTENTION]  if  (  c  =  =  '\r'  &&  c  =  =  encapsulator  &&  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }  }  if  (  !quote  )  {    out  .  append  (  value  ,  start  ,  end  )  ;  return  ;  }    out  .  append  (  encapsulator  )  ;        while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  encapsulator  )  {      out  .  append  (  value  ,  start  ,  pos  +  1  )  ;      start  =  pos  ;  }  pos++  ;  }    out  .  append  (  value  ,  start  ,  pos  )  ;  out  .  append  (  encapsulator  )  ;  }    [METHOD]  printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out  
[REPLACE]  }  else  if  (  c  <=  '#'  )  {	[BUGGY]    if  (encapsulator    =  =    '#'  )  {[FE]  (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo\n "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "foo\n  baar  ,  ,  ,   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "\n\t  \n "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  void  printAndEncapsulate  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  boolean  first  =  newLine  ;  //  is  this  the  first  value  on  this  line?  boolean  quote  =  false  ;  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  encapsulator  =  format  .  getEncapsulator  (  )  ;    if  (  len  <  =  0  )  {          if  (  first  )  {  quote  =  true  ;  }  }  else  {  char  c  =  value  .  charAt  (  pos  )  ;      if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )  ||  (  c  >  'z'  )  )  )  {  quote  =  true  ;    [ATTENTION]  }if  (  encapsulator  =  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }  }  if  (  !quote  )  {    out  .  append  (  value  ,  start  ,  end  )  ;  return  ;  }    out  .  append  (  encapsulator  )  ;        while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  encapsulator  )  {      out  .  append  (  value  ,  start  ,  pos  +  1  )  ;      start  =  pos  ;  }  pos++  ;  }    out  .  append  (  value  ,  start  ,  pos  )  ;  out  .  append  (  encapsulator  )  ;  }    [METHOD]  printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out  
[REPLACE]  while  (  pos  <  end  )  {	[BUGGY]  while  (  pos  >  offset  )  {[FE]  AssertionFailedError    expected:<[ "x  ,  y "]  ,  z>  but  was:<[x  ,  y]  ,  z>  assertEquals( " "  ,  format.format())  ;  assertEquals( "a  ,  b  ,  c "  ,  format.format( "a "  ,   "b "  ,   "c "))  ;  assertEquals( "\ "x  ,  y\ "  ,  z "  ,  format.format( "x  ,  y "  ,   "z "))  ;  [CONTEXT]  }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  [ATTENTION]  while  (  pos>  offset  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }    [METHOD]  printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out  
[ADD]  quote  =  true;	[BUGGY]  [FE]  AssertionFailedError    expected:<[ "x  ,  y "]  ,  z>  but  was:<[x  ,  y]  ,  z>  assertEquals( " "  ,  format.format())  ;  assertEquals( "a  ,  b  ,  c "  ,  format.format( "a "  ,   "b "  ,   "c "))  ;  assertEquals( "\ "x  ,  y\ "  ,  z "  ,  format.format( "x  ,  y "  ,   "z "))  ;  [CONTEXT]  }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  [ATTENTION]  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }    [METHOD]  printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out  
[REPLACE]  if  (  c  <=  '  '  )  {	[BUGGY]  if  (  c    =  =    '  '  )  {[FE]  (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo\n "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "foo\n  baar  ,  ,  ,   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "\n\t  \n "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        [ATTENTION]  if  (  c  =  =  '  '  )  {  quote  =  true  ;  }  }  }    [METHOD]  printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out  
[REPLACE]  if  (  c  <=  '  '  )  {	[BUGGY]  if  (encapsulator  >  =    '  '  )  {[FE]  AssertionFailedError    expected:<[a  ,  b  ,  c]>  but  was:<[ "a "  ,   "b "  ,   "c "]>  assertEquals( " "  ,  format.format())  ;  assertEquals( "a  ,  b  ,  c "  ,  format.format( "a "  ,   "b "  ,   "c "))  ;  assertEquals( "\ "x  ,  y\ "  ,  z "  ,  format.format( "x  ,  y "  ,   "z "))  ;  [CONTEXT]  }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        [ATTENTION]  if  (  encapsulator>  =  '  '  )  {  quote  =  true  ;  }  }  }    [METHOD]  printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out  
[REMOVE]  	[BUGGY]  if  (  first  )  {      quote  =  true  ;  }[FE]  (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo\n "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "foo\n  baar  ,  ,  ,   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "\n\t  \n "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        [ATTENTION]  if  (  c  <  =  '  '  )  {  if  (  first  )  {  quote  =  true  ;  }quote  =  true  ;  }  }    [METHOD]  printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out  
[REPLACE]  quote  =  true;	[BUGGY]  quote  =  false  ;  [FE]  (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo\n "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "foo\n  baar  ,  ,  ,   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "\n\t  \n "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  void  printAndEncapsulate  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  boolean  first  =  newLine  ;  //  is  this  the  first  value  on  this  line?  boolean  quote  =  false  ;  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  encapsulator  =  format  .  getEncapsulator  (  )  ;    if  (  len  <  =  0  )  {          if  (  first  )  {  quote  =  true  ;  }  }  else  {  char  c  =  value  .  charAt  (  pos  )  ;      if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )  ||  (  c  >  'z'  )  )  )  {  quote  =  true  ;    }  else  if  (  c  <  =  '#'  )  {        [ATTENTION]  quote  =  false  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }  }  if  (  !quote  )  {    out  .  append  (  value  ,  start  ,  end  )  ;  return  ;  }    out  .  append  (  encapsulator  )  ;        while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  encapsulator  )  {      out  .  append  (  value  ,  start  ,  pos  +  1  )  ;      start  =  pos  ;  }  pos++  ;  }    out  .  append  (  value  ,  start  ,  pos  )  ;  out  .  append  (  encapsulator  )  ;  }    [METHOD]  printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out  
[REPLACE]  if  (  !quote  )  {	[BUGGY]  if  (  quote  )  {[FE]  (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo\n "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "foo\n  baar  ,  ,  ,   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "\n\t  \n "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  void  printAndEncapsulate  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  boolean  first  =  newLine  ;  //  is  this  the  first  value  on  this  line?  boolean  quote  =  false  ;  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  encapsulator  =  format  .  getEncapsulator  (  )  ;    if  (  len  <  =  0  )  {          if  (  first  )  {  quote  =  true  ;  }  }  else  {  char  c  =  value  .  charAt  (  pos  )  ;      if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )  ||  (  c  >  'z'  )  )  )  {  quote  =  true  ;    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  [ATTENTION]  if  (  quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }  }  if  (  !quote  )  {    out  .  append  (  value  ,  start  ,  end  )  ;  return  ;  }    out  .  append  (  encapsulator  )  ;        while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  encapsulator  )  {      out  .  append  (  value  ,  start  ,  pos  +  1  )  ;      start  =  pos  ;  }  pos++  ;  }    out  .  append  (  value  ,  start  ,  pos  )  ;  out  .  append  (  encapsulator  )  ;  }    [METHOD]  printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out  
[REMOVE]  	[BUGGY]  if  (  c  =  =  '\n'  )  {      c  =  'n'  ;  }else      if  (  c  =  =  '\r'  )  {          c  =  'r'  ;      }[FE]  (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo\n "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "foo\n  baar  ,  ,  ,   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "\n\t  \n "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  void  printAndEncapsulate  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  boolean  first  =  newLine  ;  //  is  this  the  first  value  on  this  line?  boolean  quote  =  false  ;  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  encapsulator  =  format  .  getEncapsulator  (  )  ;    if  (  len  <  =  0  )  {          if  (  first  )  {  quote  =  true  ;  }  }  else  {  char  c  =  value  .  charAt  (  pos  )  ;      if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )  ||  (  c  >  'z'  )  )  )  {  quote  =  true  ;    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  [ATTENTION]  if  (  !quote  )  {  if  (  c  =  =  '\n'  )  {  c  =  'n'  ;  }else  if  (  c  =  =  '\r'  )  {  c  =  'r'  ;  }pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }  }  if  (  !quote  )  {    out  .  append  (  value  ,  start  ,  end  )  ;  return  ;  }    out  .  append  (  encapsulator  )  ;        while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  encapsulator  )  {      out  .  append  (  value  ,  start  ,  pos  +  1  )  ;      start  =  pos  ;  }  pos++  ;  }    out  .  append  (  value  ,  start  ,  pos  )  ;  out  .  append  (  encapsulator  )  ;      [METHOD]  printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out  
[REPLACE]  if  (  c  <=  '  '  )  {	[BUGGY]  if  (  c    =  =    '  '  )  {[FE]  (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo\n "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "foo\n  baar  ,  ,  ,   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "\n\t  \n "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  void  printAndEncapsulate  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  boolean  first  =  newLine  ;  //  is  this  the  first  value  on  this  line?  boolean  quote  =  false  ;  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  encapsulator  =  format  .  getEncapsulator  (  )  ;    if  (  len  <  =  0  )  {          if  (  first  )  {  quote  =  true  ;  }  }  else  {  char  c  =  value  .  charAt  (  pos  )  ;      if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )  ||  (  c  >  'z'  )  )  )  {  quote  =  true  ;    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        [ATTENTION]  if  (  c  =  =  '  '  )  {  quote  =  true  ;  }  }  }  }  if  (  !quote  )  {    out  .  append  (  value  ,  start  ,  end  )  ;  return  ;  }    out  .  append  (  encapsulator  )  ;        while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  encapsulator  )  {      out  .  append  (  value  ,  start  ,  pos  +  1  )  ;      start  =  pos  ;  }  pos++  ;  }    out  .  append  (  value  ,  start  ,  pos  )  ;  out  .  append  (  encapsulator  )  ;  }    [METHOD]  printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out  
[REPLACE]  quote  =  true;	[BUGGY]  quote  =  false  ;  [FE]  (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo\n "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "foo\n  baar  ,  ,  ,   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "\n\t  \n "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  void  printAndEncapsulate  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  boolean  first  =  newLine  ;  //  is  this  the  first  value  on  this  line?  boolean  quote  =  false  ;  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  encapsulator  =  format  .  getEncapsulator  (  )  ;    if  (  len  <  =  0  )  {          if  (  first  )  {  quote  =  true  ;  }  }  else  {  char  c  =  value  .  charAt  (  pos  )  ;      if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )  ||  (  c  >  'z'  )  )  )  {  quote  =  true  ;    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  [ATTENTION]  quote  =  false  ;  }  }  }  }  if  (  !quote  )  {    out  .  append  (  value  ,  start  ,  end  )  ;  return  ;  }    out  .  append  (  encapsulator  )  ;        while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  encapsulator  )  {      out  .  append  (  value  ,  start  ,  pos  +  1  )  ;      start  =  pos  ;  }  pos++  ;  }    out  .  append  (  value  ,  start  ,  pos  )  ;  out  .  append  (  encapsulator  )  ;  }    [METHOD]  printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out  
[REPLACE]  pos  =  end  -  1;	[BUGGY]  pos  =  end  |  2  ;  [FE]  String  index  out  of  range:  3  assertEquals( " "  ,  format.format())  ;  assertEquals( "a  ,  b  ,  c "  ,  format.format( "a "  ,   "b "  ,   "c "))  ;  assertEquals( "\ "x  ,  y\ "  ,  z "  ,  format.format( "x  ,  y "  ,   "z "))  ;  [CONTEXT]  void  printAndEncapsulate  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  boolean  first  =  newLine  ;  //  is  this  the  first  value  on  this  line?  boolean  quote  =  false  ;  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  encapsulator  =  format  .  getEncapsulator  (  )  ;    if  (  len  <  =  0  )  {          if  (  first  )  {  quote  =  true  ;  }  }  else  {  char  c  =  value  .  charAt  (  pos  )  ;      if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )  ||  (  c  >  'z'  )  )  )  {  quote  =  true  ;    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  [ATTENTION]  pos  =  end|2  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }  }  if  (  !quote  )  {    out  .  append  (  value  ,  start  ,  end  )  ;  return  ;  }    out  .  append  (  encapsulator  )  ;        while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  encapsulator  )  {      out  .  append  (  value  ,  start  ,  pos  +  1  )  ;      start  =  pos  ;  }  pos++  ;  }    out  .  append  (  value  ,  start  ,  pos  )  ;  out  .  append  (  encapsulator  )  ;  }    [METHOD]  printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out  
[ADD]  pos  =  end  -  1;	[BUGGY]  [FE]  String  index  out  of  range:  1  assertEquals( " "  ,  format.format())  ;  assertEquals( "a  ,  b  ,  c "  ,  format.format( "a "  ,   "b "  ,   "c "))  ;  assertEquals( "\ "x  ,  y\ "  ,  z "  ,  format.format( "x  ,  y "  ,   "z "))  ;  [CONTEXT]  void  printAndEncapsulate  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  boolean  first  =  newLine  ;  //  is  this  the  first  value  on  this  line?  boolean  quote  =  false  ;  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  encapsulator  =  format  .  getEncapsulator  (  )  ;    if  (  len  <  =  0  )  {          if  (  first  )  {  quote  =  true  ;  }  }  else  {  char  c  =  value  .  charAt  (  pos  )  ;      if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )  ||  (  c  >  'z'  )  )  )  {  quote  =  true  ;    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  [ATTENTION]  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }  }  if  (  !quote  )  {    out  .  append  (  value  ,  start  ,  end  )  ;  return  ;  }    out  .  append  (  encapsulator  )  ;        while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  encapsulator  )  {      out  .  append  (  value  ,  start  ,  pos  +  1  )  ;      start  =  pos  ;  }  pos++  ;  }    out  .  append  (  value  ,  start  ,  pos  )  ;  out  .  append  (  encapsulator  )  ;  }    [METHOD]  printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out  
[REPLACE]  c  =  value  .  charAt  (  pos  )  ;	[BUGGY]  c  =    null  .  charAt  (  pos  )  ;  [CE]  <null>  cannot  be  dereferenced  [CONTEXT]  void  printAndEncapsulate  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  boolean  first  =  newLine  ;  //  is  this  the  first  value  on  this  line?  boolean  quote  =  false  ;  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  encapsulator  =  format  .  getEncapsulator  (  )  ;    if  (  len  <  =  0  )  {          if  (  first  )  {  quote  =  true  ;  }  }  else  {  char  c  =  value  .  charAt  (  pos  )  ;      if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )  ||  (  c  >  'z'  )  )  )  {  quote  =  true  ;    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  [ATTENTION]  c  =  null  .  charAt  (  pos  )    ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }  }  if  (  !quote  )  {    out  .  append  (  value  ,  start  ,  end  )  ;  return  ;  }    out  .  append  (  encapsulator  )  ;        while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  encapsulator  )  {      out  .  append  (  value  ,  start  ,  pos  +  1  )  ;      start  =  pos  ;  }  pos++  ;  }    out  .  append  (  value  ,  start  ,  pos  )  ;  out  .  append  (  encapsulator  )  ;  }    [METHOD]  printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out  
[REPLACE]  if  (  c  <=  '  '  )  {	[BUGGY]  if  (  encapsulator  >  '  '  )  {[FE]  AssertionFailedError    expected:<[a  ,  b  ,  c]>  but  was:<[ "a "  ,   "b "  ,   "c "]>  assertEquals( " "  ,  format.format())  ;  assertEquals( "a  ,  b  ,  c "  ,  format.format( "a "  ,   "b "  ,   "c "))  ;  assertEquals( "\ "x  ,  y\ "  ,  z "  ,  format.format( "x  ,  y "  ,   "z "))  ;  [CONTEXT]  void  printAndEncapsulate  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  boolean  first  =  newLine  ;  //  is  this  the  first  value  on  this  line?  boolean  quote  =  false  ;  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  encapsulator  =  format  .  getEncapsulator  (  )  ;    if  (  len  <  =  0  )  {          if  (  first  )  {  quote  =  true  ;  }  }  else  {  char  c  =  value  .  charAt  (  pos  )  ;      if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )  ||  (  c  >  'z'  )  )  )  {  quote  =  true  ;    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        [ATTENTION]  if  (  encapsulator>'  '  )  {  quote  =  true  ;  }  }  }  }  if  (  !quote  )  {    out  .  append  (  value  ,  start  ,  end  )  ;  return  ;  }    out  .  append  (  encapsulator  )  ;        while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  encapsulator  )  {      out  .  append  (  value  ,  start  ,  pos  +  1  )  ;      start  =  pos  ;  }  pos++  ;  }    out  .  append  (  value  ,  start  ,  pos  )  ;  out  .  append  (  encapsulator  )  ;  }    [METHOD]  printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out  
[ADD]  if  (  c  <=  '  '  )  {  quote  =  true;  }	[BUGGY]  quote  =  true  ;  [FE]  AssertionFailedError    expected:<[a  ,  b  ,  c]>  but  was:<[ "a "  ,   "b "  ,   "c "]>  assertEquals( " "  ,  format.format())  ;  assertEquals( "a  ,  b  ,  c "  ,  format.format( "a "  ,   "b "  ,   "c "))  ;  assertEquals( "\ "x  ,  y\ "  ,  z "  ,  format.format( "x  ,  y "  ,   "z "))  ;  [CONTEXT]  void  printAndEncapsulate  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  boolean  first  =  newLine  ;  //  is  this  the  first  value  on  this  line?  boolean  quote  =  false  ;  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  encapsulator  =  format  .  getEncapsulator  (  )  ;    if  (  len  <  =  0  )  {          if  (  first  )  {  quote  =  true  ;  }  }  else  {  char  c  =  value  .  charAt  (  pos  )  ;      if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )  ||  (  c  >  'z'  )  )  )  {  quote  =  true  ;    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        [ATTENTION]  quote  =  true  ;    }  }  }  if  (  !quote  )  {    out  .  append  (  value  ,  start  ,  end  )  ;  return  ;  }    out  .  append  (  encapsulator  )  ;        while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  encapsulator  )  {      out  .  append  (  value  ,  start  ,  pos  +  1  )  ;      start  =  pos  ;  }  pos++  ;  }    out  .  append  (  value  ,  start  ,  pos  )  ;  out  .  append  (  encapsulator  )  ;  }    [METHOD]  printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out  
[ADD]  quote  =  true;	[BUGGY]  [FE]  (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo\n "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "foo\n  baar  ,  ,  ,   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "\n\t  \n "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  void  printAndEncapsulate  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  boolean  first  =  newLine  ;  //  is  this  the  first  value  on  this  line?  boolean  quote  =  false  ;  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  encapsulator  =  format  .  getEncapsulator  (  )  ;    if  (  len  <  =  0  )  {          if  (  first  )  {  quote  =  true  ;  }  }  else  {  char  c  =  value  .  charAt  (  pos  )  ;      if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )  ||  (  c  >  'z'  )  )  )  {  quote  =  true  ;    }  else  if  (  c  <  =  '#'  )  {        [ATTENTION]  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }  }  if  (  !quote  )  {    out  .  append  (  value  ,  start  ,  end  )  ;  return  ;  }    out  .  append  (  encapsulator  )  ;        while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  encapsulator  )  {      out  .  append  (  value  ,  start  ,  pos  +  1  )  ;      start  =  pos  ;  }  pos++  ;  }    out  .  append  (  value  ,  start  ,  pos  )  ;  out  .  append  (  encapsulator  )  ;  }    [METHOD]  printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out  
[ADD]  quote  =  true;	[BUGGY]  [FE]  AssertionFailedError    expected:<[ "x  ,  y "]  ,  z>  but  was:<[x  ,  y]  ,  z>  assertEquals( " "  ,  format.format())  ;  assertEquals( "a  ,  b  ,  c "  ,  format.format( "a "  ,   "b "  ,   "c "))  ;  assertEquals( "\ "x  ,  y\ "  ,  z "  ,  format.format( "x  ,  y "  ,   "z "))  ;  [CONTEXT]  void  printAndEncapsulate  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  boolean  first  =  newLine  ;  //  is  this  the  first  value  on  this  line?  boolean  quote  =  false  ;  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  encapsulator  =  format  .  getEncapsulator  (  )  ;    if  (  len  <  =  0  )  {          if  (  first  )  {  quote  =  true  ;  }  }  else  {  char  c  =  value  .  charAt  (  pos  )  ;      if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )  ||  (  c  >  'z'  )  )  )  {  quote  =  true  ;    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  [ATTENTION]  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }  }  if  (  !quote  )  {    out  .  append  (  value  ,  start  ,  end  )  ;  return  ;  }    out  .  append  (  encapsulator  )  ;        while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  encapsulator  )  {      out  .  append  (  value  ,  start  ,  pos  +  1  )  ;      start  =  pos  ;  }  pos++  ;  }    out  .  append  (  value  ,  start  ,  pos  )  ;  out  .  append  (  encapsulator  )  ;  }    [METHOD]  printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out  
[REPLACE]  pos  =  end  -  1;	[BUGGY]  pos  =  len  -  0  ;  [FE]  String  index  out  of  range:  1  assertEquals( " "  ,  format.format())  ;  assertEquals( "a  ,  b  ,  c "  ,  format.format( "a "  ,   "b "  ,   "c "))  ;  assertEquals( "\ "x  ,  y\ "  ,  z "  ,  format.format( "x  ,  y "  ,   "z "))  ;  [CONTEXT]  void  printAndEncapsulate  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  boolean  first  =  newLine  ;  //  is  this  the  first  value  on  this  line?  boolean  quote  =  false  ;  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  encapsulator  =  format  .  getEncapsulator  (  )  ;    if  (  len  <  =  0  )  {          if  (  first  )  {  quote  =  true  ;  }  }  else  {  char  c  =  value  .  charAt  (  pos  )  ;      if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )  ||  (  c  >  'z'  )  )  )  {  quote  =  true  ;    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  [ATTENTION]  pos  =  len  -  0  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }  }  if  (  !quote  )  {    out  .  append  (  value  ,  start  ,  end  )  ;  return  ;  }    out  .  append  (  encapsulator  )  ;        while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  encapsulator  )  {      out  .  append  (  value  ,  start  ,  pos  +  1  )  ;      start  =  pos  ;  }  pos++  ;  }    out  .  append  (  value  ,  start  ,  pos  )  ;  out  .  append  (  encapsulator  )  ;  }    [METHOD]  printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out  
[REPLACE]  }  else  if  (  c  <=  '#'  )  {	[BUGGY]    else  {[CE]  'else'  without  'if'  [CONTEXT]  void  printAndEncapsulate  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  boolean  first  =  newLine  ;  //  is  this  the  first  value  on  this  line?  boolean  quote  =  false  ;  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  encapsulator  =  format  .  getEncapsulator  (  )  ;    if  (  len  <  =  0  )  {          if  (  first  )  {  quote  =  true  ;  }  }  else  {  char  c  =  value  .  charAt  (  pos  )  ;      if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )  ||  (  c  >  'z'  )  )  )  {  quote  =  true  ;    [ATTENTION]  }else  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }  }  if  (  !quote  )  {    out  .  append  (  value  ,  start  ,  end  )  ;  return  ;  }    out  .  append  (  encapsulator  )  ;        while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  encapsulator  )  {      out  .  append  (  value  ,  start  ,  pos  +  1  )  ;      start  =  pos  ;  }  pos++  ;  }    out  .  append  (  value  ,  start  ,  pos  )  ;  out  .  append  (  encapsulator  )  ;  }    [METHOD]  printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out  
[REPLACE]  while  (  pos  <  end  )  {	[BUGGY]  while  (  pos  >  =  offset  )  {[FE]  String  index  out  of  range:  1  assertEquals( " "  ,  format.format())  ;  assertEquals( "a  ,  b  ,  c "  ,  format.format( "a "  ,   "b "  ,   "c "))  ;  assertEquals( "\ "x  ,  y\ "  ,  z "  ,  format.format( "x  ,  y "  ,   "z "))  ;  [CONTEXT]  }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  [ATTENTION]  while  (  pos>  =  offset  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }    [METHOD]  printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out  
[REPLACE]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUGGY]  if  (  encapsulator  =  =  '\n'  &&  c  =  =  '\r'  &&  c  =  =  encapsulator  &&  c  =  =  delim  )  {[FE]  AssertionFailedError    expected:<[ "x  ,  y "]  ,  z>  but  was:<[x  ,  y]  ,  z>  assertEquals( " "  ,  format.format())  ;  assertEquals( "a  ,  b  ,  c "  ,  format.format( "a "  ,   "b "  ,   "c "))  ;  assertEquals( "\ "x  ,  y\ "  ,  z "  ,  format.format( "x  ,  y "  ,   "z "))  ;  [CONTEXT]  }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  [ATTENTION]  if  (  encapsulator  =  =  '\n'  &&  c  =  =  '\r'  &&  c  =  =  encapsulator  &&  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }    [METHOD]  printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out  
[REPLACE]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUGGY]  if  (  c  =  =  '\n'  &&  c  =  =  '\r'  &&  c  =  =  encapsulator  &&  quote  )  {[FE]  AssertionFailedError    expected:<[ "x  ,  y "]  ,  z>  but  was:<[x  ,  y]  ,  z>  assertEquals( " "  ,  format.format())  ;  assertEquals( "a  ,  b  ,  c "  ,  format.format( "a "  ,   "b "  ,   "c "))  ;  assertEquals( "\ "x  ,  y\ "  ,  z "  ,  format.format( "x  ,  y "  ,   "z "))  ;  [CONTEXT]  }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  [ATTENTION]  if  (  c  =  =  '\n'  &&  c  =  =  '\r'  &&  c  =  =  encapsulator  &&  quote  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }    [METHOD]  printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out  
[REPLACE]  if  (  c  <=  '  '  )  {	[BUGGY]  if  (  c  >  =    '  '  )  {[FE]  AssertionFailedError    expected:<[a  ,  b  ,  c]>  but  was:<[ "a "  ,   "b "  ,   "c "]>  assertEquals( " "  ,  format.format())  ;  assertEquals( "a  ,  b  ,  c "  ,  format.format( "a "  ,   "b "  ,   "c "))  ;  assertEquals( "\ "x  ,  y\ "  ,  z "  ,  format.format( "x  ,  y "  ,   "z "))  ;  [CONTEXT]  }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        [ATTENTION]  if  (  c>  =  '  '  )  {  quote  =  true  ;  }  }  }    [METHOD]  printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out  
[REPLACE]  if  (  c  <=  '  '  )  {	[BUGGY]  if  (  c  !  =  encapsulator  )  {[FE]  AssertionFailedError    expected:<[a  ,  b  ,  c]>  but  was:<[ "a "  ,   "b "  ,   "c "]>  assertEquals( " "  ,  format.format())  ;  assertEquals( "a  ,  b  ,  c "  ,  format.format( "a "  ,   "b "  ,   "c "))  ;  assertEquals( "\ "x  ,  y\ "  ,  z "  ,  format.format( "x  ,  y "  ,   "z "))  ;  [CONTEXT]  }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        [ATTENTION]  if  (  c!  =  encapsulator  )  {  quote  =  true  ;  }  }  }    [METHOD]  printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out  
[REPLACE]  pos  =  end  -  1;	[BUGGY]  pos  =  end  !  =    1  ;  [CE]  incompatible  types  [CONTEXT]  }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  [ATTENTION]  pos  =  end!  =  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }    [METHOD]  printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out  
[ADD]  pos  =  end  -  1;	[BUGGY]  [FE]  String  index  out  of  range:  1  assertEquals( " "  ,  format.format())  ;  assertEquals( "a  ,  b  ,  c "  ,  format.format( "a "  ,   "b "  ,   "c "))  ;  assertEquals( "\ "x  ,  y\ "  ,  z "  ,  format.format( "x  ,  y "  ,   "z "))  ;  [CONTEXT]  }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  [ATTENTION]  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }    [METHOD]  printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out  
[REPLACE]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUGGY]  if  (  c  =  =  '\n'  &&  c  =  =  '\r'  &&  c  =  =  encapsulator  &&  c  =  =  encapsulator  )  {[FE]  AssertionFailedError    expected:<[ "x  ,  y "]  ,  z>  but  was:<[x  ,  y]  ,  z>  assertEquals( " "  ,  format.format())  ;  assertEquals( "a  ,  b  ,  c "  ,  format.format( "a "  ,   "b "  ,   "c "))  ;  assertEquals( "\ "x  ,  y\ "  ,  z "  ,  format.format( "x  ,  y "  ,   "z "))  ;  [CONTEXT]  void  printAndEncapsulate  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  boolean  first  =  newLine  ;  //  is  this  the  first  value  on  this  line?  boolean  quote  =  false  ;  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  encapsulator  =  format  .  getEncapsulator  (  )  ;    if  (  len  <  =  0  )  {          if  (  first  )  {  quote  =  true  ;  }  }  else  {  char  c  =  value  .  charAt  (  pos  )  ;      if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )  ||  (  c  >  'z'  )  )  )  {  quote  =  true  ;    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  [ATTENTION]  if  (  c  =  =  '\n'  &&  c  =  =  '\r'  &&  c  =  =  encapsulator  &&  c  =  =  encapsulator  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }  }  if  (  !quote  )  {    out  .  append  (  value  ,  start  ,  end  )  ;  return  ;  }    out  .  append  (  encapsulator  )  ;        while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  encapsulator  )  {      out  .  append  (  value  ,  start  ,  pos  +  1  )  ;      start  =  pos  ;  }  pos++  ;  }    out  .  append  (  value  ,  start  ,  pos  )  ;  out  .  append  (  encapsulator  )  ;  }    [METHOD]  printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out  
[ADD]  if  (  !quote  )  {  pos  =  end  -  1;  c  =  value  .  charAt  (  pos  )  ;	[BUGGY]  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;  [CE]  illegal  start  of  type  [CONTEXT]  void  printAndEncapsulate  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  boolean  first  =  newLine  ;  //  is  this  the  first  value  on  this  line?  boolean  quote  =  false  ;  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  encapsulator  =  format  .  getEncapsulator  (  )  ;    if  (  len  <  =  0  )  {          if  (  first  )  {  quote  =  true  ;  }  }  else  {  char  c  =  value  .  charAt  (  pos  )  ;      if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )  ||  (  c  >  'z'  )  )  )  {  quote  =  true  ;    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  [ATTENTION]  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )    ;          if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }  }  if  (  !quote  )  {    out  .  append  (  value  ,  start  ,  end  )  ;  return  ;  }    out  .  append  (  encapsulator  )  ;        while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  encapsulator  )  {      out  .  append  (  value  ,  start  ,  pos  +  1  )  ;      start  =  pos  ;  }  pos++  ;  }    out  .  append  (  value  ,  start  ,  pos  )  ;  out  .  append  (  encapsulator  )  ;  }    [METHOD]  printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out  
[REPLACE]  if  (  c  <=  '  '  )  {	[BUGGY]  if  (encapsulator    =  =    '  '  )  {[FE]  (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo\n "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "foo\n  baar  ,  ,  ,   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "\n\t  \n "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  void  printAndEncapsulate  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  boolean  first  =  newLine  ;  //  is  this  the  first  value  on  this  line?  boolean  quote  =  false  ;  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  encapsulator  =  format  .  getEncapsulator  (  )  ;    if  (  len  <  =  0  )  {          if  (  first  )  {  quote  =  true  ;  }  }  else  {  char  c  =  value  .  charAt  (  pos  )  ;      if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )  ||  (  c  >  'z'  )  )  )  {  quote  =  true  ;    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        [ATTENTION]  if  (  encapsulator  =  =  '  '  )  {  quote  =  true  ;  }  }  }  }  if  (  !quote  )  {    out  .  append  (  value  ,  start  ,  end  )  ;  return  ;  }    out  .  append  (  encapsulator  )  ;        while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  encapsulator  )  {      out  .  append  (  value  ,  start  ,  pos  +  1  )  ;      start  =  pos  ;  }  pos++  ;  }    out  .  append  (  value  ,  start  ,  pos  )  ;  out  .  append  (  encapsulator  )  ;  }    [METHOD]  printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out  
[REPLACE]  pos  =  end  -  1;	[BUGGY]  pos  =  end  -len  ;  [FE]  (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo\n "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "foo\n  baar  ,  ,  ,   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "\n\t  \n "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  void  printAndEncapsulate  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  boolean  first  =  newLine  ;  //  is  this  the  first  value  on  this  line?  boolean  quote  =  false  ;  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  encapsulator  =  format  .  getEncapsulator  (  )  ;    if  (  len  <  =  0  )  {          if  (  first  )  {  quote  =  true  ;  }  }  else  {  char  c  =  value  .  charAt  (  pos  )  ;      if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )  ||  (  c  >  'z'  )  )  )  {  quote  =  true  ;    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  [ATTENTION]  pos  =  end  -len  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }  }  if  (  !quote  )  {    out  .  append  (  value  ,  start  ,  end  )  ;  return  ;  }    out  .  append  (  encapsulator  )  ;        while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  encapsulator  )  {      out  .  append  (  value  ,  start  ,  pos  +  1  )  ;      start  =  pos  ;  }  pos++  ;  }    out  .  append  (  value  ,  start  ,  pos  )  ;  out  .  append  (  encapsulator  )  ;  }    [METHOD]  printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out  
[ADD]  c  =  value  .  charAt  (  pos  )  ;	[BUGGY]  [FE]  (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo\n "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "foo\n  baar  ,  ,  ,   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "\n\t  \n "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  void  printAndEncapsulate  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  boolean  first  =  newLine  ;  //  is  this  the  first  value  on  this  line?  boolean  quote  =  false  ;  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  encapsulator  =  format  .  getEncapsulator  (  )  ;    if  (  len  <  =  0  )  {          if  (  first  )  {  quote  =  true  ;  }  }  else  {  char  c  =  value  .  charAt  (  pos  )  ;      if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )  ||  (  c  >  'z'  )  )  )  {  quote  =  true  ;    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  [ATTENTION]        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }  }  if  (  !quote  )  {    out  .  append  (  value  ,  start  ,  end  )  ;  return  ;  }    out  .  append  (  encapsulator  )  ;        while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  encapsulator  )  {      out  .  append  (  value  ,  start  ,  pos  +  1  )  ;      start  =  pos  ;  }  pos++  ;  }    out  .  append  (  value  ,  start  ,  pos  )  ;  out  .  append  (  encapsulator  )  ;  }    [METHOD]  printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out  
[ADD]  quote  =  true;	[BUGGY]  [FE]  (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo\n "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "foo\n  baar  ,  ,  ,   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "\n\t  \n "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  void  printAndEncapsulate  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  boolean  first  =  newLine  ;  //  is  this  the  first  value  on  this  line?  boolean  quote  =  false  ;  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  encapsulator  =  format  .  getEncapsulator  (  )  ;    if  (  len  <  =  0  )  {          if  (  first  )  {  quote  =  true  ;  }  }  else  {  char  c  =  value  .  charAt  (  pos  )  ;      if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )  ||  (  c  >  'z'  )  )  )  {  quote  =  true  ;    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  [ATTENTION]  }  }  }  }  if  (  !quote  )  {    out  .  append  (  value  ,  start  ,  end  )  ;  return  ;  }    out  .  append  (  encapsulator  )  ;        while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  encapsulator  )  {      out  .  append  (  value  ,  start  ,  pos  +  1  )  ;      start  =  pos  ;  }  pos++  ;  }    out  .  append  (  value  ,  start  ,  pos  )  ;  out  .  append  (  encapsulator  )  ;  }    [METHOD]  printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out  
[REPLACE]  if  (  c  <=  '  '  )  {	[BUGGY]  if  (encapsulator  <  '  '  )  {[FE]  (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo\n "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "foo\n  baar  ,  ,  ,   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "\n\t  \n "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  void  printAndEncapsulate  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  boolean  first  =  newLine  ;  //  is  this  the  first  value  on  this  line?  boolean  quote  =  false  ;  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  encapsulator  =  format  .  getEncapsulator  (  )  ;    if  (  len  <  =  0  )  {          if  (  first  )  {  quote  =  true  ;  }  }  else  {  char  c  =  value  .  charAt  (  pos  )  ;      if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )  ||  (  c  >  'z'  )  )  )  {  quote  =  true  ;    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        [ATTENTION]  if  (  encapsulator<'  '  )  {  quote  =  true  ;  }  }  }  }  if  (  !quote  )  {    out  .  append  (  value  ,  start  ,  end  )  ;  return  ;  }    out  .  append  (  encapsulator  )  ;        while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  encapsulator  )  {      out  .  append  (  value  ,  start  ,  pos  +  1  )  ;      start  =  pos  ;  }  pos++  ;  }    out  .  append  (  value  ,  start  ,  pos  )  ;  out  .  append  (  encapsulator  )  ;  }    [METHOD]  printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out  
[REPLACE]  quote  =  true;	[BUGGY]  quote  =  false  ;  [FE]  (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo\n "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "foo\n  baar  ,  ,  ,   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "\n\t  \n "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  void  printAndEncapsulate  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  boolean  first  =  newLine  ;  //  is  this  the  first  value  on  this  line?  boolean  quote  =  false  ;  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  encapsulator  =  format  .  getEncapsulator  (  )  ;    if  (  len  <  =  0  )  {          if  (  first  )  {  quote  =  true  ;  }  }  else  {  char  c  =  value  .  charAt  (  pos  )  ;      if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )  ||  (  c  >  'z'  )  )  )  {  [ATTENTION]  quote  =  false  ;    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }  }  if  (  !quote  )  {    out  .  append  (  value  ,  start  ,  end  )  ;  return  ;  }    out  .  append  (  encapsulator  )  ;        while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  encapsulator  )  {      out  .  append  (  value  ,  start  ,  pos  +  1  )  ;      start  =  pos  ;  }  pos++  ;  }    out  .  append  (  value  ,  start  ,  pos  )  ;  out  .  append  (  encapsulator  )  ;  }    [METHOD]  printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out  
[REPLACE]  char  c  =  value  .  charAt  (  pos  )  ;	[BUGGY]  char  c  =  value  .  charAt  (  offset  )  ;  [FE]  (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo\n "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "foo\n  baar  ,  ,  ,   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "\n\t  \n "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  void  printAndEncapsulate  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  boolean  first  =  newLine  ;  //  is  this  the  first  value  on  this  line?  boolean  quote  =  false  ;  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  encapsulator  =  format  .  getEncapsulator  (  )  ;    if  (  len  <  =  0  )  {          if  (  first  )  {  quote  =  true  ;  }  }  else  {  [ATTENTION]  char  c  =  value  .  charAt  (  offset  )    ;      if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )  ||  (  c  >  'z'  )  )  )  {  quote  =  true  ;    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }  }  if  (  !quote  )  {    out  .  append  (  value  ,  start  ,  end  )  ;  return  ;  }    out  .  append  (  encapsulator  )  ;        while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  encapsulator  )  {      out  .  append  (  value  ,  start  ,  pos  +  1  )  ;      start  =  pos  ;  }  pos++  ;  }    out  .  append  (  value  ,  start  ,  pos  )  ;  out  .  append  (  encapsulator  )  ;  }    [METHOD]  printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out  
[REPLACE]  if  (  !quote  )  {	[BUGGY]  if  (  quote  )  {[FE]  AssertionFailedError    expected:<[a  ,  b  ,  c]>  but  was:<[ "a "  ,   "b "  ,   "c "]>  assertEquals( " "  ,  format.format())  ;  assertEquals( "a  ,  b  ,  c "  ,  format.format( "a "  ,   "b "  ,   "c "))  ;  assertEquals( "\ "x  ,  y\ "  ,  z "  ,  format.format( "x  ,  y "  ,   "z "))  ;  [CONTEXT]  void  printAndEncapsulate  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  boolean  first  =  newLine  ;  //  is  this  the  first  value  on  this  line?  boolean  quote  =  false  ;  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  encapsulator  =  format  .  getEncapsulator  (  )  ;    if  (  len  <  =  0  )  {          if  (  first  )  {  quote  =  true  ;  }  }  else  {  char  c  =  value  .  charAt  (  pos  )  ;      if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )  ||  (  c  >  'z'  )  )  )  {  quote  =  true  ;    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }  }  [ATTENTION]  if  (  quote  )  {    out  .  append  (  value  ,  start  ,  end  )  ;  return  ;  }    out  .  append  (  encapsulator  )  ;        while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  encapsulator  )  {      out  .  append  (  value  ,  start  ,  pos  +  1  )  ;      start  =  pos  ;  }  pos++  ;  }    out  .  append  (  value  ,  start  ,  pos  )  ;  out  .  append  (  encapsulator  )  ;  }    [METHOD]  printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out  
[REPLACE]  out  .  append  (  encapsulator  )  ;	[BUGGY]  out  .  append  (  delim  )  ;  [FE]  AssertionFailedError    expected:<[ "]x  ,  y "  ,  z>  but  was:<[  ,  ]x  ,  y "  ,  z>  assertEquals( " "  ,  format.format())  ;  assertEquals( "a  ,  b  ,  c "  ,  format.format( "a "  ,   "b "  ,   "c "))  ;  assertEquals( "\ "x  ,  y\ "  ,  z "  ,  format.format( "x  ,  y "  ,   "z "))  ;  [CONTEXT]  void  printAndEncapsulate  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  boolean  first  =  newLine  ;  //  is  this  the  first  value  on  this  line?  boolean  quote  =  false  ;  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  encapsulator  =  format  .  getEncapsulator  (  )  ;    if  (  len  <  =  0  )  {          if  (  first  )  {  quote  =  true  ;  }  }  else  {  char  c  =  value  .  charAt  (  pos  )  ;      if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )  ||  (  c  >  'z'  )  )  )  {  quote  =  true  ;    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }  }  if  (  !quote  )  {    out  .  append  (  value  ,  start  ,  end  )  ;  return  ;  }    [ATTENTION]  out  .  append  (  delim  )    ;        while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  encapsulator  )  {      out  .  append  (  value  ,  start  ,  pos  +  1  )  ;      start  =  pos  ;  }  pos++  ;  }    out  .  append  (  value  ,  start  ,  pos  )  ;  out  .  append  (  encapsulator  )  ;  }    [METHOD]  printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out  
[REPLACE]  while  (  pos  <  end  )  {	[BUGGY]  while  (offset  >  end  )  {[FE]  AssertionFailedError    expected:< "x[  ,  y] "  ,  z>  but  was:< "x[] "  ,  z>  assertEquals( " "  ,  format.format())  ;  assertEquals( "a  ,  b  ,  c "  ,  format.format( "a "  ,   "b "  ,   "c "))  ;  assertEquals( "\ "x  ,  y\ "  ,  z "  ,  format.format( "x  ,  y "  ,   "z "))  ;  [CONTEXT]  void  printAndEncapsulate  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  boolean  first  =  newLine  ;  //  is  this  the  first  value  on  this  line?  boolean  quote  =  false  ;  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  encapsulator  =  format  .  getEncapsulator  (  )  ;    if  (  len  <  =  0  )  {          if  (  first  )  {  quote  =  true  ;  }  }  else  {  char  c  =  value  .  charAt  (  pos  )  ;      if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )  ||  (  c  >  'z'  )  )  )  {  quote  =  true  ;    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }  }  if  (  !quote  )  {    out  .  append  (  value  ,  start  ,  end  )  ;  return  ;  }    out  .  append  (  encapsulator  )  ;        [ATTENTION]  while  (  offset>end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  encapsulator  )  {      out  .  append  (  value  ,  start  ,  pos  +  1  )  ;      start  =  pos  ;  }  pos++  ;  }    out  .  append  (  value  ,  start  ,  pos  )  ;  out  .  append  (  encapsulator  )  ;  }    [METHOD]  printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out  
[REPLACE]  if  (  c  ==  encapsulator  )  {	[BUGGY]  if  (  c  &&  encapsulator  )  {[CE]  bad  operand  types  for  binary  operator  '&&'  [CONTEXT]  void  printAndEncapsulate  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  boolean  first  =  newLine  ;  //  is  this  the  first  value  on  this  line?  boolean  quote  =  false  ;  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  encapsulator  =  format  .  getEncapsulator  (  )  ;    if  (  len  <  =  0  )  {          if  (  first  )  {  quote  =  true  ;  }  }  else  {  char  c  =  value  .  charAt  (  pos  )  ;      if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )  ||  (  c  >  'z'  )  )  )  {  quote  =  true  ;    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }  }  if  (  !quote  )  {    out  .  append  (  value  ,  start  ,  end  )  ;  return  ;  }    out  .  append  (  encapsulator  )  ;        while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  [ATTENTION]  if  (  c&&encapsulator  )  {      out  .  append  (  value  ,  start  ,  pos  +  1  )  ;      start  =  pos  ;  }  pos++  ;  }    out  .  append  (  value  ,  start  ,  pos  )  ;  out  .  append  (  encapsulator  )  ;  }    [METHOD]  printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out  
[ADD]  if  (  c  ==  encapsulator  )  {  out  .  append  (  value,  start,  pos  +  1  )  ;	[BUGGY]  [CE]  <identifier>  expected  [CONTEXT]  void  printAndEncapsulate  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  boolean  first  =  newLine  ;  //  is  this  the  first  value  on  this  line?  boolean  quote  =  false  ;  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  encapsulator  =  format  .  getEncapsulator  (  )  ;    if  (  len  <  =  0  )  {          if  (  first  )  {  quote  =  true  ;  }  }  else  {  char  c  =  value  .  charAt  (  pos  )  ;      if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )  ||  (  c  >  'z'  )  )  )  {  quote  =  true  ;    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }  }  if  (  !quote  )  {    out  .  append  (  value  ,  start  ,  end  )  ;  return  ;  }    out  .  append  (  encapsulator  )  ;        while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  [ATTENTION]            start  =  pos  ;  }  pos++  ;  }    out  .  append  (  value  ,  start  ,  pos  )  ;  out  .  append  (  encapsulator  )  ;  }    [METHOD]  printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out  
[REPLACE]  start  =  pos;	[BUGGY]  start  =  pos  +  1  ;    ;  [FE]  (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo\n "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "foo\n  baar  ,  ,  ,   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "\n\t  \n "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  void  printAndEncapsulate  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  boolean  first  =  newLine  ;  //  is  this  the  first  value  on  this  line?  boolean  quote  =  false  ;  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  encapsulator  =  format  .  getEncapsulator  (  )  ;    if  (  len  <  =  0  )  {          if  (  first  )  {  quote  =  true  ;  }  }  else  {  char  c  =  value  .  charAt  (  pos  )  ;      if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )  ||  (  c  >  'z'  )  )  )  {  quote  =  true  ;    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }  }  if  (  !quote  )  {    out  .  append  (  value  ,  start  ,  end  )  ;  return  ;  }    out  .  append  (  encapsulator  )  ;        while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  encapsulator  )  {      out  .  append  (  value  ,  start  ,  pos  +  1  )  ;      [ATTENTION]  start  =  pos  +  1  ;    ;  }  pos++  ;  }    out  .  append  (  value  ,  start  ,  pos  )  ;  out  .  append  (  encapsulator  )  ;  }    [METHOD]  printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out  
[REPLACE]  char  c  =  value  .  charAt  (  pos  )  ;	[BUGGY]  char  c  =  value  .  charAt  (  offset  )  ;  [FE]  (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo\n "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "foo\n  baar  ,  ,  ,   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "\n\t  \n "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  void  printAndEncapsulate  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  boolean  first  =  newLine  ;  //  is  this  the  first  value  on  this  line?  boolean  quote  =  false  ;  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  encapsulator  =  format  .  getEncapsulator  (  )  ;    if  (  len  <  =  0  )  {          if  (  first  )  {  quote  =  true  ;  }  }  else  {  char  c  =  value  .  charAt  (  pos  )  ;      if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )  ||  (  c  >  'z'  )  )  )  {  quote  =  true  ;    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }  }  if  (  !quote  )  {    out  .  append  (  value  ,  start  ,  end  )  ;  return  ;  }    out  .  append  (  encapsulator  )  ;        while  (  pos  <  end  )  {  [ATTENTION]  char  c  =  value  .  charAt  (  offset  )    ;  if  (  c  =  =  encapsulator  )  {      out  .  append  (  value  ,  start  ,  pos  +  1  )  ;      start  =  pos  ;  }  pos++  ;  }    out  .  append  (  value  ,  start  ,  pos  )  ;  out  .  append  (  encapsulator  )  ;  }    [METHOD]  printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out  
[REPLACE]  out  .  append  (  value,  start,  pos  )  ;	[BUGGY]  out  .  append  (  value  ,  start  ,  end  )  ;  [FE]  (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo\n "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "foo\n  baar  ,  ,  ,   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "\n\t  \n "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  void  printAndEncapsulate  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  boolean  first  =  newLine  ;  //  is  this  the  first  value  on  this  line?  boolean  quote  =  false  ;  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  encapsulator  =  format  .  getEncapsulator  (  )  ;    if  (  len  <  =  0  )  {          if  (  first  )  {  quote  =  true  ;  }  }  else  {  char  c  =  value  .  charAt  (  pos  )  ;      if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )  ||  (  c  >  'z'  )  )  )  {  quote  =  true  ;    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }  }  if  (  !quote  )  {    out  .  append  (  value  ,  start  ,  end  )  ;  return  ;  }    out  .  append  (  encapsulator  )  ;        while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  encapsulator  )  {      out  .  append  (  value  ,  start  ,  pos  +  1  )  ;      start  =  pos  ;  }  pos++  ;  }    [ATTENTION]  out  .  append  (  value  ,  start  ,  end  )    ;  out  .  append  (  encapsulator  )  ;  }    [METHOD]  printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out  
[ADD]  out  .  append  (  value,  start,  pos  )  ;  out  .  append  (  encapsulator  )  ;	[BUGGY]  out  .  append  (  encapsulator  )  ;  [FE]  AssertionFailedError    expected:< "[x  ,  y] "  ,  z>  but  was:< "[] "  ,  z>  assertEquals( " "  ,  format.format())  ;  assertEquals( "a  ,  b  ,  c "  ,  format.format( "a "  ,   "b "  ,   "c "))  ;  assertEquals( "\ "x  ,  y\ "  ,  z "  ,  format.format( "x  ,  y "  ,   "z "))  ;  [CONTEXT]  void  printAndEncapsulate  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  boolean  first  =  newLine  ;  //  is  this  the  first  value  on  this  line?  boolean  quote  =  false  ;  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  encapsulator  =  format  .  getEncapsulator  (  )  ;    if  (  len  <  =  0  )  {          if  (  first  )  {  quote  =  true  ;  }  }  else  {  char  c  =  value  .  charAt  (  pos  )  ;      if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )  ||  (  c  >  'z'  )  )  )  {  quote  =  true  ;    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }  }  if  (  !quote  )  {    out  .  append  (  value  ,  start  ,  end  )  ;  return  ;  }    out  .  append  (  encapsulator  )  ;        while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  encapsulator  )  {      out  .  append  (  value  ,  start  ,  pos  +  1  )  ;      start  =  pos  ;  }  pos++  ;  }    [ATTENTION]  out  .  append  (  encapsulator  )    ;    }    [METHOD]  printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out  
[REPLACE]  out  .  append  (  encapsulator  )  ;	[BUGGY]  out  .  append  (  delim  )  ;  [FE]  AssertionFailedError    expected:< "x  ,  y[ "]  ,  z>  but  was:< "x  ,  y[  ,  ]  ,  z>  assertEquals( " "  ,  format.format())  ;  assertEquals( "a  ,  b  ,  c "  ,  format.format( "a "  ,   "b "  ,   "c "))  ;  assertEquals( "\ "x  ,  y\ "  ,  z "  ,  format.format( "x  ,  y "  ,   "z "))  ;  [CONTEXT]  void  printAndEncapsulate  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  boolean  first  =  newLine  ;  //  is  this  the  first  value  on  this  line?  boolean  quote  =  false  ;  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  encapsulator  =  format  .  getEncapsulator  (  )  ;    if  (  len  <  =  0  )  {          if  (  first  )  {  quote  =  true  ;  }  }  else  {  char  c  =  value  .  charAt  (  pos  )  ;      if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )  ||  (  c  >  'z'  )  )  )  {  quote  =  true  ;    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }  }  if  (  !quote  )  {    out  .  append  (  value  ,  start  ,  end  )  ;  return  ;  }    out  .  append  (  encapsulator  )  ;        while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  encapsulator  )  {      out  .  append  (  value  ,  start  ,  pos  +  1  )  ;      start  =  pos  ;  }  pos++  ;  }    out  .  append  (  value  ,  start  ,  pos  )  ;  [ATTENTION]  out  .  append  (  delim  )    ;  }    [METHOD]  printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out  
[REPLACE]  if  (  value  ==  null  )  {	[BUGGY]  if  (  value  !  =  null  )  {[FE]  AssertionFailedError    expected:<[a  ,  b  ,  c]>  but  was:<[ " "  ,  ,  ]>  assertEquals( " "  ,  format.format())  ;  assertEquals( "a  ,  b  ,  c "  ,  format.format( "a "  ,   "b "  ,   "c "))  ;  assertEquals( "\ "x  ,  y\ "  ,  z "  ,  format.format( "x  ,  y "  ,   "z "))  ;  [CONTEXT]  public  void  print  (  String  value  ,  boolean  checkForEscape  )  throws  IOException  {  [ATTENTION]  if  (  value  !  =  null  )  {    value  =   " "  ;  }  if  (  !checkForEscape  )  {    printSep  (  )  ;  out  .  append  (  value  )  ;  }  else  {  print  (  value  ,  0  ,  value  .  length  (  )  )  ;  }  }    [METHOD]  print  [TYPE]  void  [PARAMETER]  String  value  boolean  checkForEscape  [CLASS]  CSVPrinter    [TYPE]  CSVFormat  format  [TYPE]  boolean  checkForEscape  false  first  newLine  quote  true  [TYPE]  String  value  [TYPE]  Appendable  out  
[REMOVE]  	[BUGGY]  if  (  first  )  {      quote  =  true  ;  }[CE]  cannot  find  symbol  first  [CONTEXT]  public  void  print  (  String  value  ,  boolean  checkForEscape  )  throws  IOException  {  [ATTENTION]  if  (  value  =  =  null  )  {  if  (  first  )  {  quote  =  true  ;  }//  null  values  are  considered  empty  value  =   " "  ;  }  if  (  !checkForEscape  )  {    printSep  (  )  ;  out  .  append  (  value  )  ;  }  else  {  print  (  value  ,  0  ,  value  .  length  (  )  )  ;  }    [METHOD]  print  [TYPE]  void  [PARAMETER]  String  value  boolean  checkForEscape  [CLASS]  CSVPrinter    [TYPE]  CSVFormat  format  [TYPE]  boolean  checkForEscape  false  first  newLine  quote  true  [TYPE]  String  value  [TYPE]  Appendable  out  
[REPLACE]  value  =   " ";	[BUGGY]  value    =    value  ;  [FE]  (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo\n "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "foo\n  baar  ,  ,  ,   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "\n\t  \n "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  public  void  print  (  String  value  ,  boolean  checkForEscape  )  throws  IOException  {  if  (  value  =  =  null  )  {    [ATTENTION]  value  =  value  ;  }  if  (  !checkForEscape  )  {    printSep  (  )  ;  out  .  append  (  value  )  ;  }  else  {  print  (  value  ,  0  ,  value  .  length  (  )  )  ;  }  }    [METHOD]  print  [TYPE]  void  [PARAMETER]  String  value  boolean  checkForEscape  [CLASS]  CSVPrinter    [TYPE]  CSVFormat  format  [TYPE]  boolean  checkForEscape  false  first  newLine  quote  true  [TYPE]  String  value  [TYPE]  Appendable  out  
[REPLACE]  if  (  !checkForEscape  )  {	[BUGGY]  if  (  newLine  )  {[FE]  AssertionFailedError    expected:<[ "x  ,  y "]  ,  z>  but  was:<[x  ,  y]  ,  z>  assertEquals( " "  ,  format.format())  ;  assertEquals( "a  ,  b  ,  c "  ,  format.format( "a "  ,   "b "  ,   "c "))  ;  assertEquals( "\ "x  ,  y\ "  ,  z "  ,  format.format( "x  ,  y "  ,   "z "))  ;  [CONTEXT]  public  void  print  (  String  value  ,  boolean  checkForEscape  )  throws  IOException  {  if  (  value  =  =  null  )  {    value  =   " "  ;  }  [ATTENTION]  if  (  newLine  )  {    printSep  (  )  ;  out  .  append  (  value  )  ;  }  else  {  print  (  value  ,  0  ,  value  .  length  (  )  )  ;  }  }    [METHOD]  print  [TYPE]  void  [PARAMETER]  String  value  boolean  checkForEscape  [CLASS]  CSVPrinter    [TYPE]  CSVFormat  format  [TYPE]  boolean  checkForEscape  false  first  newLine  quote  true  [TYPE]  String  value  [TYPE]  Appendable  out  
[REPLACE]  print  (  value,  0,  value  .  length  (  )  )  ;	[BUGGY]  print  (  value  ,  0  ,  value  .  length  (  )  )  ;  [FE]  (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo\n "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "foo\n  baar  ,  ,  ,   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "\n\t  \n "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  public  void  print  (  String  value  ,  boolean  checkForEscape  )  throws  IOException  {  if  (  value  =  =  null  )  {    value  =   " "  ;  }  if  (  !checkForEscape  )  {    printSep  (  )  ;  out  .  append  (  value  )  ;  }  else  {  [ATTENTION]  print  (  value  ,  0  ,  value  .  length  (  )  )    ;  }  }    [METHOD]  print  [TYPE]  void  [PARAMETER]  String  value  boolean  checkForEscape  [CLASS]  CSVPrinter    [TYPE]  CSVFormat  format  [TYPE]  boolean  checkForEscape  false  first  newLine  quote  true  [TYPE]  String  value  [TYPE]  Appendable  out  
[REPLACE]  print  (  value,  0,  value  .  length  (  )  )  ;	[BUGGY]  char  c  =  value  .  charAt  (  pos  )  ;  [CE]  cannot  find  symbol  pos  [CONTEXT]  public  void  print  (  String  value  ,  boolean  checkForEscape  )  throws  IOException  {  if  (  value  =  =  null  )  {    value  =   " "  ;  }  if  (  !checkForEscape  )  {    printSep  (  )  ;  out  .  append  (  value  )  ;  }  else  {  [ATTENTION]  char  c  =  value  .  charAt  (  pos  )    ;  }  }    [METHOD]  print  [TYPE]  void  [PARAMETER]  String  value  boolean  checkForEscape  [CLASS]  CSVPrinter    [TYPE]  CSVFormat  format  [TYPE]  boolean  checkForEscape  false  first  newLine  quote  true  [TYPE]  String  value  [TYPE]  Appendable  out  
[REPLACE]  printSep  (  )  ;	[BUGGY]  out  .  append  (  '  '  )  ;  [FE]  (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "foo\n "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "b "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "foo\n  baar  ,  ,  ,   "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   "\n\t  \n "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  public  void  print  (  String  value  ,  boolean  checkForEscape  )  throws  IOException  {  if  (  value  =  =  null  )  {    value  =   " "  ;  }  if  (  !checkForEscape  )  {    [ATTENTION]  out  .  append  (  '  '  )    ;  out  .  append  (  value  )  ;  }  else  {  print  (  value  ,  0  ,  value  .  length  (  )  )  ;  }  }    [METHOD]  print  [TYPE]  void  [PARAMETER]  String  value  boolean  checkForEscape  [CLASS]  CSVPrinter    [TYPE]  CSVFormat  format  [TYPE]  boolean  checkForEscape  false  first  newLine  quote  true  [TYPE]  String  value  [TYPE]  Appendable  out  
[REPLACE]  out  .  append  (  value  )  ;	[BUGGY]  out  .  append  (  null  ,  null  ,  null  )    ;  [CE]  no  suitable  method  found  for  append(<null>  ,  <null>  ,  <null>)  [CONTEXT]  public  void  print  (  String  value  ,  boolean  checkForEscape  )  throws  IOException  {  if  (  value  =  =  null  )  {    value  =   " "  ;  }  if  (  !checkForEscape  )  {    printSep  (  )  ;  [ATTENTION]  out  .  append  (  null  ,  null  ,  null  )  ;  }  else  {  print  (  value  ,  0  ,  value  .  length  (  )  )  ;  }  }    [METHOD]  print  [TYPE]  void  [PARAMETER]  String  value  boolean  checkForEscape  [CLASS]  CSVPrinter    [TYPE]  CSVFormat  format  [TYPE]  boolean  checkForEscape  false  first  newLine  quote  true  [TYPE]  String  value  [TYPE]  Appendable  out  
[REPLACE]  print  (  value,  true  )  ;	[BUGGY]  print  (  value  ,  false  )  ;  [FE]  AssertionFailedError    expected:<[ "x  ,  y "]  ,  z>  but  was:<[x  ,  y]  ,  z>  assertEquals( " "  ,  format.format())  ;  assertEquals( "a  ,  b  ,  c "  ,  format.format( "a "  ,   "b "  ,   "c "))  ;  assertEquals( "\ "x  ,  y\ "  ,  z "  ,  format.format( "x  ,  y "  ,   "z "))  ;  [CONTEXT]  public  void  print  (  String  value  )  throws  IOException  {  [ATTENTION]  print  (  value  ,  false  )    ;  }    [METHOD]  print  [TYPE]  void  [PARAMETER]  String  value  [CLASS]  CSVPrinter    [TYPE]  CSVFormat  format  [TYPE]  boolean  checkForEscape  false  first  newLine  quote  true  [TYPE]  String  value  [TYPE]  Appendable  out  
[REPLACE]  static  final  int  END_OF_STREAM  =  -1;	[BUGGY]  static  final  int  END_OF_STREAM  =  -1L  ;  [CE]  possible  loss  of  precision  [CONTEXT]      [CLASS]  ExtendedBufferedReader  
[REPLACE]  static  final  int  UNDEFINED  =  -2;	[BUGGY]  static  final  int  UNDEFINED    =  null  ;  [CE]  incompatible  types  [CONTEXT]      [CLASS]  ExtendedBufferedReader  
[REPLACE]  private  int  lastChar  =  UNDEFINED;	[BUGGY]  private  int  lastChar    =  null  ;  [CE]  incompatible  types  [CONTEXT]      [CLASS]  ExtendedBufferedReader  
[REPLACE]  private  int  lineCounter  =  0;	[BUGGY]  private  int  lineCounter  ;  [FE]  AssertionFailedError    expected:<[ "x  ,  y "]  ,  z>  but  was:<[x  ,  y]  ,  z>  assertEquals( " "  ,  format.format())  ;  assertEquals( "a  ,  b  ,  c "  ,  format.format( "a "  ,   "b "  ,   "c "))  ;  assertEquals( "\ "x  ,  y\ "  ,  z "  ,  format.format( "x  ,  y "  ,   "z "))  ;  [CONTEXT]      [CLASS]  ExtendedBufferedReader  
[REPLACE]  super  (  r  )  ;	[BUGGY]  super  .  reset  (  )  ;  [CE]  no  suitable  constructor  found  for  BufferedReader()  [CONTEXT]  ExtendedBufferedReader  (  Reader  r  )  {  [ATTENTION]  super  .  reset  (  )    ;  }    [METHOD]  <init>  [TYPE]  Reader)  [PARAMETER]  Reader  r  [CLASS]  ExtendedBufferedReader    [TYPE]  Reader  r  [TYPE]  int  END_OF_STREAM  UNDEFINED  lastChar  lineCounter  [TYPE]  boolean  false  true  
[REPLACE]  int  current  =  super  .  read  (  )  ;	[BUGGY]  int  current  =  super  .  reset  (  )  ;  [CE]  incompatible  types  [CONTEXT]  public  int  read  (  )  throws  IOException  {  [ATTENTION]  int  current  =  super  .  reset  (  )    ;  if  (  current  =  =  '\r'  ||  (  current  =  =  '\n'  &&  lastChar  !  =  '\r'  )  )  {  lineCounter++  ;  }  lastChar  =  current  ;  return  lastChar  ;  }    [METHOD]  read  [TYPE]  int  [PARAMETER]  [CLASS]  ExtendedBufferedReader    [TYPE]  int  END_OF_STREAM  UNDEFINED  current  lastChar  lineCounter  [TYPE]  boolean  false  true  
[REPLACE]  if  (  current  ==  '\r'  ||  (  current  ==  '\n'  &&  lastChar  !=  '\r'  )  )  {	[BUGGY]  if  (    (  current  =  =  '\n'  &&  lastChar  !  =  '\r'  )  )  {[FE]  AssertionFailedError    expected:<[ "x  ,  y "]  ,  z>  but  was:<[x  ,  y]  ,  z>  assertEquals( " "  ,  format.format())  ;  assertEquals( "a  ,  b  ,  c "  ,  format.format( "a "  ,   "b "  ,   "c "))  ;  assertEquals( "\ "x  ,  y\ "  ,  z "  ,  format.format( "x  ,  y "  ,   "z "))  ;  [CONTEXT]  public  int  read  (  )  throws  IOException  {  int  current  =  super  .  read  (  )  ;  [ATTENTION]  if  (    (  current  =  =  '\n'  &&  lastChar  !  =  '\r'  )  )  {  lineCounter++  ;  }  lastChar  =  current  ;  return  lastChar  ;  }    [METHOD]  read  [TYPE]  int  [PARAMETER]  [CLASS]  ExtendedBufferedReader    [TYPE]  int  END_OF_STREAM  UNDEFINED  current  lastChar  lineCounter  [TYPE]  boolean  false  true  
[REPLACE]  lastChar  =  current;	[BUGGY]  lastChar  =    lineCounter  ;  [FE]  [CONTEXT]  public  int  read  (  )  throws  IOException  {  int  current  =  super  .  read  (  )  ;  if  (  current  =  =  '\r'  ||  (  current  =  =  '\n'  &&  lastChar  !  =  '\r'  )  )  {  lineCounter++  ;  }  [ATTENTION]  lastChar  =  lineCounter  ;  return  lastChar  ;  }    [METHOD]  read  [TYPE]  int  [PARAMETER]  [CLASS]  ExtendedBufferedReader    [TYPE]  int  END_OF_STREAM  UNDEFINED  current  lastChar  lineCounter  [TYPE]  boolean  false  true  
[ADD]  lastChar  =  current;  return  lastChar;	[BUGGY]  return  lastChar  ;  [FE]  [CONTEXT]  public  int  read  (  )  throws  IOException  {  int  current  =  super  .  read  (  )  ;  if  (  current  =  =  '\r'  ||  (  current  =  =  '\n'  &&  lastChar  !  =  '\r'  )  )  {  lineCounter++  ;  }  [ATTENTION]  return  lastChar  ;    }    [METHOD]  read  [TYPE]  int  [PARAMETER]  [CLASS]  ExtendedBufferedReader    [TYPE]  int  END_OF_STREAM  UNDEFINED  current  lastChar  lineCounter  [TYPE]  boolean  false  true  
[REPLACE]  return  lastChar;	[BUGGY]  return  line  ;  [CE]  cannot  find  symbol  line  [CONTEXT]  public  int  read  (  )  throws  IOException  {  int  current  =  super  .  read  (  )  ;  if  (  current  =  =  '\r'  ||  (  current  =  =  '\n'  &&  lastChar  !  =  '\r'  )  )  {  lineCounter++  ;  }  lastChar  =  current  ;  [ATTENTION]  return  line  ;  }    [METHOD]  read  [TYPE]  int  [PARAMETER]  [CLASS]  ExtendedBufferedReader    [TYPE]  int  END_OF_STREAM  UNDEFINED  current  lastChar  lineCounter  [TYPE]  boolean  false  true  
[REPLACE]  return  lastChar;	[BUGGY]  return  line  ;  [CE]  cannot  find  symbol  line  [CONTEXT]  int  readAgain  (  )  {  [ATTENTION]  return  line  ;  }    [METHOD]  readAgain  [TYPE]  int  [PARAMETER]  [CLASS]  ExtendedBufferedReader    [TYPE]  int  END_OF_STREAM  UNDEFINED  current  lastChar  lineCounter  [TYPE]  boolean  false  true  
[REPLACE]  if  (  length  ==  0  )  {	[BUGGY]  if  (  length  -  4  =  =  0  )  {[FE]  AssertionFailedError    expected:<[ "x  ,  y "]  ,  z>  but  was:<[x  ,  y]  ,  z>  assertEquals( " "  ,  format.format())  ;  assertEquals( "a  ,  b  ,  c "  ,  format.format( "a "  ,   "b "  ,   "c "))  ;  assertEquals( "\ "x  ,  y\ "  ,  z "  ,  format.format( "x  ,  y "  ,   "z "))  ;  [CONTEXT]  public  int  read  (  char[]  buf  ,  int  offset  ,  int  length  )  throws  IOException  {  [ATTENTION]  if  (  length  -  4  =  =  0  )  {  return  0  ;  }  int  len  =  super  .  read  (  buf  ,  offset  ,  length  )  ;    if  (  len  >  0  )  {  for  (  int  i  =  offset  ;  i  <  offset  +  len  ;  i++  )  {  char  ch  =  buf[i]  ;  if  (  ch  =  =  '\n'  )  {  if  (  '\r'  !  =    (  i  >  0  ?  buf[i-1]:  lastChar  )  )  {  lineCounter++  ;  }  }  else  if  (  ch  =  =  '\r'  )  {  lineCounter++  ;  }  }  lastChar  =  buf[offset  +  len  -  1]  ;    }  else  if  (  len  =  =  -1  )  {  lastChar  =  END_OF_STREAM  ;  }  return  len  ;  }    [METHOD]  read  [TYPE]  int  [PARAMETER]  char[]  buf  int  offset  int  length  [CLASS]  ExtendedBufferedReader    [TYPE]  char  ch  [TYPE]  boolean  false  true  [TYPE]  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  [TYPE]  char[]  buf  
[REPLACE]  return  0;	[BUGGY]  return  0  /  3  ;  [FE]  AssertionFailedError    expected:<[ "x  ,  y "]  ,  z>  but  was:<[x  ,  y]  ,  z>  assertEquals( " "  ,  format.format())  ;  assertEquals( "a  ,  b  ,  c "  ,  format.format( "a "  ,   "b "  ,   "c "))  ;  assertEquals( "\ "x  ,  y\ "  ,  z "  ,  format.format( "x  ,  y "  ,   "z "))  ;  [CONTEXT]  public  int  read  (  char[]  buf  ,  int  offset  ,  int  length  )  throws  IOException  {  if  (  length  =  =  0  )  {  [ATTENTION]  return  0  /  3  ;  }  int  len  =  super  .  read  (  buf  ,  offset  ,  length  )  ;    if  (  len  >  0  )  {  for  (  int  i  =  offset  ;  i  <  offset  +  len  ;  i++  )  {  char  ch  =  buf[i]  ;  if  (  ch  =  =  '\n'  )  {  if  (  '\r'  !  =    (  i  >  0  ?  buf[i-1]:  lastChar  )  )  {  lineCounter++  ;  }  }  else  if  (  ch  =  =  '\r'  )  {  lineCounter++  ;  }  }  lastChar  =  buf[offset  +  len  -  1]  ;    }  else  if  (  len  =  =  -1  )  {  lastChar  =  END_OF_STREAM  ;  }  return  len  ;  }    [METHOD]  read  [TYPE]  int  [PARAMETER]  char[]  buf  int  offset  int  length  [CLASS]  ExtendedBufferedReader    [TYPE]  char  ch  [TYPE]  boolean  false  true  [TYPE]  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  [TYPE]  char[]  buf  
[REPLACE]  return  0;	[BUGGY]  return  1  ;  [FE]  AssertionFailedError    expected:<[ "x  ,  y "]  ,  z>  but  was:<[x  ,  y]  ,  z>  assertEquals( " "  ,  format.format())  ;  assertEquals( "a  ,  b  ,  c "  ,  format.format( "a "  ,   "b "  ,   "c "))  ;  assertEquals( "\ "x  ,  y\ "  ,  z "  ,  format.format( "x  ,  y "  ,   "z "))  ;  [CONTEXT]  public  int  read  (  char[]  buf  ,  int  offset  ,  int  length  )  throws  IOException  {  if  (  length  =  =  0  )  {  [ATTENTION]  return  1  ;  }  int  len  =  super  .  read  (  buf  ,  offset  ,  length  )  ;    if  (  len  >  0  )  {  for  (  int  i  =  offset  ;  i  <  offset  +  len  ;  i++  )  {  char  ch  =  buf[i]  ;  if  (  ch  =  =  '\n'  )  {  if  (  '\r'  !  =    (  i  >  0  ?  buf[i-1]:  lastChar  )  )  {  lineCounter++  ;  }  }  else  if  (  ch  =  =  '\r'  )  {  lineCounter++  ;  }  }  lastChar  =  buf[offset  +  len  -  1]  ;    }  else  if  (  len  =  =  -1  )  {  lastChar  =  END_OF_STREAM  ;  }  return  len  ;  }    [METHOD]  read  [TYPE]  int  [PARAMETER]  char[]  buf  int  offset  int  length  [CLASS]  ExtendedBufferedReader    [TYPE]  char  ch  [TYPE]  boolean  false  true  [TYPE]  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  [TYPE]  char[]  buf  
[REPLACE]  int  len  =  super  .  read  (  buf,  offset,  length  )  ;	[BUGGY]  int  len  =  super  .  read  (  buf  ,  lineCounter  ,  length  )  ;  [FE]  AssertionFailedError    expected:<[ "x  ,  y "]  ,  z>  but  was:<[x  ,  y]  ,  z>  assertEquals( " "  ,  format.format())  ;  assertEquals( "a  ,  b  ,  c "  ,  format.format( "a "  ,   "b "  ,   "c "))  ;  assertEquals( "\ "x  ,  y\ "  ,  z "  ,  format.format( "x  ,  y "  ,   "z "))  ;  [CONTEXT]  public  int  read  (  char[]  buf  ,  int  offset  ,  int  length  )  throws  IOException  {  if  (  length  =  =  0  )  {  return  0  ;  }  [ATTENTION]  int  len  =  super  .  read  (  buf  ,  lineCounter  ,  length  )    ;    if  (  len  >  0  )  {  for  (  int  i  =  offset  ;  i  <  offset  +  len  ;  i++  )  {  char  ch  =  buf[i]  ;  if  (  ch  =  =  '\n'  )  {  if  (  '\r'  !  =    (  i  >  0  ?  buf[i-1]:  lastChar  )  )  {  lineCounter++  ;  }  }  else  if  (  ch  =  =  '\r'  )  {  lineCounter++  ;  }  }  lastChar  =  buf[offset  +  len  -  1]  ;    }  else  if  (  len  =  =  -1  )  {  lastChar  =  END_OF_STREAM  ;  }  return  len  ;  }    [METHOD]  read  [TYPE]  int  [PARAMETER]  char[]  buf  int  offset  int  length  [CLASS]  ExtendedBufferedReader    [TYPE]  char  ch  [TYPE]  boolean  false  true  [TYPE]  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  [TYPE]  char[]  buf  
[REPLACE]  if  (  len  >  0  )  {	[BUGGY]  if  (  len  >  =    0  )  {[FE]  AssertionFailedError    expected:<[ "x  ,  y "]  ,  z>  but  was:<[x  ,  y]  ,  z>  assertEquals( " "  ,  format.format())  ;  assertEquals( "a  ,  b  ,  c "  ,  format.format( "a "  ,   "b "  ,   "c "))  ;  assertEquals( "\ "x  ,  y\ "  ,  z "  ,  format.format( "x  ,  y "  ,   "z "))  ;  [CONTEXT]  public  int  read  (  char[]  buf  ,  int  offset  ,  int  length  )  throws  IOException  {  if  (  length  =  =  0  )  {  return  0  ;  }  int  len  =  super  .  read  (  buf  ,  offset  ,  length  )  ;    [ATTENTION]  if  (  len>  =  0  )  {  for  (  int  i  =  offset  ;  i  <  offset  +  len  ;  i++  )  {  char  ch  =  buf[i]  ;  if  (  ch  =  =  '\n'  )  {  if  (  '\r'  !  =    (  i  >  0  ?  buf[i-1]:  lastChar  )  )  {  lineCounter++  ;  }  }  else  if  (  ch  =  =  '\r'  )  {  lineCounter++  ;  }  }  lastChar  =  buf[offset  +  len  -  1]  ;    }  else  if  (  len  =  =  -1  )  {  lastChar  =  END_OF_STREAM  ;  }  return  len  ;  }    [METHOD]  read  [TYPE]  int  [PARAMETER]  char[]  buf  int  offset  int  length  [CLASS]  ExtendedBufferedReader    [TYPE]  char  ch  [TYPE]  boolean  false  true  [TYPE]  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  [TYPE]  char[]  buf  
[REPLACE]  }  else  if  (  len  ==  -1  )  {	[BUGGY]    if  (  len  !  =  offset  )  {[FE]  AssertionFailedError    expected:<[ "x  ,  y "]  ,  z>  but  was:<[x  ,  y]  ,  z>  assertEquals( " "  ,  format.format())  ;  assertEquals( "a  ,  b  ,  c "  ,  format.format( "a "  ,   "b "  ,   "c "))  ;  assertEquals( "\ "x  ,  y\ "  ,  z "  ,  format.format( "x  ,  y "  ,   "z "))  ;  [CONTEXT]  public  int  read  (  char[]  buf  ,  int  offset  ,  int  length  )  throws  IOException  {  if  (  length  =  =  0  )  {  return  0  ;  }  int  len  =  super  .  read  (  buf  ,  offset  ,  length  )  ;    if  (  len  >  0  )  {  for  (  int  i  =  offset  ;  i  <  offset  +  len  ;  i++  )  {  char  ch  =  buf[i]  ;  if  (  ch  =  =  '\n'  )  {  if  (  '\r'  !  =    (  i  >  0  ?  buf[i-1]:  lastChar  )  )  {  lineCounter++  ;  }  }  else  if  (  ch  =  =  '\r'  )  {  lineCounter++  ;  }  }  lastChar  =  buf[offset  +  len  -  1]  ;    [ATTENTION]  }if  (  len!  =  offset  )  {  lastChar  =  END_OF_STREAM  ;  }  return  len  ;  }    [METHOD]  read  [TYPE]  int  [PARAMETER]  char[]  buf  int  offset  int  length  [CLASS]  ExtendedBufferedReader    [TYPE]  char  ch  [TYPE]  boolean  false  true  [TYPE]  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  [TYPE]  char[]  buf  
[ADD]  else  if  (  len  ==  -1  )  {  lastChar  =  END_OF_STREAM;  }	[BUGGY]    lastChar  =  END_OF_STREAM  ;  [FE]  AssertionFailedError    expected:<[ "x  ,  y "]  ,  z>  but  was:<[x  ,  y]  ,  z>  assertEquals( " "  ,  format.format())  ;  assertEquals( "a  ,  b  ,  c "  ,  format.format( "a "  ,   "b "  ,   "c "))  ;  assertEquals( "\ "x  ,  y\ "  ,  z "  ,  format.format( "x  ,  y "  ,   "z "))  ;  [CONTEXT]  public  int  read  (  char[]  buf  ,  int  offset  ,  int  length  )  throws  IOException  {  if  (  length  =  =  0  )  {  return  0  ;  }  int  len  =  super  .  read  (  buf  ,  offset  ,  length  )  ;    if  (  len  >  0  )  {  for  (  int  i  =  offset  ;  i  <  offset  +  len  ;  i++  )  {  char  ch  =  buf[i]  ;  if  (  ch  =  =  '\n'  )  {  if  (  '\r'  !  =    (  i  >  0  ?  buf[i-1]:  lastChar  )  )  {  lineCounter++  ;  }  }  else  if  (  ch  =  =  '\r'  )  {  lineCounter++  ;  }  }  lastChar  =  buf[offset  +  len  -  1]  ;    [ATTENTION]  }  lastChar  =  END_OF_STREAM  ;      return  len  ;  }    [METHOD]  read  [TYPE]  int  [PARAMETER]  char[]  buf  int  offset  int  length  [CLASS]  ExtendedBufferedReader    [TYPE]  char  ch  [TYPE]  boolean  false  true  [TYPE]  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  [TYPE]  char[]  buf  
[REPLACE]  lastChar  =  END_OF_STREAM;	[BUGGY]  lastChar  ;  [CE]  not  a  statement  [CONTEXT]  public  int  read  (  char[]  buf  ,  int  offset  ,  int  length  )  throws  IOException  {  if  (  length  =  =  0  )  {  return  0  ;  }  int  len  =  super  .  read  (  buf  ,  offset  ,  length  )  ;    if  (  len  >  0  )  {  for  (  int  i  =  offset  ;  i  <  offset  +  len  ;  i++  )  {  char  ch  =  buf[i]  ;  if  (  ch  =  =  '\n'  )  {  if  (  '\r'  !  =    (  i  >  0  ?  buf[i-1]:  lastChar  )  )  {  lineCounter++  ;  }  }  else  if  (  ch  =  =  '\r'  )  {  lineCounter++  ;  }  }  lastChar  =  buf[offset  +  len  -  1]  ;    }  else  if  (  len  =  =  -1  )  {  [ATTENTION]  lastChar  ;  }  return  len  ;  }    [METHOD]  read  [TYPE]  int  [PARAMETER]  char[]  buf  int  offset  int  length  [CLASS]  ExtendedBufferedReader    [TYPE]  char  ch  [TYPE]  boolean  false  true  [TYPE]  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  [TYPE]  char[]  buf  
[REPLACE]  lastChar  =  END_OF_STREAM;	[BUGGY]  lastChar    =    lastChar  ;  [FE]  AssertionFailedError    expected:<[ "x  ,  y "]  ,  z>  but  was:<[x  ,  y]  ,  z>  assertEquals( " "  ,  format.format())  ;  assertEquals( "a  ,  b  ,  c "  ,  format.format( "a "  ,   "b "  ,   "c "))  ;  assertEquals( "\ "x  ,  y\ "  ,  z "  ,  format.format( "x  ,  y "  ,   "z "))  ;  [CONTEXT]  public  int  read  (  char[]  buf  ,  int  offset  ,  int  length  )  throws  IOException  {  if  (  length  =  =  0  )  {  return  0  ;  }  int  len  =  super  .  read  (  buf  ,  offset  ,  length  )  ;    if  (  len  >  0  )  {  for  (  int  i  =  offset  ;  i  <  offset  +  len  ;  i++  )  {  char  ch  =  buf[i]  ;  if  (  ch  =  =  '\n'  )  {  if  (  '\r'  !  =    (  i  >  0  ?  buf[i-1]:  lastChar  )  )  {  lineCounter++  ;  }  }  else  if  (  ch  =  =  '\r'  )  {  lineCounter++  ;  }  }  lastChar  =  buf[offset  +  len  -  1]  ;    }  else  if  (  len  =  =  -1  )  {  [ATTENTION]  lastChar  =  lastChar  ;  }  return  len  ;  }    [METHOD]  read  [TYPE]  int  [PARAMETER]  char[]  buf  int  offset  int  length  [CLASS]  ExtendedBufferedReader    [TYPE]  char  ch  [TYPE]  boolean  false  true  [TYPE]  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  [TYPE]  char[]  buf  
[REPLACE]  if  (  ch  ==  '\n'  )  {	[BUGGY]  if  (  ch  ||  '\n'  )  {[CE]  bad  operand  types  for  binary  operator  '||'  [CONTEXT]  public  int  read  (  char[]  buf  ,  int  offset  ,  int  length  )  throws  IOException  {  if  (  length  =  =  0  )  {  return  0  ;  }  int  len  =  super  .  read  (  buf  ,  offset  ,  length  )  ;    if  (  len  >  0  )  {  for  (  int  i  =  offset  ;  i  <  offset  +  len  ;  i++  )  {  char  ch  =  buf[i]  ;  [ATTENTION]  if  (  ch||'\n'  )  {  if  (  '\r'  !  =    (  i  >  0  ?  buf[i-1]:  lastChar  )  )  {  lineCounter++  ;  }  }  else  if  (  ch  =  =  '\r'  )  {  lineCounter++  ;  }  }  lastChar  =  buf[offset  +  len  -  1]  ;    }  else  if  (  len  =  =  -1  )  {  lastChar  =  END_OF_STREAM  ;  }  return  len  ;  }    [METHOD]  read  [TYPE]  int  [PARAMETER]  char[]  buf  int  offset  int  length  [CLASS]  ExtendedBufferedReader    [TYPE]  char  ch  [TYPE]  boolean  false  true  [TYPE]  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  [TYPE]  char[]  buf  
[REPLACE]  }  else  if  (  ch  ==  '\r'  )  {	[BUGGY]    if  (  ch  !  =    '\r'  )  {[FE]  AssertionFailedError    expected:<[ "x  ,  y "]  ,  z>  but  was:<[x  ,  y]  ,  z>  assertEquals( " "  ,  format.format())  ;  assertEquals( "a  ,  b  ,  c "  ,  format.format( "a "  ,   "b "  ,   "c "))  ;  assertEquals( "\ "x  ,  y\ "  ,  z "  ,  format.format( "x  ,  y "  ,   "z "))  ;  [CONTEXT]  public  int  read  (  char[]  buf  ,  int  offset  ,  int  length  )  throws  IOException  {  if  (  length  =  =  0  )  {  return  0  ;  }  int  len  =  super  .  read  (  buf  ,  offset  ,  length  )  ;    if  (  len  >  0  )  {  for  (  int  i  =  offset  ;  i  <  offset  +  len  ;  i++  )  {  char  ch  =  buf[i]  ;  if  (  ch  =  =  '\n'  )  {  if  (  '\r'  !  =    (  i  >  0  ?  buf[i-1]:  lastChar  )  )  {  lineCounter++  ;  }  [ATTENTION]  }if  (  ch!  =  '\r'  )  {  lineCounter++  ;  }  }  lastChar  =  buf[offset  +  len  -  1]  ;    }  else  if  (  len  =  =  -1  )  {  lastChar  =  END_OF_STREAM  ;  }  return  len  ;  }    [METHOD]  read  [TYPE]  int  [PARAMETER]  char[]  buf  int  offset  int  length  [CLASS]  ExtendedBufferedReader    [TYPE]  char  ch  [TYPE]  boolean  false  true  [TYPE]  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  [TYPE]  char[]  buf  
[ADD]  else  if  (  ch  ==  '\r'  )  {  lineCounter++;  }	[BUGGY]    lineCounter++  ;  [FE]  AssertionFailedError    expected:<[ "x  ,  y "]  ,  z>  but  was:<[x  ,  y]  ,  z>  assertEquals( " "  ,  format.format())  ;  assertEquals( "a  ,  b  ,  c "  ,  format.format( "a "  ,   "b "  ,   "c "))  ;  assertEquals( "\ "x  ,  y\ "  ,  z "  ,  format.format( "x  ,  y "  ,   "z "))  ;  [CONTEXT]  public  int  read  (  char[]  buf  ,  int  offset  ,  int  length  )  throws  IOException  {  if  (  length  =  =  0  )  {  return  0  ;  }  int  len  =  super  .  read  (  buf  ,  offset  ,  length  )  ;    if  (  len  >  0  )  {  for  (  int  i  =  offset  ;  i  <  offset  +  len  ;  i++  )  {  char  ch  =  buf[i]  ;  if  (  ch  =  =  '\n'  )  {  if  (  '\r'  !  =    (  i  >  0  ?  buf[i-1]:  lastChar  )  )  {  lineCounter++  ;  }  [ATTENTION]  }  lineCounter++  ;    }  lastChar  =  buf[offset  +  len  -  1]  ;    }  else  if  (  len  =  =  -1  )  {  lastChar  =  END_OF_STREAM  ;  }  return  len  ;  }    [METHOD]  read  [TYPE]  int  [PARAMETER]  char[]  buf  int  offset  int  length  [CLASS]  ExtendedBufferedReader    [TYPE]  char  ch  [TYPE]  boolean  false  true  [TYPE]  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  [TYPE]  char[]  buf  
[REPLACE]  if  (  '\r'  !=  (  i  >  0  ?  buf[i-1]:  lastChar  )  )  {	[BUGGY]  if  (  '\r'    =    buf[i-1]  ;  [CE]  ')'  expected  [CONTEXT]  public  int  read  (  char[]  buf  ,  int  offset  ,  int  length  )  throws  IOException  {  if  (  length  =  =  0  )  {  return  0  ;  }  int  len  =  super  .  read  (  buf  ,  offset  ,  length  )  ;    if  (  len  >  0  )  {  for  (  int  i  =  offset  ;  i  <  offset  +  len  ;  i++  )  {  char  ch  =  buf[i]  ;  if  (  ch  =  =  '\n'  )  {  [ATTENTION]  if  (  '\r'  =  buf[i-1]  ;  lineCounter++  ;  }  }  else  if  (  ch  =  =  '\r'  )  {  lineCounter++  ;  }  }  lastChar  =  buf[offset  +  len  -  1]  ;    }  else  if  (  len  =  =  -1  )  {  lastChar  =  END_OF_STREAM  ;  }  return  len  ;  }    [METHOD]  read  [TYPE]  int  [PARAMETER]  char[]  buf  int  offset  int  length  [CLASS]  ExtendedBufferedReader    [TYPE]  char  ch  [TYPE]  boolean  false  true  [TYPE]  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  [TYPE]  char[]  buf  
[REPLACE]  if  (  '\r'  !=  (  i  >  0  ?  buf[i-1]:  lastChar  )  )  {	[BUGGY]  if  (  '\r'  !  =    lastChar  )  )  {[CE]  ')'  expected  [CONTEXT]  public  int  read  (  char[]  buf  ,  int  offset  ,  int  length  )  throws  IOException  {  if  (  length  =  =  0  )  {  return  0  ;  }  int  len  =  super  .  read  (  buf  ,  offset  ,  length  )  ;    if  (  len  >  0  )  {  for  (  int  i  =  offset  ;  i  <  offset  +  len  ;  i++  )  {  char  ch  =  buf[i]  ;  if  (  ch  =  =  '\n'  )  {  [ATTENTION]  if  (  '\r'  !  =  lastChar  )  )  {  lineCounter++  ;  }  }  else  if  (  ch  =  =  '\r'  )  {  lineCounter++  ;  }  }  lastChar  =  buf[offset  +  len  -  1]  ;    }  else  if  (  len  =  =  -1  )  {  lastChar  =  END_OF_STREAM  ;  }  return  len  ;  }    [METHOD]  read  [TYPE]  int  [PARAMETER]  char[]  buf  int  offset  int  length  [CLASS]  ExtendedBufferedReader    [TYPE]  char  ch  [TYPE]  boolean  false  true  [TYPE]  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  [TYPE]  char[]  buf  
[REPLACE]  }  else  if  (  ch  ==  '\r'  )  {	[BUGGY]    else  {[FE]  AssertionFailedError    expected:<[ "x  ,  y "]  ,  z>  but  was:<[x  ,  y]  ,  z>  assertEquals( " "  ,  format.format())  ;  assertEquals( "a  ,  b  ,  c "  ,  format.format( "a "  ,   "b "  ,   "c "))  ;  assertEquals( "\ "x  ,  y\ "  ,  z "  ,  format.format( "x  ,  y "  ,   "z "))  ;  [CONTEXT]  public  int  read  (  char[]  buf  ,  int  offset  ,  int  length  )  throws  IOException  {  if  (  length  =  =  0  )  {  return  0  ;  }  int  len  =  super  .  read  (  buf  ,  offset  ,  length  )  ;    if  (  len  >  0  )  {  for  (  int  i  =  offset  ;  i  <  offset  +  len  ;  i++  )  {  char  ch  =  buf[i]  ;  if  (  ch  =  =  '\n'  )  {  if  (  '\r'  !  =    (  i  >  0  ?  buf[i-1]:  lastChar  )  )  {  lineCounter++  ;  }  [ATTENTION]  }else  {  lineCounter++  ;  }  }  lastChar  =  buf[offset  +  len  -  1]  ;    }  else  if  (  len  =  =  -1  )  {  lastChar  =  END_OF_STREAM  ;  }  return  len  ;  }    [METHOD]  read  [TYPE]  int  [PARAMETER]  char[]  buf  int  offset  int  length  [CLASS]  ExtendedBufferedReader    [TYPE]  char  ch  [TYPE]  boolean  false  true  [TYPE]  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  [TYPE]  char[]  buf  
[REPLACE]  for  (  int  i  =  offset;  i  <  offset  +  len;  i++  )  {	[BUGGY]  for  (  int  i  =  offset  ;  i  >  =    offset  +  len  ;  i++  )  {[FE]  AssertionFailedError    expected:<[ "x  ,  y "]  ,  z>  but  was:<[x  ,  y]  ,  z>  assertEquals( " "  ,  format.format())  ;  assertEquals( "a  ,  b  ,  c "  ,  format.format( "a "  ,   "b "  ,   "c "))  ;  assertEquals( "\ "x  ,  y\ "  ,  z "  ,  format.format( "x  ,  y "  ,   "z "))  ;  [CONTEXT]  public  int  read  (  char[]  buf  ,  int  offset  ,  int  length  )  throws  IOException  {  if  (  length  =  =  0  )  {  return  0  ;  }  int  len  =  super  .  read  (  buf  ,  offset  ,  length  )  ;    if  (  len  >  0  )  {  [ATTENTION]  for  (  int  i  =  offset  ;  i>  =  offset  +  len  ;  i++  )  {  char  ch  =  buf[i]  ;  if  (  ch  =  =  '\n'  )  {  if  (  '\r'  !  =    (  i  >  0  ?  buf[i-1]:  lastChar  )  )  {  lineCounter++  ;  }  }  else  if  (  ch  =  =  '\r'  )  {  lineCounter++  ;  }  }  lastChar  =  buf[offset  +  len  -  1]  ;    }  else  if  (  len  =  =  -1  )  {  lastChar  =  END_OF_STREAM  ;  }  return  len  ;  }    [METHOD]  read  [TYPE]  int  [PARAMETER]  char[]  buf  int  offset  int  length  [CLASS]  ExtendedBufferedReader    [TYPE]  char  ch  [TYPE]  boolean  false  true  [TYPE]  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  [TYPE]  char[]  buf  
[ADD]  if  (  '\r'  !=  (  i  >  0  ?  buf[i-1]:  lastChar  )  )  {  lineCounter++;  }	[BUGGY]  [FE]  AssertionFailedError    expected:<[ "x  ,  y "]  ,  z>  but  was:<[x  ,  y]  ,  z>  assertEquals( " "  ,  format.format())  ;  assertEquals( "a  ,  b  ,  c "  ,  format.format( "a "  ,   "b "  ,   "c "))  ;  assertEquals( "\ "x  ,  y\ "  ,  z "  ,  format.format( "x  ,  y "  ,   "z "))  ;  [CONTEXT]  public  int  read  (  char[]  buf  ,  int  offset  ,  int  length  )  throws  IOException  {  if  (  length  =  =  0  )  {  return  0  ;  }  int  len  =  super  .  read  (  buf  ,  offset  ,  length  )  ;    if  (  len  >  0  )  {  for  (  int  i  =  offset  ;  i  <  offset  +  len  ;  i++  )  {  char  ch  =  buf[i]  ;  if  (  ch  =  =  '\n'  )  {  [ATTENTION]    }  else  if  (  ch  =  =  '\r'  )  {  lineCounter++  ;  }  }  lastChar  =  buf[offset  +  len  -  1]  ;    }  else  if  (  len  =  =  -1  )  {  lastChar  =  END_OF_STREAM  ;  }  return  len  ;  }    [METHOD]  read  [TYPE]  int  [PARAMETER]  char[]  buf  int  offset  int  length  [CLASS]  ExtendedBufferedReader    [TYPE]  char  ch  [TYPE]  boolean  false  true  [TYPE]  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  [TYPE]  char[]  buf  
[REPLACE]  if  (  '\r'  !=  (  i  >  0  ?  buf[i-1]:  lastChar  )  )  {	[BUGGY]  if  (  '\r'  !  =    buf[i-1]  ;  [CE]  ')'  expected  [CONTEXT]  public  int  read  (  char[]  buf  ,  int  offset  ,  int  length  )  throws  IOException  {  if  (  length  =  =  0  )  {  return  0  ;  }  int  len  =  super  .  read  (  buf  ,  offset  ,  length  )  ;    if  (  len  >  0  )  {  for  (  int  i  =  offset  ;  i  <  offset  +  len  ;  i++  )  {  char  ch  =  buf[i]  ;  if  (  ch  =  =  '\n'  )  {  [ATTENTION]  if  (  '\r'  !  =  buf[i-1]  ;  lineCounter++  ;  }  }  else  if  (  ch  =  =  '\r'  )  {  lineCounter++  ;  }  }  lastChar  =  buf[offset  +  len  -  1]  ;    }  else  if  (  len  =  =  -1  )  {  lastChar  =  END_OF_STREAM  ;  }  return  len  ;  }    [METHOD]  read  [TYPE]  int  [PARAMETER]  char[]  buf  int  offset  int  length  [CLASS]  ExtendedBufferedReader    [TYPE]  char  ch  [TYPE]  boolean  false  true  [TYPE]  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  [TYPE]  char[]  buf  
[ADD]  if  (  '\r'  !=  (  i  >  0  ?  buf[i-1]:  lastChar  )  )  {  lineCounter++;  }	[BUGGY]  lineCounter++  ;  [FE]  AssertionFailedError    expected:<[ "x  ,  y "]  ,  z>  but  was:<[x  ,  y]  ,  z>  assertEquals( " "  ,  format.format())  ;  assertEquals( "a  ,  b  ,  c "  ,  format.format( "a "  ,   "b "  ,   "c "))  ;  assertEquals( "\ "x  ,  y\ "  ,  z "  ,  format.format( "x  ,  y "  ,   "z "))  ;  [CONTEXT]  public  int  read  (  char[]  buf  ,  int  offset  ,  int  length  )  throws  IOException  {  if  (  length  =  =  0  )  {  return  0  ;  }  int  len  =  super  .  read  (  buf  ,  offset  ,  length  )  ;    if  (  len  >  0  )  {  for  (  int  i  =  offset  ;  i  <  offset  +  len  ;  i++  )  {  char  ch  =  buf[i]  ;  if  (  ch  =  =  '\n'  )  {  [ATTENTION]  lineCounter++  ;    }  else  if  (  ch  =  =  '\r'  )  {  lineCounter++  ;  }  }  lastChar  =  buf[offset  +  len  -  1]  ;    }  else  if  (  len  =  =  -1  )  {  lastChar  =  END_OF_STREAM  ;  }  return  len  ;  }    [METHOD]  read  [TYPE]  int  [PARAMETER]  char[]  buf  int  offset  int  length  [CLASS]  ExtendedBufferedReader    [TYPE]  char  ch  [TYPE]  boolean  false  true  [TYPE]  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  [TYPE]  char[]  buf  
[REPLACE]  char  ch  =  buf[i];	[BUGGY]  for  (  int  i  =  offset  ;  i  <  offset  +  len  ;  i++  )  {  char  ch  =  buf[i]  ;  [CE]  'else'  without  'if'  [CONTEXT]  public  int  read  (  char[]  buf  ,  int  offset  ,  int  length  )  throws  IOException  {  if  (  length  =  =  0  )  {  return  0  ;  }  int  len  =  super  .  read  (  buf  ,  offset  ,  length  )  ;    if  (  len  >  0  )  {  for  (  int  i  =  offset  ;  i  <  offset  +  len  ;  i++  )  {  [ATTENTION]  for  (  int  i  =  offset  ;  i  <  offset  +  len  ;  i++  )  {  char  ch  =  buf[i]  ;  if  (  ch  =  =  '\n'  )  {  if  (  '\r'  !  =    (  i  >  0  ?  buf[i-1]:  lastChar  )  )  {  lineCounter++  ;  }  }  else  if  (  ch  =  =  '\r'  )  {  lineCounter++  ;  }  }  lastChar  =  buf[offset  +  len  -  1]  ;    }  else  if  (  len  =  =  -1  )  {  lastChar  =  END_OF_STREAM  ;  }  return  len  ;  }    [METHOD]  read  [TYPE]  int  [PARAMETER]  char[]  buf  int  offset  int  length  [CLASS]  ExtendedBufferedReader    [TYPE]  char  ch  [TYPE]  boolean  false  true  [TYPE]  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  [TYPE]  char[]  buf  
[REPLACE]  lastChar  =  buf[offset  +  len  -  1];	[BUGGY]  lastChar  =  buf[offset  +  len  -offset]  ;  [FE]  AssertionFailedError    expected:<[ "x  ,  y "]  ,  z>  but  was:<[x  ,  y]  ,  z>  assertEquals( " "  ,  format.format())  ;  assertEquals( "a  ,  b  ,  c "  ,  format.format( "a "  ,   "b "  ,   "c "))  ;  assertEquals( "\ "x  ,  y\ "  ,  z "  ,  format.format( "x  ,  y "  ,   "z "))  ;  [CONTEXT]  public  int  read  (  char[]  buf  ,  int  offset  ,  int  length  )  throws  IOException  {  if  (  length  =  =  0  )  {  return  0  ;  }  int  len  =  super  .  read  (  buf  ,  offset  ,  length  )  ;    if  (  len  >  0  )  {  for  (  int  i  =  offset  ;  i  <  offset  +  len  ;  i++  )  {  char  ch  =  buf[i]  ;  if  (  ch  =  =  '\n'  )  {  if  (  '\r'  !  =    (  i  >  0  ?  buf[i-1]:  lastChar  )  )  {  lineCounter++  ;  }  }  else  if  (  ch  =  =  '\r'  )  {  lineCounter++  ;  }  }  [ATTENTION]  lastChar  =  buf[offset  +  len  -offset]  ;    }  else  if  (  len  =  =  -1  )  {  lastChar  =  END_OF_STREAM  ;  }  return  len  ;  }    [METHOD]  read  [TYPE]  int  [PARAMETER]  char[]  buf  int  offset  int  length  [CLASS]  ExtendedBufferedReader    [TYPE]  char  ch  [TYPE]  boolean  false  true  [TYPE]  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  [TYPE]  char[]  buf  
[REPLACE]  for  (  int  i  =  offset;  i  <  offset  +  len;  i++  )  {	[BUGGY]  for  (  int  i  =  lineCounter  ;  i  <  offset  +  len  ;  i++  )  {[FE]  AssertionFailedError    expected:<[ "x  ,  y "]  ,  z>  but  was:<[x  ,  y]  ,  z>  assertEquals( " "  ,  format.format())  ;  assertEquals( "a  ,  b  ,  c "  ,  format.format( "a "  ,   "b "  ,   "c "))  ;  assertEquals( "\ "x  ,  y\ "  ,  z "  ,  format.format( "x  ,  y "  ,   "z "))  ;  [CONTEXT]  public  int  read  (  char[]  buf  ,  int  offset  ,  int  length  )  throws  IOException  {  if  (  length  =  =  0  )  {  return  0  ;  }  int  len  =  super  .  read  (  buf  ,  offset  ,  length  )  ;    if  (  len  >  0  )  {  [ATTENTION]  for  (  int  i  =  lineCounter  ;  i  <  offset  +  len  ;  i++  )  {  char  ch  =  buf[i]  ;  if  (  ch  =  =  '\n'  )  {  if  (  '\r'  !  =    (  i  >  0  ?  buf[i-1]:  lastChar  )  )  {  lineCounter++  ;  }  }  else  if  (  ch  =  =  '\r'  )  {  lineCounter++  ;  }  }  lastChar  =  buf[offset  +  len  -  1]  ;    }  else  if  (  len  =  =  -1  )  {  lastChar  =  END_OF_STREAM  ;  }  return  len  ;  }    [METHOD]  read  [TYPE]  int  [PARAMETER]  char[]  buf  int  offset  int  length  [CLASS]  ExtendedBufferedReader    [TYPE]  char  ch  [TYPE]  boolean  false  true  [TYPE]  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  [TYPE]  char[]  buf  
[REPLACE]  }  else  if  (  ch  ==  '\r'  )  {	[BUGGY]    if  (  ch  ||  '\r'  )  {[CE]  bad  operand  types  for  binary  operator  '||'  [CONTEXT]  public  int  read  (  char[]  buf  ,  int  offset  ,  int  length  )  throws  IOException  {  if  (  length  =  =  0  )  {  return  0  ;  }  int  len  =  super  .  read  (  buf  ,  offset  ,  length  )  ;    if  (  len  >  0  )  {  for  (  int  i  =  offset  ;  i  <  offset  +  len  ;  i++  )  {  char  ch  =  buf[i]  ;  if  (  ch  =  =  '\n'  )  {  if  (  '\r'  !  =    (  i  >  0  ?  buf[i-1]:  lastChar  )  )  {  lineCounter++  ;  }  [ATTENTION]  }if  (  ch||'\r'  )  {  lineCounter++  ;  }  }  lastChar  =  buf[offset  +  len  -  1]  ;    }  else  if  (  len  =  =  -1  )  {  lastChar  =  END_OF_STREAM  ;  }  return  len  ;  }    [METHOD]  read  [TYPE]  int  [PARAMETER]  char[]  buf  int  offset  int  length  [CLASS]  ExtendedBufferedReader    [TYPE]  char  ch  [TYPE]  boolean  false  true  [TYPE]  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  [TYPE]  char[]  buf  
[REMOVE]  	[BUGGY]  if  (  (  current  =  =  '\r'  )  ||  (  (  current  =  =  '\n'  )  &&  (  (  lastChar  )  !  =  '\r'  )  )  )  {      (  lineCounter  )  ++  ;  }[CE]  cannot  find  symbol  current  [CONTEXT]  public  int  read  (  char[]  buf  ,  int  offset  ,  int  length  )  throws  IOException  {  if  (  length  =  =  0  )  {  return  0  ;  }  int  len  =  super  .  read  (  buf  ,  offset  ,  length  )  ;    if  (  len  >  0  )  {  for  (  int  i  =  offset  ;  i  <  offset  +  len  ;  i++  )  {  char  ch  =  buf[i]  ;  if  (  ch  =  =  '\n'  )  {  [ATTENTION]  if  (  '\r'  !  =    (  i  >  0  ?  buf[i-1]:  lastChar  )  )  {  if  (  (  current  =  =  '\r'  )  ||  (  (  current  =  =  '\n'  )  &&  (  (  lastChar  )  !  =  '\r'  )  )  )  {  (  lineCounter  )  ++  ;  }lineCounter++  ;  }  }  else  if  (  ch  =  =  '\r'  )  {  lineCounter++  ;  }  }  lastChar  =  buf[offset  +  len  -  1]  ;    }  else  if  (  len  =  =  -1  )  {  lastChar  =  END_OF_STREAM  ;  }  return  len  ;      [METHOD]  read  [TYPE]  int  [PARAMETER]  char[]  buf  int  offset  int  length  [CLASS]  ExtendedBufferedReader    [TYPE]  char  ch  [TYPE]  boolean  false  true  [TYPE]  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  [TYPE]  char[]  buf  
[REPLACE]  }  else  if  (  ch  ==  '\r'  )  {	[BUGGY]    if  (  ch  &&  '\r'  )  {[CE]  bad  operand  types  for  binary  operator  '&&'  [CONTEXT]  public  int  read  (  char[]  buf  ,  int  offset  ,  int  length  )  throws  IOException  {  if  (  length  =  =  0  )  {  return  0  ;  }  int  len  =  super  .  read  (  buf  ,  offset  ,  length  )  ;    if  (  len  >  0  )  {  for  (  int  i  =  offset  ;  i  <  offset  +  len  ;  i++  )  {  char  ch  =  buf[i]  ;  if  (  ch  =  =  '\n'  )  {  if  (  '\r'  !  =    (  i  >  0  ?  buf[i-1]:  lastChar  )  )  {  lineCounter++  ;  }  [ATTENTION]  }if  (  ch&&'\r'  )  {  lineCounter++  ;  }  }  lastChar  =  buf[offset  +  len  -  1]  ;    }  else  if  (  len  =  =  -1  )  {  lastChar  =  END_OF_STREAM  ;  }  return  len  ;  }    [METHOD]  read  [TYPE]  int  [PARAMETER]  char[]  buf  int  offset  int  length  [CLASS]  ExtendedBufferedReader    [TYPE]  char  ch  [TYPE]  boolean  false  true  [TYPE]  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  [TYPE]  char[]  buf  
[REPLACE]  }  else  if  (  len  ==  -1  )  {	[BUGGY]    else  {[FE]  AssertionFailedError    expected:<[ "x  ,  y "]  ,  z>  but  was:<[x  ,  y]  ,  z>  assertEquals( " "  ,  format.format())  ;  assertEquals( "a  ,  b  ,  c "  ,  format.format( "a "  ,   "b "  ,   "c "))  ;  assertEquals( "\ "x  ,  y\ "  ,  z "  ,  format.format( "x  ,  y "  ,   "z "))  ;  [CONTEXT]  public  int  read  (  char[]  buf  ,  int  offset  ,  int  length  )  throws  IOException  {  if  (  length  =  =  0  )  {  return  0  ;  }  int  len  =  super  .  read  (  buf  ,  offset  ,  length  )  ;    if  (  len  >  0  )  {  for  (  int  i  =  offset  ;  i  <  offset  +  len  ;  i++  )  {  char  ch  =  buf[i]  ;  if  (  ch  =  =  '\n'  )  {  if  (  '\r'  !  =    (  i  >  0  ?  buf[i-1]:  lastChar  )  )  {  lineCounter++  ;  }  }  else  if  (  ch  =  =  '\r'  )  {  lineCounter++  ;  }  }  lastChar  =  buf[offset  +  len  -  1]  ;    [ATTENTION]  }else  {  lastChar  =  END_OF_STREAM  ;  }  return  len  ;  }    [METHOD]  read  [TYPE]  int  [PARAMETER]  char[]  buf  int  offset  int  length  [CLASS]  ExtendedBufferedReader    [TYPE]  char  ch  [TYPE]  boolean  false  true  [TYPE]  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  [TYPE]  char[]  buf  
[REPLACE]  lastChar  =  END_OF_STREAM;	[BUGGY]  lastChar    =  null  ;  [CE]  incompatible  types  [CONTEXT]  public  int  read  (  char[]  buf  ,  int  offset  ,  int  length  )  throws  IOException  {  if  (  length  =  =  0  )  {  return  0  ;  }  int  len  =  super  .  read  (  buf  ,  offset  ,  length  )  ;    if  (  len  >  0  )  {  for  (  int  i  =  offset  ;  i  <  offset  +  len  ;  i++  )  {  char  ch  =  buf[i]  ;  if  (  ch  =  =  '\n'  )  {  if  (  '\r'  !  =    (  i  >  0  ?  buf[i-1]:  lastChar  )  )  {  lineCounter++  ;  }  }  else  if  (  ch  =  =  '\r'  )  {  lineCounter++  ;  }  }  lastChar  =  buf[offset  +  len  -  1]  ;    }  else  if  (  len  =  =  -1  )  {  [ATTENTION]  lastChar  =  null  ;  }  return  len  ;  }    [METHOD]  read  [TYPE]  int  [PARAMETER]  char[]  buf  int  offset  int  length  [CLASS]  ExtendedBufferedReader    [TYPE]  char  ch  [TYPE]  boolean  false  true  [TYPE]  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  [TYPE]  char[]  buf  
[REPLACE]  for  (  int  i  =  offset;  i  <  offset  +  len;  i++  )  {	[BUGGY]  for  (lineCounternt  i  =  offset  ;  i  >  =    offset  +  len  ;  i++  )  {[CE]  cannot  find  symbol  [CONTEXT]  public  int  read  (  char[]  buf  ,  int  offset  ,  int  length  )  throws  IOException  {  if  (  length  =  =  0  )  {  return  0  ;  }  int  len  =  super  .  read  (  buf  ,  offset  ,  length  )  ;    if  (  len  >  0  )  {  [ATTENTION]  for  (  lineCounternt  i  =  offset  ;  i>  =  offset  +  len  ;  i++  )  {  char  ch  =  buf[i]  ;  if  (  ch  =  =  '\n'  )  {  if  (  '\r'  !  =    (  i  >  0  ?  buf[i-1]:  lastChar  )  )  {  lineCounter++  ;  }  }  else  if  (  ch  =  =  '\r'  )  {  lineCounter++  ;  }  }  lastChar  =  buf[offset  +  len  -  1]  ;    }  else  if  (  len  =  =  -1  )  {  lastChar  =  END_OF_STREAM  ;  }  return  len  ;  }    [METHOD]  read  [TYPE]  int  [PARAMETER]  char[]  buf  int  offset  int  length  [CLASS]  ExtendedBufferedReader    [TYPE]  char  ch  [TYPE]  boolean  false  true  [TYPE]  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  [TYPE]  char[]  buf  
[ADD]  if  (  ch  ==  '\n'  )  {  if  (  '\r'  !=  (  i  >  0  ?  buf[i-1]:  lastChar  )  )  {  lineCounter++;  }	[BUGGY]  [CE]  'else'  without  'if'  [CONTEXT]  public  int  read  (  char[]  buf  ,  int  offset  ,  int  length  )  throws  IOException  {  if  (  length  =  =  0  )  {  return  0  ;  }  int  len  =  super  .  read  (  buf  ,  offset  ,  length  )  ;    if  (  len  >  0  )  {  for  (  int  i  =  offset  ;  i  <  offset  +  len  ;  i++  )  {  char  ch  =  buf[i]  ;  [ATTENTION]      }  else  if  (  ch  =  =  '\r'  )  {  lineCounter++  ;  }  }  lastChar  =  buf[offset  +  len  -  1]  ;    }  else  if  (  len  =  =  -1  )  {  lastChar  =  END_OF_STREAM  ;  }  return  len  ;  }    [METHOD]  read  [TYPE]  int  [PARAMETER]  char[]  buf  int  offset  int  length  [CLASS]  ExtendedBufferedReader    [TYPE]  char  ch  [TYPE]  boolean  false  true  [TYPE]  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  [TYPE]  char[]  buf  
[REMOVE]  	[BUGGY]  if  (  (  current  =  =  '\r'  )  ||  (  (  current  =  =  '\n'  )  &&  (  (  lastChar  )  !  =  '\r'  )  )  )  {      (  lineCounter  )  ++  ;  }[CE]  cannot  find  symbol  current  [CONTEXT]  public  int  read  (  char[]  buf  ,  int  offset  ,  int  length  )  throws  IOException  {  if  (  length  =  =  0  )  {  return  0  ;  }  int  len  =  super  .  read  (  buf  ,  offset  ,  length  )  ;    if  (  len  >  0  )  {  for  (  int  i  =  offset  ;  i  <  offset  +  len  ;  i++  )  {  char  ch  =  buf[i]  ;  if  (  ch  =  =  '\n'  )  {  if  (  '\r'  !  =    (  i  >  0  ?  buf[i-1]:  lastChar  )  )  {  lineCounter++  ;  }  [ATTENTION]  }  else  if  (  ch  =  =  '\r'  )  {  if  (  (  current  =  =  '\r'  )  ||  (  (  current  =  =  '\n'  )  &&  (  (  lastChar  )  !  =  '\r'  )  )  )  {  (  lineCounter  )  ++  ;  }lineCounter++  ;  }  }  lastChar  =  buf[offset  +  len  -  1]  ;    }  else  if  (  len  =  =  -1  )  {  lastChar  =  END_OF_STREAM  ;  }  return  len  ;      [METHOD]  read  [TYPE]  int  [PARAMETER]  char[]  buf  int  offset  int  length  [CLASS]  ExtendedBufferedReader    [TYPE]  char  ch  [TYPE]  boolean  false  true  [TYPE]  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  [TYPE]  char[]  buf  
[ADD]  else  if  (  ch  ==  '\r'  )  {  lineCounter++;  }	[BUGGY]  [FE]  AssertionFailedError    expected:<[ "x  ,  y "]  ,  z>  but  was:<[x  ,  y]  ,  z>  assertEquals( " "  ,  format.format())  ;  assertEquals( "a  ,  b  ,  c "  ,  format.format( "a "  ,   "b "  ,   "c "))  ;  assertEquals( "\ "x  ,  y\ "  ,  z "  ,  format.format( "x  ,  y "  ,   "z "))  ;  [CONTEXT]  public  int  read  (  char[]  buf  ,  int  offset  ,  int  length  )  throws  IOException  {  if  (  length  =  =  0  )  {  return  0  ;  }  int  len  =  super  .  read  (  buf  ,  offset  ,  length  )  ;    if  (  len  >  0  )  {  for  (  int  i  =  offset  ;  i  <  offset  +  len  ;  i++  )  {  char  ch  =  buf[i]  ;  if  (  ch  =  =  '\n'  )  {  if  (  '\r'  !  =    (  i  >  0  ?  buf[i-1]:  lastChar  )  )  {  lineCounter++  ;  }  [ATTENTION]  }    }  lastChar  =  buf[offset  +  len  -  1]  ;    }  else  if  (  len  =  =  -1  )  {  lastChar  =  END_OF_STREAM  ;  }  return  len  ;  }    [METHOD]  read  [TYPE]  int  [PARAMETER]  char[]  buf  int  offset  int  length  [CLASS]  ExtendedBufferedReader    [TYPE]  char  ch  [TYPE]  boolean  false  true  [TYPE]  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  [TYPE]  char[]  buf  
[REPLACE]  lastChar  =  buf[offset  +  len  -  1];	[BUGGY]  lastChar  =  buf[offset  +  len  ||  1]  ;  [CE]  bad  operand  types  for  binary  operator  '||'  [CONTEXT]  public  int  read  (  char[]  buf  ,  int  offset  ,  int  length  )  throws  IOException  {  if  (  length  =  =  0  )  {  return  0  ;  }  int  len  =  super  .  read  (  buf  ,  offset  ,  length  )  ;    if  (  len  >  0  )  {  for  (  int  i  =  offset  ;  i  <  offset  +  len  ;  i++  )  {  char  ch  =  buf[i]  ;  if  (  ch  =  =  '\n'  )  {  if  (  '\r'  !  =    (  i  >  0  ?  buf[i-1]:  lastChar  )  )  {  lineCounter++  ;  }  }  else  if  (  ch  =  =  '\r'  )  {  lineCounter++  ;  }  }  [ATTENTION]  lastChar  =  buf[offset  +  len||1]  ;    }  else  if  (  len  =  =  -1  )  {  lastChar  =  END_OF_STREAM  ;  }  return  len  ;  }    [METHOD]  read  [TYPE]  int  [PARAMETER]  char[]  buf  int  offset  int  length  [CLASS]  ExtendedBufferedReader    [TYPE]  char  ch  [TYPE]  boolean  false  true  [TYPE]  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  [TYPE]  char[]  buf  
[ADD]  lastChar  =  END_OF_STREAM;	[BUGGY]  [FE]  AssertionFailedError    expected:<[ "x  ,  y "]  ,  z>  but  was:<[x  ,  y]  ,  z>  assertEquals( " "  ,  format.format())  ;  assertEquals( "a  ,  b  ,  c "  ,  format.format( "a "  ,   "b "  ,   "c "))  ;  assertEquals( "\ "x  ,  y\ "  ,  z "  ,  format.format( "x  ,  y "  ,   "z "))  ;  [CONTEXT]  public  int  read  (  char[]  buf  ,  int  offset  ,  int  length  )  throws  IOException  {  if  (  length  =  =  0  )  {  return  0  ;  }  int  len  =  super  .  read  (  buf  ,  offset  ,  length  )  ;    if  (  len  >  0  )  {  for  (  int  i  =  offset  ;  i  <  offset  +  len  ;  i++  )  {  char  ch  =  buf[i]  ;  if  (  ch  =  =  '\n'  )  {  if  (  '\r'  !  =    (  i  >  0  ?  buf[i-1]:  lastChar  )  )  {  lineCounter++  ;  }  }  else  if  (  ch  =  =  '\r'  )  {  lineCounter++  ;  }  }  lastChar  =  buf[offset  +  len  -  1]  ;    }  else  if  (  len  =  =  -1  )  {  [ATTENTION]  }  return  len  ;  }    [METHOD]  read  [TYPE]  int  [PARAMETER]  char[]  buf  int  offset  int  length  [CLASS]  ExtendedBufferedReader    [TYPE]  char  ch  [TYPE]  boolean  false  true  [TYPE]  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  [TYPE]  char[]  buf  
[REPLACE]  return  len;	[BUGGY]  return  lineCounter  ;  [FE]  AssertionFailedError    expected:<[ "x  ,  y "]  ,  z>  but  was:<[x  ,  y]  ,  z>  assertEquals( " "  ,  format.format())  ;  assertEquals( "a  ,  b  ,  c "  ,  format.format( "a "  ,   "b "  ,   "c "))  ;  assertEquals( "\ "x  ,  y\ "  ,  z "  ,  format.format( "x  ,  y "  ,   "z "))  ;  [CONTEXT]  public  int  read  (  char[]  buf  ,  int  offset  ,  int  length  )  throws  IOException  {  if  (  length  =  =  0  )  {  return  0  ;  }  int  len  =  super  .  read  (  buf  ,  offset  ,  length  )  ;    if  (  len  >  0  )  {  for  (  int  i  =  offset  ;  i  <  offset  +  len  ;  i++  )  {  char  ch  =  buf[i]  ;  if  (  ch  =  =  '\n'  )  {  if  (  '\r'  !  =    (  i  >  0  ?  buf[i-1]:  lastChar  )  )  {  lineCounter++  ;  }  }  else  if  (  ch  =  =  '\r'  )  {  lineCounter++  ;  }  }  lastChar  =  buf[offset  +  len  -  1]  ;    }  else  if  (  len  =  =  -1  )  {  lastChar  =  END_OF_STREAM  ;  }  [ATTENTION]  return  lineCounter  ;  }    [METHOD]  read  [TYPE]  int  [PARAMETER]  char[]  buf  int  offset  int  length  [CLASS]  ExtendedBufferedReader    [TYPE]  char  ch  [TYPE]  boolean  false  true  [TYPE]  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  [TYPE]  char[]  buf  
[REPLACE]  String  line  =  super  .  readLine  (  )  ;	[BUGGY]  String  line  =  super  .  read  (  )    ;  [CE]  incompatible  types  [CONTEXT]  public  String  readLine  (  )  throws  IOException  {  [ATTENTION]  String  line  =  super  .  read  (  )  ;    if  (  line  !  =  null  )  {  if  (  line  .  length  (  )  >  0  )  {  lastChar  =  line  .  charAt  (  line  .  length  (  )  -  1  )  ;  }  lineCounter++  ;  }  else  {  lastChar  =  END_OF_STREAM  ;  }  return  line  ;  }    [METHOD]  readLine  [TYPE]  String  [PARAMETER]  [CLASS]  ExtendedBufferedReader    [TYPE]  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  [TYPE]  String  line  [TYPE]  boolean  false  true  
[ADD]  String  line  =  super  .  readLine  (  )  ;	[BUGGY]  [CE]  cannot  find  symbol  line  [CONTEXT]  public  String  readLine  (  )  throws  IOException  {  [ATTENTION]    if  (  line  !  =  null  )  {  if  (  line  .  length  (  )  >  0  )  {  lastChar  =  line  .  charAt  (  line  .  length  (  )  -  1  )  ;  }  lineCounter++  ;  }  else  {  lastChar  =  END_OF_STREAM  ;  }  return  line  ;  }    [METHOD]  readLine  [TYPE]  String  [PARAMETER]  [CLASS]  ExtendedBufferedReader    [TYPE]  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  [TYPE]  String  line  [TYPE]  boolean  false  true  
[REPLACE]  if  (  line  !=  null  )  {	[BUGGY]  if  (  line  =  =  null  )  {[FE]  AssertionFailedError    expected:<[ "x  ,  y "]  ,  z>  but  was:<[x  ,  y]  ,  z>  assertEquals( " "  ,  format.format())  ;  assertEquals( "a  ,  b  ,  c "  ,  format.format( "a "  ,   "b "  ,   "c "))  ;  assertEquals( "\ "x  ,  y\ "  ,  z "  ,  format.format( "x  ,  y "  ,   "z "))  ;  [CONTEXT]  public  String  readLine  (  )  throws  IOException  {  String  line  =  super  .  readLine  (  )  ;    [ATTENTION]  if  (  line  =  =  null  )  {  if  (  line  .  length  (  )  >  0  )  {  lastChar  =  line  .  charAt  (  line  .  length  (  )  -  1  )  ;  }  lineCounter++  ;  }  else  {  lastChar  =  END_OF_STREAM  ;  }  return  line  ;  }    [METHOD]  readLine  [TYPE]  String  [PARAMETER]  [CLASS]  ExtendedBufferedReader    [TYPE]  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  [TYPE]  String  line  [TYPE]  boolean  false  true  
[REPLACE]  lastChar  =  END_OF_STREAM;	[BUGGY]  lastChar    =  null  ;  [CE]  incompatible  types  [CONTEXT]  public  String  readLine  (  )  throws  IOException  {  String  line  =  super  .  readLine  (  )  ;    if  (  line  !  =  null  )  {  if  (  line  .  length  (  )  >  0  )  {  lastChar  =  line  .  charAt  (  line  .  length  (  )  -  1  )  ;  }  lineCounter++  ;  }  else  {  [ATTENTION]  lastChar  =  null  ;  }  return  line  ;  }    [METHOD]  readLine  [TYPE]  String  [PARAMETER]  [CLASS]  ExtendedBufferedReader    [TYPE]  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  [TYPE]  String  line  [TYPE]  boolean  false  true  
[REPLACE]  if  (  line  .  length  (  )  >  0  )  {	[BUGGY]  if  (  line  .  length  (  )  *  0  .  5  >  0  )  {[FE]  AssertionFailedError    expected:<[ "x  ,  y "]  ,  z>  but  was:<[x  ,  y]  ,  z>  assertEquals( " "  ,  format.format())  ;  assertEquals( "a  ,  b  ,  c "  ,  format.format( "a "  ,   "b "  ,   "c "))  ;  assertEquals( "\ "x  ,  y\ "  ,  z "  ,  format.format( "x  ,  y "  ,   "z "))  ;  [CONTEXT]  public  String  readLine  (  )  throws  IOException  {  String  line  =  super  .  readLine  (  )  ;    if  (  line  !  =  null  )  {  [ATTENTION]  if  (  line  .  length  (  )  *0  .  5>  0  )  {  lastChar  =  line  .  charAt  (  line  .  length  (  )  -  1  )  ;  }  lineCounter++  ;  }  else  {  lastChar  =  END_OF_STREAM  ;  }  return  line  ;  }    [METHOD]  readLine  [TYPE]  String  [PARAMETER]  [CLASS]  ExtendedBufferedReader    [TYPE]  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  [TYPE]  String  line  [TYPE]  boolean  false  true  
[REPLACE]  lastChar  =  line  .  charAt  (  line  .  length  (  )  -  1  )  ;	[BUGGY]  lastChar  =  line  .  charAt  (  line  .  length  (  )  +  4  -  1  )  ;  [FE]  AssertionFailedError    expected:<[ "x  ,  y "]  ,  z>  but  was:<[x  ,  y]  ,  z>  assertEquals( " "  ,  format.format())  ;  assertEquals( "a  ,  b  ,  c "  ,  format.format( "a "  ,   "b "  ,   "c "))  ;  assertEquals( "\ "x  ,  y\ "  ,  z "  ,  format.format( "x  ,  y "  ,   "z "))  ;  [CONTEXT]  public  String  readLine  (  )  throws  IOException  {  String  line  =  super  .  readLine  (  )  ;    if  (  line  !  =  null  )  {  if  (  line  .  length  (  )  >  0  )  {  [ATTENTION]  lastChar  =  line  .  charAt  (  line  .  length  (  )  +  4  -  1  )    ;  }  lineCounter++  ;  }  else  {  lastChar  =  END_OF_STREAM  ;  }  return  line  ;  }    [METHOD]  readLine  [TYPE]  String  [PARAMETER]  [CLASS]  ExtendedBufferedReader    [TYPE]  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  [TYPE]  String  line  [TYPE]  boolean  false  true  
[REPLACE]  lastChar  =  line  .  charAt  (  line  .  length  (  )  -  1  )  ;	[BUGGY]  lastChar  =  line  .  charAt  (  line  .  length  (  )  *  0  .  5  -  0  )  ;  [CE]  method  charAt  in  class  String  cannot  be  applied  to  given  types  ;  [CONTEXT]  public  String  readLine  (  )  throws  IOException  {  String  line  =  super  .  readLine  (  )  ;    if  (  line  !  =  null  )  {  if  (  line  .  length  (  )  >  0  )  {  [ATTENTION]  lastChar  =  line  .  charAt  (  line  .  length  (  )  *0  .  5-  0  )    ;  }  lineCounter++  ;  }  else  {  lastChar  =  END_OF_STREAM  ;  }  return  line  ;  }    [METHOD]  readLine  [TYPE]  String  [PARAMETER]  [CLASS]  ExtendedBufferedReader    [TYPE]  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  [TYPE]  String  line  [TYPE]  boolean  false  true  
[REPLACE]  if  (  line  .  length  (  )  >  0  )  {	[BUGGY]  if  (  line  .  length  (  )  -  1  >  0  )  {[FE]  AssertionFailedError    expected:<[ "x  ,  y "]  ,  z>  but  was:<[x  ,  y]  ,  z>  assertEquals( " "  ,  format.format())  ;  assertEquals( "a  ,  b  ,  c "  ,  format.format( "a "  ,   "b "  ,   "c "))  ;  assertEquals( "\ "x  ,  y\ "  ,  z "  ,  format.format( "x  ,  y "  ,   "z "))  ;  [CONTEXT]  public  String  readLine  (  )  throws  IOException  {  String  line  =  super  .  readLine  (  )  ;    if  (  line  !  =  null  )  {  [ATTENTION]  if  (  line  .  length  (  )  -  1  >  0  )  {  lastChar  =  line  .  charAt  (  line  .  length  (  )  -  1  )  ;  }  lineCounter++  ;  }  else  {  lastChar  =  END_OF_STREAM  ;  }  return  line  ;  }    [METHOD]  readLine  [TYPE]  String  [PARAMETER]  [CLASS]  ExtendedBufferedReader    [TYPE]  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  [TYPE]  String  line  [TYPE]  boolean  false  true  
[REPLACE]  lastChar  =  line  .  charAt  (  line  .  length  (  )  -  1  )  ;	[BUGGY]  lastChar  =  line  .  charAt  (  line  .  length  (  )  %  2  -  1  )  ;  [FE]  AssertionFailedError    expected:<[ "x  ,  y "]  ,  z>  but  was:<[x  ,  y]  ,  z>  assertEquals( " "  ,  format.format())  ;  assertEquals( "a  ,  b  ,  c "  ,  format.format( "a "  ,   "b "  ,   "c "))  ;  assertEquals( "\ "x  ,  y\ "  ,  z "  ,  format.format( "x  ,  y "  ,   "z "))  ;  [CONTEXT]  public  String  readLine  (  )  throws  IOException  {  String  line  =  super  .  readLine  (  )  ;    if  (  line  !  =  null  )  {  if  (  line  .  length  (  )  >  0  )  {  [ATTENTION]  lastChar  =  line  .  charAt  (  line  .  length  (  )  %2  -  1  )    ;  }  lineCounter++  ;  }  else  {  lastChar  =  END_OF_STREAM  ;  }  return  line  ;  }    [METHOD]  readLine  [TYPE]  String  [PARAMETER]  [CLASS]  ExtendedBufferedReader    [TYPE]  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  [TYPE]  String  line  [TYPE]  boolean  false  true  
[REPLACE]  lastChar  =  line  .  charAt  (  line  .  length  (  )  -  1  )  ;	[BUGGY]  lastChar  =  line  .  charAt  (  line  .  length  (  )  -  4  -  1  )  ;  [FE]  AssertionFailedError    expected:<[ "x  ,  y "]  ,  z>  but  was:<[x  ,  y]  ,  z>  assertEquals( " "  ,  format.format())  ;  assertEquals( "a  ,  b  ,  c "  ,  format.format( "a "  ,   "b "  ,   "c "))  ;  assertEquals( "\ "x  ,  y\ "  ,  z "  ,  format.format( "x  ,  y "  ,   "z "))  ;  [CONTEXT]  public  String  readLine  (  )  throws  IOException  {  String  line  =  super  .  readLine  (  )  ;    if  (  line  !  =  null  )  {  if  (  line  .  length  (  )  >  0  )  {  [ATTENTION]  lastChar  =  line  .  charAt  (  line  .  length  (  )  -  4  -  1  )    ;  }  lineCounter++  ;  }  else  {  lastChar  =  END_OF_STREAM  ;  }  return  line  ;  }    [METHOD]  readLine  [TYPE]  String  [PARAMETER]  [CLASS]  ExtendedBufferedReader    [TYPE]  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  [TYPE]  String  line  [TYPE]  boolean  false  true  
[REPLACE]  lastChar  =  END_OF_STREAM;	[BUGGY]  lastChar    =    lastChar  ;  [FE]  AssertionFailedError    expected:<[ "x  ,  y "]  ,  z>  but  was:<[x  ,  y]  ,  z>  assertEquals( " "  ,  format.format())  ;  assertEquals( "a  ,  b  ,  c "  ,  format.format( "a "  ,   "b "  ,   "c "))  ;  assertEquals( "\ "x  ,  y\ "  ,  z "  ,  format.format( "x  ,  y "  ,   "z "))  ;  [CONTEXT]  public  String  readLine  (  )  throws  IOException  {  String  line  =  super  .  readLine  (  )  ;    if  (  line  !  =  null  )  {  if  (  line  .  length  (  )  >  0  )  {  lastChar  =  line  .  charAt  (  line  .  length  (  )  -  1  )  ;  }  lineCounter++  ;  }  else  {  [ATTENTION]  lastChar  =  lastChar  ;  }  return  line  ;  }    [METHOD]  readLine  [TYPE]  String  [PARAMETER]  [CLASS]  ExtendedBufferedReader    [TYPE]  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  [TYPE]  String  line  [TYPE]  boolean  false  true  
[REPLACE]  return  line;	[BUGGY]  return  len  ;  [CE]  cannot  find  symbol  len  [CONTEXT]  public  String  readLine  (  )  throws  IOException  {  String  line  =  super  .  readLine  (  )  ;    if  (  line  !  =  null  )  {  if  (  line  .  length  (  )  >  0  )  {  lastChar  =  line  .  charAt  (  line  .  length  (  )  -  1  )  ;  }  lineCounter++  ;  }  else  {  lastChar  =  END_OF_STREAM  ;  }  [ATTENTION]  return  len  ;  }    [METHOD]  readLine  [TYPE]  String  [PARAMETER]  [CLASS]  ExtendedBufferedReader    [TYPE]  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  [TYPE]  String  line  [TYPE]  boolean  false  true  
[REPLACE]  super  .  mark  (  1  )  ;	[BUGGY]  super  .  readLine  (  )    ;  [FE]  AssertionFailedError    expected:<[ "x  ,  y "]  ,  z>  but  was:<[x  ,  y]  ,  z>  assertEquals( " "  ,  format.format())  ;  assertEquals( "a  ,  b  ,  c "  ,  format.format( "a "  ,   "b "  ,   "c "))  ;  assertEquals( "\ "x  ,  y\ "  ,  z "  ,  format.format( "x  ,  y "  ,   "z "))  ;  [CONTEXT]  int  lookAhead  (  )  throws  IOException  {  [ATTENTION]  super  .  readLine  (  )  ;  int  c  =  super  .  read  (  )  ;  super  .  reset  (  )  ;    return  c  ;  }    [METHOD]  lookAhead  [TYPE]  int  [PARAMETER]  [CLASS]  ExtendedBufferedReader    [TYPE]  int  END_OF_STREAM  UNDEFINED  c  current  i  lastChar  len  length  lineCounter  offset  [TYPE]  boolean  false  true  
[REPLACE]  int  c  =  super  .  read  (  )  ;	[BUGGY]  int  c  =  super  .  read  (  )    ;  [FE]  AssertionFailedError    expected:<[ "x  ,  y "]  ,  z>  but  was:<[x  ,  y]  ,  z>  assertEquals( " "  ,  format.format())  ;  assertEquals( "a  ,  b  ,  c "  ,  format.format( "a "  ,   "b "  ,   "c "))  ;  assertEquals( "\ "x  ,  y\ "  ,  z "  ,  format.format( "x  ,  y "  ,   "z "))  ;  [CONTEXT]  int  lookAhead  (  )  throws  IOException  {  super  .  mark  (  1  )  ;  [ATTENTION]  int  c  =  super  .  read  (  )  ;  super  .  reset  (  )  ;    return  c  ;  }    [METHOD]  lookAhead  [TYPE]  int  [PARAMETER]  [CLASS]  ExtendedBufferedReader    [TYPE]  int  END_OF_STREAM  UNDEFINED  c  current  i  lastChar  len  length  lineCounter  offset  [TYPE]  boolean  false  true  
[REPLACE]  super  .  reset  (  )  ;	[BUGGY]  super  .  read  (  )    ;  [FE]  AssertionFailedError    expected:<[ "x  ,  y "]  ,  z>  but  was:<[x  ,  y]  ,  z>  assertEquals( " "  ,  format.format())  ;  assertEquals( "a  ,  b  ,  c "  ,  format.format( "a "  ,   "b "  ,   "c "))  ;  assertEquals( "\ "x  ,  y\ "  ,  z "  ,  format.format( "x  ,  y "  ,   "z "))  ;  [CONTEXT]  int  lookAhead  (  )  throws  IOException  {  super  .  mark  (  1  )  ;  int  c  =  super  .  read  (  )  ;  [ATTENTION]  super  .  read  (  )  ;    return  c  ;  }    [METHOD]  lookAhead  [TYPE]  int  [PARAMETER]  [CLASS]  ExtendedBufferedReader    [TYPE]  int  END_OF_STREAM  UNDEFINED  c  current  i  lastChar  len  length  lineCounter  offset  [TYPE]  boolean  false  true  
[ADD]  super  .  reset  (  )  ;	[BUGGY]  [FE]  AssertionFailedError    expected:<[ "x  ,  y "]  ,  z>  but  was:<[x  ,  y]  ,  z>  assertEquals( " "  ,  format.format())  ;  assertEquals( "a  ,  b  ,  c "  ,  format.format( "a "  ,   "b "  ,   "c "))  ;  assertEquals( "\ "x  ,  y\ "  ,  z "  ,  format.format( "x  ,  y "  ,   "z "))  ;  [CONTEXT]  int  lookAhead  (  )  throws  IOException  {  super  .  mark  (  1  )  ;  int  c  =  super  .  read  (  )  ;  [ATTENTION]    return  c  ;  }    [METHOD]  lookAhead  [TYPE]  int  [PARAMETER]  [CLASS]  ExtendedBufferedReader    [TYPE]  int  END_OF_STREAM  UNDEFINED  c  current  i  lastChar  len  length  lineCounter  offset  [TYPE]  boolean  false  true  
[REPLACE]  return  c;	[BUGGY]  return  lineCounter  ;  [FE]  AssertionFailedError    expected:<[ "x  ,  y "]  ,  z>  but  was:<[x  ,  y]  ,  z>  assertEquals( " "  ,  format.format())  ;  assertEquals( "a  ,  b  ,  c "  ,  format.format( "a "  ,   "b "  ,   "c "))  ;  assertEquals( "\ "x  ,  y\ "  ,  z "  ,  format.format( "x  ,  y "  ,   "z "))  ;  [CONTEXT]  int  lookAhead  (  )  throws  IOException  {  super  .  mark  (  1  )  ;  int  c  =  super  .  read  (  )  ;  super  .  reset  (  )  ;    [ATTENTION]  return  lineCounter  ;  }    [METHOD]  lookAhead  [TYPE]  int  [PARAMETER]  [CLASS]  ExtendedBufferedReader    [TYPE]  int  END_OF_STREAM  UNDEFINED  c  current  i  lastChar  len  length  lineCounter  offset  [TYPE]  boolean  false  true  
[REPLACE]  return  lineCounter;	[BUGGY]  return  line  ;  [CE]  cannot  find  symbol  line  [CONTEXT]  int  getLineNumber  (  )  {  [ATTENTION]  return  line  ;  }    [METHOD]  getLineNumber  [TYPE]  int  [PARAMETER]  [CLASS]  ExtendedBufferedReader    [TYPE]  int  END_OF_STREAM  UNDEFINED  c  current  i  lastChar  len  length  lineCounter  offset  [TYPE]  boolean  false  true  
[REPLACE]  private  static  final  String  CRLF  =   "\r\n ";	[BUGGY]  private  static  final  String  CRLF  ;  [CE]  variable  CRLF  might  not  have  been  initialized  [CONTEXT]      [CLASS]  CSVFormat  
[REPLACE]  private  final  char  commentStart;	[BUGGY]  private  char  commentStart  ;  [FE]  AssertionFailedError    expected:<[ "x  ,  y "]  ,  z>  but  was:<[x  ,  y]  ,  z>  assertEquals( " "  ,  format.format())  ;  assertEquals( "a  ,  b  ,  c "  ,  format.format( "a "  ,   "b "  ,   "c "))  ;  assertEquals( "\ "x  ,  y\ "  ,  z "  ,  format.format( "x  ,  y "  ,   "z "))  ;  [CONTEXT]      [CLASS]  CSVFormat  
[REPLACE]  private  final  char  escape;	[BUGGY]  private  char  escape  ;  [FE]  AssertionFailedError    expected:<[ "x  ,  y "]  ,  z>  but  was:<[x  ,  y]  ,  z>  assertEquals( " "  ,  format.format())  ;  assertEquals( "a  ,  b  ,  c "  ,  format.format( "a "  ,   "b "  ,   "c "))  ;  assertEquals( "\ "x  ,  y\ "  ,  z "  ,  format.format( "x  ,  y "  ,   "z "))  ;  [CONTEXT]      [CLASS]  CSVFormat  
[REPLACE]  private  final  boolean  surroundingSpacesIgnored;	[BUGGY]  private  boolean  surroundingSpacesIgnored  ;  [FE]  AssertionFailedError    expected:<[ "x  ,  y "]  ,  z>  but  was:<[x  ,  y]  ,  z>  assertEquals( " "  ,  format.format())  ;  assertEquals( "a  ,  b  ,  c "  ,  format.format( "a "  ,   "b "  ,   "c "))  ;  assertEquals( "\ "x  ,  y\ "  ,  z "  ,  format.format( "x  ,  y "  ,   "z "))  ;  [CONTEXT]      [CLASS]  CSVFormat  
[REPLACE]  static  final  char  DISABLED  =  '\ufffe';	[BUGGY]  final  char  DISABLED  =  '\ufffe'  ;  [CE]  non-static  variable  DISABLED  cannot  be  referenced  from  a  static  context  [CONTEXT]      [CLASS]  CSVFormat  
[REPLACE]  private  static  CSVFormat  PRISTINE  =  new  CSVFormat  (  DISABLED,  DISABLED,  DISABLED,  DISABLED,  false,  false,  null,  null  )  ;	[BUGGY]  private  static  CSVFormat  PRISTINE    =  null  ;  [FE]  null  assertNotNull(format)  ;  assertEquals( "delimiter "  ,  CSVFormat.DEFAULT.getDelimiter()  ,  format.getDelimiter())  ;  assertEquals( "encapsulator "  ,  CSVFormat.DEFAULT.getEncapsulator()  ,  format.getEncapsulator())  ;  assertEquals( "comment  start "  ,  CSVFormat.DEFAULT.getCommentStart()  ,  format.getCommentStart())  ;  assertEquals( "line  separator "  ,  CSVFormat.DEFAULT.getLineSeparator()  ,  format.getLineSeparator())  ;  assertEquals( "escape "  ,  CSVFormat.DEFAULT.getEscape()  ,  format.getEscape())  ;  assertEquals( "trim "  ,  CSVFormat.DEFAULT.isSurroundingSpacesIgnored()  ,  format.isSurroundingSpacesIgnored())  ;  assertEquals( "empty  lines "  ,  CSVFormat.DEFAULT.isEmptyLinesIgnored()  ,  format.isEmptyLinesIgnored())  ;  [CONTEXT]      [CLASS]  CSVFormat  
[REPLACE]  public  static  final  CSVFormat  DEFAULT  =  PRISTINE  .    withDelimiter  (  ','  )    .  withEncapsulator  (  ' "'  )	[BUGGY]  public  static  CSVFormat  DEFAULT  =  PRISTINE  .  withDelimiter  (  '  ,  '  )  .  withEncapsulator  (  ' "'  )[NO-ERROR]  [CONTEXT]  [ATTENTION]  public  staticCSVFormat  DEFAULT  =  PRISTINE  .  withDelimiter  (  '  ,  '  )    .  withEncapsulator  (  ' "'  )      .  withEmptyLinesIgnored  (  true  )    .  withLineSeparator  (  CRLF  )  ;      [CLASS]  CSVFormat  
[REPLACE]  public  static  final  CSVFormat  RFC4180  =  PRISTINE  .    withDelimiter  (  ','  )    .  withEncapsulator  (  ' "'  )	[BUGGY]  public  static  final  CSVFormat  RFC4180  ;  [CE]  illegal  start  of  type  [CONTEXT]  [ATTENTION]  public  static  final  CSVFormat  RFC4180  ;      .  withLineSeparator  (  CRLF  )  ;      [CLASS]  CSVFormat  
[REPLACE]  public  static  final  CSVFormat  EXCEL  =  PRISTINE    .  withDelimiter  (  ','  )    .  withEncapsulator  (  ' "'  )	[BUGGY]  public  static  final  CSVFormat  EXCEL  ;  [CE]  illegal  start  of  type  [CONTEXT]  [ATTENTION]  public  static  final  CSVFormat  EXCEL  ;      .  withLineSeparator  (  CRLF  )  ;      [CLASS]  CSVFormat  
[REPLACE]  public  static  final  CSVFormat  TDF  =  PRISTINE    .  withDelimiter  (  '\t'  )    .  withEncapsulator  (  ' "'  )	[BUGGY]  public  static  final  CSVFormat  TDF  ;  [CE]  illegal  start  of  type  [CONTEXT]  [ATTENTION]  public  static  final  CSVFormat  TDF  ;      .  withSurroundingSpacesIgnored  (  true  )    .  withEmptyLinesIgnored  (  true  )    .  withLineSeparator  (  CRLF  )  ;      [CLASS]  CSVFormat  
[REPLACE]  public  static  final  CSVFormat  MYSQL  =  PRISTINE    .  withDelimiter  (  '\t'  )    .  withEscape  (  '\\'  )	[BUGGY]  public  static  final  CSVFormat  MYSQL  ;  [CE]  illegal  start  of  type  [CONTEXT]  [ATTENTION]  public  static  final  CSVFormat  MYSQL  ;      .  withLineSeparator  (   "\n "  )  ;      [CLASS]  CSVFormat  
[REPLACE]  this  .  delimiter  =  delimiter;	[BUGGY]  this  .  delimiter  =    escape  ;  [FE]  The  encapsulator  character  and  the  delimiter  cannot  be  the  same  ( "  [CONTEXT]  CSVFormat  (  char  delimiter  ,  char  encapsulator  ,  char  commentStart  ,  char  escape  ,  boolean  surroundingSpacesIgnored  ,  boolean  emptyLinesIgnored  ,  String  lineSeparator  ,  String[]  header  )  {  [ATTENTION]  this  .  delimiter  =  escape  ;  this  .  encapsulator  =  encapsulator  ;  this  .  commentStart  =  commentStart  ;  this  .  escape  =  escape  ;  this  .  surroundingSpacesIgnored  =  surroundingSpacesIgnored  ;  this  .  emptyLinesIgnored  =  emptyLinesIgnored  ;  this  .  lineSeparator  =  lineSeparator  ;  this  .  header  =  header  ;  }    [METHOD]  <init>  [TYPE]  String[])  [PARAMETER]  char  delimiter  char  encapsulator  char  commentStart  char  escape  boolean  surroundingSpacesIgnored  boolean  emptyLinesIgnored  String  lineSeparator  String[]  header  [CLASS]  CSVFormat    [TYPE]  char  DISABLED  commentStart  delimiter  encapsulator  escape  [TYPE]  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  [TYPE]  boolean  emptyLinesIgnored  false  surroundingSpacesIgnored  true  [TYPE]  String  CRLF  lineSeparator  [TYPE]  String[]  header  
[REPLACE]  this  .  encapsulator  =  encapsulator;	[BUGGY]  this  .  encapsulator  =    escape  ;  [FE]  null  [CONTEXT]  CSVFormat  (  char  delimiter  ,  char  encapsulator  ,  char  commentStart  ,  char  escape  ,  boolean  surroundingSpacesIgnored  ,  boolean  emptyLinesIgnored  ,  String  lineSeparator  ,  String[]  header  )  {  this  .  delimiter  =  delimiter  ;  [ATTENTION]  this  .  encapsulator  =  escape  ;  this  .  commentStart  =  commentStart  ;  this  .  escape  =  escape  ;  this  .  surroundingSpacesIgnored  =  surroundingSpacesIgnored  ;  this  .  emptyLinesIgnored  =  emptyLinesIgnored  ;  this  .  lineSeparator  =  lineSeparator  ;  this  .  header  =  header  ;  }    [METHOD]  <init>  [TYPE]  String[])  [PARAMETER]  char  delimiter  char  encapsulator  char  commentStart  char  escape  boolean  surroundingSpacesIgnored  boolean  emptyLinesIgnored  String  lineSeparator  String[]  header  [CLASS]  CSVFormat    [TYPE]  char  DISABLED  commentStart  delimiter  encapsulator  escape  [TYPE]  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  [TYPE]  boolean  emptyLinesIgnored  false  surroundingSpacesIgnored  true  [TYPE]  String  CRLF  lineSeparator  [TYPE]  String[]  header  
[REPLACE]  this  .  commentStart  =  commentStart;	[BUGGY]  this  .  commentStart  =    null  ;  [CE]  incompatible  types  [CONTEXT]  CSVFormat  (  char  delimiter  ,  char  encapsulator  ,  char  commentStart  ,  char  escape  ,  boolean  surroundingSpacesIgnored  ,  boolean  emptyLinesIgnored  ,  String  lineSeparator  ,  String[]  header  )  {  this  .  delimiter  =  delimiter  ;  this  .  encapsulator  =  encapsulator  ;  [ATTENTION]  this  .  commentStart  =  null  ;  this  .  escape  =  escape  ;  this  .  surroundingSpacesIgnored  =  surroundingSpacesIgnored  ;  this  .  emptyLinesIgnored  =  emptyLinesIgnored  ;  this  .  lineSeparator  =  lineSeparator  ;  this  .  header  =  header  ;  }    [METHOD]  <init>  [TYPE]  String[])  [PARAMETER]  char  delimiter  char  encapsulator  char  commentStart  char  escape  boolean  surroundingSpacesIgnored  boolean  emptyLinesIgnored  String  lineSeparator  String[]  header  [CLASS]  CSVFormat    [TYPE]  char  DISABLED  commentStart  delimiter  encapsulator  escape  [TYPE]  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  [TYPE]  boolean  emptyLinesIgnored  false  surroundingSpacesIgnored  true  [TYPE]  String  CRLF  lineSeparator  [TYPE]  String[]  header  
[REPLACE]  this  .  escape  =  escape;	[BUGGY]  this  .  escape  =    encapsulator  ;  [FE]  null  [CONTEXT]  CSVFormat  (  char  delimiter  ,  char  encapsulator  ,  char  commentStart  ,  char  escape  ,  boolean  surroundingSpacesIgnored  ,  boolean  emptyLinesIgnored  ,  String  lineSeparator  ,  String[]  header  )  {  this  .  delimiter  =  delimiter  ;  this  .  encapsulator  =  encapsulator  ;  this  .  commentStart  =  commentStart  ;  [ATTENTION]  this  .  escape  =  encapsulator  ;  this  .  surroundingSpacesIgnored  =  surroundingSpacesIgnored  ;  this  .  emptyLinesIgnored  =  emptyLinesIgnored  ;  this  .  lineSeparator  =  lineSeparator  ;  this  .  header  =  header  ;  }    [METHOD]  <init>  [TYPE]  String[])  [PARAMETER]  char  delimiter  char  encapsulator  char  commentStart  char  escape  boolean  surroundingSpacesIgnored  boolean  emptyLinesIgnored  String  lineSeparator  String[]  header  [CLASS]  CSVFormat    [TYPE]  char  DISABLED  commentStart  delimiter  encapsulator  escape  [TYPE]  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  [TYPE]  boolean  emptyLinesIgnored  false  surroundingSpacesIgnored  true  [TYPE]  String  CRLF  lineSeparator  [TYPE]  String[]  header  
[ADD]  this  .  escape  =  escape;  this  .  surroundingSpacesIgnored  =  surroundingSpacesIgnored;	[BUGGY]  this  .  surroundingSpacesIgnored  =  surroundingSpacesIgnored  ;  [CE]  variable  escape  might  not  have  been  initialized  [CONTEXT]  CSVFormat  (  char  delimiter  ,  char  encapsulator  ,  char  commentStart  ,  char  escape  ,  boolean  surroundingSpacesIgnored  ,  boolean  emptyLinesIgnored  ,  String  lineSeparator  ,  String[]  header  )  {  this  .  delimiter  =  delimiter  ;  this  .  encapsulator  =  encapsulator  ;  this  .  commentStart  =  commentStart  ;  [ATTENTION]  this  .  surroundingSpacesIgnored  =  surroundingSpacesIgnored  ;    this  .  emptyLinesIgnored  =  emptyLinesIgnored  ;  this  .  lineSeparator  =  lineSeparator  ;  this  .  header  =  header  ;  }    [METHOD]  <init>  [TYPE]  String[])  [PARAMETER]  char  delimiter  char  encapsulator  char  commentStart  char  escape  boolean  surroundingSpacesIgnored  boolean  emptyLinesIgnored  String  lineSeparator  String[]  header  [CLASS]  CSVFormat    [TYPE]  char  DISABLED  commentStart  delimiter  encapsulator  escape  [TYPE]  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  [TYPE]  boolean  emptyLinesIgnored  false  surroundingSpacesIgnored  true  [TYPE]  String  CRLF  lineSeparator  [TYPE]  String[]  header  
[REPLACE]  this  .  surroundingSpacesIgnored  =  surroundingSpacesIgnored;	[BUGGY]  this  .  surroundingSpacesIgnored  =    true  ;  [FE]  null  assertEquals('?'  ,  format.withDelimiter('?').getDelimiter())  ;  assertEquals('?'  ,  format.withEncapsulator('?').getEncapsulator())  ;  assertEquals('?'  ,  format.withCommentStart('?').getCommentStart())  ;  assertEquals( "? "  ,  format.withLineSeparator( "? ").getLineSeparator())  ;  assertEquals('?'  ,  format.withEscape('?').getEscape())  ;  assertFalse(format.withSurroundingSpacesIgnored(false).isSurroundingSpacesIgnored())  ;  assertFalse(format.withEmptyLinesIgnored(false).isEmptyLinesIgnored())  ;  [CONTEXT]  CSVFormat  (  char  delimiter  ,  char  encapsulator  ,  char  commentStart  ,  char  escape  ,  boolean  surroundingSpacesIgnored  ,  boolean  emptyLinesIgnored  ,  String  lineSeparator  ,  String[]  header  )  {  this  .  delimiter  =  delimiter  ;  this  .  encapsulator  =  encapsulator  ;  this  .  commentStart  =  commentStart  ;  this  .  escape  =  escape  ;  [ATTENTION]  this  .  surroundingSpacesIgnored  =  true  ;  this  .  emptyLinesIgnored  =  emptyLinesIgnored  ;  this  .  lineSeparator  =  lineSeparator  ;  this  .  header  =  header  ;  }    [METHOD]  <init>  [TYPE]  String[])  [PARAMETER]  char  delimiter  char  encapsulator  char  commentStart  char  escape  boolean  surroundingSpacesIgnored  boolean  emptyLinesIgnored  String  lineSeparator  String[]  header  [CLASS]  CSVFormat    [TYPE]  char  DISABLED  commentStart  delimiter  encapsulator  escape  [TYPE]  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  [TYPE]  boolean  emptyLinesIgnored  false  surroundingSpacesIgnored  true  [TYPE]  String  CRLF  lineSeparator  [TYPE]  String[]  header  
[REPLACE]  this  .  emptyLinesIgnored  =  emptyLinesIgnored;	[BUGGY]  this  .  emptyLinesIgnored  =    true  ;  [FE]  null  assertEquals('?'  ,  format.withDelimiter('?').getDelimiter())  ;  assertEquals('?'  ,  format.withEncapsulator('?').getEncapsulator())  ;  assertEquals('?'  ,  format.withCommentStart('?').getCommentStart())  ;  assertEquals( "? "  ,  format.withLineSeparator( "? ").getLineSeparator())  ;  assertEquals('?'  ,  format.withEscape('?').getEscape())  ;  assertFalse(format.withSurroundingSpacesIgnored(false).isSurroundingSpacesIgnored())  ;  assertFalse(format.withEmptyLinesIgnored(false).isEmptyLinesIgnored())  ;  [CONTEXT]  CSVFormat  (  char  delimiter  ,  char  encapsulator  ,  char  commentStart  ,  char  escape  ,  boolean  surroundingSpacesIgnored  ,  boolean  emptyLinesIgnored  ,  String  lineSeparator  ,  String[]  header  )  {  this  .  delimiter  =  delimiter  ;  this  .  encapsulator  =  encapsulator  ;  this  .  commentStart  =  commentStart  ;  this  .  escape  =  escape  ;  this  .  surroundingSpacesIgnored  =  surroundingSpacesIgnored  ;  [ATTENTION]  this  .  emptyLinesIgnored  =  true  ;  this  .  lineSeparator  =  lineSeparator  ;  this  .  header  =  header  ;  }    [METHOD]  <init>  [TYPE]  String[])  [PARAMETER]  char  delimiter  char  encapsulator  char  commentStart  char  escape  boolean  surroundingSpacesIgnored  boolean  emptyLinesIgnored  String  lineSeparator  String[]  header  [CLASS]  CSVFormat    [TYPE]  char  DISABLED  commentStart  delimiter  encapsulator  escape  [TYPE]  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  [TYPE]  boolean  emptyLinesIgnored  false  surroundingSpacesIgnored  true  [TYPE]  String  CRLF  lineSeparator  [TYPE]  String[]  header  
[REPLACE]  this  .  lineSeparator  =  lineSeparator;	[BUGGY]  this  .  lineSeparator  =    CRLF  ;  [FE]  AssertionFailedError    expected:<[?]>  but  was:<[  assertEquals('?'  ,  format.withDelimiter('?').getDelimiter())  ;  assertEquals('?'  ,  format.withEncapsulator('?').getEncapsulator())  ;  assertEquals('?'  ,  format.withCommentStart('?').getCommentStart())  ;  assertEquals( "? "  ,  format.withLineSeparator( "? ").getLineSeparator())  ;  assertEquals('?'  ,  format.withEscape('?').getEscape())  ;  assertFalse(format.withSurroundingSpacesIgnored(false).isSurroundingSpacesIgnored())  ;  assertFalse(format.withEmptyLinesIgnored(false).isEmptyLinesIgnored())  ;  [CONTEXT]  CSVFormat  (  char  delimiter  ,  char  encapsulator  ,  char  commentStart  ,  char  escape  ,  boolean  surroundingSpacesIgnored  ,  boolean  emptyLinesIgnored  ,  String  lineSeparator  ,  String[]  header  )  {  this  .  delimiter  =  delimiter  ;  this  .  encapsulator  =  encapsulator  ;  this  .  commentStart  =  commentStart  ;  this  .  escape  =  escape  ;  this  .  surroundingSpacesIgnored  =  surroundingSpacesIgnored  ;  this  .  emptyLinesIgnored  =  emptyLinesIgnored  ;  [ATTENTION]  this  .  lineSeparator  =  CRLF  ;  this  .  header  =  header  ;  }    [METHOD]  <init>  [TYPE]  String[])  [PARAMETER]  char  delimiter  char  encapsulator  char  commentStart  char  escape  boolean  surroundingSpacesIgnored  boolean  emptyLinesIgnored  String  lineSeparator  String[]  header  [CLASS]  CSVFormat    [TYPE]  char  DISABLED  commentStart  delimiter  encapsulator  escape  [TYPE]  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  [TYPE]  boolean  emptyLinesIgnored  false  surroundingSpacesIgnored  true  [TYPE]  String  CRLF  lineSeparator  [TYPE]  String[]  header  
[REPLACE]  this  .  header  =  header;	[BUGGY]  this  .  header  =    null  ;  [FE]  No  header  was  specified  ,  the  record  values  can't  be  accessed  by  name  assertTrue(records.hasNext())  ;  assertEquals(record.get(0)  ,  record.get( "A "))  ;  assertEquals(record.get(1)  ,  record.get( "B "))  ;  assertEquals(record.get(2)  ,  record.get( "C "))  ;  assertFalse(records.hasNext())  ;  [CONTEXT]  CSVFormat  (  char  delimiter  ,  char  encapsulator  ,  char  commentStart  ,  char  escape  ,  boolean  surroundingSpacesIgnored  ,  boolean  emptyLinesIgnored  ,  String  lineSeparator  ,  String[]  header  )  {  this  .  delimiter  =  delimiter  ;  this  .  encapsulator  =  encapsulator  ;  this  .  commentStart  =  commentStart  ;  this  .  escape  =  escape  ;  this  .  surroundingSpacesIgnored  =  surroundingSpacesIgnored  ;  this  .  emptyLinesIgnored  =  emptyLinesIgnored  ;  this  .  lineSeparator  =  lineSeparator  ;  [ATTENTION]  this  .  header  =  null  ;  }    [METHOD]  <init>  [TYPE]  String[])  [PARAMETER]  char  delimiter  char  encapsulator  char  commentStart  char  escape  boolean  surroundingSpacesIgnored  boolean  emptyLinesIgnored  String  lineSeparator  String[]  header  [CLASS]  CSVFormat    [TYPE]  char  DISABLED  commentStart  delimiter  encapsulator  escape  [TYPE]  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  [TYPE]  boolean  emptyLinesIgnored  false  surroundingSpacesIgnored  true  [TYPE]  String  CRLF  lineSeparator  [TYPE]  String[]  header  
[REPLACE]  return  c  ==  '\n'  ||  c  ==  '\r';	[BUGGY]  return  c  ;  [CE]  incompatible  types  [CONTEXT]  private  static  boolean  isLineBreak  (  char  c  )  {  [ATTENTION]  return  c  ;  }    [METHOD]  isLineBreak  [TYPE]  boolean  [PARAMETER]  char  c  [CLASS]  CSVFormat    [TYPE]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  [TYPE]  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  [TYPE]  boolean  emptyLinesIgnored  false  surroundingSpacesIgnored  true  [TYPE]  String  CRLF  lineSeparator  [TYPE]  String[]  header  
[REPLACE]  if  (  delimiter  ==  encapsulator  )  {	[BUGGY]  if  (  delimiter  &&  encapsulator  )  {[CE]  bad  operand  types  for  binary  operator  '&&'  [CONTEXT]  void  validate  (  )  throws  IllegalArgumentException  {  [ATTENTION]  if  (  delimiter&&encapsulator  )  {  throw  new  IllegalArgumentException  (   "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (  \ " "  +  encapsulator  +   "\ "  )   "  )  ;  }  if  (  delimiter  =  =  escape  )  {  throw  new  IllegalArgumentException  (   "The  escape  character  and  the  delimiter  cannot  be  the  same  (  \ " "  +  escape  +   "\ "  )   "  )  ;  }  if  (  delimiter  =  =  commentStart  )  {  throw  new  IllegalArgumentException  (   "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (  \ " "  +  commentStart  +   "\ "  )   "  )  ;  }  if  (  encapsulator  !  =  DISABLED  &&  encapsulator  =  =  commentStart  )  {  throw  new  IllegalArgumentException  (   "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (  \ " "  +  commentStart  +   "\ "  )   "  )  ;  }  if  (  escape  !  =  DISABLED  &&  escape  =  =  commentStart  )  {  throw  new  IllegalArgumentException  (   "The  comment  start  and  the  escape  character  cannot  be  the  same  (  \ " "  +  commentStart  +   "\ "  )   "  )  ;  }  }    [METHOD]  validate  [TYPE]  void  [PARAMETER]  [CLASS]  CSVFormat    [TYPE]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  [TYPE]  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  [TYPE]  boolean  emptyLinesIgnored  false  surroundingSpacesIgnored  true  [TYPE]  String  CRLF  lineSeparator  [TYPE]  String[]  header  
[REPLACE]  throw  new  IllegalArgumentException  ( "   ")  ;	[BUGGY]  return  ;  [FE]  null  [CONTEXT]  void  validate  (  )  throws  IllegalArgumentException  {  if  (  delimiter  =  =  encapsulator  )  {  [ATTENTION]  return  ;  }  if  (  delimiter  =  =  escape  )  {  throw  new  IllegalArgumentException  (   "The  escape  character  and  the  delimiter  cannot  be  the  same  (  \ " "  +  escape  +   "\ "  )   "  )  ;  }  if  (  delimiter  =  =  commentStart  )  {  throw  new  IllegalArgumentException  (   "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (  \ " "  +  commentStart  +   "\ "  )   "  )  ;  }  if  (  encapsulator  !  =  DISABLED  &&  encapsulator  =  =  commentStart  )  {  throw  new  IllegalArgumentException  (   "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (  \ " "  +  commentStart  +   "\ "  )   "  )  ;  }  if  (  escape  !  =  DISABLED  &&  escape  =  =  commentStart  )  {  throw  new  IllegalArgumentException  (   "The  comment  start  and  the  escape  character  cannot  be  the  same  (  \ " "  +  commentStart  +   "\ "  )   "  )  ;  }  }    [METHOD]  validate  [TYPE]  void  [PARAMETER]  [CLASS]  CSVFormat    [TYPE]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  [TYPE]  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  [TYPE]  boolean  emptyLinesIgnored  false  surroundingSpacesIgnored  true  [TYPE]  String  CRLF  lineSeparator  [TYPE]  String[]  header  
[ADD]  throw  new  IllegalArgumentException  ( "   ")  ;	[BUGGY]  [FE]  null  [CONTEXT]  void  validate  (  )  throws  IllegalArgumentException  {  if  (  delimiter  =  =  encapsulator  )  {  [ATTENTION]  }  if  (  delimiter  =  =  escape  )  {  throw  new  IllegalArgumentException  (   "The  escape  character  and  the  delimiter  cannot  be  the  same  (  \ " "  +  escape  +   "\ "  )   "  )  ;  }  if  (  delimiter  =  =  commentStart  )  {  throw  new  IllegalArgumentException  (   "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (  \ " "  +  commentStart  +   "\ "  )   "  )  ;  }  if  (  encapsulator  !  =  DISABLED  &&  encapsulator  =  =  commentStart  )  {  throw  new  IllegalArgumentException  (   "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (  \ " "  +  commentStart  +   "\ "  )   "  )  ;  }  if  (  escape  !  =  DISABLED  &&  escape  =  =  commentStart  )  {  throw  new  IllegalArgumentException  (   "The  comment  start  and  the  escape  character  cannot  be  the  same  (  \ " "  +  commentStart  +   "\ "  )   "  )  ;  }  }    [METHOD]  validate  [TYPE]  void  [PARAMETER]  [CLASS]  CSVFormat    [TYPE]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  [TYPE]  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  [TYPE]  boolean  emptyLinesIgnored  false  surroundingSpacesIgnored  true  [TYPE]  String  CRLF  lineSeparator  [TYPE]  String[]  header  
[REPLACE]  if  (  delimiter  ==  escape  )  {	[BUGGY]  if  (encapsulator  !  =    escape  )  {[FE]  The  escape  character  and  the  delimiter  cannot  be  the  same  ( "  [CONTEXT]  void  validate  (  )  throws  IllegalArgumentException  {  if  (  delimiter  =  =  encapsulator  )  {  throw  new  IllegalArgumentException  (   "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (  \ " "  +  encapsulator  +   "\ "  )   "  )  ;  }  [ATTENTION]  if  (  encapsulator!  =  escape  )  {  throw  new  IllegalArgumentException  (   "The  escape  character  and  the  delimiter  cannot  be  the  same  (  \ " "  +  escape  +   "\ "  )   "  )  ;  }  if  (  delimiter  =  =  commentStart  )  {  throw  new  IllegalArgumentException  (   "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (  \ " "  +  commentStart  +   "\ "  )   "  )  ;  }  if  (  encapsulator  !  =  DISABLED  &&  encapsulator  =  =  commentStart  )  {  throw  new  IllegalArgumentException  (   "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (  \ " "  +  commentStart  +   "\ "  )   "  )  ;  }  if  (  escape  !  =  DISABLED  &&  escape  =  =  commentStart  )  {  throw  new  IllegalArgumentException  (   "The  comment  start  and  the  escape  character  cannot  be  the  same  (  \ " "  +  commentStart  +   "\ "  )   "  )  ;  }  }    [METHOD]  validate  [TYPE]  void  [PARAMETER]  [CLASS]  CSVFormat    [TYPE]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  [TYPE]  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  [TYPE]  boolean  emptyLinesIgnored  false  surroundingSpacesIgnored  true  [TYPE]  String  CRLF  lineSeparator  [TYPE]  String[]  header  
[REPLACE]  throw  new  IllegalArgumentException  ( "   ")  ;	[BUGGY]  return  ;  [FE]  null  [CONTEXT]  void  validate  (  )  throws  IllegalArgumentException  {  if  (  delimiter  =  =  encapsulator  )  {  throw  new  IllegalArgumentException  (   "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (  \ " "  +  encapsulator  +   "\ "  )   "  )  ;  }  if  (  delimiter  =  =  escape  )  {  [ATTENTION]  return  ;  }  if  (  delimiter  =  =  commentStart  )  {  throw  new  IllegalArgumentException  (   "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (  \ " "  +  commentStart  +   "\ "  )   "  )  ;  }  if  (  encapsulator  !  =  DISABLED  &&  encapsulator  =  =  commentStart  )  {  throw  new  IllegalArgumentException  (   "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (  \ " "  +  commentStart  +   "\ "  )   "  )  ;  }  if  (  escape  !  =  DISABLED  &&  escape  =  =  commentStart  )  {  throw  new  IllegalArgumentException  (   "The  comment  start  and  the  escape  character  cannot  be  the  same  (  \ " "  +  commentStart  +   "\ "  )   "  )  ;  }  }    [METHOD]  validate  [TYPE]  void  [PARAMETER]  [CLASS]  CSVFormat    [TYPE]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  [TYPE]  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  [TYPE]  boolean  emptyLinesIgnored  false  surroundingSpacesIgnored  true  [TYPE]  String  CRLF  lineSeparator  [TYPE]  String[]  header  
[REPLACE]  if  (  delimiter  ==  commentStart  )  {	[BUGGY]  if  (  delimiter  ||  commentStart  )  {[CE]  bad  operand  types  for  binary  operator  '||'  [CONTEXT]  void  validate  (  )  throws  IllegalArgumentException  {  if  (  delimiter  =  =  encapsulator  )  {  throw  new  IllegalArgumentException  (   "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (  \ " "  +  encapsulator  +   "\ "  )   "  )  ;  }  if  (  delimiter  =  =  escape  )  {  throw  new  IllegalArgumentException  (   "The  escape  character  and  the  delimiter  cannot  be  the  same  (  \ " "  +  escape  +   "\ "  )   "  )  ;  }  [ATTENTION]  if  (  delimiter||commentStart  )  {  throw  new  IllegalArgumentException  (   "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (  \ " "  +  commentStart  +   "\ "  )   "  )  ;  }  if  (  encapsulator  !  =  DISABLED  &&  encapsulator  =  =  commentStart  )  {  throw  new  IllegalArgumentException  (   "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (  \ " "  +  commentStart  +   "\ "  )   "  )  ;  }  if  (  escape  !  =  DISABLED  &&  escape  =  =  commentStart  )  {  throw  new  IllegalArgumentException  (   "The  comment  start  and  the  escape  character  cannot  be  the  same  (  \ " "  +  commentStart  +   "\ "  )   "  )  ;  }  }    [METHOD]  validate  [TYPE]  void  [PARAMETER]  [CLASS]  CSVFormat    [TYPE]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  [TYPE]  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  [TYPE]  boolean  emptyLinesIgnored  false  surroundingSpacesIgnored  true  [TYPE]  String  CRLF  lineSeparator  [TYPE]  String[]  header  
[REPLACE]  throw  new  IllegalArgumentException  ( "   ")  ;	[BUGGY]  return  ;  [FE]  null  [CONTEXT]  void  validate  (  )  throws  IllegalArgumentException  {  if  (  delimiter  =  =  encapsulator  )  {  throw  new  IllegalArgumentException  (   "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (  \ " "  +  encapsulator  +   "\ "  )   "  )  ;  }  if  (  delimiter  =  =  escape  )  {  throw  new  IllegalArgumentException  (   "The  escape  character  and  the  delimiter  cannot  be  the  same  (  \ " "  +  escape  +   "\ "  )   "  )  ;  }  if  (  delimiter  =  =  commentStart  )  {  [ATTENTION]  return  ;  }  if  (  encapsulator  !  =  DISABLED  &&  encapsulator  =  =  commentStart  )  {  throw  new  IllegalArgumentException  (   "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (  \ " "  +  commentStart  +   "\ "  )   "  )  ;  }  if  (  escape  !  =  DISABLED  &&  escape  =  =  commentStart  )  {  throw  new  IllegalArgumentException  (   "The  comment  start  and  the  escape  character  cannot  be  the  same  (  \ " "  +  commentStart  +   "\ "  )   "  )  ;  }  }    [METHOD]  validate  [TYPE]  void  [PARAMETER]  [CLASS]  CSVFormat    [TYPE]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  [TYPE]  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  [TYPE]  boolean  emptyLinesIgnored  false  surroundingSpacesIgnored  true  [TYPE]  String  CRLF  lineSeparator  [TYPE]  String[]  header  
[REPLACE]  if  (  encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart  )  {	[BUGGY]  if  (  encapsulator  !  =  DISABLED  ||  encapsulator  =  =  commentStart  )  {[FE]  The  comment  start  character  and  the  encapsulator  cannot  be  the  same  ( "  [CONTEXT]  void  validate  (  )  throws  IllegalArgumentException  {  if  (  delimiter  =  =  encapsulator  )  {  throw  new  IllegalArgumentException  (   "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (  \ " "  +  encapsulator  +   "\ "  )   "  )  ;  }  if  (  delimiter  =  =  escape  )  {  throw  new  IllegalArgumentException  (   "The  escape  character  and  the  delimiter  cannot  be  the  same  (  \ " "  +  escape  +   "\ "  )   "  )  ;  }  if  (  delimiter  =  =  commentStart  )  {  throw  new  IllegalArgumentException  (   "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (  \ " "  +  commentStart  +   "\ "  )   "  )  ;  }  [ATTENTION]  if  (  encapsulator  !  =  DISABLED  ||  encapsulator  =  =  commentStart  )  {  throw  new  IllegalArgumentException  (   "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (  \ " "  +  commentStart  +   "\ "  )   "  )  ;  }  if  (  escape  !  =  DISABLED  &&  escape  =  =  commentStart  )  {  throw  new  IllegalArgumentException  (   "The  comment  start  and  the  escape  character  cannot  be  the  same  (  \ " "  +  commentStart  +   "\ "  )   "  )  ;  }  }    [METHOD]  validate  [TYPE]  void  [PARAMETER]  [CLASS]  CSVFormat    [TYPE]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  [TYPE]  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  [TYPE]  boolean  emptyLinesIgnored  false  surroundingSpacesIgnored  true  [TYPE]  String  CRLF  lineSeparator  [TYPE]  String[]  header  
[REPLACE]  throw  new  IllegalArgumentException  ( "   ")  ;	[BUGGY]  return  ;  [FE]  null  [CONTEXT]  void  validate  (  )  throws  IllegalArgumentException  {  if  (  delimiter  =  =  encapsulator  )  {  throw  new  IllegalArgumentException  (   "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (  \ " "  +  encapsulator  +   "\ "  )   "  )  ;  }  if  (  delimiter  =  =  escape  )  {  throw  new  IllegalArgumentException  (   "The  escape  character  and  the  delimiter  cannot  be  the  same  (  \ " "  +  escape  +   "\ "  )   "  )  ;  }  if  (  delimiter  =  =  commentStart  )  {  throw  new  IllegalArgumentException  (   "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (  \ " "  +  commentStart  +   "\ "  )   "  )  ;  }  if  (  encapsulator  !  =  DISABLED  &&  encapsulator  =  =  commentStart  )  {  [ATTENTION]  return  ;  }  if  (  escape  !  =  DISABLED  &&  escape  =  =  commentStart  )  {  throw  new  IllegalArgumentException  (   "The  comment  start  and  the  escape  character  cannot  be  the  same  (  \ " "  +  commentStart  +   "\ "  )   "  )  ;  }  }    [METHOD]  validate  [TYPE]  void  [PARAMETER]  [CLASS]  CSVFormat    [TYPE]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  [TYPE]  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  [TYPE]  boolean  emptyLinesIgnored  false  surroundingSpacesIgnored  true  [TYPE]  String  CRLF  lineSeparator  [TYPE]  String[]  header  
[REPLACE]  if  (  escape  !=  DISABLED  &&  escape  ==  commentStart  )  {	[BUGGY]  if  (  true  )  {[FE]  The  comment  start  and  the  escape  character  cannot  be  the  same  ( "  [CONTEXT]  void  validate  (  )  throws  IllegalArgumentException  {  if  (  delimiter  =  =  encapsulator  )  {  throw  new  IllegalArgumentException  (   "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (  \ " "  +  encapsulator  +   "\ "  )   "  )  ;  }  if  (  delimiter  =  =  escape  )  {  throw  new  IllegalArgumentException  (   "The  escape  character  and  the  delimiter  cannot  be  the  same  (  \ " "  +  escape  +   "\ "  )   "  )  ;  }  if  (  delimiter  =  =  commentStart  )  {  throw  new  IllegalArgumentException  (   "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (  \ " "  +  commentStart  +   "\ "  )   "  )  ;  }  if  (  encapsulator  !  =  DISABLED  &&  encapsulator  =  =  commentStart  )  {  throw  new  IllegalArgumentException  (   "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (  \ " "  +  commentStart  +   "\ "  )   "  )  ;  }  [ATTENTION]  if  (  true  )  {  throw  new  IllegalArgumentException  (   "The  comment  start  and  the  escape  character  cannot  be  the  same  (  \ " "  +  commentStart  +   "\ "  )   "  )  ;  }  }    [METHOD]  validate  [TYPE]  void  [PARAMETER]  [CLASS]  CSVFormat    [TYPE]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  [TYPE]  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  [TYPE]  boolean  emptyLinesIgnored  false  surroundingSpacesIgnored  true  [TYPE]  String  CRLF  lineSeparator  [TYPE]  String[]  header  
[ADD]  if  (  escape  !=  DISABLED  &&  escape  ==  commentStart  )  {  throw  new  IllegalArgumentException  ( "   ")  ;  }	[BUGGY]  [FE]  null  [CONTEXT]  void  validate  (  )  throws  IllegalArgumentException  {  if  (  delimiter  =  =  encapsulator  )  {  throw  new  IllegalArgumentException  (   "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (  \ " "  +  encapsulator  +   "\ "  )   "  )  ;  }  if  (  delimiter  =  =  escape  )  {  throw  new  IllegalArgumentException  (   "The  escape  character  and  the  delimiter  cannot  be  the  same  (  \ " "  +  escape  +   "\ "  )   "  )  ;  }  if  (  delimiter  =  =  commentStart  )  {  throw  new  IllegalArgumentException  (   "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (  \ " "  +  commentStart  +   "\ "  )   "  )  ;  }  if  (  encapsulator  !  =  DISABLED  &&  encapsulator  =  =  commentStart  )  {  throw  new  IllegalArgumentException  (   "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (  \ " "  +  commentStart  +   "\ "  )   "  )  ;  }  [ATTENTION]    }    [METHOD]  validate  [TYPE]  void  [PARAMETER]  [CLASS]  CSVFormat    [TYPE]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  [TYPE]  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  [TYPE]  boolean  emptyLinesIgnored  false  surroundingSpacesIgnored  true  [TYPE]  String  CRLF  lineSeparator  [TYPE]  String[]  header  
[REPLACE]  throw  new  IllegalArgumentException  ( "   ")  ;	[BUGGY]  return  ;  [FE]  null  [CONTEXT]  void  validate  (  )  throws  IllegalArgumentException  {  if  (  delimiter  =  =  encapsulator  )  {  throw  new  IllegalArgumentException  (   "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (  \ " "  +  encapsulator  +   "\ "  )   "  )  ;  }  if  (  delimiter  =  =  escape  )  {  throw  new  IllegalArgumentException  (   "The  escape  character  and  the  delimiter  cannot  be  the  same  (  \ " "  +  escape  +   "\ "  )   "  )  ;  }  if  (  delimiter  =  =  commentStart  )  {  throw  new  IllegalArgumentException  (   "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (  \ " "  +  commentStart  +   "\ "  )   "  )  ;  }  if  (  encapsulator  !  =  DISABLED  &&  encapsulator  =  =  commentStart  )  {  throw  new  IllegalArgumentException  (   "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (  \ " "  +  commentStart  +   "\ "  )   "  )  ;  }  if  (  escape  !  =  DISABLED  &&  escape  =  =  commentStart  )  {  [ATTENTION]  return  ;  }  }    [METHOD]  validate  [TYPE]  void  [PARAMETER]  [CLASS]  CSVFormat    [TYPE]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  [TYPE]  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  [TYPE]  boolean  emptyLinesIgnored  false  surroundingSpacesIgnored  true  [TYPE]  String  CRLF  lineSeparator  [TYPE]  String[]  header  
[REPLACE]  return  delimiter;	[BUGGY]  return  lineSeparator  ;  [CE]  incompatible  types  [CONTEXT]  public  char  getDelimiter  (  )  {  [ATTENTION]  return  lineSeparator  ;  }    [METHOD]  getDelimiter  [TYPE]  char  [PARAMETER]  [CLASS]  CSVFormat    [TYPE]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  [TYPE]  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  [TYPE]  boolean  emptyLinesIgnored  false  surroundingSpacesIgnored  true  [TYPE]  String  CRLF  lineSeparator  [TYPE]  String[]  header  
[REPLACE]  if  (  isLineBreak  (  delimiter  )  )  {	[BUGGY]  if  (  isLineBreak  (  escape  )  )  {[FE]  null  [CONTEXT]  public  CSVFormat  withDelimiter  (  char  delimiter  )  {  [ATTENTION]  if  (  isLineBreak  (  escape  )  )  {  throw  new  IllegalArgumentException  (   "The  delimiter  cannot  be  a  line  break "  )  ;  }  return  new  CSVFormat  (  delimiter  ,  encapsulator  ,  commentStart  ,  escape  ,  surroundingSpacesIgnored  ,  emptyLinesIgnored  ,  lineSeparator  ,  header  )  ;  }    [METHOD]  withDelimiter  [TYPE]  CSVFormat  [PARAMETER]  char  delimiter  [CLASS]  CSVFormat    [TYPE]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  [TYPE]  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  [TYPE]  boolean  emptyLinesIgnored  false  surroundingSpacesIgnored  true  [TYPE]  String  CRLF  lineSeparator  [TYPE]  String[]  header  
[ADD]  if  (  isLineBreak  (  delimiter  )  )  {  throw  new  IllegalArgumentException  ( "   ")  ;  }	[BUGGY]  [FE]  null  [CONTEXT]  public  CSVFormat  withDelimiter  (  char  delimiter  )  {  [ATTENTION]      return  new  CSVFormat  (  delimiter  ,  encapsulator  ,  commentStart  ,  escape  ,  surroundingSpacesIgnored  ,  emptyLinesIgnored  ,  lineSeparator  ,  header  )  ;  }    [METHOD]  withDelimiter  [TYPE]  CSVFormat  [PARAMETER]  char  delimiter  [CLASS]  CSVFormat    [TYPE]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  [TYPE]  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  [TYPE]  boolean  emptyLinesIgnored  false  surroundingSpacesIgnored  true  [TYPE]  String  CRLF  lineSeparator  [TYPE]  String[]  header  
[REPLACE]  throw  new  IllegalArgumentException  ( "   ")  ;	[BUGGY]  return  ;  [CE]  missing  return  value  [CONTEXT]  public  CSVFormat  withDelimiter  (  char  delimiter  )  {  if  (  isLineBreak  (  delimiter  )  )  {  [ATTENTION]  return  ;  }  return  new  CSVFormat  (  delimiter  ,  encapsulator  ,  commentStart  ,  escape  ,  surroundingSpacesIgnored  ,  emptyLinesIgnored  ,  lineSeparator  ,  header  )  ;  }    [METHOD]  withDelimiter  [TYPE]  CSVFormat  [PARAMETER]  char  delimiter  [CLASS]  CSVFormat    [TYPE]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  [TYPE]  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  [TYPE]  boolean  emptyLinesIgnored  false  surroundingSpacesIgnored  true  [TYPE]  String  CRLF  lineSeparator  [TYPE]  String[]  header  
[REPLACE]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat  (  escape  ,  encapsulator  ,  commentStart  ,  escape  ,  surroundingSpacesIgnored  ,  emptyLinesIgnored  ,  lineSeparator  ,  header  )  ;  [FE]  The  encapsulator  character  and  the  delimiter  cannot  be  the  same  ( "  [CONTEXT]  public  CSVFormat  withDelimiter  (  char  delimiter  )  {  if  (  isLineBreak  (  delimiter  )  )  {  throw  new  IllegalArgumentException  (   "The  delimiter  cannot  be  a  line  break "  )  ;  }  [ATTENTION]  return  new  CSVFormat  (  escape  ,  encapsulator  ,  commentStart  ,  escape  ,  surroundingSpacesIgnored  ,  emptyLinesIgnored  ,  lineSeparator  ,  header  )    ;  }    [METHOD]  withDelimiter  [TYPE]  CSVFormat  [PARAMETER]  char  delimiter  [CLASS]  CSVFormat    [TYPE]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  [TYPE]  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  [TYPE]  boolean  emptyLinesIgnored  false  surroundingSpacesIgnored  true  [TYPE]  String  CRLF  lineSeparator  [TYPE]  String[]  header  
[REPLACE]  return  encapsulator;	[BUGGY]  return  lineSeparator  ;  [CE]  incompatible  types  [CONTEXT]  public  char  getEncapsulator  (  )  {  [ATTENTION]  return  lineSeparator  ;  }    [METHOD]  getEncapsulator  [TYPE]  char  [PARAMETER]  [CLASS]  CSVFormat    [TYPE]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  [TYPE]  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  [TYPE]  boolean  emptyLinesIgnored  false  surroundingSpacesIgnored  true  [TYPE]  String  CRLF  lineSeparator  [TYPE]  String[]  header  
[REPLACE]  if  (  isLineBreak  (  encapsulator  )  )  {	[BUGGY]  if  (  isLineBreak  (  escape  )  )  {[FE]  null  [CONTEXT]  public  CSVFormat  withEncapsulator  (  char  encapsulator  )  {  [ATTENTION]  if  (  isLineBreak  (  escape  )  )  {  throw  new  IllegalArgumentException  (   "The  encapsulator  cannot  be  a  line  break "  )  ;  }  return  new  CSVFormat  (  delimiter  ,  encapsulator  ,  commentStart  ,  escape  ,  surroundingSpacesIgnored  ,  emptyLinesIgnored  ,  lineSeparator  ,  header  )  ;  }    [METHOD]  withEncapsulator  [TYPE]  CSVFormat  [PARAMETER]  char  encapsulator  [CLASS]  CSVFormat    [TYPE]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  [TYPE]  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  [TYPE]  boolean  emptyLinesIgnored  false  surroundingSpacesIgnored  true  [TYPE]  String  CRLF  lineSeparator  [TYPE]  String[]  header  
[REPLACE]  throw  new  IllegalArgumentException  ( "   ")  ;	[BUGGY]  return  ;  [CE]  missing  return  value  [CONTEXT]  public  CSVFormat  withEncapsulator  (  char  encapsulator  )  {  if  (  isLineBreak  (  encapsulator  )  )  {  [ATTENTION]  return  ;  }  return  new  CSVFormat  (  delimiter  ,  encapsulator  ,  commentStart  ,  escape  ,  surroundingSpacesIgnored  ,  emptyLinesIgnored  ,  lineSeparator  ,  header  )  ;  }    [METHOD]  withEncapsulator  [TYPE]  CSVFormat  [PARAMETER]  char  encapsulator  [CLASS]  CSVFormat    [TYPE]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  [TYPE]  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  [TYPE]  boolean  emptyLinesIgnored  false  surroundingSpacesIgnored  true  [TYPE]  String  CRLF  lineSeparator  [TYPE]  String[]  header  
[ADD]  throw  new  IllegalArgumentException  ( "   ")  ;	[BUGGY]  [FE]  null  [CONTEXT]  public  CSVFormat  withEncapsulator  (  char  encapsulator  )  {  if  (  isLineBreak  (  encapsulator  )  )  {  [ATTENTION]  }  return  new  CSVFormat  (  delimiter  ,  encapsulator  ,  commentStart  ,  escape  ,  surroundingSpacesIgnored  ,  emptyLinesIgnored  ,  lineSeparator  ,  header  )  ;  }    [METHOD]  withEncapsulator  [TYPE]  CSVFormat  [PARAMETER]  char  encapsulator  [CLASS]  CSVFormat    [TYPE]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  [TYPE]  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  [TYPE]  boolean  emptyLinesIgnored  false  surroundingSpacesIgnored  true  [TYPE]  String  CRLF  lineSeparator  [TYPE]  String[]  header  
[REPLACE]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat  (  delimiter  ,  escape  ,  commentStart  ,  escape  ,  surroundingSpacesIgnored  ,  emptyLinesIgnored  ,  lineSeparator  ,  header  )  ;  [FE]  null  [CONTEXT]  public  CSVFormat  withEncapsulator  (  char  encapsulator  )  {  if  (  isLineBreak  (  encapsulator  )  )  {  throw  new  IllegalArgumentException  (   "The  encapsulator  cannot  be  a  line  break "  )  ;  }  [ATTENTION]  return  new  CSVFormat  (  delimiter  ,  escape  ,  commentStart  ,  escape  ,  surroundingSpacesIgnored  ,  emptyLinesIgnored  ,  lineSeparator  ,  header  )    ;  }    [METHOD]  withEncapsulator  [TYPE]  CSVFormat  [PARAMETER]  char  encapsulator  [CLASS]  CSVFormat    [TYPE]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  [TYPE]  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  [TYPE]  boolean  emptyLinesIgnored  false  surroundingSpacesIgnored  true  [TYPE]  String  CRLF  lineSeparator  [TYPE]  String[]  header  
[REPLACE]  return  this  .  encapsulator  !=  DISABLED;	[BUGGY]  return  this  .  encapsulator    ;  [CE]  incompatible  types  [CONTEXT]  boolean  isEncapsulating  (  )  {  [ATTENTION]  return  this  .  encapsulator  ;  }    [METHOD]  isEncapsulating  [TYPE]  boolean  [PARAMETER]  [CLASS]  CSVFormat    [TYPE]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  [TYPE]  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  [TYPE]  boolean  emptyLinesIgnored  false  surroundingSpacesIgnored  true  [TYPE]  String  CRLF  lineSeparator  [TYPE]  String[]  header  
[REPLACE]  return  commentStart;	[BUGGY]  return  lineSeparator  ;  [CE]  incompatible  types  [CONTEXT]  public  char  getCommentStart  (  )  {  [ATTENTION]  return  lineSeparator  ;  }    [METHOD]  getCommentStart  [TYPE]  char  [PARAMETER]  [CLASS]  CSVFormat    [TYPE]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  [TYPE]  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  [TYPE]  boolean  emptyLinesIgnored  false  surroundingSpacesIgnored  true  [TYPE]  String  CRLF  lineSeparator  [TYPE]  String[]  header  
[REPLACE]  if  (  isLineBreak  (  commentStart  )  )  {	[BUGGY]  if  (  isLineBreak  (  escape  )  )  {[FE]  null  [CONTEXT]  public  CSVFormat  withCommentStart  (  char  commentStart  )  {  [ATTENTION]  if  (  isLineBreak  (  escape  )  )  {  throw  new  IllegalArgumentException  (   "The  comment  start  character  cannot  be  a  line  break "  )  ;  }  return  new  CSVFormat  (  delimiter  ,  encapsulator  ,  commentStart  ,  escape  ,  surroundingSpacesIgnored  ,  emptyLinesIgnored  ,  lineSeparator  ,  header  )  ;  }    [METHOD]  withCommentStart  [TYPE]  CSVFormat  [PARAMETER]  char  commentStart  [CLASS]  CSVFormat    [TYPE]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  [TYPE]  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  [TYPE]  boolean  emptyLinesIgnored  false  surroundingSpacesIgnored  true  [TYPE]  String  CRLF  lineSeparator  [TYPE]  String[]  header  
[ADD]  if  (  isLineBreak  (  commentStart  )  )  {  throw  new  IllegalArgumentException  ( "   ")  ;  }	[BUGGY]  [FE]  null  [CONTEXT]  public  CSVFormat  withCommentStart  (  char  commentStart  )  {  [ATTENTION]      return  new  CSVFormat  (  delimiter  ,  encapsulator  ,  commentStart  ,  escape  ,  surroundingSpacesIgnored  ,  emptyLinesIgnored  ,  lineSeparator  ,  header  )  ;  }    [METHOD]  withCommentStart  [TYPE]  CSVFormat  [PARAMETER]  char  commentStart  [CLASS]  CSVFormat    [TYPE]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  [TYPE]  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  [TYPE]  boolean  emptyLinesIgnored  false  surroundingSpacesIgnored  true  [TYPE]  String  CRLF  lineSeparator  [TYPE]  String[]  header  
[REPLACE]  throw  new  IllegalArgumentException  ( "   ")  ;	[BUGGY]  return  ;  [CE]  missing  return  value  [CONTEXT]  public  CSVFormat  withCommentStart  (  char  commentStart  )  {  if  (  isLineBreak  (  commentStart  )  )  {  [ATTENTION]  return  ;  }  return  new  CSVFormat  (  delimiter  ,  encapsulator  ,  commentStart  ,  escape  ,  surroundingSpacesIgnored  ,  emptyLinesIgnored  ,  lineSeparator  ,  header  )  ;  }    [METHOD]  withCommentStart  [TYPE]  CSVFormat  [PARAMETER]  char  commentStart  [CLASS]  CSVFormat    [TYPE]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  [TYPE]  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  [TYPE]  boolean  emptyLinesIgnored  false  surroundingSpacesIgnored  true  [TYPE]  String  CRLF  lineSeparator  [TYPE]  String[]  header  
[ADD]  throw  new  IllegalArgumentException  ( "   ")  ;	[BUGGY]  [FE]  null  [CONTEXT]  public  CSVFormat  withCommentStart  (  char  commentStart  )  {  if  (  isLineBreak  (  commentStart  )  )  {  [ATTENTION]  }  return  new  CSVFormat  (  delimiter  ,  encapsulator  ,  commentStart  ,  escape  ,  surroundingSpacesIgnored  ,  emptyLinesIgnored  ,  lineSeparator  ,  header  )  ;  }    [METHOD]  withCommentStart  [TYPE]  CSVFormat  [PARAMETER]  char  commentStart  [CLASS]  CSVFormat    [TYPE]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  [TYPE]  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  [TYPE]  boolean  emptyLinesIgnored  false  surroundingSpacesIgnored  true  [TYPE]  String  CRLF  lineSeparator  [TYPE]  String[]  header  
[REPLACE]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat  (  delimiter  ,  encapsulator  ,  escape  ,  escape  ,  surroundingSpacesIgnored  ,  emptyLinesIgnored  ,  lineSeparator  ,  header  )  ;  [FE]  null  [CONTEXT]  public  CSVFormat  withCommentStart  (  char  commentStart  )  {  if  (  isLineBreak  (  commentStart  )  )  {  throw  new  IllegalArgumentException  (   "The  comment  start  character  cannot  be  a  line  break "  )  ;  }  [ATTENTION]  return  new  CSVFormat  (  delimiter  ,  encapsulator  ,  escape  ,  escape  ,  surroundingSpacesIgnored  ,  emptyLinesIgnored  ,  lineSeparator  ,  header  )    ;  }    [METHOD]  withCommentStart  [TYPE]  CSVFormat  [PARAMETER]  char  commentStart  [CLASS]  CSVFormat    [TYPE]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  [TYPE]  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  [TYPE]  boolean  emptyLinesIgnored  false  surroundingSpacesIgnored  true  [TYPE]  String  CRLF  lineSeparator  [TYPE]  String[]  header  
[REPLACE]  return  this  .  commentStart  !=  DISABLED;	[BUGGY]  return  this  .  commentStart    ;  [CE]  incompatible  types  [CONTEXT]  public  boolean  isCommentingEnabled  (  )  {  [ATTENTION]  return  this  .  commentStart  ;  }    [METHOD]  isCommentingEnabled  [TYPE]  boolean  [PARAMETER]  [CLASS]  CSVFormat    [TYPE]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  [TYPE]  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  [TYPE]  boolean  emptyLinesIgnored  false  surroundingSpacesIgnored  true  [TYPE]  String  CRLF  lineSeparator  [TYPE]  String[]  header  
[REPLACE]  return  escape;	[BUGGY]  return  lineSeparator  ;  [CE]  incompatible  types  [CONTEXT]  public  char  getEscape  (  )  {  [ATTENTION]  return  lineSeparator  ;  }    [METHOD]  getEscape  [TYPE]  char  [PARAMETER]  [CLASS]  CSVFormat    [TYPE]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  [TYPE]  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  [TYPE]  boolean  emptyLinesIgnored  false  surroundingSpacesIgnored  true  [TYPE]  String  CRLF  lineSeparator  [TYPE]  String[]  header  
[REPLACE]  if  (  isLineBreak  (  escape  )  )  {	[BUGGY]  if  (  isLineBreak  (  encapsulator  )  )  {[FE]  null  [CONTEXT]  public  CSVFormat  withEscape  (  char  escape  )  {  [ATTENTION]  if  (  isLineBreak  (  encapsulator  )  )  {  throw  new  IllegalArgumentException  (   "The  escape  character  cannot  be  a  line  break "  )  ;  }  return  new  CSVFormat  (  delimiter  ,  encapsulator  ,  commentStart  ,  escape  ,  surroundingSpacesIgnored  ,  emptyLinesIgnored  ,  lineSeparator  ,  header  )  ;  }    [METHOD]  withEscape  [TYPE]  CSVFormat  [PARAMETER]  char  escape  [CLASS]  CSVFormat    [TYPE]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  [TYPE]  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  [TYPE]  boolean  emptyLinesIgnored  false  surroundingSpacesIgnored  true  [TYPE]  String  CRLF  lineSeparator  [TYPE]  String[]  header  
[ADD]  if  (  isLineBreak  (  escape  )  )  {  throw  new  IllegalArgumentException  ( "   ")  ;  }	[BUGGY]  [FE]  null  [CONTEXT]  public  CSVFormat  withEscape  (  char  escape  )  {  [ATTENTION]      return  new  CSVFormat  (  delimiter  ,  encapsulator  ,  commentStart  ,  escape  ,  surroundingSpacesIgnored  ,  emptyLinesIgnored  ,  lineSeparator  ,  header  )  ;  }    [METHOD]  withEscape  [TYPE]  CSVFormat  [PARAMETER]  char  escape  [CLASS]  CSVFormat    [TYPE]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  [TYPE]  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  [TYPE]  boolean  emptyLinesIgnored  false  surroundingSpacesIgnored  true  [TYPE]  String  CRLF  lineSeparator  [TYPE]  String[]  header  
[REPLACE]  throw  new  IllegalArgumentException  ( "   ")  ;	[BUGGY]  return  ;  [CE]  missing  return  value  [CONTEXT]  public  CSVFormat  withEscape  (  char  escape  )  {  if  (  isLineBreak  (  escape  )  )  {  [ATTENTION]  return  ;  }  return  new  CSVFormat  (  delimiter  ,  encapsulator  ,  commentStart  ,  escape  ,  surroundingSpacesIgnored  ,  emptyLinesIgnored  ,  lineSeparator  ,  header  )  ;  }    [METHOD]  withEscape  [TYPE]  CSVFormat  [PARAMETER]  char  escape  [CLASS]  CSVFormat    [TYPE]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  [TYPE]  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  [TYPE]  boolean  emptyLinesIgnored  false  surroundingSpacesIgnored  true  [TYPE]  String  CRLF  lineSeparator  [TYPE]  String[]  header  
[ADD]  throw  new  IllegalArgumentException  ( "   ")  ;	[BUGGY]  [FE]  null  [CONTEXT]  public  CSVFormat  withEscape  (  char  escape  )  {  if  (  isLineBreak  (  escape  )  )  {  [ATTENTION]  }  return  new  CSVFormat  (  delimiter  ,  encapsulator  ,  commentStart  ,  escape  ,  surroundingSpacesIgnored  ,  emptyLinesIgnored  ,  lineSeparator  ,  header  )  ;  }    [METHOD]  withEscape  [TYPE]  CSVFormat  [PARAMETER]  char  escape  [CLASS]  CSVFormat    [TYPE]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  [TYPE]  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  [TYPE]  boolean  emptyLinesIgnored  false  surroundingSpacesIgnored  true  [TYPE]  String  CRLF  lineSeparator  [TYPE]  String[]  header  
[REPLACE]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat  (  delimiter  ,  encapsulator  ,  commentStart  ,  encapsulator  ,  surroundingSpacesIgnored  ,  emptyLinesIgnored  ,  lineSeparator  ,  header  )  ;  [FE]  null  [CONTEXT]  public  CSVFormat  withEscape  (  char  escape  )  {  if  (  isLineBreak  (  escape  )  )  {  throw  new  IllegalArgumentException  (   "The  escape  character  cannot  be  a  line  break "  )  ;  }  [ATTENTION]  return  new  CSVFormat  (  delimiter  ,  encapsulator  ,  commentStart  ,  encapsulator  ,  surroundingSpacesIgnored  ,  emptyLinesIgnored  ,  lineSeparator  ,  header  )    ;  }    [METHOD]  withEscape  [TYPE]  CSVFormat  [PARAMETER]  char  escape  [CLASS]  CSVFormat    [TYPE]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  [TYPE]  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  [TYPE]  boolean  emptyLinesIgnored  false  surroundingSpacesIgnored  true  [TYPE]  String  CRLF  lineSeparator  [TYPE]  String[]  header  
[REPLACE]  return  this  .  escape  !=  DISABLED;	[BUGGY]  return  this  .  escape    ;  [CE]  incompatible  types  [CONTEXT]  boolean  isEscaping  (  )  {  [ATTENTION]  return  this  .  escape  ;  }    [METHOD]  isEscaping  [TYPE]  boolean  [PARAMETER]  [CLASS]  CSVFormat    [TYPE]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  [TYPE]  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  [TYPE]  boolean  emptyLinesIgnored  false  surroundingSpacesIgnored  true  [TYPE]  String  CRLF  lineSeparator  [TYPE]  String[]  header  
[REPLACE]  return  surroundingSpacesIgnored;	[BUGGY]  return  lineSeparator  ;  [CE]  incompatible  types  [CONTEXT]  public  boolean  isSurroundingSpacesIgnored  (  )  {  [ATTENTION]  return  lineSeparator  ;  }    [METHOD]  isSurroundingSpacesIgnored  [TYPE]  boolean  [PARAMETER]  [CLASS]  CSVFormat    [TYPE]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  [TYPE]  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  [TYPE]  boolean  emptyLinesIgnored  false  surroundingSpacesIgnored  true  [TYPE]  String  CRLF  lineSeparator  [TYPE]  String[]  header  
[REPLACE]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat  (  delimiter  ,  encapsulator  ,  commentStart  ,  escape  ,  true  ,  emptyLinesIgnored  ,  lineSeparator  ,  header  )  ;  [FE]  null  assertEquals('?'  ,  format.withDelimiter('?').getDelimiter())  ;  assertEquals('?'  ,  format.withEncapsulator('?').getEncapsulator())  ;  assertEquals('?'  ,  format.withCommentStart('?').getCommentStart())  ;  assertEquals( "? "  ,  format.withLineSeparator( "? ").getLineSeparator())  ;  assertEquals('?'  ,  format.withEscape('?').getEscape())  ;  assertFalse(format.withSurroundingSpacesIgnored(false).isSurroundingSpacesIgnored())  ;  assertFalse(format.withEmptyLinesIgnored(false).isEmptyLinesIgnored())  ;  [CONTEXT]  public  CSVFormat  withSurroundingSpacesIgnored  (  boolean  surroundingSpacesIgnored  )  {  [ATTENTION]  return  new  CSVFormat  (  delimiter  ,  encapsulator  ,  commentStart  ,  escape  ,  true  ,  emptyLinesIgnored  ,  lineSeparator  ,  header  )    ;  }    [METHOD]  withSurroundingSpacesIgnored  [TYPE]  CSVFormat  [PARAMETER]  boolean  surroundingSpacesIgnored  [CLASS]  CSVFormat    [TYPE]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  [TYPE]  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  [TYPE]  boolean  emptyLinesIgnored  false  surroundingSpacesIgnored  true  [TYPE]  String  CRLF  lineSeparator  [TYPE]  String[]  header  
[REPLACE]  return  emptyLinesIgnored;	[BUGGY]  return  lineSeparator  ;  [CE]  incompatible  types  [CONTEXT]  public  boolean  isEmptyLinesIgnored  (  )  {  [ATTENTION]  return  lineSeparator  ;  }    [METHOD]  isEmptyLinesIgnored  [TYPE]  boolean  [PARAMETER]  [CLASS]  CSVFormat    [TYPE]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  [TYPE]  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  [TYPE]  boolean  emptyLinesIgnored  false  surroundingSpacesIgnored  true  [TYPE]  String  CRLF  lineSeparator  [TYPE]  String[]  header  
[REPLACE]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat  (  delimiter  ,  encapsulator  ,  commentStart  ,  escape  ,  surroundingSpacesIgnored  ,  true  ,  lineSeparator  ,  header  )  ;  [FE]  null  assertEquals('?'  ,  format.withDelimiter('?').getDelimiter())  ;  assertEquals('?'  ,  format.withEncapsulator('?').getEncapsulator())  ;  assertEquals('?'  ,  format.withCommentStart('?').getCommentStart())  ;  assertEquals( "? "  ,  format.withLineSeparator( "? ").getLineSeparator())  ;  assertEquals('?'  ,  format.withEscape('?').getEscape())  ;  assertFalse(format.withSurroundingSpacesIgnored(false).isSurroundingSpacesIgnored())  ;  assertFalse(format.withEmptyLinesIgnored(false).isEmptyLinesIgnored())  ;  [CONTEXT]  public  CSVFormat  withEmptyLinesIgnored  (  boolean  emptyLinesIgnored  )  {  [ATTENTION]  return  new  CSVFormat  (  delimiter  ,  encapsulator  ,  commentStart  ,  escape  ,  surroundingSpacesIgnored  ,  true  ,  lineSeparator  ,  header  )    ;  }    [METHOD]  withEmptyLinesIgnored  [TYPE]  CSVFormat  [PARAMETER]  boolean  emptyLinesIgnored  [CLASS]  CSVFormat    [TYPE]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  [TYPE]  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  [TYPE]  boolean  emptyLinesIgnored  false  surroundingSpacesIgnored  true  [TYPE]  String  CRLF  lineSeparator  [TYPE]  String[]  header  
[REPLACE]  return  lineSeparator;	[BUGGY]  return  new  CSVParser  (  in  ,  this  )  ;  [CE]  cannot  find  symbol  in  [CONTEXT]  public  String  getLineSeparator  (  )  {  [ATTENTION]  return  new  CSVParser  (  in  ,  this  )    ;  }    [METHOD]  getLineSeparator  [TYPE]  String  [PARAMETER]  [CLASS]  CSVFormat    [TYPE]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  [TYPE]  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  [TYPE]  boolean  emptyLinesIgnored  false  surroundingSpacesIgnored  true  [TYPE]  String  CRLF  lineSeparator  [TYPE]  String[]  header  
[REPLACE]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  new  CSVFormat  (  delimiter  ,  encapsulator  ,  commentStart  ,  escape  ,  surroundingSpacesIgnored  ,  emptyLinesIgnored  ,  CRLF  ,  header  )  ;  [FE]  AssertionFailedError    expected:<[?]>  but  was:<[  assertEquals('?'  ,  format.withDelimiter('?').getDelimiter())  ;  assertEquals('?'  ,  format.withEncapsulator('?').getEncapsulator())  ;  assertEquals('?'  ,  format.withCommentStart('?').getCommentStart())  ;  assertEquals( "? "  ,  format.withLineSeparator( "? ").getLineSeparator())  ;  assertEquals('?'  ,  format.withEscape('?').getEscape())  ;  assertFalse(format.withSurroundingSpacesIgnored(false).isSurroundingSpacesIgnored())  ;  assertFalse(format.withEmptyLinesIgnored(false).isEmptyLinesIgnored())  ;  [CONTEXT]  public  CSVFormat  withLineSeparator  (  String  lineSeparator  )  {  [ATTENTION]  return  new  CSVFormat  (  delimiter  ,  encapsulator  ,  commentStart  ,  escape  ,  surroundingSpacesIgnored  ,  emptyLinesIgnored  ,  CRLF  ,  header  )    ;  }    [METHOD]  withLineSeparator  [TYPE]  CSVFormat  [PARAMETER]  String  lineSeparator  [CLASS]  CSVFormat    [TYPE]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  [TYPE]  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  [TYPE]  boolean  emptyLinesIgnored  false  surroundingSpacesIgnored  true  [TYPE]  String  CRLF  lineSeparator  [TYPE]  String[]  header  
[REPLACE]  return  header;	[BUGGY]  return  lineSeparator  ;  [CE]  incompatible  types  [CONTEXT]  String[]  getHeader  (  )  {  [ATTENTION]  return  lineSeparator  ;  }    [METHOD]  getHeader  [TYPE]  String[]  [PARAMETER]  [CLASS]  CSVFormat    [TYPE]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  [TYPE]  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  [TYPE]  boolean  emptyLinesIgnored  false  surroundingSpacesIgnored  true  [TYPE]  String  CRLF  lineSeparator  [TYPE]  String[]  header  
[REPLACE]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUGGY]  return  lineSeparator  ;  [CE]  incompatible  types  [CONTEXT]  public  CSVFormat  withHeader  (  String  .  .  .  header  )  {  [ATTENTION]  return  lineSeparator  ;  }    [METHOD]  withHeader  [TYPE]  CSVFormat  [PARAMETER]  header  [CLASS]  CSVFormat    [TYPE]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  [TYPE]  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  [TYPE]  boolean  emptyLinesIgnored  false  surroundingSpacesIgnored  true  [TYPE]  String  CRLF  lineSeparator  [TYPE]  String[]  header  
[REPLACE]  return  new  CSVParser  (  in,  this  )  ;	[BUGGY]  return  new  CSVPrinter  (  out  ,  this  )    ;  [CE]  cannot  find  symbol  out  [CONTEXT]  public  Iterable<CSVRecord>  parse  (  Reader  in  )  throws  IOException  {  [ATTENTION]  returnnew  CSVPrinter  (  out  ,  this  )  ;  }    [METHOD]  parse  [TYPE]  Iterable  [PARAMETER]  Reader  in  [CLASS]  CSVFormat    [TYPE]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  [TYPE]  Reader  in  [TYPE]  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  [TYPE]  boolean  emptyLinesIgnored  false  surroundingSpacesIgnored  true  [TYPE]  String  CRLF  lineSeparator  [TYPE]  String[]  header  
[REPLACE]  StringWriter  out  =  new  StringWriter  (  )  ;	[BUGGY]  StringBuilder  sb  =  new  StringBuilder  (  )  ;  [CE]  cannot  find  symbol  out  [CONTEXT]  public  String  format  (  String  .  .  .  values  )  {  [ATTENTION]  StringBuilder  sb  =  new  StringBuilder  (  )    ;  try  {  new  CSVPrinter  (  out  ,  this  )  .  println  (  values  )  ;  }  catch  (  IOException  e  )  {    }  return  out  .  toString  (  )  .  trim  (  )  ;  }    [METHOD]  format  [TYPE]  String  [PARAMETER]  values  [CLASS]  CSVFormat    [TYPE]  boolean  emptyLinesIgnored  false  surroundingSpacesIgnored  true  [TYPE]  StringWriter  out  [TYPE]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  [TYPE]  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  [TYPE]  String  CRLF  lineSeparator  [TYPE]  String[]  header  values  [TYPE]  IOException  e  
[ADD]  try  {  new  CSVPrinter  (  out,  this  )    .  println  (  values  )  ;  }  catch  (  IOException  e  )  {  }	[BUGGY]  new  CSVPrinter  (  out  ,  this  )  .  println  (  values  )  ;  [CE]  unreported  exception  IOException  ;  must  be  caught  or  declared  to  be  thrown  [CONTEXT]  public  String  format  (  String  .  .  .  values  )  {  StringWriter  out  =  new  StringWriter  (  )  ;  [ATTENTION]  new  CSVPrinter  (  out  ,  this  )    .  println  (  values  )    ;        return  out  .  toString  (  )  .  trim  (  )  ;  }    [METHOD]  format  [TYPE]  String  [PARAMETER]  values  [CLASS]  CSVFormat    [TYPE]  boolean  emptyLinesIgnored  false  surroundingSpacesIgnored  true  [TYPE]  StringWriter  out  [TYPE]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  [TYPE]  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  [TYPE]  String  CRLF  lineSeparator  [TYPE]  String[]  header  values  [TYPE]  IOException  e  
[REPLACE]  new  CSVPrinter  (  out,  this  )    .  println  (  values  )  ;	[BUGGY]  new  CSVPrinter  (  out  ,  this  )  .  CSVPrinter  (  header  )  ;  [CE]  cannot  find  symbol  [CONTEXT]  public  String  format  (  String  .  .  .  values  )  {  StringWriter  out  =  new  StringWriter  (  )  ;  try  {  [ATTENTION]  new  CSVPrinter  (  out  ,  this  )    .  CSVPrinter  (  header  )    ;  }  catch  (  IOException  e  )  {    }  return  out  .  toString  (  )  .  trim  (  )  ;  }    [METHOD]  format  [TYPE]  String  [PARAMETER]  values  [CLASS]  CSVFormat    [TYPE]  boolean  emptyLinesIgnored  false  surroundingSpacesIgnored  true  [TYPE]  StringWriter  out  [TYPE]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  [TYPE]  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  [TYPE]  String  CRLF  lineSeparator  [TYPE]  String[]  header  values  [TYPE]  IOException  e  
[ADD]  new  CSVPrinter  (  out,  this  )    .  println  (  values  )  ;	[BUGGY]  [CE]  exception  IOException  is  never  thrown  in  body  of  corresponding  try  statement  [CONTEXT]  public  String  format  (  String  .  .  .  values  )  {  StringWriter  out  =  new  StringWriter  (  )  ;  try  {  [ATTENTION]  }  catch  (  IOException  e  )  {    }  return  out  .  toString  (  )  .  trim  (  )  ;  }    [METHOD]  format  [TYPE]  String  [PARAMETER]  values  [CLASS]  CSVFormat    [TYPE]  boolean  emptyLinesIgnored  false  surroundingSpacesIgnored  true  [TYPE]  StringWriter  out  [TYPE]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  [TYPE]  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  [TYPE]  String  CRLF  lineSeparator  [TYPE]  String[]  header  values  [TYPE]  IOException  e  
[REPLACE]  return  out  .  toString  (  )    .  trim  (  )  ;	[BUGGY]  return  out  .  StringWriter  (  )  .  trim  (  )  ;  [CE]  cannot  find  symbol  [CONTEXT]  public  String  format  (  String  .  .  .  values  )  {  StringWriter  out  =  new  StringWriter  (  )  ;  try  {  new  CSVPrinter  (  out  ,  this  )  .  println  (  values  )  ;  }  catch  (  IOException  e  )  {    }  [ATTENTION]  return  out  .  StringWriter  (  )    .  trim  (  )    ;  }    [METHOD]  format  [TYPE]  String  [PARAMETER]  values  [CLASS]  CSVFormat    [TYPE]  boolean  emptyLinesIgnored  false  surroundingSpacesIgnored  true  [TYPE]  StringWriter  out  [TYPE]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  [TYPE]  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  [TYPE]  String  CRLF  lineSeparator  [TYPE]  String[]  header  values  [TYPE]  IOException  e  
[REPLACE]  StringBuilder  sb  =  new  StringBuilder  (  )  ;	[BUGGY]  StringWriter  out  =  new  StringWriter  (  )  ;  [CE]  cannot  find  symbol  sb  [CONTEXT]  public  String  toString  (  )  {  [ATTENTION]  StringWriter  out  =  new  StringWriter  (  )    ;  sb  .  append  (   "Delimiter  =  < "  )  .  append  (  delimiter  )  .  append  (  '>'  )  ;  if  (  isEscaping  (  )  )  {  sb  .  append  (  '  '  )  ;  sb  .  append  (   "Escape  =  < "  )  .  append  (  escape  )  .  append  (  '>'  )  ;  }  if  (  isEncapsulating  (  )  )  {  sb  .  append  (  '  '  )  ;  sb  .  append  (   "Encapsulator  =  < "  )  .  append  (  encapsulator  )  .  append  (  '>'  )  ;  }  if  (  isCommentingEnabled  (  )  )  {  sb  .  append  (  '  '  )  ;  sb  .  append  (   "CommentStart  =  < "  )  .  append  (  commentStart  )  .  append  (  '>'  )  ;  }  if  (  isEmptyLinesIgnored  (  )  )  {  sb  .  append  (   "  EmptyLines:ignored "  )  ;  }  if  (  isSurroundingSpacesIgnored  (  )  )  {  sb  .  append  (   "  SurroundingSpaces:ignored "  )  ;  }  return  sb  .  toString  (  )  ;  }    [METHOD]  toString  [TYPE]  String  [PARAMETER]  [CLASS]  CSVFormat    [TYPE]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  [TYPE]  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  [TYPE]  boolean  emptyLinesIgnored  false  surroundingSpacesIgnored  true  [TYPE]  String  CRLF  lineSeparator  [TYPE]  String[]  header  values  [TYPE]  StringBuilder  sb  
[REPLACE]  sb  .  append  (   "Delimiter=< "  )    .  append  (  delimiter  )    .  append  (  '>'  )  ;	[BUGGY]  sb  .  StringBuilder  (  )[CE]  '  ;  '  expected  [CONTEXT]  public  String  toString  (  )  {  StringBuilder  sb  =  new  StringBuilder  (  )  ;  [ATTENTION]  sb  .  StringBuilder  (  )  if  (  isEscaping  (  )  )  {  sb  .  append  (  '  '  )  ;  sb  .  append  (   "Escape  =  < "  )  .  append  (  escape  )  .  append  (  '>'  )  ;  }  if  (  isEncapsulating  (  )  )  {  sb  .  append  (  '  '  )  ;  sb  .  append  (   "Encapsulator  =  < "  )  .  append  (  encapsulator  )  .  append  (  '>'  )  ;  }  if  (  isCommentingEnabled  (  )  )  {  sb  .  append  (  '  '  )  ;  sb  .  append  (   "CommentStart  =  < "  )  .  append  (  commentStart  )  .  append  (  '>'  )  ;  }  if  (  isEmptyLinesIgnored  (  )  )  {  sb  .  append  (   "  EmptyLines:ignored "  )  ;  }  if  (  isSurroundingSpacesIgnored  (  )  )  {  sb  .  append  (   "  SurroundingSpaces:ignored "  )  ;  }  return  sb  .  toString  (  )  ;  }    [METHOD]  toString  [TYPE]  String  [PARAMETER]  [CLASS]  CSVFormat    [TYPE]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  [TYPE]  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  [TYPE]  boolean  emptyLinesIgnored  false  surroundingSpacesIgnored  true  [TYPE]  String  CRLF  lineSeparator  [TYPE]  String[]  header  values  [TYPE]  StringBuilder  sb  
[REPLACE]  sb  .  append  (   "Delimiter=< "  )    .  append  (  delimiter  )    .  append  (  '>'  )  ;	[BUGGY]  sb  .  append  (   "CommentStart  =  < "  )  .  append  (  commentStart  )  .  append  (  '>'  )  ;  [NO-ERROR]  [CONTEXT]  public  String  toString  (  )  {  StringBuilder  sb  =  new  StringBuilder  (  )  ;  [ATTENTION]  sb  .  append  (   "CommentStart  =  < "  )    .  append  (  commentStart  )    .  append  (  '>'  )    ;  if  (  isEscaping  (  )  )  {  sb  .  append  (  '  '  )  ;  sb  .  append  (   "Escape  =  < "  )  .  append  (  escape  )  .  append  (  '>'  )  ;  }  if  (  isEncapsulating  (  )  )  {  sb  .  append  (  '  '  )  ;  sb  .  append  (   "Encapsulator  =  < "  )  .  append  (  encapsulator  )  .  append  (  '>'  )  ;  }  if  (  isCommentingEnabled  (  )  )  {  sb  .  append  (  '  '  )  ;  sb  .  append  (   "CommentStart  =  < "  )  .  append  (  commentStart  )  .  append  (  '>'  )  ;  }  if  (  isEmptyLinesIgnored  (  )  )  {  sb  .  append  (   "  EmptyLines:ignored "  )  ;  }  if  (  isSurroundingSpacesIgnored  (  )  )  {  sb  .  append  (   "  SurroundingSpaces:ignored "  )  ;  }  return  sb  .  toString  (  )  ;  }    [METHOD]  toString  [TYPE]  String  [PARAMETER]  [CLASS]  CSVFormat    [TYPE]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  [TYPE]  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  [TYPE]  boolean  emptyLinesIgnored  false  surroundingSpacesIgnored  true  [TYPE]  String  CRLF  lineSeparator  [TYPE]  String[]  header  values  [TYPE]  StringBuilder  sb  
[REPLACE]  if  (  isEscaping  (  )  )  {	[BUGGY]  if  (  isEncapsulating  (  )  )  {[NO-ERROR]  [CONTEXT]  public  String  toString  (  )  {  StringBuilder  sb  =  new  StringBuilder  (  )  ;  sb  .  append  (   "Delimiter  =  < "  )  .  append  (  delimiter  )  .  append  (  '>'  )  ;  [ATTENTION]  if  (  isEncapsulating  (  )  )  {  sb  .  append  (  '  '  )  ;  sb  .  append  (   "Escape  =  < "  )  .  append  (  escape  )  .  append  (  '>'  )  ;  }  if  (  isEncapsulating  (  )  )  {  sb  .  append  (  '  '  )  ;  sb  .  append  (   "Encapsulator  =  < "  )  .  append  (  encapsulator  )  .  append  (  '>'  )  ;  }  if  (  isCommentingEnabled  (  )  )  {  sb  .  append  (  '  '  )  ;  sb  .  append  (   "CommentStart  =  < "  )  .  append  (  commentStart  )  .  append  (  '>'  )  ;  }  if  (  isEmptyLinesIgnored  (  )  )  {  sb  .  append  (   "  EmptyLines:ignored "  )  ;  }  if  (  isSurroundingSpacesIgnored  (  )  )  {  sb  .  append  (   "  SurroundingSpaces:ignored "  )  ;  }  return  sb  .  toString  (  )  ;  }    [METHOD]  toString  [TYPE]  String  [PARAMETER]  [CLASS]  CSVFormat    [TYPE]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  [TYPE]  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  [TYPE]  boolean  emptyLinesIgnored  false  surroundingSpacesIgnored  true  [TYPE]  String  CRLF  lineSeparator  [TYPE]  String[]  header  values  [TYPE]  StringBuilder  sb  
[REPLACE]  sb  .  append  (  '  '  )  ;	[BUGGY]  sb  .  StringBuilder  (  )    ;  [CE]  cannot  find  symbol  [CONTEXT]  public  String  toString  (  )  {  StringBuilder  sb  =  new  StringBuilder  (  )  ;  sb  .  append  (   "Delimiter  =  < "  )  .  append  (  delimiter  )  .  append  (  '>'  )  ;  if  (  isEscaping  (  )  )  {  [ATTENTION]  sb  .  StringBuilder  (  )  ;  sb  .  append  (   "Escape  =  < "  )  .  append  (  escape  )  .  append  (  '>'  )  ;  }  if  (  isEncapsulating  (  )  )  {  sb  .  append  (  '  '  )  ;  sb  .  append  (   "Encapsulator  =  < "  )  .  append  (  encapsulator  )  .  append  (  '>'  )  ;  }  if  (  isCommentingEnabled  (  )  )  {  sb  .  append  (  '  '  )  ;  sb  .  append  (   "CommentStart  =  < "  )  .  append  (  commentStart  )  .  append  (  '>'  )  ;  }  if  (  isEmptyLinesIgnored  (  )  )  {  sb  .  append  (   "  EmptyLines:ignored "  )  ;  }  if  (  isSurroundingSpacesIgnored  (  )  )  {  sb  .  append  (   "  SurroundingSpaces:ignored "  )  ;  }  return  sb  .  toString  (  )  ;  }    [METHOD]  toString  [TYPE]  String  [PARAMETER]  [CLASS]  CSVFormat    [TYPE]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  [TYPE]  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  [TYPE]  boolean  emptyLinesIgnored  false  surroundingSpacesIgnored  true  [TYPE]  String  CRLF  lineSeparator  [TYPE]  String[]  header  values  [TYPE]  StringBuilder  sb  
[ADD]  sb  .  append  (  '  '  )  ;	[BUGGY]  [NO-ERROR]  [CONTEXT]  public  String  toString  (  )  {  StringBuilder  sb  =  new  StringBuilder  (  )  ;  sb  .  append  (   "Delimiter  =  < "  )  .  append  (  delimiter  )  .  append  (  '>'  )  ;  if  (  isEscaping  (  )  )  {  [ATTENTION]  sb  .  append  (   "Escape  =  < "  )  .  append  (  escape  )  .  append  (  '>'  )  ;  }  if  (  isEncapsulating  (  )  )  {  sb  .  append  (  '  '  )  ;  sb  .  append  (   "Encapsulator  =  < "  )  .  append  (  encapsulator  )  .  append  (  '>'  )  ;  }  if  (  isCommentingEnabled  (  )  )  {  sb  .  append  (  '  '  )  ;  sb  .  append  (   "CommentStart  =  < "  )  .  append  (  commentStart  )  .  append  (  '>'  )  ;  }  if  (  isEmptyLinesIgnored  (  )  )  {  sb  .  append  (   "  EmptyLines:ignored "  )  ;  }  if  (  isSurroundingSpacesIgnored  (  )  )  {  sb  .  append  (   "  SurroundingSpaces:ignored "  )  ;  }  return  sb  .  toString  (  )  ;  }    [METHOD]  toString  [TYPE]  String  [PARAMETER]  [CLASS]  CSVFormat    [TYPE]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  [TYPE]  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  [TYPE]  boolean  emptyLinesIgnored  false  surroundingSpacesIgnored  true  [TYPE]  String  CRLF  lineSeparator  [TYPE]  String[]  header  values  [TYPE]  StringBuilder  sb  
[REPLACE]  sb  .  append  (   "Escape=< "  )    .  append  (  escape  )    .  append  (  '>'  )  ;	[BUGGY]  sb  .  append  (   "Delimiter  =  < "  )  .  append  (  delimiter  )  .  append  (  '>'  )  ;  [NO-ERROR]  [CONTEXT]  public  String  toString  (  )  {  StringBuilder  sb  =  new  StringBuilder  (  )  ;  sb  .  append  (   "Delimiter  =  < "  )  .  append  (  delimiter  )  .  append  (  '>'  )  ;  if  (  isEscaping  (  )  )  {  sb  .  append  (  '  '  )  ;  [ATTENTION]  sb  .  append  (   "Delimiter  =  < "  )    .  append  (  delimiter  )    .  append  (  '>'  )    ;  }  if  (  isEncapsulating  (  )  )  {  sb  .  append  (  '  '  )  ;  sb  .  append  (   "Encapsulator  =  < "  )  .  append  (  encapsulator  )  .  append  (  '>'  )  ;  }  if  (  isCommentingEnabled  (  )  )  {  sb  .  append  (  '  '  )  ;  sb  .  append  (   "CommentStart  =  < "  )  .  append  (  commentStart  )  .  append  (  '>'  )  ;  }  if  (  isEmptyLinesIgnored  (  )  )  {  sb  .  append  (   "  EmptyLines:ignored "  )  ;  }  if  (  isSurroundingSpacesIgnored  (  )  )  {  sb  .  append  (   "  SurroundingSpaces:ignored "  )  ;  }  return  sb  .  toString  (  )  ;  }    [METHOD]  toString  [TYPE]  String  [PARAMETER]  [CLASS]  CSVFormat    [TYPE]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  [TYPE]  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  [TYPE]  boolean  emptyLinesIgnored  false  surroundingSpacesIgnored  true  [TYPE]  String  CRLF  lineSeparator  [TYPE]  String[]  header  values  [TYPE]  StringBuilder  sb  
[REPLACE]  sb  .  append  (   "Escape=< "  )    .  append  (  escape  )    .  append  (  '>'  )  ;	[BUGGY]  sb  .  StringBuilder  (  )[CE]  '  ;  '  expected  [CONTEXT]  public  String  toString  (  )  {  StringBuilder  sb  =  new  StringBuilder  (  )  ;  sb  .  append  (   "Delimiter  =  < "  )  .  append  (  delimiter  )  .  append  (  '>'  )  ;  if  (  isEscaping  (  )  )  {  sb  .  append  (  '  '  )  ;  [ATTENTION]  sb  .  StringBuilder  (  )  }  if  (  isEncapsulating  (  )  )  {  sb  .  append  (  '  '  )  ;  sb  .  append  (   "Encapsulator  =  < "  )  .  append  (  encapsulator  )  .  append  (  '>'  )  ;  }  if  (  isCommentingEnabled  (  )  )  {  sb  .  append  (  '  '  )  ;  sb  .  append  (   "CommentStart  =  < "  )  .  append  (  commentStart  )  .  append  (  '>'  )  ;  }  if  (  isEmptyLinesIgnored  (  )  )  {  sb  .  append  (   "  EmptyLines:ignored "  )  ;  }  if  (  isSurroundingSpacesIgnored  (  )  )  {  sb  .  append  (   "  SurroundingSpaces:ignored "  )  ;  }  return  sb  .  toString  (  )  ;  }    [METHOD]  toString  [TYPE]  String  [PARAMETER]  [CLASS]  CSVFormat    [TYPE]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  [TYPE]  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  [TYPE]  boolean  emptyLinesIgnored  false  surroundingSpacesIgnored  true  [TYPE]  String  CRLF  lineSeparator  [TYPE]  String[]  header  values  [TYPE]  StringBuilder  sb  
[REPLACE]  if  (  isEncapsulating  (  )  )  {	[BUGGY]  if  (  isEscaping  (  )  )  {[NO-ERROR]  [CONTEXT]  public  String  toString  (  )  {  StringBuilder  sb  =  new  StringBuilder  (  )  ;  sb  .  append  (   "Delimiter  =  < "  )  .  append  (  delimiter  )  .  append  (  '>'  )  ;  if  (  isEscaping  (  )  )  {  sb  .  append  (  '  '  )  ;  sb  .  append  (   "Escape  =  < "  )  .  append  (  escape  )  .  append  (  '>'  )  ;  }  [ATTENTION]  if  (  isEscaping  (  )  )  {  sb  .  append  (  '  '  )  ;  sb  .  append  (   "Encapsulator  =  < "  )  .  append  (  encapsulator  )  .  append  (  '>'  )  ;  }  if  (  isCommentingEnabled  (  )  )  {  sb  .  append  (  '  '  )  ;  sb  .  append  (   "CommentStart  =  < "  )  .  append  (  commentStart  )  .  append  (  '>'  )  ;  }  if  (  isEmptyLinesIgnored  (  )  )  {  sb  .  append  (   "  EmptyLines:ignored "  )  ;  }  if  (  isSurroundingSpacesIgnored  (  )  )  {  sb  .  append  (   "  SurroundingSpaces:ignored "  )  ;  }  return  sb  .  toString  (  )  ;  }    [METHOD]  toString  [TYPE]  String  [PARAMETER]  [CLASS]  CSVFormat    [TYPE]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  [TYPE]  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  [TYPE]  boolean  emptyLinesIgnored  false  surroundingSpacesIgnored  true  [TYPE]  String  CRLF  lineSeparator  [TYPE]  String[]  header  values  [TYPE]  StringBuilder  sb  
[ADD]  if  (  isEncapsulating  (  )  )  {  sb  .  append  (  '  '  )  ;  sb  .  append  (   "Encapsulator=< "  )    .  append  (  encapsulator  )    .  append  (  '>'  )  ;  }	[BUGGY]  [NO-ERROR]  [CONTEXT]  public  String  toString  (  )  {  StringBuilder  sb  =  new  StringBuilder  (  )  ;  sb  .  append  (   "Delimiter  =  < "  )  .  append  (  delimiter  )  .  append  (  '>'  )  ;  if  (  isEscaping  (  )  )  {  sb  .  append  (  '  '  )  ;  sb  .  append  (   "Escape  =  < "  )  .  append  (  escape  )  .  append  (  '>'  )  ;  }  [ATTENTION]      if  (  isCommentingEnabled  (  )  )  {  sb  .  append  (  '  '  )  ;  sb  .  append  (   "CommentStart  =  < "  )  .  append  (  commentStart  )  .  append  (  '>'  )  ;  }  if  (  isEmptyLinesIgnored  (  )  )  {  sb  .  append  (   "  EmptyLines:ignored "  )  ;  }  if  (  isSurroundingSpacesIgnored  (  )  )  {  sb  .  append  (   "  SurroundingSpaces:ignored "  )  ;  }  return  sb  .  toString  (  )  ;  }    [METHOD]  toString  [TYPE]  String  [PARAMETER]  [CLASS]  CSVFormat    [TYPE]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  [TYPE]  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  [TYPE]  boolean  emptyLinesIgnored  false  surroundingSpacesIgnored  true  [TYPE]  String  CRLF  lineSeparator  [TYPE]  String[]  header  values  [TYPE]  StringBuilder  sb  
[REPLACE]  sb  .  append  (  '  '  )  ;	[BUGGY]  sb  .  StringBuilder  (  )    ;  [CE]  cannot  find  symbol  [CONTEXT]  public  String  toString  (  )  {  StringBuilder  sb  =  new  StringBuilder  (  )  ;  sb  .  append  (   "Delimiter  =  < "  )  .  append  (  delimiter  )  .  append  (  '>'  )  ;  if  (  isEscaping  (  )  )  {  sb  .  append  (  '  '  )  ;  sb  .  append  (   "Escape  =  < "  )  .  append  (  escape  )  .  append  (  '>'  )  ;  }  if  (  isEncapsulating  (  )  )  {  [ATTENTION]  sb  .  StringBuilder  (  )  ;  sb  .  append  (   "Encapsulator  =  < "  )  .  append  (  encapsulator  )  .  append  (  '>'  )  ;  }  if  (  isCommentingEnabled  (  )  )  {  sb  .  append  (  '  '  )  ;  sb  .  append  (   "CommentStart  =  < "  )  .  append  (  commentStart  )  .  append  (  '>'  )  ;  }  if  (  isEmptyLinesIgnored  (  )  )  {  sb  .  append  (   "  EmptyLines:ignored "  )  ;  }  if  (  isSurroundingSpacesIgnored  (  )  )  {  sb  .  append  (   "  SurroundingSpaces:ignored "  )  ;  }  return  sb  .  toString  (  )  ;  }    [METHOD]  toString  [TYPE]  String  [PARAMETER]  [CLASS]  CSVFormat    [TYPE]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  [TYPE]  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  [TYPE]  boolean  emptyLinesIgnored  false  surroundingSpacesIgnored  true  [TYPE]  String  CRLF  lineSeparator  [TYPE]  String[]  header  values  [TYPE]  StringBuilder  sb  
[REPLACE]  sb  .  append  (   "Encapsulator=< "  )    .  append  (  encapsulator  )    .  append  (  '>'  )  ;	[BUGGY]  sb  .  append  (   "Delimiter  =  < "  )  .  append  (  delimiter  )  .  append  (  '>'  )  ;  [NO-ERROR]  [CONTEXT]  public  String  toString  (  )  {  StringBuilder  sb  =  new  StringBuilder  (  )  ;  sb  .  append  (   "Delimiter  =  < "  )  .  append  (  delimiter  )  .  append  (  '>'  )  ;  if  (  isEscaping  (  )  )  {  sb  .  append  (  '  '  )  ;  sb  .  append  (   "Escape  =  < "  )  .  append  (  escape  )  .  append  (  '>'  )  ;  }  if  (  isEncapsulating  (  )  )  {  sb  .  append  (  '  '  )  ;  [ATTENTION]  sb  .  append  (   "Delimiter  =  < "  )    .  append  (  delimiter  )    .  append  (  '>'  )    ;  }  if  (  isCommentingEnabled  (  )  )  {  sb  .  append  (  '  '  )  ;  sb  .  append  (   "CommentStart  =  < "  )  .  append  (  commentStart  )  .  append  (  '>'  )  ;  }  if  (  isEmptyLinesIgnored  (  )  )  {  sb  .  append  (   "  EmptyLines:ignored "  )  ;  }  if  (  isSurroundingSpacesIgnored  (  )  )  {  sb  .  append  (   "  SurroundingSpaces:ignored "  )  ;  }  return  sb  .  toString  (  )  ;  }    [METHOD]  toString  [TYPE]  String  [PARAMETER]  [CLASS]  CSVFormat    [TYPE]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  [TYPE]  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  [TYPE]  boolean  emptyLinesIgnored  false  surroundingSpacesIgnored  true  [TYPE]  String  CRLF  lineSeparator  [TYPE]  String[]  header  values  [TYPE]  StringBuilder  sb  
[ADD]  sb  .  append  (   "Encapsulator=< "  )    .  append  (  encapsulator  )    .  append  (  '>'  )  ;	[BUGGY]  [NO-ERROR]  [CONTEXT]  public  String  toString  (  )  {  StringBuilder  sb  =  new  StringBuilder  (  )  ;  sb  .  append  (   "Delimiter  =  < "  )  .  append  (  delimiter  )  .  append  (  '>'  )  ;  if  (  isEscaping  (  )  )  {  sb  .  append  (  '  '  )  ;  sb  .  append  (   "Escape  =  < "  )  .  append  (  escape  )  .  append  (  '>'  )  ;  }  if  (  isEncapsulating  (  )  )  {  sb  .  append  (  '  '  )  ;  [ATTENTION]  }  if  (  isCommentingEnabled  (  )  )  {  sb  .  append  (  '  '  )  ;  sb  .  append  (   "CommentStart  =  < "  )  .  append  (  commentStart  )  .  append  (  '>'  )  ;  }  if  (  isEmptyLinesIgnored  (  )  )  {  sb  .  append  (   "  EmptyLines:ignored "  )  ;  }  if  (  isSurroundingSpacesIgnored  (  )  )  {  sb  .  append  (   "  SurroundingSpaces:ignored "  )  ;  }  return  sb  .  toString  (  )  ;  }    [METHOD]  toString  [TYPE]  String  [PARAMETER]  [CLASS]  CSVFormat    [TYPE]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  [TYPE]  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  [TYPE]  boolean  emptyLinesIgnored  false  surroundingSpacesIgnored  true  [TYPE]  String  CRLF  lineSeparator  [TYPE]  String[]  header  values  [TYPE]  StringBuilder  sb  
[REPLACE]  sb  .  append  (   "Encapsulator=< "  )    .  append  (  encapsulator  )    .  append  (  '>'  )  ;	[BUGGY]  sb  .  StringBuilder  (  )[CE]  '  ;  '  expected  [CONTEXT]  public  String  toString  (  )  {  StringBuilder  sb  =  new  StringBuilder  (  )  ;  sb  .  append  (   "Delimiter  =  < "  )  .  append  (  delimiter  )  .  append  (  '>'  )  ;  if  (  isEscaping  (  )  )  {  sb  .  append  (  '  '  )  ;  sb  .  append  (   "Escape  =  < "  )  .  append  (  escape  )  .  append  (  '>'  )  ;  }  if  (  isEncapsulating  (  )  )  {  sb  .  append  (  '  '  )  ;  [ATTENTION]  sb  .  StringBuilder  (  )  }  if  (  isCommentingEnabled  (  )  )  {  sb  .  append  (  '  '  )  ;  sb  .  append  (   "CommentStart  =  < "  )  .  append  (  commentStart  )  .  append  (  '>'  )  ;  }  if  (  isEmptyLinesIgnored  (  )  )  {  sb  .  append  (   "  EmptyLines:ignored "  )  ;  }  if  (  isSurroundingSpacesIgnored  (  )  )  {  sb  .  append  (   "  SurroundingSpaces:ignored "  )  ;  }  return  sb  .  toString  (  )  ;  }    [METHOD]  toString  [TYPE]  String  [PARAMETER]  [CLASS]  CSVFormat    [TYPE]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  [TYPE]  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  [TYPE]  boolean  emptyLinesIgnored  false  surroundingSpacesIgnored  true  [TYPE]  String  CRLF  lineSeparator  [TYPE]  String[]  header  values  [TYPE]  StringBuilder  sb  
[REPLACE]  if  (  isCommentingEnabled  (  )  )  {	[BUGGY]  if  (  isLineBreak  (  escape  )  )  {[NO-ERROR]  [CONTEXT]  public  String  toString  (  )  {  StringBuilder  sb  =  new  StringBuilder  (  )  ;  sb  .  append  (   "Delimiter  =  < "  )  .  append  (  delimiter  )  .  append  (  '>'  )  ;  if  (  isEscaping  (  )  )  {  sb  .  append  (  '  '  )  ;  sb  .  append  (   "Escape  =  < "  )  .  append  (  escape  )  .  append  (  '>'  )  ;  }  if  (  isEncapsulating  (  )  )  {  sb  .  append  (  '  '  )  ;  sb  .  append  (   "Encapsulator  =  < "  )  .  append  (  encapsulator  )  .  append  (  '>'  )  ;  }  [ATTENTION]  if  (  isLineBreak  (  escape  )  )  {  sb  .  append  (  '  '  )  ;  sb  .  append  (   "CommentStart  =  < "  )  .  append  (  commentStart  )  .  append  (  '>'  )  ;  }  if  (  isEmptyLinesIgnored  (  )  )  {  sb  .  append  (   "  EmptyLines:ignored "  )  ;  }  if  (  isSurroundingSpacesIgnored  (  )  )  {  sb  .  append  (   "  SurroundingSpaces:ignored "  )  ;  }  return  sb  .  toString  (  )  ;  }    [METHOD]  toString  [TYPE]  String  [PARAMETER]  [CLASS]  CSVFormat    [TYPE]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  [TYPE]  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  [TYPE]  boolean  emptyLinesIgnored  false  surroundingSpacesIgnored  true  [TYPE]  String  CRLF  lineSeparator  [TYPE]  String[]  header  values  [TYPE]  StringBuilder  sb  
[REPLACE]  sb  .  append  (  '  '  )  ;	[BUGGY]  sb  .  append  (   "  EmptyLines:ignored "  )  ;  [NO-ERROR]  [CONTEXT]  public  String  toString  (  )  {  StringBuilder  sb  =  new  StringBuilder  (  )  ;  sb  .  append  (   "Delimiter  =  < "  )  .  append  (  delimiter  )  .  append  (  '>'  )  ;  if  (  isEscaping  (  )  )  {  sb  .  append  (  '  '  )  ;  sb  .  append  (   "Escape  =  < "  )  .  append  (  escape  )  .  append  (  '>'  )  ;  }  if  (  isEncapsulating  (  )  )  {  sb  .  append  (  '  '  )  ;  sb  .  append  (   "Encapsulator  =  < "  )  .  append  (  encapsulator  )  .  append  (  '>'  )  ;  }  if  (  isCommentingEnabled  (  )  )  {  [ATTENTION]  sb  .  append  (   "  EmptyLines:ignored "  )    ;  sb  .  append  (   "CommentStart  =  < "  )  .  append  (  commentStart  )  .  append  (  '>'  )  ;  }  if  (  isEmptyLinesIgnored  (  )  )  {  sb  .  append  (   "  EmptyLines:ignored "  )  ;  }  if  (  isSurroundingSpacesIgnored  (  )  )  {  sb  .  append  (   "  SurroundingSpaces:ignored "  )  ;  }  return  sb  .  toString  (  )  ;  }    [METHOD]  toString  [TYPE]  String  [PARAMETER]  [CLASS]  CSVFormat    [TYPE]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  [TYPE]  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  [TYPE]  boolean  emptyLinesIgnored  false  surroundingSpacesIgnored  true  [TYPE]  String  CRLF  lineSeparator  [TYPE]  String[]  header  values  [TYPE]  StringBuilder  sb  
[REPLACE]  sb  .  append  (   "CommentStart=< "  )    .  append  (  commentStart  )    .  append  (  '>'  )  ;	[BUGGY]  sb  .  append  (   "Delimiter  =  < "  )  .  append  (  delimiter  )  .  append  (  '>'  )  ;  [NO-ERROR]  [CONTEXT]  public  String  toString  (  )  {  StringBuilder  sb  =  new  StringBuilder  (  )  ;  sb  .  append  (   "Delimiter  =  < "  )  .  append  (  delimiter  )  .  append  (  '>'  )  ;  if  (  isEscaping  (  )  )  {  sb  .  append  (  '  '  )  ;  sb  .  append  (   "Escape  =  < "  )  .  append  (  escape  )  .  append  (  '>'  )  ;  }  if  (  isEncapsulating  (  )  )  {  sb  .  append  (  '  '  )  ;  sb  .  append  (   "Encapsulator  =  < "  )  .  append  (  encapsulator  )  .  append  (  '>'  )  ;  }  if  (  isCommentingEnabled  (  )  )  {  sb  .  append  (  '  '  )  ;  [ATTENTION]  sb  .  append  (   "Delimiter  =  < "  )    .  append  (  delimiter  )    .  append  (  '>'  )    ;  }  if  (  isEmptyLinesIgnored  (  )  )  {  sb  .  append  (   "  EmptyLines:ignored "  )  ;  }  if  (  isSurroundingSpacesIgnored  (  )  )  {  sb  .  append  (   "  SurroundingSpaces:ignored "  )  ;  }  return  sb  .  toString  (  )  ;  }    [METHOD]  toString  [TYPE]  String  [PARAMETER]  [CLASS]  CSVFormat    [TYPE]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  [TYPE]  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  [TYPE]  boolean  emptyLinesIgnored  false  surroundingSpacesIgnored  true  [TYPE]  String  CRLF  lineSeparator  [TYPE]  String[]  header  values  [TYPE]  StringBuilder  sb  
[REPLACE]  if  (  isEmptyLinesIgnored  (  )  )  {	[BUGGY]  if  (  isLineBreak  (  escape  )  )  {[NO-ERROR]  [CONTEXT]  public  String  toString  (  )  {  StringBuilder  sb  =  new  StringBuilder  (  )  ;  sb  .  append  (   "Delimiter  =  < "  )  .  append  (  delimiter  )  .  append  (  '>'  )  ;  if  (  isEscaping  (  )  )  {  sb  .  append  (  '  '  )  ;  sb  .  append  (   "Escape  =  < "  )  .  append  (  escape  )  .  append  (  '>'  )  ;  }  if  (  isEncapsulating  (  )  )  {  sb  .  append  (  '  '  )  ;  sb  .  append  (   "Encapsulator  =  < "  )  .  append  (  encapsulator  )  .  append  (  '>'  )  ;  }  if  (  isCommentingEnabled  (  )  )  {  sb  .  append  (  '  '  )  ;  sb  .  append  (   "CommentStart  =  < "  )  .  append  (  commentStart  )  .  append  (  '>'  )  ;  }  [ATTENTION]  if  (  isLineBreak  (  escape  )  )  {  sb  .  append  (   "  EmptyLines:ignored "  )  ;  }  if  (  isSurroundingSpacesIgnored  (  )  )  {  sb  .  append  (   "  SurroundingSpaces:ignored "  )  ;  }  return  sb  .  toString  (  )  ;  }    [METHOD]  toString  [TYPE]  String  [PARAMETER]  [CLASS]  CSVFormat    [TYPE]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  [TYPE]  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  [TYPE]  boolean  emptyLinesIgnored  false  surroundingSpacesIgnored  true  [TYPE]  String  CRLF  lineSeparator  [TYPE]  String[]  header  values  [TYPE]  StringBuilder  sb  
[REPLACE]  sb  .  append  (   "  EmptyLines:ignored "  )  ;	[BUGGY]  sb  .  StringBuilder  (  )    ;  [CE]  cannot  find  symbol  [CONTEXT]  public  String  toString  (  )  {  StringBuilder  sb  =  new  StringBuilder  (  )  ;  sb  .  append  (   "Delimiter  =  < "  )  .  append  (  delimiter  )  .  append  (  '>'  )  ;  if  (  isEscaping  (  )  )  {  sb  .  append  (  '  '  )  ;  sb  .  append  (   "Escape  =  < "  )  .  append  (  escape  )  .  append  (  '>'  )  ;  }  if  (  isEncapsulating  (  )  )  {  sb  .  append  (  '  '  )  ;  sb  .  append  (   "Encapsulator  =  < "  )  .  append  (  encapsulator  )  .  append  (  '>'  )  ;  }  if  (  isCommentingEnabled  (  )  )  {  sb  .  append  (  '  '  )  ;  sb  .  append  (   "CommentStart  =  < "  )  .  append  (  commentStart  )  .  append  (  '>'  )  ;  }  if  (  isEmptyLinesIgnored  (  )  )  {  [ATTENTION]  sb  .  StringBuilder  (  )  ;  }  if  (  isSurroundingSpacesIgnored  (  )  )  {  sb  .  append  (   "  SurroundingSpaces:ignored "  )  ;  }  return  sb  .  toString  (  )  ;  }    [METHOD]  toString  [TYPE]  String  [PARAMETER]  [CLASS]  CSVFormat    [TYPE]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  [TYPE]  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  [TYPE]  boolean  emptyLinesIgnored  false  surroundingSpacesIgnored  true  [TYPE]  String  CRLF  lineSeparator  [TYPE]  String[]  header  values  [TYPE]  StringBuilder  sb  
[REPLACE]  if  (  isSurroundingSpacesIgnored  (  )  )  {	[BUGGY]  if  (  isLineBreak  (  escape  )  )  {[NO-ERROR]  [CONTEXT]  public  String  toString  (  )  {  StringBuilder  sb  =  new  StringBuilder  (  )  ;  sb  .  append  (   "Delimiter  =  < "  )  .  append  (  delimiter  )  .  append  (  '>'  )  ;  if  (  isEscaping  (  )  )  {  sb  .  append  (  '  '  )  ;  sb  .  append  (   "Escape  =  < "  )  .  append  (  escape  )  .  append  (  '>'  )  ;  }  if  (  isEncapsulating  (  )  )  {  sb  .  append  (  '  '  )  ;  sb  .  append  (   "Encapsulator  =  < "  )  .  append  (  encapsulator  )  .  append  (  '>'  )  ;  }  if  (  isCommentingEnabled  (  )  )  {  sb  .  append  (  '  '  )  ;  sb  .  append  (   "CommentStart  =  < "  )  .  append  (  commentStart  )  .  append  (  '>'  )  ;  }  if  (  isEmptyLinesIgnored  (  )  )  {  sb  .  append  (   "  EmptyLines:ignored "  )  ;  }  [ATTENTION]  if  (  isLineBreak  (  escape  )  )  {  sb  .  append  (   "  SurroundingSpaces:ignored "  )  ;  }  return  sb  .  toString  (  )  ;  }    [METHOD]  toString  [TYPE]  String  [PARAMETER]  [CLASS]  CSVFormat    [TYPE]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  [TYPE]  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  [TYPE]  boolean  emptyLinesIgnored  false  surroundingSpacesIgnored  true  [TYPE]  String  CRLF  lineSeparator  [TYPE]  String[]  header  values  [TYPE]  StringBuilder  sb  
[ADD]  if  (  isSurroundingSpacesIgnored  (  )  )  {  sb  .  append  (   "  SurroundingSpaces:ignored "  )  ;  }	[BUGGY]  [NO-ERROR]  [CONTEXT]  public  String  toString  (  )  {  StringBuilder  sb  =  new  StringBuilder  (  )  ;  sb  .  append  (   "Delimiter  =  < "  )  .  append  (  delimiter  )  .  append  (  '>'  )  ;  if  (  isEscaping  (  )  )  {  sb  .  append  (  '  '  )  ;  sb  .  append  (   "Escape  =  < "  )  .  append  (  escape  )  .  append  (  '>'  )  ;  }  if  (  isEncapsulating  (  )  )  {  sb  .  append  (  '  '  )  ;  sb  .  append  (   "Encapsulator  =  < "  )  .  append  (  encapsulator  )  .  append  (  '>'  )  ;  }  if  (  isCommentingEnabled  (  )  )  {  sb  .  append  (  '  '  )  ;  sb  .  append  (   "CommentStart  =  < "  )  .  append  (  commentStart  )  .  append  (  '>'  )  ;  }  if  (  isEmptyLinesIgnored  (  )  )  {  sb  .  append  (   "  EmptyLines:ignored "  )  ;  }  [ATTENTION]    return  sb  .  toString  (  )  ;  }    [METHOD]  toString  [TYPE]  String  [PARAMETER]  [CLASS]  CSVFormat    [TYPE]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  [TYPE]  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  [TYPE]  boolean  emptyLinesIgnored  false  surroundingSpacesIgnored  true  [TYPE]  String  CRLF  lineSeparator  [TYPE]  String[]  header  values  [TYPE]  StringBuilder  sb  
[REPLACE]  sb  .  append  (   "  SurroundingSpaces:ignored "  )  ;	[BUGGY]  sb  .  StringBuilder  (  )    ;  [CE]  cannot  find  symbol  [CONTEXT]  public  String  toString  (  )  {  StringBuilder  sb  =  new  StringBuilder  (  )  ;  sb  .  append  (   "Delimiter  =  < "  )  .  append  (  delimiter  )  .  append  (  '>'  )  ;  if  (  isEscaping  (  )  )  {  sb  .  append  (  '  '  )  ;  sb  .  append  (   "Escape  =  < "  )  .  append  (  escape  )  .  append  (  '>'  )  ;  }  if  (  isEncapsulating  (  )  )  {  sb  .  append  (  '  '  )  ;  sb  .  append  (   "Encapsulator  =  < "  )  .  append  (  encapsulator  )  .  append  (  '>'  )  ;  }  if  (  isCommentingEnabled  (  )  )  {  sb  .  append  (  '  '  )  ;  sb  .  append  (   "CommentStart  =  < "  )  .  append  (  commentStart  )  .  append  (  '>'  )  ;  }  if  (  isEmptyLinesIgnored  (  )  )  {  sb  .  append  (   "  EmptyLines:ignored "  )  ;  }  if  (  isSurroundingSpacesIgnored  (  )  )  {  [ATTENTION]  sb  .  StringBuilder  (  )  ;  }  return  sb  .  toString  (  )  ;  }    [METHOD]  toString  [TYPE]  String  [PARAMETER]  [CLASS]  CSVFormat    [TYPE]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  [TYPE]  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  [TYPE]  boolean  emptyLinesIgnored  false  surroundingSpacesIgnored  true  [TYPE]  String  CRLF  lineSeparator  [TYPE]  String[]  header  values  [TYPE]  StringBuilder  sb  
[ADD]  sb  .  append  (   "  SurroundingSpaces:ignored "  )  ;	[BUGGY]  [NO-ERROR]  [CONTEXT]  public  String  toString  (  )  {  StringBuilder  sb  =  new  StringBuilder  (  )  ;  sb  .  append  (   "Delimiter  =  < "  )  .  append  (  delimiter  )  .  append  (  '>'  )  ;  if  (  isEscaping  (  )  )  {  sb  .  append  (  '  '  )  ;  sb  .  append  (   "Escape  =  < "  )  .  append  (  escape  )  .  append  (  '>'  )  ;  }  if  (  isEncapsulating  (  )  )  {  sb  .  append  (  '  '  )  ;  sb  .  append  (   "Encapsulator  =  < "  )  .  append  (  encapsulator  )  .  append  (  '>'  )  ;  }  if  (  isCommentingEnabled  (  )  )  {  sb  .  append  (  '  '  )  ;  sb  .  append  (   "CommentStart  =  < "  )  .  append  (  commentStart  )  .  append  (  '>'  )  ;  }  if  (  isEmptyLinesIgnored  (  )  )  {  sb  .  append  (   "  EmptyLines:ignored "  )  ;  }  if  (  isSurroundingSpacesIgnored  (  )  )  {  [ATTENTION]  }  return  sb  .  toString  (  )  ;  }    [METHOD]  toString  [TYPE]  String  [PARAMETER]  [CLASS]  CSVFormat    [TYPE]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  [TYPE]  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  [TYPE]  boolean  emptyLinesIgnored  false  surroundingSpacesIgnored  true  [TYPE]  String  CRLF  lineSeparator  [TYPE]  String[]  header  values  [TYPE]  StringBuilder  sb  
[REPLACE]  return  sb  .  toString  (  )  ;	[BUGGY]  return  sb  .  StringBuilder  (  )  ;  [CE]  cannot  find  symbol  [CONTEXT]  public  String  toString  (  )  {  StringBuilder  sb  =  new  StringBuilder  (  )  ;  sb  .  append  (   "Delimiter  =  < "  )  .  append  (  delimiter  )  .  append  (  '>'  )  ;  if  (  isEscaping  (  )  )  {  sb  .  append  (  '  '  )  ;  sb  .  append  (   "Escape  =  < "  )  .  append  (  escape  )  .  append  (  '>'  )  ;  }  if  (  isEncapsulating  (  )  )  {  sb  .  append  (  '  '  )  ;  sb  .  append  (   "Encapsulator  =  < "  )  .  append  (  encapsulator  )  .  append  (  '>'  )  ;  }  if  (  isCommentingEnabled  (  )  )  {  sb  .  append  (  '  '  )  ;  sb  .  append  (   "CommentStart  =  < "  )  .  append  (  commentStart  )  .  append  (  '>'  )  ;  }  if  (  isEmptyLinesIgnored  (  )  )  {  sb  .  append  (   "  EmptyLines:ignored "  )  ;  }  if  (  isSurroundingSpacesIgnored  (  )  )  {  sb  .  append  (   "  SurroundingSpaces:ignored "  )  ;  }  [ATTENTION]  return  sb  .  StringBuilder  (  )    ;  }    [METHOD]  toString  [TYPE]  String  [PARAMETER]  [CLASS]  CSVFormat    [TYPE]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  [TYPE]  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  [TYPE]  boolean  emptyLinesIgnored  false  surroundingSpacesIgnored  true  [TYPE]  String  CRLF  lineSeparator  [TYPE]  String[]  header  values  [TYPE]  StringBuilder  sb  
[REPLACE]  private  static  final  int  INITIAL_TOKEN_LENGTH  =  50;	[BUGGY]  private  static  final  int  INITIAL_TOKEN_LENGTH    =  null  ;  [CE]  incompatible  types  [CONTEXT]      [CLASS]  Token  Type  
[REPLACE]  Token  .  Type  type  =  INVALID;	[BUGGY]  Token  .  Type  type  ;  [FE]  AssertionFailedError    Token  type  expected:<TOKEN>  but  was:<null>  assertTokenEquals(TOKEN  ,   "abc "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "def "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "hijk "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "lmnop "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "qrst "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "uv "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "wxy "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "z "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   " "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   " "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]      [CLASS]  Token  Type  
[REPLACE]  StringBuilder  content  =  new  StringBuilder  (  INITIAL_TOKEN_LENGTH  )  ;	[BUGGY]  StringBuilder  content  ;  [FE]  null  assertTokenEquals(TOKEN  ,   "abc "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "def "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "hijk "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "lmnop "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "qrst "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "uv "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "wxy "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "z "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   " "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   " "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]      [CLASS]  Token  Type  
[REPLACE]  content  .  setLength  (  0  )  ;	[BUGGY]  content  .  setLength  (  4  )  ;  [FE]  AssertionFailedError    Token  content  expected:<[]>  but  was:<[  assertTokenEquals(TOKEN  ,   "1 "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "2 "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "3 "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   " "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "b  x "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "c "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "d "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "e "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   " "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  Token  reset  (  )  {  [ATTENTION]  content  .  setLength  (  4  )    ;  type  =  INVALID  ;  isReady  =  false  ;  return  this  ;  }    [METHOD]  reset  [TYPE]  Token  [PARAMETER]  [CLASS]  Token  Type    [TYPE]  Type  EOF  EORECORD  INVALID  TOKEN  type  [TYPE]  boolean  false  isReady  true  [TYPE]  StringBuilder  content  [TYPE]  int  INITIAL_TOKEN_LENGTH  
[REPLACE]  type  =  INVALID;	[BUGGY]  type    =    type  ;  [FE]  null  assertEquals(CSVFormat.DISABLED  ,  format.getCommentStart())  ;  assertTrue(records.size()  >  0)  ;  assertTrue(CSVPrinterTest.equals(res  ,  records))  ;  assertTrue(CSVPrinterTest.equals(res_comments  ,  records))  ;  [CONTEXT]  Token  reset  (  )  {  content  .  setLength  (  0  )  ;  [ATTENTION]  type  =  type  ;  isReady  =  false  ;  return  this  ;  }    [METHOD]  reset  [TYPE]  Token  [PARAMETER]  [CLASS]  Token  Type    [TYPE]  Type  EOF  EORECORD  INVALID  TOKEN  type  [TYPE]  boolean  false  isReady  true  [TYPE]  StringBuilder  content  [TYPE]  int  INITIAL_TOKEN_LENGTH  
[ADD]  type  =  INVALID;	[BUGGY]  [FE]  null  assertEquals(CSVFormat.DISABLED  ,  format.getCommentStart())  ;  assertTrue(records.size()  >  0)  ;  assertTrue(CSVPrinterTest.equals(res  ,  records))  ;  assertTrue(CSVPrinterTest.equals(res_comments  ,  records))  ;  [CONTEXT]  Token  reset  (  )  {  content  .  setLength  (  0  )  ;  [ATTENTION]  isReady  =  false  ;  return  this  ;  }    [METHOD]  reset  [TYPE]  Token  [PARAMETER]  [CLASS]  Token  Type    [TYPE]  Type  EOF  EORECORD  INVALID  TOKEN  type  [TYPE]  boolean  false  isReady  true  [TYPE]  StringBuilder  content  [TYPE]  int  INITIAL_TOKEN_LENGTH  
[REPLACE]  isReady  =  false;	[BUGGY]  isReady  =  true  ;  [FE]  [CONTEXT]  Token  reset  (  )  {  content  .  setLength  (  0  )  ;  type  =  INVALID  ;  [ATTENTION]  isReady  =  true  ;  return  this  ;  }    [METHOD]  reset  [TYPE]  Token  [PARAMETER]  [CLASS]  Token  Type    [TYPE]  Type  EOF  EORECORD  INVALID  TOKEN  type  [TYPE]  boolean  false  isReady  true  [TYPE]  StringBuilder  content  [TYPE]  int  INITIAL_TOKEN_LENGTH  
[REPLACE]  return  this;	[BUGGY]  return  null  ;  [FE]  null  assertTokenEquals(TOKEN  ,   "1 "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "2 "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "3 "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   " "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "b  x "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "c "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "d "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "e "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   " "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  Token  reset  (  )  {  content  .  setLength  (  0  )  ;  type  =  INVALID  ;  isReady  =  false  ;  [ATTENTION]  return  null  ;  }    [METHOD]  reset  [TYPE]  Token  [PARAMETER]  [CLASS]  Token  Type    [TYPE]  Type  EOF  EORECORD  INVALID  TOKEN  type  [TYPE]  boolean  false  isReady  true  [TYPE]  StringBuilder  content  [TYPE]  int  INITIAL_TOKEN_LENGTH  
[REPLACE]  private  static  final  String[]  EMPTY_STRING_ARRAY  =  new  String[0];	[BUGGY]  private  static  final  String[]  EMPTY_STRING_ARRAY    =  null  ;  [FE]  null  assertTokenEquals(TOKEN  ,   "1 "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "2 "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "3 "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   " "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "b  x "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "c "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "d "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "e "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   " "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]      [CLASS]  CSVRecord  
[REPLACE]  this  .  values  =  values  !=  null  ?  values  :  EMPTY_STRING_ARRAY;	[BUGGY]  this  .  values    =    values  ;  [FE]  null  assertTokenEquals(TOKEN  ,   "1 "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "2 "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "3 "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   " "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "b  x "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "c "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "d "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "e "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   " "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  CSVRecord  (  String[]  values  ,  Map<String  ,  Integer>  mapping  )  {  [ATTENTION]  this  .  values  =  values  ;  this  .  mapping  =  mapping  ;  }    [METHOD]  <init>  [TYPE]  Map)  [PARAMETER]  String[]  values  Integer>  mapping  [CLASS]  CSVRecord    [TYPE]  Map  mapping  [TYPE]  String[]  EMPTY_STRING_ARRAY  values  [TYPE]  boolean  false  true  
[REPLACE]  this  .  mapping  =  mapping;	[BUGGY]  this  .  mapping  =    0  ;  [CE]  incompatible  types  [CONTEXT]  CSVRecord  (  String[]  values  ,  Map<String  ,  Integer>  mapping  )  {  this  .  values  =  values  !  =  null  ?  values  :  EMPTY_STRING_ARRAY  ;  [ATTENTION]  this  .  mapping  =  0  ;  }    [METHOD]  <init>  [TYPE]  Map)  [PARAMETER]  String[]  values  Integer>  mapping  [CLASS]  CSVRecord    [TYPE]  Map  mapping  [TYPE]  String[]  EMPTY_STRING_ARRAY  values  [TYPE]  boolean  false  true  
[ADD]  this  .  mapping  =  mapping;	[BUGGY]  [CE]  variable  mapping  might  not  have  been  initialized  [CONTEXT]  CSVRecord  (  String[]  values  ,  Map<String  ,  Integer>  mapping  )  {  this  .  values  =  values  !  =  null  ?  values  :  EMPTY_STRING_ARRAY  ;  [ATTENTION]  }    [METHOD]  <init>  [TYPE]  Map)  [PARAMETER]  String[]  values  Integer>  mapping  [CLASS]  CSVRecord    [TYPE]  Map  mapping  [TYPE]  String[]  EMPTY_STRING_ARRAY  values  [TYPE]  boolean  false  true  
[REPLACE]  return  values[i];	[BUGGY]  return  values  ;  [CE]  incompatible  types  [CONTEXT]  public  String  get  (  int  i  )  {  [ATTENTION]  return  values  ;  }    [METHOD]  get  [TYPE]  String  [PARAMETER]  int  i  [CLASS]  CSVRecord    [TYPE]  String[]  EMPTY_STRING_ARRAY  values  [TYPE]  boolean  false  true  [TYPE]  Map  mapping  [TYPE]  int  i  
[REPLACE]  if  (  mapping  ==  null  )  {	[BUGGY]  if  (  mapping  !  =  false  )  {[CE]  incomparable  types:  Map<String  ,  Integer>  and  boolean  [CONTEXT]  public  String  get  (  String  name  )  {  [ATTENTION]  if  (  mapping  !  =  false  )  {  throw  new  IllegalStateException  (   "No  header  was  specified  ,  the  record  values  can't  be  accessed  by  name "  )  ;  }  Integer  index  =  mapping  .  get  (  name  )  ;    return  index  !  =  null  ?  values[index  .  intValue  (  )  ]  :  null  ;  }    [METHOD]  get  [TYPE]  String  [PARAMETER]  String  name  [CLASS]  CSVRecord    [TYPE]  Integer  index  [TYPE]  String[]  EMPTY_STRING_ARRAY  values  [TYPE]  String  name  [TYPE]  boolean  false  true  [TYPE]  Map  mapping  
[REPLACE]  throw  new  IllegalStateException  ( "   ")  ;	[BUGGY]  return  ;  [CE]  missing  return  value  [CONTEXT]  public  String  get  (  String  name  )  {  if  (  mapping  =  =  null  )  {  [ATTENTION]  return  ;  }  Integer  index  =  mapping  .  get  (  name  )  ;    return  index  !  =  null  ?  values[index  .  intValue  (  )  ]  :  null  ;  }    [METHOD]  get  [TYPE]  String  [PARAMETER]  String  name  [CLASS]  CSVRecord    [TYPE]  Integer  index  [TYPE]  String[]  EMPTY_STRING_ARRAY  values  [TYPE]  String  name  [TYPE]  boolean  false  true  [TYPE]  Map  mapping  
[REPLACE]  Integer  index  =  mapping  .  get  (  name  )  ;	[BUGGY]  Integer  index  =  mapping  .  CSVRecord  (  values  ,  null  )    ;  [CE]  cannot  find  symbol  [CONTEXT]  public  String  get  (  String  name  )  {  if  (  mapping  =  =  null  )  {  throw  new  IllegalStateException  (   "No  header  was  specified  ,  the  record  values  can't  be  accessed  by  name "  )  ;  }  [ATTENTION]  Integer  index  =  mapping  .  CSVRecord  (  values  ,  null  )  ;    return  index  !  =  null  ?  values[index  .  intValue  (  )  ]  :  null  ;  }    [METHOD]  get  [TYPE]  String  [PARAMETER]  String  name  [CLASS]  CSVRecord    [TYPE]  Integer  index  [TYPE]  String[]  EMPTY_STRING_ARRAY  values  [TYPE]  String  name  [TYPE]  boolean  false  true  [TYPE]  Map  mapping  
[REPLACE]  return  index  !=  null  ?  values[index  .  intValue  (  )  ]  :  null;	[BUGGY]  return  index  ;  [CE]  incompatible  types  [CONTEXT]  public  String  get  (  String  name  )  {  if  (  mapping  =  =  null  )  {  throw  new  IllegalStateException  (   "No  header  was  specified  ,  the  record  values  can't  be  accessed  by  name "  )  ;  }  Integer  index  =  mapping  .  get  (  name  )  ;    [ATTENTION]  return  index  ;  }    [METHOD]  get  [TYPE]  String  [PARAMETER]  String  name  [CLASS]  CSVRecord    [TYPE]  Integer  index  [TYPE]  String[]  EMPTY_STRING_ARRAY  values  [TYPE]  String  name  [TYPE]  boolean  false  true  [TYPE]  Map  mapping  
[REPLACE]  return  Arrays  .  asList  (  values  )    .  iterator  (  )  ;	[BUGGY]  return  values[i]  ;  [CE]  cannot  find  symbol  i  [CONTEXT]  public  Iterator<String>  iterator  (  )  {  [ATTENTION]  return  values[i]  ;  }    [METHOD]  iterator  [TYPE]  Iterator  [PARAMETER]  [CLASS]  CSVRecord    [TYPE]  Map  mapping  [TYPE]  String[]  EMPTY_STRING_ARRAY  values  [TYPE]  boolean  false  true  
[REPLACE]  return  values;	[BUGGY]  return  values[i]  ;  [CE]  cannot  find  symbol  i  [CONTEXT]  String[]  values  (  )  {  [ATTENTION]  return  values[i]  ;  }    [METHOD]  values  [TYPE]  String[]  [PARAMETER]  [CLASS]  CSVRecord    [TYPE]  Map  mapping  [TYPE]  String[]  EMPTY_STRING_ARRAY  values  [TYPE]  boolean  false  true  
[REPLACE]  return  values  .  length;	[BUGGY]  return  values  ;  [CE]  incompatible  types  [CONTEXT]  public  int  size  (  )  {  [ATTENTION]  return  values  ;  }    [METHOD]  size  [TYPE]  int  [PARAMETER]  [CLASS]  CSVRecord    [TYPE]  Map  mapping  [TYPE]  String[]  EMPTY_STRING_ARRAY  values  [TYPE]  boolean  false  true  
[REPLACE]  return  Arrays  .  toString  (  values  )  ;	[BUGGY]  return  Arrays  .  asList  (  true  )    ;  [CE]  incompatible  types  [CONTEXT]  public  String  toString  (  )  {  [ATTENTION]  return  Arrays  .  asList  (  true  )  ;  }    [METHOD]  toString  [TYPE]  String  [PARAMETER]  [CLASS]  CSVRecord    [TYPE]  Map  mapping  [TYPE]  String[]  EMPTY_STRING_ARRAY  values  [TYPE]  boolean  false  true  
[REPLACE]  private  final  char  delimiter;	[BUGGY]  private  String  delimiter  ;  [CE]  incompatible  types  [CONTEXT]      [CLASS]  Lexer  
[REPLACE]  private  final  char  escape;	[BUGGY]  private  final  String  escape  ;  [CE]  incompatible  types  [CONTEXT]      [CLASS]  Lexer  
[REPLACE]  private  final  char  encapsulator;	[BUGGY]  private  String  encapsulator  ;  [CE]  incompatible  types  [CONTEXT]      [CLASS]  Lexer  
[REPLACE]  final  boolean  surroundingSpacesIgnored;	[BUGGY]  boolean  surroundingSpacesIgnored  ;  [FE]  null  assertTokenEquals(TOKEN  ,   "1 "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "2 "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "3 "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   " "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "b  x "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "c "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "d "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "e "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   " "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]      [CLASS]  Lexer  
[REPLACE]  final  CSVFormat  format;	[BUGGY]  CSVFormat  format  ;  [FE]  null  assertTokenEquals(TOKEN  ,   "1 "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "2 "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "3 "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   " "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "b  x "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "c "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "d "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "e "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   " "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]      [CLASS]  Lexer  
[REPLACE]  this  .  format  =  format;	[BUGGY]  this  .  format  =    null  ;  [FE]  null  assertTokenEquals(TOKEN  ,   "abc "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "def "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "hijk "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "lmnop "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "qrst "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "uv "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "wxy "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "z "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   " "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   " "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  Lexer  (  CSVFormat  format  ,  ExtendedBufferedReader  in  )  {  [ATTENTION]  this  .  format  =  null  ;  this  .  in  =  in  ;  this  .  isEncapsulating  =  format  .  isEncapsulating  (  )  ;  this  .  isEscaping  =  format  .  isEscaping  (  )  ;  this  .  isCommentEnabled  =  format  .  isCommentingEnabled  (  )  ;  this  .  delimiter  =  format  .  getDelimiter  (  )  ;  this  .  escape  =  format  .  getEscape  (  )  ;  this  .  encapsulator  =  format  .  getEncapsulator  (  )  ;  this  .  commmentStart  =  format  .  getCommentStart  (  )  ;  this  .  surroundingSpacesIgnored  =  format  .  isSurroundingSpacesIgnored  (  )  ;  this  .  emptyLinesIgnored  =  format  .  isEmptyLinesIgnored  (  )  ;  }    [METHOD]  <init>  [TYPE]  ExtendedBufferedReader)  [PARAMETER]  CSVFormat  format  ExtendedBufferedReader  in  [CLASS]  Lexer    [TYPE]  char  commmentStart  delimiter  encapsulator  escape  [TYPE]  ExtendedBufferedReader  in  [TYPE]  CSVFormat  format  [TYPE]  boolean  emptyLinesIgnored  false  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored  true  
[REPLACE]  this  .  in  =  in;	[BUGGY]  this  .  in  =    null  ;  [FE]  null  assertTokenEquals(TOKEN  ,   "abc "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "def "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "hijk "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "lmnop "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "qrst "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "uv "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "wxy "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "z "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   " "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   " "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  Lexer  (  CSVFormat  format  ,  ExtendedBufferedReader  in  )  {  this  .  format  =  format  ;  [ATTENTION]  this  .  in  =  null  ;  this  .  isEncapsulating  =  format  .  isEncapsulating  (  )  ;  this  .  isEscaping  =  format  .  isEscaping  (  )  ;  this  .  isCommentEnabled  =  format  .  isCommentingEnabled  (  )  ;  this  .  delimiter  =  format  .  getDelimiter  (  )  ;  this  .  escape  =  format  .  getEscape  (  )  ;  this  .  encapsulator  =  format  .  getEncapsulator  (  )  ;  this  .  commmentStart  =  format  .  getCommentStart  (  )  ;  this  .  surroundingSpacesIgnored  =  format  .  isSurroundingSpacesIgnored  (  )  ;  this  .  emptyLinesIgnored  =  format  .  isEmptyLinesIgnored  (  )  ;  }    [METHOD]  <init>  [TYPE]  ExtendedBufferedReader)  [PARAMETER]  CSVFormat  format  ExtendedBufferedReader  in  [CLASS]  Lexer    [TYPE]  char  commmentStart  delimiter  encapsulator  escape  [TYPE]  ExtendedBufferedReader  in  [TYPE]  CSVFormat  format  [TYPE]  boolean  emptyLinesIgnored  false  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored  true  
[REPLACE]  this  .  isEncapsulating  =  format  .  isEncapsulating  (  )  ;	[BUGGY]  this  .  encapsulator  =  format  .  getEncapsulator  (  )  ;    ;  [CE]  variable  encapsulator  might  already  have  been  assigned  [CONTEXT]  Lexer  (  CSVFormat  format  ,  ExtendedBufferedReader  in  )  {  this  .  format  =  format  ;  this  .  in  =  in  ;  [ATTENTION]  this  .  encapsulator  =  format  .  getEncapsulator  (  )    ;    ;  this  .  isEscaping  =  format  .  isEscaping  (  )  ;  this  .  isCommentEnabled  =  format  .  isCommentingEnabled  (  )  ;  this  .  delimiter  =  format  .  getDelimiter  (  )  ;  this  .  escape  =  format  .  getEscape  (  )  ;  this  .  encapsulator  =  format  .  getEncapsulator  (  )  ;  this  .  commmentStart  =  format  .  getCommentStart  (  )  ;  this  .  surroundingSpacesIgnored  =  format  .  isSurroundingSpacesIgnored  (  )  ;  this  .  emptyLinesIgnored  =  format  .  isEmptyLinesIgnored  (  )  ;  }    [METHOD]  <init>  [TYPE]  ExtendedBufferedReader)  [PARAMETER]  CSVFormat  format  ExtendedBufferedReader  in  [CLASS]  Lexer    [TYPE]  char  commmentStart  delimiter  encapsulator  escape  [TYPE]  ExtendedBufferedReader  in  [TYPE]  CSVFormat  format  [TYPE]  boolean  emptyLinesIgnored  false  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored  true  
[REPLACE]  this  .  isEscaping  =  format  .  isEscaping  (  )  ;	[BUGGY]  this  .  escape  =  format  .  getEscape  (  )  ;    ;  [CE]  variable  escape  might  already  have  been  assigned  [CONTEXT]  Lexer  (  CSVFormat  format  ,  ExtendedBufferedReader  in  )  {  this  .  format  =  format  ;  this  .  in  =  in  ;  this  .  isEncapsulating  =  format  .  isEncapsulating  (  )  ;  [ATTENTION]  this  .  escape  =  format  .  getEscape  (  )    ;    ;  this  .  isCommentEnabled  =  format  .  isCommentingEnabled  (  )  ;  this  .  delimiter  =  format  .  getDelimiter  (  )  ;  this  .  escape  =  format  .  getEscape  (  )  ;  this  .  encapsulator  =  format  .  getEncapsulator  (  )  ;  this  .  commmentStart  =  format  .  getCommentStart  (  )  ;  this  .  surroundingSpacesIgnored  =  format  .  isSurroundingSpacesIgnored  (  )  ;  this  .  emptyLinesIgnored  =  format  .  isEmptyLinesIgnored  (  )  ;  }    [METHOD]  <init>  [TYPE]  ExtendedBufferedReader)  [PARAMETER]  CSVFormat  format  ExtendedBufferedReader  in  [CLASS]  Lexer    [TYPE]  char  commmentStart  delimiter  encapsulator  escape  [TYPE]  ExtendedBufferedReader  in  [TYPE]  CSVFormat  format  [TYPE]  boolean  emptyLinesIgnored  false  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored  true  
[ADD]  this  .  isEscaping  =  format  .  isEscaping  (  )  ;  this  .  isCommentEnabled  =  format  .  isCommentingEnabled  (  )  ;  this  .  delimiter  =  format  .  getDelimiter  (  )  ;  this  .  escape  =  format  .  getEscape  (  )  ;  this  .  encapsulator  =  format  .  getEncapsulator  (  )  ;	[BUGGY]  [CE]  variable  isEscaping  might  not  have  been  initialized  [CONTEXT]  Lexer  (  CSVFormat  format  ,  ExtendedBufferedReader  in  )  {  this  .  format  =  format  ;  this  .  in  =  in  ;  this  .  isEncapsulating  =  format  .  isEncapsulating  (  )  ;  [ATTENTION]      this  .  commmentStart  =  format  .  getCommentStart  (  )  ;  this  .  surroundingSpacesIgnored  =  format  .  isSurroundingSpacesIgnored  (  )  ;  this  .  emptyLinesIgnored  =  format  .  isEmptyLinesIgnored  (  )  ;  }    [METHOD]  <init>  [TYPE]  ExtendedBufferedReader)  [PARAMETER]  CSVFormat  format  ExtendedBufferedReader  in  [CLASS]  Lexer    [TYPE]  char  commmentStart  delimiter  encapsulator  escape  [TYPE]  ExtendedBufferedReader  in  [TYPE]  CSVFormat  format  [TYPE]  boolean  emptyLinesIgnored  false  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored  true  
[REPLACE]  this  .  isCommentEnabled  =  format  .  isCommentingEnabled  (  )  ;	[BUGGY]  this  .  isCommentEnabled  =    null  .  isCommentingEnabled  (  )  ;  [CE]  <null>  cannot  be  dereferenced  [CONTEXT]  Lexer  (  CSVFormat  format  ,  ExtendedBufferedReader  in  )  {  this  .  format  =  format  ;  this  .  in  =  in  ;  this  .  isEncapsulating  =  format  .  isEncapsulating  (  )  ;  this  .  isEscaping  =  format  .  isEscaping  (  )  ;  [ATTENTION]  this  .  isCommentEnabled  =  null  .  isCommentingEnabled  (  )    ;  this  .  delimiter  =  format  .  getDelimiter  (  )  ;  this  .  escape  =  format  .  getEscape  (  )  ;  this  .  encapsulator  =  format  .  getEncapsulator  (  )  ;  this  .  commmentStart  =  format  .  getCommentStart  (  )  ;  this  .  surroundingSpacesIgnored  =  format  .  isSurroundingSpacesIgnored  (  )  ;  this  .  emptyLinesIgnored  =  format  .  isEmptyLinesIgnored  (  )  ;  }    [METHOD]  <init>  [TYPE]  ExtendedBufferedReader)  [PARAMETER]  CSVFormat  format  ExtendedBufferedReader  in  [CLASS]  Lexer    [TYPE]  char  commmentStart  delimiter  encapsulator  escape  [TYPE]  ExtendedBufferedReader  in  [TYPE]  CSVFormat  format  [TYPE]  boolean  emptyLinesIgnored  false  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored  true  
[REPLACE]  this  .  delimiter  =  format  .  getDelimiter  (  )  ;	[BUGGY]  this  .  delimiter  =    null  .  getDelimiter  (  )  ;  [CE]  <null>  cannot  be  dereferenced  [CONTEXT]  Lexer  (  CSVFormat  format  ,  ExtendedBufferedReader  in  )  {  this  .  format  =  format  ;  this  .  in  =  in  ;  this  .  isEncapsulating  =  format  .  isEncapsulating  (  )  ;  this  .  isEscaping  =  format  .  isEscaping  (  )  ;  this  .  isCommentEnabled  =  format  .  isCommentingEnabled  (  )  ;  [ATTENTION]  this  .  delimiter  =  null  .  getDelimiter  (  )    ;  this  .  escape  =  format  .  getEscape  (  )  ;  this  .  encapsulator  =  format  .  getEncapsulator  (  )  ;  this  .  commmentStart  =  format  .  getCommentStart  (  )  ;  this  .  surroundingSpacesIgnored  =  format  .  isSurroundingSpacesIgnored  (  )  ;  this  .  emptyLinesIgnored  =  format  .  isEmptyLinesIgnored  (  )  ;  }    [METHOD]  <init>  [TYPE]  ExtendedBufferedReader)  [PARAMETER]  CSVFormat  format  ExtendedBufferedReader  in  [CLASS]  Lexer    [TYPE]  char  commmentStart  delimiter  encapsulator  escape  [TYPE]  ExtendedBufferedReader  in  [TYPE]  CSVFormat  format  [TYPE]  boolean  emptyLinesIgnored  false  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored  true  
[REPLACE]  this  .  escape  =  format  .  getEscape  (  )  ;	[BUGGY]  this  .  isEscaping  =  format  .  isEscaping  (  )  ;    ;  [CE]  variable  isEscaping  might  already  have  been  assigned  [CONTEXT]  Lexer  (  CSVFormat  format  ,  ExtendedBufferedReader  in  )  {  this  .  format  =  format  ;  this  .  in  =  in  ;  this  .  isEncapsulating  =  format  .  isEncapsulating  (  )  ;  this  .  isEscaping  =  format  .  isEscaping  (  )  ;  this  .  isCommentEnabled  =  format  .  isCommentingEnabled  (  )  ;  this  .  delimiter  =  format  .  getDelimiter  (  )  ;  [ATTENTION]  this  .  isEscaping  =  format  .  isEscaping  (  )    ;    ;  this  .  encapsulator  =  format  .  getEncapsulator  (  )  ;  this  .  commmentStart  =  format  .  getCommentStart  (  )  ;  this  .  surroundingSpacesIgnored  =  format  .  isSurroundingSpacesIgnored  (  )  ;  this  .  emptyLinesIgnored  =  format  .  isEmptyLinesIgnored  (  )  ;  }    [METHOD]  <init>  [TYPE]  ExtendedBufferedReader)  [PARAMETER]  CSVFormat  format  ExtendedBufferedReader  in  [CLASS]  Lexer    [TYPE]  char  commmentStart  delimiter  encapsulator  escape  [TYPE]  ExtendedBufferedReader  in  [TYPE]  CSVFormat  format  [TYPE]  boolean  emptyLinesIgnored  false  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored  true  
[ADD]  this  .  escape  =  format  .  getEscape  (  )  ;  this  .  encapsulator  =  format  .  getEncapsulator  (  )  ;  this  .  commmentStart  =  format  .  getCommentStart  (  )  ;  this  .  surroundingSpacesIgnored  =  format  .  isSurroundingSpacesIgnored  (  )  ;  this  .  emptyLinesIgnored  =  format  .  isEmptyLinesIgnored  (  )  ;	[BUGGY]  [CE]  variable  escape  might  not  have  been  initialized  [CONTEXT]  Lexer  (  CSVFormat  format  ,  ExtendedBufferedReader  in  )  {  this  .  format  =  format  ;  this  .  in  =  in  ;  this  .  isEncapsulating  =  format  .  isEncapsulating  (  )  ;  this  .  isEscaping  =  format  .  isEscaping  (  )  ;  this  .  isCommentEnabled  =  format  .  isCommentingEnabled  (  )  ;  this  .  delimiter  =  format  .  getDelimiter  (  )  ;  [ATTENTION]      }    [METHOD]  <init>  [TYPE]  ExtendedBufferedReader)  [PARAMETER]  CSVFormat  format  ExtendedBufferedReader  in  [CLASS]  Lexer    [TYPE]  char  commmentStart  delimiter  encapsulator  escape  [TYPE]  ExtendedBufferedReader  in  [TYPE]  CSVFormat  format  [TYPE]  boolean  emptyLinesIgnored  false  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored  true  
[REPLACE]  this  .  encapsulator  =  format  .  getEncapsulator  (  )  ;	[BUGGY]  this  .  isEncapsulating  =  format  .  isEncapsulating  (  )  ;    ;  [CE]  variable  isEncapsulating  might  already  have  been  assigned  [CONTEXT]  Lexer  (  CSVFormat  format  ,  ExtendedBufferedReader  in  )  {  this  .  format  =  format  ;  this  .  in  =  in  ;  this  .  isEncapsulating  =  format  .  isEncapsulating  (  )  ;  this  .  isEscaping  =  format  .  isEscaping  (  )  ;  this  .  isCommentEnabled  =  format  .  isCommentingEnabled  (  )  ;  this  .  delimiter  =  format  .  getDelimiter  (  )  ;  this  .  escape  =  format  .  getEscape  (  )  ;  [ATTENTION]  this  .  isEncapsulating  =  format  .  isEncapsulating  (  )    ;    ;  this  .  commmentStart  =  format  .  getCommentStart  (  )  ;  this  .  surroundingSpacesIgnored  =  format  .  isSurroundingSpacesIgnored  (  )  ;  this  .  emptyLinesIgnored  =  format  .  isEmptyLinesIgnored  (  )  ;  }    [METHOD]  <init>  [TYPE]  ExtendedBufferedReader)  [PARAMETER]  CSVFormat  format  ExtendedBufferedReader  in  [CLASS]  Lexer    [TYPE]  char  commmentStart  delimiter  encapsulator  escape  [TYPE]  ExtendedBufferedReader  in  [TYPE]  CSVFormat  format  [TYPE]  boolean  emptyLinesIgnored  false  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored  true  
[REPLACE]  this  .  commmentStart  =  format  .  getCommentStart  (  )  ;	[BUGGY]  this  .  commmentStart  =    null  .  getCommentStart  (  )  ;  [CE]  <null>  cannot  be  dereferenced  [CONTEXT]  Lexer  (  CSVFormat  format  ,  ExtendedBufferedReader  in  )  {  this  .  format  =  format  ;  this  .  in  =  in  ;  this  .  isEncapsulating  =  format  .  isEncapsulating  (  )  ;  this  .  isEscaping  =  format  .  isEscaping  (  )  ;  this  .  isCommentEnabled  =  format  .  isCommentingEnabled  (  )  ;  this  .  delimiter  =  format  .  getDelimiter  (  )  ;  this  .  escape  =  format  .  getEscape  (  )  ;  this  .  encapsulator  =  format  .  getEncapsulator  (  )  ;  [ATTENTION]  this  .  commmentStart  =  null  .  getCommentStart  (  )    ;  this  .  surroundingSpacesIgnored  =  format  .  isSurroundingSpacesIgnored  (  )  ;  this  .  emptyLinesIgnored  =  format  .  isEmptyLinesIgnored  (  )  ;  }    [METHOD]  <init>  [TYPE]  ExtendedBufferedReader)  [PARAMETER]  CSVFormat  format  ExtendedBufferedReader  in  [CLASS]  Lexer    [TYPE]  char  commmentStart  delimiter  encapsulator  escape  [TYPE]  ExtendedBufferedReader  in  [TYPE]  CSVFormat  format  [TYPE]  boolean  emptyLinesIgnored  false  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored  true  
[ADD]  this  .  commmentStart  =  format  .  getCommentStart  (  )  ;  this  .  surroundingSpacesIgnored  =  format  .  isSurroundingSpacesIgnored  (  )  ;  this  .  emptyLinesIgnored  =  format  .  isEmptyLinesIgnored  (  )  ;  }	[BUGGY]  [CE]  '  ;  '  expected  [CONTEXT]  Lexer  (  CSVFormat  format  ,  ExtendedBufferedReader  in  )  {  this  .  format  =  format  ;  this  .  in  =  in  ;  this  .  isEncapsulating  =  format  .  isEncapsulating  (  )  ;  this  .  isEscaping  =  format  .  isEscaping  (  )  ;  this  .  isCommentEnabled  =  format  .  isCommentingEnabled  (  )  ;  this  .  delimiter  =  format  .  getDelimiter  (  )  ;  this  .  escape  =  format  .  getEscape  (  )  ;  this  .  encapsulator  =  format  .  getEncapsulator  (  )  ;  [ATTENTION]        [METHOD]  <init>  [TYPE]  ExtendedBufferedReader)  [PARAMETER]  CSVFormat  format  ExtendedBufferedReader  in  [CLASS]  Lexer    [TYPE]  char  commmentStart  delimiter  encapsulator  escape  [TYPE]  ExtendedBufferedReader  in  [TYPE]  CSVFormat  format  [TYPE]  boolean  emptyLinesIgnored  false  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored  true  
[REPLACE]  this  .  surroundingSpacesIgnored  =  format  .  isSurroundingSpacesIgnored  (  )  ;	[BUGGY]  this  .  surroundingSpacesIgnored  =    null  .  isSurroundingSpacesIgnored  (  )  ;  [CE]  <null>  cannot  be  dereferenced  [CONTEXT]  Lexer  (  CSVFormat  format  ,  ExtendedBufferedReader  in  )  {  this  .  format  =  format  ;  this  .  in  =  in  ;  this  .  isEncapsulating  =  format  .  isEncapsulating  (  )  ;  this  .  isEscaping  =  format  .  isEscaping  (  )  ;  this  .  isCommentEnabled  =  format  .  isCommentingEnabled  (  )  ;  this  .  delimiter  =  format  .  getDelimiter  (  )  ;  this  .  escape  =  format  .  getEscape  (  )  ;  this  .  encapsulator  =  format  .  getEncapsulator  (  )  ;  this  .  commmentStart  =  format  .  getCommentStart  (  )  ;  [ATTENTION]  this  .  surroundingSpacesIgnored  =  null  .  isSurroundingSpacesIgnored  (  )    ;  this  .  emptyLinesIgnored  =  format  .  isEmptyLinesIgnored  (  )  ;  }    [METHOD]  <init>  [TYPE]  ExtendedBufferedReader)  [PARAMETER]  CSVFormat  format  ExtendedBufferedReader  in  [CLASS]  Lexer    [TYPE]  char  commmentStart  delimiter  encapsulator  escape  [TYPE]  ExtendedBufferedReader  in  [TYPE]  CSVFormat  format  [TYPE]  boolean  emptyLinesIgnored  false  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored  true  
[ADD]  this  .  surroundingSpacesIgnored  =  format  .  isSurroundingSpacesIgnored  (  )  ;  this  .  emptyLinesIgnored  =  format  .  isEmptyLinesIgnored  (  )  ;  }	[BUGGY]  [CE]  '  ;  '  expected  [CONTEXT]  Lexer  (  CSVFormat  format  ,  ExtendedBufferedReader  in  )  {  this  .  format  =  format  ;  this  .  in  =  in  ;  this  .  isEncapsulating  =  format  .  isEncapsulating  (  )  ;  this  .  isEscaping  =  format  .  isEscaping  (  )  ;  this  .  isCommentEnabled  =  format  .  isCommentingEnabled  (  )  ;  this  .  delimiter  =  format  .  getDelimiter  (  )  ;  this  .  escape  =  format  .  getEscape  (  )  ;  this  .  encapsulator  =  format  .  getEncapsulator  (  )  ;  this  .  commmentStart  =  format  .  getCommentStart  (  )  ;  [ATTENTION]        [METHOD]  <init>  [TYPE]  ExtendedBufferedReader)  [PARAMETER]  CSVFormat  format  ExtendedBufferedReader  in  [CLASS]  Lexer    [TYPE]  char  commmentStart  delimiter  encapsulator  escape  [TYPE]  ExtendedBufferedReader  in  [TYPE]  CSVFormat  format  [TYPE]  boolean  emptyLinesIgnored  false  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored  true  
[REPLACE]  this  .  emptyLinesIgnored  =  format  .  isEmptyLinesIgnored  (  )  ;	[BUGGY]  this  .  emptyLinesIgnored  =    null  .  isEmptyLinesIgnored  (  )  ;  [CE]  <null>  cannot  be  dereferenced  [CONTEXT]  Lexer  (  CSVFormat  format  ,  ExtendedBufferedReader  in  )  {  this  .  format  =  format  ;  this  .  in  =  in  ;  this  .  isEncapsulating  =  format  .  isEncapsulating  (  )  ;  this  .  isEscaping  =  format  .  isEscaping  (  )  ;  this  .  isCommentEnabled  =  format  .  isCommentingEnabled  (  )  ;  this  .  delimiter  =  format  .  getDelimiter  (  )  ;  this  .  escape  =  format  .  getEscape  (  )  ;  this  .  encapsulator  =  format  .  getEncapsulator  (  )  ;  this  .  commmentStart  =  format  .  getCommentStart  (  )  ;  this  .  surroundingSpacesIgnored  =  format  .  isSurroundingSpacesIgnored  (  )  ;  [ATTENTION]  this  .  emptyLinesIgnored  =  null  .  isEmptyLinesIgnored  (  )    ;  }    [METHOD]  <init>  [TYPE]  ExtendedBufferedReader)  [PARAMETER]  CSVFormat  format  ExtendedBufferedReader  in  [CLASS]  Lexer    [TYPE]  char  commmentStart  delimiter  encapsulator  escape  [TYPE]  ExtendedBufferedReader  in  [TYPE]  CSVFormat  format  [TYPE]  boolean  emptyLinesIgnored  false  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored  true  
[REPLACE]  return  in  .  getLineNumber  (  )  ;	[BUGGY]  return  in  .  read  (  )    ;  [CE]  unreported  exception  IOException  ;  must  be  caught  or  declared  to  be  thrown  [CONTEXT]  int  getLineNumber  (  )  {  [ATTENTION]  return  in  .  read  (  )  ;  }    [METHOD]  getLineNumber  [TYPE]  int  [PARAMETER]  [CLASS]  Lexer    [TYPE]  char  commmentStart  delimiter  encapsulator  escape  [TYPE]  ExtendedBufferedReader  in  [TYPE]  CSVFormat  format  [TYPE]  boolean  emptyLinesIgnored  false  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored  true  
[REPLACE]  c  =  in  .  read  (  )  ;	[BUGGY]  c    =    c  ;  [FE]  null  assertTokenEquals(TOKEN  ,   "1 "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "2 "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "3 "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   " "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "b  x "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "c "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "d "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "e "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   " "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  int  readEscape  (  int  c  )  throws  IOException  {    [ATTENTION]  c  =  c  ;  switch  (  c  )  {  case  'r':  return  '\r'  ;  case  'n':  return  '\n'  ;  case  't':  return  '\t'  ;  case  'b':  return  '\b'  ;  case  'f':  return  '\f'  ;  default:  return  c  ;  }  }    [METHOD]  readEscape  [TYPE]  int  [PARAMETER]  int  c  [CLASS]  Lexer    [TYPE]  char  commmentStart  delimiter  encapsulator  escape  [TYPE]  ExtendedBufferedReader  in  [TYPE]  CSVFormat  format  [TYPE]  boolean  emptyLinesIgnored  false  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored  true  [TYPE]  int  c  
[ADD]  c  =  in  .  read  (  )  ;	[BUGGY]  [FE]  null  assertTokenEquals(TOKEN  ,   "1 "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "2 "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "3 "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   " "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "b  x "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "c "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "d "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "e "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   " "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  int  readEscape  (  int  c  )  throws  IOException  {    [ATTENTION]  switch  (  c  )  {  case  'r':  return  '\r'  ;  case  'n':  return  '\n'  ;  case  't':  return  '\t'  ;  case  'b':  return  '\b'  ;  case  'f':  return  '\f'  ;  default:  return  c  ;  }  }    [METHOD]  readEscape  [TYPE]  int  [PARAMETER]  int  c  [CLASS]  Lexer    [TYPE]  char  commmentStart  delimiter  encapsulator  escape  [TYPE]  ExtendedBufferedReader  in  [TYPE]  CSVFormat  format  [TYPE]  boolean  emptyLinesIgnored  false  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored  true  [TYPE]  int  c  
[REPLACE]  return  '\r';	[BUGGY]  return  '\t'  ;  [FE]  null  assertTokenEquals(TOKEN  ,   "1 "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "2 "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "3 "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   " "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "b  x "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "c "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "d "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "e "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   " "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  int  readEscape  (  int  c  )  throws  IOException  {    c  =  in  .  read  (  )  ;  switch  (  c  )  {  case  'r':  [ATTENTION]  return  '\t'  ;  case  'n':  return  '\n'  ;  case  't':  return  '\t'  ;  case  'b':  return  '\b'  ;  case  'f':  return  '\f'  ;  default:  return  c  ;  }  }    [METHOD]  readEscape  [TYPE]  int  [PARAMETER]  int  c  [CLASS]  Lexer    [TYPE]  char  commmentStart  delimiter  encapsulator  escape  [TYPE]  ExtendedBufferedReader  in  [TYPE]  CSVFormat  format  [TYPE]  boolean  emptyLinesIgnored  false  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored  true  [TYPE]  int  c  
[REPLACE]  return  '\n';	[BUGGY]  return  '\t'  ;  [FE]  null  assertTokenEquals(TOKEN  ,   "1 "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "2 "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "3 "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   " "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "b  x "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "c "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "d "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "e "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   " "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  int  readEscape  (  int  c  )  throws  IOException  {    c  =  in  .  read  (  )  ;  switch  (  c  )  {  case  'r':  return  '\r'  ;  case  'n':  [ATTENTION]  return  '\t'  ;  case  't':  return  '\t'  ;  case  'b':  return  '\b'  ;  case  'f':  return  '\f'  ;  default:  return  c  ;  }  }    [METHOD]  readEscape  [TYPE]  int  [PARAMETER]  int  c  [CLASS]  Lexer    [TYPE]  char  commmentStart  delimiter  encapsulator  escape  [TYPE]  ExtendedBufferedReader  in  [TYPE]  CSVFormat  format  [TYPE]  boolean  emptyLinesIgnored  false  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored  true  [TYPE]  int  c  
[REPLACE]  return  '\t';	[BUGGY]  return  '\r'  ;  [FE]  null  assertTokenEquals(TOKEN  ,   "1 "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "2 "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "3 "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   " "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "b  x "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "c "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "d "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "e "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   " "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  int  readEscape  (  int  c  )  throws  IOException  {    c  =  in  .  read  (  )  ;  switch  (  c  )  {  case  'r':  return  '\r'  ;  case  'n':  return  '\n'  ;  case  't':  [ATTENTION]  return  '\r'  ;  case  'b':  return  '\b'  ;  case  'f':  return  '\f'  ;  default:  return  c  ;  }  }    [METHOD]  readEscape  [TYPE]  int  [PARAMETER]  int  c  [CLASS]  Lexer    [TYPE]  char  commmentStart  delimiter  encapsulator  escape  [TYPE]  ExtendedBufferedReader  in  [TYPE]  CSVFormat  format  [TYPE]  boolean  emptyLinesIgnored  false  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored  true  [TYPE]  int  c  
[REPLACE]  return  '\b';	[BUGGY]  return  '\t'  ;  [FE]  null  assertTokenEquals(TOKEN  ,   "1 "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "2 "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "3 "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   " "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "b  x "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "c "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "d "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "e "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   " "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  int  readEscape  (  int  c  )  throws  IOException  {    c  =  in  .  read  (  )  ;  switch  (  c  )  {  case  'r':  return  '\r'  ;  case  'n':  return  '\n'  ;  case  't':  return  '\t'  ;  case  'b':  [ATTENTION]  return  '\t'  ;  case  'f':  return  '\f'  ;  default:  return  c  ;  }  }    [METHOD]  readEscape  [TYPE]  int  [PARAMETER]  int  c  [CLASS]  Lexer    [TYPE]  char  commmentStart  delimiter  encapsulator  escape  [TYPE]  ExtendedBufferedReader  in  [TYPE]  CSVFormat  format  [TYPE]  boolean  emptyLinesIgnored  false  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored  true  [TYPE]  int  c  
[REPLACE]  return  '\f';	[BUGGY]  return  '\t'  ;  [FE]  null  assertTokenEquals(TOKEN  ,   "1 "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "2 "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "3 "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   " "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "b  x "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "c "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "d "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "e "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   " "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  int  readEscape  (  int  c  )  throws  IOException  {    c  =  in  .  read  (  )  ;  switch  (  c  )  {  case  'r':  return  '\r'  ;  case  'n':  return  '\n'  ;  case  't':  return  '\t'  ;  case  'b':  return  '\b'  ;  case  'f':  [ATTENTION]  return  '\t'  ;  default:  return  c  ;  }  }    [METHOD]  readEscape  [TYPE]  int  [PARAMETER]  int  c  [CLASS]  Lexer    [TYPE]  char  commmentStart  delimiter  encapsulator  escape  [TYPE]  ExtendedBufferedReader  in  [TYPE]  CSVFormat  format  [TYPE]  boolean  emptyLinesIgnored  false  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored  true  [TYPE]  int  c  
[REPLACE]  return  c;	[BUGGY]  return  '\t'  ;  [FE]  null  assertTokenEquals(TOKEN  ,   "1 "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "2 "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "3 "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   " "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "b  x "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "c "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "d "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "e "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   " "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  int  readEscape  (  int  c  )  throws  IOException  {    c  =  in  .  read  (  )  ;  switch  (  c  )  {  case  'r':  return  '\r'  ;  case  'n':  return  '\n'  ;  case  't':  return  '\t'  ;  case  'b':  return  '\b'  ;  case  'f':  return  '\f'  ;  default:  [ATTENTION]  return  '\t'  ;  }  }    [METHOD]  readEscape  [TYPE]  int  [PARAMETER]  int  c  [CLASS]  Lexer    [TYPE]  char  commmentStart  delimiter  encapsulator  escape  [TYPE]  ExtendedBufferedReader  in  [TYPE]  CSVFormat  format  [TYPE]  boolean  emptyLinesIgnored  false  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored  true  [TYPE]  int  c  
[REPLACE]  int  length  =  buffer  .  length  (  )  ;	[BUGGY]  int  length  =  buffer  .  setLength  (  length  )    ;  [CE]  incompatible  types  [CONTEXT]  void  trimTrailingSpaces  (  StringBuilder  buffer  )  {  [ATTENTION]  int  length  =  buffer  .  setLength  (  length  )  ;  while  (  length  >  0  &&  Character  .  isWhitespace  (  buffer  .  charAt  (  length  -  1  )  )  )  {  length  =  length  -  1  ;  }  if  (  length  !  =  buffer  .  length  (  )  )  {  buffer  .  setLength  (  length  )  ;  }  }    [METHOD]  trimTrailingSpaces  [TYPE]  void  [PARAMETER]  StringBuilder  buffer  [CLASS]  Lexer    [TYPE]  char  commmentStart  delimiter  encapsulator  escape  [TYPE]  ExtendedBufferedReader  in  [TYPE]  CSVFormat  format  [TYPE]  boolean  emptyLinesIgnored  false  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored  true  [TYPE]  StringBuilder  buffer  [TYPE]  int  length  
[REPLACE]  while  (  length  >  0  &&  Character  .  isWhitespace  (  buffer  .  charAt  (  length  -  1  )  )  )  {	[BUGGY]  while  (  length  +  3  >  0  &&  Character  .  isWhitespace  (  buffer  .  charAt  (  length  +  3  -  1  )  )  )  {[FE]  String  index  out  of  range:  5  assertTokenEquals(TOKEN  ,   "abc "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "def "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "hijk "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "lmnop "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "qrst "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "uv "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "wxy "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "z "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   " "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   " "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  void  trimTrailingSpaces  (  StringBuilder  buffer  )  {  int  length  =  buffer  .  length  (  )  ;  [ATTENTION]  while  (  length  +  3  >  0&&  Character  .  isWhitespace  (  buffer  .  charAt  (  length  +  3  -  1  )  )  )  {  length  =  length  -  1  ;  }  if  (  length  !  =  buffer  .  length  (  )  )  {  buffer  .  setLength  (  length  )  ;  }  }    [METHOD]  trimTrailingSpaces  [TYPE]  void  [PARAMETER]  StringBuilder  buffer  [CLASS]  Lexer    [TYPE]  char  commmentStart  delimiter  encapsulator  escape  [TYPE]  ExtendedBufferedReader  in  [TYPE]  CSVFormat  format  [TYPE]  boolean  emptyLinesIgnored  false  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored  true  [TYPE]  StringBuilder  buffer  [TYPE]  int  length  
[REPLACE]  length  =  length  -  1;	[BUGGY]  length  +  5  =  length  +  5  -  0  ;  [CE]  unexpected  type  [CONTEXT]  void  trimTrailingSpaces  (  StringBuilder  buffer  )  {  int  length  =  buffer  .  length  (  )  ;  while  (  length  >  0  &&  Character  .  isWhitespace  (  buffer  .  charAt  (  length  -  1  )  )  )  {  [ATTENTION]  length  +  5  =  length  +  5  -  0  ;  }  if  (  length  !  =  buffer  .  length  (  )  )  {  buffer  .  setLength  (  length  )  ;  }  }    [METHOD]  trimTrailingSpaces  [TYPE]  void  [PARAMETER]  StringBuilder  buffer  [CLASS]  Lexer    [TYPE]  char  commmentStart  delimiter  encapsulator  escape  [TYPE]  ExtendedBufferedReader  in  [TYPE]  CSVFormat  format  [TYPE]  boolean  emptyLinesIgnored  false  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored  true  [TYPE]  StringBuilder  buffer  [TYPE]  int  length  
[REPLACE]  length  =  length  -  1;	[BUGGY]  length  %  0  .  5    =  length  %  0  .  5  -  1  ;  [CE]  unexpected  type  [CONTEXT]  void  trimTrailingSpaces  (  StringBuilder  buffer  )  {  int  length  =  buffer  .  length  (  )  ;  while  (  length  >  0  &&  Character  .  isWhitespace  (  buffer  .  charAt  (  length  -  1  )  )  )  {  [ATTENTION]  length  %0  .  5  =  length  %0  .  5-  1  ;  }  if  (  length  !  =  buffer  .  length  (  )  )  {  buffer  .  setLength  (  length  )  ;  }  }    [METHOD]  trimTrailingSpaces  [TYPE]  void  [PARAMETER]  StringBuilder  buffer  [CLASS]  Lexer    [TYPE]  char  commmentStart  delimiter  encapsulator  escape  [TYPE]  ExtendedBufferedReader  in  [TYPE]  CSVFormat  format  [TYPE]  boolean  emptyLinesIgnored  false  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored  true  [TYPE]  StringBuilder  buffer  [TYPE]  int  length  
[REPLACE]  if  (  length  !=  buffer  .  length  (  )  )  {	[BUGGY]  if  (  length  !  =  buffer  .  length  (  )  *  2  )  {[FE]  null  assertTokenEquals(TOKEN  ,   "1 "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "2 "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "3 "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   " "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "b  x "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "c "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "d "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "e "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   " "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  void  trimTrailingSpaces  (  StringBuilder  buffer  )  {  int  length  =  buffer  .  length  (  )  ;  while  (  length  >  0  &&  Character  .  isWhitespace  (  buffer  .  charAt  (  length  -  1  )  )  )  {  length  =  length  -  1  ;  }  [ATTENTION]  if  (  length  !  =  buffer  .  length  (  )  *2  )  {  buffer  .  setLength  (  length  )  ;  }  }    [METHOD]  trimTrailingSpaces  [TYPE]  void  [PARAMETER]  StringBuilder  buffer  [CLASS]  Lexer    [TYPE]  char  commmentStart  delimiter  encapsulator  escape  [TYPE]  ExtendedBufferedReader  in  [TYPE]  CSVFormat  format  [TYPE]  boolean  emptyLinesIgnored  false  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored  true  [TYPE]  StringBuilder  buffer  [TYPE]  int  length  
[REPLACE]  buffer  .  setLength  (  length  )  ;	[BUGGY]  buffer  .  charAt  (  length  )  ;  [FE]  AssertionFailedError    Token  content  expected:<uv[]>  but  was:<uv[  ]>  assertTokenEquals(TOKEN  ,   "abc "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "def "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "hijk "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "lmnop "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "qrst "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "uv "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "wxy "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "z "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   " "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   " "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  void  trimTrailingSpaces  (  StringBuilder  buffer  )  {  int  length  =  buffer  .  length  (  )  ;  while  (  length  >  0  &&  Character  .  isWhitespace  (  buffer  .  charAt  (  length  -  1  )  )  )  {  length  =  length  -  1  ;  }  if  (  length  !  =  buffer  .  length  (  )  )  {  [ATTENTION]  buffer  .  charAt  (  length  )    ;  }  }    [METHOD]  trimTrailingSpaces  [TYPE]  void  [PARAMETER]  StringBuilder  buffer  [CLASS]  Lexer    [TYPE]  char  commmentStart  delimiter  encapsulator  escape  [TYPE]  ExtendedBufferedReader  in  [TYPE]  CSVFormat  format  [TYPE]  boolean  emptyLinesIgnored  false  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored  true  [TYPE]  StringBuilder  buffer  [TYPE]  int  length  
[REPLACE]  return  (  c  !=  format  .  getDelimiter  (  )  )  &&  Character  .  isWhitespace  (  (  char  )  c  )  ;	[BUGGY]  return  (  c  !  =  format  .  getDelimiter  (  )  )    ;  ;  [CE]  unreachable  statement  [CONTEXT]  boolean  isWhitespace  (  int  c  )  {  [ATTENTION]  return  (  c  !  =  format  .  getDelimiter  (  )  )  ;  ;  }    [METHOD]  isWhitespace  [TYPE]  boolean  [PARAMETER]  int  c  [CLASS]  Lexer    [TYPE]  char  commmentStart  delimiter  encapsulator  escape  [TYPE]  ExtendedBufferedReader  in  [TYPE]  CSVFormat  format  [TYPE]  boolean  emptyLinesIgnored  false  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored  true  [TYPE]  int  c  
[REPLACE]  if  (  c  ==  '\r'  &&  in  .  lookAhead  (  )  ==  '\n'  )  {	[BUGGY]  if  (  c  =  =  '\r'  )  {[FE]  null  assertTokenEquals(TOKEN  ,   "1 "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "2 "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "3 "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   " "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "b  x "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "c "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "d "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "e "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   " "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  boolean  isEndOfLine  (  int  c  )  throws  IOException  {    [ATTENTION]  if  (  c  =  =  '\r'  )  {    c  =  in  .  read  (  )  ;  }  return  (  c  =  =  '\n'  ||  c  =  =  '\r'  )  ;  }    [METHOD]  isEndOfLine  [TYPE]  boolean  [PARAMETER]  int  c  [CLASS]  Lexer    [TYPE]  char  commmentStart  delimiter  encapsulator  escape  [TYPE]  ExtendedBufferedReader  in  [TYPE]  CSVFormat  format  [TYPE]  boolean  emptyLinesIgnored  false  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored  true  [TYPE]  int  c  
[REPLACE]  c  =  in  .  read  (  )  ;	[BUGGY]  c    =    c  ;  [FE]  null  assertTokenEquals(TOKEN  ,   "1 "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "2 "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "3 "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   " "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "b  x "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "c "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "d "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "e "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   " "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  boolean  isEndOfLine  (  int  c  )  throws  IOException  {    if  (  c  =  =  '\r'  &&  in  .  lookAhead  (  )    =  =  '\n'  )  {    [ATTENTION]  c  =  c  ;  }  return  (  c  =  =  '\n'  ||  c  =  =  '\r'  )  ;  }    [METHOD]  isEndOfLine  [TYPE]  boolean  [PARAMETER]  int  c  [CLASS]  Lexer    [TYPE]  char  commmentStart  delimiter  encapsulator  escape  [TYPE]  ExtendedBufferedReader  in  [TYPE]  CSVFormat  format  [TYPE]  boolean  emptyLinesIgnored  false  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored  true  [TYPE]  int  c  
[REPLACE]  c  =  in  .  read  (  )  ;	[BUGGY]  c  ;  [CE]  not  a  statement  [CONTEXT]  boolean  isEndOfLine  (  int  c  )  throws  IOException  {    if  (  c  =  =  '\r'  &&  in  .  lookAhead  (  )    =  =  '\n'  )  {    [ATTENTION]  c  ;  }  return  (  c  =  =  '\n'  ||  c  =  =  '\r'  )  ;  }    [METHOD]  isEndOfLine  [TYPE]  boolean  [PARAMETER]  int  c  [CLASS]  Lexer    [TYPE]  char  commmentStart  delimiter  encapsulator  escape  [TYPE]  ExtendedBufferedReader  in  [TYPE]  CSVFormat  format  [TYPE]  boolean  emptyLinesIgnored  false  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored  true  [TYPE]  int  c  
[REPLACE]  return  (  c  ==  '\n'  ||  c  ==  '\r'  )  ;	[BUGGY]  return  (  c  ;  [CE]  ')'  expected  [CONTEXT]  boolean  isEndOfLine  (  int  c  )  throws  IOException  {    if  (  c  =  =  '\r'  &&  in  .  lookAhead  (  )    =  =  '\n'  )  {    c  =  in  .  read  (  )  ;  }  [ATTENTION]  return  (  c  ;  }    [METHOD]  isEndOfLine  [TYPE]  boolean  [PARAMETER]  int  c  [CLASS]  Lexer    [TYPE]  char  commmentStart  delimiter  encapsulator  escape  [TYPE]  ExtendedBufferedReader  in  [TYPE]  CSVFormat  format  [TYPE]  boolean  emptyLinesIgnored  false  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored  true  [TYPE]  int  c  
[REPLACE]  return  c  ==  ExtendedBufferedReader  .  END_OF_STREAM;	[BUGGY]  return  true  ;  [FE]  AssertionFailedError    Token  type  expected:<TOKEN>  but  was:<EOF>  assertTokenEquals(TOKEN  ,   "abc "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "def "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "hijk "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "lmnop "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "qrst "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "uv "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "wxy "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "z "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   " "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   " "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  boolean  isEndOfFile  (  int  c  )  {  [ATTENTION]  return  true  ;  }    [METHOD]  isEndOfFile  [TYPE]  boolean  [PARAMETER]  int  c  [CLASS]  Lexer    [TYPE]  char  commmentStart  delimiter  encapsulator  escape  [TYPE]  ExtendedBufferedReader  in  [TYPE]  CSVFormat  format  [TYPE]  boolean  emptyLinesIgnored  false  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored  true  [TYPE]  int  c  
[REPLACE]  return  c  ==  delimiter;	[BUGGY]  return  c  ||  delimiter  ;  [CE]  bad  operand  types  for  binary  operator  '||'  [CONTEXT]  boolean  isDelimiter  (  int  c  )  {  [ATTENTION]  return  c||delimiter  ;  }    [METHOD]  isDelimiter  [TYPE]  boolean  [PARAMETER]  int  c  [CLASS]  Lexer    [TYPE]  char  commmentStart  delimiter  encapsulator  escape  [TYPE]  ExtendedBufferedReader  in  [TYPE]  CSVFormat  format  [TYPE]  boolean  emptyLinesIgnored  false  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored  true  [TYPE]  int  c  
[REPLACE]  return  isEscaping  &&  c  ==  escape;	[BUGGY]  return    c  ;  [CE]  incompatible  types  [CONTEXT]  boolean  isEscape  (  int  c  )  {  [ATTENTION]  return  c  ;  }    [METHOD]  isEscape  [TYPE]  boolean  [PARAMETER]  int  c  [CLASS]  Lexer    [TYPE]  char  commmentStart  delimiter  encapsulator  escape  [TYPE]  ExtendedBufferedReader  in  [TYPE]  CSVFormat  format  [TYPE]  boolean  emptyLinesIgnored  false  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored  true  [TYPE]  int  c  
[REPLACE]  return  isEncapsulating  &&  c  ==  encapsulator;	[BUGGY]  return  false  ;  [FE]  null  assertTokenEquals(TOKEN  ,   "1 "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "2 "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "3 "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   " "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "b  x "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "c "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "d "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "e "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   " "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  boolean  isEncapsulator  (  int  c  )  {  [ATTENTION]  return  false  ;  }    [METHOD]  isEncapsulator  [TYPE]  boolean  [PARAMETER]  int  c  [CLASS]  Lexer    [TYPE]  char  commmentStart  delimiter  encapsulator  escape  [TYPE]  ExtendedBufferedReader  in  [TYPE]  CSVFormat  format  [TYPE]  boolean  emptyLinesIgnored  false  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored  true  [TYPE]  int  c  
[REPLACE]  return  isCommentEnabled  &&  c  ==  commmentStart;	[BUGGY]  return  isCommentEnabled  ;  [FE]  null  assertTokenEquals(TOKEN  ,   "1 "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "2 "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "3 "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   " "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "a "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "b  x "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EORECORD  ,   "c "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "d "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(TOKEN  ,   "e "  ,  parser.nextToken(new  Token()))  ;  assertTokenEquals(EOF  ,   " "  ,  parser.nextToken(new  Token()))  ;  [CONTEXT]  boolean  isCommentStart  (  int  c  )  {  [ATTENTION]  return  isCommentEnabled  ;  }    [METHOD]  isCommentStart  [TYPE]  boolean  [PARAMETER]  int  c  [CLASS]  Lexer    [TYPE]  char  commmentStart  delimiter  encapsulator  escape  [TYPE]  ExtendedBufferedReader  in  [TYPE]  CSVFormat  format  [TYPE]  boolean  emptyLinesIgnored  false  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored  true  [TYPE]  int  c  
