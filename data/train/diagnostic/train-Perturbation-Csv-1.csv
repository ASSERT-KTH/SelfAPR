[REPLACE]    super    (    format,    in    )    ;  	[BUGGY]  int  c  =  in  .  read  (  )  ;  [CE]  constructor  Lexer  in  class  Lexer  cannot  be  applied  to  given  types  ;    [METHOD]    <init>  [TYPE]  ExtendedBufferedReader)  [PARAMETER]  CSVFormat  format  ExtendedBufferedReader  in  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  ExtendedBufferedReader  in  [TYPE]  CSVFormat  format    [CONTEXT]    public  CSVLexer  (  CSVFormat  format  ,  ExtendedBufferedReader  in  )  {  [ATTENTION]  int  c  =  in  .  read  (  )    ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^28^^^^^27^29^
[REPLACE]    int    lastChar    =    in    .    readAgain    (    )    ;  	[BUGGY]  int  lastChar  =  in  .  readLine  (  )    ;  [CE]  incompatible  types    [METHOD]    nextToken  [TYPE]  Token  [PARAMETER]  Token  tkn  [CLASS]  CSVLexer    [TYPE]  boolean  eol  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  lastChar    [CONTEXT]    Token  nextToken  (  Token  tkn  )  throws  IOException  {    [ATTENTION]  int  lastChar  =  in  .  readLine  (  )  ;              int  c  =  in  .  read  (  )  ;  boolean  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;      if  (  emptyLinesIgnored  )  {  while  (  eol  &&  (  lastChar  =  =  '\n'  ||  lastChar  =  =  '\r'  ||  lastChar  =  =  ExtendedBufferedReader  .  UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {    lastChar  =  c  ;  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;    if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }  }  }    if  (  isEndOfFile  (  lastChar  )  ||  (  !isDelimiter  (  lastChar  )  &&  isEndOfFile  (  c  )  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }    while  (  tkn  .  type  =  =  INVALID  )  {    if  (  surroundingSpacesIgnored  )  {  while  (  isWhitespace  (  c  )  &&  !eol  )  {  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  }  }    if  (  isCommentStart  (  c  )  )  {    in  .  readLine  (  )  ;  tkn  =  nextToken  (  tkn  .  reset  (  )  )  ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  }  else  if  (  eol  )  {      tkn  .  type  =  EORECORD  ;  }  else  if  (  isEncapsulator  (  c  )  )  {    encapsulatedTokenLexer  (  tkn  ,  c  )  ;  }  else  if  (  isEndOfFile  (  c  )  )  {      tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  there  is  data  at  EOF  }  else  {      simpleTokenLexer  (  tkn  ,  c  )  ;  }  }  return  tkn  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^44^^^^^41^118^
[REPLACE]    int    c    =    in    .    read    (    )    ;  	[BUGGY]  int  c  =  in  .  readLine  (  )  ;  [CE]  incompatible  types    [METHOD]    nextToken  [TYPE]  Token  [PARAMETER]  Token  tkn  [CLASS]  CSVLexer    [TYPE]  boolean  eol  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  lastChar    [CONTEXT]    Token  nextToken  (  Token  tkn  )  throws  IOException  {    int  lastChar  =  in  .  readAgain  (  )  ;              [ATTENTION]  int  c  =  in  .  readLine  (  )    ;  boolean  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;      if  (  emptyLinesIgnored  )  {  while  (  eol  &&  (  lastChar  =  =  '\n'  ||  lastChar  =  =  '\r'  ||  lastChar  =  =  ExtendedBufferedReader  .  UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {    lastChar  =  c  ;  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;    if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }  }  }    if  (  isEndOfFile  (  lastChar  )  ||  (  !isDelimiter  (  lastChar  )  &&  isEndOfFile  (  c  )  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }    while  (  tkn  .  type  =  =  INVALID  )  {    if  (  surroundingSpacesIgnored  )  {  while  (  isWhitespace  (  c  )  &&  !eol  )  {  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  }  }    if  (  isCommentStart  (  c  )  )  {    in  .  readLine  (  )  ;  tkn  =  nextToken  (  tkn  .  reset  (  )  )  ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  }  else  if  (  eol  )  {      tkn  .  type  =  EORECORD  ;  }  else  if  (  isEncapsulator  (  c  )  )  {    encapsulatedTokenLexer  (  tkn  ,  c  )  ;  }  else  if  (  isEndOfFile  (  c  )  )  {      tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  there  is  data  at  EOF  }  else  {      simpleTokenLexer  (  tkn  ,  c  )  ;  }  }  return  tkn  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^51^^^^^41^118^
[ADD]    int    c    =    in    .    read    (    )    ;  	[BUGGY]  [CE]  cannot  find  symbol  c    [METHOD]    nextToken  [TYPE]  Token  [PARAMETER]  Token  tkn  [CLASS]  CSVLexer    [TYPE]  boolean  eol  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  lastChar    [CONTEXT]    Token  nextToken  (  Token  tkn  )  throws  IOException  {    int  lastChar  =  in  .  readAgain  (  )  ;              [ATTENTION]  boolean  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;      if  (  emptyLinesIgnored  )  {  while  (  eol  &&  (  lastChar  =  =  '\n'  ||  lastChar  =  =  '\r'  ||  lastChar  =  =  ExtendedBufferedReader  .  UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {    lastChar  =  c  ;  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;    if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }  }  }    if  (  isEndOfFile  (  lastChar  )  ||  (  !isDelimiter  (  lastChar  )  &&  isEndOfFile  (  c  )  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }    while  (  tkn  .  type  =  =  INVALID  )  {    if  (  surroundingSpacesIgnored  )  {  while  (  isWhitespace  (  c  )  &&  !eol  )  {  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  }  }    if  (  isCommentStart  (  c  )  )  {    in  .  readLine  (  )  ;  tkn  =  nextToken  (  tkn  .  reset  (  )  )  ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  }  else  if  (  eol  )  {      tkn  .  type  =  EORECORD  ;  }  else  if  (  isEncapsulator  (  c  )  )  {    encapsulatedTokenLexer  (  tkn  ,  c  )  ;  }  else  if  (  isEndOfFile  (  c  )  )  {      tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  there  is  data  at  EOF  }  else  {      simpleTokenLexer  (  tkn  ,  c  )  ;  }  }  return  tkn  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^51^^^^^41^118^
[REPLACE]    boolean    eol    =    isEndOfLine    (    c    )    ;  	[BUGGY]  boolean  eol  =  isEndOfLine  (  lastChar  )  ;  [FE]    AssertionFailedError    Token  content  expected:<[a]>  but  was:<[]>  assertTokenEquals(TOKEN  ,     "1   "  ,  parser.nextToken(new  Token()))      [METHOD]    nextToken  [TYPE]  Token  [PARAMETER]  Token  tkn  [CLASS]  CSVLexer    [TYPE]  boolean  eol  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  lastChar    [CONTEXT]    Token  nextToken  (  Token  tkn  )  throws  IOException  {    int  lastChar  =  in  .  readAgain  (  )  ;              int  c  =  in  .  read  (  )  ;  [ATTENTION]  boolean  eol  =  isEndOfLine  (  lastChar  )    ;  c  =  in  .  readAgain  (  )  ;      if  (  emptyLinesIgnored  )  {  while  (  eol  &&  (  lastChar  =  =  '\n'  ||  lastChar  =  =  '\r'  ||  lastChar  =  =  ExtendedBufferedReader  .  UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {    lastChar  =  c  ;  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;    if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }  }  }    if  (  isEndOfFile  (  lastChar  )  ||  (  !isDelimiter  (  lastChar  )  &&  isEndOfFile  (  c  )  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }    while  (  tkn  .  type  =  =  INVALID  )  {    if  (  surroundingSpacesIgnored  )  {  while  (  isWhitespace  (  c  )  &&  !eol  )  {  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  }  }    if  (  isCommentStart  (  c  )  )  {    in  .  readLine  (  )  ;  tkn  =  nextToken  (  tkn  .  reset  (  )  )  ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  }  else  if  (  eol  )  {      tkn  .  type  =  EORECORD  ;  }  else  if  (  isEncapsulator  (  c  )  )  {    encapsulatedTokenLexer  (  tkn  ,  c  )  ;  }  else  if  (  isEndOfFile  (  c  )  )  {      tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  there  is  data  at  EOF  }  else  {      simpleTokenLexer  (  tkn  ,  c  )  ;  }  }  return  tkn  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^52^^^^^41^118^
[REPLACE]    c    =    in    .    readAgain    (    )    ;  	[BUGGY]  c  =  in  .  read  (  )  ;    ;  [FE]    AssertionFailedError    Token  content  expected:<[a]bc>  but  was:<[]bc>  assertTokenEquals(TOKEN  ,     "abc   "  ,  parser.nextToken(new  Token()))      [METHOD]    nextToken  [TYPE]  Token  [PARAMETER]  Token  tkn  [CLASS]  CSVLexer    [TYPE]  boolean  eol  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  lastChar    [CONTEXT]    Token  nextToken  (  Token  tkn  )  throws  IOException  {    int  lastChar  =  in  .  readAgain  (  )  ;              int  c  =  in  .  read  (  )  ;  boolean  eol  =  isEndOfLine  (  c  )  ;  [ATTENTION]  c  =  in  .  read  (  )    ;    ;      if  (  emptyLinesIgnored  )  {  while  (  eol  &&  (  lastChar  =  =  '\n'  ||  lastChar  =  =  '\r'  ||  lastChar  =  =  ExtendedBufferedReader  .  UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {    lastChar  =  c  ;  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;    if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }  }  }    if  (  isEndOfFile  (  lastChar  )  ||  (  !isDelimiter  (  lastChar  )  &&  isEndOfFile  (  c  )  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }    while  (  tkn  .  type  =  =  INVALID  )  {    if  (  surroundingSpacesIgnored  )  {  while  (  isWhitespace  (  c  )  &&  !eol  )  {  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  }  }    if  (  isCommentStart  (  c  )  )  {    in  .  readLine  (  )  ;  tkn  =  nextToken  (  tkn  .  reset  (  )  )  ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  }  else  if  (  eol  )  {      tkn  .  type  =  EORECORD  ;  }  else  if  (  isEncapsulator  (  c  )  )  {    encapsulatedTokenLexer  (  tkn  ,  c  )  ;  }  else  if  (  isEndOfFile  (  c  )  )  {      tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  there  is  data  at  EOF  }  else  {      simpleTokenLexer  (  tkn  ,  c  )  ;  }  }  return  tkn  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^53^^^^^41^118^
[REPLACE]    if    (    isEndOfFile    (    c    )    )    {  	[BUGGY]  if  (  isEndOfFile  (  lastChar  )  )  {[NO-ERROR]    [METHOD]    nextToken  [TYPE]  Token  [PARAMETER]  Token  tkn  [CLASS]  CSVLexer    [TYPE]  boolean  eol  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  lastChar    [CONTEXT]    while  (  eol  &&  (  lastChar  =  =  '\n'  ||  lastChar  =  =  '\r'  ||  lastChar  =  =  ExtendedBufferedReader  .  UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {    lastChar  =  c  ;  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;    [ATTENTION]  if  (  isEndOfFile  (  lastChar  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^66^^^^^57^71^
[REPLACE]    tkn    .    type    =    EOF;  	[BUGGY]  tkn  .  type  =  TOKEN  ;    ;  [FE]    AssertionFailedError    Token  type  expected:<EOF>  but  was:<TOKEN>  assertTokenEquals(TOKEN  ,     "1   "  ,  parser.nextToken(new  Token()))      [METHOD]    nextToken  [TYPE]  Token  [PARAMETER]  Token  tkn  [CLASS]  CSVLexer    [TYPE]  boolean  eol  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  lastChar    [CONTEXT]    while  (  eol  &&  (  lastChar  =  =  '\n'  ||  lastChar  =  =  '\r'  ||  lastChar  =  =  ExtendedBufferedReader  .  UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {    lastChar  =  c  ;  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;    if  (  isEndOfFile  (  c  )  )  {  [ATTENTION]  tkn  .  type  =  TOKEN  ;    ;    return  tkn  ;  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^67^^^^^57^71^
[REPLACE]    lastChar    =    c;  	[BUGGY]  lastChar  =    null  ;  [CE]  incompatible  types    [METHOD]    nextToken  [TYPE]  Token  [PARAMETER]  Token  tkn  [CLASS]  CSVLexer    [TYPE]  boolean  eol  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  lastChar    [CONTEXT]    while  (  eol  &&  (  lastChar  =  =  '\n'  ||  lastChar  =  =  '\r'  ||  lastChar  =  =  ExtendedBufferedReader  .  UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {    [ATTENTION]  lastChar  =  null  ;  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;    if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^61^^^^^57^71^
[ADD]    lastChar    =    c;    c    =    in    .    read    (    )    ;  	[BUGGY]  [FE]  [METHOD]    nextToken  [TYPE]  Token  [PARAMETER]  Token  tkn  [CLASS]  CSVLexer    [TYPE]  boolean  eol  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  lastChar    [CONTEXT]    while  (  eol  &&  (  lastChar  =  =  '\n'  ||  lastChar  =  =  '\r'  ||  lastChar  =  =  ExtendedBufferedReader  .  UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {    [ATTENTION]    eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;    if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^61^62^^^^57^71^
[REPLACE]    c    =    in    .    read    (    )    ;  	[BUGGY]  c  =  in  .  readAgain  (  )  ;    ;  [FE]  [METHOD]    nextToken  [TYPE]  Token  [PARAMETER]  Token  tkn  [CLASS]  CSVLexer    [TYPE]  boolean  eol  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  lastChar    [CONTEXT]    while  (  eol  &&  (  lastChar  =  =  '\n'  ||  lastChar  =  =  '\r'  ||  lastChar  =  =  ExtendedBufferedReader  .  UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {    lastChar  =  c  ;  [ATTENTION]  c  =  in  .  readAgain  (  )    ;    ;  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;    if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^62^^^^^57^71^
[REPLACE]    eol    =    isEndOfLine    (    c    )    ;  	[BUGGY]  eol  =    isEndOfLine  (  lastChar  )  ;  [FE]    AssertionFailedError    arrays  first  differed  at  element  [0]      [METHOD]    nextToken  [TYPE]  Token  [PARAMETER]  Token  tkn  [CLASS]  CSVLexer    [TYPE]  boolean  eol  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  lastChar    [CONTEXT]    while  (  eol  &&  (  lastChar  =  =  '\n'  ||  lastChar  =  =  '\r'  ||  lastChar  =  =  ExtendedBufferedReader  .  UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {    lastChar  =  c  ;  c  =  in  .  read  (  )  ;  [ATTENTION]  eol  =  isEndOfLine  (  lastChar  )    ;  c  =  in  .  readAgain  (  )  ;    if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^63^^^^^57^71^
[ADD]    eol    =    isEndOfLine    (    c    )    ;  	[BUGGY]  [FE]    AssertionFailedError    expected:<3>  but  was:<5>  assertEquals(3  ,  records.size())      [METHOD]    nextToken  [TYPE]  Token  [PARAMETER]  Token  tkn  [CLASS]  CSVLexer    [TYPE]  boolean  eol  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  lastChar    [CONTEXT]    while  (  eol  &&  (  lastChar  =  =  '\n'  ||  lastChar  =  =  '\r'  ||  lastChar  =  =  ExtendedBufferedReader  .  UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {    lastChar  =  c  ;  c  =  in  .  read  (  )  ;  [ATTENTION]  c  =  in  .  readAgain  (  )  ;    if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^63^^^^^57^71^
[REPLACE]    c    =    in    .    readAgain    (    )    ;  	[BUGGY]  c  =  in  .  read  (  )  ;    ;  [FE]    AssertionFailedError    arrays  first  differed  at  element  [0]      [METHOD]    nextToken  [TYPE]  Token  [PARAMETER]  Token  tkn  [CLASS]  CSVLexer    [TYPE]  boolean  eol  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  lastChar    [CONTEXT]    while  (  eol  &&  (  lastChar  =  =  '\n'  ||  lastChar  =  =  '\r'  ||  lastChar  =  =  ExtendedBufferedReader  .  UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {    lastChar  =  c  ;  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  [ATTENTION]  c  =  in  .  read  (  )    ;    ;    if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^64^^^^^57^71^
[REPLACE]    if    (    emptyLinesIgnored    )    {  	[BUGGY]  if  (  isEscape  (  c  )  )  {[FE]    AssertionFailedError    Token  type  expected:<EOF>  but  was:<EORECORD>  assertTokenEquals(TOKEN  ,     "1   "  ,  parser.nextToken(new  Token()))      [METHOD]    nextToken  [TYPE]  Token  [PARAMETER]  Token  tkn  [CLASS]  CSVLexer    [TYPE]  boolean  eol  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  lastChar    [CONTEXT]    Token  nextToken  (  Token  tkn  )  throws  IOException  {    int  lastChar  =  in  .  readAgain  (  )  ;              int  c  =  in  .  read  (  )  ;  boolean  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;      [ATTENTION]  if  (  isEscape  (  c  )  )  {  while  (  eol  &&  (  lastChar  =  =  '\n'  ||  lastChar  =  =  '\r'  ||  lastChar  =  =  ExtendedBufferedReader  .  UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {    lastChar  =  c  ;  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;    if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }  }  }    if  (  isEndOfFile  (  lastChar  )  ||  (  !isDelimiter  (  lastChar  )  &&  isEndOfFile  (  c  )  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }    while  (  tkn  .  type  =  =  INVALID  )  {    if  (  surroundingSpacesIgnored  )  {  while  (  isWhitespace  (  c  )  &&  !eol  )  {  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  }  }    if  (  isCommentStart  (  c  )  )  {    in  .  readLine  (  )  ;  tkn  =  nextToken  (  tkn  .  reset  (  )  )  ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  }  else  if  (  eol  )  {      tkn  .  type  =  EORECORD  ;  }  else  if  (  isEncapsulator  (  c  )  )  {    encapsulatedTokenLexer  (  tkn  ,  c  )  ;  }  else  if  (  isEndOfFile  (  c  )  )  {      tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  there  is  data  at  EOF  }  else  {      simpleTokenLexer  (  tkn  ,  c  )  ;  }  }  return  tkn  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^56^^^^^41^118^
[REPLACE]    while    (    eol    &&    (    lastChar    ==    '\n'    ||    lastChar    ==    '\r'    ||    lastChar    ==    ExtendedBufferedReader    .    UNDEFINED    )    &&    !isEndOfFile    (    lastChar    )    )    {  	[BUGGY]  while  (  eol  ;  [CE]  ')'  expected    [METHOD]    nextToken  [TYPE]  Token  [PARAMETER]  Token  tkn  [CLASS]  CSVLexer    [TYPE]  boolean  eol  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  lastChar    [CONTEXT]    Token  nextToken  (  Token  tkn  )  throws  IOException  {    int  lastChar  =  in  .  readAgain  (  )  ;              int  c  =  in  .  read  (  )  ;  boolean  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;      if  (  emptyLinesIgnored  )  {  [ATTENTION]  while  (  eol  ;      lastChar  =  c  ;  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;    if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }  }  }    if  (  isEndOfFile  (  lastChar  )  ||  (  !isDelimiter  (  lastChar  )  &&  isEndOfFile  (  c  )  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }    while  (  tkn  .  type  =  =  INVALID  )  {    if  (  surroundingSpacesIgnored  )  {  while  (  isWhitespace  (  c  )  &&  !eol  )  {  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  }  }    if  (  isCommentStart  (  c  )  )  {    in  .  readLine  (  )  ;  tkn  =  nextToken  (  tkn  .  reset  (  )  )  ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  }  else  if  (  eol  )  {      tkn  .  type  =  EORECORD  ;  }  else  if  (  isEncapsulator  (  c  )  )  {    encapsulatedTokenLexer  (  tkn  ,  c  )  ;  }  else  if  (  isEndOfFile  (  c  )  )  {      tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  there  is  data  at  EOF  }  else  {      simpleTokenLexer  (  tkn  ,  c  )  ;  }  }  return  tkn  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^57^58^59^^^41^118^
[REPLACE]    if    (    isEndOfFile    (    c    )    )    {  	[BUGGY]  if  (  isEscape  (  c  )  )  {[NO-ERROR]    [METHOD]    nextToken  [TYPE]  Token  [PARAMETER]  Token  tkn  [CLASS]  CSVLexer    [TYPE]  boolean  eol  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  lastChar    [CONTEXT]    while  (  eol  &&  (  lastChar  =  =  '\n'  ||  lastChar  =  =  '\r'  ||  lastChar  =  =  ExtendedBufferedReader  .  UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {    lastChar  =  c  ;  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;    [ATTENTION]  if  (  isEscape  (  c  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^66^^^^^57^71^
[ADD]    c    =    in    .    read    (    )    ;    eol    =    isEndOfLine    (    c    )    ;  	[BUGGY]  [FE]  [METHOD]    nextToken  [TYPE]  Token  [PARAMETER]  Token  tkn  [CLASS]  CSVLexer    [TYPE]  boolean  eol  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  lastChar    [CONTEXT]    while  (  eol  &&  (  lastChar  =  =  '\n'  ||  lastChar  =  =  '\r'  ||  lastChar  =  =  ExtendedBufferedReader  .  UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {    lastChar  =  c  ;  [ATTENTION]    c  =  in  .  readAgain  (  )  ;    if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^62^63^^^^57^71^
[ADD]    c    =    in    .    readAgain    (    )    ;  	[BUGGY]  [NO-ERROR]    [METHOD]    nextToken  [TYPE]  Token  [PARAMETER]  Token  tkn  [CLASS]  CSVLexer    [TYPE]  boolean  eol  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  lastChar    [CONTEXT]    while  (  eol  &&  (  lastChar  =  =  '\n'  ||  lastChar  =  =  '\r'  ||  lastChar  =  =  ExtendedBufferedReader  .  UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {    lastChar  =  c  ;  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  [ATTENTION]    if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^64^^^^^57^71^
[ADD]    tkn    .    type    =    EOF;  	[BUGGY]  [FE]    AssertionFailedError    Token  type  expected:<EOF>  but  was:<INVALID>  assertTokenEquals(TOKEN  ,     "1   "  ,  parser.nextToken(new  Token()))      [METHOD]    nextToken  [TYPE]  Token  [PARAMETER]  Token  tkn  [CLASS]  CSVLexer    [TYPE]  boolean  eol  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  lastChar    [CONTEXT]    while  (  eol  &&  (  lastChar  =  =  '\n'  ||  lastChar  =  =  '\r'  ||  lastChar  =  =  ExtendedBufferedReader  .  UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {    lastChar  =  c  ;  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;    if  (  isEndOfFile  (  c  )  )  {  [ATTENTION]    return  tkn  ;  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^67^^^^^57^71^
[REPLACE]    if    (    isEndOfFile    (    c    )    )    {  	[BUGGY]  if  (  isEscape  (  c  )  )  {[NO-ERROR]    [METHOD]    nextToken  [TYPE]  Token  [PARAMETER]  Token  tkn  [CLASS]  CSVLexer    [TYPE]  boolean  eol  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  lastChar    [CONTEXT]    Token  nextToken  (  Token  tkn  )  throws  IOException  {    int  lastChar  =  in  .  readAgain  (  )  ;              int  c  =  in  .  read  (  )  ;  boolean  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;      if  (  emptyLinesIgnored  )  {  while  (  eol  &&  (  lastChar  =  =  '\n'  ||  lastChar  =  =  '\r'  ||  lastChar  =  =  ExtendedBufferedReader  .  UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {    lastChar  =  c  ;  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;    [ATTENTION]  if  (  isEscape  (  c  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }  }  }    if  (  isEndOfFile  (  lastChar  )  ||  (  !isDelimiter  (  lastChar  )  &&  isEndOfFile  (  c  )  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }    while  (  tkn  .  type  =  =  INVALID  )  {    if  (  surroundingSpacesIgnored  )  {  while  (  isWhitespace  (  c  )  &&  !eol  )  {  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  }  }    if  (  isCommentStart  (  c  )  )  {    in  .  readLine  (  )  ;  tkn  =  nextToken  (  tkn  .  reset  (  )  )  ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  }  else  if  (  eol  )  {      tkn  .  type  =  EORECORD  ;  }  else  if  (  isEncapsulator  (  c  )  )  {    encapsulatedTokenLexer  (  tkn  ,  c  )  ;  }  else  if  (  isEndOfFile  (  c  )  )  {      tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  there  is  data  at  EOF  }  else  {      simpleTokenLexer  (  tkn  ,  c  )  ;  }  }  return  tkn  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^66^^^^^41^118^
[REPLACE]    tkn    .    type    =    EOF;  	[BUGGY]  tkn  .  type  =  TOKEN  ;    ;  [FE]    AssertionFailedError    Token  type  expected:<EOF>  but  was:<TOKEN>  assertTokenEquals(TOKEN  ,     "1   "  ,  parser.nextToken(new  Token()))      [METHOD]    nextToken  [TYPE]  Token  [PARAMETER]  Token  tkn  [CLASS]  CSVLexer    [TYPE]  boolean  eol  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  lastChar    [CONTEXT]    Token  nextToken  (  Token  tkn  )  throws  IOException  {    int  lastChar  =  in  .  readAgain  (  )  ;              int  c  =  in  .  read  (  )  ;  boolean  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;      if  (  emptyLinesIgnored  )  {  while  (  eol  &&  (  lastChar  =  =  '\n'  ||  lastChar  =  =  '\r'  ||  lastChar  =  =  ExtendedBufferedReader  .  UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {    lastChar  =  c  ;  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;    if  (  isEndOfFile  (  c  )  )  {  [ATTENTION]  tkn  .  type  =  TOKEN  ;    ;    return  tkn  ;  }  }  }    if  (  isEndOfFile  (  lastChar  )  ||  (  !isDelimiter  (  lastChar  )  &&  isEndOfFile  (  c  )  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }    while  (  tkn  .  type  =  =  INVALID  )  {    if  (  surroundingSpacesIgnored  )  {  while  (  isWhitespace  (  c  )  &&  !eol  )  {  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  }  }    if  (  isCommentStart  (  c  )  )  {    in  .  readLine  (  )  ;  tkn  =  nextToken  (  tkn  .  reset  (  )  )  ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  }  else  if  (  eol  )  {      tkn  .  type  =  EORECORD  ;  }  else  if  (  isEncapsulator  (  c  )  )  {    encapsulatedTokenLexer  (  tkn  ,  c  )  ;  }  else  if  (  isEndOfFile  (  c  )  )  {      tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  there  is  data  at  EOF  }  else  {      simpleTokenLexer  (  tkn  ,  c  )  ;  }  }  return  tkn  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^67^^^^^41^118^
[ADD]    tkn    .    type    =    EOF;  	[BUGGY]  [FE]    AssertionFailedError    Token  type  expected:<EOF>  but  was:<INVALID>  assertTokenEquals(TOKEN  ,     "1   "  ,  parser.nextToken(new  Token()))      [METHOD]    nextToken  [TYPE]  Token  [PARAMETER]  Token  tkn  [CLASS]  CSVLexer    [TYPE]  boolean  eol  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  lastChar    [CONTEXT]    Token  nextToken  (  Token  tkn  )  throws  IOException  {    int  lastChar  =  in  .  readAgain  (  )  ;              int  c  =  in  .  read  (  )  ;  boolean  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;      if  (  emptyLinesIgnored  )  {  while  (  eol  &&  (  lastChar  =  =  '\n'  ||  lastChar  =  =  '\r'  ||  lastChar  =  =  ExtendedBufferedReader  .  UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {    lastChar  =  c  ;  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;    if  (  isEndOfFile  (  c  )  )  {  [ATTENTION]    return  tkn  ;  }  }  }    if  (  isEndOfFile  (  lastChar  )  ||  (  !isDelimiter  (  lastChar  )  &&  isEndOfFile  (  c  )  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }    while  (  tkn  .  type  =  =  INVALID  )  {    if  (  surroundingSpacesIgnored  )  {  while  (  isWhitespace  (  c  )  &&  !eol  )  {  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  }  }    if  (  isCommentStart  (  c  )  )  {    in  .  readLine  (  )  ;  tkn  =  nextToken  (  tkn  .  reset  (  )  )  ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  }  else  if  (  eol  )  {      tkn  .  type  =  EORECORD  ;  }  else  if  (  isEncapsulator  (  c  )  )  {    encapsulatedTokenLexer  (  tkn  ,  c  )  ;  }  else  if  (  isEndOfFile  (  c  )  )  {      tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  there  is  data  at  EOF  }  else  {      simpleTokenLexer  (  tkn  ,  c  )  ;  }  }  return  tkn  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^67^^^^^41^118^
[REPLACE]    lastChar    =    c;  	[BUGGY]  lastChar  =    null  ;  [CE]  incompatible  types    [METHOD]    nextToken  [TYPE]  Token  [PARAMETER]  Token  tkn  [CLASS]  CSVLexer    [TYPE]  boolean  eol  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  lastChar    [CONTEXT]    Token  nextToken  (  Token  tkn  )  throws  IOException  {    int  lastChar  =  in  .  readAgain  (  )  ;              int  c  =  in  .  read  (  )  ;  boolean  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;      if  (  emptyLinesIgnored  )  {  while  (  eol  &&  (  lastChar  =  =  '\n'  ||  lastChar  =  =  '\r'  ||  lastChar  =  =  ExtendedBufferedReader  .  UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {    [ATTENTION]  lastChar  =  null  ;  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;    if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }  }  }    if  (  isEndOfFile  (  lastChar  )  ||  (  !isDelimiter  (  lastChar  )  &&  isEndOfFile  (  c  )  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }    while  (  tkn  .  type  =  =  INVALID  )  {    if  (  surroundingSpacesIgnored  )  {  while  (  isWhitespace  (  c  )  &&  !eol  )  {  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  }  }    if  (  isCommentStart  (  c  )  )  {    in  .  readLine  (  )  ;  tkn  =  nextToken  (  tkn  .  reset  (  )  )  ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  }  else  if  (  eol  )  {      tkn  .  type  =  EORECORD  ;  }  else  if  (  isEncapsulator  (  c  )  )  {    encapsulatedTokenLexer  (  tkn  ,  c  )  ;  }  else  if  (  isEndOfFile  (  c  )  )  {      tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  there  is  data  at  EOF  }  else  {      simpleTokenLexer  (  tkn  ,  c  )  ;  }  }  return  tkn  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^61^^^^^41^118^
[REPLACE]    c    =    in    .    read    (    )    ;  	[BUGGY]  c  =  in  .  readAgain  (  )  ;    ;  [FE]  [METHOD]    nextToken  [TYPE]  Token  [PARAMETER]  Token  tkn  [CLASS]  CSVLexer    [TYPE]  boolean  eol  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  lastChar    [CONTEXT]    Token  nextToken  (  Token  tkn  )  throws  IOException  {    int  lastChar  =  in  .  readAgain  (  )  ;              int  c  =  in  .  read  (  )  ;  boolean  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;      if  (  emptyLinesIgnored  )  {  while  (  eol  &&  (  lastChar  =  =  '\n'  ||  lastChar  =  =  '\r'  ||  lastChar  =  =  ExtendedBufferedReader  .  UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {    lastChar  =  c  ;  [ATTENTION]  c  =  in  .  readAgain  (  )    ;    ;  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;    if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }  }  }    if  (  isEndOfFile  (  lastChar  )  ||  (  !isDelimiter  (  lastChar  )  &&  isEndOfFile  (  c  )  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }    while  (  tkn  .  type  =  =  INVALID  )  {    if  (  surroundingSpacesIgnored  )  {  while  (  isWhitespace  (  c  )  &&  !eol  )  {  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  }  }    if  (  isCommentStart  (  c  )  )  {    in  .  readLine  (  )  ;  tkn  =  nextToken  (  tkn  .  reset  (  )  )  ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  }  else  if  (  eol  )  {      tkn  .  type  =  EORECORD  ;  }  else  if  (  isEncapsulator  (  c  )  )  {    encapsulatedTokenLexer  (  tkn  ,  c  )  ;  }  else  if  (  isEndOfFile  (  c  )  )  {      tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  there  is  data  at  EOF  }  else  {      simpleTokenLexer  (  tkn  ,  c  )  ;  }  }  return  tkn  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^62^^^^^41^118^
[REPLACE]    eol    =    isEndOfLine    (    c    )    ;  	[BUGGY]  eol  =    isEndOfLine  (  lastChar  )  ;  [FE]    AssertionFailedError    arrays  first  differed  at  element  [0]      [METHOD]    nextToken  [TYPE]  Token  [PARAMETER]  Token  tkn  [CLASS]  CSVLexer    [TYPE]  boolean  eol  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  lastChar    [CONTEXT]    Token  nextToken  (  Token  tkn  )  throws  IOException  {    int  lastChar  =  in  .  readAgain  (  )  ;              int  c  =  in  .  read  (  )  ;  boolean  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;      if  (  emptyLinesIgnored  )  {  while  (  eol  &&  (  lastChar  =  =  '\n'  ||  lastChar  =  =  '\r'  ||  lastChar  =  =  ExtendedBufferedReader  .  UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {    lastChar  =  c  ;  c  =  in  .  read  (  )  ;  [ATTENTION]  eol  =  isEndOfLine  (  lastChar  )    ;  c  =  in  .  readAgain  (  )  ;    if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }  }  }    if  (  isEndOfFile  (  lastChar  )  ||  (  !isDelimiter  (  lastChar  )  &&  isEndOfFile  (  c  )  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }    while  (  tkn  .  type  =  =  INVALID  )  {    if  (  surroundingSpacesIgnored  )  {  while  (  isWhitespace  (  c  )  &&  !eol  )  {  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  }  }    if  (  isCommentStart  (  c  )  )  {    in  .  readLine  (  )  ;  tkn  =  nextToken  (  tkn  .  reset  (  )  )  ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  }  else  if  (  eol  )  {      tkn  .  type  =  EORECORD  ;  }  else  if  (  isEncapsulator  (  c  )  )  {    encapsulatedTokenLexer  (  tkn  ,  c  )  ;  }  else  if  (  isEndOfFile  (  c  )  )  {      tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  there  is  data  at  EOF  }  else  {      simpleTokenLexer  (  tkn  ,  c  )  ;  }  }  return  tkn  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^63^^^^^41^118^
[ADD]    eol    =    isEndOfLine    (    c    )    ;    c    =    in    .    readAgain    (    )    ;  	[BUGGY]  [FE]    AssertionFailedError    expected:<3>  but  was:<5>  assertEquals(3  ,  records.size())      [METHOD]    nextToken  [TYPE]  Token  [PARAMETER]  Token  tkn  [CLASS]  CSVLexer    [TYPE]  boolean  eol  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  lastChar    [CONTEXT]    Token  nextToken  (  Token  tkn  )  throws  IOException  {    int  lastChar  =  in  .  readAgain  (  )  ;              int  c  =  in  .  read  (  )  ;  boolean  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;      if  (  emptyLinesIgnored  )  {  while  (  eol  &&  (  lastChar  =  =  '\n'  ||  lastChar  =  =  '\r'  ||  lastChar  =  =  ExtendedBufferedReader  .  UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {    lastChar  =  c  ;  c  =  in  .  read  (  )  ;  [ATTENTION]      if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }  }  }    if  (  isEndOfFile  (  lastChar  )  ||  (  !isDelimiter  (  lastChar  )  &&  isEndOfFile  (  c  )  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }    while  (  tkn  .  type  =  =  INVALID  )  {    if  (  surroundingSpacesIgnored  )  {  while  (  isWhitespace  (  c  )  &&  !eol  )  {  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  }  }    if  (  isCommentStart  (  c  )  )  {    in  .  readLine  (  )  ;  tkn  =  nextToken  (  tkn  .  reset  (  )  )  ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  }  else  if  (  eol  )  {      tkn  .  type  =  EORECORD  ;  }  else  if  (  isEncapsulator  (  c  )  )  {    encapsulatedTokenLexer  (  tkn  ,  c  )  ;  }  else  if  (  isEndOfFile  (  c  )  )  {      tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  there  is  data  at  EOF  }  else  {      simpleTokenLexer  (  tkn  ,  c  )  ;  }  }  return  tkn  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^63^64^^^^41^118^
[REPLACE]    c    =    in    .    readAgain    (    )    ;  	[BUGGY]  c  =  in  .  read  (  )  ;    ;  [FE]    AssertionFailedError    arrays  first  differed  at  element  [0]      [METHOD]    nextToken  [TYPE]  Token  [PARAMETER]  Token  tkn  [CLASS]  CSVLexer    [TYPE]  boolean  eol  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  lastChar    [CONTEXT]    Token  nextToken  (  Token  tkn  )  throws  IOException  {    int  lastChar  =  in  .  readAgain  (  )  ;              int  c  =  in  .  read  (  )  ;  boolean  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;      if  (  emptyLinesIgnored  )  {  while  (  eol  &&  (  lastChar  =  =  '\n'  ||  lastChar  =  =  '\r'  ||  lastChar  =  =  ExtendedBufferedReader  .  UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {    lastChar  =  c  ;  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  [ATTENTION]  c  =  in  .  read  (  )    ;    ;    if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }  }  }    if  (  isEndOfFile  (  lastChar  )  ||  (  !isDelimiter  (  lastChar  )  &&  isEndOfFile  (  c  )  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }    while  (  tkn  .  type  =  =  INVALID  )  {    if  (  surroundingSpacesIgnored  )  {  while  (  isWhitespace  (  c  )  &&  !eol  )  {  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  }  }    if  (  isCommentStart  (  c  )  )  {    in  .  readLine  (  )  ;  tkn  =  nextToken  (  tkn  .  reset  (  )  )  ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  }  else  if  (  eol  )  {      tkn  .  type  =  EORECORD  ;  }  else  if  (  isEncapsulator  (  c  )  )  {    encapsulatedTokenLexer  (  tkn  ,  c  )  ;  }  else  if  (  isEndOfFile  (  c  )  )  {      tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  there  is  data  at  EOF  }  else  {      simpleTokenLexer  (  tkn  ,  c  )  ;  }  }  return  tkn  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^64^^^^^41^118^
[REPLACE]    if    (    isEndOfFile    (    c    )    )    {  	[BUGGY]  if  (  isEndOfFile  (  lastChar  )  )  {[NO-ERROR]    [METHOD]    nextToken  [TYPE]  Token  [PARAMETER]  Token  tkn  [CLASS]  CSVLexer    [TYPE]  boolean  eol  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  lastChar    [CONTEXT]    Token  nextToken  (  Token  tkn  )  throws  IOException  {    int  lastChar  =  in  .  readAgain  (  )  ;              int  c  =  in  .  read  (  )  ;  boolean  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;      if  (  emptyLinesIgnored  )  {  while  (  eol  &&  (  lastChar  =  =  '\n'  ||  lastChar  =  =  '\r'  ||  lastChar  =  =  ExtendedBufferedReader  .  UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {    lastChar  =  c  ;  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;    [ATTENTION]  if  (  isEndOfFile  (  lastChar  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }  }  }    if  (  isEndOfFile  (  lastChar  )  ||  (  !isDelimiter  (  lastChar  )  &&  isEndOfFile  (  c  )  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }    while  (  tkn  .  type  =  =  INVALID  )  {    if  (  surroundingSpacesIgnored  )  {  while  (  isWhitespace  (  c  )  &&  !eol  )  {  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  }  }    if  (  isCommentStart  (  c  )  )  {    in  .  readLine  (  )  ;  tkn  =  nextToken  (  tkn  .  reset  (  )  )  ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  }  else  if  (  eol  )  {      tkn  .  type  =  EORECORD  ;  }  else  if  (  isEncapsulator  (  c  )  )  {    encapsulatedTokenLexer  (  tkn  ,  c  )  ;  }  else  if  (  isEndOfFile  (  c  )  )  {      tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  there  is  data  at  EOF  }  else  {      simpleTokenLexer  (  tkn  ,  c  )  ;  }  }  return  tkn  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^66^^^^^41^118^
[REPLACE]    if    (    isEndOfFile    (    lastChar    )    ||    (    !isDelimiter    (    lastChar    )    &&    isEndOfFile    (    c    )    )    )    {  	[BUGGY]  if  (  isEndOfFile  (  lastChar  )  ||  (  isDelimiter  (  lastChar  )  &&  isEndOfFile  (  c  )  )  )  {[FE]    null  assertEquals(CSVFormat.DISABLED  ,  format.getCommentStart())      [METHOD]    nextToken  [TYPE]  Token  [PARAMETER]  Token  tkn  [CLASS]  CSVLexer    [TYPE]  boolean  eol  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  lastChar    [CONTEXT]    Token  nextToken  (  Token  tkn  )  throws  IOException  {    int  lastChar  =  in  .  readAgain  (  )  ;              int  c  =  in  .  read  (  )  ;  boolean  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;      if  (  emptyLinesIgnored  )  {  while  (  eol  &&  (  lastChar  =  =  '\n'  ||  lastChar  =  =  '\r'  ||  lastChar  =  =  ExtendedBufferedReader  .  UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {    lastChar  =  c  ;  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;    if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }  }  }    [ATTENTION]  if  (  isEndOfFile  (  lastChar  )  ||  (  isDelimiter  (  lastChar  )  &&  isEndOfFile  (  c  )  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }    while  (  tkn  .  type  =  =  INVALID  )  {    if  (  surroundingSpacesIgnored  )  {  while  (  isWhitespace  (  c  )  &&  !eol  )  {  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  }  }    if  (  isCommentStart  (  c  )  )  {    in  .  readLine  (  )  ;  tkn  =  nextToken  (  tkn  .  reset  (  )  )  ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  }  else  if  (  eol  )  {      tkn  .  type  =  EORECORD  ;  }  else  if  (  isEncapsulator  (  c  )  )  {    encapsulatedTokenLexer  (  tkn  ,  c  )  ;  }  else  if  (  isEndOfFile  (  c  )  )  {      tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  there  is  data  at  EOF  }  else  {      simpleTokenLexer  (  tkn  ,  c  )  ;  }  }  return  tkn  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^75^^^^^41^118^
[REMOVE]      	[BUGGY]  if  (  isEndOfFile  (  c  )  )  {      tkn  .  type  =  EOF  ;      return  tkn  ;  }[NO-ERROR]    [METHOD]    nextToken  [TYPE]  Token  [PARAMETER]  Token  tkn  [CLASS]  CSVLexer    [TYPE]  boolean  eol  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  lastChar    [CONTEXT]    Token  nextToken  (  Token  tkn  )  throws  IOException  {    int  lastChar  =  in  .  readAgain  (  )  ;              int  c  =  in  .  read  (  )  ;  boolean  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;      if  (  emptyLinesIgnored  )  {  while  (  eol  &&  (  lastChar  =  =  '\n'  ||  lastChar  =  =  '\r'  ||  lastChar  =  =  ExtendedBufferedReader  .  UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {    lastChar  =  c  ;  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;    if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }  }  }    [ATTENTION]  if  (  isEndOfFile  (  lastChar  )  ||  (  !isDelimiter  (  lastChar  )  &&  isEndOfFile  (  c  )  )  )  {  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  return  tkn  ;  }tkn  .  type  =  EOF  ;    return  tkn  ;  }    while  (  tkn  .  type  =  =  INVALID  )  {    if  (  surroundingSpacesIgnored  )  {  while  (  isWhitespace  (  c  )  &&  !eol  )  {  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  }  }    if  (  isCommentStart  (  c  )  )  {    in  .  readLine  (  )  ;  tkn  =  nextToken  (  tkn  .  reset  (  )  )  ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  }  else  if  (  eol  )  {      tkn  .  type  =  EORECORD  ;  }  else  if  (  isEncapsulator  (  c  )  )  {    encapsulatedTokenLexer  (  tkn  ,  c  )  ;  }  else  if  (  isEndOfFile  (  c  )  )  {      tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  there  is  data  at  EOF  }  else  {      simpleTokenLexer  (  tkn  ,  c  )  ;  }  }  return  tkn  ;      	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^75^^^^^41^118^
[REPLACE]    tkn    .    type    =    EOF;  	[BUGGY]  tkn  .  type  =  TOKEN  ;    ;  [FE]  [METHOD]    nextToken  [TYPE]  Token  [PARAMETER]  Token  tkn  [CLASS]  CSVLexer    [TYPE]  boolean  eol  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  lastChar    [CONTEXT]    Token  nextToken  (  Token  tkn  )  throws  IOException  {    int  lastChar  =  in  .  readAgain  (  )  ;              int  c  =  in  .  read  (  )  ;  boolean  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;      if  (  emptyLinesIgnored  )  {  while  (  eol  &&  (  lastChar  =  =  '\n'  ||  lastChar  =  =  '\r'  ||  lastChar  =  =  ExtendedBufferedReader  .  UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {    lastChar  =  c  ;  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;    if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }  }  }    if  (  isEndOfFile  (  lastChar  )  ||  (  !isDelimiter  (  lastChar  )  &&  isEndOfFile  (  c  )  )  )  {  [ATTENTION]  tkn  .  type  =  TOKEN  ;    ;    return  tkn  ;  }    while  (  tkn  .  type  =  =  INVALID  )  {    if  (  surroundingSpacesIgnored  )  {  while  (  isWhitespace  (  c  )  &&  !eol  )  {  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  }  }    if  (  isCommentStart  (  c  )  )  {    in  .  readLine  (  )  ;  tkn  =  nextToken  (  tkn  .  reset  (  )  )  ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  }  else  if  (  eol  )  {      tkn  .  type  =  EORECORD  ;  }  else  if  (  isEncapsulator  (  c  )  )  {    encapsulatedTokenLexer  (  tkn  ,  c  )  ;  }  else  if  (  isEndOfFile  (  c  )  )  {      tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  there  is  data  at  EOF  }  else  {      simpleTokenLexer  (  tkn  ,  c  )  ;  }  }  return  tkn  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^76^^^^^41^118^
[REPLACE]    while    (    tkn    .    type    ==    INVALID    )    {  	[BUGGY]  while  (  tkn  .  type  &&  INVALID  )  {[CE]  bad  operand  types  for  binary  operator  '&&'    [METHOD]    nextToken  [TYPE]  Token  [PARAMETER]  Token  tkn  [CLASS]  CSVLexer    [TYPE]  boolean  eol  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  lastChar    [CONTEXT]    Token  nextToken  (  Token  tkn  )  throws  IOException  {    int  lastChar  =  in  .  readAgain  (  )  ;              int  c  =  in  .  read  (  )  ;  boolean  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;      if  (  emptyLinesIgnored  )  {  while  (  eol  &&  (  lastChar  =  =  '\n'  ||  lastChar  =  =  '\r'  ||  lastChar  =  =  ExtendedBufferedReader  .  UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {    lastChar  =  c  ;  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;    if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }  }  }    if  (  isEndOfFile  (  lastChar  )  ||  (  !isDelimiter  (  lastChar  )  &&  isEndOfFile  (  c  )  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }    [ATTENTION]  while  (  tkn  .  type&&INVALID  )  {    if  (  surroundingSpacesIgnored  )  {  while  (  isWhitespace  (  c  )  &&  !eol  )  {  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  }  }    if  (  isCommentStart  (  c  )  )  {    in  .  readLine  (  )  ;  tkn  =  nextToken  (  tkn  .  reset  (  )  )  ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  }  else  if  (  eol  )  {      tkn  .  type  =  EORECORD  ;  }  else  if  (  isEncapsulator  (  c  )  )  {    encapsulatedTokenLexer  (  tkn  ,  c  )  ;  }  else  if  (  isEndOfFile  (  c  )  )  {      tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  there  is  data  at  EOF  }  else  {      simpleTokenLexer  (  tkn  ,  c  )  ;  }  }  return  tkn  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^82^^^^^41^118^
[ADD]    while    (    tkn    .    type    ==    INVALID    )    {    if    (    surroundingSpacesIgnored    )    {  	[BUGGY]  [CE]  illegal  start  of  type    [METHOD]    nextToken  [TYPE]  Token  [PARAMETER]  Token  tkn  [CLASS]  CSVLexer    [TYPE]  boolean  eol  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  lastChar    [CONTEXT]    Token  nextToken  (  Token  tkn  )  throws  IOException  {    int  lastChar  =  in  .  readAgain  (  )  ;              int  c  =  in  .  read  (  )  ;  boolean  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;      if  (  emptyLinesIgnored  )  {  while  (  eol  &&  (  lastChar  =  =  '\n'  ||  lastChar  =  =  '\r'  ||  lastChar  =  =  ExtendedBufferedReader  .  UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {    lastChar  =  c  ;  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;    if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }  }  }    if  (  isEndOfFile  (  lastChar  )  ||  (  !isDelimiter  (  lastChar  )  &&  isEndOfFile  (  c  )  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }    [ATTENTION]    while  (  isWhitespace  (  c  )  &&  !eol  )  {  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  }  }    if  (  isCommentStart  (  c  )  )  {    in  .  readLine  (  )  ;  tkn  =  nextToken  (  tkn  .  reset  (  )  )  ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  }  else  if  (  eol  )  {      tkn  .  type  =  EORECORD  ;  }  else  if  (  isEncapsulator  (  c  )  )  {    encapsulatedTokenLexer  (  tkn  ,  c  )  ;  }  else  if  (  isEndOfFile  (  c  )  )  {      tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  there  is  data  at  EOF  }  else  {      simpleTokenLexer  (  tkn  ,  c  )  ;  }  }  return  tkn  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^82^83^84^^^41^118^
[REPLACE]    while    (    isWhitespace    (    c    )    &&    !eol    )    {  	[BUGGY]  while  (  isWhitespace  (  c  )    ;  [CE]  ')'  expected    [METHOD]    nextToken  [TYPE]  Token  [PARAMETER]  Token  tkn  [CLASS]  CSVLexer    [TYPE]  boolean  eol  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  lastChar    [CONTEXT]    Token  nextToken  (  Token  tkn  )  throws  IOException  {    int  lastChar  =  in  .  readAgain  (  )  ;              int  c  =  in  .  read  (  )  ;  boolean  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;      if  (  emptyLinesIgnored  )  {  while  (  eol  &&  (  lastChar  =  =  '\n'  ||  lastChar  =  =  '\r'  ||  lastChar  =  =  ExtendedBufferedReader  .  UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {    lastChar  =  c  ;  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;    if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }  }  }    if  (  isEndOfFile  (  lastChar  )  ||  (  !isDelimiter  (  lastChar  )  &&  isEndOfFile  (  c  )  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }    while  (  tkn  .  type  =  =  INVALID  )  {    if  (  surroundingSpacesIgnored  )  {  [ATTENTION]  while  (  isWhitespace  (  c  )  ;  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  }  }    if  (  isCommentStart  (  c  )  )  {    in  .  readLine  (  )  ;  tkn  =  nextToken  (  tkn  .  reset  (  )  )  ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  }  else  if  (  eol  )  {      tkn  .  type  =  EORECORD  ;  }  else  if  (  isEncapsulator  (  c  )  )  {    encapsulatedTokenLexer  (  tkn  ,  c  )  ;  }  else  if  (  isEndOfFile  (  c  )  )  {      tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  there  is  data  at  EOF  }  else  {      simpleTokenLexer  (  tkn  ,  c  )  ;  }  }  return  tkn  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^85^^^^^41^118^
[REPLACE]    c    =    in    .    read    (    )    ;  	[BUGGY]  c  =  in  .  readAgain  (  )  ;    ;  [FE]  [METHOD]    nextToken  [TYPE]  Token  [PARAMETER]  Token  tkn  [CLASS]  CSVLexer    [TYPE]  boolean  eol  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  lastChar    [CONTEXT]    Token  nextToken  (  Token  tkn  )  throws  IOException  {    int  lastChar  =  in  .  readAgain  (  )  ;              int  c  =  in  .  read  (  )  ;  boolean  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;      if  (  emptyLinesIgnored  )  {  while  (  eol  &&  (  lastChar  =  =  '\n'  ||  lastChar  =  =  '\r'  ||  lastChar  =  =  ExtendedBufferedReader  .  UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {    lastChar  =  c  ;  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;    if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }  }  }    if  (  isEndOfFile  (  lastChar  )  ||  (  !isDelimiter  (  lastChar  )  &&  isEndOfFile  (  c  )  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }    while  (  tkn  .  type  =  =  INVALID  )  {    if  (  surroundingSpacesIgnored  )  {  while  (  isWhitespace  (  c  )  &&  !eol  )  {  [ATTENTION]  c  =  in  .  readAgain  (  )    ;    ;  eol  =  isEndOfLine  (  c  )  ;  }  }    if  (  isCommentStart  (  c  )  )  {    in  .  readLine  (  )  ;  tkn  =  nextToken  (  tkn  .  reset  (  )  )  ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  }  else  if  (  eol  )  {      tkn  .  type  =  EORECORD  ;  }  else  if  (  isEncapsulator  (  c  )  )  {    encapsulatedTokenLexer  (  tkn  ,  c  )  ;  }  else  if  (  isEndOfFile  (  c  )  )  {      tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  there  is  data  at  EOF  }  else  {      simpleTokenLexer  (  tkn  ,  c  )  ;  }  }  return  tkn  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^86^^^^^41^118^
[ADD]    c    =    in    .    read    (    )    ;  	[BUGGY]  [FE]  [METHOD]    nextToken  [TYPE]  Token  [PARAMETER]  Token  tkn  [CLASS]  CSVLexer    [TYPE]  boolean  eol  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  lastChar    [CONTEXT]    Token  nextToken  (  Token  tkn  )  throws  IOException  {    int  lastChar  =  in  .  readAgain  (  )  ;              int  c  =  in  .  read  (  )  ;  boolean  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;      if  (  emptyLinesIgnored  )  {  while  (  eol  &&  (  lastChar  =  =  '\n'  ||  lastChar  =  =  '\r'  ||  lastChar  =  =  ExtendedBufferedReader  .  UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {    lastChar  =  c  ;  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;    if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }  }  }    if  (  isEndOfFile  (  lastChar  )  ||  (  !isDelimiter  (  lastChar  )  &&  isEndOfFile  (  c  )  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }    while  (  tkn  .  type  =  =  INVALID  )  {    if  (  surroundingSpacesIgnored  )  {  while  (  isWhitespace  (  c  )  &&  !eol  )  {  [ATTENTION]  eol  =  isEndOfLine  (  c  )  ;  }  }    if  (  isCommentStart  (  c  )  )  {    in  .  readLine  (  )  ;  tkn  =  nextToken  (  tkn  .  reset  (  )  )  ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  }  else  if  (  eol  )  {      tkn  .  type  =  EORECORD  ;  }  else  if  (  isEncapsulator  (  c  )  )  {    encapsulatedTokenLexer  (  tkn  ,  c  )  ;  }  else  if  (  isEndOfFile  (  c  )  )  {      tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  there  is  data  at  EOF  }  else  {      simpleTokenLexer  (  tkn  ,  c  )  ;  }  }  return  tkn  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^86^^^^^41^118^
[REPLACE]    eol    =    isEndOfLine    (    c    )    ;  	[BUGGY]  eol  =    isEndOfLine  (  null  )  ;  [CE]  method  isEndOfLine  in  class  Lexer  cannot  be  applied  to  given  types  ;    [METHOD]    nextToken  [TYPE]  Token  [PARAMETER]  Token  tkn  [CLASS]  CSVLexer    [TYPE]  boolean  eol  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  lastChar    [CONTEXT]    Token  nextToken  (  Token  tkn  )  throws  IOException  {    int  lastChar  =  in  .  readAgain  (  )  ;              int  c  =  in  .  read  (  )  ;  boolean  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;      if  (  emptyLinesIgnored  )  {  while  (  eol  &&  (  lastChar  =  =  '\n'  ||  lastChar  =  =  '\r'  ||  lastChar  =  =  ExtendedBufferedReader  .  UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {    lastChar  =  c  ;  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;    if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }  }  }    if  (  isEndOfFile  (  lastChar  )  ||  (  !isDelimiter  (  lastChar  )  &&  isEndOfFile  (  c  )  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }    while  (  tkn  .  type  =  =  INVALID  )  {    if  (  surroundingSpacesIgnored  )  {  while  (  isWhitespace  (  c  )  &&  !eol  )  {  c  =  in  .  read  (  )  ;  [ATTENTION]  eol  =  isEndOfLine  (  null  )    ;  }  }    if  (  isCommentStart  (  c  )  )  {    in  .  readLine  (  )  ;  tkn  =  nextToken  (  tkn  .  reset  (  )  )  ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  }  else  if  (  eol  )  {      tkn  .  type  =  EORECORD  ;  }  else  if  (  isEncapsulator  (  c  )  )  {    encapsulatedTokenLexer  (  tkn  ,  c  )  ;  }  else  if  (  isEndOfFile  (  c  )  )  {      tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  there  is  data  at  EOF  }  else  {      simpleTokenLexer  (  tkn  ,  c  )  ;  }  }  return  tkn  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^87^^^^^41^118^
[REPLACE]    if    (    surroundingSpacesIgnored    )    {  	[BUGGY]  if  (  isEscape  (  c  )  )  {[FE]    AssertionFailedError    Token  content  expected:<[]hijk>  but  was:<[  ]hijk>  assertTokenEquals(TOKEN  ,     "abc   "  ,  parser.nextToken(new  Token()))      [METHOD]    nextToken  [TYPE]  Token  [PARAMETER]  Token  tkn  [CLASS]  CSVLexer    [TYPE]  boolean  eol  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  lastChar    [CONTEXT]    Token  nextToken  (  Token  tkn  )  throws  IOException  {    int  lastChar  =  in  .  readAgain  (  )  ;              int  c  =  in  .  read  (  )  ;  boolean  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;      if  (  emptyLinesIgnored  )  {  while  (  eol  &&  (  lastChar  =  =  '\n'  ||  lastChar  =  =  '\r'  ||  lastChar  =  =  ExtendedBufferedReader  .  UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {    lastChar  =  c  ;  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;    if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }  }  }    if  (  isEndOfFile  (  lastChar  )  ||  (  !isDelimiter  (  lastChar  )  &&  isEndOfFile  (  c  )  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }    while  (  tkn  .  type  =  =  INVALID  )  {    [ATTENTION]  if  (  isEscape  (  c  )  )  {  while  (  isWhitespace  (  c  )  &&  !eol  )  {  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  }  }    if  (  isCommentStart  (  c  )  )  {    in  .  readLine  (  )  ;  tkn  =  nextToken  (  tkn  .  reset  (  )  )  ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  }  else  if  (  eol  )  {      tkn  .  type  =  EORECORD  ;  }  else  if  (  isEncapsulator  (  c  )  )  {    encapsulatedTokenLexer  (  tkn  ,  c  )  ;  }  else  if  (  isEndOfFile  (  c  )  )  {      tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  there  is  data  at  EOF  }  else  {      simpleTokenLexer  (  tkn  ,  c  )  ;  }  }  return  tkn  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^84^^^^^41^118^
[REPLACE]    while    (    isWhitespace    (    c    )    &&    !eol    )    {  	[BUGGY]  while  (  isWhitespace  (  c  )    >  =    false  )  {[CE]  bad  operand  types  for  binary  operator  '>  =  '    [METHOD]    nextToken  [TYPE]  Token  [PARAMETER]  Token  tkn  [CLASS]  CSVLexer    [TYPE]  boolean  eol  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  lastChar    [CONTEXT]    Token  nextToken  (  Token  tkn  )  throws  IOException  {    int  lastChar  =  in  .  readAgain  (  )  ;              int  c  =  in  .  read  (  )  ;  boolean  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;      if  (  emptyLinesIgnored  )  {  while  (  eol  &&  (  lastChar  =  =  '\n'  ||  lastChar  =  =  '\r'  ||  lastChar  =  =  ExtendedBufferedReader  .  UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {    lastChar  =  c  ;  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;    if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }  }  }    if  (  isEndOfFile  (  lastChar  )  ||  (  !isDelimiter  (  lastChar  )  &&  isEndOfFile  (  c  )  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }    while  (  tkn  .  type  =  =  INVALID  )  {    if  (  surroundingSpacesIgnored  )  {  [ATTENTION]  while  (  isWhitespace  (  c  )  >  =  false  )  {  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  }  }    if  (  isCommentStart  (  c  )  )  {    in  .  readLine  (  )  ;  tkn  =  nextToken  (  tkn  .  reset  (  )  )  ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  }  else  if  (  eol  )  {      tkn  .  type  =  EORECORD  ;  }  else  if  (  isEncapsulator  (  c  )  )  {    encapsulatedTokenLexer  (  tkn  ,  c  )  ;  }  else  if  (  isEndOfFile  (  c  )  )  {      tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  there  is  data  at  EOF  }  else  {      simpleTokenLexer  (  tkn  ,  c  )  ;  }  }  return  tkn  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^85^^^^^41^118^
[REPLACE]    eol    =    isEndOfLine    (    c    )    ;  	[BUGGY]  eol  =    isEndOfLine  (  lastChar  )  ;  [FE]    array  lengths  differed  ,  expected.length  =  3  actual.length  =  1  assertArrayEquals(re  ,  parser.getRecord().values())      [METHOD]    nextToken  [TYPE]  Token  [PARAMETER]  Token  tkn  [CLASS]  CSVLexer    [TYPE]  boolean  eol  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  lastChar    [CONTEXT]    Token  nextToken  (  Token  tkn  )  throws  IOException  {    int  lastChar  =  in  .  readAgain  (  )  ;              int  c  =  in  .  read  (  )  ;  boolean  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;      if  (  emptyLinesIgnored  )  {  while  (  eol  &&  (  lastChar  =  =  '\n'  ||  lastChar  =  =  '\r'  ||  lastChar  =  =  ExtendedBufferedReader  .  UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {    lastChar  =  c  ;  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;    if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }  }  }    if  (  isEndOfFile  (  lastChar  )  ||  (  !isDelimiter  (  lastChar  )  &&  isEndOfFile  (  c  )  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }    while  (  tkn  .  type  =  =  INVALID  )  {    if  (  surroundingSpacesIgnored  )  {  while  (  isWhitespace  (  c  )  &&  !eol  )  {  c  =  in  .  read  (  )  ;  [ATTENTION]  eol  =  isEndOfLine  (  lastChar  )    ;  }  }    if  (  isCommentStart  (  c  )  )  {    in  .  readLine  (  )  ;  tkn  =  nextToken  (  tkn  .  reset  (  )  )  ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  }  else  if  (  eol  )  {      tkn  .  type  =  EORECORD  ;  }  else  if  (  isEncapsulator  (  c  )  )  {    encapsulatedTokenLexer  (  tkn  ,  c  )  ;  }  else  if  (  isEndOfFile  (  c  )  )  {      tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  there  is  data  at  EOF  }  else  {      simpleTokenLexer  (  tkn  ,  c  )  ;  }  }  return  tkn  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^87^^^^^41^118^
[REPLACE]    if    (    isCommentStart    (    c    )    )    {  	[BUGGY]  if  (  isCommentStart  (  lastChar  )  )  {[FE]    AssertionFailedError    Token  content  expected:<[]>  but  was:<[#foo]>  assertTokenEquals(TOKEN  ,     "1   "  ,  parser.nextToken(new  Token()))      [METHOD]    nextToken  [TYPE]  Token  [PARAMETER]  Token  tkn  [CLASS]  CSVLexer    [TYPE]  boolean  eol  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  lastChar    [CONTEXT]    Token  nextToken  (  Token  tkn  )  throws  IOException  {    int  lastChar  =  in  .  readAgain  (  )  ;              int  c  =  in  .  read  (  )  ;  boolean  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;      if  (  emptyLinesIgnored  )  {  while  (  eol  &&  (  lastChar  =  =  '\n'  ||  lastChar  =  =  '\r'  ||  lastChar  =  =  ExtendedBufferedReader  .  UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {    lastChar  =  c  ;  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;    if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }  }  }    if  (  isEndOfFile  (  lastChar  )  ||  (  !isDelimiter  (  lastChar  )  &&  isEndOfFile  (  c  )  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }    while  (  tkn  .  type  =  =  INVALID  )  {    if  (  surroundingSpacesIgnored  )  {  while  (  isWhitespace  (  c  )  &&  !eol  )  {  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  }  }    [ATTENTION]  if  (  isCommentStart  (  lastChar  )  )  {    in  .  readLine  (  )  ;  tkn  =  nextToken  (  tkn  .  reset  (  )  )  ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  }  else  if  (  eol  )  {      tkn  .  type  =  EORECORD  ;  }  else  if  (  isEncapsulator  (  c  )  )  {    encapsulatedTokenLexer  (  tkn  ,  c  )  ;  }  else  if  (  isEndOfFile  (  c  )  )  {      tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  there  is  data  at  EOF  }  else  {      simpleTokenLexer  (  tkn  ,  c  )  ;  }  }  return  tkn  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^92^^^^^41^118^
[REPLACE]    }    else    if    (    isDelimiter    (    c    )    )    {  	[BUGGY]    else  {[CE]  'else'  without  'if'    [METHOD]    nextToken  [TYPE]  Token  [PARAMETER]  Token  tkn  [CLASS]  CSVLexer    [TYPE]  boolean  eol  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  lastChar    [CONTEXT]    Token  nextToken  (  Token  tkn  )  throws  IOException  {    int  lastChar  =  in  .  readAgain  (  )  ;              int  c  =  in  .  read  (  )  ;  boolean  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;      if  (  emptyLinesIgnored  )  {  while  (  eol  &&  (  lastChar  =  =  '\n'  ||  lastChar  =  =  '\r'  ||  lastChar  =  =  ExtendedBufferedReader  .  UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {    lastChar  =  c  ;  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;    if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }  }  }    if  (  isEndOfFile  (  lastChar  )  ||  (  !isDelimiter  (  lastChar  )  &&  isEndOfFile  (  c  )  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }    while  (  tkn  .  type  =  =  INVALID  )  {    if  (  surroundingSpacesIgnored  )  {  while  (  isWhitespace  (  c  )  &&  !eol  )  {  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  }  }    if  (  isCommentStart  (  c  )  )  {    in  .  readLine  (  )  ;  tkn  =  nextToken  (  tkn  .  reset  (  )  )  ;  [ATTENTION]  }else  {    tkn  .  type  =  TOKEN  ;  }  else  if  (  eol  )  {      tkn  .  type  =  EORECORD  ;  }  else  if  (  isEncapsulator  (  c  )  )  {    encapsulatedTokenLexer  (  tkn  ,  c  )  ;  }  else  if  (  isEndOfFile  (  c  )  )  {      tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  there  is  data  at  EOF  }  else  {      simpleTokenLexer  (  tkn  ,  c  )  ;  }  }  return  tkn  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^96^^^^^41^118^
[ADD]    else    if    (    isDelimiter    (    c    )    )    {    tkn    .    type    =    TOKEN;    }    else    if    (    eol    )    {  	[BUGGY]    tkn  .  type  =  TOKEN  ;  [CE]  'else'  without  'if'    [METHOD]    nextToken  [TYPE]  Token  [PARAMETER]  Token  tkn  [CLASS]  CSVLexer    [TYPE]  boolean  eol  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  lastChar    [CONTEXT]    Token  nextToken  (  Token  tkn  )  throws  IOException  {    int  lastChar  =  in  .  readAgain  (  )  ;              int  c  =  in  .  read  (  )  ;  boolean  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;      if  (  emptyLinesIgnored  )  {  while  (  eol  &&  (  lastChar  =  =  '\n'  ||  lastChar  =  =  '\r'  ||  lastChar  =  =  ExtendedBufferedReader  .  UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {    lastChar  =  c  ;  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;    if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }  }  }    if  (  isEndOfFile  (  lastChar  )  ||  (  !isDelimiter  (  lastChar  )  &&  isEndOfFile  (  c  )  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }    while  (  tkn  .  type  =  =  INVALID  )  {    if  (  surroundingSpacesIgnored  )  {  while  (  isWhitespace  (  c  )  &&  !eol  )  {  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  }  }    if  (  isCommentStart  (  c  )  )  {    in  .  readLine  (  )  ;  tkn  =  nextToken  (  tkn  .  reset  (  )  )  ;  [ATTENTION]  }  tkn  .  type  =  TOKEN  ;          tkn  .  type  =  EORECORD  ;  }  else  if  (  isEncapsulator  (  c  )  )  {    encapsulatedTokenLexer  (  tkn  ,  c  )  ;  }  else  if  (  isEndOfFile  (  c  )  )  {      tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  there  is  data  at  EOF  }  else  {      simpleTokenLexer  (  tkn  ,  c  )  ;  }  }  return  tkn  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^96^97^98^99^^41^118^
[REPLACE]    }    else    if    (    eol    )    {  	[BUGGY]    if  (  eol  )  {[FE]    AssertionFailedError    Token  type  expected:<EORECORD>  but  was:<TOKEN>  assertTokenEquals(TOKEN  ,     "1   "  ,  parser.nextToken(new  Token()))      [METHOD]    nextToken  [TYPE]  Token  [PARAMETER]  Token  tkn  [CLASS]  CSVLexer    [TYPE]  boolean  eol  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  lastChar    [CONTEXT]    Token  nextToken  (  Token  tkn  )  throws  IOException  {    int  lastChar  =  in  .  readAgain  (  )  ;              int  c  =  in  .  read  (  )  ;  boolean  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;      if  (  emptyLinesIgnored  )  {  while  (  eol  &&  (  lastChar  =  =  '\n'  ||  lastChar  =  =  '\r'  ||  lastChar  =  =  ExtendedBufferedReader  .  UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {    lastChar  =  c  ;  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;    if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }  }  }    if  (  isEndOfFile  (  lastChar  )  ||  (  !isDelimiter  (  lastChar  )  &&  isEndOfFile  (  c  )  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }    while  (  tkn  .  type  =  =  INVALID  )  {    if  (  surroundingSpacesIgnored  )  {  while  (  isWhitespace  (  c  )  &&  !eol  )  {  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  }  }    if  (  isCommentStart  (  c  )  )  {    in  .  readLine  (  )  ;  tkn  =  nextToken  (  tkn  .  reset  (  )  )  ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  [ATTENTION]  }if  (  eol  )  {      tkn  .  type  =  EORECORD  ;  }  else  if  (  isEncapsulator  (  c  )  )  {    encapsulatedTokenLexer  (  tkn  ,  c  )  ;  }  else  if  (  isEndOfFile  (  c  )  )  {      tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  there  is  data  at  EOF  }  else  {      simpleTokenLexer  (  tkn  ,  c  )  ;  }  }  return  tkn  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^99^^^^^41^118^
[REPLACE]    }    else    if    (    isEncapsulator    (    c    )    )    {  	[BUGGY]    if  (  isEncapsulator  (  c  )  )  {[FE]    AssertionFailedError    Token  type  expected:<EORECORD>  but  was:<TOKEN>  assertTokenEquals(TOKEN  ,     "1   "  ,  parser.nextToken(new  Token()))      [METHOD]    nextToken  [TYPE]  Token  [PARAMETER]  Token  tkn  [CLASS]  CSVLexer    [TYPE]  boolean  eol  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  lastChar    [CONTEXT]    Token  nextToken  (  Token  tkn  )  throws  IOException  {    int  lastChar  =  in  .  readAgain  (  )  ;              int  c  =  in  .  read  (  )  ;  boolean  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;      if  (  emptyLinesIgnored  )  {  while  (  eol  &&  (  lastChar  =  =  '\n'  ||  lastChar  =  =  '\r'  ||  lastChar  =  =  ExtendedBufferedReader  .  UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {    lastChar  =  c  ;  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;    if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }  }  }    if  (  isEndOfFile  (  lastChar  )  ||  (  !isDelimiter  (  lastChar  )  &&  isEndOfFile  (  c  )  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }    while  (  tkn  .  type  =  =  INVALID  )  {    if  (  surroundingSpacesIgnored  )  {  while  (  isWhitespace  (  c  )  &&  !eol  )  {  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  }  }    if  (  isCommentStart  (  c  )  )  {    in  .  readLine  (  )  ;  tkn  =  nextToken  (  tkn  .  reset  (  )  )  ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  }  else  if  (  eol  )  {      tkn  .  type  =  EORECORD  ;  [ATTENTION]  }if  (  isEncapsulator  (  c  )  )  {    encapsulatedTokenLexer  (  tkn  ,  c  )  ;  }  else  if  (  isEndOfFile  (  c  )  )  {      tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  there  is  data  at  EOF  }  else  {      simpleTokenLexer  (  tkn  ,  c  )  ;  }  }  return  tkn  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^103^^^^^41^118^
[ADD]    else    if    (    isEncapsulator    (    c    )    )    {    encapsulatedTokenLexer    (    tkn,    c    )    ;    }    else    if    (    isEndOfFile    (    c    )    )    {  	[BUGGY]    encapsulatedTokenLexer  (  tkn  ,  c  )  ;  [CE]  'else'  without  'if'    [METHOD]    nextToken  [TYPE]  Token  [PARAMETER]  Token  tkn  [CLASS]  CSVLexer    [TYPE]  boolean  eol  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  lastChar    [CONTEXT]    Token  nextToken  (  Token  tkn  )  throws  IOException  {    int  lastChar  =  in  .  readAgain  (  )  ;              int  c  =  in  .  read  (  )  ;  boolean  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;      if  (  emptyLinesIgnored  )  {  while  (  eol  &&  (  lastChar  =  =  '\n'  ||  lastChar  =  =  '\r'  ||  lastChar  =  =  ExtendedBufferedReader  .  UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {    lastChar  =  c  ;  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;    if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }  }  }    if  (  isEndOfFile  (  lastChar  )  ||  (  !isDelimiter  (  lastChar  )  &&  isEndOfFile  (  c  )  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }    while  (  tkn  .  type  =  =  INVALID  )  {    if  (  surroundingSpacesIgnored  )  {  while  (  isWhitespace  (  c  )  &&  !eol  )  {  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  }  }    if  (  isCommentStart  (  c  )  )  {    in  .  readLine  (  )  ;  tkn  =  nextToken  (  tkn  .  reset  (  )  )  ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  }  else  if  (  eol  )  {      tkn  .  type  =  EORECORD  ;  [ATTENTION]  }  encapsulatedTokenLexer  (  tkn  ,  c  )    ;          tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  there  is  data  at  EOF  }  else  {      simpleTokenLexer  (  tkn  ,  c  )  ;  }  }  return  tkn  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^103^104^105^106^^41^118^
[REPLACE]    }    else    if    (    isEndOfFile    (    c    )    )    {  	[BUGGY]    else  {[CE]  'else'  without  'if'    [METHOD]    nextToken  [TYPE]  Token  [PARAMETER]  Token  tkn  [CLASS]  CSVLexer    [TYPE]  boolean  eol  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  lastChar    [CONTEXT]    Token  nextToken  (  Token  tkn  )  throws  IOException  {    int  lastChar  =  in  .  readAgain  (  )  ;              int  c  =  in  .  read  (  )  ;  boolean  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;      if  (  emptyLinesIgnored  )  {  while  (  eol  &&  (  lastChar  =  =  '\n'  ||  lastChar  =  =  '\r'  ||  lastChar  =  =  ExtendedBufferedReader  .  UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {    lastChar  =  c  ;  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;    if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }  }  }    if  (  isEndOfFile  (  lastChar  )  ||  (  !isDelimiter  (  lastChar  )  &&  isEndOfFile  (  c  )  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }    while  (  tkn  .  type  =  =  INVALID  )  {    if  (  surroundingSpacesIgnored  )  {  while  (  isWhitespace  (  c  )  &&  !eol  )  {  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  }  }    if  (  isCommentStart  (  c  )  )  {    in  .  readLine  (  )  ;  tkn  =  nextToken  (  tkn  .  reset  (  )  )  ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  }  else  if  (  eol  )  {      tkn  .  type  =  EORECORD  ;  }  else  if  (  isEncapsulator  (  c  )  )  {    encapsulatedTokenLexer  (  tkn  ,  c  )  ;  [ATTENTION]  }else  {      tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  there  is  data  at  EOF  }  else  {      simpleTokenLexer  (  tkn  ,  c  )  ;  }  }  return  tkn  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^106^^^^^41^118^
[ADD]    else    if    (    isEndOfFile    (    c    )    )    {    tkn    .    type    =    EOF;    tkn    .    isReady    =    true;  	[BUGGY]    tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  [CE]  'else'  without  'if'    [METHOD]    nextToken  [TYPE]  Token  [PARAMETER]  Token  tkn  [CLASS]  CSVLexer    [TYPE]  boolean  eol  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  lastChar    [CONTEXT]    Token  nextToken  (  Token  tkn  )  throws  IOException  {    int  lastChar  =  in  .  readAgain  (  )  ;              int  c  =  in  .  read  (  )  ;  boolean  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;      if  (  emptyLinesIgnored  )  {  while  (  eol  &&  (  lastChar  =  =  '\n'  ||  lastChar  =  =  '\r'  ||  lastChar  =  =  ExtendedBufferedReader  .  UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {    lastChar  =  c  ;  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;    if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }  }  }    if  (  isEndOfFile  (  lastChar  )  ||  (  !isDelimiter  (  lastChar  )  &&  isEndOfFile  (  c  )  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }    while  (  tkn  .  type  =  =  INVALID  )  {    if  (  surroundingSpacesIgnored  )  {  while  (  isWhitespace  (  c  )  &&  !eol  )  {  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  }  }    if  (  isCommentStart  (  c  )  )  {    in  .  readLine  (  )  ;  tkn  =  nextToken  (  tkn  .  reset  (  )  )  ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  }  else  if  (  eol  )  {      tkn  .  type  =  EORECORD  ;  }  else  if  (  isEncapsulator  (  c  )  )  {    encapsulatedTokenLexer  (  tkn  ,  c  )  ;  [ATTENTION]  }  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;        }  else  {      simpleTokenLexer  (  tkn  ,  c  )  ;  }  }  return  tkn  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^106^107^^109^110^41^118^
[REPLACE]    simpleTokenLexer    (    tkn,    c    )    ;  	[BUGGY]  tkn  =  nextToken  (  tkn  .  reset  (  )  )  ;  [FE]    AssertionFailedError    Token  content  expected:<[abc]>  but  was:<[]>  assertTokenEquals(TOKEN  ,     "abc   "  ,  parser.nextToken(new  Token()))      [METHOD]    nextToken  [TYPE]  Token  [PARAMETER]  Token  tkn  [CLASS]  CSVLexer    [TYPE]  boolean  eol  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  lastChar    [CONTEXT]    }  else  if  (  isEndOfFile  (  c  )  )  {      tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  there  is  data  at  EOF  }  else  {      [ATTENTION]  tkn  =  nextToken  (  tkn  .  reset  (  )  )    ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^114^^^^^106^115^
[ADD]    simpleTokenLexer    (    tkn,    c    )    ;  	[BUGGY]  [FE]  [METHOD]    nextToken  [TYPE]  Token  [PARAMETER]  Token  tkn  [CLASS]  CSVLexer    [TYPE]  boolean  eol  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  lastChar    [CONTEXT]    }  else  if  (  isEndOfFile  (  c  )  )  {      tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  there  is  data  at  EOF  }  else  {      [ATTENTION]  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^114^^^^^106^115^
[REPLACE]    tkn    .    type    =    EOF;  	[BUGGY]  tkn  .  type  =  TOKEN  ;    ;  [FE]    AssertionFailedError    Token  type  expected:<EOF>  but  was:<TOKEN>  assertTokenEquals(TOKEN  ,     "abc   "  ,  parser.nextToken(new  Token()))      [METHOD]    nextToken  [TYPE]  Token  [PARAMETER]  Token  tkn  [CLASS]  CSVLexer    [TYPE]  boolean  eol  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  lastChar    [CONTEXT]    Token  nextToken  (  Token  tkn  )  throws  IOException  {    int  lastChar  =  in  .  readAgain  (  )  ;              int  c  =  in  .  read  (  )  ;  boolean  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;      if  (  emptyLinesIgnored  )  {  while  (  eol  &&  (  lastChar  =  =  '\n'  ||  lastChar  =  =  '\r'  ||  lastChar  =  =  ExtendedBufferedReader  .  UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {    lastChar  =  c  ;  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;    if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }  }  }    if  (  isEndOfFile  (  lastChar  )  ||  (  !isDelimiter  (  lastChar  )  &&  isEndOfFile  (  c  )  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }    while  (  tkn  .  type  =  =  INVALID  )  {    if  (  surroundingSpacesIgnored  )  {  while  (  isWhitespace  (  c  )  &&  !eol  )  {  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  }  }    if  (  isCommentStart  (  c  )  )  {    in  .  readLine  (  )  ;  tkn  =  nextToken  (  tkn  .  reset  (  )  )  ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  }  else  if  (  eol  )  {      tkn  .  type  =  EORECORD  ;  }  else  if  (  isEncapsulator  (  c  )  )  {    encapsulatedTokenLexer  (  tkn  ,  c  )  ;  }  else  if  (  isEndOfFile  (  c  )  )  {      [ATTENTION]  tkn  .  type  =  TOKEN  ;    ;  tkn  .  isReady  =  true  ;  //  there  is  data  at  EOF  }  else  {      simpleTokenLexer  (  tkn  ,  c  )  ;  }  }  return  tkn  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^109^^^^^41^118^
[REPLACE]    tkn    .    isReady    =    true;  	[BUGGY]  tkn  .  isReady  =  false  ;  [FE]    array  lengths  differed  ,  expected.length  =  2  actual.length  =  1  assertEquals(res.length  ,  records.size())      [METHOD]    nextToken  [TYPE]  Token  [PARAMETER]  Token  tkn  [CLASS]  CSVLexer    [TYPE]  boolean  eol  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  lastChar    [CONTEXT]    Token  nextToken  (  Token  tkn  )  throws  IOException  {    int  lastChar  =  in  .  readAgain  (  )  ;              int  c  =  in  .  read  (  )  ;  boolean  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;      if  (  emptyLinesIgnored  )  {  while  (  eol  &&  (  lastChar  =  =  '\n'  ||  lastChar  =  =  '\r'  ||  lastChar  =  =  ExtendedBufferedReader  .  UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {    lastChar  =  c  ;  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;    if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }  }  }    if  (  isEndOfFile  (  lastChar  )  ||  (  !isDelimiter  (  lastChar  )  &&  isEndOfFile  (  c  )  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }    while  (  tkn  .  type  =  =  INVALID  )  {    if  (  surroundingSpacesIgnored  )  {  while  (  isWhitespace  (  c  )  &&  !eol  )  {  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  }  }    if  (  isCommentStart  (  c  )  )  {    in  .  readLine  (  )  ;  tkn  =  nextToken  (  tkn  .  reset  (  )  )  ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  }  else  if  (  eol  )  {      tkn  .  type  =  EORECORD  ;  }  else  if  (  isEncapsulator  (  c  )  )  {    encapsulatedTokenLexer  (  tkn  ,  c  )  ;  }  else  if  (  isEndOfFile  (  c  )  )  {      tkn  .  type  =  EOF  ;  [ATTENTION]  tkn  .  isReady  =  false  ;  }  else  {      simpleTokenLexer  (  tkn  ,  c  )  ;  }  }  return  tkn  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^110^^^^^41^118^
[ADD]    tkn    .    isReady    =    true;  	[BUGGY]  [FE]    array  lengths  differed  ,  expected.length  =  2  actual.length  =  1  assertEquals(res.length  ,  records.size())      [METHOD]    nextToken  [TYPE]  Token  [PARAMETER]  Token  tkn  [CLASS]  CSVLexer    [TYPE]  boolean  eol  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  lastChar    [CONTEXT]    Token  nextToken  (  Token  tkn  )  throws  IOException  {    int  lastChar  =  in  .  readAgain  (  )  ;              int  c  =  in  .  read  (  )  ;  boolean  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;      if  (  emptyLinesIgnored  )  {  while  (  eol  &&  (  lastChar  =  =  '\n'  ||  lastChar  =  =  '\r'  ||  lastChar  =  =  ExtendedBufferedReader  .  UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {    lastChar  =  c  ;  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;    if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }  }  }    if  (  isEndOfFile  (  lastChar  )  ||  (  !isDelimiter  (  lastChar  )  &&  isEndOfFile  (  c  )  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }    while  (  tkn  .  type  =  =  INVALID  )  {    if  (  surroundingSpacesIgnored  )  {  while  (  isWhitespace  (  c  )  &&  !eol  )  {  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  }  }    if  (  isCommentStart  (  c  )  )  {    in  .  readLine  (  )  ;  tkn  =  nextToken  (  tkn  .  reset  (  )  )  ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  }  else  if  (  eol  )  {      tkn  .  type  =  EORECORD  ;  }  else  if  (  isEncapsulator  (  c  )  )  {    encapsulatedTokenLexer  (  tkn  ,  c  )  ;  }  else  if  (  isEndOfFile  (  c  )  )  {      tkn  .  type  =  EOF  ;  [ATTENTION]  }  else  {      simpleTokenLexer  (  tkn  ,  c  )  ;  }  }  return  tkn  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^110^^^^^41^118^
[REPLACE]    encapsulatedTokenLexer    (    tkn,    c    )    ;  	[BUGGY]  encapsulatedTokenLexer  (  tkn  ,  lastChar  )  ;  [NO-ERROR]    [METHOD]    nextToken  [TYPE]  Token  [PARAMETER]  Token  tkn  [CLASS]  CSVLexer    [TYPE]  boolean  eol  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  lastChar    [CONTEXT]    Token  nextToken  (  Token  tkn  )  throws  IOException  {    int  lastChar  =  in  .  readAgain  (  )  ;              int  c  =  in  .  read  (  )  ;  boolean  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;      if  (  emptyLinesIgnored  )  {  while  (  eol  &&  (  lastChar  =  =  '\n'  ||  lastChar  =  =  '\r'  ||  lastChar  =  =  ExtendedBufferedReader  .  UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {    lastChar  =  c  ;  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;    if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }  }  }    if  (  isEndOfFile  (  lastChar  )  ||  (  !isDelimiter  (  lastChar  )  &&  isEndOfFile  (  c  )  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }    while  (  tkn  .  type  =  =  INVALID  )  {    if  (  surroundingSpacesIgnored  )  {  while  (  isWhitespace  (  c  )  &&  !eol  )  {  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  }  }    if  (  isCommentStart  (  c  )  )  {    in  .  readLine  (  )  ;  tkn  =  nextToken  (  tkn  .  reset  (  )  )  ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  }  else  if  (  eol  )  {      tkn  .  type  =  EORECORD  ;  }  else  if  (  isEncapsulator  (  c  )  )  {    [ATTENTION]  encapsulatedTokenLexer  (  tkn  ,  lastChar  )    ;  }  else  if  (  isEndOfFile  (  c  )  )  {      tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  there  is  data  at  EOF  }  else  {      simpleTokenLexer  (  tkn  ,  c  )  ;  }  }  return  tkn  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^105^^^^^41^118^
[REMOVE]      	[BUGGY]  if  (  isEncapsulator  (  c  )  )  {      encapsulatedTokenLexer  (  tkn  ,  c  )  ;  }else      if  (  isEndOfFile  (  c  )  )  {          tkn  .  type  =  EOF  ;          tkn  .  isReady  =  true  ;      }else  {          simpleTokenLexer  (  tkn  ,  c  )  ;      }[NO-ERROR]    [METHOD]    nextToken  [TYPE]  Token  [PARAMETER]  Token  tkn  [CLASS]  CSVLexer    [TYPE]  boolean  eol  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  lastChar    [CONTEXT]    Token  nextToken  (  Token  tkn  )  throws  IOException  {    int  lastChar  =  in  .  readAgain  (  )  ;              int  c  =  in  .  read  (  )  ;  boolean  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;      if  (  emptyLinesIgnored  )  {  while  (  eol  &&  (  lastChar  =  =  '\n'  ||  lastChar  =  =  '\r'  ||  lastChar  =  =  ExtendedBufferedReader  .  UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {    lastChar  =  c  ;  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;    if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }  }  }    if  (  isEndOfFile  (  lastChar  )  ||  (  !isDelimiter  (  lastChar  )  &&  isEndOfFile  (  c  )  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }    while  (  tkn  .  type  =  =  INVALID  )  {    if  (  surroundingSpacesIgnored  )  {  while  (  isWhitespace  (  c  )  &&  !eol  )  {  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  }  }    if  (  isCommentStart  (  c  )  )  {    in  .  readLine  (  )  ;  tkn  =  nextToken  (  tkn  .  reset  (  )  )  ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  }  else  if  (  eol  )  {      tkn  .  type  =  EORECORD  ;  }  else  if  (  isEncapsulator  (  c  )  )  {    encapsulatedTokenLexer  (  tkn  ,  c  )  ;  [ATTENTION]  }  else  if  (  isEndOfFile  (  c  )  )  {  if  (  isEncapsulator  (  c  )  )  {  encapsulatedTokenLexer  (  tkn  ,  c  )    ;  }else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  }else  {  simpleTokenLexer  (  tkn  ,  c  )    ;  }//  end  of  file  return  EOF  (  )    tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  there  is  data  at  EOF  }  else  {      simpleTokenLexer  (  tkn  ,  c  )  ;  }  }  return  tkn  ;      	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^106^^^^^41^118^
[REPLACE]    simpleTokenLexer    (    tkn,    c    )    ;  	[BUGGY]  simpleTokenLexer  (  tkn  ,  lastChar  )  ;  [FE]    AssertionFailedError    Token  content  expected:<[a]bc>  but  was:<[  assertTokenEquals(TOKEN  ,     "abc   "  ,  parser.nextToken(new  Token()))      [METHOD]    nextToken  [TYPE]  Token  [PARAMETER]  Token  tkn  [CLASS]  CSVLexer    [TYPE]  boolean  eol  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  lastChar    [CONTEXT]    }  else  if  (  isEndOfFile  (  c  )  )  {      tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  there  is  data  at  EOF  }  else  {      [ATTENTION]  simpleTokenLexer  (  tkn  ,  lastChar  )    ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^114^^^^^106^115^
[REPLACE]    tkn    .    type    =    EORECORD;  	[BUGGY]  tkn  .  type    =  null  ;  [FE]    AssertionFailedError    Token  type  expected:<EORECORD>  but  was:<null>  assertTokenEquals(TOKEN  ,     "1   "  ,  parser.nextToken(new  Token()))      [METHOD]    nextToken  [TYPE]  Token  [PARAMETER]  Token  tkn  [CLASS]  CSVLexer    [TYPE]  boolean  eol  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  lastChar    [CONTEXT]    Token  nextToken  (  Token  tkn  )  throws  IOException  {    int  lastChar  =  in  .  readAgain  (  )  ;              int  c  =  in  .  read  (  )  ;  boolean  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;      if  (  emptyLinesIgnored  )  {  while  (  eol  &&  (  lastChar  =  =  '\n'  ||  lastChar  =  =  '\r'  ||  lastChar  =  =  ExtendedBufferedReader  .  UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {    lastChar  =  c  ;  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;    if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }  }  }    if  (  isEndOfFile  (  lastChar  )  ||  (  !isDelimiter  (  lastChar  )  &&  isEndOfFile  (  c  )  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }    while  (  tkn  .  type  =  =  INVALID  )  {    if  (  surroundingSpacesIgnored  )  {  while  (  isWhitespace  (  c  )  &&  !eol  )  {  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  }  }    if  (  isCommentStart  (  c  )  )  {    in  .  readLine  (  )  ;  tkn  =  nextToken  (  tkn  .  reset  (  )  )  ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  }  else  if  (  eol  )  {      [ATTENTION]  tkn  .  type  =  null  ;  }  else  if  (  isEncapsulator  (  c  )  )  {    encapsulatedTokenLexer  (  tkn  ,  c  )  ;  }  else  if  (  isEndOfFile  (  c  )  )  {      tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  there  is  data  at  EOF  }  else  {      simpleTokenLexer  (  tkn  ,  c  )  ;  }  }  return  tkn  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^102^^^^^41^118^
[REPLACE]    }    else    if    (    isEncapsulator    (    c    )    )    {  	[BUGGY]    else  {[CE]  'else'  without  'if'    [METHOD]    nextToken  [TYPE]  Token  [PARAMETER]  Token  tkn  [CLASS]  CSVLexer    [TYPE]  boolean  eol  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  lastChar    [CONTEXT]    Token  nextToken  (  Token  tkn  )  throws  IOException  {    int  lastChar  =  in  .  readAgain  (  )  ;              int  c  =  in  .  read  (  )  ;  boolean  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;      if  (  emptyLinesIgnored  )  {  while  (  eol  &&  (  lastChar  =  =  '\n'  ||  lastChar  =  =  '\r'  ||  lastChar  =  =  ExtendedBufferedReader  .  UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {    lastChar  =  c  ;  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;    if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }  }  }    if  (  isEndOfFile  (  lastChar  )  ||  (  !isDelimiter  (  lastChar  )  &&  isEndOfFile  (  c  )  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }    while  (  tkn  .  type  =  =  INVALID  )  {    if  (  surroundingSpacesIgnored  )  {  while  (  isWhitespace  (  c  )  &&  !eol  )  {  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  }  }    if  (  isCommentStart  (  c  )  )  {    in  .  readLine  (  )  ;  tkn  =  nextToken  (  tkn  .  reset  (  )  )  ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  }  else  if  (  eol  )  {      tkn  .  type  =  EORECORD  ;  [ATTENTION]  }else  {    encapsulatedTokenLexer  (  tkn  ,  c  )  ;  }  else  if  (  isEndOfFile  (  c  )  )  {      tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  there  is  data  at  EOF  }  else  {      simpleTokenLexer  (  tkn  ,  c  )  ;  }  }  return  tkn  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^103^^^^^41^118^
[ADD]    tkn    .    type    =    EOF;  	[BUGGY]  [FE]  [METHOD]    nextToken  [TYPE]  Token  [PARAMETER]  Token  tkn  [CLASS]  CSVLexer    [TYPE]  boolean  eol  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  lastChar    [CONTEXT]    Token  nextToken  (  Token  tkn  )  throws  IOException  {    int  lastChar  =  in  .  readAgain  (  )  ;              int  c  =  in  .  read  (  )  ;  boolean  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;      if  (  emptyLinesIgnored  )  {  while  (  eol  &&  (  lastChar  =  =  '\n'  ||  lastChar  =  =  '\r'  ||  lastChar  =  =  ExtendedBufferedReader  .  UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {    lastChar  =  c  ;  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;    if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }  }  }    if  (  isEndOfFile  (  lastChar  )  ||  (  !isDelimiter  (  lastChar  )  &&  isEndOfFile  (  c  )  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }    while  (  tkn  .  type  =  =  INVALID  )  {    if  (  surroundingSpacesIgnored  )  {  while  (  isWhitespace  (  c  )  &&  !eol  )  {  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  }  }    if  (  isCommentStart  (  c  )  )  {    in  .  readLine  (  )  ;  tkn  =  nextToken  (  tkn  .  reset  (  )  )  ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  }  else  if  (  eol  )  {      tkn  .  type  =  EORECORD  ;  }  else  if  (  isEncapsulator  (  c  )  )  {    encapsulatedTokenLexer  (  tkn  ,  c  )  ;  }  else  if  (  isEndOfFile  (  c  )  )  {      [ATTENTION]  tkn  .  isReady  =  true  ;  //  there  is  data  at  EOF  }  else  {      simpleTokenLexer  (  tkn  ,  c  )  ;  }  }  return  tkn  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^109^^^^^41^118^
[REPLACE]    encapsulatedTokenLexer    (    tkn,    c    )    ;  	[BUGGY]  if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {[CE]  illegal  start  of  expression    [METHOD]    nextToken  [TYPE]  Token  [PARAMETER]  Token  tkn  [CLASS]  CSVLexer    [TYPE]  boolean  eol  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  lastChar    [CONTEXT]    Token  nextToken  (  Token  tkn  )  throws  IOException  {    int  lastChar  =  in  .  readAgain  (  )  ;              int  c  =  in  .  read  (  )  ;  boolean  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;      if  (  emptyLinesIgnored  )  {  while  (  eol  &&  (  lastChar  =  =  '\n'  ||  lastChar  =  =  '\r'  ||  lastChar  =  =  ExtendedBufferedReader  .  UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {    lastChar  =  c  ;  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;    if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }  }  }    if  (  isEndOfFile  (  lastChar  )  ||  (  !isDelimiter  (  lastChar  )  &&  isEndOfFile  (  c  )  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }    while  (  tkn  .  type  =  =  INVALID  )  {    if  (  surroundingSpacesIgnored  )  {  while  (  isWhitespace  (  c  )  &&  !eol  )  {  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  }  }    if  (  isCommentStart  (  c  )  )  {    in  .  readLine  (  )  ;  tkn  =  nextToken  (  tkn  .  reset  (  )  )  ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  }  else  if  (  eol  )  {      tkn  .  type  =  EORECORD  ;  }  else  if  (  isEncapsulator  (  c  )  )  {    [ATTENTION]  if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {  }  else  if  (  isEndOfFile  (  c  )  )  {      tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  there  is  data  at  EOF  }  else  {      simpleTokenLexer  (  tkn  ,  c  )  ;  }  }  return  tkn  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^105^^^^^41^118^
[ADD]    encapsulatedTokenLexer    (    tkn,    c    )    ;  	[BUGGY]  [FE]  [METHOD]    nextToken  [TYPE]  Token  [PARAMETER]  Token  tkn  [CLASS]  CSVLexer    [TYPE]  boolean  eol  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  lastChar    [CONTEXT]    Token  nextToken  (  Token  tkn  )  throws  IOException  {    int  lastChar  =  in  .  readAgain  (  )  ;              int  c  =  in  .  read  (  )  ;  boolean  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;      if  (  emptyLinesIgnored  )  {  while  (  eol  &&  (  lastChar  =  =  '\n'  ||  lastChar  =  =  '\r'  ||  lastChar  =  =  ExtendedBufferedReader  .  UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {    lastChar  =  c  ;  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;    if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }  }  }    if  (  isEndOfFile  (  lastChar  )  ||  (  !isDelimiter  (  lastChar  )  &&  isEndOfFile  (  c  )  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }    while  (  tkn  .  type  =  =  INVALID  )  {    if  (  surroundingSpacesIgnored  )  {  while  (  isWhitespace  (  c  )  &&  !eol  )  {  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  }  }    if  (  isCommentStart  (  c  )  )  {    in  .  readLine  (  )  ;  tkn  =  nextToken  (  tkn  .  reset  (  )  )  ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  }  else  if  (  eol  )  {      tkn  .  type  =  EORECORD  ;  }  else  if  (  isEncapsulator  (  c  )  )  {    [ATTENTION]  }  else  if  (  isEndOfFile  (  c  )  )  {      tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  there  is  data  at  EOF  }  else  {      simpleTokenLexer  (  tkn  ,  c  )  ;  }  }  return  tkn  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^105^^^^^41^118^
[REPLACE]    }    else    if    (    isEndOfFile    (    c    )    )    {  	[BUGGY]    if  (  isEndOfFile  (  lastChar  )  )  {[FE]    AssertionFailedError    Token  type  expected:<EORECORD>  but  was:<TOKEN>  assertTokenEquals(TOKEN  ,     "1   "  ,  parser.nextToken(new  Token()))      [METHOD]    nextToken  [TYPE]  Token  [PARAMETER]  Token  tkn  [CLASS]  CSVLexer    [TYPE]  boolean  eol  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  lastChar    [CONTEXT]    Token  nextToken  (  Token  tkn  )  throws  IOException  {    int  lastChar  =  in  .  readAgain  (  )  ;              int  c  =  in  .  read  (  )  ;  boolean  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;      if  (  emptyLinesIgnored  )  {  while  (  eol  &&  (  lastChar  =  =  '\n'  ||  lastChar  =  =  '\r'  ||  lastChar  =  =  ExtendedBufferedReader  .  UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {    lastChar  =  c  ;  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;    if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }  }  }    if  (  isEndOfFile  (  lastChar  )  ||  (  !isDelimiter  (  lastChar  )  &&  isEndOfFile  (  c  )  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }    while  (  tkn  .  type  =  =  INVALID  )  {    if  (  surroundingSpacesIgnored  )  {  while  (  isWhitespace  (  c  )  &&  !eol  )  {  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  }  }    if  (  isCommentStart  (  c  )  )  {    in  .  readLine  (  )  ;  tkn  =  nextToken  (  tkn  .  reset  (  )  )  ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  }  else  if  (  eol  )  {      tkn  .  type  =  EORECORD  ;  }  else  if  (  isEncapsulator  (  c  )  )  {    encapsulatedTokenLexer  (  tkn  ,  c  )  ;  [ATTENTION]  }if  (  isEndOfFile  (  lastChar  )  )  {      tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  there  is  data  at  EOF  }  else  {      simpleTokenLexer  (  tkn  ,  c  )  ;  }  }  return  tkn  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^106^^^^^41^118^
[ADD]    tkn    .    type    =    EOF;    tkn    .    isReady    =    true;  	[BUGGY]  [FE]  [METHOD]    nextToken  [TYPE]  Token  [PARAMETER]  Token  tkn  [CLASS]  CSVLexer    [TYPE]  boolean  eol  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  lastChar    [CONTEXT]    Token  nextToken  (  Token  tkn  )  throws  IOException  {    int  lastChar  =  in  .  readAgain  (  )  ;              int  c  =  in  .  read  (  )  ;  boolean  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;      if  (  emptyLinesIgnored  )  {  while  (  eol  &&  (  lastChar  =  =  '\n'  ||  lastChar  =  =  '\r'  ||  lastChar  =  =  ExtendedBufferedReader  .  UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {    lastChar  =  c  ;  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;    if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }  }  }    if  (  isEndOfFile  (  lastChar  )  ||  (  !isDelimiter  (  lastChar  )  &&  isEndOfFile  (  c  )  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }    while  (  tkn  .  type  =  =  INVALID  )  {    if  (  surroundingSpacesIgnored  )  {  while  (  isWhitespace  (  c  )  &&  !eol  )  {  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  }  }    if  (  isCommentStart  (  c  )  )  {    in  .  readLine  (  )  ;  tkn  =  nextToken  (  tkn  .  reset  (  )  )  ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  }  else  if  (  eol  )  {      tkn  .  type  =  EORECORD  ;  }  else  if  (  isEncapsulator  (  c  )  )  {    encapsulatedTokenLexer  (  tkn  ,  c  )  ;  }  else  if  (  isEndOfFile  (  c  )  )  {      [ATTENTION]    }  else  {      simpleTokenLexer  (  tkn  ,  c  )  ;  }  }  return  tkn  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^109^110^^^^41^118^
[REPLACE]    tkn    .    type    =    TOKEN;  	[BUGGY]  tkn  .  type  =  EOF  ;    ;  [FE]    AssertionFailedError    Token  type  expected:<TOKEN>  but  was:<EOF>  assertTokenEquals(TOKEN  ,     "abc   "  ,  parser.nextToken(new  Token()))      [METHOD]    nextToken  [TYPE]  Token  [PARAMETER]  Token  tkn  [CLASS]  CSVLexer    [TYPE]  boolean  eol  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  lastChar    [CONTEXT]    Token  nextToken  (  Token  tkn  )  throws  IOException  {    int  lastChar  =  in  .  readAgain  (  )  ;              int  c  =  in  .  read  (  )  ;  boolean  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;      if  (  emptyLinesIgnored  )  {  while  (  eol  &&  (  lastChar  =  =  '\n'  ||  lastChar  =  =  '\r'  ||  lastChar  =  =  ExtendedBufferedReader  .  UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {    lastChar  =  c  ;  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;    if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }  }  }    if  (  isEndOfFile  (  lastChar  )  ||  (  !isDelimiter  (  lastChar  )  &&  isEndOfFile  (  c  )  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }    while  (  tkn  .  type  =  =  INVALID  )  {    if  (  surroundingSpacesIgnored  )  {  while  (  isWhitespace  (  c  )  &&  !eol  )  {  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  }  }    if  (  isCommentStart  (  c  )  )  {    in  .  readLine  (  )  ;  tkn  =  nextToken  (  tkn  .  reset  (  )  )  ;  }  else  if  (  isDelimiter  (  c  )  )  {    [ATTENTION]  tkn  .  type  =  EOF  ;    ;  }  else  if  (  eol  )  {      tkn  .  type  =  EORECORD  ;  }  else  if  (  isEncapsulator  (  c  )  )  {    encapsulatedTokenLexer  (  tkn  ,  c  )  ;  }  else  if  (  isEndOfFile  (  c  )  )  {      tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  there  is  data  at  EOF  }  else  {      simpleTokenLexer  (  tkn  ,  c  )  ;  }  }  return  tkn  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^98^^^^^41^118^
[REPLACE]    }    else    if    (    eol    )    {  	[BUGGY]    else  {[CE]  'else'  without  'if'    [METHOD]    nextToken  [TYPE]  Token  [PARAMETER]  Token  tkn  [CLASS]  CSVLexer    [TYPE]  boolean  eol  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  lastChar    [CONTEXT]    Token  nextToken  (  Token  tkn  )  throws  IOException  {    int  lastChar  =  in  .  readAgain  (  )  ;              int  c  =  in  .  read  (  )  ;  boolean  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;      if  (  emptyLinesIgnored  )  {  while  (  eol  &&  (  lastChar  =  =  '\n'  ||  lastChar  =  =  '\r'  ||  lastChar  =  =  ExtendedBufferedReader  .  UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {    lastChar  =  c  ;  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;    if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }  }  }    if  (  isEndOfFile  (  lastChar  )  ||  (  !isDelimiter  (  lastChar  )  &&  isEndOfFile  (  c  )  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }    while  (  tkn  .  type  =  =  INVALID  )  {    if  (  surroundingSpacesIgnored  )  {  while  (  isWhitespace  (  c  )  &&  !eol  )  {  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  }  }    if  (  isCommentStart  (  c  )  )  {    in  .  readLine  (  )  ;  tkn  =  nextToken  (  tkn  .  reset  (  )  )  ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  [ATTENTION]  }else  {      tkn  .  type  =  EORECORD  ;  }  else  if  (  isEncapsulator  (  c  )  )  {    encapsulatedTokenLexer  (  tkn  ,  c  )  ;  }  else  if  (  isEndOfFile  (  c  )  )  {      tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  there  is  data  at  EOF  }  else  {      simpleTokenLexer  (  tkn  ,  c  )  ;  }  }  return  tkn  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^99^^^^^41^118^
[REPLACE]    }    else    if    (    isEncapsulator    (    c    )    )    {  	[BUGGY]    if  (  isEncapsulator  (  lastChar  )  )  {[FE]    AssertionFailedError    Token  type  expected:<EORECORD>  but  was:<TOKEN>  assertTokenEquals(TOKEN  ,     "1   "  ,  parser.nextToken(new  Token()))      [METHOD]    nextToken  [TYPE]  Token  [PARAMETER]  Token  tkn  [CLASS]  CSVLexer    [TYPE]  boolean  eol  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  lastChar    [CONTEXT]    Token  nextToken  (  Token  tkn  )  throws  IOException  {    int  lastChar  =  in  .  readAgain  (  )  ;              int  c  =  in  .  read  (  )  ;  boolean  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;      if  (  emptyLinesIgnored  )  {  while  (  eol  &&  (  lastChar  =  =  '\n'  ||  lastChar  =  =  '\r'  ||  lastChar  =  =  ExtendedBufferedReader  .  UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {    lastChar  =  c  ;  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;    if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }  }  }    if  (  isEndOfFile  (  lastChar  )  ||  (  !isDelimiter  (  lastChar  )  &&  isEndOfFile  (  c  )  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }    while  (  tkn  .  type  =  =  INVALID  )  {    if  (  surroundingSpacesIgnored  )  {  while  (  isWhitespace  (  c  )  &&  !eol  )  {  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  }  }    if  (  isCommentStart  (  c  )  )  {    in  .  readLine  (  )  ;  tkn  =  nextToken  (  tkn  .  reset  (  )  )  ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  }  else  if  (  eol  )  {      tkn  .  type  =  EORECORD  ;  [ATTENTION]  }if  (  isEncapsulator  (  lastChar  )  )  {    encapsulatedTokenLexer  (  tkn  ,  c  )  ;  }  else  if  (  isEndOfFile  (  c  )  )  {      tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  there  is  data  at  EOF  }  else  {      simpleTokenLexer  (  tkn  ,  c  )  ;  }  }  return  tkn  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^103^^^^^41^118^
[REPLACE]    }    else    if    (    isEndOfFile    (    c    )    )    {  	[BUGGY]    if  (  isEndOfFile  (  c  )  )  {[FE]    AssertionFailedError    Token  type  expected:<EORECORD>  but  was:<TOKEN>  assertTokenEquals(TOKEN  ,     "1   "  ,  parser.nextToken(new  Token()))      [METHOD]    nextToken  [TYPE]  Token  [PARAMETER]  Token  tkn  [CLASS]  CSVLexer    [TYPE]  boolean  eol  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  lastChar    [CONTEXT]    Token  nextToken  (  Token  tkn  )  throws  IOException  {    int  lastChar  =  in  .  readAgain  (  )  ;              int  c  =  in  .  read  (  )  ;  boolean  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;      if  (  emptyLinesIgnored  )  {  while  (  eol  &&  (  lastChar  =  =  '\n'  ||  lastChar  =  =  '\r'  ||  lastChar  =  =  ExtendedBufferedReader  .  UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {    lastChar  =  c  ;  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;    if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }  }  }    if  (  isEndOfFile  (  lastChar  )  ||  (  !isDelimiter  (  lastChar  )  &&  isEndOfFile  (  c  )  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }    while  (  tkn  .  type  =  =  INVALID  )  {    if  (  surroundingSpacesIgnored  )  {  while  (  isWhitespace  (  c  )  &&  !eol  )  {  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  }  }    if  (  isCommentStart  (  c  )  )  {    in  .  readLine  (  )  ;  tkn  =  nextToken  (  tkn  .  reset  (  )  )  ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  }  else  if  (  eol  )  {      tkn  .  type  =  EORECORD  ;  }  else  if  (  isEncapsulator  (  c  )  )  {    encapsulatedTokenLexer  (  tkn  ,  c  )  ;  [ATTENTION]  }if  (  isEndOfFile  (  c  )  )  {      tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  there  is  data  at  EOF  }  else  {      simpleTokenLexer  (  tkn  ,  c  )  ;  }  }  return  tkn  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^106^^^^^41^118^
[REPLACE]    tkn    .    type    =    EORECORD;  	[BUGGY]  tkn  .  type    =    tkn  .  type  ;  [FE]  [METHOD]    nextToken  [TYPE]  Token  [PARAMETER]  Token  tkn  [CLASS]  CSVLexer    [TYPE]  boolean  eol  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  lastChar    [CONTEXT]    Token  nextToken  (  Token  tkn  )  throws  IOException  {    int  lastChar  =  in  .  readAgain  (  )  ;              int  c  =  in  .  read  (  )  ;  boolean  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;      if  (  emptyLinesIgnored  )  {  while  (  eol  &&  (  lastChar  =  =  '\n'  ||  lastChar  =  =  '\r'  ||  lastChar  =  =  ExtendedBufferedReader  .  UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {    lastChar  =  c  ;  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;    if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }  }  }    if  (  isEndOfFile  (  lastChar  )  ||  (  !isDelimiter  (  lastChar  )  &&  isEndOfFile  (  c  )  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }    while  (  tkn  .  type  =  =  INVALID  )  {    if  (  surroundingSpacesIgnored  )  {  while  (  isWhitespace  (  c  )  &&  !eol  )  {  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  }  }    if  (  isCommentStart  (  c  )  )  {    in  .  readLine  (  )  ;  tkn  =  nextToken  (  tkn  .  reset  (  )  )  ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  }  else  if  (  eol  )  {      [ATTENTION]  tkn  .  type  =  tkn  .  type  ;  }  else  if  (  isEncapsulator  (  c  )  )  {    encapsulatedTokenLexer  (  tkn  ,  c  )  ;  }  else  if  (  isEndOfFile  (  c  )  )  {      tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  there  is  data  at  EOF  }  else  {      simpleTokenLexer  (  tkn  ,  c  )  ;  }  }  return  tkn  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^102^^^^^41^118^
[REMOVE]      	[BUGGY]  super  (  format  ,  in  )  ;  [CE]  call  to  super  must  be  first  statement  in  constructor    [METHOD]    nextToken  [TYPE]  Token  [PARAMETER]  Token  tkn  [CLASS]  CSVLexer    [TYPE]  boolean  eol  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  lastChar    [CONTEXT]    }  else  if  (  isEndOfFile  (  c  )  )  {      tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  there  is  data  at  EOF  }  else  {      [ATTENTION]  simpleTokenLexer  (  tkn  ,  c  )  ;      	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^114^^^^^106^115^
[REPLACE]    }    else    if    (    isEndOfFile    (    c    )    )    {  	[BUGGY]  else  if  (  isDelimiter  (  c  )  )  {[NO-ERROR]    [METHOD]    nextToken  [TYPE]  Token  [PARAMETER]  Token  tkn  [CLASS]  CSVLexer    [TYPE]  boolean  eol  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  lastChar    [CONTEXT]    Token  nextToken  (  Token  tkn  )  throws  IOException  {    int  lastChar  =  in  .  readAgain  (  )  ;              int  c  =  in  .  read  (  )  ;  boolean  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;      if  (  emptyLinesIgnored  )  {  while  (  eol  &&  (  lastChar  =  =  '\n'  ||  lastChar  =  =  '\r'  ||  lastChar  =  =  ExtendedBufferedReader  .  UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {    lastChar  =  c  ;  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;    if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }  }  }    if  (  isEndOfFile  (  lastChar  )  ||  (  !isDelimiter  (  lastChar  )  &&  isEndOfFile  (  c  )  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }    while  (  tkn  .  type  =  =  INVALID  )  {    if  (  surroundingSpacesIgnored  )  {  while  (  isWhitespace  (  c  )  &&  !eol  )  {  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  }  }    if  (  isCommentStart  (  c  )  )  {    in  .  readLine  (  )  ;  tkn  =  nextToken  (  tkn  .  reset  (  )  )  ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  }  else  if  (  eol  )  {      tkn  .  type  =  EORECORD  ;  }  else  if  (  isEncapsulator  (  c  )  )  {    encapsulatedTokenLexer  (  tkn  ,  c  )  ;  [ATTENTION]  }  else  if  (  isDelimiter  (  c  )  )  {      tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  there  is  data  at  EOF  }  else  {      simpleTokenLexer  (  tkn  ,  c  )  ;  }  }  return  tkn  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^106^^^^^41^118^
[REPLACE]    tkn    =    nextToken    (    tkn    .    reset    (    )    )    ;  	[BUGGY]  tkn  =    nextToken  (  null  .  reset  (  )  )  ;  [CE]  <null>  cannot  be  dereferenced    [METHOD]    nextToken  [TYPE]  Token  [PARAMETER]  Token  tkn  [CLASS]  CSVLexer    [TYPE]  boolean  eol  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  lastChar    [CONTEXT]    Token  nextToken  (  Token  tkn  )  throws  IOException  {    int  lastChar  =  in  .  readAgain  (  )  ;              int  c  =  in  .  read  (  )  ;  boolean  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;      if  (  emptyLinesIgnored  )  {  while  (  eol  &&  (  lastChar  =  =  '\n'  ||  lastChar  =  =  '\r'  ||  lastChar  =  =  ExtendedBufferedReader  .  UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {    lastChar  =  c  ;  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;    if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }  }  }    if  (  isEndOfFile  (  lastChar  )  ||  (  !isDelimiter  (  lastChar  )  &&  isEndOfFile  (  c  )  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }    while  (  tkn  .  type  =  =  INVALID  )  {    if  (  surroundingSpacesIgnored  )  {  while  (  isWhitespace  (  c  )  &&  !eol  )  {  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  }  }    if  (  isCommentStart  (  c  )  )  {    in  .  readLine  (  )  ;  [ATTENTION]  tkn  =  nextToken  (  null  .  reset  (  )  )    ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  }  else  if  (  eol  )  {      tkn  .  type  =  EORECORD  ;  }  else  if  (  isEncapsulator  (  c  )  )  {    encapsulatedTokenLexer  (  tkn  ,  c  )  ;  }  else  if  (  isEndOfFile  (  c  )  )  {      tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  there  is  data  at  EOF  }  else  {      simpleTokenLexer  (  tkn  ,  c  )  ;  }  }  return  tkn  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^95^^^^^41^118^
[REPLACE]    }    else    if    (    isDelimiter    (    c    )    )    {  	[BUGGY]    if  (  isDelimiter  (  c  )  )  {[FE]    AssertionFailedError    Token  type  expected:<EORECORD>  but  was:<TOKEN>  assertTokenEquals(TOKEN  ,     "1   "  ,  parser.nextToken(new  Token()))      [METHOD]    nextToken  [TYPE]  Token  [PARAMETER]  Token  tkn  [CLASS]  CSVLexer    [TYPE]  boolean  eol  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  lastChar    [CONTEXT]    Token  nextToken  (  Token  tkn  )  throws  IOException  {    int  lastChar  =  in  .  readAgain  (  )  ;              int  c  =  in  .  read  (  )  ;  boolean  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;      if  (  emptyLinesIgnored  )  {  while  (  eol  &&  (  lastChar  =  =  '\n'  ||  lastChar  =  =  '\r'  ||  lastChar  =  =  ExtendedBufferedReader  .  UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {    lastChar  =  c  ;  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;    if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }  }  }    if  (  isEndOfFile  (  lastChar  )  ||  (  !isDelimiter  (  lastChar  )  &&  isEndOfFile  (  c  )  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }    while  (  tkn  .  type  =  =  INVALID  )  {    if  (  surroundingSpacesIgnored  )  {  while  (  isWhitespace  (  c  )  &&  !eol  )  {  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  }  }    if  (  isCommentStart  (  c  )  )  {    in  .  readLine  (  )  ;  tkn  =  nextToken  (  tkn  .  reset  (  )  )  ;  [ATTENTION]  }if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  }  else  if  (  eol  )  {      tkn  .  type  =  EORECORD  ;  }  else  if  (  isEncapsulator  (  c  )  )  {    encapsulatedTokenLexer  (  tkn  ,  c  )  ;  }  else  if  (  isEndOfFile  (  c  )  )  {      tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  there  is  data  at  EOF  }  else  {      simpleTokenLexer  (  tkn  ,  c  )  ;  }  }  return  tkn  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^96^^^^^41^118^
[REPLACE]    }    else    if    (    eol    )    {  	[BUGGY]    if  (  false  )  {[FE]    AssertionFailedError    Token  type  expected:<EORECORD>  but  was:<TOKEN>  assertTokenEquals(TOKEN  ,     "1   "  ,  parser.nextToken(new  Token()))      [METHOD]    nextToken  [TYPE]  Token  [PARAMETER]  Token  tkn  [CLASS]  CSVLexer    [TYPE]  boolean  eol  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  lastChar    [CONTEXT]    Token  nextToken  (  Token  tkn  )  throws  IOException  {    int  lastChar  =  in  .  readAgain  (  )  ;              int  c  =  in  .  read  (  )  ;  boolean  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;      if  (  emptyLinesIgnored  )  {  while  (  eol  &&  (  lastChar  =  =  '\n'  ||  lastChar  =  =  '\r'  ||  lastChar  =  =  ExtendedBufferedReader  .  UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {    lastChar  =  c  ;  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;    if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }  }  }    if  (  isEndOfFile  (  lastChar  )  ||  (  !isDelimiter  (  lastChar  )  &&  isEndOfFile  (  c  )  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }    while  (  tkn  .  type  =  =  INVALID  )  {    if  (  surroundingSpacesIgnored  )  {  while  (  isWhitespace  (  c  )  &&  !eol  )  {  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  }  }    if  (  isCommentStart  (  c  )  )  {    in  .  readLine  (  )  ;  tkn  =  nextToken  (  tkn  .  reset  (  )  )  ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  [ATTENTION]  }if  (  false  )  {      tkn  .  type  =  EORECORD  ;  }  else  if  (  isEncapsulator  (  c  )  )  {    encapsulatedTokenLexer  (  tkn  ,  c  )  ;  }  else  if  (  isEndOfFile  (  c  )  )  {      tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  there  is  data  at  EOF  }  else  {      simpleTokenLexer  (  tkn  ,  c  )  ;  }  }  return  tkn  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^99^^^^^41^118^
[ADD]    else    if    (    eol    )    {    tkn    .    type    =    EORECORD;  	[BUGGY]    tkn  .  type  =  EORECORD  ;  [CE]  'else'  without  'if'    [METHOD]    nextToken  [TYPE]  Token  [PARAMETER]  Token  tkn  [CLASS]  CSVLexer    [TYPE]  boolean  eol  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  lastChar    [CONTEXT]    Token  nextToken  (  Token  tkn  )  throws  IOException  {    int  lastChar  =  in  .  readAgain  (  )  ;              int  c  =  in  .  read  (  )  ;  boolean  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;      if  (  emptyLinesIgnored  )  {  while  (  eol  &&  (  lastChar  =  =  '\n'  ||  lastChar  =  =  '\r'  ||  lastChar  =  =  ExtendedBufferedReader  .  UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {    lastChar  =  c  ;  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;    if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }  }  }    if  (  isEndOfFile  (  lastChar  )  ||  (  !isDelimiter  (  lastChar  )  &&  isEndOfFile  (  c  )  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }    while  (  tkn  .  type  =  =  INVALID  )  {    if  (  surroundingSpacesIgnored  )  {  while  (  isWhitespace  (  c  )  &&  !eol  )  {  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  }  }    if  (  isCommentStart  (  c  )  )  {    in  .  readLine  (  )  ;  tkn  =  nextToken  (  tkn  .  reset  (  )  )  ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  [ATTENTION]  }  tkn  .  type  =  EORECORD  ;      }  else  if  (  isEncapsulator  (  c  )  )  {    encapsulatedTokenLexer  (  tkn  ,  c  )  ;  }  else  if  (  isEndOfFile  (  c  )  )  {      tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  there  is  data  at  EOF  }  else  {      simpleTokenLexer  (  tkn  ,  c  )  ;  }  }  return  tkn  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^99^100^^102^^41^118^
[REPLACE]    tkn    .    type    =    EORECORD;  	[BUGGY]  tkn  .  type  ;  [CE]  not  a  statement    [METHOD]    nextToken  [TYPE]  Token  [PARAMETER]  Token  tkn  [CLASS]  CSVLexer    [TYPE]  boolean  eol  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  lastChar    [CONTEXT]    Token  nextToken  (  Token  tkn  )  throws  IOException  {    int  lastChar  =  in  .  readAgain  (  )  ;              int  c  =  in  .  read  (  )  ;  boolean  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;      if  (  emptyLinesIgnored  )  {  while  (  eol  &&  (  lastChar  =  =  '\n'  ||  lastChar  =  =  '\r'  ||  lastChar  =  =  ExtendedBufferedReader  .  UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {    lastChar  =  c  ;  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;    if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }  }  }    if  (  isEndOfFile  (  lastChar  )  ||  (  !isDelimiter  (  lastChar  )  &&  isEndOfFile  (  c  )  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }    while  (  tkn  .  type  =  =  INVALID  )  {    if  (  surroundingSpacesIgnored  )  {  while  (  isWhitespace  (  c  )  &&  !eol  )  {  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  }  }    if  (  isCommentStart  (  c  )  )  {    in  .  readLine  (  )  ;  tkn  =  nextToken  (  tkn  .  reset  (  )  )  ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  }  else  if  (  eol  )  {      [ATTENTION]  tkn  .  type  ;  }  else  if  (  isEncapsulator  (  c  )  )  {    encapsulatedTokenLexer  (  tkn  ,  c  )  ;  }  else  if  (  isEndOfFile  (  c  )  )  {      tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  there  is  data  at  EOF  }  else  {      simpleTokenLexer  (  tkn  ,  c  )  ;  }  }  return  tkn  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^102^^^^^41^118^
[REPLACE]    }    else    if    (    isEncapsulator    (    c    )    )    {  	[BUGGY]  else  if  (  isEncapsulator  (  lastChar  )  )  {[FE]    AssertionFailedError    Token  content  expected:<[foo]>  but  was:<[   "foo   "]>  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    nextToken  [TYPE]  Token  [PARAMETER]  Token  tkn  [CLASS]  CSVLexer    [TYPE]  boolean  eol  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  lastChar    [CONTEXT]    Token  nextToken  (  Token  tkn  )  throws  IOException  {    int  lastChar  =  in  .  readAgain  (  )  ;              int  c  =  in  .  read  (  )  ;  boolean  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;      if  (  emptyLinesIgnored  )  {  while  (  eol  &&  (  lastChar  =  =  '\n'  ||  lastChar  =  =  '\r'  ||  lastChar  =  =  ExtendedBufferedReader  .  UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {    lastChar  =  c  ;  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;    if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }  }  }    if  (  isEndOfFile  (  lastChar  )  ||  (  !isDelimiter  (  lastChar  )  &&  isEndOfFile  (  c  )  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }    while  (  tkn  .  type  =  =  INVALID  )  {    if  (  surroundingSpacesIgnored  )  {  while  (  isWhitespace  (  c  )  &&  !eol  )  {  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  }  }    if  (  isCommentStart  (  c  )  )  {    in  .  readLine  (  )  ;  tkn  =  nextToken  (  tkn  .  reset  (  )  )  ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  }  else  if  (  eol  )  {      tkn  .  type  =  EORECORD  ;  [ATTENTION]  }  else  if  (  isEncapsulator  (  lastChar  )  )  {    encapsulatedTokenLexer  (  tkn  ,  c  )  ;  }  else  if  (  isEndOfFile  (  c  )  )  {      tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  there  is  data  at  EOF  }  else  {      simpleTokenLexer  (  tkn  ,  c  )  ;  }  }  return  tkn  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^103^^^^^41^118^
[REPLACE]    }    else    if    (    isEndOfFile    (    c    )    )    {  	[BUGGY]  else  if  (  isEndOfFile  (  lastChar  )  )  {[NO-ERROR]    [METHOD]    nextToken  [TYPE]  Token  [PARAMETER]  Token  tkn  [CLASS]  CSVLexer    [TYPE]  boolean  eol  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  lastChar    [CONTEXT]    Token  nextToken  (  Token  tkn  )  throws  IOException  {    int  lastChar  =  in  .  readAgain  (  )  ;              int  c  =  in  .  read  (  )  ;  boolean  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;      if  (  emptyLinesIgnored  )  {  while  (  eol  &&  (  lastChar  =  =  '\n'  ||  lastChar  =  =  '\r'  ||  lastChar  =  =  ExtendedBufferedReader  .  UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {    lastChar  =  c  ;  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;    if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }  }  }    if  (  isEndOfFile  (  lastChar  )  ||  (  !isDelimiter  (  lastChar  )  &&  isEndOfFile  (  c  )  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }    while  (  tkn  .  type  =  =  INVALID  )  {    if  (  surroundingSpacesIgnored  )  {  while  (  isWhitespace  (  c  )  &&  !eol  )  {  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  }  }    if  (  isCommentStart  (  c  )  )  {    in  .  readLine  (  )  ;  tkn  =  nextToken  (  tkn  .  reset  (  )  )  ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  }  else  if  (  eol  )  {      tkn  .  type  =  EORECORD  ;  }  else  if  (  isEncapsulator  (  c  )  )  {    encapsulatedTokenLexer  (  tkn  ,  c  )  ;  [ATTENTION]  }  else  if  (  isEndOfFile  (  lastChar  )  )  {      tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  there  is  data  at  EOF  }  else  {      simpleTokenLexer  (  tkn  ,  c  )  ;  }  }  return  tkn  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^106^^^^^41^118^
[ADD]    tkn    .    type    =    EOF;    tkn    .    isReady    =    true;  	[BUGGY]  tkn  .  isReady  =  true  ;  [FE]  [METHOD]    nextToken  [TYPE]  Token  [PARAMETER]  Token  tkn  [CLASS]  CSVLexer    [TYPE]  boolean  eol  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  lastChar    [CONTEXT]    Token  nextToken  (  Token  tkn  )  throws  IOException  {    int  lastChar  =  in  .  readAgain  (  )  ;              int  c  =  in  .  read  (  )  ;  boolean  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;      if  (  emptyLinesIgnored  )  {  while  (  eol  &&  (  lastChar  =  =  '\n'  ||  lastChar  =  =  '\r'  ||  lastChar  =  =  ExtendedBufferedReader  .  UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {    lastChar  =  c  ;  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;    if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }  }  }    if  (  isEndOfFile  (  lastChar  )  ||  (  !isDelimiter  (  lastChar  )  &&  isEndOfFile  (  c  )  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }    while  (  tkn  .  type  =  =  INVALID  )  {    if  (  surroundingSpacesIgnored  )  {  while  (  isWhitespace  (  c  )  &&  !eol  )  {  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  }  }    if  (  isCommentStart  (  c  )  )  {    in  .  readLine  (  )  ;  tkn  =  nextToken  (  tkn  .  reset  (  )  )  ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  }  else  if  (  eol  )  {      tkn  .  type  =  EORECORD  ;  }  else  if  (  isEncapsulator  (  c  )  )  {    encapsulatedTokenLexer  (  tkn  ,  c  )  ;  }  else  if  (  isEndOfFile  (  c  )  )  {      [ATTENTION]  tkn  .  isReady  =  true  ;    }  else  {      simpleTokenLexer  (  tkn  ,  c  )  ;  }  }  return  tkn  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^109^110^^^^41^118^
[ADD]    c    =    in    .    read    (    )    ;    eol    =    isEndOfLine    (    c    )    ;  	[BUGGY]  [FE]  [METHOD]    nextToken  [TYPE]  Token  [PARAMETER]  Token  tkn  [CLASS]  CSVLexer    [TYPE]  boolean  eol  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  lastChar    [CONTEXT]    Token  nextToken  (  Token  tkn  )  throws  IOException  {    int  lastChar  =  in  .  readAgain  (  )  ;              int  c  =  in  .  read  (  )  ;  boolean  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;      if  (  emptyLinesIgnored  )  {  while  (  eol  &&  (  lastChar  =  =  '\n'  ||  lastChar  =  =  '\r'  ||  lastChar  =  =  ExtendedBufferedReader  .  UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {    lastChar  =  c  ;  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;    if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }  }  }    if  (  isEndOfFile  (  lastChar  )  ||  (  !isDelimiter  (  lastChar  )  &&  isEndOfFile  (  c  )  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }    while  (  tkn  .  type  =  =  INVALID  )  {    if  (  surroundingSpacesIgnored  )  {  while  (  isWhitespace  (  c  )  &&  !eol  )  {  [ATTENTION]    }  }    if  (  isCommentStart  (  c  )  )  {    in  .  readLine  (  )  ;  tkn  =  nextToken  (  tkn  .  reset  (  )  )  ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  }  else  if  (  eol  )  {      tkn  .  type  =  EORECORD  ;  }  else  if  (  isEncapsulator  (  c  )  )  {    encapsulatedTokenLexer  (  tkn  ,  c  )  ;  }  else  if  (  isEndOfFile  (  c  )  )  {      tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  there  is  data  at  EOF  }  else  {      simpleTokenLexer  (  tkn  ,  c  )  ;  }  }  return  tkn  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^86^87^^^^41^118^
[ADD]    eol    =    isEndOfLine    (    c    )    ;  	[BUGGY]  [NO-ERROR]    [METHOD]    nextToken  [TYPE]  Token  [PARAMETER]  Token  tkn  [CLASS]  CSVLexer    [TYPE]  boolean  eol  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  lastChar    [CONTEXT]    Token  nextToken  (  Token  tkn  )  throws  IOException  {    int  lastChar  =  in  .  readAgain  (  )  ;              int  c  =  in  .  read  (  )  ;  boolean  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;      if  (  emptyLinesIgnored  )  {  while  (  eol  &&  (  lastChar  =  =  '\n'  ||  lastChar  =  =  '\r'  ||  lastChar  =  =  ExtendedBufferedReader  .  UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {    lastChar  =  c  ;  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;    if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }  }  }    if  (  isEndOfFile  (  lastChar  )  ||  (  !isDelimiter  (  lastChar  )  &&  isEndOfFile  (  c  )  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }    while  (  tkn  .  type  =  =  INVALID  )  {    if  (  surroundingSpacesIgnored  )  {  while  (  isWhitespace  (  c  )  &&  !eol  )  {  c  =  in  .  read  (  )  ;  [ATTENTION]  }  }    if  (  isCommentStart  (  c  )  )  {    in  .  readLine  (  )  ;  tkn  =  nextToken  (  tkn  .  reset  (  )  )  ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  }  else  if  (  eol  )  {      tkn  .  type  =  EORECORD  ;  }  else  if  (  isEncapsulator  (  c  )  )  {    encapsulatedTokenLexer  (  tkn  ,  c  )  ;  }  else  if  (  isEndOfFile  (  c  )  )  {      tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  there  is  data  at  EOF  }  else  {      simpleTokenLexer  (  tkn  ,  c  )  ;  }  }  return  tkn  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^87^^^^^41^118^
[REPLACE]    while    (    isWhitespace    (    c    )    &&    !eol    )    {  	[BUGGY]  while  (  isWhitespace  (  c  )  ||  !eol  )  {[FE]  [METHOD]    nextToken  [TYPE]  Token  [PARAMETER]  Token  tkn  [CLASS]  CSVLexer    [TYPE]  boolean  eol  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  lastChar    [CONTEXT]    Token  nextToken  (  Token  tkn  )  throws  IOException  {    int  lastChar  =  in  .  readAgain  (  )  ;              int  c  =  in  .  read  (  )  ;  boolean  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;      if  (  emptyLinesIgnored  )  {  while  (  eol  &&  (  lastChar  =  =  '\n'  ||  lastChar  =  =  '\r'  ||  lastChar  =  =  ExtendedBufferedReader  .  UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {    lastChar  =  c  ;  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;    if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }  }  }    if  (  isEndOfFile  (  lastChar  )  ||  (  !isDelimiter  (  lastChar  )  &&  isEndOfFile  (  c  )  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }    while  (  tkn  .  type  =  =  INVALID  )  {    if  (  surroundingSpacesIgnored  )  {  [ATTENTION]  while  (  isWhitespace  (  c  )  ||  !eol  )  {  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  }  }    if  (  isCommentStart  (  c  )  )  {    in  .  readLine  (  )  ;  tkn  =  nextToken  (  tkn  .  reset  (  )  )  ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  }  else  if  (  eol  )  {      tkn  .  type  =  EORECORD  ;  }  else  if  (  isEncapsulator  (  c  )  )  {    encapsulatedTokenLexer  (  tkn  ,  c  )  ;  }  else  if  (  isEndOfFile  (  c  )  )  {      tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  there  is  data  at  EOF  }  else  {      simpleTokenLexer  (  tkn  ,  c  )  ;  }  }  return  tkn  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^85^^^^^41^118^
[ADD]    while    (    isWhitespace    (    c    )    &&    !eol    )    {    c    =    in    .    read    (    )    ;  	[BUGGY]  [CE]  illegal  start  of  type    [METHOD]    nextToken  [TYPE]  Token  [PARAMETER]  Token  tkn  [CLASS]  CSVLexer    [TYPE]  boolean  eol  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  lastChar    [CONTEXT]    Token  nextToken  (  Token  tkn  )  throws  IOException  {    int  lastChar  =  in  .  readAgain  (  )  ;              int  c  =  in  .  read  (  )  ;  boolean  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;      if  (  emptyLinesIgnored  )  {  while  (  eol  &&  (  lastChar  =  =  '\n'  ||  lastChar  =  =  '\r'  ||  lastChar  =  =  ExtendedBufferedReader  .  UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {    lastChar  =  c  ;  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;    if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }  }  }    if  (  isEndOfFile  (  lastChar  )  ||  (  !isDelimiter  (  lastChar  )  &&  isEndOfFile  (  c  )  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }    while  (  tkn  .  type  =  =  INVALID  )  {    if  (  surroundingSpacesIgnored  )  {  [ATTENTION]    eol  =  isEndOfLine  (  c  )  ;  }  }    if  (  isCommentStart  (  c  )  )  {    in  .  readLine  (  )  ;  tkn  =  nextToken  (  tkn  .  reset  (  )  )  ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  }  else  if  (  eol  )  {      tkn  .  type  =  EORECORD  ;  }  else  if  (  isEncapsulator  (  c  )  )  {    encapsulatedTokenLexer  (  tkn  ,  c  )  ;  }  else  if  (  isEndOfFile  (  c  )  )  {      tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  there  is  data  at  EOF  }  else  {      simpleTokenLexer  (  tkn  ,  c  )  ;  }  }  return  tkn  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^85^86^^^^41^118^
[ADD]    if    (    surroundingSpacesIgnored    )    {    while    (    isWhitespace    (    c    )    &&    !eol    )    {    c    =    in    .    read    (    )    ;    eol    =    isEndOfLine    (    c    )    ;    }  	[BUGGY]  [CE]  illegal  start  of  type    [METHOD]    nextToken  [TYPE]  Token  [PARAMETER]  Token  tkn  [CLASS]  CSVLexer    [TYPE]  boolean  eol  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  lastChar    [CONTEXT]    Token  nextToken  (  Token  tkn  )  throws  IOException  {    int  lastChar  =  in  .  readAgain  (  )  ;              int  c  =  in  .  read  (  )  ;  boolean  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;      if  (  emptyLinesIgnored  )  {  while  (  eol  &&  (  lastChar  =  =  '\n'  ||  lastChar  =  =  '\r'  ||  lastChar  =  =  ExtendedBufferedReader  .  UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {    lastChar  =  c  ;  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;    if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }  }  }    if  (  isEndOfFile  (  lastChar  )  ||  (  !isDelimiter  (  lastChar  )  &&  isEndOfFile  (  c  )  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }    while  (  tkn  .  type  =  =  INVALID  )  {    [ATTENTION]      }    if  (  isCommentStart  (  c  )  )  {    in  .  readLine  (  )  ;  tkn  =  nextToken  (  tkn  .  reset  (  )  )  ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  }  else  if  (  eol  )  {      tkn  .  type  =  EORECORD  ;  }  else  if  (  isEncapsulator  (  c  )  )  {    encapsulatedTokenLexer  (  tkn  ,  c  )  ;  }  else  if  (  isEndOfFile  (  c  )  )  {      tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  there  is  data  at  EOF  }  else  {      simpleTokenLexer  (  tkn  ,  c  )  ;  }  }  return  tkn  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^84^85^86^87^88^41^118^
[REPLACE]    if    (    isCommentStart    (    c    )    )    {  	[BUGGY]  if  (  isEscape  (  c  )  )  {[FE]    AssertionFailedError    Token  content  expected:<[]>  but  was:<[#foo]>  assertTokenEquals(TOKEN  ,     "1   "  ,  parser.nextToken(new  Token()))      [METHOD]    nextToken  [TYPE]  Token  [PARAMETER]  Token  tkn  [CLASS]  CSVLexer    [TYPE]  boolean  eol  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  lastChar    [CONTEXT]    Token  nextToken  (  Token  tkn  )  throws  IOException  {    int  lastChar  =  in  .  readAgain  (  )  ;              int  c  =  in  .  read  (  )  ;  boolean  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;      if  (  emptyLinesIgnored  )  {  while  (  eol  &&  (  lastChar  =  =  '\n'  ||  lastChar  =  =  '\r'  ||  lastChar  =  =  ExtendedBufferedReader  .  UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {    lastChar  =  c  ;  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;    if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }  }  }    if  (  isEndOfFile  (  lastChar  )  ||  (  !isDelimiter  (  lastChar  )  &&  isEndOfFile  (  c  )  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }    while  (  tkn  .  type  =  =  INVALID  )  {    if  (  surroundingSpacesIgnored  )  {  while  (  isWhitespace  (  c  )  &&  !eol  )  {  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  }  }    [ATTENTION]  if  (  isEscape  (  c  )  )  {    in  .  readLine  (  )  ;  tkn  =  nextToken  (  tkn  .  reset  (  )  )  ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  }  else  if  (  eol  )  {      tkn  .  type  =  EORECORD  ;  }  else  if  (  isEncapsulator  (  c  )  )  {    encapsulatedTokenLexer  (  tkn  ,  c  )  ;  }  else  if  (  isEndOfFile  (  c  )  )  {      tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  there  is  data  at  EOF  }  else  {      simpleTokenLexer  (  tkn  ,  c  )  ;  }  }  return  tkn  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^92^^^^^41^118^
[REPLACE]    }    else    if    (    isDelimiter    (    c    )    )    {  	[BUGGY]    if  (  isDelimiter  (  lastChar  )  )  {[FE]    AssertionFailedError    Token  content  expected:<[def]>  but  was:<[]>  assertTokenEquals(TOKEN  ,     "abc   "  ,  parser.nextToken(new  Token()))      [METHOD]    nextToken  [TYPE]  Token  [PARAMETER]  Token  tkn  [CLASS]  CSVLexer    [TYPE]  boolean  eol  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  lastChar    [CONTEXT]    Token  nextToken  (  Token  tkn  )  throws  IOException  {    int  lastChar  =  in  .  readAgain  (  )  ;              int  c  =  in  .  read  (  )  ;  boolean  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;      if  (  emptyLinesIgnored  )  {  while  (  eol  &&  (  lastChar  =  =  '\n'  ||  lastChar  =  =  '\r'  ||  lastChar  =  =  ExtendedBufferedReader  .  UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {    lastChar  =  c  ;  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;    if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }  }  }    if  (  isEndOfFile  (  lastChar  )  ||  (  !isDelimiter  (  lastChar  )  &&  isEndOfFile  (  c  )  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }    while  (  tkn  .  type  =  =  INVALID  )  {    if  (  surroundingSpacesIgnored  )  {  while  (  isWhitespace  (  c  )  &&  !eol  )  {  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  }  }    if  (  isCommentStart  (  c  )  )  {    in  .  readLine  (  )  ;  tkn  =  nextToken  (  tkn  .  reset  (  )  )  ;  [ATTENTION]  }if  (  isDelimiter  (  lastChar  )  )  {    tkn  .  type  =  TOKEN  ;  }  else  if  (  eol  )  {      tkn  .  type  =  EORECORD  ;  }  else  if  (  isEncapsulator  (  c  )  )  {    encapsulatedTokenLexer  (  tkn  ,  c  )  ;  }  else  if  (  isEndOfFile  (  c  )  )  {      tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  there  is  data  at  EOF  }  else  {      simpleTokenLexer  (  tkn  ,  c  )  ;  }  }  return  tkn  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^96^^^^^41^118^
[REMOVE]      	[BUGGY]  if  (  isDelimiter  (  c  )  )  {      tkn  .  type  =  TOKEN  ;  }else      if  (  eol  )  {          tkn  .  type  =  EORECORD  ;      }else          if  (  isEncapsulator  (  c  )  )  {              encapsulatedTokenLexer  (  tkn  ,  c  )  ;          }else              if  (  isEndOfFile  (  c  )  )  {                  tkn  .  type  =  EOF  ;                  tkn  .  isReady  =  true  ;              }else  {                  simpleTokenLexer  (  tkn  ,  c  )  ;              }[NO-ERROR]    [METHOD]    nextToken  [TYPE]  Token  [PARAMETER]  Token  tkn  [CLASS]  CSVLexer    [TYPE]  boolean  eol  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  lastChar    [CONTEXT]    Token  nextToken  (  Token  tkn  )  throws  IOException  {    int  lastChar  =  in  .  readAgain  (  )  ;              int  c  =  in  .  read  (  )  ;  boolean  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;      if  (  emptyLinesIgnored  )  {  while  (  eol  &&  (  lastChar  =  =  '\n'  ||  lastChar  =  =  '\r'  ||  lastChar  =  =  ExtendedBufferedReader  .  UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {    lastChar  =  c  ;  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;    if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }  }  }    if  (  isEndOfFile  (  lastChar  )  ||  (  !isDelimiter  (  lastChar  )  &&  isEndOfFile  (  c  )  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }    while  (  tkn  .  type  =  =  INVALID  )  {    if  (  surroundingSpacesIgnored  )  {  while  (  isWhitespace  (  c  )  &&  !eol  )  {  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  }  }    if  (  isCommentStart  (  c  )  )  {    in  .  readLine  (  )  ;  tkn  =  nextToken  (  tkn  .  reset  (  )  )  ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  [ATTENTION]  }  else  if  (  eol  )  {  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  }else  if  (  eol  )  {  tkn  .  type  =  EORECORD  ;  }else  if  (  isEncapsulator  (  c  )  )  {  encapsulatedTokenLexer  (  tkn  ,  c  )    ;  }else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  }else  {  simpleTokenLexer  (  tkn  ,  c  )    ;  }//  empty  token  return  EORECORD  (     "   "  )    tkn  .  type  =  EORECORD  ;  }  else  if  (  isEncapsulator  (  c  )  )  {    encapsulatedTokenLexer  (  tkn  ,  c  )  ;  }  else  if  (  isEndOfFile  (  c  )  )  {      tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  there  is  data  at  EOF  }  else  {      simpleTokenLexer  (  tkn  ,  c  )  ;  }  }  return  tkn  ;      	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^99^^^^^41^118^
[ADD]    tkn    .    type    =    EORECORD;  	[BUGGY]  [FE]  [METHOD]    nextToken  [TYPE]  Token  [PARAMETER]  Token  tkn  [CLASS]  CSVLexer    [TYPE]  boolean  eol  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  lastChar    [CONTEXT]    Token  nextToken  (  Token  tkn  )  throws  IOException  {    int  lastChar  =  in  .  readAgain  (  )  ;              int  c  =  in  .  read  (  )  ;  boolean  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;      if  (  emptyLinesIgnored  )  {  while  (  eol  &&  (  lastChar  =  =  '\n'  ||  lastChar  =  =  '\r'  ||  lastChar  =  =  ExtendedBufferedReader  .  UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {    lastChar  =  c  ;  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;    if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }  }  }    if  (  isEndOfFile  (  lastChar  )  ||  (  !isDelimiter  (  lastChar  )  &&  isEndOfFile  (  c  )  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }    while  (  tkn  .  type  =  =  INVALID  )  {    if  (  surroundingSpacesIgnored  )  {  while  (  isWhitespace  (  c  )  &&  !eol  )  {  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  }  }    if  (  isCommentStart  (  c  )  )  {    in  .  readLine  (  )  ;  tkn  =  nextToken  (  tkn  .  reset  (  )  )  ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  }  else  if  (  eol  )  {      [ATTENTION]  }  else  if  (  isEncapsulator  (  c  )  )  {    encapsulatedTokenLexer  (  tkn  ,  c  )  ;  }  else  if  (  isEndOfFile  (  c  )  )  {      tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  there  is  data  at  EOF  }  else  {      simpleTokenLexer  (  tkn  ,  c  )  ;  }  }  return  tkn  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^102^^^^^41^118^
[ADD]    tkn    =    nextToken    (    tkn    .    reset    (    )    )    ;  	[BUGGY]  [FE]  [METHOD]    nextToken  [TYPE]  Token  [PARAMETER]  Token  tkn  [CLASS]  CSVLexer    [TYPE]  boolean  eol  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  lastChar    [CONTEXT]    Token  nextToken  (  Token  tkn  )  throws  IOException  {    int  lastChar  =  in  .  readAgain  (  )  ;              int  c  =  in  .  read  (  )  ;  boolean  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;      if  (  emptyLinesIgnored  )  {  while  (  eol  &&  (  lastChar  =  =  '\n'  ||  lastChar  =  =  '\r'  ||  lastChar  =  =  ExtendedBufferedReader  .  UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {    lastChar  =  c  ;  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;    if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }  }  }    if  (  isEndOfFile  (  lastChar  )  ||  (  !isDelimiter  (  lastChar  )  &&  isEndOfFile  (  c  )  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }    while  (  tkn  .  type  =  =  INVALID  )  {    if  (  surroundingSpacesIgnored  )  {  while  (  isWhitespace  (  c  )  &&  !eol  )  {  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  }  }    if  (  isCommentStart  (  c  )  )  {    in  .  readLine  (  )  ;  [ATTENTION]  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  }  else  if  (  eol  )  {      tkn  .  type  =  EORECORD  ;  }  else  if  (  isEncapsulator  (  c  )  )  {    encapsulatedTokenLexer  (  tkn  ,  c  )  ;  }  else  if  (  isEndOfFile  (  c  )  )  {      tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  there  is  data  at  EOF  }  else  {      simpleTokenLexer  (  tkn  ,  c  )  ;  }  }  return  tkn  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^95^^^^^41^118^
[REPLACE]    }    else    if    (    isDelimiter    (    c    )    )    {  	[BUGGY]  else  if  (  isEndOfFile  (  c  )  )  {[FE]    AssertionFailedError    Token  type  expected:<EOF>  but  was:<TOKEN>  assertTokenEquals(TOKEN  ,     "abc   "  ,  parser.nextToken(new  Token()))      [METHOD]    nextToken  [TYPE]  Token  [PARAMETER]  Token  tkn  [CLASS]  CSVLexer    [TYPE]  boolean  eol  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  lastChar    [CONTEXT]    Token  nextToken  (  Token  tkn  )  throws  IOException  {    int  lastChar  =  in  .  readAgain  (  )  ;              int  c  =  in  .  read  (  )  ;  boolean  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;      if  (  emptyLinesIgnored  )  {  while  (  eol  &&  (  lastChar  =  =  '\n'  ||  lastChar  =  =  '\r'  ||  lastChar  =  =  ExtendedBufferedReader  .  UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {    lastChar  =  c  ;  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;    if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }  }  }    if  (  isEndOfFile  (  lastChar  )  ||  (  !isDelimiter  (  lastChar  )  &&  isEndOfFile  (  c  )  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }    while  (  tkn  .  type  =  =  INVALID  )  {    if  (  surroundingSpacesIgnored  )  {  while  (  isWhitespace  (  c  )  &&  !eol  )  {  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  }  }    if  (  isCommentStart  (  c  )  )  {    in  .  readLine  (  )  ;  tkn  =  nextToken  (  tkn  .  reset  (  )  )  ;  [ATTENTION]  }  else  if  (  isEndOfFile  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  }  else  if  (  eol  )  {      tkn  .  type  =  EORECORD  ;  }  else  if  (  isEncapsulator  (  c  )  )  {    encapsulatedTokenLexer  (  tkn  ,  c  )  ;  }  else  if  (  isEndOfFile  (  c  )  )  {      tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  there  is  data  at  EOF  }  else  {      simpleTokenLexer  (  tkn  ,  c  )  ;  }  }  return  tkn  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^96^^^^^41^118^
[REMOVE]      	[BUGGY]  if  (  eol  )  {      tkn  .  type  =  EORECORD  ;  }else      if  (  isEncapsulator  (  c  )  )  {          encapsulatedTokenLexer  (  tkn  ,  c  )  ;      }else          if  (  isEndOfFile  (  c  )  )  {              tkn  .  type  =  EOF  ;              tkn  .  isReady  =  true  ;          }else  {              simpleTokenLexer  (  tkn  ,  c  )  ;          }[NO-ERROR]    [METHOD]    nextToken  [TYPE]  Token  [PARAMETER]  Token  tkn  [CLASS]  CSVLexer    [TYPE]  boolean  eol  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  lastChar    [CONTEXT]    Token  nextToken  (  Token  tkn  )  throws  IOException  {    int  lastChar  =  in  .  readAgain  (  )  ;              int  c  =  in  .  read  (  )  ;  boolean  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;      if  (  emptyLinesIgnored  )  {  while  (  eol  &&  (  lastChar  =  =  '\n'  ||  lastChar  =  =  '\r'  ||  lastChar  =  =  ExtendedBufferedReader  .  UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {    lastChar  =  c  ;  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;    if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }  }  }    if  (  isEndOfFile  (  lastChar  )  ||  (  !isDelimiter  (  lastChar  )  &&  isEndOfFile  (  c  )  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }    while  (  tkn  .  type  =  =  INVALID  )  {    if  (  surroundingSpacesIgnored  )  {  while  (  isWhitespace  (  c  )  &&  !eol  )  {  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  }  }    if  (  isCommentStart  (  c  )  )  {    in  .  readLine  (  )  ;  tkn  =  nextToken  (  tkn  .  reset  (  )  )  ;  [ATTENTION]  }  else  if  (  isDelimiter  (  c  )  )  {  if  (  eol  )  {  tkn  .  type  =  EORECORD  ;  }else  if  (  isEncapsulator  (  c  )  )  {  encapsulatedTokenLexer  (  tkn  ,  c  )    ;  }else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  }else  {  simpleTokenLexer  (  tkn  ,  c  )    ;  }//  empty  token  return  TOKEN  (     "   "  )  tkn  .  type  =  TOKEN  ;  }  else  if  (  eol  )  {      tkn  .  type  =  EORECORD  ;  }  else  if  (  isEncapsulator  (  c  )  )  {    encapsulatedTokenLexer  (  tkn  ,  c  )  ;  }  else  if  (  isEndOfFile  (  c  )  )  {      tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  there  is  data  at  EOF  }  else  {      simpleTokenLexer  (  tkn  ,  c  )  ;  }  }  return  tkn  ;      	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^96^^^^^41^118^
[REPLACE]    }    else    if    (    isEncapsulator    (    c    )    )    {  	[BUGGY]  else  if  (  isEndOfFile  (  c  )  )  {[FE]    (startline  0)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,     "abc   "  ,  parser.nextToken(new  Token()))      [METHOD]    nextToken  [TYPE]  Token  [PARAMETER]  Token  tkn  [CLASS]  CSVLexer    [TYPE]  boolean  eol  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  lastChar    [CONTEXT]    Token  nextToken  (  Token  tkn  )  throws  IOException  {    int  lastChar  =  in  .  readAgain  (  )  ;              int  c  =  in  .  read  (  )  ;  boolean  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;      if  (  emptyLinesIgnored  )  {  while  (  eol  &&  (  lastChar  =  =  '\n'  ||  lastChar  =  =  '\r'  ||  lastChar  =  =  ExtendedBufferedReader  .  UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {    lastChar  =  c  ;  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  c  =  in  .  readAgain  (  )  ;    if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }  }  }    if  (  isEndOfFile  (  lastChar  )  ||  (  !isDelimiter  (  lastChar  )  &&  isEndOfFile  (  c  )  )  )  {  tkn  .  type  =  EOF  ;    return  tkn  ;  }    while  (  tkn  .  type  =  =  INVALID  )  {    if  (  surroundingSpacesIgnored  )  {  while  (  isWhitespace  (  c  )  &&  !eol  )  {  c  =  in  .  read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  }  }    if  (  isCommentStart  (  c  )  )  {    in  .  readLine  (  )  ;  tkn  =  nextToken  (  tkn  .  reset  (  )  )  ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  }  else  if  (  eol  )  {      tkn  .  type  =  EORECORD  ;  [ATTENTION]  }  else  if  (  isEndOfFile  (  c  )  )  {    encapsulatedTokenLexer  (  tkn  ,  c  )  ;  }  else  if  (  isEndOfFile  (  c  )  )  {      tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  there  is  data  at  EOF  }  else  {      simpleTokenLexer  (  tkn  ,  c  )  ;  }  }  return  tkn  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^103^^^^^41^118^
[REPLACE]    while    (    true    )    {  	[BUGGY]  while  (  false  )  {[CE]  unreachable  statement    [METHOD]    simpleTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c    [CONTEXT]    private  Token  simpleTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {  [ATTENTION]  while  (  false  )  {  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  break  ;  }  else  if  (  isEndOfFile  (  c  )  )  {    tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  break  ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  break  ;  }  else  if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  {  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  c  =  in  .  read  (  )  ;  }  if  (  surroundingSpacesIgnored  )  {  trimTrailingSpaces  (  tkn  .  content  )  ;  }  return  tkn  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^138^^^^^137^166^
[REPLACE]    if    (    isEndOfLine    (    c    )    )    {  	[BUGGY]  if  (  isEscape  (  c  )  )  {[FE]    AssertionFailedError    Token  type  expected:<EORECORD>  but  was:<TOKEN>  assertTokenEquals(TOKEN  ,     "1   "  ,  parser.nextToken(new  Token()))      [METHOD]    simpleTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c    [CONTEXT]    private  Token  simpleTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {  while  (  true  )  {  [ATTENTION]  if  (  isEscape  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  break  ;  }  else  if  (  isEndOfFile  (  c  )  )  {    tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  break  ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  break  ;  }  else  if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  {  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  c  =  in  .  read  (  )  ;  }  if  (  surroundingSpacesIgnored  )  {  trimTrailingSpaces  (  tkn  .  content  )  ;  }  return  tkn  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^139^^^^^137^166^
[REPLACE]    }    else    if    (    isEndOfFile    (    c    )    )    {  	[BUGGY]    if  (  isEndOfFile  (  c  )  )  {[NO-ERROR]    [METHOD]    simpleTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c    [CONTEXT]    private  Token  simpleTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {  while  (  true  )  {  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  break  ;  [ATTENTION]  }if  (  isEndOfFile  (  c  )  )  {    tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  break  ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  break  ;  }  else  if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  {  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  c  =  in  .  read  (  )  ;  }  if  (  surroundingSpacesIgnored  )  {  trimTrailingSpaces  (  tkn  .  content  )  ;  }  return  tkn  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^143^^^^^137^166^
[REPLACE]    }    else    if    (    isDelimiter    (    c    )    )    {  	[BUGGY]    if  (  isDelimiter  (  c  )  )  {[NO-ERROR]    [METHOD]    simpleTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c    [CONTEXT]    private  Token  simpleTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {  while  (  true  )  {  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  break  ;  }  else  if  (  isEndOfFile  (  c  )  )  {    tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  break  ;  [ATTENTION]  }if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  break  ;  }  else  if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  {  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  c  =  in  .  read  (  )  ;  }  if  (  surroundingSpacesIgnored  )  {  trimTrailingSpaces  (  tkn  .  content  )  ;  }  return  tkn  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^148^^^^^137^166^
[REMOVE]      	[BUGGY]  if  (  isEncapsulator  (  c  )  )  {      encapsulatedTokenLexer  (  tkn  ,  c  )  ;  }else      if  (  isEndOfFile  (  c  )  )  {          tkn  .  type  =  EOF  ;          tkn  .  isReady  =  true  ;      }else  {          simpleTokenLexer  (  tkn  ,  c  )  ;      }[FE]    null  assertTokenEquals(TOKEN  ,     "abc   "  ,  parser.nextToken(new  Token()))      [METHOD]    simpleTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c    [CONTEXT]    private  Token  simpleTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {  while  (  true  )  {  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  break  ;  }  else  if  (  isEndOfFile  (  c  )  )  {    tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  break  ;  [ATTENTION]  }  else  if  (  isDelimiter  (  c  )  )  {  if  (  isEncapsulator  (  c  )  )  {  encapsulatedTokenLexer  (  tkn  ,  c  )    ;  }else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  }else  {  simpleTokenLexer  (  tkn  ,  c  )    ;  }//  end  of  token  tkn  .  type  =  TOKEN  ;  break  ;  }  else  if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  {  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  c  =  in  .  read  (  )  ;  }  if  (  surroundingSpacesIgnored  )  {  trimTrailingSpaces  (  tkn  .  content  )  ;  }  return  tkn  ;      	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^148^^^^^137^166^
[REPLACE]    }    else    if    (    isEscape    (    c    )    )    {  	[BUGGY]    if  (  isEscape  (  c  )  )  {[NO-ERROR]    [METHOD]    simpleTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c    [CONTEXT]    private  Token  simpleTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {  while  (  true  )  {  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  break  ;  }  else  if  (  isEndOfFile  (  c  )  )  {    tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  break  ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  break  ;  [ATTENTION]  }if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  {  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  c  =  in  .  read  (  )  ;  }  if  (  surroundingSpacesIgnored  )  {  trimTrailingSpaces  (  tkn  .  content  )  ;  }  return  tkn  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^152^^^^^137^166^
[REPLACE]    tkn    .    content    .    append    (    (    char    )    c    )    ;  	[BUGGY]  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  [FE]    AssertionFailedError    Token  content  expected:<[abc]>  but  was:<[  assertTokenEquals(TOKEN  ,     "abc   "  ,  parser.nextToken(new  Token()))      [METHOD]    simpleTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c    [CONTEXT]    }  else  if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  {  [ATTENTION]  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )    ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^155^^^^^152^156^
[ADD]    tkn    .    content    .    append    (    (    char    )    c    )    ;  	[BUGGY]  [FE]    AssertionFailedError    Token  content  expected:<[abc]>  but  was:<[]>  assertTokenEquals(TOKEN  ,     "abc   "  ,  parser.nextToken(new  Token()))      [METHOD]    simpleTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c    [CONTEXT]    }  else  if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  {  [ATTENTION]  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^155^^^^^152^156^
[REPLACE]    tkn    .    content    .    append    (    (    char    )    readEscape    (    c    )    )    ;  	[BUGGY]  tkn  .  content  .  append  (  (  char  )  c  )  ;  [FE]    null  assertTrue(records.size()  >  0)      [METHOD]    simpleTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c    [CONTEXT]    private  Token  simpleTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {  while  (  true  )  {  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  break  ;  }  else  if  (  isEndOfFile  (  c  )  )  {    tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  break  ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  break  ;  }  else  if  (  isEscape  (  c  )  )  {  [ATTENTION]  tkn  .  content  .  append  (  (  char  )  c  )    ;  }  else  {  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  c  =  in  .  read  (  )  ;  }  if  (  surroundingSpacesIgnored  )  {  trimTrailingSpaces  (  tkn  .  content  )  ;  }  return  tkn  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^153^^^^^137^166^
[REPLACE]    tkn    .    type    =    TOKEN;  	[BUGGY]  tkn  .  type  =  EOF  ;    ;  [FE]    AssertionFailedError    Token  type  expected:<TOKEN>  but  was:<EOF>  assertTokenEquals(TOKEN  ,     "abc   "  ,  parser.nextToken(new  Token()))      [METHOD]    simpleTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c    [CONTEXT]    private  Token  simpleTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {  while  (  true  )  {  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  break  ;  }  else  if  (  isEndOfFile  (  c  )  )  {    tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  break  ;  }  else  if  (  isDelimiter  (  c  )  )  {    [ATTENTION]  tkn  .  type  =  EOF  ;    ;  break  ;  }  else  if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  {  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  c  =  in  .  read  (  )  ;  }  if  (  surroundingSpacesIgnored  )  {  trimTrailingSpaces  (  tkn  .  content  )  ;  }  return  tkn  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^150^^^^^137^166^
[REPLACE]    }    else    if    (    isEscape    (    c    )    )    {  	[BUGGY]    else  {[CE]  'else'  without  'if'    [METHOD]    simpleTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c    [CONTEXT]    private  Token  simpleTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {  while  (  true  )  {  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  break  ;  }  else  if  (  isEndOfFile  (  c  )  )  {    tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  break  ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  break  ;  [ATTENTION]  }else  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  {  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  c  =  in  .  read  (  )  ;  }  if  (  surroundingSpacesIgnored  )  {  trimTrailingSpaces  (  tkn  .  content  )  ;  }  return  tkn  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^152^^^^^137^166^
[ADD]    tkn    .    content    .    append    (    (    char    )    readEscape    (    c    )    )    ;  	[BUGGY]  [FE]    null  assertTrue(records.size()  >  0)      [METHOD]    simpleTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c    [CONTEXT]    private  Token  simpleTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {  while  (  true  )  {  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  break  ;  }  else  if  (  isEndOfFile  (  c  )  )  {    tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  break  ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  break  ;  }  else  if  (  isEscape  (  c  )  )  {  [ATTENTION]  }  else  {  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  c  =  in  .  read  (  )  ;  }  if  (  surroundingSpacesIgnored  )  {  trimTrailingSpaces  (  tkn  .  content  )  ;  }  return  tkn  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^153^^^^^137^166^
[REPLACE]    tkn    .    type    =    EOF;  	[BUGGY]  tkn  .  type  =  TOKEN  ;    ;  [FE]    AssertionFailedError    Token  type  expected:<EOF>  but  was:<TOKEN>  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    simpleTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c    [CONTEXT]    private  Token  simpleTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {  while  (  true  )  {  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  break  ;  }  else  if  (  isEndOfFile  (  c  )  )  {    [ATTENTION]  tkn  .  type  =  TOKEN  ;    ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  break  ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  break  ;  }  else  if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  {  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  c  =  in  .  read  (  )  ;  }  if  (  surroundingSpacesIgnored  )  {  trimTrailingSpaces  (  tkn  .  content  )  ;  }  return  tkn  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^145^^^^^137^166^
[REPLACE]    tkn    .    isReady    =    true;  	[BUGGY]  tkn  .  isReady  =  false  ;  [FE]    null  assertEquals(0  ,  parser.getLineNumber())      [METHOD]    simpleTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c    [CONTEXT]    private  Token  simpleTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {  while  (  true  )  {  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  break  ;  }  else  if  (  isEndOfFile  (  c  )  )  {    tkn  .  type  =  EOF  ;  [ATTENTION]  tkn  .  isReady  =  false  ;  break  ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  break  ;  }  else  if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  {  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  c  =  in  .  read  (  )  ;  }  if  (  surroundingSpacesIgnored  )  {  trimTrailingSpaces  (  tkn  .  content  )  ;  }  return  tkn  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^146^^^^^137^166^
[REPLACE]    tkn    .    type    =    EORECORD;  	[BUGGY]  tkn  .  type    =  null  ;  [FE]    AssertionFailedError    Token  type  expected:<EORECORD>  but  was:<null>  assertTokenEquals(TOKEN  ,     "1   "  ,  parser.nextToken(new  Token()))      [METHOD]    simpleTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c    [CONTEXT]    private  Token  simpleTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {  while  (  true  )  {  if  (  isEndOfLine  (  c  )  )  {    [ATTENTION]  tkn  .  type  =  null  ;  break  ;  }  else  if  (  isEndOfFile  (  c  )  )  {    tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  break  ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  break  ;  }  else  if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  {  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  c  =  in  .  read  (  )  ;  }  if  (  surroundingSpacesIgnored  )  {  trimTrailingSpaces  (  tkn  .  content  )  ;  }  return  tkn  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^141^^^^^137^166^
[REPLACE]    }    else    if    (    isEndOfFile    (    c    )    )    {  	[BUGGY]    else  {[CE]  'else'  without  'if'    [METHOD]    simpleTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c    [CONTEXT]    private  Token  simpleTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {  while  (  true  )  {  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  break  ;  [ATTENTION]  }else  {    tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  break  ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  break  ;  }  else  if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  {  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  c  =  in  .  read  (  )  ;  }  if  (  surroundingSpacesIgnored  )  {  trimTrailingSpaces  (  tkn  .  content  )  ;  }  return  tkn  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^143^^^^^137^166^
[ADD]    else    if    (    isEndOfFile    (    c    )    )    {    tkn    .    type    =    EOF;    tkn    .    isReady    =    true;    break;  	[BUGGY]    tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  break  ;  [CE]  'else'  without  'if'    [METHOD]    simpleTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c    [CONTEXT]    private  Token  simpleTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {  while  (  true  )  {  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  break  ;  [ATTENTION]  }  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  break  ;      }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  break  ;  }  else  if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  {  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  c  =  in  .  read  (  )  ;  }  if  (  surroundingSpacesIgnored  )  {  trimTrailingSpaces  (  tkn  .  content  )  ;  }  return  tkn  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^143^144^145^146^147^137^166^
[REPLACE]    }    else    if    (    isDelimiter    (    c    )    )    {  	[BUGGY]    else  {[CE]  'else'  without  'if'    [METHOD]    simpleTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c    [CONTEXT]    private  Token  simpleTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {  while  (  true  )  {  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  break  ;  }  else  if  (  isEndOfFile  (  c  )  )  {    tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  break  ;  [ATTENTION]  }else  {    tkn  .  type  =  TOKEN  ;  break  ;  }  else  if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  {  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  c  =  in  .  read  (  )  ;  }  if  (  surroundingSpacesIgnored  )  {  trimTrailingSpaces  (  tkn  .  content  )  ;  }  return  tkn  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^148^^^^^137^166^
[REMOVE]      	[BUGGY]  int  c  =  in  .  read  (  )  ;  [CE]  variable  c  is  already  defined  in  method  simpleTokenLexer(Token  ,  int)    [METHOD]    simpleTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c    [CONTEXT]    private  Token  simpleTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {  while  (  true  )  {  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  break  ;  }  else  if  (  isEndOfFile  (  c  )  )  {    tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  break  ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  break  ;  }  else  if  (  isEscape  (  c  )  )  {  [ATTENTION]  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;    int  c  =  in  .  read  (  )    ;  }  else  {  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  c  =  in  .  read  (  )  ;  }  if  (  surroundingSpacesIgnored  )  {  trimTrailingSpaces  (  tkn  .  content  )  ;  }  return  tkn  ;      	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^153^^^^^137^166^
[REPLACE]    tkn    .    type    =    EORECORD;  	[BUGGY]  tkn  .  type    =    tkn  .  type  ;  [FE]    AssertionFailedError    Token  type  expected:<EORECORD>  but  was:<TOKEN>  assertTokenEquals(TOKEN  ,     "1   "  ,  parser.nextToken(new  Token()))      [METHOD]    simpleTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c    [CONTEXT]    private  Token  simpleTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {  while  (  true  )  {  if  (  isEndOfLine  (  c  )  )  {    [ATTENTION]  tkn  .  type  =  tkn  .  type  ;  break  ;  }  else  if  (  isEndOfFile  (  c  )  )  {    tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  break  ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  break  ;  }  else  if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  {  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  c  =  in  .  read  (  )  ;  }  if  (  surroundingSpacesIgnored  )  {  trimTrailingSpaces  (  tkn  .  content  )  ;  }  return  tkn  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^141^^^^^137^166^
[ADD]    tkn    .    type    =    EORECORD;  	[BUGGY]  [FE]    AssertionFailedError    Token  type  expected:<EORECORD>  but  was:<TOKEN>  assertTokenEquals(TOKEN  ,     "1   "  ,  parser.nextToken(new  Token()))      [METHOD]    simpleTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c    [CONTEXT]    private  Token  simpleTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {  while  (  true  )  {  if  (  isEndOfLine  (  c  )  )  {    [ATTENTION]  break  ;  }  else  if  (  isEndOfFile  (  c  )  )  {    tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  break  ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  break  ;  }  else  if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  {  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  c  =  in  .  read  (  )  ;  }  if  (  surroundingSpacesIgnored  )  {  trimTrailingSpaces  (  tkn  .  content  )  ;  }  return  tkn  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^141^^^^^137^166^
[ADD]    tkn    .    isReady    =    true;  	[BUGGY]  [FE]    null  assertEquals(0  ,  parser.getLineNumber())      [METHOD]    simpleTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c    [CONTEXT]    private  Token  simpleTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {  while  (  true  )  {  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  break  ;  }  else  if  (  isEndOfFile  (  c  )  )  {    tkn  .  type  =  EOF  ;  [ATTENTION]  break  ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  break  ;  }  else  if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  {  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  c  =  in  .  read  (  )  ;  }  if  (  surroundingSpacesIgnored  )  {  trimTrailingSpaces  (  tkn  .  content  )  ;  }  return  tkn  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^146^^^^^137^166^
[REPLACE]    c    =    in    .    read    (    )    ;  	[BUGGY]  c  =  in  .  readAgain  (  )  ;    ;  [FE]  [METHOD]    simpleTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c    [CONTEXT]    private  Token  simpleTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {  while  (  true  )  {  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  break  ;  }  else  if  (  isEndOfFile  (  c  )  )  {    tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  break  ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  break  ;  }  else  if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  {  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  [ATTENTION]  c  =  in  .  readAgain  (  )    ;    ;  }  if  (  surroundingSpacesIgnored  )  {  trimTrailingSpaces  (  tkn  .  content  )  ;  }  return  tkn  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^158^^^^^137^166^
[REMOVE]      	[BUGGY]  if  (  eol  )  {      tkn  .  type  =  EORECORD  ;  }else      if  (  isEncapsulator  (  c  )  )  {          encapsulatedTokenLexer  (  tkn  ,  c  )  ;      }else          if  (  isEndOfFile  (  c  )  )  {              tkn  .  type  =  EOF  ;              tkn  .  isReady  =  true  ;          }else  {              simpleTokenLexer  (  tkn  ,  c  )  ;          }[CE]  cannot  find  symbol  eol    [METHOD]    simpleTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c    [CONTEXT]    private  Token  simpleTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {  while  (  true  )  {  [ATTENTION]  if  (  isEndOfLine  (  c  )  )  {  if  (  eol  )  {  tkn  .  type  =  EORECORD  ;  }else  if  (  isEncapsulator  (  c  )  )  {  encapsulatedTokenLexer  (  tkn  ,  c  )    ;  }else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  }else  {  simpleTokenLexer  (  tkn  ,  c  )    ;  }//  end  of  record  tkn  .  type  =  EORECORD  ;  break  ;  }  else  if  (  isEndOfFile  (  c  )  )  {    tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  break  ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  break  ;  }  else  if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  {  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  c  =  in  .  read  (  )  ;  }  if  (  surroundingSpacesIgnored  )  {  trimTrailingSpaces  (  tkn  .  content  )  ;  }  return  tkn  ;      	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^139^^^^^137^166^
[REPLACE]    }    else    if    (    isEndOfFile    (    c    )    )    {  	[BUGGY]  else  if  (  isDelimiter  (  c  )  )  {[FE]  [METHOD]    simpleTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c    [CONTEXT]    private  Token  simpleTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {  while  (  true  )  {  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  break  ;  [ATTENTION]  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  break  ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  break  ;  }  else  if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  {  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  c  =  in  .  read  (  )  ;  }  if  (  surroundingSpacesIgnored  )  {  trimTrailingSpaces  (  tkn  .  content  )  ;  }  return  tkn  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^143^^^^^137^166^
[REMOVE]      	[BUGGY]  if  (  isDelimiter  (  c  )  )  {      tkn  .  type  =  TOKEN  ;      break  ;  }else      if  (  isEscape  (  c  )  )  {          append  (  (  (  char  )    (  readEscape  (  c  )  )  )  )  ;      }else  {          append  (  (  (  char  )    (  c  )  )  )  ;      }[CE]  cannot  find  symbol    [METHOD]    simpleTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c    [CONTEXT]    private  Token  simpleTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {  while  (  true  )  {  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  break  ;  }  else  if  (  isEndOfFile  (  c  )  )  {    tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  break  ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  break  ;  [ATTENTION]  }  else  if  (  isEscape  (  c  )  )  {  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  break  ;  }else  if  (  isEscape  (  c  )  )  {  append  (  (  (  char  )    (  readEscape  (  c  )  )  )  )    ;  }else  {  append  (  (  (  char  )    (  c  )  )  )    ;  }tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  {  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  c  =  in  .  read  (  )  ;  }  if  (  surroundingSpacesIgnored  )  {  trimTrailingSpaces  (  tkn  .  content  )  ;  }  return  tkn  ;      	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^152^^^^^137^166^
[ADD]    tkn    .    type    =    TOKEN;  	[BUGGY]  [FE]    AssertionFailedError    Token  type  expected:<TOKEN>  but  was:<EOF>  assertTokenEquals(TOKEN  ,     "abc   "  ,  parser.nextToken(new  Token()))      [METHOD]    simpleTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c    [CONTEXT]    private  Token  simpleTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {  while  (  true  )  {  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  break  ;  }  else  if  (  isEndOfFile  (  c  )  )  {    tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  break  ;  }  else  if  (  isDelimiter  (  c  )  )  {    [ATTENTION]  break  ;  }  else  if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  {  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  c  =  in  .  read  (  )  ;  }  if  (  surroundingSpacesIgnored  )  {  trimTrailingSpaces  (  tkn  .  content  )  ;  }  return  tkn  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^150^^^^^137^166^
[ADD]    else    if    (    isEscape    (    c    )    )    {    tkn    .    content    .    append    (    (    char    )    readEscape    (    c    )    )    ;    }    else    {    tkn    .    content    .    append    (    (    char    )    c    )    ;    }  	[BUGGY]    tkn  .  content  .  append  (  (  char  )  c  )  ;  [FE]    null  assertTrue(records.size()  >  0)      [METHOD]    simpleTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c    [CONTEXT]    private  Token  simpleTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {  while  (  true  )  {  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  break  ;  }  else  if  (  isEndOfFile  (  c  )  )  {    tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  break  ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  break  ;  [ATTENTION]  }  tkn  .  content  .  append  (  (  char  )  c  )    ;        c  =  in  .  read  (  )  ;  }  if  (  surroundingSpacesIgnored  )  {  trimTrailingSpaces  (  tkn  .  content  )  ;  }  return  tkn  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^152^153^154^155^156^137^166^
[ADD]    else    if    (    isEscape    (    c    )    )    {    tkn    .    content    .    append    (    (    char    )    readEscape    (    c    )    )    ;    }    else    {    tkn    .    content    .    append    (    (    char    )    c    )    ;    }  	[BUGGY]    tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  [FE]    AssertionFailedError    Token  content  expected:<[abc]>  but  was:<[  assertTokenEquals(TOKEN  ,     "abc   "  ,  parser.nextToken(new  Token()))      [METHOD]    simpleTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c    [CONTEXT]    private  Token  simpleTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {  while  (  true  )  {  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  break  ;  }  else  if  (  isEndOfFile  (  c  )  )  {    tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  break  ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  break  ;  [ATTENTION]  }  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )    ;  tkn  .  content  .  append  (  (  char  )  c  )    ;        c  =  in  .  read  (  )  ;  }  if  (  surroundingSpacesIgnored  )  {  trimTrailingSpaces  (  tkn  .  content  )  ;  }  return  tkn  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^152^153^154^155^156^137^166^
[ADD]    else    if    (    isDelimiter    (    c    )    )    {    tkn    .    type    =    TOKEN;    break;  	[BUGGY]    tkn  .  type  =  TOKEN  ;  break  ;  [CE]  'else'  without  'if'    [METHOD]    simpleTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c    [CONTEXT]    private  Token  simpleTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {  while  (  true  )  {  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  break  ;  }  else  if  (  isEndOfFile  (  c  )  )  {    tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  break  ;  [ATTENTION]  }  tkn  .  type  =  TOKEN  ;  break  ;      }  else  if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  {  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  c  =  in  .  read  (  )  ;  }  if  (  surroundingSpacesIgnored  )  {  trimTrailingSpaces  (  tkn  .  content  )  ;  }  return  tkn  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^148^149^150^151^^137^166^
[ADD]    tkn    .    type    =    EOF;    tkn    .    isReady    =    true;  	[BUGGY]  tkn  .  isReady  =  true  ;  [FE]  [METHOD]    simpleTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c    [CONTEXT]    private  Token  simpleTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {  while  (  true  )  {  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  break  ;  }  else  if  (  isEndOfFile  (  c  )  )  {    [ATTENTION]  tkn  .  isReady  =  true  ;    break  ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  break  ;  }  else  if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  {  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  c  =  in  .  read  (  )  ;  }  if  (  surroundingSpacesIgnored  )  {  trimTrailingSpaces  (  tkn  .  content  )  ;  }  return  tkn  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^145^146^^^^137^166^
[REPLACE]    }    else    if    (    isEscape    (    c    )    )    {  	[BUGGY]  if  (  isEscape  (  c  )  )  {[CE]  illegal  start  of  expression    [METHOD]    simpleTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c    [CONTEXT]    private  Token  simpleTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {  while  (  true  )  {  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  break  ;  }  else  if  (  isEndOfFile  (  c  )  )  {    tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  break  ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  break  ;  [ATTENTION]  if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  {  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  c  =  in  .  read  (  )  ;  }  if  (  surroundingSpacesIgnored  )  {  trimTrailingSpaces  (  tkn  .  content  )  ;  }  return  tkn  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^152^^^^^137^166^
[ADD]    tkn    .    isReady    =    true;    break;  	[BUGGY]  [FE]  [METHOD]    simpleTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c    [CONTEXT]    private  Token  simpleTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {  while  (  true  )  {  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  break  ;  }  else  if  (  isEndOfFile  (  c  )  )  {    tkn  .  type  =  EOF  ;  [ATTENTION]    }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  break  ;  }  else  if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  {  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  c  =  in  .  read  (  )  ;  }  if  (  surroundingSpacesIgnored  )  {  trimTrailingSpaces  (  tkn  .  content  )  ;  }  return  tkn  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^146^147^^^^137^166^
[REPLACE]    if    (    surroundingSpacesIgnored    )    {  	[BUGGY]  if  (  isEscape  (  c  )  )  {[FE]    AssertionFailedError    Token  content  expected:<uv[]>  but  was:<uv[  ]>  assertTokenEquals(TOKEN  ,     "abc   "  ,  parser.nextToken(new  Token()))      [METHOD]    simpleTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c    [CONTEXT]    private  Token  simpleTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {  while  (  true  )  {  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  break  ;  }  else  if  (  isEndOfFile  (  c  )  )  {    tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  break  ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  break  ;  }  else  if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  {  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  c  =  in  .  read  (  )  ;  }  [ATTENTION]  if  (  isEscape  (  c  )  )  {  trimTrailingSpaces  (  tkn  .  content  )  ;  }  return  tkn  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^161^^^^^137^166^
[REPLACE]    trimTrailingSpaces    (    tkn    .    content    )    ;  	[BUGGY]  simpleTokenLexer  (  tkn  ,  c  )  ;  [FE]    null  assertTokenEquals(TOKEN  ,     "abc   "  ,  parser.nextToken(new  Token()))      [METHOD]    simpleTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c    [CONTEXT]    private  Token  simpleTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {  while  (  true  )  {  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  break  ;  }  else  if  (  isEndOfFile  (  c  )  )  {    tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  break  ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  break  ;  }  else  if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  {  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  c  =  in  .  read  (  )  ;  }  if  (  surroundingSpacesIgnored  )  {  [ATTENTION]  simpleTokenLexer  (  tkn  ,  c  )    ;  }  return  tkn  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^162^^^^^137^166^
[ADD]    trimTrailingSpaces    (    tkn    .    content    )    ;  	[BUGGY]  [FE]    AssertionFailedError    Token  content  expected:<uv[]>  but  was:<uv[  ]>  assertTokenEquals(TOKEN  ,     "abc   "  ,  parser.nextToken(new  Token()))      [METHOD]    simpleTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c    [CONTEXT]    private  Token  simpleTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {  while  (  true  )  {  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  break  ;  }  else  if  (  isEndOfFile  (  c  )  )  {    tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  break  ;  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  TOKEN  ;  break  ;  }  else  if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  {  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  c  =  in  .  read  (  )  ;  }  if  (  surroundingSpacesIgnored  )  {  [ATTENTION]  }  return  tkn  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^162^^^^^137^166^
[REPLACE]    int    startLineNumber    =    getLineNumber    (    )    ;  	[BUGGY]  int  lastChar  =  in  .  readAgain  (  )  ;  [CE]  cannot  find  symbol  startLineNumber    [METHOD]    encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber    [CONTEXT]    private  Token  encapsulatedTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {    [ATTENTION]  int  lastChar  =  in  .  readAgain  (  )    ;      while  (  true  )  {  c  =  in  .  read  (  )  ;    if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  if  (  isEncapsulator  (  c  )  )  {  if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (     "  (  line     "  +  getLineNumber  (  )  +     "  )  invalid  char  between  encapsulated  token  and  delimiter   "  )  ;  }  }  }  }  else  if  (  isEndOfFile  (  c  )  )  {    throw  new  IOException  (     "  (  startline     "  +  startLineNumber  +     "  )  EOF  reached  before  encapsulated  token  finished   "  )  ;  }  else  {    tkn  .  content  .  append  (  (  char  )  c  )  ;  }  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^183^^^^^181^225^
[ADD]    int    startLineNumber    =    getLineNumber    (    )    ;  	[BUGGY]  [CE]  cannot  find  symbol  startLineNumber    [METHOD]    encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber    [CONTEXT]    private  Token  encapsulatedTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {    [ATTENTION]      while  (  true  )  {  c  =  in  .  read  (  )  ;    if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  if  (  isEncapsulator  (  c  )  )  {  if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (     "  (  line     "  +  getLineNumber  (  )  +     "  )  invalid  char  between  encapsulated  token  and  delimiter   "  )  ;  }  }  }  }  else  if  (  isEndOfFile  (  c  )  )  {    throw  new  IOException  (     "  (  startline     "  +  startLineNumber  +     "  )  EOF  reached  before  encapsulated  token  finished   "  )  ;  }  else  {    tkn  .  content  .  append  (  (  char  )  c  )  ;  }  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^183^^^^^181^225^
[ADD]    while    (    true    )    {    c    =    in    .    read    (    )    ;  	[BUGGY]  [CE]  class  ,  interface  ,  or  enum  expected    [METHOD]    encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber    [CONTEXT]    private  Token  encapsulatedTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {    int  startLineNumber  =  getLineNumber  (  )  ;      [ATTENTION]    if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  if  (  isEncapsulator  (  c  )  )  {  if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (     "  (  line     "  +  getLineNumber  (  )  +     "  )  invalid  char  between  encapsulated  token  and  delimiter   "  )  ;  }  }  }  }  else  if  (  isEndOfFile  (  c  )  )  {    throw  new  IOException  (     "  (  startline     "  +  startLineNumber  +     "  )  EOF  reached  before  encapsulated  token  finished   "  )  ;  }  else  {    tkn  .  content  .  append  (  (  char  )  c  )  ;  }  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^186^187^^^^181^225^
[REPLACE]    while    (    true    )    {  	[BUGGY]  while  (  false  )  {[CE]  unreachable  statement    [METHOD]    encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber    [CONTEXT]    private  Token  encapsulatedTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {    int  startLineNumber  =  getLineNumber  (  )  ;      while  (  true  )  {  c  =  in  .  read  (  )  ;    if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  if  (  isEncapsulator  (  c  )  )  {  if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    [ATTENTION]  while  (  false  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (     "  (  line     "  +  getLineNumber  (  )  +     "  )  invalid  char  between  encapsulated  token  and  delimiter   "  )  ;  }  }  }  }  else  if  (  isEndOfFile  (  c  )  )  {    throw  new  IOException  (     "  (  startline     "  +  startLineNumber  +     "  )  EOF  reached  before  encapsulated  token  finished   "  )  ;  }  else  {    tkn  .  content  .  append  (  (  char  )  c  )  ;  }  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^198^^^^^181^225^
[REPLACE]    if    (    isDelimiter    (    c    )    )    {  	[BUGGY]  if  (  isEscape  (  c  )  )  {[FE]    (line  0)  invalid  char  between  encapsulated  token  and  delimiter  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber    [CONTEXT]    private  Token  encapsulatedTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {    int  startLineNumber  =  getLineNumber  (  )  ;      while  (  true  )  {  c  =  in  .  read  (  )  ;    if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  if  (  isEncapsulator  (  c  )  )  {  if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  [ATTENTION]  if  (  isEscape  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (     "  (  line     "  +  getLineNumber  (  )  +     "  )  invalid  char  between  encapsulated  token  and  delimiter   "  )  ;  }  }  }  }  else  if  (  isEndOfFile  (  c  )  )  {    throw  new  IOException  (     "  (  startline     "  +  startLineNumber  +     "  )  EOF  reached  before  encapsulated  token  finished   "  )  ;  }  else  {    tkn  .  content  .  append  (  (  char  )  c  )  ;  }  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^200^^^^^181^225^
[REPLACE]    }    else    if    (    isEndOfFile    (    c    )    )    {  	[BUGGY]    if  (  isEndOfFile  (  c  )  )  {[NO-ERROR]    [METHOD]    encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber    [CONTEXT]    private  Token  encapsulatedTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {    int  startLineNumber  =  getLineNumber  (  )  ;      while  (  true  )  {  c  =  in  .  read  (  )  ;    if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  if  (  isEncapsulator  (  c  )  )  {  if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  [ATTENTION]  }if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (     "  (  line     "  +  getLineNumber  (  )  +     "  )  invalid  char  between  encapsulated  token  and  delimiter   "  )  ;  }  }  }  }  else  if  (  isEndOfFile  (  c  )  )  {    throw  new  IOException  (     "  (  startline     "  +  startLineNumber  +     "  )  EOF  reached  before  encapsulated  token  finished   "  )  ;  }  else  {    tkn  .  content  .  append  (  (  char  )  c  )  ;  }  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^203^^^^^181^225^
[ADD]    else    if    (    isEndOfFile    (    c    )    )    {    tkn    .    type    =    EOF;    tkn    .    isReady    =    true;    return    tkn;  	[BUGGY]    tkn  .  isReady  =  true  ;  return  tkn  ;  [CE]  'else'  without  'if'    [METHOD]    encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber    [CONTEXT]    private  Token  encapsulatedTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {    int  startLineNumber  =  getLineNumber  (  )  ;      while  (  true  )  {  c  =  in  .  read  (  )  ;    if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  if  (  isEncapsulator  (  c  )  )  {  if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  [ATTENTION]  }  tkn  .  isReady  =  true  ;  return  tkn  ;      }  else  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (     "  (  line     "  +  getLineNumber  (  )  +     "  )  invalid  char  between  encapsulated  token  and  delimiter   "  )  ;  }  }  }  }  else  if  (  isEndOfFile  (  c  )  )  {    throw  new  IOException  (     "  (  startline     "  +  startLineNumber  +     "  )  EOF  reached  before  encapsulated  token  finished   "  )  ;  }  else  {    tkn  .  content  .  append  (  (  char  )  c  )  ;  }  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^203^204^205^206^^181^225^
[REPLACE]    }    else    if    (    isEndOfLine    (    c    )    )    {  	[BUGGY]    else  {[CE]  'else'  without  'if'    [METHOD]    encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber    [CONTEXT]    private  Token  encapsulatedTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {    int  startLineNumber  =  getLineNumber  (  )  ;      while  (  true  )  {  c  =  in  .  read  (  )  ;    if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  if  (  isEncapsulator  (  c  )  )  {  if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  [ATTENTION]  }else  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (     "  (  line     "  +  getLineNumber  (  )  +     "  )  invalid  char  between  encapsulated  token  and  delimiter   "  )  ;  }  }  }  }  else  if  (  isEndOfFile  (  c  )  )  {    throw  new  IOException  (     "  (  startline     "  +  startLineNumber  +     "  )  EOF  reached  before  encapsulated  token  finished   "  )  ;  }  else  {    tkn  .  content  .  append  (  (  char  )  c  )  ;  }  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^207^^^^^181^225^
[REPLACE]    }    else    if    (    !isWhitespace    (    c    )    )    {  	[BUGGY]    if  (  isWhitespace  (  c  )  )  {[FE]    (line  2)  invalid  char  between  encapsulated  token  and  delimiter  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber    [CONTEXT]    private  Token  encapsulatedTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {    int  startLineNumber  =  getLineNumber  (  )  ;      while  (  true  )  {  c  =  in  .  read  (  )  ;    if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  if  (  isEncapsulator  (  c  )  )  {  if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  [ATTENTION]  }if  (  isWhitespace  (  c  )  )  {    throw  new  IOException  (     "  (  line     "  +  getLineNumber  (  )  +     "  )  invalid  char  between  encapsulated  token  and  delimiter   "  )  ;  }  }  }  }  else  if  (  isEndOfFile  (  c  )  )  {    throw  new  IOException  (     "  (  startline     "  +  startLineNumber  +     "  )  EOF  reached  before  encapsulated  token  finished   "  )  ;  }  else  {    tkn  .  content  .  append  (  (  char  )  c  )  ;  }  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^211^^^^^181^225^
[ADD]    else    if    (    !isWhitespace    (    c    )    )    {    throw    new    IOException    (   "       ")    ;    }  	[BUGGY]  [NO-ERROR]    [METHOD]    encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber    [CONTEXT]    private  Token  encapsulatedTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {    int  startLineNumber  =  getLineNumber  (  )  ;      while  (  true  )  {  c  =  in  .  read  (  )  ;    if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  if  (  isEncapsulator  (  c  )  )  {  if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  [ATTENTION]  }    }  }  }  else  if  (  isEndOfFile  (  c  )  )  {    throw  new  IOException  (     "  (  startline     "  +  startLineNumber  +     "  )  EOF  reached  before  encapsulated  token  finished   "  )  ;  }  else  {    tkn  .  content  .  append  (  (  char  )  c  )  ;  }  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^211^212^213^214^^181^225^
[REPLACE]    throw    new    IOException    (   "       ")    ;  	[BUGGY]  return  ;  [CE]  missing  return  value    [METHOD]    encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber    [CONTEXT]    private  Token  encapsulatedTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {    int  startLineNumber  =  getLineNumber  (  )  ;      while  (  true  )  {  c  =  in  .  read  (  )  ;    if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  if  (  isEncapsulator  (  c  )  )  {  if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    [ATTENTION]  return  ;  }  }  }  }  else  if  (  isEndOfFile  (  c  )  )  {    throw  new  IOException  (     "  (  startline     "  +  startLineNumber  +     "  )  EOF  reached  before  encapsulated  token  finished   "  )  ;  }  else  {    tkn  .  content  .  append  (  (  char  )  c  )  ;  }  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^213^^^^^181^225^
[ADD]    throw    new    IOException    (   "       ")    ;  	[BUGGY]  [NO-ERROR]    [METHOD]    encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber    [CONTEXT]    private  Token  encapsulatedTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {    int  startLineNumber  =  getLineNumber  (  )  ;      while  (  true  )  {  c  =  in  .  read  (  )  ;    if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  if  (  isEncapsulator  (  c  )  )  {  if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    [ATTENTION]  }  }  }  }  else  if  (  isEndOfFile  (  c  )  )  {    throw  new  IOException  (     "  (  startline     "  +  startLineNumber  +     "  )  EOF  reached  before  encapsulated  token  finished   "  )  ;  }  else  {    tkn  .  content  .  append  (  (  char  )  c  )  ;  }  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^213^^^^^181^225^
[REPLACE]    throw    new    IOException    (   "       ")    ;  	[BUGGY]  eol  =  isEndOfLine  (  c  )  ;  [CE]  cannot  find  symbol  eol    [METHOD]    encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber    [CONTEXT]    private  Token  encapsulatedTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {    int  startLineNumber  =  getLineNumber  (  )  ;      while  (  true  )  {  c  =  in  .  read  (  )  ;    if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  if  (  isEncapsulator  (  c  )  )  {  if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    [ATTENTION]  eol  =  isEndOfLine  (  c  )    ;  }  }  }  }  else  if  (  isEndOfFile  (  c  )  )  {    throw  new  IOException  (     "  (  startline     "  +  startLineNumber  +     "  )  EOF  reached  before  encapsulated  token  finished   "  )  ;  }  else  {    tkn  .  content  .  append  (  (  char  )  c  )  ;  }  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^213^^^^^181^225^
[REPLACE]    tkn    .    type    =    EORECORD;  	[BUGGY]  tkn  .  type  ;  [CE]  not  a  statement    [METHOD]    encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber    [CONTEXT]    private  Token  encapsulatedTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {    int  startLineNumber  =  getLineNumber  (  )  ;      while  (  true  )  {  c  =  in  .  read  (  )  ;    if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  if  (  isEncapsulator  (  c  )  )  {  if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    [ATTENTION]  tkn  .  type  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (     "  (  line     "  +  getLineNumber  (  )  +     "  )  invalid  char  between  encapsulated  token  and  delimiter   "  )  ;  }  }  }  }  else  if  (  isEndOfFile  (  c  )  )  {    throw  new  IOException  (     "  (  startline     "  +  startLineNumber  +     "  )  EOF  reached  before  encapsulated  token  finished   "  )  ;  }  else  {    tkn  .  content  .  append  (  (  char  )  c  )  ;  }  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^209^^^^^181^225^
[REPLACE]    tkn    .    type    =    EORECORD;  	[BUGGY]  tkn  .  type    =    tkn  .  type  ;  [FE]    AssertionFailedError    Token  type  expected:<EORECORD>  but  was:<EOF>  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber    [CONTEXT]    private  Token  encapsulatedTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {    int  startLineNumber  =  getLineNumber  (  )  ;      while  (  true  )  {  c  =  in  .  read  (  )  ;    if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  if  (  isEncapsulator  (  c  )  )  {  if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    [ATTENTION]  tkn  .  type  =  tkn  .  type  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (     "  (  line     "  +  getLineNumber  (  )  +     "  )  invalid  char  between  encapsulated  token  and  delimiter   "  )  ;  }  }  }  }  else  if  (  isEndOfFile  (  c  )  )  {    throw  new  IOException  (     "  (  startline     "  +  startLineNumber  +     "  )  EOF  reached  before  encapsulated  token  finished   "  )  ;  }  else  {    tkn  .  content  .  append  (  (  char  )  c  )  ;  }  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^209^^^^^181^225^
[REPLACE]    tkn    .    type    =    EOF;  	[BUGGY]  tkn  .  type  =  TOKEN  ;    ;  [FE]    AssertionFailedError    Token  type  expected:<EOF>  but  was:<TOKEN>  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber    [CONTEXT]    private  Token  encapsulatedTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {    int  startLineNumber  =  getLineNumber  (  )  ;      while  (  true  )  {  c  =  in  .  read  (  )  ;    if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  if  (  isEncapsulator  (  c  )  )  {  if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  [ATTENTION]  tkn  .  type  =  TOKEN  ;    ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (     "  (  line     "  +  getLineNumber  (  )  +     "  )  invalid  char  between  encapsulated  token  and  delimiter   "  )  ;  }  }  }  }  else  if  (  isEndOfFile  (  c  )  )  {    throw  new  IOException  (     "  (  startline     "  +  startLineNumber  +     "  )  EOF  reached  before  encapsulated  token  finished   "  )  ;  }  else  {    tkn  .  content  .  append  (  (  char  )  c  )  ;  }  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^204^^^^^181^225^
[REPLACE]    tkn    .    isReady    =    true;  	[BUGGY]  tkn  .  isReady  =  false  ;  [FE]    array  lengths  differed  ,  expected.length  =  2  actual.length  =  1  assertEquals(res.length  ,  records.size())      [METHOD]    encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber    [CONTEXT]    private  Token  encapsulatedTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {    int  startLineNumber  =  getLineNumber  (  )  ;      while  (  true  )  {  c  =  in  .  read  (  )  ;    if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  if  (  isEncapsulator  (  c  )  )  {  if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  [ATTENTION]  tkn  .  isReady  =  false  ;  return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (     "  (  line     "  +  getLineNumber  (  )  +     "  )  invalid  char  between  encapsulated  token  and  delimiter   "  )  ;  }  }  }  }  else  if  (  isEndOfFile  (  c  )  )  {    throw  new  IOException  (     "  (  startline     "  +  startLineNumber  +     "  )  EOF  reached  before  encapsulated  token  finished   "  )  ;  }  else  {    tkn  .  content  .  append  (  (  char  )  c  )  ;  }  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^205^^^^^181^225^
[REPLACE]    }    else    if    (    isEndOfLine    (    c    )    )    {  	[BUGGY]    if  (  isEndOfLine  (  c  )  )  {[NO-ERROR]    [METHOD]    encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber    [CONTEXT]    private  Token  encapsulatedTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {    int  startLineNumber  =  getLineNumber  (  )  ;      while  (  true  )  {  c  =  in  .  read  (  )  ;    if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  if  (  isEncapsulator  (  c  )  )  {  if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  [ATTENTION]  }if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (     "  (  line     "  +  getLineNumber  (  )  +     "  )  invalid  char  between  encapsulated  token  and  delimiter   "  )  ;  }  }  }  }  else  if  (  isEndOfFile  (  c  )  )  {    throw  new  IOException  (     "  (  startline     "  +  startLineNumber  +     "  )  EOF  reached  before  encapsulated  token  finished   "  )  ;  }  else  {    tkn  .  content  .  append  (  (  char  )  c  )  ;  }  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^207^^^^^181^225^
[REPLACE]    }    else    if    (    !isWhitespace    (    c    )    )    {  	[BUGGY]    else  {[FE]    (line  2)  invalid  char  between  encapsulated  token  and  delimiter  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber    [CONTEXT]    private  Token  encapsulatedTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {    int  startLineNumber  =  getLineNumber  (  )  ;      while  (  true  )  {  c  =  in  .  read  (  )  ;    if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  if  (  isEncapsulator  (  c  )  )  {  if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  [ATTENTION]  }else  {    throw  new  IOException  (     "  (  line     "  +  getLineNumber  (  )  +     "  )  invalid  char  between  encapsulated  token  and  delimiter   "  )  ;  }  }  }  }  else  if  (  isEndOfFile  (  c  )  )  {    throw  new  IOException  (     "  (  startline     "  +  startLineNumber  +     "  )  EOF  reached  before  encapsulated  token  finished   "  )  ;  }  else  {    tkn  .  content  .  append  (  (  char  )  c  )  ;  }  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^211^^^^^181^225^
[REPLACE]    tkn    .    type    =    EORECORD;  	[BUGGY]  tkn  .  type    =  null  ;  [FE]    AssertionFailedError    Token  type  expected:<EORECORD>  but  was:<null>  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber    [CONTEXT]    private  Token  encapsulatedTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {    int  startLineNumber  =  getLineNumber  (  )  ;      while  (  true  )  {  c  =  in  .  read  (  )  ;    if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  if  (  isEncapsulator  (  c  )  )  {  if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    [ATTENTION]  tkn  .  type  =  null  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (     "  (  line     "  +  getLineNumber  (  )  +     "  )  invalid  char  between  encapsulated  token  and  delimiter   "  )  ;  }  }  }  }  else  if  (  isEndOfFile  (  c  )  )  {    throw  new  IOException  (     "  (  startline     "  +  startLineNumber  +     "  )  EOF  reached  before  encapsulated  token  finished   "  )  ;  }  else  {    tkn  .  content  .  append  (  (  char  )  c  )  ;  }  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^209^^^^^181^225^
[REPLACE]    tkn    .    type    =    TOKEN;  	[BUGGY]  tkn  .  type  =  EOF  ;    ;  [FE]    AssertionFailedError    Token  type  expected:<TOKEN>  but  was:<EOF>  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber    [CONTEXT]    private  Token  encapsulatedTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {    int  startLineNumber  =  getLineNumber  (  )  ;      while  (  true  )  {  c  =  in  .  read  (  )  ;    if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  if  (  isEncapsulator  (  c  )  )  {  if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  [ATTENTION]  tkn  .  type  =  EOF  ;    ;  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (     "  (  line     "  +  getLineNumber  (  )  +     "  )  invalid  char  between  encapsulated  token  and  delimiter   "  )  ;  }  }  }  }  else  if  (  isEndOfFile  (  c  )  )  {    throw  new  IOException  (     "  (  startline     "  +  startLineNumber  +     "  )  EOF  reached  before  encapsulated  token  finished   "  )  ;  }  else  {    tkn  .  content  .  append  (  (  char  )  c  )  ;  }  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^201^^^^^181^225^
[REPLACE]    }    else    if    (    isEndOfFile    (    c    )    )    {  	[BUGGY]  else  if  (  isDelimiter  (  c  )  )  {[FE]    (line  6)  invalid  char  between  encapsulated  token  and  delimiter  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber    [CONTEXT]    private  Token  encapsulatedTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {    int  startLineNumber  =  getLineNumber  (  )  ;      while  (  true  )  {  c  =  in  .  read  (  )  ;    if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  if  (  isEncapsulator  (  c  )  )  {  if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  [ATTENTION]  }  else  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (     "  (  line     "  +  getLineNumber  (  )  +     "  )  invalid  char  between  encapsulated  token  and  delimiter   "  )  ;  }  }  }  }  else  if  (  isEndOfFile  (  c  )  )  {    throw  new  IOException  (     "  (  startline     "  +  startLineNumber  +     "  )  EOF  reached  before  encapsulated  token  finished   "  )  ;  }  else  {    tkn  .  content  .  append  (  (  char  )  c  )  ;  }  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^203^^^^^181^225^
[ADD]    tkn    .    type    =    EORECORD;    return    tkn;  	[BUGGY]  [FE]    (line  4)  invalid  char  between  encapsulated  token  and  delimiter  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber    [CONTEXT]    private  Token  encapsulatedTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {    int  startLineNumber  =  getLineNumber  (  )  ;      while  (  true  )  {  c  =  in  .  read  (  )  ;    if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  if  (  isEncapsulator  (  c  )  )  {  if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    [ATTENTION]    }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (     "  (  line     "  +  getLineNumber  (  )  +     "  )  invalid  char  between  encapsulated  token  and  delimiter   "  )  ;  }  }  }  }  else  if  (  isEndOfFile  (  c  )  )  {    throw  new  IOException  (     "  (  startline     "  +  startLineNumber  +     "  )  EOF  reached  before  encapsulated  token  finished   "  )  ;  }  else  {    tkn  .  content  .  append  (  (  char  )  c  )  ;  }  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^209^210^^^^181^225^
[ADD]    else    if    (    isEndOfLine    (    c    )    )    {    tkn    .    type    =    EORECORD;    return    tkn;  	[BUGGY]    tkn  .  type  =  EORECORD  ;  return  tkn  ;  [CE]  'else'  without  'if'    [METHOD]    encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber    [CONTEXT]    private  Token  encapsulatedTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {    int  startLineNumber  =  getLineNumber  (  )  ;      while  (  true  )  {  c  =  in  .  read  (  )  ;    if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  if  (  isEncapsulator  (  c  )  )  {  if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  [ATTENTION]  }  tkn  .  type  =  EORECORD  ;  return  tkn  ;      }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (     "  (  line     "  +  getLineNumber  (  )  +     "  )  invalid  char  between  encapsulated  token  and  delimiter   "  )  ;  }  }  }  }  else  if  (  isEndOfFile  (  c  )  )  {    throw  new  IOException  (     "  (  startline     "  +  startLineNumber  +     "  )  EOF  reached  before  encapsulated  token  finished   "  )  ;  }  else  {    tkn  .  content  .  append  (  (  char  )  c  )  ;  }  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^207^208^209^210^^181^225^
[REPLACE]    c    =    in    .    read    (    )    ;  	[BUGGY]  c  =  in  .  readAgain  (  )  ;    ;  [FE]    (line  0)  invalid  char  between  encapsulated  token  and  delimiter  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber    [CONTEXT]    private  Token  encapsulatedTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {    int  startLineNumber  =  getLineNumber  (  )  ;      while  (  true  )  {  c  =  in  .  read  (  )  ;    if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  if  (  isEncapsulator  (  c  )  )  {  if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  [ATTENTION]  c  =  in  .  readAgain  (  )    ;    ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (     "  (  line     "  +  getLineNumber  (  )  +     "  )  invalid  char  between  encapsulated  token  and  delimiter   "  )  ;  }  }  }  }  else  if  (  isEndOfFile  (  c  )  )  {    throw  new  IOException  (     "  (  startline     "  +  startLineNumber  +     "  )  EOF  reached  before  encapsulated  token  finished   "  )  ;  }  else  {    tkn  .  content  .  append  (  (  char  )  c  )  ;  }  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^199^^^^^181^225^
[REPLACE]    if    (    isEscape    (    c    )    )    {  	[BUGGY]  if  (  isDelimiter  (  c  )  )  {[FE]    Token  content  expected:<foo  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber    [CONTEXT]    private  Token  encapsulatedTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {    int  startLineNumber  =  getLineNumber  (  )  ;      while  (  true  )  {  c  =  in  .  read  (  )  ;    [ATTENTION]  if  (  isDelimiter  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  if  (  isEncapsulator  (  c  )  )  {  if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (     "  (  line     "  +  getLineNumber  (  )  +     "  )  invalid  char  between  encapsulated  token  and  delimiter   "  )  ;  }  }  }  }  else  if  (  isEndOfFile  (  c  )  )  {    throw  new  IOException  (     "  (  startline     "  +  startLineNumber  +     "  )  EOF  reached  before  encapsulated  token  finished   "  )  ;  }  else  {    tkn  .  content  .  append  (  (  char  )  c  )  ;  }  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^189^^^^^181^225^
[ADD]    if    (    isEscape    (    c    )    )    {    tkn    .    content    .    append    (    (    char    )    readEscape    (    c    )    )    ;    }    else    if    (    isEncapsulator    (    c    )    )    {    if    (    isEncapsulator    (    in    .    lookAhead    (    )    )    )    {  	[BUGGY]  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  [CE]  'else'  without  'if'    [METHOD]    encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber    [CONTEXT]    private  Token  encapsulatedTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {    int  startLineNumber  =  getLineNumber  (  )  ;      while  (  true  )  {  c  =  in  .  read  (  )  ;    [ATTENTION]  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )    ;        c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (     "  (  line     "  +  getLineNumber  (  )  +     "  )  invalid  char  between  encapsulated  token  and  delimiter   "  )  ;  }  }  }  }  else  if  (  isEndOfFile  (  c  )  )  {    throw  new  IOException  (     "  (  startline     "  +  startLineNumber  +     "  )  EOF  reached  before  encapsulated  token  finished   "  )  ;  }  else  {    tkn  .  content  .  append  (  (  char  )  c  )  ;  }  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^189^190^191^192^^181^225^
[ADD]    if    (    isDelimiter    (    c    )    )    {    tkn    .    type    =    TOKEN;    return    tkn;    }    else    if    (    isEndOfFile    (    c    )    )    {    tkn    .    type    =    EOF;  	[BUGGY]  tkn  .  type  =  TOKEN  ;  return  tkn  ;  tkn  .  type  =  EOF  ;  [CE]  'else'  without  'if'    [METHOD]    encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber    [CONTEXT]    private  Token  encapsulatedTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {    int  startLineNumber  =  getLineNumber  (  )  ;      while  (  true  )  {  c  =  in  .  read  (  )  ;    if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  if  (  isEncapsulator  (  c  )  )  {  if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  [ATTENTION]  tkn  .  type  =  TOKEN  ;  return  tkn  ;  tkn  .  type  =  EOF  ;      tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (     "  (  line     "  +  getLineNumber  (  )  +     "  )  invalid  char  between  encapsulated  token  and  delimiter   "  )  ;  }  }  }  }  else  if  (  isEndOfFile  (  c  )  )  {    throw  new  IOException  (     "  (  startline     "  +  startLineNumber  +     "  )  EOF  reached  before  encapsulated  token  finished   "  )  ;  }  else  {    tkn  .  content  .  append  (  (  char  )  c  )  ;  }  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^200^201^202^203^204^181^225^
[ADD]    else    if    (    isEndOfFile    (    c    )    )    {    tkn    .    type    =    EOF;    tkn    .    isReady    =    true;    return    tkn;  	[BUGGY]    tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  return  tkn  ;  [CE]  'else'  without  'if'    [METHOD]    encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber    [CONTEXT]    private  Token  encapsulatedTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {    int  startLineNumber  =  getLineNumber  (  )  ;      while  (  true  )  {  c  =  in  .  read  (  )  ;    if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  if  (  isEncapsulator  (  c  )  )  {  if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  [ATTENTION]  }  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  return  tkn  ;      }  else  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (     "  (  line     "  +  getLineNumber  (  )  +     "  )  invalid  char  between  encapsulated  token  and  delimiter   "  )  ;  }  }  }  }  else  if  (  isEndOfFile  (  c  )  )  {    throw  new  IOException  (     "  (  startline     "  +  startLineNumber  +     "  )  EOF  reached  before  encapsulated  token  finished   "  )  ;  }  else  {    tkn  .  content  .  append  (  (  char  )  c  )  ;  }  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^203^204^205^206^^181^225^
[REPLACE]    }    else    if    (    !isWhitespace    (    c    )    )    {  	[BUGGY]  else  if  (  isWhitespace  (  c  )  )  {[FE]    (line  2)  invalid  char  between  encapsulated  token  and  delimiter  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber    [CONTEXT]    private  Token  encapsulatedTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {    int  startLineNumber  =  getLineNumber  (  )  ;      while  (  true  )  {  c  =  in  .  read  (  )  ;    if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  if  (  isEncapsulator  (  c  )  )  {  if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  [ATTENTION]  }  else  if  (  isWhitespace  (  c  )  )  {    throw  new  IOException  (     "  (  line     "  +  getLineNumber  (  )  +     "  )  invalid  char  between  encapsulated  token  and  delimiter   "  )  ;  }  }  }  }  else  if  (  isEndOfFile  (  c  )  )  {    throw  new  IOException  (     "  (  startline     "  +  startLineNumber  +     "  )  EOF  reached  before  encapsulated  token  finished   "  )  ;  }  else  {    tkn  .  content  .  append  (  (  char  )  c  )  ;  }  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^211^^^^^181^225^
[ADD]    tkn    .    type    =    EORECORD;  	[BUGGY]  [FE]    AssertionFailedError    Token  type  expected:<EORECORD>  but  was:<EOF>  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber    [CONTEXT]    private  Token  encapsulatedTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {    int  startLineNumber  =  getLineNumber  (  )  ;      while  (  true  )  {  c  =  in  .  read  (  )  ;    if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  if  (  isEncapsulator  (  c  )  )  {  if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    [ATTENTION]  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (     "  (  line     "  +  getLineNumber  (  )  +     "  )  invalid  char  between  encapsulated  token  and  delimiter   "  )  ;  }  }  }  }  else  if  (  isEndOfFile  (  c  )  )  {    throw  new  IOException  (     "  (  startline     "  +  startLineNumber  +     "  )  EOF  reached  before  encapsulated  token  finished   "  )  ;  }  else  {    tkn  .  content  .  append  (  (  char  )  c  )  ;  }  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^209^^^^^181^225^
[ADD]    tkn    .    type    =    TOKEN;    return    tkn;  	[BUGGY]  return  tkn  ;  [FE]    (line  1)  invalid  char  between  encapsulated  token  and  delimiter  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber    [CONTEXT]    private  Token  encapsulatedTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {    int  startLineNumber  =  getLineNumber  (  )  ;      while  (  true  )  {  c  =  in  .  read  (  )  ;    if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  if  (  isEncapsulator  (  c  )  )  {  if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  [ATTENTION]  return  tkn  ;    }  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (     "  (  line     "  +  getLineNumber  (  )  +     "  )  invalid  char  between  encapsulated  token  and  delimiter   "  )  ;  }  }  }  }  else  if  (  isEndOfFile  (  c  )  )  {    throw  new  IOException  (     "  (  startline     "  +  startLineNumber  +     "  )  EOF  reached  before  encapsulated  token  finished   "  )  ;  }  else  {    tkn  .  content  .  append  (  (  char  )  c  )  ;  }  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^201^202^^^^181^225^
[REMOVE]      	[BUGGY]  int  c  =  in  .  read  (  )  ;  [CE]  variable  c  is  already  defined  in  method  encapsulatedTokenLexer(Token  ,  int)    [METHOD]    encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber    [CONTEXT]    private  Token  encapsulatedTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {    int  startLineNumber  =  getLineNumber  (  )  ;      while  (  true  )  {  c  =  in  .  read  (  )  ;    if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  if  (  isEncapsulator  (  c  )  )  {  if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    [ATTENTION]  throw  new  IOException  (     "  (  line     "  +  getLineNumber  (  )  +     "  )  invalid  char  between  encapsulated  token  and  delimiter   "  )  ;    int  c  =  in  .  read  (  )    ;  }  }  }  }  else  if  (  isEndOfFile  (  c  )  )  {    throw  new  IOException  (     "  (  startline     "  +  startLineNumber  +     "  )  EOF  reached  before  encapsulated  token  finished   "  )  ;  }  else  {    tkn  .  content  .  append  (  (  char  )  c  )  ;  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^213^^^^^181^225^
[REPLACE]    }    else    if    (    isEncapsulator    (    c    )    )    {  	[BUGGY]    if  (  isEncapsulator  (  c  )  )  {[FE]    AssertionFailedError    arrays  first  differed  at  element  [0]      [METHOD]    encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber    [CONTEXT]    private  Token  encapsulatedTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {    int  startLineNumber  =  getLineNumber  (  )  ;      while  (  true  )  {  c  =  in  .  read  (  )  ;    if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  [ATTENTION]  }if  (  isEncapsulator  (  c  )  )  {  if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (     "  (  line     "  +  getLineNumber  (  )  +     "  )  invalid  char  between  encapsulated  token  and  delimiter   "  )  ;  }  }  }  }  else  if  (  isEndOfFile  (  c  )  )  {    throw  new  IOException  (     "  (  startline     "  +  startLineNumber  +     "  )  EOF  reached  before  encapsulated  token  finished   "  )  ;  }  else  {    tkn  .  content  .  append  (  (  char  )  c  )  ;  }  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^191^^^^^181^225^
[REPLACE]    }    else    if    (    isEndOfFile    (    c    )    )    {  	[BUGGY]    else  {[CE]  'else'  without  'if'    [METHOD]    encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber    [CONTEXT]    private  Token  encapsulatedTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {    int  startLineNumber  =  getLineNumber  (  )  ;      while  (  true  )  {  c  =  in  .  read  (  )  ;    if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  if  (  isEncapsulator  (  c  )  )  {  if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (     "  (  line     "  +  getLineNumber  (  )  +     "  )  invalid  char  between  encapsulated  token  and  delimiter   "  )  ;  }  }  }  [ATTENTION]  }else  {    throw  new  IOException  (     "  (  startline     "  +  startLineNumber  +     "  )  EOF  reached  before  encapsulated  token  finished   "  )  ;  }  else  {    tkn  .  content  .  append  (  (  char  )  c  )  ;  }  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^217^^^^^181^225^
[REPLACE]    tkn    .    content    .    append    (    (    char    )    c    )    ;  	[BUGGY]  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  [FE]    (line  1)  invalid  char  between  encapsulated  token  and  delimiter  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber    [CONTEXT]    }  else  if  (  isEndOfFile  (  c  )  )  {    throw  new  IOException  (     "  (  startline     "  +  startLineNumber  +     "  )  EOF  reached  before  encapsulated  token  finished   "  )  ;  }  else  {    [ATTENTION]  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )    ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^222^^^^^217^223^
[REPLACE]    throw    new    IOException    (   "       ")    ;  	[BUGGY]  return  ;  [CE]  missing  return  value    [METHOD]    encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber    [CONTEXT]    private  Token  encapsulatedTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {    int  startLineNumber  =  getLineNumber  (  )  ;      while  (  true  )  {  c  =  in  .  read  (  )  ;    if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  if  (  isEncapsulator  (  c  )  )  {  if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (     "  (  line     "  +  getLineNumber  (  )  +     "  )  invalid  char  between  encapsulated  token  and  delimiter   "  )  ;  }  }  }  }  else  if  (  isEndOfFile  (  c  )  )  {    [ATTENTION]  return  ;  }  else  {    tkn  .  content  .  append  (  (  char  )  c  )  ;  }  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^219^^^^^181^225^
[REPLACE]    }    else    if    (    isEndOfLine    (    c    )    )    {  	[BUGGY]  else  if  (  isDelimiter  (  c  )  )  {[FE]    (line  4)  invalid  char  between  encapsulated  token  and  delimiter  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber    [CONTEXT]    private  Token  encapsulatedTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {    int  startLineNumber  =  getLineNumber  (  )  ;      while  (  true  )  {  c  =  in  .  read  (  )  ;    if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  if  (  isEncapsulator  (  c  )  )  {  if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  [ATTENTION]  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (     "  (  line     "  +  getLineNumber  (  )  +     "  )  invalid  char  between  encapsulated  token  and  delimiter   "  )  ;  }  }  }  }  else  if  (  isEndOfFile  (  c  )  )  {    throw  new  IOException  (     "  (  startline     "  +  startLineNumber  +     "  )  EOF  reached  before  encapsulated  token  finished   "  )  ;  }  else  {    tkn  .  content  .  append  (  (  char  )  c  )  ;  }  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^207^^^^^181^225^
[ADD]    tkn    .    type    =    EORECORD;    return    tkn;  	[BUGGY]  return  tkn  ;  [FE]    AssertionFailedError    Token  type  expected:<EORECORD>  but  was:<EOF>  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber    [CONTEXT]    private  Token  encapsulatedTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {    int  startLineNumber  =  getLineNumber  (  )  ;      while  (  true  )  {  c  =  in  .  read  (  )  ;    if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  if  (  isEncapsulator  (  c  )  )  {  if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    [ATTENTION]  return  tkn  ;    }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (     "  (  line     "  +  getLineNumber  (  )  +     "  )  invalid  char  between  encapsulated  token  and  delimiter   "  )  ;  }  }  }  }  else  if  (  isEndOfFile  (  c  )  )  {    throw  new  IOException  (     "  (  startline     "  +  startLineNumber  +     "  )  EOF  reached  before  encapsulated  token  finished   "  )  ;  }  else  {    tkn  .  content  .  append  (  (  char  )  c  )  ;  }  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^209^210^^^^181^225^
[ADD]    tkn    .    type    =    TOKEN;  	[BUGGY]  [FE]    (line  1)  invalid  char  between  encapsulated  token  and  delimiter  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber    [CONTEXT]    private  Token  encapsulatedTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {    int  startLineNumber  =  getLineNumber  (  )  ;      while  (  true  )  {  c  =  in  .  read  (  )  ;    if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  if  (  isEncapsulator  (  c  )  )  {  if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  [ATTENTION]  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (     "  (  line     "  +  getLineNumber  (  )  +     "  )  invalid  char  between  encapsulated  token  and  delimiter   "  )  ;  }  }  }  }  else  if  (  isEndOfFile  (  c  )  )  {    throw  new  IOException  (     "  (  startline     "  +  startLineNumber  +     "  )  EOF  reached  before  encapsulated  token  finished   "  )  ;  }  else  {    tkn  .  content  .  append  (  (  char  )  c  )  ;  }  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^201^^^^^181^225^
[REPLACE]    }    else    if    (    isEndOfFile    (    c    )    )    {  	[BUGGY]    else  {[CE]  'else'  without  'if'    [METHOD]    encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber    [CONTEXT]    private  Token  encapsulatedTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {    int  startLineNumber  =  getLineNumber  (  )  ;      while  (  true  )  {  c  =  in  .  read  (  )  ;    if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  if  (  isEncapsulator  (  c  )  )  {  if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  [ATTENTION]  }else  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (     "  (  line     "  +  getLineNumber  (  )  +     "  )  invalid  char  between  encapsulated  token  and  delimiter   "  )  ;  }  }  }  }  else  if  (  isEndOfFile  (  c  )  )  {    throw  new  IOException  (     "  (  startline     "  +  startLineNumber  +     "  )  EOF  reached  before  encapsulated  token  finished   "  )  ;  }  else  {    tkn  .  content  .  append  (  (  char  )  c  )  ;  }  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^203^^^^^181^225^
[ADD]    tkn    .    isReady    =    true;  	[BUGGY]  [FE]    array  lengths  differed  ,  expected.length  =  2  actual.length  =  1  assertEquals(res.length  ,  records.size())      [METHOD]    encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber    [CONTEXT]    private  Token  encapsulatedTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {    int  startLineNumber  =  getLineNumber  (  )  ;      while  (  true  )  {  c  =  in  .  read  (  )  ;    if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  if  (  isEncapsulator  (  c  )  )  {  if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  [ATTENTION]  return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (     "  (  line     "  +  getLineNumber  (  )  +     "  )  invalid  char  between  encapsulated  token  and  delimiter   "  )  ;  }  }  }  }  else  if  (  isEndOfFile  (  c  )  )  {    throw  new  IOException  (     "  (  startline     "  +  startLineNumber  +     "  )  EOF  reached  before  encapsulated  token  finished   "  )  ;  }  else  {    tkn  .  content  .  append  (  (  char  )  c  )  ;  }  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^205^^^^^181^225^
[ADD]    c    =    in    .    read    (    )    ;  	[BUGGY]  [FE]    (line  0)  invalid  char  between  encapsulated  token  and  delimiter  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber    [CONTEXT]    private  Token  encapsulatedTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {    int  startLineNumber  =  getLineNumber  (  )  ;      while  (  true  )  {  c  =  in  .  read  (  )  ;    if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  if  (  isEncapsulator  (  c  )  )  {  if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  [ATTENTION]  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (     "  (  line     "  +  getLineNumber  (  )  +     "  )  invalid  char  between  encapsulated  token  and  delimiter   "  )  ;  }  }  }  }  else  if  (  isEndOfFile  (  c  )  )  {    throw  new  IOException  (     "  (  startline     "  +  startLineNumber  +     "  )  EOF  reached  before  encapsulated  token  finished   "  )  ;  }  else  {    tkn  .  content  .  append  (  (  char  )  c  )  ;  }  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^199^^^^^181^225^
[ADD]    tkn    .    type    =    EOF;    tkn    .    isReady    =    true;  	[BUGGY]  [FE]    (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber    [CONTEXT]    private  Token  encapsulatedTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {    int  startLineNumber  =  getLineNumber  (  )  ;      while  (  true  )  {  c  =  in  .  read  (  )  ;    if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  if  (  isEncapsulator  (  c  )  )  {  if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  [ATTENTION]    return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (     "  (  line     "  +  getLineNumber  (  )  +     "  )  invalid  char  between  encapsulated  token  and  delimiter   "  )  ;  }  }  }  }  else  if  (  isEndOfFile  (  c  )  )  {    throw  new  IOException  (     "  (  startline     "  +  startLineNumber  +     "  )  EOF  reached  before  encapsulated  token  finished   "  )  ;  }  else  {    tkn  .  content  .  append  (  (  char  )  c  )  ;  }  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^204^205^^^^181^225^
[ADD]    tkn    .    isReady    =    true;    return    tkn;  	[BUGGY]  [FE]  [METHOD]    encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber    [CONTEXT]    private  Token  encapsulatedTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {    int  startLineNumber  =  getLineNumber  (  )  ;      while  (  true  )  {  c  =  in  .  read  (  )  ;    if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  if  (  isEncapsulator  (  c  )  )  {  if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  [ATTENTION]    }  else  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (     "  (  line     "  +  getLineNumber  (  )  +     "  )  invalid  char  between  encapsulated  token  and  delimiter   "  )  ;  }  }  }  }  else  if  (  isEndOfFile  (  c  )  )  {    throw  new  IOException  (     "  (  startline     "  +  startLineNumber  +     "  )  EOF  reached  before  encapsulated  token  finished   "  )  ;  }  else  {    tkn  .  content  .  append  (  (  char  )  c  )  ;  }  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^205^206^^^^181^225^
[REPLACE]    if    (    isEncapsulator    (    in    .    lookAhead    (    )    )    )    {  	[BUGGY]  if  (  isEscape  (  c  )  )  {[FE]    (line  0)  invalid  char  between  encapsulated  token  and  delimiter  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber    [CONTEXT]    private  Token  encapsulatedTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {    int  startLineNumber  =  getLineNumber  (  )  ;      while  (  true  )  {  c  =  in  .  read  (  )  ;    if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  if  (  isEncapsulator  (  c  )  )  {  [ATTENTION]  if  (  isEscape  (  c  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (     "  (  line     "  +  getLineNumber  (  )  +     "  )  invalid  char  between  encapsulated  token  and  delimiter   "  )  ;  }  }  }  }  else  if  (  isEndOfFile  (  c  )  )  {    throw  new  IOException  (     "  (  startline     "  +  startLineNumber  +     "  )  EOF  reached  before  encapsulated  token  finished   "  )  ;  }  else  {    tkn  .  content  .  append  (  (  char  )  c  )  ;  }  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^192^^^^^181^225^
[ADD]    if    (    isEncapsulator    (    in    .    lookAhead    (    )    )    )    {    c    =    in    .    read    (    )    ;    tkn    .    content    .    append    (    (    char    )    c    )    ;  	[BUGGY]  [CE]  'else'  without  'if'    [METHOD]    encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber    [CONTEXT]    private  Token  encapsulatedTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {    int  startLineNumber  =  getLineNumber  (  )  ;      while  (  true  )  {  c  =  in  .  read  (  )  ;    if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  if  (  isEncapsulator  (  c  )  )  {  [ATTENTION]      }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (     "  (  line     "  +  getLineNumber  (  )  +     "  )  invalid  char  between  encapsulated  token  and  delimiter   "  )  ;  }  }  }  }  else  if  (  isEndOfFile  (  c  )  )  {    throw  new  IOException  (     "  (  startline     "  +  startLineNumber  +     "  )  EOF  reached  before  encapsulated  token  finished   "  )  ;  }  else  {    tkn  .  content  .  append  (  (  char  )  c  )  ;  }  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^192^193^194^195^^181^225^
[REPLACE]    while    (    true    )    {  	[BUGGY]  while  (  false  )  {[CE]  unreachable  statement    [METHOD]    encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber    [CONTEXT]    if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    [ATTENTION]  while  (  false  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (     "  (  line     "  +  getLineNumber  (  )  +     "  )  invalid  char  between  encapsulated  token  and  delimiter   "  )  ;  }  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^198^^^^^192^216^
[REPLACE]    if    (    isDelimiter    (    c    )    )    {  	[BUGGY]  if  (  isEscape  (  c  )  )  {[FE]    (line  0)  invalid  char  between  encapsulated  token  and  delimiter  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber    [CONTEXT]    if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  [ATTENTION]  if  (  isEscape  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (     "  (  line     "  +  getLineNumber  (  )  +     "  )  invalid  char  between  encapsulated  token  and  delimiter   "  )  ;  }  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^200^^^^^192^216^
[ADD]    if    (    isDelimiter    (    c    )    )    {    tkn    .    type    =    TOKEN;    return    tkn;    }    else    if    (    isEndOfFile    (    c    )    )    {    tkn    .    type    =    EOF;  	[BUGGY]  tkn  .  type  =  TOKEN  ;  return  tkn  ;  tkn  .  type  =  EOF  ;  [CE]  'else'  without  'if'    [METHOD]    encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber    [CONTEXT]    if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  [ATTENTION]  tkn  .  type  =  TOKEN  ;  return  tkn  ;  tkn  .  type  =  EOF  ;      tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (     "  (  line     "  +  getLineNumber  (  )  +     "  )  invalid  char  between  encapsulated  token  and  delimiter   "  )  ;  }  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^200^201^202^203^204^192^216^
[REPLACE]    }    else    if    (    isEndOfFile    (    c    )    )    {  	[BUGGY]    if  (  isEndOfFile  (  c  )  )  {[NO-ERROR]    [METHOD]    encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber    [CONTEXT]    if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  [ATTENTION]  }if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (     "  (  line     "  +  getLineNumber  (  )  +     "  )  invalid  char  between  encapsulated  token  and  delimiter   "  )  ;  }  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^203^^^^^192^216^
[REPLACE]    }    else    if    (    isEndOfLine    (    c    )    )    {  	[BUGGY]    else  {[CE]  'else'  without  'if'    [METHOD]    encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber    [CONTEXT]    if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  [ATTENTION]  }else  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (     "  (  line     "  +  getLineNumber  (  )  +     "  )  invalid  char  between  encapsulated  token  and  delimiter   "  )  ;  }  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^207^^^^^192^216^
[REPLACE]    }    else    if    (    !isWhitespace    (    c    )    )    {  	[BUGGY]  else  if  (  isWhitespace  (  c  )  )  {[FE]    (line  2)  invalid  char  between  encapsulated  token  and  delimiter  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber    [CONTEXT]    if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  [ATTENTION]  }  else  if  (  isWhitespace  (  c  )  )  {    throw  new  IOException  (     "  (  line     "  +  getLineNumber  (  )  +     "  )  invalid  char  between  encapsulated  token  and  delimiter   "  )  ;  }  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^211^^^^^192^216^
[REPLACE]    throw    new    IOException    (   "       ")    ;  	[BUGGY]  return  ;  [CE]  missing  return  value    [METHOD]    encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber    [CONTEXT]    if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    [ATTENTION]  return  ;  }  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^213^^^^^192^216^
[ADD]    throw    new    IOException    (   "       ")    ;  	[BUGGY]  [NO-ERROR]    [METHOD]    encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber    [CONTEXT]    if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    [ATTENTION]  }  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^213^^^^^192^216^
[REPLACE]    throw    new    IOException    (   "       ")    ;  	[BUGGY]  eol  =  isEndOfLine  (  c  )  ;  [CE]  cannot  find  symbol  eol    [METHOD]    encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber    [CONTEXT]    if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    [ATTENTION]  eol  =  isEndOfLine  (  c  )    ;  }  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^213^^^^^192^216^
[REPLACE]    tkn    .    type    =    EORECORD;  	[BUGGY]  tkn  .  type    =    tkn  .  type  ;  [FE]    AssertionFailedError    Token  type  expected:<EORECORD>  but  was:<EOF>  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber    [CONTEXT]    if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    [ATTENTION]  tkn  .  type  =  tkn  .  type  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (     "  (  line     "  +  getLineNumber  (  )  +     "  )  invalid  char  between  encapsulated  token  and  delimiter   "  )  ;  }  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^209^^^^^192^216^
[REPLACE]    }    else    if    (    !isWhitespace    (    c    )    )    {  	[BUGGY]    else  {[FE]    (line  2)  invalid  char  between  encapsulated  token  and  delimiter  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber    [CONTEXT]    if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  [ATTENTION]  }else  {    throw  new  IOException  (     "  (  line     "  +  getLineNumber  (  )  +     "  )  invalid  char  between  encapsulated  token  and  delimiter   "  )  ;  }  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^211^^^^^192^216^
[REPLACE]    tkn    .    type    =    EORECORD;  	[BUGGY]  tkn  .  type  ;  [CE]  not  a  statement    [METHOD]    encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber    [CONTEXT]    if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    [ATTENTION]  tkn  .  type  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (     "  (  line     "  +  getLineNumber  (  )  +     "  )  invalid  char  between  encapsulated  token  and  delimiter   "  )  ;  }  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^209^^^^^192^216^
[REPLACE]    tkn    .    type    =    EOF;  	[BUGGY]  tkn  .  type  =  TOKEN  ;    ;  [FE]    AssertionFailedError    Token  type  expected:<EOF>  but  was:<TOKEN>  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber    [CONTEXT]    if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  [ATTENTION]  tkn  .  type  =  TOKEN  ;    ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (     "  (  line     "  +  getLineNumber  (  )  +     "  )  invalid  char  between  encapsulated  token  and  delimiter   "  )  ;  }  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^204^^^^^192^216^
[REPLACE]    tkn    .    isReady    =    true;  	[BUGGY]  tkn  .  isReady  =  false  ;  [FE]    array  lengths  differed  ,  expected.length  =  2  actual.length  =  1  assertEquals(res.length  ,  records.size())      [METHOD]    encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber    [CONTEXT]    if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  [ATTENTION]  tkn  .  isReady  =  false  ;  return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (     "  (  line     "  +  getLineNumber  (  )  +     "  )  invalid  char  between  encapsulated  token  and  delimiter   "  )  ;  }  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^205^^^^^192^216^
[REPLACE]    }    else    if    (    isEndOfLine    (    c    )    )    {  	[BUGGY]  else  if  (  isDelimiter  (  c  )  )  {[FE]    (line  4)  invalid  char  between  encapsulated  token  and  delimiter  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber    [CONTEXT]    if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  [ATTENTION]  }  else  if  (  isDelimiter  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (     "  (  line     "  +  getLineNumber  (  )  +     "  )  invalid  char  between  encapsulated  token  and  delimiter   "  )  ;  }  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^207^^^^^192^216^
[ADD]    else    if    (    isEndOfLine    (    c    )    )    {    tkn    .    type    =    EORECORD;    return    tkn;  	[BUGGY]    tkn  .  type  =  EORECORD  ;  return  tkn  ;  [CE]  'else'  without  'if'    [METHOD]    encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber    [CONTEXT]    if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  [ATTENTION]  }  tkn  .  type  =  EORECORD  ;  return  tkn  ;      }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (     "  (  line     "  +  getLineNumber  (  )  +     "  )  invalid  char  between  encapsulated  token  and  delimiter   "  )  ;  }  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^207^208^209^210^^192^216^
[ADD]    tkn    .    type    =    EORECORD;  	[BUGGY]  [FE]    AssertionFailedError    Token  type  expected:<EORECORD>  but  was:<EOF>  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber    [CONTEXT]    if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    [ATTENTION]  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (     "  (  line     "  +  getLineNumber  (  )  +     "  )  invalid  char  between  encapsulated  token  and  delimiter   "  )  ;  }  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^209^^^^^192^216^
[REPLACE]    tkn    .    type    =    TOKEN;  	[BUGGY]  tkn  .  type  =  EOF  ;    ;  [FE]    AssertionFailedError    Token  type  expected:<TOKEN>  but  was:<EOF>  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber    [CONTEXT]    if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  [ATTENTION]  tkn  .  type  =  EOF  ;    ;  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (     "  (  line     "  +  getLineNumber  (  )  +     "  )  invalid  char  between  encapsulated  token  and  delimiter   "  )  ;  }  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^201^^^^^192^216^
[REPLACE]    }    else    if    (    isEndOfFile    (    c    )    )    {  	[BUGGY]    else  {[CE]  'else'  without  'if'    [METHOD]    encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber    [CONTEXT]    if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  [ATTENTION]  }else  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (     "  (  line     "  +  getLineNumber  (  )  +     "  )  invalid  char  between  encapsulated  token  and  delimiter   "  )  ;  }  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^203^^^^^192^216^
[ADD]    tkn    .    type    =    EORECORD;    return    tkn;  	[BUGGY]  [FE]    (line  4)  invalid  char  between  encapsulated  token  and  delimiter  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber    [CONTEXT]    if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    [ATTENTION]    }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (     "  (  line     "  +  getLineNumber  (  )  +     "  )  invalid  char  between  encapsulated  token  and  delimiter   "  )  ;  }  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^209^210^^^^192^216^
[REPLACE]    }    else    if    (    !isWhitespace    (    c    )    )    {  	[BUGGY]    if  (  isWhitespace  (  c  )  )  {[FE]    (line  2)  invalid  char  between  encapsulated  token  and  delimiter  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber    [CONTEXT]    if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  [ATTENTION]  }if  (  isWhitespace  (  c  )  )  {    throw  new  IOException  (     "  (  line     "  +  getLineNumber  (  )  +     "  )  invalid  char  between  encapsulated  token  and  delimiter   "  )  ;  }  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^211^^^^^192^216^
[ADD]    else    if    (    !isWhitespace    (    c    )    )    {    throw    new    IOException    (   "       ")    ;    }  	[BUGGY]  [NO-ERROR]    [METHOD]    encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber    [CONTEXT]    if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  [ATTENTION]  }    }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^211^212^213^214^^192^216^
[REPLACE]    tkn    .    type    =    EORECORD;  	[BUGGY]  tkn  .  type    =  null  ;  [FE]    AssertionFailedError    Token  type  expected:<EORECORD>  but  was:<null>  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber    [CONTEXT]    if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    [ATTENTION]  tkn  .  type  =  null  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (     "  (  line     "  +  getLineNumber  (  )  +     "  )  invalid  char  between  encapsulated  token  and  delimiter   "  )  ;  }  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^209^^^^^192^216^
[REPLACE]    c    =    in    .    read    (    )    ;  	[BUGGY]  c  =  in  .  readAgain  (  )  ;    ;  [FE]    (line  0)  invalid  char  between  encapsulated  token  and  delimiter  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber    [CONTEXT]    if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  [ATTENTION]  c  =  in  .  readAgain  (  )    ;    ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (     "  (  line     "  +  getLineNumber  (  )  +     "  )  invalid  char  between  encapsulated  token  and  delimiter   "  )  ;  }  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^199^^^^^192^216^
[ADD]    tkn    .    isReady    =    true;    return    tkn;  	[BUGGY]  [FE]  [METHOD]    encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber    [CONTEXT]    if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  [ATTENTION]    }  else  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (     "  (  line     "  +  getLineNumber  (  )  +     "  )  invalid  char  between  encapsulated  token  and  delimiter   "  )  ;  }  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^205^206^^^^192^216^
[REPLACE]    }    else    if    (    isEndOfFile    (    c    )    )    {  	[BUGGY]  else  if  (  isDelimiter  (  c  )  )  {[FE]    (line  6)  invalid  char  between  encapsulated  token  and  delimiter  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber    [CONTEXT]    if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  [ATTENTION]  }  else  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (     "  (  line     "  +  getLineNumber  (  )  +     "  )  invalid  char  between  encapsulated  token  and  delimiter   "  )  ;  }  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^203^^^^^192^216^
[ADD]    tkn    .    type    =    EOF;  	[BUGGY]  [FE]    (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber    [CONTEXT]    if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  [ATTENTION]  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (     "  (  line     "  +  getLineNumber  (  )  +     "  )  invalid  char  between  encapsulated  token  and  delimiter   "  )  ;  }  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^204^^^^^192^216^
[REPLACE]    }    else    if    (    isEndOfLine    (    c    )    )    {  	[BUGGY]    if  (  isEndOfLine  (  c  )  )  {[NO-ERROR]    [METHOD]    encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber    [CONTEXT]    if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  [ATTENTION]  }if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (     "  (  line     "  +  getLineNumber  (  )  +     "  )  invalid  char  between  encapsulated  token  and  delimiter   "  )  ;  }  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^207^^^^^192^216^
[ADD]    tkn    .    type    =    TOKEN;  	[BUGGY]  [FE]    (line  1)  invalid  char  between  encapsulated  token  and  delimiter  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber    [CONTEXT]    if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  [ATTENTION]  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (     "  (  line     "  +  getLineNumber  (  )  +     "  )  invalid  char  between  encapsulated  token  and  delimiter   "  )  ;  }  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^201^^^^^192^216^
[REPLACE]    c    =    in    .    read    (    )    ;  	[BUGGY]  c  =  in  .  readAgain  (  )  ;    ;  [FE]    (line  0)  invalid  char  between  encapsulated  token  and  delimiter  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber    [CONTEXT]    private  Token  encapsulatedTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {    int  startLineNumber  =  getLineNumber  (  )  ;      while  (  true  )  {  c  =  in  .  read  (  )  ;    if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  if  (  isEncapsulator  (  c  )  )  {  if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    [ATTENTION]  c  =  in  .  readAgain  (  )    ;    ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (     "  (  line     "  +  getLineNumber  (  )  +     "  )  invalid  char  between  encapsulated  token  and  delimiter   "  )  ;  }  }  }  }  else  if  (  isEndOfFile  (  c  )  )  {    throw  new  IOException  (     "  (  startline     "  +  startLineNumber  +     "  )  EOF  reached  before  encapsulated  token  finished   "  )  ;  }  else  {    tkn  .  content  .  append  (  (  char  )  c  )  ;  }  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^194^^^^^181^225^
[ADD]    tkn    .    type    =    EOF;  	[BUGGY]  [FE]    (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber    [CONTEXT]    private  Token  encapsulatedTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {    int  startLineNumber  =  getLineNumber  (  )  ;      while  (  true  )  {  c  =  in  .  read  (  )  ;    if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  if  (  isEncapsulator  (  c  )  )  {  if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  [ATTENTION]  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (     "  (  line     "  +  getLineNumber  (  )  +     "  )  invalid  char  between  encapsulated  token  and  delimiter   "  )  ;  }  }  }  }  else  if  (  isEndOfFile  (  c  )  )  {    throw  new  IOException  (     "  (  startline     "  +  startLineNumber  +     "  )  EOF  reached  before  encapsulated  token  finished   "  )  ;  }  else  {    tkn  .  content  .  append  (  (  char  )  c  )  ;  }  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^204^^^^^181^225^
[REMOVE]      	[BUGGY]  if  (  eol  )  {      tkn  .  type  =  EORECORD  ;  }else      if  (  isEncapsulator  (  c  )  )  {          encapsulatedTokenLexer  (  tkn  ,  c  )  ;      }else          if  (  isEndOfFile  (  c  )  )  {              tkn  .  type  =  EOF  ;              tkn  .  isReady  =  true  ;          }else  {              simpleTokenLexer  (  tkn  ,  c  )  ;          }[CE]  cannot  find  symbol  eol    [METHOD]    encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber    [CONTEXT]    private  Token  encapsulatedTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {    int  startLineNumber  =  getLineNumber  (  )  ;      while  (  true  )  {  c  =  in  .  read  (  )  ;    if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  if  (  isEncapsulator  (  c  )  )  {  if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  [ATTENTION]  }  else  if  (  isEndOfFile  (  c  )  )  {  if  (  eol  )  {  tkn  .  type  =  EORECORD  ;  }else  if  (  isEncapsulator  (  c  )  )  {  encapsulatedTokenLexer  (  tkn  ,  c  )    ;  }else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  }else  {  simpleTokenLexer  (  tkn  ,  c  )    ;  }tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (     "  (  line     "  +  getLineNumber  (  )  +     "  )  invalid  char  between  encapsulated  token  and  delimiter   "  )  ;  }  }  }  }  else  if  (  isEndOfFile  (  c  )  )  {    throw  new  IOException  (     "  (  startline     "  +  startLineNumber  +     "  )  EOF  reached  before  encapsulated  token  finished   "  )  ;  }  else  {    tkn  .  content  .  append  (  (  char  )  c  )  ;  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^203^^^^^181^225^
[REMOVE]      	[BUGGY]  if  (  isEndOfFile  (  c  )  )  {      tkn  .  type  =  EOF  ;      tkn  .  isReady  =  true  ;      return  tkn  ;  }else      if  (  isEndOfLine  (  c  )  )  {          tkn  .  type  =  EORECORD  ;          return  tkn  ;      }else          if  (  !  (  isWhitespace  (  c  )  )  )  {              throw  new  IOException  (  (  (     "  (  line     "  +  (  getLineNumber  (  )  )  )  +     "  )  invalid  char  between  encapsulated  token  and  delimiter   "  )  )  ;          }[NO-ERROR]    [METHOD]    encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber    [CONTEXT]    private  Token  encapsulatedTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {    int  startLineNumber  =  getLineNumber  (  )  ;      while  (  true  )  {  c  =  in  .  read  (  )  ;    if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  if  (  isEncapsulator  (  c  )  )  {  if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  [ATTENTION]  }  else  if  (  !isWhitespace  (  c  )  )  {  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  return  tkn  ;  }else  if  (  isEndOfLine  (  c  )  )  {  tkn  .  type  =  EORECORD  ;  return  tkn  ;  }else  if  (  !  (  isWhitespace  (  c  )  )  )  {  throw  new  IOException  (  (  (     "  (  line     "  +  (  getLineNumber  (  )  )  )  +     "  )  invalid  char  between  encapsulated  token  and  delimiter   "  )  )    ;  }//  error  invalid  char  between  token  and  next  delimiter  throw  new  IOException  (     "  (  line     "  +  getLineNumber  (  )  +     "  )  invalid  char  between  encapsulated  token  and  delimiter   "  )  ;  }  }  }  }  else  if  (  isEndOfFile  (  c  )  )  {    throw  new  IOException  (     "  (  startline     "  +  startLineNumber  +     "  )  EOF  reached  before  encapsulated  token  finished   "  )  ;  }  else  {    tkn  .  content  .  append  (  (  char  )  c  )  ;  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^211^^^^^181^225^
[ADD]    tkn    .    type    =    TOKEN;    return    tkn;  	[BUGGY]  [FE]    (line  0)  invalid  char  between  encapsulated  token  and  delimiter  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber    [CONTEXT]    if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  [ATTENTION]    }  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (     "  (  line     "  +  getLineNumber  (  )  +     "  )  invalid  char  between  encapsulated  token  and  delimiter   "  )  ;  }  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^201^202^^^^192^216^
[ADD]    else    if    (    isEndOfFile    (    c    )    )    {    tkn    .    type    =    EOF;    tkn    .    isReady    =    true;    return    tkn;  	[BUGGY]    tkn  .  isReady  =  true  ;  return  tkn  ;  [CE]  'else'  without  'if'    [METHOD]    encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber    [CONTEXT]    if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  [ATTENTION]  }  tkn  .  isReady  =  true  ;  return  tkn  ;      }  else  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (     "  (  line     "  +  getLineNumber  (  )  +     "  )  invalid  char  between  encapsulated  token  and  delimiter   "  )  ;  }  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^203^204^205^206^^192^216^
[ADD]    tkn    .    isReady    =    true;  	[BUGGY]  [FE]    array  lengths  differed  ,  expected.length  =  2  actual.length  =  1  assertEquals(res.length  ,  records.size())      [METHOD]    encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber    [CONTEXT]    if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  [ATTENTION]  return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (     "  (  line     "  +  getLineNumber  (  )  +     "  )  invalid  char  between  encapsulated  token  and  delimiter   "  )  ;  }  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^205^^^^^192^216^
[ADD]    if    (    isDelimiter    (    c    )    )    {    tkn    .    type    =    TOKEN;    return    tkn;    }    else    if    (    isEndOfFile    (    c    )    )    {    tkn    .    type    =    EOF;  	[BUGGY]  [CE]  'else'  without  'if'    [METHOD]    encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber    [CONTEXT]    if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  [ATTENTION]      tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (     "  (  line     "  +  getLineNumber  (  )  +     "  )  invalid  char  between  encapsulated  token  and  delimiter   "  )  ;  }  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^200^201^202^203^204^192^216^
[REMOVE]      	[BUGGY]  if  (  isDelimiter  (  c  )  )  {      tkn  .  type  =  TOKEN  ;      break  ;  }else      if  (  isEscape  (  c  )  )  {          append  (  (  (  char  )    (  readEscape  (  c  )  )  )  )  ;      }else  {          append  (  (  (  char  )    (  c  )  )  )  ;      }[CE]  cannot  find  symbol    [METHOD]    encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber    [CONTEXT]    if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  [ATTENTION]  }  else  if  (  isEndOfLine  (  c  )  )  {  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  break  ;  }else  if  (  isEscape  (  c  )  )  {  append  (  (  (  char  )    (  readEscape  (  c  )  )  )  )    ;  }else  {  append  (  (  (  char  )    (  c  )  )  )    ;  }//  ok  eo  token  reached  tkn  .  type  =  EORECORD  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (     "  (  line     "  +  getLineNumber  (  )  +     "  )  invalid  char  between  encapsulated  token  and  delimiter   "  )  ;  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^207^^^^^192^216^
[REMOVE]      	[BUGGY]  if  (  isEndOfFile  (  c  )  )  {      tkn  .  type  =  EOF  ;      tkn  .  isReady  =  true  ;      return  tkn  ;  }else      if  (  isEndOfLine  (  c  )  )  {          tkn  .  type  =  EORECORD  ;          return  tkn  ;      }else          if  (  !  (  isWhitespace  (  c  )  )  )  {              throw  new  IOException  (  (  (     "  (  line     "  +  (  getLineNumber  (  )  )  )  +     "  )  invalid  char  between  encapsulated  token  and  delimiter   "  )  )  ;          }[NO-ERROR]    [METHOD]    encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber    [CONTEXT]    if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  [ATTENTION]  }  else  if  (  !isWhitespace  (  c  )  )  {  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  return  tkn  ;  }else  if  (  isEndOfLine  (  c  )  )  {  tkn  .  type  =  EORECORD  ;  return  tkn  ;  }else  if  (  !  (  isWhitespace  (  c  )  )  )  {  throw  new  IOException  (  (  (     "  (  line     "  +  (  getLineNumber  (  )  )  )  +     "  )  invalid  char  between  encapsulated  token  and  delimiter   "  )  )    ;  }//  error  invalid  char  between  token  and  next  delimiter  throw  new  IOException  (     "  (  line     "  +  getLineNumber  (  )  +     "  )  invalid  char  between  encapsulated  token  and  delimiter   "  )  ;  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^211^^^^^192^216^
[ADD]    else    if    (    isEndOfFile    (    c    )    )    {    tkn    .    type    =    EOF;    tkn    .    isReady    =    true;    return    tkn;  	[BUGGY]    tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  return  tkn  ;  [CE]  'else'  without  'if'    [METHOD]    encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber    [CONTEXT]    if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  [ATTENTION]  }  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  return  tkn  ;      }  else  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (     "  (  line     "  +  getLineNumber  (  )  +     "  )  invalid  char  between  encapsulated  token  and  delimiter   "  )  ;  }  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^203^204^205^206^^192^216^
[REMOVE]      	[BUGGY]  int  c  =  in  .  read  (  )  ;  [CE]  variable  c  is  already  defined  in  method  encapsulatedTokenLexer(Token  ,  int)    [METHOD]    encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber    [CONTEXT]    if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    [ATTENTION]  throw  new  IOException  (     "  (  line     "  +  getLineNumber  (  )  +     "  )  invalid  char  between  encapsulated  token  and  delimiter   "  )  ;    int  c  =  in  .  read  (  )    ;  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^213^^^^^192^216^
[ADD]    tkn    .    type    =    EOF;    tkn    .    isReady    =    true;  	[BUGGY]  [FE]    (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber    [CONTEXT]    if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  [ATTENTION]    return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (     "  (  line     "  +  getLineNumber  (  )  +     "  )  invalid  char  between  encapsulated  token  and  delimiter   "  )  ;  }  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^204^205^^^^192^216^
[ADD]    tkn    .    type    =    EOF;    tkn    .    isReady    =    true;  	[BUGGY]  tkn  .  isReady  =  true  ;  [FE]    (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber    [CONTEXT]    if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  [ATTENTION]  tkn  .  isReady  =  true  ;    return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (     "  (  line     "  +  getLineNumber  (  )  +     "  )  invalid  char  between  encapsulated  token  and  delimiter   "  )  ;  }  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^204^205^^^^192^216^
[ADD]    c    =    in    .    read    (    )    ;    tkn    .    content    .    append    (    (    char    )    c    )    ;  	[BUGGY]  tkn  .  content  .  append  (  (  char  )  c  )  ;  [FE]    (line  0)  invalid  char  between  encapsulated  token  and  delimiter  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber    [CONTEXT]    private  Token  encapsulatedTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {    int  startLineNumber  =  getLineNumber  (  )  ;      while  (  true  )  {  c  =  in  .  read  (  )  ;    if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  if  (  isEncapsulator  (  c  )  )  {  if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    [ATTENTION]  tkn  .  content  .  append  (  (  char  )  c  )    ;    }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (     "  (  line     "  +  getLineNumber  (  )  +     "  )  invalid  char  between  encapsulated  token  and  delimiter   "  )  ;  }  }  }  }  else  if  (  isEndOfFile  (  c  )  )  {    throw  new  IOException  (     "  (  startline     "  +  startLineNumber  +     "  )  EOF  reached  before  encapsulated  token  finished   "  )  ;  }  else  {    tkn  .  content  .  append  (  (  char  )  c  )  ;  }  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^194^195^^^^181^225^
[REPLACE]    }    else    if    (    isEndOfFile    (    c    )    )    {  	[BUGGY]    if  (  isEndOfFile  (  c  )  )  {[FE]    Token  content  expected:<b  and  '[]  more  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber    [CONTEXT]    private  Token  encapsulatedTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {    int  startLineNumber  =  getLineNumber  (  )  ;      while  (  true  )  {  c  =  in  .  read  (  )  ;    if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  if  (  isEncapsulator  (  c  )  )  {  if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (     "  (  line     "  +  getLineNumber  (  )  +     "  )  invalid  char  between  encapsulated  token  and  delimiter   "  )  ;  }  }  }  [ATTENTION]  }if  (  isEndOfFile  (  c  )  )  {    throw  new  IOException  (     "  (  startline     "  +  startLineNumber  +     "  )  EOF  reached  before  encapsulated  token  finished   "  )  ;  }  else  {    tkn  .  content  .  append  (  (  char  )  c  )  ;  }  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^217^^^^^181^225^
[ADD]    tkn    .    content    .    append    (    (    char    )    c    )    ;  	[BUGGY]  [FE]    AssertionFailedError    Token  content  expected:<[foo]>  but  was:<[]>  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber    [CONTEXT]    }  else  if  (  isEndOfFile  (  c  )  )  {    throw  new  IOException  (     "  (  startline     "  +  startLineNumber  +     "  )  EOF  reached  before  encapsulated  token  finished   "  )  ;  }  else  {    [ATTENTION]  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^222^^^^^217^223^
[REPLACE]    tkn    .    content    .    append    (    (    char    )    readEscape    (    c    )    )    ;  	[BUGGY]  tkn  .  content  .  append  (  (  char  )  c  )  ;  [FE]    (line  3)  invalid  char  between  encapsulated  token  and  delimiter  assertEquals(res.length  ,  records.size())      [METHOD]    encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber    [CONTEXT]    private  Token  encapsulatedTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {    int  startLineNumber  =  getLineNumber  (  )  ;      while  (  true  )  {  c  =  in  .  read  (  )  ;    if  (  isEscape  (  c  )  )  {  [ATTENTION]  tkn  .  content  .  append  (  (  char  )  c  )    ;  }  else  if  (  isEncapsulator  (  c  )  )  {  if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (     "  (  line     "  +  getLineNumber  (  )  +     "  )  invalid  char  between  encapsulated  token  and  delimiter   "  )  ;  }  }  }  }  else  if  (  isEndOfFile  (  c  )  )  {    throw  new  IOException  (     "  (  startline     "  +  startLineNumber  +     "  )  EOF  reached  before  encapsulated  token  finished   "  )  ;  }  else  {    tkn  .  content  .  append  (  (  char  )  c  )  ;  }  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^190^^^^^181^225^
[REPLACE]    }    else    if    (    isEncapsulator    (    c    )    )    {  	[BUGGY]    else  {[CE]  'else'  without  'if'    [METHOD]    encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber    [CONTEXT]    private  Token  encapsulatedTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {    int  startLineNumber  =  getLineNumber  (  )  ;      while  (  true  )  {  c  =  in  .  read  (  )  ;    if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  [ATTENTION]  }else  {  if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (     "  (  line     "  +  getLineNumber  (  )  +     "  )  invalid  char  between  encapsulated  token  and  delimiter   "  )  ;  }  }  }  }  else  if  (  isEndOfFile  (  c  )  )  {    throw  new  IOException  (     "  (  startline     "  +  startLineNumber  +     "  )  EOF  reached  before  encapsulated  token  finished   "  )  ;  }  else  {    tkn  .  content  .  append  (  (  char  )  c  )  ;  }  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^191^^^^^181^225^
[REPLACE]    }    else    if    (    isEndOfFile    (    c    )    )    {  	[BUGGY]  else  if  (  isDelimiter  (  c  )  )  {[FE]    (startline  2)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber    [CONTEXT]    private  Token  encapsulatedTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {    int  startLineNumber  =  getLineNumber  (  )  ;      while  (  true  )  {  c  =  in  .  read  (  )  ;    if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  if  (  isEncapsulator  (  c  )  )  {  if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (     "  (  line     "  +  getLineNumber  (  )  +     "  )  invalid  char  between  encapsulated  token  and  delimiter   "  )  ;  }  }  }  [ATTENTION]  }  else  if  (  isDelimiter  (  c  )  )  {    throw  new  IOException  (     "  (  startline     "  +  startLineNumber  +     "  )  EOF  reached  before  encapsulated  token  finished   "  )  ;  }  else  {    tkn  .  content  .  append  (  (  char  )  c  )  ;  }  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^217^^^^^181^225^
[ADD]    else    if    (    isEndOfFile    (    c    )    )    {    throw    new    IOException    (   "       ")    ;    }    else    {  	[BUGGY]  [CE]  class  ,  interface  ,  or  enum  expected    [METHOD]    encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber    [CONTEXT]    private  Token  encapsulatedTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {    int  startLineNumber  =  getLineNumber  (  )  ;      while  (  true  )  {  c  =  in  .  read  (  )  ;    if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  if  (  isEncapsulator  (  c  )  )  {  if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (     "  (  line     "  +  getLineNumber  (  )  +     "  )  invalid  char  between  encapsulated  token  and  delimiter   "  )  ;  }  }  }  [ATTENTION]  }      tkn  .  content  .  append  (  (  char  )  c  )  ;  }  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^217^218^219^220^^181^225^
[REMOVE]      	[BUGGY]  if  (  eol  )  {      tkn  .  type  =  EORECORD  ;  }else      if  (  isEncapsulator  (  c  )  )  {          encapsulatedTokenLexer  (  tkn  ,  c  )  ;      }else          if  (  isEndOfFile  (  c  )  )  {              tkn  .  type  =  EOF  ;              tkn  .  isReady  =  true  ;          }else  {              simpleTokenLexer  (  tkn  ,  c  )  ;          }[CE]  cannot  find  symbol  eol    [METHOD]    encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber    [CONTEXT]    if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  [ATTENTION]  }  else  if  (  isEndOfFile  (  c  )  )  {  if  (  eol  )  {  tkn  .  type  =  EORECORD  ;  }else  if  (  isEncapsulator  (  c  )  )  {  encapsulatedTokenLexer  (  tkn  ,  c  )    ;  }else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  }else  {  simpleTokenLexer  (  tkn  ,  c  )    ;  }tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (     "  (  line     "  +  getLineNumber  (  )  +     "  )  invalid  char  between  encapsulated  token  and  delimiter   "  )  ;  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^203^^^^^192^216^
[ADD]    tkn    .    type    =    EORECORD;    return    tkn;  	[BUGGY]  return  tkn  ;  [FE]    AssertionFailedError    Token  type  expected:<EORECORD>  but  was:<EOF>  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber    [CONTEXT]    if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    [ATTENTION]  return  tkn  ;    }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (     "  (  line     "  +  getLineNumber  (  )  +     "  )  invalid  char  between  encapsulated  token  and  delimiter   "  )  ;  }  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^209^210^^^^192^216^
[ADD]    c    =    in    .    read    (    )    ;  	[BUGGY]  [FE]    (line  0)  invalid  char  between  encapsulated  token  and  delimiter  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber    [CONTEXT]    private  Token  encapsulatedTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {    int  startLineNumber  =  getLineNumber  (  )  ;      while  (  true  )  {  c  =  in  .  read  (  )  ;    if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  if  (  isEncapsulator  (  c  )  )  {  if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    [ATTENTION]  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (     "  (  line     "  +  getLineNumber  (  )  +     "  )  invalid  char  between  encapsulated  token  and  delimiter   "  )  ;  }  }  }  }  else  if  (  isEndOfFile  (  c  )  )  {    throw  new  IOException  (     "  (  startline     "  +  startLineNumber  +     "  )  EOF  reached  before  encapsulated  token  finished   "  )  ;  }  else  {    tkn  .  content  .  append  (  (  char  )  c  )  ;  }  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^194^^^^^181^225^
[REMOVE]      	[BUGGY]  if  (  isDelimiter  (  c  )  )  {      tkn  .  type  =  TOKEN  ;      break  ;  }else      if  (  isEscape  (  c  )  )  {          append  (  (  (  char  )    (  readEscape  (  c  )  )  )  )  ;      }else  {          append  (  (  (  char  )    (  c  )  )  )  ;      }[CE]  cannot  find  symbol    [METHOD]    encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber    [CONTEXT]    private  Token  encapsulatedTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {    int  startLineNumber  =  getLineNumber  (  )  ;      while  (  true  )  {  c  =  in  .  read  (  )  ;    if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  if  (  isEncapsulator  (  c  )  )  {  if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  [ATTENTION]  }  else  if  (  isEndOfLine  (  c  )  )  {  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  break  ;  }else  if  (  isEscape  (  c  )  )  {  append  (  (  (  char  )    (  readEscape  (  c  )  )  )  )    ;  }else  {  append  (  (  (  char  )    (  c  )  )  )    ;  }//  ok  eo  token  reached  tkn  .  type  =  EORECORD  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (     "  (  line     "  +  getLineNumber  (  )  +     "  )  invalid  char  between  encapsulated  token  and  delimiter   "  )  ;  }  }  }  }  else  if  (  isEndOfFile  (  c  )  )  {    throw  new  IOException  (     "  (  startline     "  +  startLineNumber  +     "  )  EOF  reached  before  encapsulated  token  finished   "  )  ;  }  else  {    tkn  .  content  .  append  (  (  char  )  c  )  ;  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^207^^^^^181^225^
[ADD]    c    =    in    .    read    (    )    ;    tkn    .    content    .    append    (    (    char    )    c    )    ;  	[BUGGY]  [FE]    (line  0)  invalid  char  between  encapsulated  token  and  delimiter  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber    [CONTEXT]    private  Token  encapsulatedTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {    int  startLineNumber  =  getLineNumber  (  )  ;      while  (  true  )  {  c  =  in  .  read  (  )  ;    if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  if  (  isEncapsulator  (  c  )  )  {  if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    [ATTENTION]    }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (     "  (  line     "  +  getLineNumber  (  )  +     "  )  invalid  char  between  encapsulated  token  and  delimiter   "  )  ;  }  }  }  }  else  if  (  isEndOfFile  (  c  )  )  {    throw  new  IOException  (     "  (  startline     "  +  startLineNumber  +     "  )  EOF  reached  before  encapsulated  token  finished   "  )  ;  }  else  {    tkn  .  content  .  append  (  (  char  )  c  )  ;  }  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^194^195^^^^181^225^
[ADD]    tkn    .    isReady    =    true;    return    tkn;  	[BUGGY]  return  tkn  ;  [FE]    array  lengths  differed  ,  expected.length  =  2  actual.length  =  1  assertEquals(res.length  ,  records.size())      [METHOD]    encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber    [CONTEXT]    if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  [ATTENTION]  return  tkn  ;    }  else  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (     "  (  line     "  +  getLineNumber  (  )  +     "  )  invalid  char  between  encapsulated  token  and  delimiter   "  )  ;  }  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^205^206^^^^192^216^
[REPLACE]    c    =    in    .    read    (    )    ;  	[BUGGY]  c  =  in  .  readAgain  (  )  ;    ;  [FE]    (line  0)  invalid  char  between  encapsulated  token  and  delimiter  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber    [CONTEXT]    private  Token  encapsulatedTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {    int  startLineNumber  =  getLineNumber  (  )  ;      while  (  true  )  {  [ATTENTION]  c  =  in  .  readAgain  (  )    ;    ;    if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  if  (  isEncapsulator  (  c  )  )  {  if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (     "  (  line     "  +  getLineNumber  (  )  +     "  )  invalid  char  between  encapsulated  token  and  delimiter   "  )  ;  }  }  }  }  else  if  (  isEndOfFile  (  c  )  )  {    throw  new  IOException  (     "  (  startline     "  +  startLineNumber  +     "  )  EOF  reached  before  encapsulated  token  finished   "  )  ;  }  else  {    tkn  .  content  .  append  (  (  char  )  c  )  ;  }  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^187^^^^^181^225^
[ADD]    c    =    in    .    read    (    )    ;  	[BUGGY]  [FE]    (line  0)  invalid  char  between  encapsulated  token  and  delimiter  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber    [CONTEXT]    private  Token  encapsulatedTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {    int  startLineNumber  =  getLineNumber  (  )  ;      while  (  true  )  {  [ATTENTION]    if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  if  (  isEncapsulator  (  c  )  )  {  if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (     "  (  line     "  +  getLineNumber  (  )  +     "  )  invalid  char  between  encapsulated  token  and  delimiter   "  )  ;  }  }  }  }  else  if  (  isEndOfFile  (  c  )  )  {    throw  new  IOException  (     "  (  startline     "  +  startLineNumber  +     "  )  EOF  reached  before  encapsulated  token  finished   "  )  ;  }  else  {    tkn  .  content  .  append  (  (  char  )  c  )  ;  }  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^187^^^^^181^225^
[ADD]    throw    new    IOException    (   "       ")    ;  	[BUGGY]  [NO-ERROR]    [METHOD]    encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber    [CONTEXT]    private  Token  encapsulatedTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {    int  startLineNumber  =  getLineNumber  (  )  ;      while  (  true  )  {  c  =  in  .  read  (  )  ;    if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  if  (  isEncapsulator  (  c  )  )  {  if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (     "  (  line     "  +  getLineNumber  (  )  +     "  )  invalid  char  between  encapsulated  token  and  delimiter   "  )  ;  }  }  }  }  else  if  (  isEndOfFile  (  c  )  )  {    [ATTENTION]  }  else  {    tkn  .  content  .  append  (  (  char  )  c  )  ;  }  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^219^^^^^181^225^
[REMOVE]      	[BUGGY]  if  (  eol  )  {      tkn  .  type  =  EORECORD  ;  }else      if  (  isEncapsulator  (  c  )  )  {          encapsulatedTokenLexer  (  tkn  ,  c  )  ;      }else          if  (  isEndOfFile  (  c  )  )  {              tkn  .  type  =  EOF  ;              tkn  .  isReady  =  true  ;          }else  {              simpleTokenLexer  (  tkn  ,  c  )  ;          }[CE]  cannot  find  symbol  eol    [METHOD]    encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber    [CONTEXT]    private  Token  encapsulatedTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {    int  startLineNumber  =  getLineNumber  (  )  ;      while  (  true  )  {  c  =  in  .  read  (  )  ;    if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  if  (  isEncapsulator  (  c  )  )  {  if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  [ATTENTION]  if  (  isDelimiter  (  c  )  )  {  if  (  eol  )  {  tkn  .  type  =  EORECORD  ;  }else  if  (  isEncapsulator  (  c  )  )  {  encapsulatedTokenLexer  (  tkn  ,  c  )    ;  }else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  }else  {  simpleTokenLexer  (  tkn  ,  c  )    ;  }tkn  .  type  =  TOKEN  ;  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (     "  (  line     "  +  getLineNumber  (  )  +     "  )  invalid  char  between  encapsulated  token  and  delimiter   "  )  ;  }  }  }  }  else  if  (  isEndOfFile  (  c  )  )  {    throw  new  IOException  (     "  (  startline     "  +  startLineNumber  +     "  )  EOF  reached  before  encapsulated  token  finished   "  )  ;  }  else  {    tkn  .  content  .  append  (  (  char  )  c  )  ;  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^200^^^^^181^225^
[REPLACE]    }    else    if    (    isEncapsulator    (    c    )    )    {  	[BUGGY]  else  if  (  isEndOfFile  (  c  )  )  {[FE]    AssertionFailedError    Token  type  expected:<TOKEN>  but  was:<EOF>  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber    [CONTEXT]    private  Token  encapsulatedTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {    int  startLineNumber  =  getLineNumber  (  )  ;      while  (  true  )  {  c  =  in  .  read  (  )  ;    if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  [ATTENTION]  }  else  if  (  isEndOfFile  (  c  )  )  {  if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (     "  (  line     "  +  getLineNumber  (  )  +     "  )  invalid  char  between  encapsulated  token  and  delimiter   "  )  ;  }  }  }  }  else  if  (  isEndOfFile  (  c  )  )  {    throw  new  IOException  (     "  (  startline     "  +  startLineNumber  +     "  )  EOF  reached  before  encapsulated  token  finished   "  )  ;  }  else  {    tkn  .  content  .  append  (  (  char  )  c  )  ;  }  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^191^^^^^181^225^
[ADD]    while    (    true    )    {    c    =    in    .    read    (    )    ;  	[BUGGY]  [CE]  'else'  without  'if'    [METHOD]    encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber    [CONTEXT]    private  Token  encapsulatedTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {    int  startLineNumber  =  getLineNumber  (  )  ;      while  (  true  )  {  c  =  in  .  read  (  )  ;    if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  if  (  isEncapsulator  (  c  )  )  {  if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    [ATTENTION]    if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (     "  (  line     "  +  getLineNumber  (  )  +     "  )  invalid  char  between  encapsulated  token  and  delimiter   "  )  ;  }  }  }  }  else  if  (  isEndOfFile  (  c  )  )  {    throw  new  IOException  (     "  (  startline     "  +  startLineNumber  +     "  )  EOF  reached  before  encapsulated  token  finished   "  )  ;  }  else  {    tkn  .  content  .  append  (  (  char  )  c  )  ;  }  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^198^199^^^^181^225^
[ADD]    while    (    true    )    {    c    =    in    .    read    (    )    ;  	[BUGGY]  [CE]  'else'  without  'if'    [METHOD]    encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber    [CONTEXT]    if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    [ATTENTION]    if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (     "  (  line     "  +  getLineNumber  (  )  +     "  )  invalid  char  between  encapsulated  token  and  delimiter   "  )  ;  }  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^198^199^^^^192^216^
[ADD]    c    =    in    .    read    (    )    ;  	[BUGGY]  [FE]    (line  0)  invalid  char  between  encapsulated  token  and  delimiter  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber    [CONTEXT]    if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  [ATTENTION]  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (     "  (  line     "  +  getLineNumber  (  )  +     "  )  invalid  char  between  encapsulated  token  and  delimiter   "  )  ;  }  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^199^^^^^192^216^
[ADD]    if    (    isDelimiter    (    c    )    )    {    tkn    .    type    =    TOKEN;    return    tkn;    }    else    if    (    isEndOfFile    (    c    )    )    {    tkn    .    type    =    EOF;  	[BUGGY]  [CE]  'else'  without  'if'    [METHOD]    encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber    [CONTEXT]    private  Token  encapsulatedTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {    int  startLineNumber  =  getLineNumber  (  )  ;      while  (  true  )  {  c  =  in  .  read  (  )  ;    if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  if  (  isEncapsulator  (  c  )  )  {  if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  [ATTENTION]      tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (     "  (  line     "  +  getLineNumber  (  )  +     "  )  invalid  char  between  encapsulated  token  and  delimiter   "  )  ;  }  }  }  }  else  if  (  isEndOfFile  (  c  )  )  {    throw  new  IOException  (     "  (  startline     "  +  startLineNumber  +     "  )  EOF  reached  before  encapsulated  token  finished   "  )  ;  }  else  {    tkn  .  content  .  append  (  (  char  )  c  )  ;  }  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^200^201^202^203^204^181^225^
[ADD]    tkn    .    type    =    TOKEN;    return    tkn;  	[BUGGY]  [FE]    (line  0)  invalid  char  between  encapsulated  token  and  delimiter  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber    [CONTEXT]    private  Token  encapsulatedTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {    int  startLineNumber  =  getLineNumber  (  )  ;      while  (  true  )  {  c  =  in  .  read  (  )  ;    if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  if  (  isEncapsulator  (  c  )  )  {  if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  [ATTENTION]    }  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (     "  (  line     "  +  getLineNumber  (  )  +     "  )  invalid  char  between  encapsulated  token  and  delimiter   "  )  ;  }  }  }  }  else  if  (  isEndOfFile  (  c  )  )  {    throw  new  IOException  (     "  (  startline     "  +  startLineNumber  +     "  )  EOF  reached  before  encapsulated  token  finished   "  )  ;  }  else  {    tkn  .  content  .  append  (  (  char  )  c  )  ;  }  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^201^202^^^^181^225^
[ADD]    tkn    .    type    =    TOKEN;    return    tkn;  	[BUGGY]  return  tkn  ;  [FE]    (line  1)  invalid  char  between  encapsulated  token  and  delimiter  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber    [CONTEXT]    if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  [ATTENTION]  return  tkn  ;    }  else  if  (  isEndOfFile  (  c  )  )  {  tkn  .  type  =  EOF  ;  tkn  .  isReady  =  true  ;  //  There  is  data  at  EOF  return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (     "  (  line     "  +  getLineNumber  (  )  +     "  )  invalid  char  between  encapsulated  token  and  delimiter   "  )  ;  }  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^201^202^^^^192^216^
[ADD]    tkn    .    type    =    EOF;    tkn    .    isReady    =    true;  	[BUGGY]  tkn  .  isReady  =  true  ;  [FE]    (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    encapsulatedTokenLexer  [TYPE]  Token  [PARAMETER]  Token  tkn  int  c  [CLASS]  CSVLexer    [TYPE]  boolean  false  true  [TYPE]  Token  tkn  [TYPE]  int  c  startLineNumber    [CONTEXT]    private  Token  encapsulatedTokenLexer  (  Token  tkn  ,  int  c  )  throws  IOException  {    int  startLineNumber  =  getLineNumber  (  )  ;      while  (  true  )  {  c  =  in  .  read  (  )  ;    if  (  isEscape  (  c  )  )  {  tkn  .  content  .  append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  if  (  isEncapsulator  (  c  )  )  {  if  (  isEncapsulator  (  in  .  lookAhead  (  )  )  )  {    c  =  in  .  read  (  )  ;  tkn  .  content  .  append  (  (  char  )  c  )  ;  }  else  {    while  (  true  )  {  c  =  in  .  read  (  )  ;  if  (  isDelimiter  (  c  )  )  {  tkn  .  type  =  TOKEN  ;  return  tkn  ;  }  else  if  (  isEndOfFile  (  c  )  )  {  [ATTENTION]  tkn  .  isReady  =  true  ;    return  tkn  ;  }  else  if  (  isEndOfLine  (  c  )  )  {    tkn  .  type  =  EORECORD  ;  return  tkn  ;  }  else  if  (  !isWhitespace  (  c  )  )  {    throw  new  IOException  (     "  (  line     "  +  getLineNumber  (  )  +     "  )  invalid  char  between  encapsulated  token  and  delimiter   "  )  ;  }  }  }  }  else  if  (  isEndOfFile  (  c  )  )  {    throw  new  IOException  (     "  (  startline     "  +  startLineNumber  +     "  )  EOF  reached  before  encapsulated  token  finished   "  )  ;  }  else  {    tkn  .  content  .  append  (  (  char  )  c  )  ;  }  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVLexer.java^204^205^^^^181^225^
[REPLACE]    private    final    List<String>    record    =    new    ArrayList<String>    (    )    ;  	[BUGGY]  private  List<String>  record  =  new  ArrayList<String>  (  )  ;  [FE]    (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [CONTEXT]        [CLASS]  CSVParser  1    	None^71^^^^^^^
[REPLACE]    private    final    Token    reusableToken    =    new    Token    (    )    ;  	[BUGGY]  private  final  Token  reusableToken  ;  [CE]  variable  reusableToken  might  not  have  been  initialized    [CONTEXT]        [CLASS]  CSVParser  1    	None^72^^^^^^^
[REPLACE]    this    (    input,    CSVFormat    .    DEFAULT    )    ;  	[BUGGY]  while  (  (  rec  =  getRecord  (  )  )  !  =  null  )  {  records  .  add  (  rec  )  ;  [CE]  illegal  start  of  expression    [METHOD]    <init>  [TYPE]  Reader)  [PARAMETER]  Reader  input  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  boolean  false  true  [TYPE]  Reader  input  [TYPE]  List  record  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  [TYPE]  Map  headerMapping    [CONTEXT]    public  CSVParser  (  Reader  input  )  throws  IOException  {  [ATTENTION]  while  (  (  rec  =  getRecord  (  )  )  !  =  null  )  {  records  .  add  (  rec  )    ;  }    	None^81^^^^^80^82^
[REPLACE]    format    .    validate    (    )    ;  	[BUGGY]  format  .  getHeader  (  )    ;  [FE]    (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    <init>  [TYPE]  CSVFormat)  [PARAMETER]  Reader  input  CSVFormat  format  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  boolean  false  true  [TYPE]  Reader  input  [TYPE]  List  record  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  [TYPE]  CSVFormat  format  [TYPE]  Map  headerMapping    [CONTEXT]    public  CSVParser  (  Reader  input  ,  CSVFormat  format  )  throws  IOException  {  [ATTENTION]  format  .  getHeader  (  )  ;    this  .  lexer  =  new  CSVLexer  (  format  ,  new  ExtendedBufferedReader  (  input  )  )  ;    this  .  headerMapping  =  initializeHeader  (  format  )  ;  }    	None^92^^^^^91^97^
[REPLACE]    this    .    lexer    =    new    CSVLexer    (    format,    new    ExtendedBufferedReader    (    input    )    )    ;  	[BUGGY]  this  .  lexer  =    new  CSVLexer  (  null  ,  new  ExtendedBufferedReader  (  input  )  )  ;  [FE]    (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    <init>  [TYPE]  CSVFormat)  [PARAMETER]  Reader  input  CSVFormat  format  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  boolean  false  true  [TYPE]  Reader  input  [TYPE]  List  record  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  [TYPE]  CSVFormat  format  [TYPE]  Map  headerMapping    [CONTEXT]    public  CSVParser  (  Reader  input  ,  CSVFormat  format  )  throws  IOException  {  format  .  validate  (  )  ;    [ATTENTION]  this  .  lexer  =  new  CSVLexer  (  null  ,  new  ExtendedBufferedReader  (  input  )  )    ;    this  .  headerMapping  =  initializeHeader  (  format  )  ;  }    	None^94^^^^^91^97^
[REPLACE]    this    .    headerMapping    =    initializeHeader    (    format    )    ;  	[BUGGY]  this  .  headerMapping  =    initializeHeader  (  null  )  ;  [FE]    (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    <init>  [TYPE]  CSVFormat)  [PARAMETER]  Reader  input  CSVFormat  format  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  boolean  false  true  [TYPE]  Reader  input  [TYPE]  List  record  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  [TYPE]  CSVFormat  format  [TYPE]  Map  headerMapping    [CONTEXT]    public  CSVParser  (  Reader  input  ,  CSVFormat  format  )  throws  IOException  {  format  .  validate  (  )  ;    this  .  lexer  =  new  CSVLexer  (  format  ,  new  ExtendedBufferedReader  (  input  )  )  ;    [ATTENTION]  this  .  headerMapping  =  initializeHeader  (  null  )    ;  }    	None^96^^^^^91^97^
[ADD]    this    .    headerMapping    =    initializeHeader    (    format    )    ;    }  	[BUGGY]  [CE]  illegal  start  of  expression    [METHOD]    <init>  [TYPE]  CSVFormat)  [PARAMETER]  Reader  input  CSVFormat  format  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  boolean  false  true  [TYPE]  Reader  input  [TYPE]  List  record  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  [TYPE]  CSVFormat  format  [TYPE]  Map  headerMapping    [CONTEXT]    public  CSVParser  (  Reader  input  ,  CSVFormat  format  )  throws  IOException  {  format  .  validate  (  )  ;    this  .  lexer  =  new  CSVLexer  (  format  ,  new  ExtendedBufferedReader  (  input  )  )  ;    [ATTENTION]      	None^96^97^^^^91^97^
[REPLACE]    this    (    new    StringReader    (    input    )    ,    format    )    ;  	[BUGGY]  this  .  headerMapping  =  initializeHeader  (  format  )  ;  [CE]  variable  lexer  might  not  have  been  initialized    [METHOD]    <init>  [TYPE]  CSVFormat)  [PARAMETER]  String  input  CSVFormat  format  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  boolean  false  true  [TYPE]  List  record  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  [TYPE]  CSVFormat  format  [TYPE]  String  input  [TYPE]  Map  headerMapping    [CONTEXT]    public  CSVParser  (  String  input  ,  CSVFormat  format  )  throws  IOException{  [ATTENTION]  this  .  headerMapping  =  initializeHeader  (  format  )    ;  }    	None^107^^^^^106^108^
[REMOVE]      	[BUGGY]  while  (  (  rec  =  getRecord  (  )  )  !  =  null  )  {  records  .  add  (  rec  )  ;  [CE]  illegal  start  of  expression    [METHOD]    <init>  [TYPE]  CSVFormat)  [PARAMETER]  String  input  CSVFormat  format  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  boolean  false  true  [TYPE]  List  record  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  [TYPE]  CSVFormat  format  [TYPE]  String  input  [TYPE]  Map  headerMapping    [CONTEXT]    public  CSVParser  (  String  input  ,  CSVFormat  format  )  throws  IOException{  [ATTENTION]  this  (  new  StringReader  (  input  )  ,  format  )  ;      	None^107^^^^^106^108^
[REPLACE]    List<CSVRecord>    records    =    new    ArrayList<CSVRecord>    (    )    ;  	[BUGGY]  CSVRecord  rec  =  getRecord  (  )  ;  [CE]  variable  rec  is  already  defined  in  method  getRecords()    [METHOD]    getRecords  [TYPE]  List  [PARAMETER]  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  rec  [TYPE]  boolean  false  true  [TYPE]  Map  headerMapping    [CONTEXT]    public  List<CSVRecord>  getRecords  (  )  throws  IOException  {  [ATTENTION]  CSVRecord  rec  =  getRecord  (  )    ;  CSVRecord  rec  ;  while  (  (  rec  =  getRecord  (  )  )  !  =  null  )  {  records  .  add  (  rec  )  ;  }  return  records  ;  }    	None^121^^^^^120^127^
[REPLACE]    CSVRecord    rec;  	[BUGGY]  CSVRecord  rec  =  getRecord  (  )  ;  [FE]    (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    getRecords  [TYPE]  List  [PARAMETER]  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  rec  [TYPE]  boolean  false  true  [TYPE]  Map  headerMapping    [CONTEXT]    public  List<CSVRecord>  getRecords  (  )  throws  IOException  {  List<CSVRecord>  records  =  new  ArrayList<CSVRecord>  (  )  ;  [ATTENTION]  CSVRecord  rec  =  getRecord  (  )    ;  while  (  (  rec  =  getRecord  (  )  )  !  =  null  )  {  records  .  add  (  rec  )  ;  }  return  records  ;  }    	None^122^^^^^120^127^
[ADD]    CSVRecord    rec;  	[BUGGY]  [CE]  cannot  find  symbol  rec    [METHOD]    getRecords  [TYPE]  List  [PARAMETER]  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  rec  [TYPE]  boolean  false  true  [TYPE]  Map  headerMapping    [CONTEXT]    public  List<CSVRecord>  getRecords  (  )  throws  IOException  {  List<CSVRecord>  records  =  new  ArrayList<CSVRecord>  (  )  ;  [ATTENTION]  while  (  (  rec  =  getRecord  (  )  )  !  =  null  )  {  records  .  add  (  rec  )  ;  }  return  records  ;  }    	None^122^^^^^120^127^
[REPLACE]    while    (    (    rec    =    getRecord    (    )    )    !=    null    )    {  	[BUGGY]  while  (  (  rec  =  getRecord  (  )  )    =  =  null  )  {[FE]    (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    getRecords  [TYPE]  List  [PARAMETER]  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  rec  [TYPE]  boolean  false  true  [TYPE]  Map  headerMapping    [CONTEXT]    public  List<CSVRecord>  getRecords  (  )  throws  IOException  {  List<CSVRecord>  records  =  new  ArrayList<CSVRecord>  (  )  ;  CSVRecord  rec  ;  [ATTENTION]  while  (  (  rec  =  getRecord  (  )  )  =  =  null  )  {  records  .  add  (  rec  )  ;  }  return  records  ;  }    	None^123^^^^^120^127^
[ADD]    while    (    (    rec    =    getRecord    (    )    )    !=    null    )    {    records    .    add    (    rec    )    ;  	[BUGGY]  [CE]  illegal  start  of  type    [METHOD]    getRecords  [TYPE]  List  [PARAMETER]  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  rec  [TYPE]  boolean  false  true  [TYPE]  Map  headerMapping    [CONTEXT]    public  List<CSVRecord>  getRecords  (  )  throws  IOException  {  List<CSVRecord>  records  =  new  ArrayList<CSVRecord>  (  )  ;  CSVRecord  rec  ;  [ATTENTION]    }  return  records  ;  }    	None^123^124^^^^120^127^
[REPLACE]    records    .    add    (    rec    )    ;  	[BUGGY]  records  .  add  (  current  )  ;  [CE]  cannot  find  symbol  current    [METHOD]    getRecords  [TYPE]  List  [PARAMETER]  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  rec  [TYPE]  boolean  false  true  [TYPE]  Map  headerMapping    [CONTEXT]    public  List<CSVRecord>  getRecords  (  )  throws  IOException  {  List<CSVRecord>  records  =  new  ArrayList<CSVRecord>  (  )  ;  CSVRecord  rec  ;  while  (  (  rec  =  getRecord  (  )  )  !  =  null  )  {  [ATTENTION]  records  .  add  (  current  )    ;  }  return  records  ;  }    	None^124^^^^^120^127^
[REPLACE]    while    (    (    rec    =    getRecord    (    )    )    !=    null    )    {  	[BUGGY]  while  (  (  rec    =    while  (  (  rec  ;  [CE]  illegal  start  of  expression    [METHOD]    getRecords  [TYPE]  List  [PARAMETER]  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  rec  [TYPE]  boolean  false  true  [TYPE]  Map  headerMapping    [CONTEXT]    public  List<CSVRecord>  getRecords  (  )  throws  IOException  {  List<CSVRecord>  records  =  new  ArrayList<CSVRecord>  (  )  ;  CSVRecord  rec  ;  [ATTENTION]  while  (  (  rec  =  while  (  (  rec  ;  records  .  add  (  rec  )  ;  }  return  records  ;  }    	None^123^^^^^120^127^
[REPLACE]    return    records;  	[BUGGY]  return  null  ;  [FE]    (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    getRecords  [TYPE]  List  [PARAMETER]  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  rec  [TYPE]  boolean  false  true  [TYPE]  Map  headerMapping    [CONTEXT]    public  List<CSVRecord>  getRecords  (  )  throws  IOException  {  List<CSVRecord>  records  =  new  ArrayList<CSVRecord>  (  )  ;  CSVRecord  rec  ;  while  (  (  rec  =  getRecord  (  )  )  !  =  null  )  {  records  .  add  (  rec  )  ;  }  [ATTENTION]  return  null  ;  }    	None^126^^^^^120^127^
[REPLACE]    CSVRecord    result    =    new    CSVRecord    (    null,    headerMapping    )    ;  	[BUGGY]  CSVRecord  result  =  new  CSVRecord  (  true  ,  headerMapping  )  ;  [CE]  constructor  CSVRecord  in  class  CSVRecord  cannot  be  applied  to  given  types  ;    [METHOD]    getRecord  [TYPE]  CSVRecord  [PARAMETER]  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  rec  result  [TYPE]  boolean  false  true  [TYPE]  Map  headerMapping    [CONTEXT]    CSVRecord  getRecord  (  )  throws  IOException  {  [ATTENTION]  CSVRecord  result  =  new  CSVRecord  (  true  ,  headerMapping  )    ;  record  .  clear  (  )  ;  do  {  reusableToken  .  reset  (  )  ;  lexer  .  nextToken  (  reusableToken  )  ;  switch  (  reusableToken  .  type  )  {  case  TOKEN:  record  .  add  (  reusableToken  .  content  .  toString  (  )  )  ;  break  ;  case  EORECORD:  record  .  add  (  reusableToken  .  content  .  toString  (  )  )  ;  break  ;  case  EOF:  if  (  reusableToken  .  isReady  )  {  record  .  add  (  reusableToken  .  content  .  toString  (  )  )  ;  }  else  {  result  =  null  ;  }  break  ;  case  INVALID:  throw  new  IOException  (     "  (  line     "  +  getLineNumber  (  )  +     "  )  invalid  parse  sequence   "  )  ;  }  }  while  (  reusableToken  .  type  =  =  TOKEN  )  ;    if  (  !record  .  isEmpty  (  )  )  {  result  =  new  CSVRecord  (  record  .  toArray  (  new  String[record  .  size  (  )  ]  )  ,  headerMapping  )  ;  }  return  result  ;  }    	None^136^^^^^135^164^
[ADD]    CSVRecord    result    =    new    CSVRecord    (    null,    headerMapping    )    ;  	[BUGGY]  [CE]  cannot  find  symbol  result    [METHOD]    getRecord  [TYPE]  CSVRecord  [PARAMETER]  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  rec  result  [TYPE]  boolean  false  true  [TYPE]  Map  headerMapping    [CONTEXT]    CSVRecord  getRecord  (  )  throws  IOException  {  [ATTENTION]  record  .  clear  (  )  ;  do  {  reusableToken  .  reset  (  )  ;  lexer  .  nextToken  (  reusableToken  )  ;  switch  (  reusableToken  .  type  )  {  case  TOKEN:  record  .  add  (  reusableToken  .  content  .  toString  (  )  )  ;  break  ;  case  EORECORD:  record  .  add  (  reusableToken  .  content  .  toString  (  )  )  ;  break  ;  case  EOF:  if  (  reusableToken  .  isReady  )  {  record  .  add  (  reusableToken  .  content  .  toString  (  )  )  ;  }  else  {  result  =  null  ;  }  break  ;  case  INVALID:  throw  new  IOException  (     "  (  line     "  +  getLineNumber  (  )  +     "  )  invalid  parse  sequence   "  )  ;  }  }  while  (  reusableToken  .  type  =  =  TOKEN  )  ;    if  (  !record  .  isEmpty  (  )  )  {  result  =  new  CSVRecord  (  record  .  toArray  (  new  String[record  .  size  (  )  ]  )  ,  headerMapping  )  ;  }  return  result  ;  }    	None^136^^^^^135^164^
[REPLACE]    record    .    clear    (    )    ;  	[BUGGY]  record  .  isEmpty  (  )    ;  [FE]  [METHOD]    getRecord  [TYPE]  CSVRecord  [PARAMETER]  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  rec  result  [TYPE]  boolean  false  true  [TYPE]  Map  headerMapping    [CONTEXT]    CSVRecord  getRecord  (  )  throws  IOException  {  CSVRecord  result  =  new  CSVRecord  (  null  ,  headerMapping  )  ;  [ATTENTION]  record  .  isEmpty  (  )  ;  do  {  reusableToken  .  reset  (  )  ;  lexer  .  nextToken  (  reusableToken  )  ;  switch  (  reusableToken  .  type  )  {  case  TOKEN:  record  .  add  (  reusableToken  .  content  .  toString  (  )  )  ;  break  ;  case  EORECORD:  record  .  add  (  reusableToken  .  content  .  toString  (  )  )  ;  break  ;  case  EOF:  if  (  reusableToken  .  isReady  )  {  record  .  add  (  reusableToken  .  content  .  toString  (  )  )  ;  }  else  {  result  =  null  ;  }  break  ;  case  INVALID:  throw  new  IOException  (     "  (  line     "  +  getLineNumber  (  )  +     "  )  invalid  parse  sequence   "  )  ;  }  }  while  (  reusableToken  .  type  =  =  TOKEN  )  ;    if  (  !record  .  isEmpty  (  )  )  {  result  =  new  CSVRecord  (  record  .  toArray  (  new  String[record  .  size  (  )  ]  )  ,  headerMapping  )  ;  }  return  result  ;  }    	None^137^^^^^135^164^
[REPLACE]    if    (    reusableToken    .    isReady    )    {  	[BUGGY]  if  (  format  .  getHeader  (  )  !  =  null  )  {[CE]  cannot  find  symbol  format    [METHOD]    getRecord  [TYPE]  CSVRecord  [PARAMETER]  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  rec  result  [TYPE]  boolean  false  true  [TYPE]  Map  headerMapping    [CONTEXT]    CSVRecord  getRecord  (  )  throws  IOException  {  CSVRecord  result  =  new  CSVRecord  (  null  ,  headerMapping  )  ;  record  .  clear  (  )  ;  do  {  reusableToken  .  reset  (  )  ;  lexer  .  nextToken  (  reusableToken  )  ;  switch  (  reusableToken  .  type  )  {  case  TOKEN:  record  .  add  (  reusableToken  .  content  .  toString  (  )  )  ;  break  ;  case  EORECORD:  record  .  add  (  reusableToken  .  content  .  toString  (  )  )  ;  break  ;  case  EOF:  [ATTENTION]  if  (  format  .  getHeader  (  )  !  =  null  )  {  record  .  add  (  reusableToken  .  content  .  toString  (  )  )  ;  }  else  {  result  =  null  ;  }  break  ;  case  INVALID:  throw  new  IOException  (     "  (  line     "  +  getLineNumber  (  )  +     "  )  invalid  parse  sequence   "  )  ;  }  }  while  (  reusableToken  .  type  =  =  TOKEN  )  ;    if  (  !record  .  isEmpty  (  )  )  {  result  =  new  CSVRecord  (  record  .  toArray  (  new  String[record  .  size  (  )  ]  )  ,  headerMapping  )  ;  }  return  result  ;  }    	None^149^^^^^135^164^
[REPLACE]    result    =    null;  	[BUGGY]  result  =  false  ;  [CE]  incompatible  types    [METHOD]    getRecord  [TYPE]  CSVRecord  [PARAMETER]  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  rec  result  [TYPE]  boolean  false  true  [TYPE]  Map  headerMapping    [CONTEXT]    if  (  reusableToken  .  isReady  )  {  record  .  add  (  reusableToken  .  content  .  toString  (  )  )  ;  }  else  {  [ATTENTION]  result  =  false  ;  }    	None^152^^^^^149^153^
[ADD]    result    =    null;  	[BUGGY]  [FE]  [METHOD]    getRecord  [TYPE]  CSVRecord  [PARAMETER]  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  rec  result  [TYPE]  boolean  false  true  [TYPE]  Map  headerMapping    [CONTEXT]    if  (  reusableToken  .  isReady  )  {  record  .  add  (  reusableToken  .  content  .  toString  (  )  )  ;  }  else  {  [ATTENTION]  }    	None^152^^^^^149^153^
[REPLACE]    record    .    add    (    reusableToken    .    content    .    toString    (    )    )    ;  	[BUGGY]  record  .  toArray  (  reusableToken  .  content  .  toString  (  )  )  ;  [CE]  no  suitable  method  found  for  toArray(String)    [METHOD]    getRecord  [TYPE]  CSVRecord  [PARAMETER]  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  rec  result  [TYPE]  boolean  false  true  [TYPE]  Map  headerMapping    [CONTEXT]    CSVRecord  getRecord  (  )  throws  IOException  {  CSVRecord  result  =  new  CSVRecord  (  null  ,  headerMapping  )  ;  record  .  clear  (  )  ;  do  {  reusableToken  .  reset  (  )  ;  lexer  .  nextToken  (  reusableToken  )  ;  switch  (  reusableToken  .  type  )  {  case  TOKEN:  record  .  add  (  reusableToken  .  content  .  toString  (  )  )  ;  break  ;  case  EORECORD:  record  .  add  (  reusableToken  .  content  .  toString  (  )  )  ;  break  ;  case  EOF:  if  (  reusableToken  .  isReady  )  {  [ATTENTION]  record  .  toArray  (  reusableToken  .  content  .  toString  (  )  )    ;  }  else  {  result  =  null  ;  }  break  ;  case  INVALID:  throw  new  IOException  (     "  (  line     "  +  getLineNumber  (  )  +     "  )  invalid  parse  sequence   "  )  ;  }  }  while  (  reusableToken  .  type  =  =  TOKEN  )  ;    if  (  !record  .  isEmpty  (  )  )  {  result  =  new  CSVRecord  (  record  .  toArray  (  new  String[record  .  size  (  )  ]  )  ,  headerMapping  )  ;  }  return  result  ;  }    	None^150^^^^^135^164^
[REPLACE]    record    .    add    (    reusableToken    .    content    .    toString    (    )    )    ;  	[BUGGY]  record  .  add  (  reusableToken  .  content  .  getRecord  (  )  )  ;  [CE]  cannot  find  symbol    [METHOD]    getRecord  [TYPE]  CSVRecord  [PARAMETER]  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  rec  result  [TYPE]  boolean  false  true  [TYPE]  Map  headerMapping    [CONTEXT]    CSVRecord  getRecord  (  )  throws  IOException  {  CSVRecord  result  =  new  CSVRecord  (  null  ,  headerMapping  )  ;  record  .  clear  (  )  ;  do  {  reusableToken  .  reset  (  )  ;  lexer  .  nextToken  (  reusableToken  )  ;  switch  (  reusableToken  .  type  )  {  case  TOKEN:  record  .  add  (  reusableToken  .  content  .  toString  (  )  )  ;  break  ;  case  EORECORD:  record  .  add  (  reusableToken  .  content  .  toString  (  )  )  ;  break  ;  case  EOF:  if  (  reusableToken  .  isReady  )  {  [ATTENTION]  record  .  add  (  reusableToken  .  content  .  getRecord  (  )  )    ;  }  else  {  result  =  null  ;  }  break  ;  case  INVALID:  throw  new  IOException  (     "  (  line     "  +  getLineNumber  (  )  +     "  )  invalid  parse  sequence   "  )  ;  }  }  while  (  reusableToken  .  type  =  =  TOKEN  )  ;    if  (  !record  .  isEmpty  (  )  )  {  result  =  new  CSVRecord  (  record  .  toArray  (  new  String[record  .  size  (  )  ]  )  ,  headerMapping  )  ;  }  return  result  ;  }    	None^150^^^^^135^164^
[REPLACE]    result    =    null;  	[BUGGY]  result  =  true  ;  [CE]  incompatible  types    [METHOD]    getRecord  [TYPE]  CSVRecord  [PARAMETER]  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  rec  result  [TYPE]  boolean  false  true  [TYPE]  Map  headerMapping    [CONTEXT]    CSVRecord  getRecord  (  )  throws  IOException  {  CSVRecord  result  =  new  CSVRecord  (  null  ,  headerMapping  )  ;  record  .  clear  (  )  ;  do  {  reusableToken  .  reset  (  )  ;  lexer  .  nextToken  (  reusableToken  )  ;  switch  (  reusableToken  .  type  )  {  case  TOKEN:  record  .  add  (  reusableToken  .  content  .  toString  (  )  )  ;  break  ;  case  EORECORD:  record  .  add  (  reusableToken  .  content  .  toString  (  )  )  ;  break  ;  case  EOF:  if  (  reusableToken  .  isReady  )  {  record  .  add  (  reusableToken  .  content  .  toString  (  )  )  ;  }  else  {  [ATTENTION]  result  =  true  ;  }  break  ;  case  INVALID:  throw  new  IOException  (     "  (  line     "  +  getLineNumber  (  )  +     "  )  invalid  parse  sequence   "  )  ;  }  }  while  (  reusableToken  .  type  =  =  TOKEN  )  ;    if  (  !record  .  isEmpty  (  )  )  {  result  =  new  CSVRecord  (  record  .  toArray  (  new  String[record  .  size  (  )  ]  )  ,  headerMapping  )  ;  }  return  result  ;  }    	None^152^^^^^135^164^
[REPLACE]    throw    new    IOException    (   "       ")    ;  	[BUGGY]  throw  new  UnsupportedOperationException  (   "     ")    ;    ;  [CE]  unreachable  statement    [METHOD]    getRecord  [TYPE]  CSVRecord  [PARAMETER]  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  rec  result  [TYPE]  boolean  false  true  [TYPE]  Map  headerMapping    [CONTEXT]    CSVRecord  getRecord  (  )  throws  IOException  {  CSVRecord  result  =  new  CSVRecord  (  null  ,  headerMapping  )  ;  record  .  clear  (  )  ;  do  {  reusableToken  .  reset  (  )  ;  lexer  .  nextToken  (  reusableToken  )  ;  switch  (  reusableToken  .  type  )  {  case  TOKEN:  record  .  add  (  reusableToken  .  content  .  toString  (  )  )  ;  break  ;  case  EORECORD:  record  .  add  (  reusableToken  .  content  .  toString  (  )  )  ;  break  ;  case  EOF:  if  (  reusableToken  .  isReady  )  {  record  .  add  (  reusableToken  .  content  .  toString  (  )  )  ;  }  else  {  result  =  null  ;  }  break  ;  case  INVALID:  [ATTENTION]  throw  new  UnsupportedOperationException  (     "     "  )  ;    ;  }  }  while  (  reusableToken  .  type  =  =  TOKEN  )  ;    if  (  !record  .  isEmpty  (  )  )  {  result  =  new  CSVRecord  (  record  .  toArray  (  new  String[record  .  size  (  )  ]  )  ,  headerMapping  )  ;  }  return  result  ;  }    	None^156^^^^^135^164^
[REPLACE]    if    (    !record    .    isEmpty    (    )    )    {  	[BUGGY]  if  (  record  .  isEmpty  (  )  )  {[FE]  [METHOD]    getRecord  [TYPE]  CSVRecord  [PARAMETER]  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  rec  result  [TYPE]  boolean  false  true  [TYPE]  Map  headerMapping    [CONTEXT]    CSVRecord  getRecord  (  )  throws  IOException  {  CSVRecord  result  =  new  CSVRecord  (  null  ,  headerMapping  )  ;  record  .  clear  (  )  ;  do  {  reusableToken  .  reset  (  )  ;  lexer  .  nextToken  (  reusableToken  )  ;  switch  (  reusableToken  .  type  )  {  case  TOKEN:  record  .  add  (  reusableToken  .  content  .  toString  (  )  )  ;  break  ;  case  EORECORD:  record  .  add  (  reusableToken  .  content  .  toString  (  )  )  ;  break  ;  case  EOF:  if  (  reusableToken  .  isReady  )  {  record  .  add  (  reusableToken  .  content  .  toString  (  )  )  ;  }  else  {  result  =  null  ;  }  break  ;  case  INVALID:  throw  new  IOException  (     "  (  line     "  +  getLineNumber  (  )  +     "  )  invalid  parse  sequence   "  )  ;  }  }  while  (  reusableToken  .  type  =  =  TOKEN  )  ;    [ATTENTION]  if  (  record  .  isEmpty  (  )  )  {  result  =  new  CSVRecord  (  record  .  toArray  (  new  String[record  .  size  (  )  ]  )  ,  headerMapping  )  ;  }  return  result  ;  }    	None^160^^^^^135^164^
[ADD]    if    (    !record    .    isEmpty    (    )    )    {    result    =    new    CSVRecord    (    record    .    toArray    (    new    String[record    .    size    (    )    ]    )    ,    headerMapping    )    ;    }  	[BUGGY]  [FE]    (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    getRecord  [TYPE]  CSVRecord  [PARAMETER]  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  rec  result  [TYPE]  boolean  false  true  [TYPE]  Map  headerMapping    [CONTEXT]    CSVRecord  getRecord  (  )  throws  IOException  {  CSVRecord  result  =  new  CSVRecord  (  null  ,  headerMapping  )  ;  record  .  clear  (  )  ;  do  {  reusableToken  .  reset  (  )  ;  lexer  .  nextToken  (  reusableToken  )  ;  switch  (  reusableToken  .  type  )  {  case  TOKEN:  record  .  add  (  reusableToken  .  content  .  toString  (  )  )  ;  break  ;  case  EORECORD:  record  .  add  (  reusableToken  .  content  .  toString  (  )  )  ;  break  ;  case  EOF:  if  (  reusableToken  .  isReady  )  {  record  .  add  (  reusableToken  .  content  .  toString  (  )  )  ;  }  else  {  result  =  null  ;  }  break  ;  case  INVALID:  throw  new  IOException  (     "  (  line     "  +  getLineNumber  (  )  +     "  )  invalid  parse  sequence   "  )  ;  }  }  while  (  reusableToken  .  type  =  =  TOKEN  )  ;    [ATTENTION]    return  result  ;  }    	None^160^161^162^^^135^164^
[REPLACE]    result    =    new    CSVRecord    (    record    .    toArray    (    new    String[record    .    size    (    )    ]    )    ,    headerMapping    )    ;  	[BUGGY]  result  ;  [CE]  not  a  statement    [METHOD]    getRecord  [TYPE]  CSVRecord  [PARAMETER]  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  rec  result  [TYPE]  boolean  false  true  [TYPE]  Map  headerMapping    [CONTEXT]    CSVRecord  getRecord  (  )  throws  IOException  {  CSVRecord  result  =  new  CSVRecord  (  null  ,  headerMapping  )  ;  record  .  clear  (  )  ;  do  {  reusableToken  .  reset  (  )  ;  lexer  .  nextToken  (  reusableToken  )  ;  switch  (  reusableToken  .  type  )  {  case  TOKEN:  record  .  add  (  reusableToken  .  content  .  toString  (  )  )  ;  break  ;  case  EORECORD:  record  .  add  (  reusableToken  .  content  .  toString  (  )  )  ;  break  ;  case  EOF:  if  (  reusableToken  .  isReady  )  {  record  .  add  (  reusableToken  .  content  .  toString  (  )  )  ;  }  else  {  result  =  null  ;  }  break  ;  case  INVALID:  throw  new  IOException  (     "  (  line     "  +  getLineNumber  (  )  +     "  )  invalid  parse  sequence   "  )  ;  }  }  while  (  reusableToken  .  type  =  =  TOKEN  )  ;    if  (  !record  .  isEmpty  (  )  )  {  [ATTENTION]  result  ;  }  return  result  ;  }    	None^161^^^^^135^164^
[REPLACE]    result    =    new    CSVRecord    (    record    .    toArray    (    new    String[record    .    size    (    )    ]    )    ,    headerMapping    )    ;  	[BUGGY]  result    =  null  ;  [FE]    (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    getRecord  [TYPE]  CSVRecord  [PARAMETER]  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  rec  result  [TYPE]  boolean  false  true  [TYPE]  Map  headerMapping    [CONTEXT]    CSVRecord  getRecord  (  )  throws  IOException  {  CSVRecord  result  =  new  CSVRecord  (  null  ,  headerMapping  )  ;  record  .  clear  (  )  ;  do  {  reusableToken  .  reset  (  )  ;  lexer  .  nextToken  (  reusableToken  )  ;  switch  (  reusableToken  .  type  )  {  case  TOKEN:  record  .  add  (  reusableToken  .  content  .  toString  (  )  )  ;  break  ;  case  EORECORD:  record  .  add  (  reusableToken  .  content  .  toString  (  )  )  ;  break  ;  case  EOF:  if  (  reusableToken  .  isReady  )  {  record  .  add  (  reusableToken  .  content  .  toString  (  )  )  ;  }  else  {  result  =  null  ;  }  break  ;  case  INVALID:  throw  new  IOException  (     "  (  line     "  +  getLineNumber  (  )  +     "  )  invalid  parse  sequence   "  )  ;  }  }  while  (  reusableToken  .  type  =  =  TOKEN  )  ;    if  (  !record  .  isEmpty  (  )  )  {  [ATTENTION]  result  =  null  ;  }  return  result  ;  }    	None^161^^^^^135^164^
[REPLACE]    return    result;  	[BUGGY]  return  rec  ;  [CE]  cannot  find  symbol  rec    [METHOD]    getRecord  [TYPE]  CSVRecord  [PARAMETER]  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  rec  result  [TYPE]  boolean  false  true  [TYPE]  Map  headerMapping    [CONTEXT]    CSVRecord  getRecord  (  )  throws  IOException  {  CSVRecord  result  =  new  CSVRecord  (  null  ,  headerMapping  )  ;  record  .  clear  (  )  ;  do  {  reusableToken  .  reset  (  )  ;  lexer  .  nextToken  (  reusableToken  )  ;  switch  (  reusableToken  .  type  )  {  case  TOKEN:  record  .  add  (  reusableToken  .  content  .  toString  (  )  )  ;  break  ;  case  EORECORD:  record  .  add  (  reusableToken  .  content  .  toString  (  )  )  ;  break  ;  case  EOF:  if  (  reusableToken  .  isReady  )  {  record  .  add  (  reusableToken  .  content  .  toString  (  )  )  ;  }  else  {  result  =  null  ;  }  break  ;  case  INVALID:  throw  new  IOException  (     "  (  line     "  +  getLineNumber  (  )  +     "  )  invalid  parse  sequence   "  )  ;  }  }  while  (  reusableToken  .  type  =  =  TOKEN  )  ;    if  (  !record  .  isEmpty  (  )  )  {  result  =  new  CSVRecord  (  record  .  toArray  (  new  String[record  .  size  (  )  ]  )  ,  headerMapping  )  ;  }  [ATTENTION]  return  rec  ;  }    	None^163^^^^^135^164^
[REPLACE]    Map<String,    Integer>    hdrMap    =    null;  	[BUGGY]  Map<String  ,  Integer>  hdrMap  =  false  ;  [CE]  incompatible  types    [METHOD]    initializeHeader  [TYPE]  Map  [PARAMETER]  CSVFormat  format  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  boolean  false  true  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  rec  result  [TYPE]  CSVFormat  format  [TYPE]  String[]  header  [TYPE]  Map  hdrMap  headerMapping  [TYPE]  int  i    [CONTEXT]    private  Map<String  ,  Integer>  initializeHeader  (  CSVFormat  format  )  throws  IOException  {  [ATTENTION]  Map<String  ,  Integer>  hdrMap  =  false  ;  if  (  format  .  getHeader  (  )  !  =  null  )  {  hdrMap  =  new  HashMap<String  ,  Integer>  (  )  ;    String[]  header  =  null  ;  if  (  format  .  getHeader  (  )  .  length  =  =  0  )  {    CSVRecord  rec  =  getRecord  (  )  ;  if  (  rec  !  =  null  )  {  header  =  rec  .  values  (  )  ;  }  }  else  {  header  =  format  .  getHeader  (  )  ;  }    if  (  header  !  =  null  )  {  for  (  int  i  =  0  ;  i  <  header  .  length  ;  i++  )  {  hdrMap  .  put  (  header[i]  ,  Integer  .  valueOf  (  i  )  )  ;  }  }  }  return  hdrMap  ;  }    	None^170^^^^^169^193^
[REPLACE]    if    (    format    .    getHeader    (    )    !=    null    )    {  	[BUGGY]  if  (  format  .  validate  (  )    =  =  null  )  {[CE]  'void'  type  not  allowed  here    [METHOD]    initializeHeader  [TYPE]  Map  [PARAMETER]  CSVFormat  format  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  boolean  false  true  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  rec  result  [TYPE]  CSVFormat  format  [TYPE]  String[]  header  [TYPE]  Map  hdrMap  headerMapping  [TYPE]  int  i    [CONTEXT]    private  Map<String  ,  Integer>  initializeHeader  (  CSVFormat  format  )  throws  IOException  {  Map<String  ,  Integer>  hdrMap  =  null  ;  [ATTENTION]  if  (  format  .  validate  (  )  =  =  null  )  {  hdrMap  =  new  HashMap<String  ,  Integer>  (  )  ;    String[]  header  =  null  ;  if  (  format  .  getHeader  (  )  .  length  =  =  0  )  {    CSVRecord  rec  =  getRecord  (  )  ;  if  (  rec  !  =  null  )  {  header  =  rec  .  values  (  )  ;  }  }  else  {  header  =  format  .  getHeader  (  )  ;  }    if  (  header  !  =  null  )  {  for  (  int  i  =  0  ;  i  <  header  .  length  ;  i++  )  {  hdrMap  .  put  (  header[i]  ,  Integer  .  valueOf  (  i  )  )  ;  }  }  }  return  hdrMap  ;  }    	None^171^^^^^169^193^
[ADD]    if    (    format    .    getHeader    (    )    !=    null    )    {    hdrMap    =    new    HashMap<String,    Integer>    (    )    ;    String[]    header    =    null;  	[BUGGY]  [CE]  illegal  start  of  type    [METHOD]    initializeHeader  [TYPE]  Map  [PARAMETER]  CSVFormat  format  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  boolean  false  true  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  rec  result  [TYPE]  CSVFormat  format  [TYPE]  String[]  header  [TYPE]  Map  hdrMap  headerMapping  [TYPE]  int  i    [CONTEXT]    private  Map<String  ,  Integer>  initializeHeader  (  CSVFormat  format  )  throws  IOException  {  Map<String  ,  Integer>  hdrMap  =  null  ;  [ATTENTION]      if  (  format  .  getHeader  (  )  .  length  =  =  0  )  {    CSVRecord  rec  =  getRecord  (  )  ;  if  (  rec  !  =  null  )  {  header  =  rec  .  values  (  )  ;  }  }  else  {  header  =  format  .  getHeader  (  )  ;  }    if  (  header  !  =  null  )  {  for  (  int  i  =  0  ;  i  <  header  .  length  ;  i++  )  {  hdrMap  .  put  (  header[i]  ,  Integer  .  valueOf  (  i  )  )  ;  }  }  }  return  hdrMap  ;  }    	None^171^172^^174^^169^193^
[REPLACE]    if    (    format    .    getHeader    (    )        .    length    ==    0    )    {  	[BUGGY]  if  (  format  .  getHeader  (  )  .  length  +  2  =  =  0  )  {[FE]    (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    initializeHeader  [TYPE]  Map  [PARAMETER]  CSVFormat  format  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  boolean  false  true  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  rec  result  [TYPE]  CSVFormat  format  [TYPE]  String[]  header  [TYPE]  Map  hdrMap  headerMapping  [TYPE]  int  i    [CONTEXT]    private  Map<String  ,  Integer>  initializeHeader  (  CSVFormat  format  )  throws  IOException  {  Map<String  ,  Integer>  hdrMap  =  null  ;  if  (  format  .  getHeader  (  )  !  =  null  )  {  hdrMap  =  new  HashMap<String  ,  Integer>  (  )  ;    String[]  header  =  null  ;  [ATTENTION]  if  (  format  .  getHeader  (  )    .  length  +  2  =  =  0  )  {    CSVRecord  rec  =  getRecord  (  )  ;  if  (  rec  !  =  null  )  {  header  =  rec  .  values  (  )  ;  }  }  else  {  header  =  format  .  getHeader  (  )  ;  }    if  (  header  !  =  null  )  {  for  (  int  i  =  0  ;  i  <  header  .  length  ;  i++  )  {  hdrMap  .  put  (  header[i]  ,  Integer  .  valueOf  (  i  )  )  ;  }  }  }  return  hdrMap  ;  }    	None^175^^^^^169^193^
[REPLACE]    header    =    format    .    getHeader    (    )    ;  	[BUGGY]  header  =    null  .  getHeader  (  )  ;  [CE]  <null>  cannot  be  dereferenced    [METHOD]    initializeHeader  [TYPE]  Map  [PARAMETER]  CSVFormat  format  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  boolean  false  true  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  rec  result  [TYPE]  CSVFormat  format  [TYPE]  String[]  header  [TYPE]  Map  hdrMap  headerMapping  [TYPE]  int  i    [CONTEXT]    private  Map<String  ,  Integer>  initializeHeader  (  CSVFormat  format  )  throws  IOException  {  Map<String  ,  Integer>  hdrMap  =  null  ;  if  (  format  .  getHeader  (  )  !  =  null  )  {  hdrMap  =  new  HashMap<String  ,  Integer>  (  )  ;    String[]  header  =  null  ;  if  (  format  .  getHeader  (  )  .  length  =  =  0  )  {    CSVRecord  rec  =  getRecord  (  )  ;  if  (  rec  !  =  null  )  {  header  =  rec  .  values  (  )  ;  }  }  else  {  [ATTENTION]  header  =  null  .  getHeader  (  )    ;  }    if  (  header  !  =  null  )  {  for  (  int  i  =  0  ;  i  <  header  .  length  ;  i++  )  {  hdrMap  .  put  (  header[i]  ,  Integer  .  valueOf  (  i  )  )  ;  }  }  }  return  hdrMap  ;  }    	None^182^^^^^169^193^
[REPLACE]    if    (    rec    !=    null    )    {  	[BUGGY]  if  (  rec  =  =  true  )  {[CE]  incomparable  types:  CSVRecord  and  boolean    [METHOD]    initializeHeader  [TYPE]  Map  [PARAMETER]  CSVFormat  format  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  boolean  false  true  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  rec  result  [TYPE]  CSVFormat  format  [TYPE]  String[]  header  [TYPE]  Map  hdrMap  headerMapping  [TYPE]  int  i    [CONTEXT]    private  Map<String  ,  Integer>  initializeHeader  (  CSVFormat  format  )  throws  IOException  {  Map<String  ,  Integer>  hdrMap  =  null  ;  if  (  format  .  getHeader  (  )  !  =  null  )  {  hdrMap  =  new  HashMap<String  ,  Integer>  (  )  ;    String[]  header  =  null  ;  if  (  format  .  getHeader  (  )  .  length  =  =  0  )  {    CSVRecord  rec  =  getRecord  (  )  ;  [ATTENTION]  if  (  rec  =  =  true  )  {  header  =  rec  .  values  (  )  ;  }  }  else  {  header  =  format  .  getHeader  (  )  ;  }    if  (  header  !  =  null  )  {  for  (  int  i  =  0  ;  i  <  header  .  length  ;  i++  )  {  hdrMap  .  put  (  header[i]  ,  Integer  .  valueOf  (  i  )  )  ;  }  }  }  return  hdrMap  ;  }    	None^178^^^^^169^193^
[REPLACE]    header    =    rec    .    values    (    )    ;  	[BUGGY]  header  =    null  .  values  (  )  ;  [CE]  <null>  cannot  be  dereferenced    [METHOD]    initializeHeader  [TYPE]  Map  [PARAMETER]  CSVFormat  format  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  boolean  false  true  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  rec  result  [TYPE]  CSVFormat  format  [TYPE]  String[]  header  [TYPE]  Map  hdrMap  headerMapping  [TYPE]  int  i    [CONTEXT]    private  Map<String  ,  Integer>  initializeHeader  (  CSVFormat  format  )  throws  IOException  {  Map<String  ,  Integer>  hdrMap  =  null  ;  if  (  format  .  getHeader  (  )  !  =  null  )  {  hdrMap  =  new  HashMap<String  ,  Integer>  (  )  ;    String[]  header  =  null  ;  if  (  format  .  getHeader  (  )  .  length  =  =  0  )  {    CSVRecord  rec  =  getRecord  (  )  ;  if  (  rec  !  =  null  )  {  [ATTENTION]  header  =  null  .  values  (  )    ;  }  }  else  {  header  =  format  .  getHeader  (  )  ;  }    if  (  header  !  =  null  )  {  for  (  int  i  =  0  ;  i  <  header  .  length  ;  i++  )  {  hdrMap  .  put  (  header[i]  ,  Integer  .  valueOf  (  i  )  )  ;  }  }  }  return  hdrMap  ;  }    	None^179^^^^^169^193^
[REPLACE]    header    =    rec    .    values    (    )    ;  	[BUGGY]  header  =    result  .  values  (  )  ;  [CE]  cannot  find  symbol  result    [METHOD]    initializeHeader  [TYPE]  Map  [PARAMETER]  CSVFormat  format  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  boolean  false  true  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  rec  result  [TYPE]  CSVFormat  format  [TYPE]  String[]  header  [TYPE]  Map  hdrMap  headerMapping  [TYPE]  int  i    [CONTEXT]    private  Map<String  ,  Integer>  initializeHeader  (  CSVFormat  format  )  throws  IOException  {  Map<String  ,  Integer>  hdrMap  =  null  ;  if  (  format  .  getHeader  (  )  !  =  null  )  {  hdrMap  =  new  HashMap<String  ,  Integer>  (  )  ;    String[]  header  =  null  ;  if  (  format  .  getHeader  (  )  .  length  =  =  0  )  {    CSVRecord  rec  =  getRecord  (  )  ;  if  (  rec  !  =  null  )  {  [ATTENTION]  header  =  result  .  values  (  )    ;  }  }  else  {  header  =  format  .  getHeader  (  )  ;  }    if  (  header  !  =  null  )  {  for  (  int  i  =  0  ;  i  <  header  .  length  ;  i++  )  {  hdrMap  .  put  (  header[i]  ,  Integer  .  valueOf  (  i  )  )  ;  }  }  }  return  hdrMap  ;  }    	None^179^^^^^169^193^
[REPLACE]    CSVRecord    rec    =    getRecord    (    )    ;  	[BUGGY]  CSVRecord  result  =  new  CSVRecord  (  null  ,  headerMapping  )  ;  [CE]  cannot  find  symbol  rec    [METHOD]    initializeHeader  [TYPE]  Map  [PARAMETER]  CSVFormat  format  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  boolean  false  true  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  rec  result  [TYPE]  CSVFormat  format  [TYPE]  String[]  header  [TYPE]  Map  hdrMap  headerMapping  [TYPE]  int  i    [CONTEXT]    private  Map<String  ,  Integer>  initializeHeader  (  CSVFormat  format  )  throws  IOException  {  Map<String  ,  Integer>  hdrMap  =  null  ;  if  (  format  .  getHeader  (  )  !  =  null  )  {  hdrMap  =  new  HashMap<String  ,  Integer>  (  )  ;    String[]  header  =  null  ;  if  (  format  .  getHeader  (  )  .  length  =  =  0  )  {    [ATTENTION]  CSVRecord  result  =  new  CSVRecord  (  null  ,  headerMapping  )    ;  if  (  rec  !  =  null  )  {  header  =  rec  .  values  (  )  ;  }  }  else  {  header  =  format  .  getHeader  (  )  ;  }    if  (  header  !  =  null  )  {  for  (  int  i  =  0  ;  i  <  header  .  length  ;  i++  )  {  hdrMap  .  put  (  header[i]  ,  Integer  .  valueOf  (  i  )  )  ;  }  }  }  return  hdrMap  ;  }    	None^177^^^^^169^193^
[REPLACE]    if    (    rec    !=    null    )    {  	[BUGGY]  if  (result  =  =  null  )  {[CE]  cannot  find  symbol  result    [METHOD]    initializeHeader  [TYPE]  Map  [PARAMETER]  CSVFormat  format  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  boolean  false  true  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  rec  result  [TYPE]  CSVFormat  format  [TYPE]  String[]  header  [TYPE]  Map  hdrMap  headerMapping  [TYPE]  int  i    [CONTEXT]    private  Map<String  ,  Integer>  initializeHeader  (  CSVFormat  format  )  throws  IOException  {  Map<String  ,  Integer>  hdrMap  =  null  ;  if  (  format  .  getHeader  (  )  !  =  null  )  {  hdrMap  =  new  HashMap<String  ,  Integer>  (  )  ;    String[]  header  =  null  ;  if  (  format  .  getHeader  (  )  .  length  =  =  0  )  {    CSVRecord  rec  =  getRecord  (  )  ;  [ATTENTION]  if  (  result  =  =  null  )  {  header  =  rec  .  values  (  )  ;  }  }  else  {  header  =  format  .  getHeader  (  )  ;  }    if  (  header  !  =  null  )  {  for  (  int  i  =  0  ;  i  <  header  .  length  ;  i++  )  {  hdrMap  .  put  (  header[i]  ,  Integer  .  valueOf  (  i  )  )  ;  }  }  }  return  hdrMap  ;  }    	None^178^^^^^169^193^
[REPLACE]    if    (    header    !=    null    )    {  	[BUGGY]  if  (  header  =  =  null  )  {[FE]    (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    initializeHeader  [TYPE]  Map  [PARAMETER]  CSVFormat  format  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  boolean  false  true  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  rec  result  [TYPE]  CSVFormat  format  [TYPE]  String[]  header  [TYPE]  Map  hdrMap  headerMapping  [TYPE]  int  i    [CONTEXT]    private  Map<String  ,  Integer>  initializeHeader  (  CSVFormat  format  )  throws  IOException  {  Map<String  ,  Integer>  hdrMap  =  null  ;  if  (  format  .  getHeader  (  )  !  =  null  )  {  hdrMap  =  new  HashMap<String  ,  Integer>  (  )  ;    String[]  header  =  null  ;  if  (  format  .  getHeader  (  )  .  length  =  =  0  )  {    CSVRecord  rec  =  getRecord  (  )  ;  if  (  rec  !  =  null  )  {  header  =  rec  .  values  (  )  ;  }  }  else  {  header  =  format  .  getHeader  (  )  ;  }    [ATTENTION]  if  (  header  =  =  null  )  {  for  (  int  i  =  0  ;  i  <  header  .  length  ;  i++  )  {  hdrMap  .  put  (  header[i]  ,  Integer  .  valueOf  (  i  )  )  ;  }  }  }  return  hdrMap  ;  }    	None^186^^^^^169^193^
[REPLACE]    for    (    int    i    =    0;    i    <    header    .    length;    i++    )    {  	[BUGGY]  for  (  int  i  =  0  ;  i  <  header  .  length  %  0  .  5  ;  i++  )  {[CE]  '  ;  '  expected    [METHOD]    initializeHeader  [TYPE]  Map  [PARAMETER]  CSVFormat  format  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  boolean  false  true  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  rec  result  [TYPE]  CSVFormat  format  [TYPE]  String[]  header  [TYPE]  Map  hdrMap  headerMapping  [TYPE]  int  i    [CONTEXT]    private  Map<String  ,  Integer>  initializeHeader  (  CSVFormat  format  )  throws  IOException  {  Map<String  ,  Integer>  hdrMap  =  null  ;  if  (  format  .  getHeader  (  )  !  =  null  )  {  hdrMap  =  new  HashMap<String  ,  Integer>  (  )  ;    String[]  header  =  null  ;  if  (  format  .  getHeader  (  )  .  length  =  =  0  )  {    CSVRecord  rec  =  getRecord  (  )  ;  if  (  rec  !  =  null  )  {  header  =  rec  .  values  (  )  ;  }  }  else  {  header  =  format  .  getHeader  (  )  ;  }    if  (  header  !  =  null  )  {  [ATTENTION]  for  (  int  i  =  0  ;  i  <  header  .  length  %0  .  5  ;  i++  )  {  hdrMap  .  put  (  header[i]  ,  Integer  .  valueOf  (  i  )  )  ;  }  }  }  return  hdrMap  ;  }    	None^187^^^^^169^193^
[ADD]    for    (    int    i    =    0;    i    <    header    .    length;    i++    )    {    hdrMap    .    put    (    header[i],    Integer    .    valueOf    (    i    )    )    ;    }  	[BUGGY]  [FE]    (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    initializeHeader  [TYPE]  Map  [PARAMETER]  CSVFormat  format  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  boolean  false  true  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  rec  result  [TYPE]  CSVFormat  format  [TYPE]  String[]  header  [TYPE]  Map  hdrMap  headerMapping  [TYPE]  int  i    [CONTEXT]    private  Map<String  ,  Integer>  initializeHeader  (  CSVFormat  format  )  throws  IOException  {  Map<String  ,  Integer>  hdrMap  =  null  ;  if  (  format  .  getHeader  (  )  !  =  null  )  {  hdrMap  =  new  HashMap<String  ,  Integer>  (  )  ;    String[]  header  =  null  ;  if  (  format  .  getHeader  (  )  .  length  =  =  0  )  {    CSVRecord  rec  =  getRecord  (  )  ;  if  (  rec  !  =  null  )  {  header  =  rec  .  values  (  )  ;  }  }  else  {  header  =  format  .  getHeader  (  )  ;  }    if  (  header  !  =  null  )  {  [ATTENTION]    }  }  return  hdrMap  ;  }    	None^187^188^189^^^169^193^
[REPLACE]    hdrMap    .    put    (    header[i],    Integer    .    valueOf    (    i    )    )    ;  	[BUGGY]  hdrMap  .  put  (  header[i]  ,    i    )  ;  [FE]    (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    initializeHeader  [TYPE]  Map  [PARAMETER]  CSVFormat  format  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  boolean  false  true  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  rec  result  [TYPE]  CSVFormat  format  [TYPE]  String[]  header  [TYPE]  Map  hdrMap  headerMapping  [TYPE]  int  i    [CONTEXT]    private  Map<String  ,  Integer>  initializeHeader  (  CSVFormat  format  )  throws  IOException  {  Map<String  ,  Integer>  hdrMap  =  null  ;  if  (  format  .  getHeader  (  )  !  =  null  )  {  hdrMap  =  new  HashMap<String  ,  Integer>  (  )  ;    String[]  header  =  null  ;  if  (  format  .  getHeader  (  )  .  length  =  =  0  )  {    CSVRecord  rec  =  getRecord  (  )  ;  if  (  rec  !  =  null  )  {  header  =  rec  .  values  (  )  ;  }  }  else  {  header  =  format  .  getHeader  (  )  ;  }    if  (  header  !  =  null  )  {  for  (  int  i  =  0  ;  i  <  header  .  length  ;  i++  )  {  [ATTENTION]  hdrMap  .  put  (  header[i]  ,  i  )    ;  }  }  }  return  hdrMap  ;  }    	None^188^^^^^169^193^
[REPLACE]    for    (    int    i    =    0;    i    <    header    .    length;    i++    )    {  	[BUGGY]  for  (  int  i  =  0  ;  i  <  header  .  length  ;  i++  )  {[FE]    (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    initializeHeader  [TYPE]  Map  [PARAMETER]  CSVFormat  format  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  boolean  false  true  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  rec  result  [TYPE]  CSVFormat  format  [TYPE]  String[]  header  [TYPE]  Map  hdrMap  headerMapping  [TYPE]  int  i    [CONTEXT]    private  Map<String  ,  Integer>  initializeHeader  (  CSVFormat  format  )  throws  IOException  {  Map<String  ,  Integer>  hdrMap  =  null  ;  if  (  format  .  getHeader  (  )  !  =  null  )  {  hdrMap  =  new  HashMap<String  ,  Integer>  (  )  ;    String[]  header  =  null  ;  if  (  format  .  getHeader  (  )  .  length  =  =  0  )  {    CSVRecord  rec  =  getRecord  (  )  ;  if  (  rec  !  =  null  )  {  header  =  rec  .  values  (  )  ;  }  }  else  {  header  =  format  .  getHeader  (  )  ;  }    if  (  header  !  =  null  )  {  [ATTENTION]  for  (  int  i  =  0  ;  i  <  header  .  length  ;  i++  )  {  hdrMap  .  put  (  header[i]  ,  Integer  .  valueOf  (  i  )  )  ;  }  }  }  return  hdrMap  ;  }    	None^187^^^^^169^193^
[REPLACE]    for    (    int    i    =    0;    i    <    header    .    length;    i++    )    {  	[BUGGY]  for  (  int  i  =  0  ;  i  <  header  .  length  +  2  ;  i++  )  {[FE]    (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    initializeHeader  [TYPE]  Map  [PARAMETER]  CSVFormat  format  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  boolean  false  true  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  rec  result  [TYPE]  CSVFormat  format  [TYPE]  String[]  header  [TYPE]  Map  hdrMap  headerMapping  [TYPE]  int  i    [CONTEXT]    private  Map<String  ,  Integer>  initializeHeader  (  CSVFormat  format  )  throws  IOException  {  Map<String  ,  Integer>  hdrMap  =  null  ;  if  (  format  .  getHeader  (  )  !  =  null  )  {  hdrMap  =  new  HashMap<String  ,  Integer>  (  )  ;    String[]  header  =  null  ;  if  (  format  .  getHeader  (  )  .  length  =  =  0  )  {    CSVRecord  rec  =  getRecord  (  )  ;  if  (  rec  !  =  null  )  {  header  =  rec  .  values  (  )  ;  }  }  else  {  header  =  format  .  getHeader  (  )  ;  }    if  (  header  !  =  null  )  {  [ATTENTION]  for  (  int  i  =  0  ;  i  <  header  .  length  +  2  ;  i++  )  {  hdrMap  .  put  (  header[i]  ,  Integer  .  valueOf  (  i  )  )  ;  }  }  }  return  hdrMap  ;  }    	None^187^^^^^169^193^
[REPLACE]    hdrMap    =    new    HashMap<String,    Integer>    (    )    ;  	[BUGGY]  hdrMap  ;  [CE]  not  a  statement    [METHOD]    initializeHeader  [TYPE]  Map  [PARAMETER]  CSVFormat  format  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  boolean  false  true  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  rec  result  [TYPE]  CSVFormat  format  [TYPE]  String[]  header  [TYPE]  Map  hdrMap  headerMapping  [TYPE]  int  i    [CONTEXT]    private  Map<String  ,  Integer>  initializeHeader  (  CSVFormat  format  )  throws  IOException  {  Map<String  ,  Integer>  hdrMap  =  null  ;  if  (  format  .  getHeader  (  )  !  =  null  )  {  [ATTENTION]  hdrMap  ;    String[]  header  =  null  ;  if  (  format  .  getHeader  (  )  .  length  =  =  0  )  {    CSVRecord  rec  =  getRecord  (  )  ;  if  (  rec  !  =  null  )  {  header  =  rec  .  values  (  )  ;  }  }  else  {  header  =  format  .  getHeader  (  )  ;  }    if  (  header  !  =  null  )  {  for  (  int  i  =  0  ;  i  <  header  .  length  ;  i++  )  {  hdrMap  .  put  (  header[i]  ,  Integer  .  valueOf  (  i  )  )  ;  }  }  }  return  hdrMap  ;  }    	None^172^^^^^169^193^
[ADD]    header    =    rec    .    values    (    )    ;  	[BUGGY]  [FE]    (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    initializeHeader  [TYPE]  Map  [PARAMETER]  CSVFormat  format  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  boolean  false  true  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  rec  result  [TYPE]  CSVFormat  format  [TYPE]  String[]  header  [TYPE]  Map  hdrMap  headerMapping  [TYPE]  int  i    [CONTEXT]    private  Map<String  ,  Integer>  initializeHeader  (  CSVFormat  format  )  throws  IOException  {  Map<String  ,  Integer>  hdrMap  =  null  ;  if  (  format  .  getHeader  (  )  !  =  null  )  {  hdrMap  =  new  HashMap<String  ,  Integer>  (  )  ;    String[]  header  =  null  ;  if  (  format  .  getHeader  (  )  .  length  =  =  0  )  {    CSVRecord  rec  =  getRecord  (  )  ;  if  (  rec  !  =  null  )  {  [ATTENTION]  }  }  else  {  header  =  format  .  getHeader  (  )  ;  }    if  (  header  !  =  null  )  {  for  (  int  i  =  0  ;  i  <  header  .  length  ;  i++  )  {  hdrMap  .  put  (  header[i]  ,  Integer  .  valueOf  (  i  )  )  ;  }  }  }  return  hdrMap  ;  }    	None^179^^^^^169^193^
[REPLACE]    String[]    header    =    null;  	[BUGGY]  String[]  header  =  false  ;  [CE]  incompatible  types    [METHOD]    initializeHeader  [TYPE]  Map  [PARAMETER]  CSVFormat  format  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  boolean  false  true  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  rec  result  [TYPE]  CSVFormat  format  [TYPE]  String[]  header  [TYPE]  Map  hdrMap  headerMapping  [TYPE]  int  i    [CONTEXT]    private  Map<String  ,  Integer>  initializeHeader  (  CSVFormat  format  )  throws  IOException  {  Map<String  ,  Integer>  hdrMap  =  null  ;  if  (  format  .  getHeader  (  )  !  =  null  )  {  hdrMap  =  new  HashMap<String  ,  Integer>  (  )  ;    [ATTENTION]  String[]  header  =  false  ;  if  (  format  .  getHeader  (  )  .  length  =  =  0  )  {    CSVRecord  rec  =  getRecord  (  )  ;  if  (  rec  !  =  null  )  {  header  =  rec  .  values  (  )  ;  }  }  else  {  header  =  format  .  getHeader  (  )  ;  }    if  (  header  !  =  null  )  {  for  (  int  i  =  0  ;  i  <  header  .  length  ;  i++  )  {  hdrMap  .  put  (  header[i]  ,  Integer  .  valueOf  (  i  )  )  ;  }  }  }  return  hdrMap  ;  }    	None^174^^^^^169^193^
[ADD]    String[]    header    =    null;  	[BUGGY]  [CE]  cannot  find  symbol  header    [METHOD]    initializeHeader  [TYPE]  Map  [PARAMETER]  CSVFormat  format  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  boolean  false  true  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  rec  result  [TYPE]  CSVFormat  format  [TYPE]  String[]  header  [TYPE]  Map  hdrMap  headerMapping  [TYPE]  int  i    [CONTEXT]    private  Map<String  ,  Integer>  initializeHeader  (  CSVFormat  format  )  throws  IOException  {  Map<String  ,  Integer>  hdrMap  =  null  ;  if  (  format  .  getHeader  (  )  !  =  null  )  {  hdrMap  =  new  HashMap<String  ,  Integer>  (  )  ;    [ATTENTION]  if  (  format  .  getHeader  (  )  .  length  =  =  0  )  {    CSVRecord  rec  =  getRecord  (  )  ;  if  (  rec  !  =  null  )  {  header  =  rec  .  values  (  )  ;  }  }  else  {  header  =  format  .  getHeader  (  )  ;  }    if  (  header  !  =  null  )  {  for  (  int  i  =  0  ;  i  <  header  .  length  ;  i++  )  {  hdrMap  .  put  (  header[i]  ,  Integer  .  valueOf  (  i  )  )  ;  }  }  }  return  hdrMap  ;  }    	None^174^^^^^169^193^
[ADD]    CSVRecord    rec    =    getRecord    (    )    ;  	[BUGGY]  [CE]  cannot  find  symbol  rec    [METHOD]    initializeHeader  [TYPE]  Map  [PARAMETER]  CSVFormat  format  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  boolean  false  true  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  rec  result  [TYPE]  CSVFormat  format  [TYPE]  String[]  header  [TYPE]  Map  hdrMap  headerMapping  [TYPE]  int  i    [CONTEXT]    private  Map<String  ,  Integer>  initializeHeader  (  CSVFormat  format  )  throws  IOException  {  Map<String  ,  Integer>  hdrMap  =  null  ;  if  (  format  .  getHeader  (  )  !  =  null  )  {  hdrMap  =  new  HashMap<String  ,  Integer>  (  )  ;    String[]  header  =  null  ;  if  (  format  .  getHeader  (  )  .  length  =  =  0  )  {    [ATTENTION]  if  (  rec  !  =  null  )  {  header  =  rec  .  values  (  )  ;  }  }  else  {  header  =  format  .  getHeader  (  )  ;  }    if  (  header  !  =  null  )  {  for  (  int  i  =  0  ;  i  <  header  .  length  ;  i++  )  {  hdrMap  .  put  (  header[i]  ,  Integer  .  valueOf  (  i  )  )  ;  }  }  }  return  hdrMap  ;  }    	None^177^^^^^169^193^
[REPLACE]    if    (    format    .    getHeader    (    )        .    length    ==    0    )    {  	[BUGGY]  if  (  format  .  getHeader  (  )  .  length  %  2  =  =  0  )  {[FE]    (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    initializeHeader  [TYPE]  Map  [PARAMETER]  CSVFormat  format  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  boolean  false  true  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  rec  result  [TYPE]  CSVFormat  format  [TYPE]  String[]  header  [TYPE]  Map  hdrMap  headerMapping  [TYPE]  int  i    [CONTEXT]    private  Map<String  ,  Integer>  initializeHeader  (  CSVFormat  format  )  throws  IOException  {  Map<String  ,  Integer>  hdrMap  =  null  ;  if  (  format  .  getHeader  (  )  !  =  null  )  {  hdrMap  =  new  HashMap<String  ,  Integer>  (  )  ;    String[]  header  =  null  ;  [ATTENTION]  if  (  format  .  getHeader  (  )    .  length  %2  =  =  0  )  {    CSVRecord  rec  =  getRecord  (  )  ;  if  (  rec  !  =  null  )  {  header  =  rec  .  values  (  )  ;  }  }  else  {  header  =  format  .  getHeader  (  )  ;  }    if  (  header  !  =  null  )  {  for  (  int  i  =  0  ;  i  <  header  .  length  ;  i++  )  {  hdrMap  .  put  (  header[i]  ,  Integer  .  valueOf  (  i  )  )  ;  }  }  }  return  hdrMap  ;  }    	None^175^^^^^169^193^
[ADD]    header    =    format    .    getHeader    (    )    ;    }  	[BUGGY]  [CE]  illegal  start  of  expression    [METHOD]    initializeHeader  [TYPE]  Map  [PARAMETER]  CSVFormat  format  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  boolean  false  true  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  rec  result  [TYPE]  CSVFormat  format  [TYPE]  String[]  header  [TYPE]  Map  hdrMap  headerMapping  [TYPE]  int  i    [CONTEXT]    private  Map<String  ,  Integer>  initializeHeader  (  CSVFormat  format  )  throws  IOException  {  Map<String  ,  Integer>  hdrMap  =  null  ;  if  (  format  .  getHeader  (  )  !  =  null  )  {  hdrMap  =  new  HashMap<String  ,  Integer>  (  )  ;    String[]  header  =  null  ;  if  (  format  .  getHeader  (  )  .  length  =  =  0  )  {    CSVRecord  rec  =  getRecord  (  )  ;  if  (  rec  !  =  null  )  {  header  =  rec  .  values  (  )  ;  }  }  else  {  [ATTENTION]      if  (  header  !  =  null  )  {  for  (  int  i  =  0  ;  i  <  header  .  length  ;  i++  )  {  hdrMap  .  put  (  header[i]  ,  Integer  .  valueOf  (  i  )  )  ;  }  }  }  return  hdrMap  ;  }    	None^182^183^^^^169^193^
[REPLACE]    if    (    rec    !=    null    )    {  	[BUGGY]  if  (  rec  =  =  null  )  {[FE]    (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    initializeHeader  [TYPE]  Map  [PARAMETER]  CSVFormat  format  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  boolean  false  true  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  rec  result  [TYPE]  CSVFormat  format  [TYPE]  String[]  header  [TYPE]  Map  hdrMap  headerMapping  [TYPE]  int  i    [CONTEXT]    private  Map<String  ,  Integer>  initializeHeader  (  CSVFormat  format  )  throws  IOException  {  Map<String  ,  Integer>  hdrMap  =  null  ;  if  (  format  .  getHeader  (  )  !  =  null  )  {  hdrMap  =  new  HashMap<String  ,  Integer>  (  )  ;    String[]  header  =  null  ;  if  (  format  .  getHeader  (  )  .  length  =  =  0  )  {    CSVRecord  rec  =  getRecord  (  )  ;  [ATTENTION]  if  (  rec  =  =  null  )  {  header  =  rec  .  values  (  )  ;  }  }  else  {  header  =  format  .  getHeader  (  )  ;  }    if  (  header  !  =  null  )  {  for  (  int  i  =  0  ;  i  <  header  .  length  ;  i++  )  {  hdrMap  .  put  (  header[i]  ,  Integer  .  valueOf  (  i  )  )  ;  }  }  }  return  hdrMap  ;  }    	None^178^^^^^169^193^
[REPLACE]    for    (    int    i    =    0;    i    <    header    .    length;    i++    )    {  	[BUGGY]  for  (  int  i  =  0  ;  i  <  header  .  length  *  0  .  5  ;  i++  )  {[FE]    (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    initializeHeader  [TYPE]  Map  [PARAMETER]  CSVFormat  format  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  boolean  false  true  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  rec  result  [TYPE]  CSVFormat  format  [TYPE]  String[]  header  [TYPE]  Map  hdrMap  headerMapping  [TYPE]  int  i    [CONTEXT]    private  Map<String  ,  Integer>  initializeHeader  (  CSVFormat  format  )  throws  IOException  {  Map<String  ,  Integer>  hdrMap  =  null  ;  if  (  format  .  getHeader  (  )  !  =  null  )  {  hdrMap  =  new  HashMap<String  ,  Integer>  (  )  ;    String[]  header  =  null  ;  if  (  format  .  getHeader  (  )  .  length  =  =  0  )  {    CSVRecord  rec  =  getRecord  (  )  ;  if  (  rec  !  =  null  )  {  header  =  rec  .  values  (  )  ;  }  }  else  {  header  =  format  .  getHeader  (  )  ;  }    if  (  header  !  =  null  )  {  [ATTENTION]  for  (  int  i  =  0  ;  i  <  header  .  length  *0  .  5  ;  i++  )  {  hdrMap  .  put  (  header[i]  ,  Integer  .  valueOf  (  i  )  )  ;  }  }  }  return  hdrMap  ;  }    	None^187^^^^^169^193^
[ADD]    hdrMap    .    put    (    header[i],    Integer    .    valueOf    (    i    )    )    ;  	[BUGGY]  [FE]    (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    initializeHeader  [TYPE]  Map  [PARAMETER]  CSVFormat  format  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  boolean  false  true  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  rec  result  [TYPE]  CSVFormat  format  [TYPE]  String[]  header  [TYPE]  Map  hdrMap  headerMapping  [TYPE]  int  i    [CONTEXT]    private  Map<String  ,  Integer>  initializeHeader  (  CSVFormat  format  )  throws  IOException  {  Map<String  ,  Integer>  hdrMap  =  null  ;  if  (  format  .  getHeader  (  )  !  =  null  )  {  hdrMap  =  new  HashMap<String  ,  Integer>  (  )  ;    String[]  header  =  null  ;  if  (  format  .  getHeader  (  )  .  length  =  =  0  )  {    CSVRecord  rec  =  getRecord  (  )  ;  if  (  rec  !  =  null  )  {  header  =  rec  .  values  (  )  ;  }  }  else  {  header  =  format  .  getHeader  (  )  ;  }    if  (  header  !  =  null  )  {  for  (  int  i  =  0  ;  i  <  header  .  length  ;  i++  )  {  [ATTENTION]  }  }  }  return  hdrMap  ;  }    	None^188^^^^^169^193^
[REPLACE]    for    (    int    i    =    0;    i    <    header    .    length;    i++    )    {  	[BUGGY]  for  (  int  i  =  0  ;  i  <  header  .  length  (  )  ;  i++  )  {[CE]  cannot  find  symbol    [METHOD]    initializeHeader  [TYPE]  Map  [PARAMETER]  CSVFormat  format  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  boolean  false  true  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  rec  result  [TYPE]  CSVFormat  format  [TYPE]  String[]  header  [TYPE]  Map  hdrMap  headerMapping  [TYPE]  int  i    [CONTEXT]    private  Map<String  ,  Integer>  initializeHeader  (  CSVFormat  format  )  throws  IOException  {  Map<String  ,  Integer>  hdrMap  =  null  ;  if  (  format  .  getHeader  (  )  !  =  null  )  {  hdrMap  =  new  HashMap<String  ,  Integer>  (  )  ;    String[]  header  =  null  ;  if  (  format  .  getHeader  (  )  .  length  =  =  0  )  {    CSVRecord  rec  =  getRecord  (  )  ;  if  (  rec  !  =  null  )  {  header  =  rec  .  values  (  )  ;  }  }  else  {  header  =  format  .  getHeader  (  )  ;  }    if  (  header  !  =  null  )  {  [ATTENTION]  for  (  int  i  =  0  ;  i  <  header  .  length  (  )    ;  i++  )  {  hdrMap  .  put  (  header[i]  ,  Integer  .  valueOf  (  i  )  )  ;  }  }  }  return  hdrMap  ;  }    	None^187^^^^^169^193^
[REMOVE]      	[BUGGY]  header  =  rec  .  values  (  )  ;  [CE]  cannot  find  symbol  rec    [METHOD]    initializeHeader  [TYPE]  Map  [PARAMETER]  CSVFormat  format  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  boolean  false  true  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  rec  result  [TYPE]  CSVFormat  format  [TYPE]  String[]  header  [TYPE]  Map  hdrMap  headerMapping  [TYPE]  int  i    [CONTEXT]    private  Map<String  ,  Integer>  initializeHeader  (  CSVFormat  format  )  throws  IOException  {  Map<String  ,  Integer>  hdrMap  =  null  ;  if  (  format  .  getHeader  (  )  !  =  null  )  {  hdrMap  =  new  HashMap<String  ,  Integer>  (  )  ;    String[]  header  =  null  ;  if  (  format  .  getHeader  (  )  .  length  =  =  0  )  {    CSVRecord  rec  =  getRecord  (  )  ;  if  (  rec  !  =  null  )  {  header  =  rec  .  values  (  )  ;  }  }  else  {  header  =  format  .  getHeader  (  )  ;  }    if  (  header  !  =  null  )  {  for  (  int  i  =  0  ;  i  <  header  .  length  ;  i++  )  {  [ATTENTION]  hdrMap  .  put  (  header[i]  ,  Integer  .  valueOf  (  i  )  )  ;    header  =  rec  .  values  (  )    ;  }  }  }  return  hdrMap  ;      	None^188^^^^^169^193^
[REPLACE]    hdrMap    =    new    HashMap<String,    Integer>    (    )    ;  	[BUGGY]  hdrMap    =  null  ;  [FE]    (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    initializeHeader  [TYPE]  Map  [PARAMETER]  CSVFormat  format  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  boolean  false  true  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  rec  result  [TYPE]  CSVFormat  format  [TYPE]  String[]  header  [TYPE]  Map  hdrMap  headerMapping  [TYPE]  int  i    [CONTEXT]    private  Map<String  ,  Integer>  initializeHeader  (  CSVFormat  format  )  throws  IOException  {  Map<String  ,  Integer>  hdrMap  =  null  ;  if  (  format  .  getHeader  (  )  !  =  null  )  {  [ATTENTION]  hdrMap  =  null  ;    String[]  header  =  null  ;  if  (  format  .  getHeader  (  )  .  length  =  =  0  )  {    CSVRecord  rec  =  getRecord  (  )  ;  if  (  rec  !  =  null  )  {  header  =  rec  .  values  (  )  ;  }  }  else  {  header  =  format  .  getHeader  (  )  ;  }    if  (  header  !  =  null  )  {  for  (  int  i  =  0  ;  i  <  header  .  length  ;  i++  )  {  hdrMap  .  put  (  header[i]  ,  Integer  .  valueOf  (  i  )  )  ;  }  }  }  return  hdrMap  ;  }    	None^172^^^^^169^193^
[REPLACE]    String[]    header    =    null;  	[BUGGY]  String[]  header  =  this  ;  [CE]  incompatible  types    [METHOD]    initializeHeader  [TYPE]  Map  [PARAMETER]  CSVFormat  format  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  boolean  false  true  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  rec  result  [TYPE]  CSVFormat  format  [TYPE]  String[]  header  [TYPE]  Map  hdrMap  headerMapping  [TYPE]  int  i    [CONTEXT]    private  Map<String  ,  Integer>  initializeHeader  (  CSVFormat  format  )  throws  IOException  {  Map<String  ,  Integer>  hdrMap  =  null  ;  if  (  format  .  getHeader  (  )  !  =  null  )  {  hdrMap  =  new  HashMap<String  ,  Integer>  (  )  ;    [ATTENTION]  String[]  header  =  this  ;  if  (  format  .  getHeader  (  )  .  length  =  =  0  )  {    CSVRecord  rec  =  getRecord  (  )  ;  if  (  rec  !  =  null  )  {  header  =  rec  .  values  (  )  ;  }  }  else  {  header  =  format  .  getHeader  (  )  ;  }    if  (  header  !  =  null  )  {  for  (  int  i  =  0  ;  i  <  header  .  length  ;  i++  )  {  hdrMap  .  put  (  header[i]  ,  Integer  .  valueOf  (  i  )  )  ;  }  }  }  return  hdrMap  ;  }    	None^174^^^^^169^193^
[REPLACE]    return    hdrMap;  	[BUGGY]  return  null  ;  [FE]    (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    initializeHeader  [TYPE]  Map  [PARAMETER]  CSVFormat  format  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  boolean  false  true  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  rec  result  [TYPE]  CSVFormat  format  [TYPE]  String[]  header  [TYPE]  Map  hdrMap  headerMapping  [TYPE]  int  i    [CONTEXT]    private  Map<String  ,  Integer>  initializeHeader  (  CSVFormat  format  )  throws  IOException  {  Map<String  ,  Integer>  hdrMap  =  null  ;  if  (  format  .  getHeader  (  )  !  =  null  )  {  hdrMap  =  new  HashMap<String  ,  Integer>  (  )  ;    String[]  header  =  null  ;  if  (  format  .  getHeader  (  )  .  length  =  =  0  )  {    CSVRecord  rec  =  getRecord  (  )  ;  if  (  rec  !  =  null  )  {  header  =  rec  .  values  (  )  ;  }  }  else  {  header  =  format  .  getHeader  (  )  ;  }    if  (  header  !  =  null  )  {  for  (  int  i  =  0  ;  i  <  header  .  length  ;  i++  )  {  hdrMap  .  put  (  header[i]  ,  Integer  .  valueOf  (  i  )  )  ;  }  }  }  [ATTENTION]  return  null  ;  }    	None^192^^^^^169^193^
[REPLACE]    if    (    current    ==    null    )    {  	[BUGGY]  if  (  current  !  =  this  )  {[CE]  incomparable  types:  CSVRecord  and  <anonymous  Iterator<CSVRecord>>    [METHOD]    iterator  [TYPE]  Iterator  [PARAMETER]  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  boolean  false  true  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  next  rec  result  [TYPE]  IOException  e  [TYPE]  Map  hdrMap  headerMapping    [CONTEXT]    public  Iterator<CSVRecord>  iterator  (  )  {  return  new  Iterator<CSVRecord>  (  )  {  private  CSVRecord  current  ;    public  boolean  hasNext  (  )  {  [ATTENTION]  if  (  current  !  =  this  )  {  current  =  getNextRecord  (  )  ;  }  return  current  !  =  null  ;  }  public  CSVRecord  next  (  )  {  CSVRecord  next  =  current  ;  current  =  null  ;    if  (  next  =  =  null  )  {    next  =  getNextRecord  (  )  ;  if  (  next  =  =  null  )  {  throw  new  NoSuchElementException  (     "No  more  CSV  records  available   "  )  ;  }  }  return  next  ;  }  private  CSVRecord  getNextRecord  (  )  {  try  {  return  getRecord  (  )  ;  }  catch  (  IOException  e  )  {  throw  new  RuntimeException  (  e  )  ;  }  }  public  void  remove  (  )  {  throw  new  UnsupportedOperationException  (  )  ;  }  }  ;  }    	None^204^^^^^199^238^
[ADD]    if    (    current    ==    null    )    {    current    =    getNextRecord    (    )    ;    }  	[BUGGY]  current  =  getNextRecord  (  )  ;  [FE]    (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    iterator  [TYPE]  Iterator  [PARAMETER]  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  boolean  false  true  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  next  rec  result  [TYPE]  IOException  e  [TYPE]  Map  hdrMap  headerMapping    [CONTEXT]    public  Iterator<CSVRecord>  iterator  (  )  {  return  new  Iterator<CSVRecord>  (  )  {  private  CSVRecord  current  ;    public  boolean  hasNext  (  )  {  [ATTENTION]  current  =  getNextRecord  (  )    ;      return  current  !  =  null  ;  }  public  CSVRecord  next  (  )  {  CSVRecord  next  =  current  ;  current  =  null  ;    if  (  next  =  =  null  )  {    next  =  getNextRecord  (  )  ;  if  (  next  =  =  null  )  {  throw  new  NoSuchElementException  (     "No  more  CSV  records  available   "  )  ;  }  }  return  next  ;  }  private  CSVRecord  getNextRecord  (  )  {  try  {  return  getRecord  (  )  ;  }  catch  (  IOException  e  )  {  throw  new  RuntimeException  (  e  )  ;  }  }  public  void  remove  (  )  {  throw  new  UnsupportedOperationException  (  )  ;  }  }  ;  }    	None^204^205^206^^^199^238^
[REPLACE]    current    =    getNextRecord    (    )    ;  	[BUGGY]  next  =  getNextRecord  (  )  ;    ;  [CE]  cannot  find  symbol  next    [METHOD]    iterator  [TYPE]  Iterator  [PARAMETER]  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  boolean  false  true  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  next  rec  result  [TYPE]  IOException  e  [TYPE]  Map  hdrMap  headerMapping    [CONTEXT]    public  Iterator<CSVRecord>  iterator  (  )  {  return  new  Iterator<CSVRecord>  (  )  {  private  CSVRecord  current  ;    public  boolean  hasNext  (  )  {  if  (  current  =  =  null  )  {  [ATTENTION]  next  =  getNextRecord  (  )    ;    ;  }  return  current  !  =  null  ;  }  public  CSVRecord  next  (  )  {  CSVRecord  next  =  current  ;  current  =  null  ;    if  (  next  =  =  null  )  {    next  =  getNextRecord  (  )  ;  if  (  next  =  =  null  )  {  throw  new  NoSuchElementException  (     "No  more  CSV  records  available   "  )  ;  }  }  return  next  ;  }  private  CSVRecord  getNextRecord  (  )  {  try  {  return  getRecord  (  )  ;  }  catch  (  IOException  e  )  {  throw  new  RuntimeException  (  e  )  ;  }  }  public  void  remove  (  )  {  throw  new  UnsupportedOperationException  (  )  ;  }  }  ;  }    	None^205^^^^^199^238^
[REPLACE]    if    (    next    ==    null    )    {  	[BUGGY]  if  (  next  !  =  null  )  {[FE]    (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    iterator  [TYPE]  Iterator  [PARAMETER]  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  boolean  false  true  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  next  rec  result  [TYPE]  IOException  e  [TYPE]  Map  hdrMap  headerMapping    [CONTEXT]    public  Iterator<CSVRecord>  iterator  (  )  {  return  new  Iterator<CSVRecord>  (  )  {  private  CSVRecord  current  ;    public  boolean  hasNext  (  )  {  if  (  current  =  =  null  )  {  current  =  getNextRecord  (  )  ;  }  return  current  !  =  null  ;  }  public  CSVRecord  next  (  )  {  CSVRecord  next  =  current  ;  current  =  null  ;    [ATTENTION]  if  (  next  !  =  null  )  {    next  =  getNextRecord  (  )  ;  if  (  next  =  =  null  )  {  throw  new  NoSuchElementException  (     "No  more  CSV  records  available   "  )  ;  }  }  return  next  ;  }  private  CSVRecord  getNextRecord  (  )  {  try  {  return  getRecord  (  )  ;  }  catch  (  IOException  e  )  {  throw  new  RuntimeException  (  e  )  ;  }  }  public  void  remove  (  )  {  throw  new  UnsupportedOperationException  (  )  ;  }  }  ;  }    	None^215^^^^^199^238^
[REPLACE]    if    (    next    ==    null    )    {  	[BUGGY]  if  (  next  !  =  null  )  {[FE]    (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    iterator  [TYPE]  Iterator  [PARAMETER]  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  boolean  false  true  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  next  rec  result  [TYPE]  IOException  e  [TYPE]  Map  hdrMap  headerMapping    [CONTEXT]    public  Iterator<CSVRecord>  iterator  (  )  {  return  new  Iterator<CSVRecord>  (  )  {  private  CSVRecord  current  ;    public  boolean  hasNext  (  )  {  if  (  current  =  =  null  )  {  current  =  getNextRecord  (  )  ;  }  return  current  !  =  null  ;  }  public  CSVRecord  next  (  )  {  CSVRecord  next  =  current  ;  current  =  null  ;    if  (  next  =  =  null  )  {    next  =  getNextRecord  (  )  ;  [ATTENTION]  if  (  next  !  =  null  )  {  throw  new  NoSuchElementException  (     "No  more  CSV  records  available   "  )  ;  }  }  return  next  ;  }  private  CSVRecord  getNextRecord  (  )  {  try  {  return  getRecord  (  )  ;  }  catch  (  IOException  e  )  {  throw  new  RuntimeException  (  e  )  ;  }  }  public  void  remove  (  )  {  throw  new  UnsupportedOperationException  (  )  ;  }  }  ;  }    	None^218^^^^^199^238^
[REPLACE]    throw    new    NoSuchElementException    (   "       ")    ;  	[BUGGY]  throw  new  UnsupportedOperationException  (   "     ")    ;    ;  [CE]  unreachable  statement    [METHOD]    iterator  [TYPE]  Iterator  [PARAMETER]  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  boolean  false  true  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  next  rec  result  [TYPE]  IOException  e  [TYPE]  Map  hdrMap  headerMapping    [CONTEXT]    public  Iterator<CSVRecord>  iterator  (  )  {  return  new  Iterator<CSVRecord>  (  )  {  private  CSVRecord  current  ;    public  boolean  hasNext  (  )  {  if  (  current  =  =  null  )  {  current  =  getNextRecord  (  )  ;  }  return  current  !  =  null  ;  }  public  CSVRecord  next  (  )  {  CSVRecord  next  =  current  ;  current  =  null  ;    if  (  next  =  =  null  )  {    next  =  getNextRecord  (  )  ;  if  (  next  =  =  null  )  {  [ATTENTION]  throw  new  UnsupportedOperationException  (     "     "  )  ;    ;  }  }  return  next  ;  }  private  CSVRecord  getNextRecord  (  )  {  try  {  return  getRecord  (  )  ;  }  catch  (  IOException  e  )  {  throw  new  RuntimeException  (  e  )  ;  }  }  public  void  remove  (  )  {  throw  new  UnsupportedOperationException  (  )  ;  }  }  ;  }    	None^219^^^^^199^238^
[REPLACE]    next    =    getNextRecord    (    )    ;  	[BUGGY]  current  =  getNextRecord  (  )  ;    ;  [FE]    (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    iterator  [TYPE]  Iterator  [PARAMETER]  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  boolean  false  true  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  next  rec  result  [TYPE]  IOException  e  [TYPE]  Map  hdrMap  headerMapping    [CONTEXT]    public  Iterator<CSVRecord>  iterator  (  )  {  return  new  Iterator<CSVRecord>  (  )  {  private  CSVRecord  current  ;    public  boolean  hasNext  (  )  {  if  (  current  =  =  null  )  {  current  =  getNextRecord  (  )  ;  }  return  current  !  =  null  ;  }  public  CSVRecord  next  (  )  {  CSVRecord  next  =  current  ;  current  =  null  ;    if  (  next  =  =  null  )  {    [ATTENTION]  current  =  getNextRecord  (  )    ;    ;  if  (  next  =  =  null  )  {  throw  new  NoSuchElementException  (     "No  more  CSV  records  available   "  )  ;  }  }  return  next  ;  }  private  CSVRecord  getNextRecord  (  )  {  try  {  return  getRecord  (  )  ;  }  catch  (  IOException  e  )  {  throw  new  RuntimeException  (  e  )  ;  }  }  public  void  remove  (  )  {  throw  new  UnsupportedOperationException  (  )  ;  }  }  ;  }    	None^217^^^^^199^238^
[REPLACE]    if    (    next    ==    null    )    {  	[BUGGY]  if  (  result  !  =  false  )  {[CE]  cannot  find  symbol  result    [METHOD]    iterator  [TYPE]  Iterator  [PARAMETER]  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  boolean  false  true  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  next  rec  result  [TYPE]  IOException  e  [TYPE]  Map  hdrMap  headerMapping    [CONTEXT]    public  Iterator<CSVRecord>  iterator  (  )  {  return  new  Iterator<CSVRecord>  (  )  {  private  CSVRecord  current  ;    public  boolean  hasNext  (  )  {  if  (  current  =  =  null  )  {  current  =  getNextRecord  (  )  ;  }  return  current  !  =  null  ;  }  public  CSVRecord  next  (  )  {  CSVRecord  next  =  current  ;  current  =  null  ;    if  (  next  =  =  null  )  {    next  =  getNextRecord  (  )  ;  [ATTENTION]  if  (  result  !  =  false  )  {  throw  new  NoSuchElementException  (     "No  more  CSV  records  available   "  )  ;  }  }  return  next  ;  }  private  CSVRecord  getNextRecord  (  )  {  try  {  return  getRecord  (  )  ;  }  catch  (  IOException  e  )  {  throw  new  RuntimeException  (  e  )  ;  }  }  public  void  remove  (  )  {  throw  new  UnsupportedOperationException  (  )  ;  }  }  ;  }    	None^218^^^^^199^238^
[REPLACE]    throw    new    NoSuchElementException    (   "       ")    ;  	[BUGGY]  return  ;  [CE]  missing  return  value    [METHOD]    iterator  [TYPE]  Iterator  [PARAMETER]  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  boolean  false  true  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  next  rec  result  [TYPE]  IOException  e  [TYPE]  Map  hdrMap  headerMapping    [CONTEXT]    public  Iterator<CSVRecord>  iterator  (  )  {  return  new  Iterator<CSVRecord>  (  )  {  private  CSVRecord  current  ;    public  boolean  hasNext  (  )  {  if  (  current  =  =  null  )  {  current  =  getNextRecord  (  )  ;  }  return  current  !  =  null  ;  }  public  CSVRecord  next  (  )  {  CSVRecord  next  =  current  ;  current  =  null  ;    if  (  next  =  =  null  )  {    next  =  getNextRecord  (  )  ;  if  (  next  =  =  null  )  {  [ATTENTION]  return  ;  }  }  return  next  ;  }  private  CSVRecord  getNextRecord  (  )  {  try  {  return  getRecord  (  )  ;  }  catch  (  IOException  e  )  {  throw  new  RuntimeException  (  e  )  ;  }  }  public  void  remove  (  )  {  throw  new  UnsupportedOperationException  (  )  ;  }  }  ;  }    	None^219^^^^^199^238^
[ADD]    try    {    return    getRecord    (    )    ;    }    catch    (    IOException    e    )    {    throw    new    RuntimeException    (   "       ")    ;    }  	[BUGGY]  return  getRecord  (  )  ;  [CE]  unreported  exception  IOException  ;  must  be  caught  or  declared  to  be  thrown    [METHOD]    iterator  [TYPE]  Iterator  [PARAMETER]  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  boolean  false  true  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  next  rec  result  [TYPE]  IOException  e  [TYPE]  Map  hdrMap  headerMapping    [CONTEXT]    public  Iterator<CSVRecord>  iterator  (  )  {  return  new  Iterator<CSVRecord>  (  )  {  private  CSVRecord  current  ;    public  boolean  hasNext  (  )  {  if  (  current  =  =  null  )  {  current  =  getNextRecord  (  )  ;  }  return  current  !  =  null  ;  }  public  CSVRecord  next  (  )  {  CSVRecord  next  =  current  ;  current  =  null  ;    if  (  next  =  =  null  )  {    next  =  getNextRecord  (  )  ;  if  (  next  =  =  null  )  {  throw  new  NoSuchElementException  (     "No  more  CSV  records  available   "  )  ;  }  }  return  next  ;  }  private  CSVRecord  getNextRecord  (  )  {  [ATTENTION]  return  getRecord  (  )    ;      }  public  void  remove  (  )  {  throw  new  UnsupportedOperationException  (  )  ;  }  }  ;  }    	None^227^228^229^230^231^199^238^
[REPLACE]    return    getRecord    (    )    ;  	[BUGGY]  return  lexer  .  getLineNumber  (  )  ;  [CE]  incompatible  types    [METHOD]    iterator  [TYPE]  Iterator  [PARAMETER]  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  boolean  false  true  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  next  rec  result  [TYPE]  IOException  e  [TYPE]  Map  hdrMap  headerMapping    [CONTEXT]    public  Iterator<CSVRecord>  iterator  (  )  {  return  new  Iterator<CSVRecord>  (  )  {  private  CSVRecord  current  ;    public  boolean  hasNext  (  )  {  if  (  current  =  =  null  )  {  current  =  getNextRecord  (  )  ;  }  return  current  !  =  null  ;  }  public  CSVRecord  next  (  )  {  CSVRecord  next  =  current  ;  current  =  null  ;    if  (  next  =  =  null  )  {    next  =  getNextRecord  (  )  ;  if  (  next  =  =  null  )  {  throw  new  NoSuchElementException  (     "No  more  CSV  records  available   "  )  ;  }  }  return  next  ;  }  private  CSVRecord  getNextRecord  (  )  {  try  {  [ATTENTION]  return  lexer  .  getLineNumber  (  )    ;  }  catch  (  IOException  e  )  {  throw  new  RuntimeException  (  e  )  ;  }  }  public  void  remove  (  )  {  throw  new  UnsupportedOperationException  (  )  ;  }  }  ;  }    	None^228^^^^^199^238^
[REPLACE]    current    =    null;  	[BUGGY]  current  =  false  ;  [CE]  incompatible  types    [METHOD]    iterator  [TYPE]  Iterator  [PARAMETER]  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  boolean  false  true  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  next  rec  result  [TYPE]  IOException  e  [TYPE]  Map  hdrMap  headerMapping    [CONTEXT]    public  Iterator<CSVRecord>  iterator  (  )  {  return  new  Iterator<CSVRecord>  (  )  {  private  CSVRecord  current  ;    public  boolean  hasNext  (  )  {  if  (  current  =  =  null  )  {  current  =  getNextRecord  (  )  ;  }  return  current  !  =  null  ;  }  public  CSVRecord  next  (  )  {  CSVRecord  next  =  current  ;  [ATTENTION]  current  =  false  ;    if  (  next  =  =  null  )  {    next  =  getNextRecord  (  )  ;  if  (  next  =  =  null  )  {  throw  new  NoSuchElementException  (     "No  more  CSV  records  available   "  )  ;  }  }  return  next  ;  }  private  CSVRecord  getNextRecord  (  )  {  try  {  return  getRecord  (  )  ;  }  catch  (  IOException  e  )  {  throw  new  RuntimeException  (  e  )  ;  }  }  public  void  remove  (  )  {  throw  new  UnsupportedOperationException  (  )  ;  }  }  ;  }    	None^213^^^^^199^238^
[ADD]    next    =    getNextRecord    (    )    ;  	[BUGGY]  [FE]    (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    iterator  [TYPE]  Iterator  [PARAMETER]  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  boolean  false  true  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  next  rec  result  [TYPE]  IOException  e  [TYPE]  Map  hdrMap  headerMapping    [CONTEXT]    public  Iterator<CSVRecord>  iterator  (  )  {  return  new  Iterator<CSVRecord>  (  )  {  private  CSVRecord  current  ;    public  boolean  hasNext  (  )  {  if  (  current  =  =  null  )  {  current  =  getNextRecord  (  )  ;  }  return  current  !  =  null  ;  }  public  CSVRecord  next  (  )  {  CSVRecord  next  =  current  ;  current  =  null  ;    if  (  next  =  =  null  )  {    [ATTENTION]  if  (  next  =  =  null  )  {  throw  new  NoSuchElementException  (     "No  more  CSV  records  available   "  )  ;  }  }  return  next  ;  }  private  CSVRecord  getNextRecord  (  )  {  try  {  return  getRecord  (  )  ;  }  catch  (  IOException  e  )  {  throw  new  RuntimeException  (  e  )  ;  }  }  public  void  remove  (  )  {  throw  new  UnsupportedOperationException  (  )  ;  }  }  ;  }    	None^217^^^^^199^238^
[REPLACE]    return    new    Iterator<CSVRecord>    (    )    {  	[BUGGY]  return  false  ;  [CE]  illegal  start  of  expression    [METHOD]    iterator  [TYPE]  Iterator  [PARAMETER]  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  boolean  false  true  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  next  rec  result  [TYPE]  IOException  e  [TYPE]  Map  hdrMap  headerMapping    [CONTEXT]    public  Iterator<CSVRecord>  iterator  (  )  {  [ATTENTION]  return  false  ;  private  CSVRecord  current  ;    public  boolean  hasNext  (  )  {  if  (  current  =  =  null  )  {  current  =  getNextRecord  (  )  ;  }  return  current  !  =  null  ;  }  public  CSVRecord  next  (  )  {  CSVRecord  next  =  current  ;  current  =  null  ;    if  (  next  =  =  null  )  {    next  =  getNextRecord  (  )  ;  if  (  next  =  =  null  )  {  throw  new  NoSuchElementException  (     "No  more  CSV  records  available   "  )  ;  }  }  return  next  ;  }  private  CSVRecord  getNextRecord  (  )  {  try  {  return  getRecord  (  )  ;  }  catch  (  IOException  e  )  {  throw  new  RuntimeException  (  e  )  ;  }  }  public  void  remove  (  )  {  throw  new  UnsupportedOperationException  (  )  ;  }  }  ;  }    	None^200^^^^^199^238^
[REPLACE]    return    current    !=    null;  	[BUGGY]  return  false  ;  [FE]    (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    iterator  [TYPE]  Iterator  [PARAMETER]  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  boolean  false  true  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  next  rec  result  [TYPE]  IOException  e  [TYPE]  Map  hdrMap  headerMapping    [CONTEXT]    public  Iterator<CSVRecord>  iterator  (  )  {  return  new  Iterator<CSVRecord>  (  )  {  private  CSVRecord  current  ;    public  boolean  hasNext  (  )  {  if  (  current  =  =  null  )  {  current  =  getNextRecord  (  )  ;  }  [ATTENTION]  return  false  ;  }  public  CSVRecord  next  (  )  {  CSVRecord  next  =  current  ;  current  =  null  ;    if  (  next  =  =  null  )  {    next  =  getNextRecord  (  )  ;  if  (  next  =  =  null  )  {  throw  new  NoSuchElementException  (     "No  more  CSV  records  available   "  )  ;  }  }  return  next  ;  }  private  CSVRecord  getNextRecord  (  )  {  try  {  return  getRecord  (  )  ;  }  catch  (  IOException  e  )  {  throw  new  RuntimeException  (  e  )  ;  }  }  public  void  remove  (  )  {  throw  new  UnsupportedOperationException  (  )  ;  }  }  ;  }    	None^208^^^^^199^238^
[REPLACE]    return    next;  	[BUGGY]  return  result  ;  [CE]  cannot  find  symbol  result    [METHOD]    iterator  [TYPE]  Iterator  [PARAMETER]  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  boolean  false  true  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  next  rec  result  [TYPE]  IOException  e  [TYPE]  Map  hdrMap  headerMapping    [CONTEXT]    public  Iterator<CSVRecord>  iterator  (  )  {  return  new  Iterator<CSVRecord>  (  )  {  private  CSVRecord  current  ;    public  boolean  hasNext  (  )  {  if  (  current  =  =  null  )  {  current  =  getNextRecord  (  )  ;  }  return  current  !  =  null  ;  }  public  CSVRecord  next  (  )  {  CSVRecord  next  =  current  ;  current  =  null  ;    if  (  next  =  =  null  )  {    next  =  getNextRecord  (  )  ;  if  (  next  =  =  null  )  {  throw  new  NoSuchElementException  (     "No  more  CSV  records  available   "  )  ;  }  }  [ATTENTION]  return  result  ;  }  private  CSVRecord  getNextRecord  (  )  {  try  {  return  getRecord  (  )  ;  }  catch  (  IOException  e  )  {  throw  new  RuntimeException  (  e  )  ;  }  }  public  void  remove  (  )  {  throw  new  UnsupportedOperationException  (  )  ;  }  }  ;  }    	None^223^^^^^199^238^
[REPLACE]    CSVRecord    next    =    current;  	[BUGGY]  CSVRecord  result  =  new  CSVRecord  (  null  ,  headerMapping  )  ;  [CE]  cannot  find  symbol  next    [METHOD]    iterator  [TYPE]  Iterator  [PARAMETER]  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  boolean  false  true  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  next  rec  result  [TYPE]  IOException  e  [TYPE]  Map  hdrMap  headerMapping    [CONTEXT]    public  Iterator<CSVRecord>  iterator  (  )  {  return  new  Iterator<CSVRecord>  (  )  {  private  CSVRecord  current  ;    public  boolean  hasNext  (  )  {  if  (  current  =  =  null  )  {  current  =  getNextRecord  (  )  ;  }  return  current  !  =  null  ;  }  public  CSVRecord  next  (  )  {  [ATTENTION]  CSVRecord  result  =  new  CSVRecord  (  null  ,  headerMapping  )    ;  current  =  null  ;    if  (  next  =  =  null  )  {    next  =  getNextRecord  (  )  ;  if  (  next  =  =  null  )  {  throw  new  NoSuchElementException  (     "No  more  CSV  records  available   "  )  ;  }  }  return  next  ;  }  private  CSVRecord  getNextRecord  (  )  {  try  {  return  getRecord  (  )  ;  }  catch  (  IOException  e  )  {  throw  new  RuntimeException  (  e  )  ;  }  }  public  void  remove  (  )  {  throw  new  UnsupportedOperationException  (  )  ;  }  }  ;  }    	None^212^^^^^199^238^
[ADD]    CSVRecord    next    =    current;  	[BUGGY]  [CE]  cannot  find  symbol  next    [METHOD]    iterator  [TYPE]  Iterator  [PARAMETER]  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  boolean  false  true  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  next  rec  result  [TYPE]  IOException  e  [TYPE]  Map  hdrMap  headerMapping    [CONTEXT]    public  Iterator<CSVRecord>  iterator  (  )  {  return  new  Iterator<CSVRecord>  (  )  {  private  CSVRecord  current  ;    public  boolean  hasNext  (  )  {  if  (  current  =  =  null  )  {  current  =  getNextRecord  (  )  ;  }  return  current  !  =  null  ;  }  public  CSVRecord  next  (  )  {  [ATTENTION]  current  =  null  ;    if  (  next  =  =  null  )  {    next  =  getNextRecord  (  )  ;  if  (  next  =  =  null  )  {  throw  new  NoSuchElementException  (     "No  more  CSV  records  available   "  )  ;  }  }  return  next  ;  }  private  CSVRecord  getNextRecord  (  )  {  try  {  return  getRecord  (  )  ;  }  catch  (  IOException  e  )  {  throw  new  RuntimeException  (  e  )  ;  }  }  public  void  remove  (  )  {  throw  new  UnsupportedOperationException  (  )  ;  }  }  ;  }    	None^212^^^^^199^238^
[REPLACE]    throw    new    RuntimeException    (   "       ")    ;  	[BUGGY]  throw  new  UnsupportedOperationException  (   "     ")    ;    ;  [CE]  unreachable  statement    [METHOD]    iterator  [TYPE]  Iterator  [PARAMETER]  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  boolean  false  true  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  next  rec  result  [TYPE]  IOException  e  [TYPE]  Map  hdrMap  headerMapping    [CONTEXT]    public  Iterator<CSVRecord>  iterator  (  )  {  return  new  Iterator<CSVRecord>  (  )  {  private  CSVRecord  current  ;    public  boolean  hasNext  (  )  {  if  (  current  =  =  null  )  {  current  =  getNextRecord  (  )  ;  }  return  current  !  =  null  ;  }  public  CSVRecord  next  (  )  {  CSVRecord  next  =  current  ;  current  =  null  ;    if  (  next  =  =  null  )  {    next  =  getNextRecord  (  )  ;  if  (  next  =  =  null  )  {  throw  new  NoSuchElementException  (     "No  more  CSV  records  available   "  )  ;  }  }  return  next  ;  }  private  CSVRecord  getNextRecord  (  )  {  try  {  return  getRecord  (  )  ;  }  catch  (  IOException  e  )  {  [ATTENTION]  throw  new  UnsupportedOperationException  (     "     "  )  ;    ;  }  }  public  void  remove  (  )  {  throw  new  UnsupportedOperationException  (  )  ;  }  }  ;  }    	None^230^^^^^199^238^
[REPLACE]    throw    new    UnsupportedOperationException    (   "       ")    ;  	[BUGGY]  return  ;  [FE]    (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    iterator  [TYPE]  Iterator  [PARAMETER]  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  boolean  false  true  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  next  rec  result  [TYPE]  IOException  e  [TYPE]  Map  hdrMap  headerMapping    [CONTEXT]    public  Iterator<CSVRecord>  iterator  (  )  {  return  new  Iterator<CSVRecord>  (  )  {  private  CSVRecord  current  ;    public  boolean  hasNext  (  )  {  if  (  current  =  =  null  )  {  current  =  getNextRecord  (  )  ;  }  return  current  !  =  null  ;  }  public  CSVRecord  next  (  )  {  CSVRecord  next  =  current  ;  current  =  null  ;    if  (  next  =  =  null  )  {    next  =  getNextRecord  (  )  ;  if  (  next  =  =  null  )  {  throw  new  NoSuchElementException  (     "No  more  CSV  records  available   "  )  ;  }  }  return  next  ;  }  private  CSVRecord  getNextRecord  (  )  {  try  {  return  getRecord  (  )  ;  }  catch  (  IOException  e  )  {  throw  new  RuntimeException  (  e  )  ;  }  }  public  void  remove  (  )  {  [ATTENTION]  return  ;  }  }  ;  }    	None^235^^^^^199^238^
[REPLACE]    if    (    current    ==    null    )    {  	[BUGGY]  if  (result  !  =  null  )  {[CE]  cannot  find  symbol  result    [METHOD]    hasNext  [TYPE]  boolean  [PARAMETER]  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  next  rec  result  [TYPE]  boolean  false  true  [TYPE]  Map  hdrMap  headerMapping    [CONTEXT]    public  boolean  hasNext  (  )  {  [ATTENTION]  if  (  result  !  =  null  )  {  current  =  getNextRecord  (  )  ;  }  return  current  !  =  null  ;  }    	None^204^^^^^203^209^
[REPLACE]    current    =    getNextRecord    (    )    ;  	[BUGGY]  next  =  getNextRecord  (  )  ;    ;  [CE]  cannot  find  symbol  next    [METHOD]    hasNext  [TYPE]  boolean  [PARAMETER]  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  next  rec  result  [TYPE]  boolean  false  true  [TYPE]  Map  hdrMap  headerMapping    [CONTEXT]    public  boolean  hasNext  (  )  {  if  (  current  =  =  null  )  {  [ATTENTION]  next  =  getNextRecord  (  )    ;    ;  }  return  current  !  =  null  ;  }    	None^205^^^^^203^209^
[ADD]    current    =    getNextRecord    (    )    ;  	[BUGGY]  [FE]    (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    hasNext  [TYPE]  boolean  [PARAMETER]  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  next  rec  result  [TYPE]  boolean  false  true  [TYPE]  Map  hdrMap  headerMapping    [CONTEXT]    public  boolean  hasNext  (  )  {  if  (  current  =  =  null  )  {  [ATTENTION]  }  return  current  !  =  null  ;  }    	None^205^^^^^203^209^
[REPLACE]    return    current    !=    null;  	[BUGGY]  returnresult  ;  [CE]  not  a  statement    [METHOD]    hasNext  [TYPE]  boolean  [PARAMETER]  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  next  rec  result  [TYPE]  boolean  false  true  [TYPE]  Map  hdrMap  headerMapping    [CONTEXT]    public  boolean  hasNext  (  )  {  if  (  current  =  =  null  )  {  current  =  getNextRecord  (  )  ;  }  [ATTENTION]  returnresult  ;  }    	None^208^^^^^203^209^
[REPLACE]    CSVRecord    next    =    current;  	[BUGGY]  CSVRecord  result  =  new  CSVRecord  (  null  ,  headerMapping  )  ;  [CE]  cannot  find  symbol  next    [METHOD]    next  [TYPE]  CSVRecord  [PARAMETER]  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  next  rec  result  [TYPE]  boolean  false  true  [TYPE]  Map  hdrMap  headerMapping    [CONTEXT]    public  CSVRecord  next  (  )  {  [ATTENTION]  CSVRecord  result  =  new  CSVRecord  (  null  ,  headerMapping  )    ;  current  =  null  ;    if  (  next  =  =  null  )  {    next  =  getNextRecord  (  )  ;  if  (  next  =  =  null  )  {  throw  new  NoSuchElementException  (     "No  more  CSV  records  available   "  )  ;  }  }  return  next  ;  }    	None^212^^^^^211^224^
[REPLACE]    current    =    null;  	[BUGGY]  current  =  false  ;  [CE]  incompatible  types    [METHOD]    next  [TYPE]  CSVRecord  [PARAMETER]  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  next  rec  result  [TYPE]  boolean  false  true  [TYPE]  Map  hdrMap  headerMapping    [CONTEXT]    public  CSVRecord  next  (  )  {  CSVRecord  next  =  current  ;  [ATTENTION]  current  =  false  ;    if  (  next  =  =  null  )  {    next  =  getNextRecord  (  )  ;  if  (  next  =  =  null  )  {  throw  new  NoSuchElementException  (     "No  more  CSV  records  available   "  )  ;  }  }  return  next  ;  }    	None^213^^^^^211^224^
[ADD]    current    =    null;  	[BUGGY]  [FE]    (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    next  [TYPE]  CSVRecord  [PARAMETER]  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  next  rec  result  [TYPE]  boolean  false  true  [TYPE]  Map  hdrMap  headerMapping    [CONTEXT]    public  CSVRecord  next  (  )  {  CSVRecord  next  =  current  ;  [ATTENTION]    if  (  next  =  =  null  )  {    next  =  getNextRecord  (  )  ;  if  (  next  =  =  null  )  {  throw  new  NoSuchElementException  (     "No  more  CSV  records  available   "  )  ;  }  }  return  next  ;  }    	None^213^^^^^211^224^
[REPLACE]    if    (    next    ==    null    )    {  	[BUGGY]  if  (  next  !  =  result  )  {[CE]  cannot  find  symbol  result    [METHOD]    next  [TYPE]  CSVRecord  [PARAMETER]  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  next  rec  result  [TYPE]  boolean  false  true  [TYPE]  Map  hdrMap  headerMapping    [CONTEXT]    public  CSVRecord  next  (  )  {  CSVRecord  next  =  current  ;  current  =  null  ;    [ATTENTION]  if  (  next  !  =  result  )  {    next  =  getNextRecord  (  )  ;  if  (  next  =  =  null  )  {  throw  new  NoSuchElementException  (     "No  more  CSV  records  available   "  )  ;  }  }  return  next  ;  }    	None^215^^^^^211^224^
[REPLACE]    if    (    next    ==    null    )    {  	[BUGGY]  if  (  next  !  =  true  )  {[CE]  incomparable  types:  CSVRecord  and  boolean    [METHOD]    next  [TYPE]  CSVRecord  [PARAMETER]  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  next  rec  result  [TYPE]  boolean  false  true  [TYPE]  Map  hdrMap  headerMapping    [CONTEXT]    public  CSVRecord  next  (  )  {  CSVRecord  next  =  current  ;  current  =  null  ;    if  (  next  =  =  null  )  {    next  =  getNextRecord  (  )  ;  [ATTENTION]  if  (  next  !  =  true  )  {  throw  new  NoSuchElementException  (     "No  more  CSV  records  available   "  )  ;  }  }  return  next  ;  }    	None^218^^^^^211^224^
[REPLACE]    throw    new    NoSuchElementException    (   "       ")    ;  	[BUGGY]  return  ;  [CE]  missing  return  value    [METHOD]    next  [TYPE]  CSVRecord  [PARAMETER]  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  next  rec  result  [TYPE]  boolean  false  true  [TYPE]  Map  hdrMap  headerMapping    [CONTEXT]    public  CSVRecord  next  (  )  {  CSVRecord  next  =  current  ;  current  =  null  ;    if  (  next  =  =  null  )  {    next  =  getNextRecord  (  )  ;  if  (  next  =  =  null  )  {  [ATTENTION]  return  ;  }  }  return  next  ;  }    	None^219^^^^^211^224^
[REPLACE]    next    =    getNextRecord    (    )    ;  	[BUGGY]  current  =  getNextRecord  (  )  ;    ;  [FE]    (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    next  [TYPE]  CSVRecord  [PARAMETER]  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  next  rec  result  [TYPE]  boolean  false  true  [TYPE]  Map  hdrMap  headerMapping    [CONTEXT]    public  CSVRecord  next  (  )  {  CSVRecord  next  =  current  ;  current  =  null  ;    if  (  next  =  =  null  )  {    [ATTENTION]  current  =  getNextRecord  (  )    ;    ;  if  (  next  =  =  null  )  {  throw  new  NoSuchElementException  (     "No  more  CSV  records  available   "  )  ;  }  }  return  next  ;  }    	None^217^^^^^211^224^
[ADD]    next    =    getNextRecord    (    )    ;  	[BUGGY]  [FE]    (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    next  [TYPE]  CSVRecord  [PARAMETER]  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  next  rec  result  [TYPE]  boolean  false  true  [TYPE]  Map  hdrMap  headerMapping    [CONTEXT]    public  CSVRecord  next  (  )  {  CSVRecord  next  =  current  ;  current  =  null  ;    if  (  next  =  =  null  )  {    [ATTENTION]  if  (  next  =  =  null  )  {  throw  new  NoSuchElementException  (     "No  more  CSV  records  available   "  )  ;  }  }  return  next  ;  }    	None^217^^^^^211^224^
[REPLACE]    throw    new    NoSuchElementException    (   "       ")    ;  	[BUGGY]  throw  new  UnsupportedOperationException  (   "     ")    ;    ;  [CE]  unreachable  statement    [METHOD]    next  [TYPE]  CSVRecord  [PARAMETER]  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  next  rec  result  [TYPE]  boolean  false  true  [TYPE]  Map  hdrMap  headerMapping    [CONTEXT]    public  CSVRecord  next  (  )  {  CSVRecord  next  =  current  ;  current  =  null  ;    if  (  next  =  =  null  )  {    next  =  getNextRecord  (  )  ;  if  (  next  =  =  null  )  {  [ATTENTION]  throw  new  UnsupportedOperationException  (     "     "  )  ;    ;  }  }  return  next  ;  }    	None^219^^^^^211^224^
[REPLACE]    if    (    next    ==    null    )    {  	[BUGGY]  if  (  next  !  =  null  )  {[FE]    (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    next  [TYPE]  CSVRecord  [PARAMETER]  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  next  rec  result  [TYPE]  boolean  false  true  [TYPE]  Map  hdrMap  headerMapping    [CONTEXT]    public  CSVRecord  next  (  )  {  CSVRecord  next  =  current  ;  current  =  null  ;    if  (  next  =  =  null  )  {    next  =  getNextRecord  (  )  ;  [ATTENTION]  if  (  next  !  =  null  )  {  throw  new  NoSuchElementException  (     "No  more  CSV  records  available   "  )  ;  }  }  return  next  ;  }    	None^218^^^^^211^224^
[ADD]    if    (    next    ==    null    )    {    throw    new    NoSuchElementException    (   "       ")    ;    }  	[BUGGY]  [FE]    (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    next  [TYPE]  CSVRecord  [PARAMETER]  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  next  rec  result  [TYPE]  boolean  false  true  [TYPE]  Map  hdrMap  headerMapping    [CONTEXT]    public  CSVRecord  next  (  )  {  CSVRecord  next  =  current  ;  current  =  null  ;    if  (  next  =  =  null  )  {    next  =  getNextRecord  (  )  ;  [ATTENTION]    }  return  next  ;  }    	None^218^219^220^^^211^224^
[ADD]    throw    new    NoSuchElementException    (   "       ")    ;  	[BUGGY]  [FE]    (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    next  [TYPE]  CSVRecord  [PARAMETER]  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  next  rec  result  [TYPE]  boolean  false  true  [TYPE]  Map  hdrMap  headerMapping    [CONTEXT]    public  CSVRecord  next  (  )  {  CSVRecord  next  =  current  ;  current  =  null  ;    if  (  next  =  =  null  )  {    next  =  getNextRecord  (  )  ;  if  (  next  =  =  null  )  {  [ATTENTION]  }  }  return  next  ;  }    	None^219^^^^^211^224^
[REPLACE]    return    next;  	[BUGGY]  return  result  ;  [CE]  cannot  find  symbol  result    [METHOD]    next  [TYPE]  CSVRecord  [PARAMETER]  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  next  rec  result  [TYPE]  boolean  false  true  [TYPE]  Map  hdrMap  headerMapping    [CONTEXT]    public  CSVRecord  next  (  )  {  CSVRecord  next  =  current  ;  current  =  null  ;    if  (  next  =  =  null  )  {    next  =  getNextRecord  (  )  ;  if  (  next  =  =  null  )  {  throw  new  NoSuchElementException  (     "No  more  CSV  records  available   "  )  ;  }  }  [ATTENTION]  return  result  ;  }    	None^223^^^^^211^224^
[ADD]    try    {    return    getRecord    (    )    ;    }    catch    (    IOException    e    )    {    throw    new    RuntimeException    (   "       ")    ;    }  	[BUGGY]  return  getRecord  (  )  ;  [CE]  unreported  exception  IOException  ;  must  be  caught  or  declared  to  be  thrown    [METHOD]    getNextRecord  [TYPE]  CSVRecord  [PARAMETER]  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  boolean  false  true  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  next  rec  result  [TYPE]  IOException  e  [TYPE]  Map  hdrMap  headerMapping    [CONTEXT]    private  CSVRecord  getNextRecord  (  )  {  [ATTENTION]  return  getRecord  (  )    ;      }    	None^227^228^229^230^231^226^232^
[REPLACE]    return    getRecord    (    )    ;  	[BUGGY]  return  lexer  .  getLineNumber  (  )  ;  [CE]  incompatible  types    [METHOD]    getNextRecord  [TYPE]  CSVRecord  [PARAMETER]  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  boolean  false  true  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  next  rec  result  [TYPE]  IOException  e  [TYPE]  Map  hdrMap  headerMapping    [CONTEXT]    private  CSVRecord  getNextRecord  (  )  {  try  {  [ATTENTION]  return  lexer  .  getLineNumber  (  )    ;  }  catch  (  IOException  e  )  {  throw  new  RuntimeException  (  e  )  ;  }  }    	None^228^^^^^226^232^
[REPLACE]    throw    new    RuntimeException    (   "       ")    ;  	[BUGGY]  return  ;  [CE]  missing  return  value    [METHOD]    getNextRecord  [TYPE]  CSVRecord  [PARAMETER]  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  boolean  false  true  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  next  rec  result  [TYPE]  IOException  e  [TYPE]  Map  hdrMap  headerMapping    [CONTEXT]    private  CSVRecord  getNextRecord  (  )  {  try  {  return  getRecord  (  )  ;  }  catch  (  IOException  e  )  {  [ATTENTION]  return  ;  }  }    	None^230^^^^^226^232^
[REPLACE]    throw    new    UnsupportedOperationException    (   "       ")    ;  	[BUGGY]  throw  new  RuntimeException  (   "     ")    ;    ;  [CE]  unreachable  statement    [METHOD]    remove  [TYPE]  void  [PARAMETER]  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  next  rec  result  [TYPE]  boolean  false  true  [TYPE]  Map  hdrMap  headerMapping    [CONTEXT]    public  void  remove  (  )  {  [ATTENTION]  throw  new  RuntimeException  (     "     "  )  ;    ;  }    	None^235^^^^^234^236^
[REPLACE]    return    lexer    .    getLineNumber    (    )    ;  	[BUGGY]  return  hdrMap  ;  [CE]  cannot  find  symbol  hdrMap    [METHOD]    getLineNumber  [TYPE]  int  [PARAMETER]  [CLASS]  CSVParser  1    [TYPE]  Lexer  lexer  [TYPE]  List  record  records  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  next  rec  result  [TYPE]  boolean  false  true  [TYPE]  Map  hdrMap  headerMapping    [CONTEXT]    public  int  getLineNumber  (  )  {  [ATTENTION]  return  hdrMap  ;  }    	None^249^^^^^248^250^
[REPLACE]    if    (    current    ==    null    )    {  	[BUGGY]  if  (  current  !  =  null  )  {[FE]    (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    hasNext  [TYPE]  boolean  [PARAMETER]  [CLASS]  1    [TYPE]  CSVRecord  current  [TYPE]  boolean  false  true    [CONTEXT]    public  boolean  hasNext  (  )  {  [ATTENTION]  if  (  current  !  =  null  )  {  current  =  getNextRecord  (  )  ;  }  return  current  !  =  null  ;  }    	None^204^^^^^203^209^
[REPLACE]    current    =    getNextRecord    (    )    ;  	[BUGGY]  next  =  getNextRecord  (  )  ;    ;  [CE]  cannot  find  symbol  next    [METHOD]    hasNext  [TYPE]  boolean  [PARAMETER]  [CLASS]  1    [TYPE]  CSVRecord  current  [TYPE]  boolean  false  true    [CONTEXT]    public  boolean  hasNext  (  )  {  if  (  current  =  =  null  )  {  [ATTENTION]  next  =  getNextRecord  (  )    ;    ;  }  return  current  !  =  null  ;  }    	None^205^^^^^203^209^
[REPLACE]    return    current    !=    null;  	[BUGGY]  return  current  ;  [CE]  incompatible  types    [METHOD]    hasNext  [TYPE]  boolean  [PARAMETER]  [CLASS]  1    [TYPE]  CSVRecord  current  [TYPE]  boolean  false  true    [CONTEXT]    public  boolean  hasNext  (  )  {  if  (  current  =  =  null  )  {  current  =  getNextRecord  (  )  ;  }  [ATTENTION]  return  current  ;  }    	None^208^^^^^203^209^
[REPLACE]    current    =    null;  	[BUGGY]  current  =  this  ;  [CE]  incompatible  types    [METHOD]    next  [TYPE]  CSVRecord  [PARAMETER]  [CLASS]  1    [TYPE]  CSVRecord  current  next  [TYPE]  boolean  false  true    [CONTEXT]    public  CSVRecord  next  (  )  {  CSVRecord  next  =  current  ;  [ATTENTION]  current  =  this  ;    if  (  next  =  =  null  )  {    next  =  getNextRecord  (  )  ;  if  (  next  =  =  null  )  {  throw  new  NoSuchElementException  (     "No  more  CSV  records  available   "  )  ;  }  }  return  next  ;  }    	None^213^^^^^211^224^
[REPLACE]    if    (    next    ==    null    )    {  	[BUGGY]  if  (  next  !  =  null  )  {[FE]    (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    next  [TYPE]  CSVRecord  [PARAMETER]  [CLASS]  1    [TYPE]  CSVRecord  current  next  [TYPE]  boolean  false  true    [CONTEXT]    public  CSVRecord  next  (  )  {  CSVRecord  next  =  current  ;  current  =  null  ;    [ATTENTION]  if  (  next  !  =  null  )  {    next  =  getNextRecord  (  )  ;  if  (  next  =  =  null  )  {  throw  new  NoSuchElementException  (     "No  more  CSV  records  available   "  )  ;  }  }  return  next  ;  }    	None^215^^^^^211^224^
[REPLACE]    if    (    next    ==    null    )    {  	[BUGGY]  if  (current  !  =  null  )  {[FE]    (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    next  [TYPE]  CSVRecord  [PARAMETER]  [CLASS]  1    [TYPE]  CSVRecord  current  next  [TYPE]  boolean  false  true    [CONTEXT]    public  CSVRecord  next  (  )  {  CSVRecord  next  =  current  ;  current  =  null  ;    if  (  next  =  =  null  )  {    next  =  getNextRecord  (  )  ;  [ATTENTION]  if  (  current  !  =  null  )  {  throw  new  NoSuchElementException  (     "No  more  CSV  records  available   "  )  ;  }  }  return  next  ;  }    	None^218^^^^^211^224^
[REPLACE]    throw    new    NoSuchElementException    (   "       ")    ;  	[BUGGY]  throw  new  UnsupportedOperationException  (   "     ")    ;    ;  [CE]  unreachable  statement    [METHOD]    next  [TYPE]  CSVRecord  [PARAMETER]  [CLASS]  1    [TYPE]  CSVRecord  current  next  [TYPE]  boolean  false  true    [CONTEXT]    public  CSVRecord  next  (  )  {  CSVRecord  next  =  current  ;  current  =  null  ;    if  (  next  =  =  null  )  {    next  =  getNextRecord  (  )  ;  if  (  next  =  =  null  )  {  [ATTENTION]  throw  new  UnsupportedOperationException  (     "     "  )  ;    ;  }  }  return  next  ;  }    	None^219^^^^^211^224^
[REPLACE]    next    =    getNextRecord    (    )    ;  	[BUGGY]  current  =  getNextRecord  (  )  ;    ;  [FE]    (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    next  [TYPE]  CSVRecord  [PARAMETER]  [CLASS]  1    [TYPE]  CSVRecord  current  next  [TYPE]  boolean  false  true    [CONTEXT]    public  CSVRecord  next  (  )  {  CSVRecord  next  =  current  ;  current  =  null  ;    if  (  next  =  =  null  )  {    [ATTENTION]  current  =  getNextRecord  (  )    ;    ;  if  (  next  =  =  null  )  {  throw  new  NoSuchElementException  (     "No  more  CSV  records  available   "  )  ;  }  }  return  next  ;  }    	None^217^^^^^211^224^
[REPLACE]    if    (    next    ==    null    )    {  	[BUGGY]  if  (  current  !  =  null  )  {[FE]    (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    next  [TYPE]  CSVRecord  [PARAMETER]  [CLASS]  1    [TYPE]  CSVRecord  current  next  [TYPE]  boolean  false  true    [CONTEXT]    public  CSVRecord  next  (  )  {  CSVRecord  next  =  current  ;  current  =  null  ;    if  (  next  =  =  null  )  {    next  =  getNextRecord  (  )  ;  [ATTENTION]  if  (  current  !  =  null  )  {  throw  new  NoSuchElementException  (     "No  more  CSV  records  available   "  )  ;  }  }  return  next  ;  }    	None^218^^^^^211^224^
[ADD]    if    (    next    ==    null    )    {    throw    new    NoSuchElementException    (   "       ")    ;    }  	[BUGGY]  [FE]    (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    next  [TYPE]  CSVRecord  [PARAMETER]  [CLASS]  1    [TYPE]  CSVRecord  current  next  [TYPE]  boolean  false  true    [CONTEXT]    public  CSVRecord  next  (  )  {  CSVRecord  next  =  current  ;  current  =  null  ;    if  (  next  =  =  null  )  {    next  =  getNextRecord  (  )  ;  [ATTENTION]    }  return  next  ;  }    	None^218^219^220^^^211^224^
[ADD]    throw    new    NoSuchElementException    (   "       ")    ;  	[BUGGY]  [FE]    (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    next  [TYPE]  CSVRecord  [PARAMETER]  [CLASS]  1    [TYPE]  CSVRecord  current  next  [TYPE]  boolean  false  true    [CONTEXT]    public  CSVRecord  next  (  )  {  CSVRecord  next  =  current  ;  current  =  null  ;    if  (  next  =  =  null  )  {    next  =  getNextRecord  (  )  ;  if  (  next  =  =  null  )  {  [ATTENTION]  }  }  return  next  ;  }    	None^219^^^^^211^224^
[REPLACE]    throw    new    NoSuchElementException    (   "       ")    ;  	[BUGGY]  return  ;  [CE]  missing  return  value    [METHOD]    next  [TYPE]  CSVRecord  [PARAMETER]  [CLASS]  1    [TYPE]  CSVRecord  current  next  [TYPE]  boolean  false  true    [CONTEXT]    public  CSVRecord  next  (  )  {  CSVRecord  next  =  current  ;  current  =  null  ;    if  (  next  =  =  null  )  {    next  =  getNextRecord  (  )  ;  if  (  next  =  =  null  )  {  [ATTENTION]  return  ;  }  }  return  next  ;  }    	None^219^^^^^211^224^
[REPLACE]    return    next;  	[BUGGY]  return  current  ;  [FE]    (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    next  [TYPE]  CSVRecord  [PARAMETER]  [CLASS]  1    [TYPE]  CSVRecord  current  next  [TYPE]  boolean  false  true    [CONTEXT]    public  CSVRecord  next  (  )  {  CSVRecord  next  =  current  ;  current  =  null  ;    if  (  next  =  =  null  )  {    next  =  getNextRecord  (  )  ;  if  (  next  =  =  null  )  {  throw  new  NoSuchElementException  (     "No  more  CSV  records  available   "  )  ;  }  }  [ATTENTION]  return  current  ;  }    	None^223^^^^^211^224^
[ADD]    try    {    return    getRecord    (    )    ;    }    catch    (    IOException    e    )    {    throw    new    RuntimeException    (   "       ")    ;    }  	[BUGGY]  return  getRecord  (  )  ;  [CE]  unreported  exception  IOException  ;  must  be  caught  or  declared  to  be  thrown    [METHOD]    getNextRecord  [TYPE]  CSVRecord  [PARAMETER]  [CLASS]  1    [TYPE]  CSVRecord  current  next  [TYPE]  IOException  e  [TYPE]  boolean  false  true    [CONTEXT]    private  CSVRecord  getNextRecord  (  )  {  [ATTENTION]  return  getRecord  (  )    ;      }    	None^227^228^229^230^231^226^232^
[REPLACE]    return    getRecord    (    )    ;  	[BUGGY]  return  next  ;  [CE]  cannot  find  symbol  next    [METHOD]    getNextRecord  [TYPE]  CSVRecord  [PARAMETER]  [CLASS]  1    [TYPE]  CSVRecord  current  next  [TYPE]  IOException  e  [TYPE]  boolean  false  true    [CONTEXT]    private  CSVRecord  getNextRecord  (  )  {  try  {  [ATTENTION]  return  next  ;  }  catch  (  IOException  e  )  {  throw  new  RuntimeException  (  e  )  ;  }  }    	None^228^^^^^226^232^
[REPLACE]    throw    new    RuntimeException    (   "       ")    ;  	[BUGGY]  throw  new  UnsupportedOperationException  (   "     ")    ;    ;  [CE]  unreachable  statement    [METHOD]    getNextRecord  [TYPE]  CSVRecord  [PARAMETER]  [CLASS]  1    [TYPE]  CSVRecord  current  next  [TYPE]  IOException  e  [TYPE]  boolean  false  true    [CONTEXT]    private  CSVRecord  getNextRecord  (  )  {  try  {  return  getRecord  (  )  ;  }  catch  (  IOException  e  )  {  [ATTENTION]  throw  new  UnsupportedOperationException  (     "     "  )  ;    ;  }  }    	None^230^^^^^226^232^
[REPLACE]    throw    new    UnsupportedOperationException    (   "       ")    ;  	[BUGGY]  throw  new  RuntimeException  (   "     ")    ;    ;  [CE]  unreachable  statement    [METHOD]    remove  [TYPE]  void  [PARAMETER]  [CLASS]  1    [TYPE]  CSVRecord  current  next  [TYPE]  boolean  false  true    [CONTEXT]    public  void  remove  (  )  {  [ATTENTION]  throw  new  RuntimeException  (     "     "  )  ;    ;  }    	None^235^^^^^234^236^
[REPLACE]    private    final    CSVFormat    format;  	[BUGGY]  private  CSVFormat  format  ;  [FE]    (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [CONTEXT]        [CLASS]  CSVPrinter    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^30^^^^^^^
[REPLACE]    private    boolean    newLine    =    true;  	[BUGGY]  private  boolean  newLine  =  false  ;  [FE]    AssertionFailedError    expected:<[]a  ,  b  ,  c>  but  was:<[  ,  ]a  ,  b  ,  c>  assertEquals(   "   "  ,  format.format())      [CONTEXT]        [CLASS]  CSVPrinter    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^33^^^^^^^
[REPLACE]    this    .    out    =    out;  	[BUGGY]  this  .  out  =    null  ;  [FE]    null  assertEquals(   "   "  ,  format.format())      [METHOD]    <init>  [TYPE]  CSVFormat)  [PARAMETER]  Appendable  out  CSVFormat  format  [CLASS]  CSVPrinter    [TYPE]  CSVFormat  format  [TYPE]  boolean  false  newLine  true  [TYPE]  Appendable  out    [CONTEXT]    public  CSVPrinter  (  Appendable  out  ,  CSVFormat  format  )  {  [ATTENTION]  this  .  out  =  null  ;  this  .  format  =  format  =  =  null  ?  CSVFormat  .  DEFAULT  :  format  ;    this  .  format  .  validate  (  )  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^46^^^^^45^50^
[REPLACE]    this    .    format    =    format    ==    null    ?    CSVFormat    .    DEFAULT    :    format;  	[BUGGY]  this  .  format    =    CSVFormat  .  DEFAULT  ;  [FE]    (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    <init>  [TYPE]  CSVFormat)  [PARAMETER]  Appendable  out  CSVFormat  format  [CLASS]  CSVPrinter    [TYPE]  CSVFormat  format  [TYPE]  boolean  false  newLine  true  [TYPE]  Appendable  out    [CONTEXT]    public  CSVPrinter  (  Appendable  out  ,  CSVFormat  format  )  {  this  .  out  =  out  ;  [ATTENTION]  this  .  format  =  CSVFormat  .  DEFAULT  ;    this  .  format  .  validate  (  )  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^47^^^^^45^50^
[REPLACE]    this    .    format    .    validate    (    )    ;  	[BUGGY]  this  .  format  .  getEscape  (  )  ;  [FE]    (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    <init>  [TYPE]  CSVFormat)  [PARAMETER]  Appendable  out  CSVFormat  format  [CLASS]  CSVPrinter    [TYPE]  CSVFormat  format  [TYPE]  boolean  false  newLine  true  [TYPE]  Appendable  out    [CONTEXT]    public  CSVPrinter  (  Appendable  out  ,  CSVFormat  format  )  {  this  .  out  =  out  ;  this  .  format  =  format  =  =  null  ?  CSVFormat  .  DEFAULT  :  format  ;    [ATTENTION]  this  .  format  .  getEscape  (  )    ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^49^^^^^45^50^
[REPLACE]    out    .    append    (    format    .    getLineSeparator    (    )    )    ;  	[BUGGY]  out  .  append  (  format  .  getEncapsulator  (  )    )  ;  [FE]    AssertionFailedError    expected:<[]>  but  was:<[   "]>  assertEquals(   "   "  ,  format.format())      [METHOD]    println  [TYPE]  void  [PARAMETER]  [CLASS]  CSVPrinter    [TYPE]  CSVFormat  format  [TYPE]  boolean  false  newLine  true  [TYPE]  Appendable  out    [CONTEXT]    public  void  println  (  )  throws  IOException  {  [ATTENTION]  out  .  append  (  format  .  getEncapsulator  (  )    )    ;  newLine  =  true  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^60^^^^^59^62^
[REPLACE]    newLine    =    true;  	[BUGGY]  newLine  =  false  ;  [FE]    (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    println  [TYPE]  void  [PARAMETER]  [CLASS]  CSVPrinter    [TYPE]  CSVFormat  format  [TYPE]  boolean  false  newLine  true  [TYPE]  Appendable  out    [CONTEXT]    public  void  println  (  )  throws  IOException  {  out  .  append  (  format  .  getLineSeparator  (  )  )  ;  [ATTENTION]  newLine  =  false  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^61^^^^^59^62^
[ADD]    newLine    =    true;  	[BUGGY]  [FE]    (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    println  [TYPE]  void  [PARAMETER]  [CLASS]  CSVPrinter    [TYPE]  CSVFormat  format  [TYPE]  boolean  false  newLine  true  [TYPE]  Appendable  out    [CONTEXT]    public  void  println  (  )  throws  IOException  {  out  .  append  (  format  .  getLineSeparator  (  )  )  ;  [ATTENTION]  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^61^^^^^59^62^
[REPLACE]    if    (    out    instanceof    Flushable    )    {  	[BUGGY]  if  (  !  out  instanceof  Flushable  )  {[CE]  bad  operand  type  Appendable  for  unary  operator  '!'    [METHOD]    flush  [TYPE]  void  [PARAMETER]  [CLASS]  CSVPrinter    [TYPE]  CSVFormat  format  [TYPE]  boolean  false  newLine  true  [TYPE]  Appendable  out    [CONTEXT]    public  void  flush  (  )  throws  IOException  {  [ATTENTION]  if  (  !  out  instanceof  Flushable  )  {  (  (  Flushable  )  out  )  .  flush  (  )  ;  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^70^^^^^69^73^
[ADD]    if    (    out    instanceof    Flushable    )    {    (    (    Flushable    )    out    )        .    flush    (    )    ;    }  	[BUGGY]  (  (  Flushable  )  out  )  .  flush  (  )  ;  [FE]    (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    flush  [TYPE]  void  [PARAMETER]  [CLASS]  CSVPrinter    [TYPE]  CSVFormat  format  [TYPE]  boolean  false  newLine  true  [TYPE]  Appendable  out    [CONTEXT]    public  void  flush  (  )  throws  IOException  {  [ATTENTION]  (  (  Flushable  )  out  )    .  flush  (  )    ;    }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^70^71^72^^^69^73^
[REPLACE]    (    (    Flushable    )    out    )        .    flush    (    )    ;  	[BUGGY]  if  (  !format  .  isCommentingEnabled  (  )  )  {  return  ;  [CE]  illegal  start  of  expression    [METHOD]    flush  [TYPE]  void  [PARAMETER]  [CLASS]  CSVPrinter    [TYPE]  CSVFormat  format  [TYPE]  boolean  false  newLine  true  [TYPE]  Appendable  out    [CONTEXT]    public  void  flush  (  )  throws  IOException  {  if  (  out  instanceof  Flushable  )  {  [ATTENTION]  if  (  !format  .  isCommentingEnabled  (  )  )  {  return  ;  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^71^^^^^69^73^
[REPLACE]    for    (    String    value    :    values    )    {  	[BUGGY]  for  (  String  value  :  values  )  {  print  (  value  )  ;  [FE]    AssertionFailedError    expected:<a  ,  [b]  ,  c>  but  was:<a  ,  [a  ,  b  ,  b  ,  c]  ,  c>  assertEquals(   "   "  ,  format.format())      [METHOD]    println  [TYPE]  void  [PARAMETER]  values  [CLASS]  CSVPrinter    [TYPE]  CSVFormat  format  [TYPE]  boolean  false  newLine  true  [TYPE]  String[]  values  [TYPE]  String  value  [TYPE]  Appendable  out    [CONTEXT]    public  void  println  (  String  .  .  .  values  )  throws  IOException  {  [ATTENTION]  for  (  String  value  :  values  )  {  print  (  value  )    ;  print  (  value  )  ;  }  println  (  )  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^83^^^^^82^87^
[REPLACE]    println    (    )    ;  	[BUGGY]  out  .  append  (  '  '  )  ;  [FE]    (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    println  [TYPE]  void  [PARAMETER]  values  [CLASS]  CSVPrinter    [TYPE]  CSVFormat  format  [TYPE]  boolean  false  newLine  true  [TYPE]  String[]  values  [TYPE]  String  value  [TYPE]  Appendable  out    [CONTEXT]    public  void  println  (  String  .  .  .  values  )  throws  IOException  {  for  (  String  value  :  values  )  {  print  (  value  )  ;  }  [ATTENTION]  out  .  append  (  '  '  )    ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^86^^^^^82^87^
[REPLACE]    if    (    !format    .    isCommentingEnabled    (    )    )    {  	[BUGGY]  if  (  !format  .  getCommentStart  (  )    )  {[CE]  bad  operand  type  char  for  unary  operator  '!'    [METHOD]    printComment  [TYPE]  void  [PARAMETER]  String  comment  [CLASS]  CSVPrinter    [TYPE]  char  c  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  newLine  true  [TYPE]  String  comment  [TYPE]  int  i  [TYPE]  Appendable  out    [CONTEXT]    public  void  printComment  (  String  comment  )  throws  IOException  {  [ATTENTION]  if  (  !format  .  getCommentStart  (  )    )  {  return  ;  }  if  (  !newLine  )  {  println  (  )  ;  }  out  .  append  (  format  .  getCommentStart  (  )  )  ;  out  .  append  (  '  '  )  ;  for  (  int  i  =  0  ;  i  <  comment  .  length  (  )  ;  i++  )  {  char  c  =  comment  .  charAt  (  i  )  ;  switch  (  c  )  {  case  '\r':  if  (  i  +  1  <  comment  .  length  (  )  &&  comment  .  charAt  (  i  +  1  )    =  =  '\n'  )  {  i++  ;  }    case  '\n':  println  (  )  ;  out  .  append  (  format  .  getCommentStart  (  )  )  ;  out  .  append  (  '  '  )  ;  break  ;  default:  out  .  append  (  c  )  ;  break  ;  }  }  println  (  )  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^101^^^^^100^128^
[REPLACE]    if    (    !newLine    )    {  	[BUGGY]  if  (  newLine  )  {[FE]    (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    printComment  [TYPE]  void  [PARAMETER]  String  comment  [CLASS]  CSVPrinter    [TYPE]  char  c  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  newLine  true  [TYPE]  String  comment  [TYPE]  int  i  [TYPE]  Appendable  out    [CONTEXT]    public  void  printComment  (  String  comment  )  throws  IOException  {  if  (  !format  .  isCommentingEnabled  (  )  )  {  return  ;  }  [ATTENTION]  if  (  newLine  )  {  println  (  )  ;  }  out  .  append  (  format  .  getCommentStart  (  )  )  ;  out  .  append  (  '  '  )  ;  for  (  int  i  =  0  ;  i  <  comment  .  length  (  )  ;  i++  )  {  char  c  =  comment  .  charAt  (  i  )  ;  switch  (  c  )  {  case  '\r':  if  (  i  +  1  <  comment  .  length  (  )  &&  comment  .  charAt  (  i  +  1  )    =  =  '\n'  )  {  i++  ;  }    case  '\n':  println  (  )  ;  out  .  append  (  format  .  getCommentStart  (  )  )  ;  out  .  append  (  '  '  )  ;  break  ;  default:  out  .  append  (  c  )  ;  break  ;  }  }  println  (  )  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^104^^^^^100^128^
[REPLACE]    println    (    )    ;  	[BUGGY]  out  .  append  (  '  '  )  ;  [FE]    (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    printComment  [TYPE]  void  [PARAMETER]  String  comment  [CLASS]  CSVPrinter    [TYPE]  char  c  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  newLine  true  [TYPE]  String  comment  [TYPE]  int  i  [TYPE]  Appendable  out    [CONTEXT]    public  void  printComment  (  String  comment  )  throws  IOException  {  if  (  !format  .  isCommentingEnabled  (  )  )  {  return  ;  }  if  (  !newLine  )  {  [ATTENTION]  out  .  append  (  '  '  )    ;  }  out  .  append  (  format  .  getCommentStart  (  )  )  ;  out  .  append  (  '  '  )  ;  for  (  int  i  =  0  ;  i  <  comment  .  length  (  )  ;  i++  )  {  char  c  =  comment  .  charAt  (  i  )  ;  switch  (  c  )  {  case  '\r':  if  (  i  +  1  <  comment  .  length  (  )  &&  comment  .  charAt  (  i  +  1  )    =  =  '\n'  )  {  i++  ;  }    case  '\n':  println  (  )  ;  out  .  append  (  format  .  getCommentStart  (  )  )  ;  out  .  append  (  '  '  )  ;  break  ;  default:  out  .  append  (  c  )  ;  break  ;  }  }  println  (  )  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^105^^^^^100^128^
[ADD]    println    (    )    ;  	[BUGGY]  [FE]    (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    printComment  [TYPE]  void  [PARAMETER]  String  comment  [CLASS]  CSVPrinter    [TYPE]  char  c  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  newLine  true  [TYPE]  String  comment  [TYPE]  int  i  [TYPE]  Appendable  out    [CONTEXT]    public  void  printComment  (  String  comment  )  throws  IOException  {  if  (  !format  .  isCommentingEnabled  (  )  )  {  return  ;  }  if  (  !newLine  )  {  [ATTENTION]  }  out  .  append  (  format  .  getCommentStart  (  )  )  ;  out  .  append  (  '  '  )  ;  for  (  int  i  =  0  ;  i  <  comment  .  length  (  )  ;  i++  )  {  char  c  =  comment  .  charAt  (  i  )  ;  switch  (  c  )  {  case  '\r':  if  (  i  +  1  <  comment  .  length  (  )  &&  comment  .  charAt  (  i  +  1  )    =  =  '\n'  )  {  i++  ;  }    case  '\n':  println  (  )  ;  out  .  append  (  format  .  getCommentStart  (  )  )  ;  out  .  append  (  '  '  )  ;  break  ;  default:  out  .  append  (  c  )  ;  break  ;  }  }  println  (  )  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^105^^^^^100^128^
[REPLACE]    out    .    append    (    format    .    getCommentStart    (    )    )    ;  	[BUGGY]  out  .  append  (  null  ,  i  ,  i  )    ;  [CE]  cannot  find  symbol  i    [METHOD]    printComment  [TYPE]  void  [PARAMETER]  String  comment  [CLASS]  CSVPrinter    [TYPE]  char  c  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  newLine  true  [TYPE]  String  comment  [TYPE]  int  i  [TYPE]  Appendable  out    [CONTEXT]    public  void  printComment  (  String  comment  )  throws  IOException  {  if  (  !format  .  isCommentingEnabled  (  )  )  {  return  ;  }  if  (  !newLine  )  {  println  (  )  ;  }  [ATTENTION]  out  .  append  (  null  ,  i  ,  i  )  ;  out  .  append  (  '  '  )  ;  for  (  int  i  =  0  ;  i  <  comment  .  length  (  )  ;  i++  )  {  char  c  =  comment  .  charAt  (  i  )  ;  switch  (  c  )  {  case  '\r':  if  (  i  +  1  <  comment  .  length  (  )  &&  comment  .  charAt  (  i  +  1  )    =  =  '\n'  )  {  i++  ;  }    case  '\n':  println  (  )  ;  out  .  append  (  format  .  getCommentStart  (  )  )  ;  out  .  append  (  '  '  )  ;  break  ;  default:  out  .  append  (  c  )  ;  break  ;  }  }  println  (  )  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^107^^^^^100^128^
[REPLACE]    out    .    append    (    format    .    getCommentStart    (    )    )    ;  	[BUGGY]  out  .  append  (  format  .  getEscape  (  )  )  ;  [FE]    (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    printComment  [TYPE]  void  [PARAMETER]  String  comment  [CLASS]  CSVPrinter    [TYPE]  char  c  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  newLine  true  [TYPE]  String  comment  [TYPE]  int  i  [TYPE]  Appendable  out    [CONTEXT]    public  void  printComment  (  String  comment  )  throws  IOException  {  if  (  !format  .  isCommentingEnabled  (  )  )  {  return  ;  }  if  (  !newLine  )  {  println  (  )  ;  }  [ATTENTION]  out  .  append  (  format  .  getEscape  (  )  )    ;  out  .  append  (  '  '  )  ;  for  (  int  i  =  0  ;  i  <  comment  .  length  (  )  ;  i++  )  {  char  c  =  comment  .  charAt  (  i  )  ;  switch  (  c  )  {  case  '\r':  if  (  i  +  1  <  comment  .  length  (  )  &&  comment  .  charAt  (  i  +  1  )    =  =  '\n'  )  {  i++  ;  }    case  '\n':  println  (  )  ;  out  .  append  (  format  .  getCommentStart  (  )  )  ;  out  .  append  (  '  '  )  ;  break  ;  default:  out  .  append  (  c  )  ;  break  ;  }  }  println  (  )  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^107^^^^^100^128^
[REPLACE]    out    .    append    (    '    '    )    ;  	[BUGGY]  out  .  append  (  null  ,  i  ,  i  )    ;  [CE]  cannot  find  symbol  i    [METHOD]    printComment  [TYPE]  void  [PARAMETER]  String  comment  [CLASS]  CSVPrinter    [TYPE]  char  c  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  newLine  true  [TYPE]  String  comment  [TYPE]  int  i  [TYPE]  Appendable  out    [CONTEXT]    public  void  printComment  (  String  comment  )  throws  IOException  {  if  (  !format  .  isCommentingEnabled  (  )  )  {  return  ;  }  if  (  !newLine  )  {  println  (  )  ;  }  out  .  append  (  format  .  getCommentStart  (  )  )  ;  [ATTENTION]  out  .  append  (  null  ,  i  ,  i  )  ;  for  (  int  i  =  0  ;  i  <  comment  .  length  (  )  ;  i++  )  {  char  c  =  comment  .  charAt  (  i  )  ;  switch  (  c  )  {  case  '\r':  if  (  i  +  1  <  comment  .  length  (  )  &&  comment  .  charAt  (  i  +  1  )    =  =  '\n'  )  {  i++  ;  }    case  '\n':  println  (  )  ;  out  .  append  (  format  .  getCommentStart  (  )  )  ;  out  .  append  (  '  '  )  ;  break  ;  default:  out  .  append  (  c  )  ;  break  ;  }  }  println  (  )  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^108^^^^^100^128^
[REMOVE]      	[BUGGY]  out  .  append  (  encapsulator  )  ;  [CE]  cannot  find  symbol  encapsulator    [METHOD]    printComment  [TYPE]  void  [PARAMETER]  String  comment  [CLASS]  CSVPrinter    [TYPE]  char  c  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  newLine  true  [TYPE]  String  comment  [TYPE]  int  i  [TYPE]  Appendable  out    [CONTEXT]    public  void  printComment  (  String  comment  )  throws  IOException  {  if  (  !format  .  isCommentingEnabled  (  )  )  {  return  ;  }  if  (  !newLine  )  {  println  (  )  ;  }  out  .  append  (  format  .  getCommentStart  (  )  )  ;  [ATTENTION]  out  .  append  (  '  '  )  ;    out  .  append  (  encapsulator  )    ;  for  (  int  i  =  0  ;  i  <  comment  .  length  (  )  ;  i++  )  {  char  c  =  comment  .  charAt  (  i  )  ;  switch  (  c  )  {  case  '\r':  if  (  i  +  1  <  comment  .  length  (  )  &&  comment  .  charAt  (  i  +  1  )    =  =  '\n'  )  {  i++  ;  }    case  '\n':  println  (  )  ;  out  .  append  (  format  .  getCommentStart  (  )  )  ;  out  .  append  (  '  '  )  ;  break  ;  default:  out  .  append  (  c  )  ;  break  ;  }  }  println  (  )  ;      	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^108^^^^^100^128^
[REPLACE]    if    (    i    +    1    <    comment    .    length    (    )    &&    comment    .    charAt    (    i    +    1    )    ==    '\n'    )    {  	[BUGGY]  if  (  i  +  0  <  comment  .  length  (  )  -  2  &&  comment  .  charAt  (  i  +  0  )    =  =  '\n'  )  {[FE]    (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    printComment  [TYPE]  void  [PARAMETER]  String  comment  [CLASS]  CSVPrinter    [TYPE]  char  c  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  newLine  true  [TYPE]  String  comment  [TYPE]  int  i  [TYPE]  Appendable  out    [CONTEXT]    public  void  printComment  (  String  comment  )  throws  IOException  {  if  (  !format  .  isCommentingEnabled  (  )  )  {  return  ;  }  if  (  !newLine  )  {  println  (  )  ;  }  out  .  append  (  format  .  getCommentStart  (  )  )  ;  out  .  append  (  '  '  )  ;  for  (  int  i  =  0  ;  i  <  comment  .  length  (  )  ;  i++  )  {  char  c  =  comment  .  charAt  (  i  )  ;  switch  (  c  )  {  case  '\r':  [ATTENTION]  if  (  i  +  0<  comment  .  length  (  )  -  2  &&  comment  .  charAt  (  i  +  0  )  =  =  '\n'  )  {  i++  ;  }    case  '\n':  println  (  )  ;  out  .  append  (  format  .  getCommentStart  (  )  )  ;  out  .  append  (  '  '  )  ;  break  ;  default:  out  .  append  (  c  )  ;  break  ;  }  }  println  (  )  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^113^^^^^100^128^
[ADD]    if    (    i    +    1    <    comment    .    length    (    )    &&    comment    .    charAt    (    i    +    1    )    ==    '\n'    )    {    i++;    }  	[BUGGY]  i++  ;  [FE]    (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    printComment  [TYPE]  void  [PARAMETER]  String  comment  [CLASS]  CSVPrinter    [TYPE]  char  c  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  newLine  true  [TYPE]  String  comment  [TYPE]  int  i  [TYPE]  Appendable  out    [CONTEXT]    public  void  printComment  (  String  comment  )  throws  IOException  {  if  (  !format  .  isCommentingEnabled  (  )  )  {  return  ;  }  if  (  !newLine  )  {  println  (  )  ;  }  out  .  append  (  format  .  getCommentStart  (  )  )  ;  out  .  append  (  '  '  )  ;  for  (  int  i  =  0  ;  i  <  comment  .  length  (  )  ;  i++  )  {  char  c  =  comment  .  charAt  (  i  )  ;  switch  (  c  )  {  case  '\r':  [ATTENTION]  i++  ;      case  '\n':  println  (  )  ;  out  .  append  (  format  .  getCommentStart  (  )  )  ;  out  .  append  (  '  '  )  ;  break  ;  default:  out  .  append  (  c  )  ;  break  ;  }  }  println  (  )  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^113^114^115^^^100^128^
[REPLACE]    for    (    int    i    =    0;    i    <    comment    .    length    (    )    ;    i++    )    {  	[BUGGY]  for  (  int  i  =  0  ;  i  <  comment  .  length  (  )  /  2  ;  i++  )  {[FE]    (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    printComment  [TYPE]  void  [PARAMETER]  String  comment  [CLASS]  CSVPrinter    [TYPE]  char  c  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  newLine  true  [TYPE]  String  comment  [TYPE]  int  i  [TYPE]  Appendable  out    [CONTEXT]    public  void  printComment  (  String  comment  )  throws  IOException  {  if  (  !format  .  isCommentingEnabled  (  )  )  {  return  ;  }  if  (  !newLine  )  {  println  (  )  ;  }  out  .  append  (  format  .  getCommentStart  (  )  )  ;  out  .  append  (  '  '  )  ;  [ATTENTION]  for  (  int  i  =  0  ;  i  <  comment  .  length  (  )  /2  ;  i++  )  {  char  c  =  comment  .  charAt  (  i  )  ;  switch  (  c  )  {  case  '\r':  if  (  i  +  1  <  comment  .  length  (  )  &&  comment  .  charAt  (  i  +  1  )    =  =  '\n'  )  {  i++  ;  }    case  '\n':  println  (  )  ;  out  .  append  (  format  .  getCommentStart  (  )  )  ;  out  .  append  (  '  '  )  ;  break  ;  default:  out  .  append  (  c  )  ;  break  ;  }  }  println  (  )  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^109^^^^^100^128^
[REPLACE]    if    (    i    +    1    <    comment    .    length    (    )    &&    comment    .    charAt    (    i    +    1    )    ==    '\n'    )    {  	[BUGGY]  if  (  i  +  1  <  comment  .  charAt  (  )  +  2  )  {[CE]  method  charAt  in  class  String  cannot  be  applied  to  given  types  ;    [METHOD]    printComment  [TYPE]  void  [PARAMETER]  String  comment  [CLASS]  CSVPrinter    [TYPE]  char  c  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  newLine  true  [TYPE]  String  comment  [TYPE]  int  i  [TYPE]  Appendable  out    [CONTEXT]    public  void  printComment  (  String  comment  )  throws  IOException  {  if  (  !format  .  isCommentingEnabled  (  )  )  {  return  ;  }  if  (  !newLine  )  {  println  (  )  ;  }  out  .  append  (  format  .  getCommentStart  (  )  )  ;  out  .  append  (  '  '  )  ;  for  (  int  i  =  0  ;  i  <  comment  .  length  (  )  ;  i++  )  {  char  c  =  comment  .  charAt  (  i  )  ;  switch  (  c  )  {  case  '\r':  [ATTENTION]  if  (  i  +  1  <  comment  .  charAt  (  )  +  2  )  {  i++  ;  }    case  '\n':  println  (  )  ;  out  .  append  (  format  .  getCommentStart  (  )  )  ;  out  .  append  (  '  '  )  ;  break  ;  default:  out  .  append  (  c  )  ;  break  ;  }  }  println  (  )  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^113^^^^^100^128^
[ADD]    if    (    i    +    1    <    comment    .    length    (    )    &&    comment    .    charAt    (    i    +    1    )    ==    '\n'    )    {    i++;    }  	[BUGGY]  [FE]    (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    printComment  [TYPE]  void  [PARAMETER]  String  comment  [CLASS]  CSVPrinter    [TYPE]  char  c  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  newLine  true  [TYPE]  String  comment  [TYPE]  int  i  [TYPE]  Appendable  out    [CONTEXT]    public  void  printComment  (  String  comment  )  throws  IOException  {  if  (  !format  .  isCommentingEnabled  (  )  )  {  return  ;  }  if  (  !newLine  )  {  println  (  )  ;  }  out  .  append  (  format  .  getCommentStart  (  )  )  ;  out  .  append  (  '  '  )  ;  for  (  int  i  =  0  ;  i  <  comment  .  length  (  )  ;  i++  )  {  char  c  =  comment  .  charAt  (  i  )  ;  switch  (  c  )  {  case  '\r':  [ATTENTION]      case  '\n':  println  (  )  ;  out  .  append  (  format  .  getCommentStart  (  )  )  ;  out  .  append  (  '  '  )  ;  break  ;  default:  out  .  append  (  c  )  ;  break  ;  }  }  println  (  )  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^113^114^115^^^100^128^
[REPLACE]    char    c    =    comment    .    charAt    (    i    )    ;  	[BUGGY]  char  delim  =  format  .  getDelimiter  (  )  ;  [CE]  cannot  find  symbol  c    [METHOD]    printComment  [TYPE]  void  [PARAMETER]  String  comment  [CLASS]  CSVPrinter    [TYPE]  char  c  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  newLine  true  [TYPE]  String  comment  [TYPE]  int  i  [TYPE]  Appendable  out    [CONTEXT]    public  void  printComment  (  String  comment  )  throws  IOException  {  if  (  !format  .  isCommentingEnabled  (  )  )  {  return  ;  }  if  (  !newLine  )  {  println  (  )  ;  }  out  .  append  (  format  .  getCommentStart  (  )  )  ;  out  .  append  (  '  '  )  ;  for  (  int  i  =  0  ;  i  <  comment  .  length  (  )  ;  i++  )  {  [ATTENTION]  char  delim  =  format  .  getDelimiter  (  )    ;  switch  (  c  )  {  case  '\r':  if  (  i  +  1  <  comment  .  length  (  )  &&  comment  .  charAt  (  i  +  1  )    =  =  '\n'  )  {  i++  ;  }    case  '\n':  println  (  )  ;  out  .  append  (  format  .  getCommentStart  (  )  )  ;  out  .  append  (  '  '  )  ;  break  ;  default:  out  .  append  (  c  )  ;  break  ;  }  }  println  (  )  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^110^^^^^100^128^
[REPLACE]    for    (    int    i    =    0;    i    <    comment    .    length    (    )    ;    i++    )    {  	[BUGGY]  for  (  int  i  =  0  ;  i  <  comment  .  length  (  )  ;  i++  )  {[FE]    (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    printComment  [TYPE]  void  [PARAMETER]  String  comment  [CLASS]  CSVPrinter    [TYPE]  char  c  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  newLine  true  [TYPE]  String  comment  [TYPE]  int  i  [TYPE]  Appendable  out    [CONTEXT]    public  void  printComment  (  String  comment  )  throws  IOException  {  if  (  !format  .  isCommentingEnabled  (  )  )  {  return  ;  }  if  (  !newLine  )  {  println  (  )  ;  }  out  .  append  (  format  .  getCommentStart  (  )  )  ;  out  .  append  (  '  '  )  ;  [ATTENTION]  for  (  int  i  =  0  ;  i  <  comment  .  length  (  )    ;  i++  )  {  char  c  =  comment  .  charAt  (  i  )  ;  switch  (  c  )  {  case  '\r':  if  (  i  +  1  <  comment  .  length  (  )  &&  comment  .  charAt  (  i  +  1  )    =  =  '\n'  )  {  i++  ;  }    case  '\n':  println  (  )  ;  out  .  append  (  format  .  getCommentStart  (  )  )  ;  out  .  append  (  '  '  )  ;  break  ;  default:  out  .  append  (  c  )  ;  break  ;  }  }  println  (  )  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^109^^^^^100^128^
[REPLACE]    println    (    )    ;  	[BUGGY]  out  .  append  (  '  '  )  ;  [FE]    (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    printComment  [TYPE]  void  [PARAMETER]  String  comment  [CLASS]  CSVPrinter    [TYPE]  char  c  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  newLine  true  [TYPE]  String  comment  [TYPE]  int  i  [TYPE]  Appendable  out    [CONTEXT]    public  void  printComment  (  String  comment  )  throws  IOException  {  if  (  !format  .  isCommentingEnabled  (  )  )  {  return  ;  }  if  (  !newLine  )  {  println  (  )  ;  }  out  .  append  (  format  .  getCommentStart  (  )  )  ;  out  .  append  (  '  '  )  ;  for  (  int  i  =  0  ;  i  <  comment  .  length  (  )  ;  i++  )  {  char  c  =  comment  .  charAt  (  i  )  ;  switch  (  c  )  {  case  '\r':  if  (  i  +  1  <  comment  .  length  (  )  &&  comment  .  charAt  (  i  +  1  )    =  =  '\n'  )  {  i++  ;  }    case  '\n':  println  (  )  ;  out  .  append  (  format  .  getCommentStart  (  )  )  ;  out  .  append  (  '  '  )  ;  break  ;  default:  out  .  append  (  c  )  ;  break  ;  }  }  [ATTENTION]  out  .  append  (  '  '  )    ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^127^^^^^100^128^
[ADD]    println    (    )    ;  	[BUGGY]  [FE]    (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    printComment  [TYPE]  void  [PARAMETER]  String  comment  [CLASS]  CSVPrinter    [TYPE]  char  c  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  newLine  true  [TYPE]  String  comment  [TYPE]  int  i  [TYPE]  Appendable  out    [CONTEXT]    public  void  printComment  (  String  comment  )  throws  IOException  {  if  (  !format  .  isCommentingEnabled  (  )  )  {  return  ;  }  if  (  !newLine  )  {  println  (  )  ;  }  out  .  append  (  format  .  getCommentStart  (  )  )  ;  out  .  append  (  '  '  )  ;  for  (  int  i  =  0  ;  i  <  comment  .  length  (  )  ;  i++  )  {  char  c  =  comment  .  charAt  (  i  )  ;  switch  (  c  )  {  case  '\r':  if  (  i  +  1  <  comment  .  length  (  )  &&  comment  .  charAt  (  i  +  1  )    =  =  '\n'  )  {  i++  ;  }    case  '\n':  println  (  )  ;  out  .  append  (  format  .  getCommentStart  (  )  )  ;  out  .  append  (  '  '  )  ;  break  ;  default:  out  .  append  (  c  )  ;  break  ;  }  }  [ATTENTION]  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^127^^^^^100^128^
[REPLACE]    if    (    format    .    isEncapsulating    (    )    )    {  	[BUGGY]  if  (  newLine  )  {[FE]    (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    print  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  newLine  true  [TYPE]  int  len  offset  [TYPE]  Appendable  out    [CONTEXT]    private  void  print  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  [ATTENTION]  if  (  newLine  )  {  printAndEncapsulate  (  value  ,  offset  ,  len  )  ;  }  else  if  (  format  .  isEscaping  (  )  )  {  printAndEscape  (  value  ,  offset  ,  len  )  ;  }  else  {  printSep  (  )  ;  out  .  append  (  value  ,  offset  ,  offset  +  len  )  ;  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^132^^^^^131^140^
[REPLACE]    }    else    if    (    format    .    isEscaping    (    )    )    {  	[BUGGY]    else  {[CE]  'else'  without  'if'    [METHOD]    print  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  newLine  true  [TYPE]  int  len  offset  [TYPE]  Appendable  out    [CONTEXT]    private  void  print  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  if  (  format  .  isEncapsulating  (  )  )  {  printAndEncapsulate  (  value  ,  offset  ,  len  )  ;  [ATTENTION]  }else  {  printAndEscape  (  value  ,  offset  ,  len  )  ;  }  else  {  printSep  (  )  ;  out  .  append  (  value  ,  offset  ,  offset  +  len  )  ;  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^134^^^^^131^140^
[REPLACE]    printSep    (    )    ;  	[BUGGY]  out  .  append  (  '  '  )  ;  [FE]    (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    print  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  newLine  true  [TYPE]  int  len  offset  [TYPE]  Appendable  out    [CONTEXT]    private  void  print  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  if  (  format  .  isEncapsulating  (  )  )  {  printAndEncapsulate  (  value  ,  offset  ,  len  )  ;  }  else  if  (  format  .  isEscaping  (  )  )  {  printAndEscape  (  value  ,  offset  ,  len  )  ;  }  else  {  [ATTENTION]  out  .  append  (  '  '  )    ;  out  .  append  (  value  ,  offset  ,  offset  +  len  )  ;  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^137^^^^^131^140^
[REPLACE]    out    .    append    (    value,    offset,    offset    +    len    )    ;  	[BUGGY]  out  .  append  (  value  ,  offset  ,  offset  >  offset  )  ;  [CE]  no  suitable  method  found  for  append(CharSequence  ,  int  ,  boolean)    [METHOD]    print  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  newLine  true  [TYPE]  int  len  offset  [TYPE]  Appendable  out    [CONTEXT]    private  void  print  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  if  (  format  .  isEncapsulating  (  )  )  {  printAndEncapsulate  (  value  ,  offset  ,  len  )  ;  }  else  if  (  format  .  isEscaping  (  )  )  {  printAndEscape  (  value  ,  offset  ,  len  )  ;  }  else  {  printSep  (  )  ;  [ATTENTION]  out  .  append  (  value  ,  offset  ,  offset>offset  )    ;  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^138^^^^^131^140^
[REPLACE]    printAndEscape    (    value,    offset,    len    )    ;  	[BUGGY]  printAndEncapsulate  (  value  ,  offset  ,  len  )  ;  [FE]    (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    print  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  newLine  true  [TYPE]  int  len  offset  [TYPE]  Appendable  out    [CONTEXT]    private  void  print  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  if  (  format  .  isEncapsulating  (  )  )  {  printAndEncapsulate  (  value  ,  offset  ,  len  )  ;  }  else  if  (  format  .  isEscaping  (  )  )  {  [ATTENTION]  printAndEncapsulate  (  value  ,  offset  ,  len  )    ;  }  else  {  printSep  (  )  ;  out  .  append  (  value  ,  offset  ,  offset  +  len  )  ;  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^135^^^^^131^140^
[REPLACE]    printAndEncapsulate    (    value,    offset,    len    )    ;  	[BUGGY]  printAndEscape  (  value  ,  offset  ,  len  )  ;  [FE]    AssertionFailedError    expected:<[   "x  ,  y   "]  ,  z>  but  was:<[x  assertEquals(   "   "  ,  format.format())      [METHOD]    print  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  newLine  true  [TYPE]  int  len  offset  [TYPE]  Appendable  out    [CONTEXT]    private  void  print  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  if  (  format  .  isEncapsulating  (  )  )  {  [ATTENTION]  printAndEscape  (  value  ,  offset  ,  len  )    ;  }  else  if  (  format  .  isEscaping  (  )  )  {  printAndEscape  (  value  ,  offset  ,  len  )  ;  }  else  {  printSep  (  )  ;  out  .  append  (  value  ,  offset  ,  offset  +  len  )  ;  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^133^^^^^131^140^
[REPLACE]    }    else    if    (    format    .    isEscaping    (    )    )    {  	[BUGGY]    if  (  format  .  isEscaping  (  )  )  {[FE]    AssertionFailedError    expected:<a  ,  [b]  ,  c>  but  was:<a  ,  [a  ,  b  ,  b  ,  c]  ,  c>  assertEquals(   "   "  ,  format.format())      [METHOD]    print  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  newLine  true  [TYPE]  int  len  offset  [TYPE]  Appendable  out    [CONTEXT]    private  void  print  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  if  (  format  .  isEncapsulating  (  )  )  {  printAndEncapsulate  (  value  ,  offset  ,  len  )  ;  [ATTENTION]  }if  (  format  .  isEscaping  (  )  )  {  printAndEscape  (  value  ,  offset  ,  len  )  ;  }  else  {  printSep  (  )  ;  out  .  append  (  value  ,  offset  ,  offset  +  len  )  ;  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^134^^^^^131^140^
[ADD]    printSep    (    )    ;  	[BUGGY]  [FE]    (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    print  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  newLine  true  [TYPE]  int  len  offset  [TYPE]  Appendable  out    [CONTEXT]    private  void  print  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  if  (  format  .  isEncapsulating  (  )  )  {  printAndEncapsulate  (  value  ,  offset  ,  len  )  ;  }  else  if  (  format  .  isEscaping  (  )  )  {  printAndEscape  (  value  ,  offset  ,  len  )  ;  }  else  {  [ATTENTION]  out  .  append  (  value  ,  offset  ,  offset  +  len  )  ;  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^137^^^^^131^140^
[REPLACE]    out    .    append    (    value,    offset,    offset    +    len    )    ;  	[BUGGY]  out  .  append  (  value  ,  offset  ,  offset  >  len  )  ;  [CE]  no  suitable  method  found  for  append(CharSequence  ,  int  ,  boolean)    [METHOD]    print  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  newLine  true  [TYPE]  int  len  offset  [TYPE]  Appendable  out    [CONTEXT]    private  void  print  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  if  (  format  .  isEncapsulating  (  )  )  {  printAndEncapsulate  (  value  ,  offset  ,  len  )  ;  }  else  if  (  format  .  isEscaping  (  )  )  {  printAndEscape  (  value  ,  offset  ,  len  )  ;  }  else  {  printSep  (  )  ;  [ATTENTION]  out  .  append  (  value  ,  offset  ,  offset>len  )    ;  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^138^^^^^131^140^
[REPLACE]    if    (    newLine    )    {  	[BUGGY]  if  (  !newLine  )  {[FE]    AssertionFailedError    expected:<[]a  ,  b  ,  c>  but  was:<[  ,  ]a  ,  b  ,  c>  assertEquals(   "   "  ,  format.format())      [METHOD]    printSep  [TYPE]  void  [PARAMETER]  [CLASS]  CSVPrinter    [TYPE]  CSVFormat  format  [TYPE]  boolean  false  newLine  true  [TYPE]  Appendable  out    [CONTEXT]    void  printSep  (  )  throws  IOException  {  [ATTENTION]  if  (  !newLine  )  {  newLine  =  false  ;  }  else  {  out  .  append  (  format  .  getDelimiter  (  )  )  ;  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^143^^^^^142^148^
[REPLACE]    out    .    append    (    format    .    getDelimiter    (    )    )    ;  	[BUGGY]  out  .  append  (  format  .  getEscape  (  )    )  ;  [FE]    AssertionFailedError    expected:<a[  ,  b  ,  ]c>  but  was:<a[  assertEquals(   "   "  ,  format.format())      [METHOD]    printSep  [TYPE]  void  [PARAMETER]  [CLASS]  CSVPrinter    [TYPE]  CSVFormat  format  [TYPE]  boolean  false  newLine  true  [TYPE]  Appendable  out    [CONTEXT]    void  printSep  (  )  throws  IOException  {  if  (  newLine  )  {  newLine  =  false  ;  }  else  {  [ATTENTION]  out  .  append  (  format  .  getEscape  (  )    )    ;  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^146^^^^^142^148^
[REPLACE]    out    .    append    (    format    .    getDelimiter    (    )    )    ;  	[BUGGY]  out  .  append  (  format  .  getEscape  (  )  )  ;  [FE]    AssertionFailedError    expected:<a[  ,  b  ,  ]c>  but  was:<a[  assertEquals(   "   "  ,  format.format())      [METHOD]    printSep  [TYPE]  void  [PARAMETER]  [CLASS]  CSVPrinter    [TYPE]  CSVFormat  format  [TYPE]  boolean  false  newLine  true  [TYPE]  Appendable  out    [CONTEXT]    void  printSep  (  )  throws  IOException  {  if  (  newLine  )  {  newLine  =  false  ;  }  else  {  [ATTENTION]  out  .  append  (  format  .  getEscape  (  )  )    ;  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^146^^^^^142^148^
[ADD]    out    .    append    (    format    .    getDelimiter    (    )    )    ;    }  	[BUGGY]  [CE]  illegal  start  of  expression    [METHOD]    printSep  [TYPE]  void  [PARAMETER]  [CLASS]  CSVPrinter    [TYPE]  CSVFormat  format  [TYPE]  boolean  false  newLine  true  [TYPE]  Appendable  out    [CONTEXT]    void  printSep  (  )  throws  IOException  {  if  (  newLine  )  {  newLine  =  false  ;  }  else  {  [ATTENTION]    }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^146^147^^^^142^148^
[REPLACE]    newLine    =    false;  	[BUGGY]  newLine  =  true  ;  [FE]    AssertionFailedError    expected:<a[  ,  b  ,  ]c>  but  was:<a[b]c>  assertEquals(   "   "  ,  format.format())      [METHOD]    printSep  [TYPE]  void  [PARAMETER]  [CLASS]  CSVPrinter    [TYPE]  CSVFormat  format  [TYPE]  boolean  false  newLine  true  [TYPE]  Appendable  out    [CONTEXT]    void  printSep  (  )  throws  IOException  {  if  (  newLine  )  {  [ATTENTION]  newLine  =  true  ;  }  else  {  out  .  append  (  format  .  getDelimiter  (  )  )  ;  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^144^^^^^142^148^
[REPLACE]    int    start    =    offset;  	[BUGGY]  int  start  =  start  ;  [CE]  variable  start  might  not  have  been  initialized    [METHOD]    printAndEscape  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  escape  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  newLine  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out    [CONTEXT]    void  printAndEscape  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  [ATTENTION]  int  start  =  start  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  escape  =  format  .  getEscape  (  )  ;    while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\r'  ||  c  =  =  '\n'  ||  c  =  =  delim  ||  c  =  =  escape  )  {    if  (  pos  >  start  )  {  out  .  append  (  value  ,  start  ,  pos  )  ;  }  if  (  c  =  =  '\n'  )  {  c  =  'n'  ;  }  else  if  (  c  =  =  '\r'  )  {  c  =  'r'  ;  }  out  .  append  (  escape  )  ;  out  .  append  (  c  )  ;    start  =  pos  +  1  ;  //  start  on  the  current  char  after  this  one  }  pos++  ;  }    if  (  pos  >  start  )  {  out  .  append  (  value  ,  start  ,  pos  )  ;  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^151^^^^^150^186^
[REPLACE]    int    pos    =    offset;  	[BUGGY]  int  pos  =  start  ;  [FE]    (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    printAndEscape  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  escape  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  newLine  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out    [CONTEXT]    void  printAndEscape  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  int  start  =  offset  ;  [ATTENTION]  int  pos  =  start  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  escape  =  format  .  getEscape  (  )  ;    while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\r'  ||  c  =  =  '\n'  ||  c  =  =  delim  ||  c  =  =  escape  )  {    if  (  pos  >  start  )  {  out  .  append  (  value  ,  start  ,  pos  )  ;  }  if  (  c  =  =  '\n'  )  {  c  =  'n'  ;  }  else  if  (  c  =  =  '\r'  )  {  c  =  'r'  ;  }  out  .  append  (  escape  )  ;  out  .  append  (  c  )  ;    start  =  pos  +  1  ;  //  start  on  the  current  char  after  this  one  }  pos++  ;  }    if  (  pos  >  start  )  {  out  .  append  (  value  ,  start  ,  pos  )  ;  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^152^^^^^150^186^
[REPLACE]    int    end    =    offset    +    len;  	[BUGGY]  int  end  =  offset  !  =    len  ;  [CE]  incompatible  types    [METHOD]    printAndEscape  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  escape  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  newLine  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out    [CONTEXT]    void  printAndEscape  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  int  start  =  offset  ;  int  pos  =  offset  ;  [ATTENTION]  int  end  =  offset!  =  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  escape  =  format  .  getEscape  (  )  ;    while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\r'  ||  c  =  =  '\n'  ||  c  =  =  delim  ||  c  =  =  escape  )  {    if  (  pos  >  start  )  {  out  .  append  (  value  ,  start  ,  pos  )  ;  }  if  (  c  =  =  '\n'  )  {  c  =  'n'  ;  }  else  if  (  c  =  =  '\r'  )  {  c  =  'r'  ;  }  out  .  append  (  escape  )  ;  out  .  append  (  c  )  ;    start  =  pos  +  1  ;  //  start  on  the  current  char  after  this  one  }  pos++  ;  }    if  (  pos  >  start  )  {  out  .  append  (  value  ,  start  ,  pos  )  ;  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^153^^^^^150^186^
[REPLACE]    printSep    (    )    ;  	[BUGGY]  out  .  append  (  '  '  )  ;  [FE]    (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    printAndEscape  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  escape  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  newLine  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out    [CONTEXT]    void  printAndEscape  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    [ATTENTION]  out  .  append  (  '  '  )    ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  escape  =  format  .  getEscape  (  )  ;    while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\r'  ||  c  =  =  '\n'  ||  c  =  =  delim  ||  c  =  =  escape  )  {    if  (  pos  >  start  )  {  out  .  append  (  value  ,  start  ,  pos  )  ;  }  if  (  c  =  =  '\n'  )  {  c  =  'n'  ;  }  else  if  (  c  =  =  '\r'  )  {  c  =  'r'  ;  }  out  .  append  (  escape  )  ;  out  .  append  (  c  )  ;    start  =  pos  +  1  ;  //  start  on  the  current  char  after  this  one  }  pos++  ;  }    if  (  pos  >  start  )  {  out  .  append  (  value  ,  start  ,  pos  )  ;  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^155^^^^^150^186^
[ADD]    printSep    (    )    ;  	[BUGGY]  [FE]    (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    printAndEscape  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  escape  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  newLine  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out    [CONTEXT]    void  printAndEscape  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    [ATTENTION]    char  delim  =  format  .  getDelimiter  (  )  ;  char  escape  =  format  .  getEscape  (  )  ;    while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\r'  ||  c  =  =  '\n'  ||  c  =  =  delim  ||  c  =  =  escape  )  {    if  (  pos  >  start  )  {  out  .  append  (  value  ,  start  ,  pos  )  ;  }  if  (  c  =  =  '\n'  )  {  c  =  'n'  ;  }  else  if  (  c  =  =  '\r'  )  {  c  =  'r'  ;  }  out  .  append  (  escape  )  ;  out  .  append  (  c  )  ;    start  =  pos  +  1  ;  //  start  on  the  current  char  after  this  one  }  pos++  ;  }    if  (  pos  >  start  )  {  out  .  append  (  value  ,  start  ,  pos  )  ;  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^155^^^^^150^186^
[REPLACE]    char    delim    =    format    .    getDelimiter    (    )    ;  	[BUGGY]  char  delim  =  format  .  getEscape  (  )    ;  [FE]    (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    printAndEscape  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  escape  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  newLine  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out    [CONTEXT]    void  printAndEscape  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    [ATTENTION]  char  delim  =  format  .  getEscape  (  )  ;  char  escape  =  format  .  getEscape  (  )  ;    while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\r'  ||  c  =  =  '\n'  ||  c  =  =  delim  ||  c  =  =  escape  )  {    if  (  pos  >  start  )  {  out  .  append  (  value  ,  start  ,  pos  )  ;  }  if  (  c  =  =  '\n'  )  {  c  =  'n'  ;  }  else  if  (  c  =  =  '\r'  )  {  c  =  'r'  ;  }  out  .  append  (  escape  )  ;  out  .  append  (  c  )  ;    start  =  pos  +  1  ;  //  start  on  the  current  char  after  this  one  }  pos++  ;  }    if  (  pos  >  start  )  {  out  .  append  (  value  ,  start  ,  pos  )  ;  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^157^^^^^150^186^
[REPLACE]    char    escape    =    format    .    getEscape    (    )    ;  	[BUGGY]  char  escape  =  format  .  getEncapsulator  (  )    ;  [FE]    (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    printAndEscape  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  escape  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  newLine  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out    [CONTEXT]    void  printAndEscape  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  [ATTENTION]  char  escape  =  format  .  getEncapsulator  (  )  ;    while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\r'  ||  c  =  =  '\n'  ||  c  =  =  delim  ||  c  =  =  escape  )  {    if  (  pos  >  start  )  {  out  .  append  (  value  ,  start  ,  pos  )  ;  }  if  (  c  =  =  '\n'  )  {  c  =  'n'  ;  }  else  if  (  c  =  =  '\r'  )  {  c  =  'r'  ;  }  out  .  append  (  escape  )  ;  out  .  append  (  c  )  ;    start  =  pos  +  1  ;  //  start  on  the  current  char  after  this  one  }  pos++  ;  }    if  (  pos  >  start  )  {  out  .  append  (  value  ,  start  ,  pos  )  ;  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^158^^^^^150^186^
[REPLACE]    while    (    pos    <    end    )    {  	[BUGGY]  while  (  pos    =  =    end  )  {[FE]    (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    printAndEscape  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  escape  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  newLine  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out    [CONTEXT]    void  printAndEscape  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  escape  =  format  .  getEscape  (  )  ;    [ATTENTION]  while  (  pos  =  =  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\r'  ||  c  =  =  '\n'  ||  c  =  =  delim  ||  c  =  =  escape  )  {    if  (  pos  >  start  )  {  out  .  append  (  value  ,  start  ,  pos  )  ;  }  if  (  c  =  =  '\n'  )  {  c  =  'n'  ;  }  else  if  (  c  =  =  '\r'  )  {  c  =  'r'  ;  }  out  .  append  (  escape  )  ;  out  .  append  (  c  )  ;    start  =  pos  +  1  ;  //  start  on  the  current  char  after  this  one  }  pos++  ;  }    if  (  pos  >  start  )  {  out  .  append  (  value  ,  start  ,  pos  )  ;  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^160^^^^^150^186^
[ADD]    while    (    pos    <    end    )    {    char    c    =    value    .    charAt    (    pos    )    ;  	[BUGGY]  [CE]  illegal  start  of  type    [METHOD]    printAndEscape  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  escape  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  newLine  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out    [CONTEXT]    void  printAndEscape  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  escape  =  format  .  getEscape  (  )  ;    [ATTENTION]    if  (  c  =  =  '\r'  ||  c  =  =  '\n'  ||  c  =  =  delim  ||  c  =  =  escape  )  {    if  (  pos  >  start  )  {  out  .  append  (  value  ,  start  ,  pos  )  ;  }  if  (  c  =  =  '\n'  )  {  c  =  'n'  ;  }  else  if  (  c  =  =  '\r'  )  {  c  =  'r'  ;  }  out  .  append  (  escape  )  ;  out  .  append  (  c  )  ;    start  =  pos  +  1  ;  //  start  on  the  current  char  after  this  one  }  pos++  ;  }    if  (  pos  >  start  )  {  out  .  append  (  value  ,  start  ,  pos  )  ;  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^160^161^^^^150^186^
[REPLACE]    if    (    c    ==    '\r'    ||    c    ==    '\n'    ||    c    ==    delim    ||    c    ==    escape    )    {  	[BUGGY]  if  (  c  =  =  '\n'  &&  c  =  =  delim  &&true  )  {[FE]    (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    printAndEscape  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  escape  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  newLine  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out    [CONTEXT]    void  printAndEscape  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  escape  =  format  .  getEscape  (  )  ;    while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  [ATTENTION]  if  (  c  =  =  '\n'  &&  c  =  =  delim  &&true  )  {    if  (  pos  >  start  )  {  out  .  append  (  value  ,  start  ,  pos  )  ;  }  if  (  c  =  =  '\n'  )  {  c  =  'n'  ;  }  else  if  (  c  =  =  '\r'  )  {  c  =  'r'  ;  }  out  .  append  (  escape  )  ;  out  .  append  (  c  )  ;    start  =  pos  +  1  ;  //  start  on  the  current  char  after  this  one  }  pos++  ;  }    if  (  pos  >  start  )  {  out  .  append  (  value  ,  start  ,  pos  )  ;  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^162^^^^^150^186^
[REPLACE]    if    (    pos    >    start    )    {  	[BUGGY]  if  (  pos  <  offset  )  {[FE]    (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    printAndEscape  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  escape  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  newLine  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out    [CONTEXT]    void  printAndEscape  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  escape  =  format  .  getEscape  (  )  ;    while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\r'  ||  c  =  =  '\n'  ||  c  =  =  delim  ||  c  =  =  escape  )  {    [ATTENTION]  if  (  pos<  offset  )  {  out  .  append  (  value  ,  start  ,  pos  )  ;  }  if  (  c  =  =  '\n'  )  {  c  =  'n'  ;  }  else  if  (  c  =  =  '\r'  )  {  c  =  'r'  ;  }  out  .  append  (  escape  )  ;  out  .  append  (  c  )  ;    start  =  pos  +  1  ;  //  start  on  the  current  char  after  this  one  }  pos++  ;  }    if  (  pos  >  start  )  {  out  .  append  (  value  ,  start  ,  pos  )  ;  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^164^^^^^150^186^
[REPLACE]    out    .    append    (    value,    start,    pos    )    ;  	[BUGGY]  out  .  append  (  value  )    ;  [FE]    (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    printAndEscape  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  escape  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  newLine  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out    [CONTEXT]    void  printAndEscape  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  escape  =  format  .  getEscape  (  )  ;    while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\r'  ||  c  =  =  '\n'  ||  c  =  =  delim  ||  c  =  =  escape  )  {    if  (  pos  >  start  )  {  [ATTENTION]  out  .  append  (  value  )  ;  }  if  (  c  =  =  '\n'  )  {  c  =  'n'  ;  }  else  if  (  c  =  =  '\r'  )  {  c  =  'r'  ;  }  out  .  append  (  escape  )  ;  out  .  append  (  c  )  ;    start  =  pos  +  1  ;  //  start  on  the  current  char  after  this  one  }  pos++  ;  }    if  (  pos  >  start  )  {  out  .  append  (  value  ,  start  ,  pos  )  ;  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^165^^^^^150^186^
[ADD]    out    .    append    (    value,    start,    pos    )    ;  	[BUGGY]  [FE]    (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    printAndEscape  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  escape  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  newLine  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out    [CONTEXT]    void  printAndEscape  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  escape  =  format  .  getEscape  (  )  ;    while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\r'  ||  c  =  =  '\n'  ||  c  =  =  delim  ||  c  =  =  escape  )  {    if  (  pos  >  start  )  {  [ATTENTION]  }  if  (  c  =  =  '\n'  )  {  c  =  'n'  ;  }  else  if  (  c  =  =  '\r'  )  {  c  =  'r'  ;  }  out  .  append  (  escape  )  ;  out  .  append  (  c  )  ;    start  =  pos  +  1  ;  //  start  on  the  current  char  after  this  one  }  pos++  ;  }    if  (  pos  >  start  )  {  out  .  append  (  value  ,  start  ,  pos  )  ;  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^165^^^^^150^186^
[REPLACE]    if    (    c    ==    '\n'    )    {  	[BUGGY]  if  (  c  ||  '\n'  )  {[CE]  bad  operand  types  for  binary  operator  '||'    [METHOD]    printAndEscape  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  escape  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  newLine  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out    [CONTEXT]    void  printAndEscape  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  escape  =  format  .  getEscape  (  )  ;    while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\r'  ||  c  =  =  '\n'  ||  c  =  =  delim  ||  c  =  =  escape  )  {    if  (  pos  >  start  )  {  out  .  append  (  value  ,  start  ,  pos  )  ;  }  [ATTENTION]  if  (  c||'\n'  )  {  c  =  'n'  ;  }  else  if  (  c  =  =  '\r'  )  {  c  =  'r'  ;  }  out  .  append  (  escape  )  ;  out  .  append  (  c  )  ;    start  =  pos  +  1  ;  //  start  on  the  current  char  after  this  one  }  pos++  ;  }    if  (  pos  >  start  )  {  out  .  append  (  value  ,  start  ,  pos  )  ;  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^167^^^^^150^186^
[ADD]    if    (    c    ==    '\n'    )    {    c    =    'n';    }    else    if    (    c    ==    '\r'    )    {    c    =    'r';    }  	[BUGGY]  c  =  'n'  ;  c  =  'r'  ;  [FE]    (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    printAndEscape  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  escape  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  newLine  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out    [CONTEXT]    void  printAndEscape  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  escape  =  format  .  getEscape  (  )  ;    while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\r'  ||  c  =  =  '\n'  ||  c  =  =  delim  ||  c  =  =  escape  )  {    if  (  pos  >  start  )  {  out  .  append  (  value  ,  start  ,  pos  )  ;  }  [ATTENTION]  c  =  'n'  ;  c  =  'r'  ;        out  .  append  (  escape  )  ;  out  .  append  (  c  )  ;    start  =  pos  +  1  ;  //  start  on  the  current  char  after  this  one  }  pos++  ;  }    if  (  pos  >  start  )  {  out  .  append  (  value  ,  start  ,  pos  )  ;  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^167^168^169^170^171^150^186^
[REPLACE]    }    else    if    (    c    ==    '\r'    )    {  	[BUGGY]    if  (  c  ||  '\r'  )  {[CE]  bad  operand  types  for  binary  operator  '||'    [METHOD]    printAndEscape  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  escape  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  newLine  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out    [CONTEXT]    void  printAndEscape  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  escape  =  format  .  getEscape  (  )  ;    while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\r'  ||  c  =  =  '\n'  ||  c  =  =  delim  ||  c  =  =  escape  )  {    if  (  pos  >  start  )  {  out  .  append  (  value  ,  start  ,  pos  )  ;  }  if  (  c  =  =  '\n'  )  {  c  =  'n'  ;  [ATTENTION]  }if  (  c||'\r'  )  {  c  =  'r'  ;  }  out  .  append  (  escape  )  ;  out  .  append  (  c  )  ;    start  =  pos  +  1  ;  //  start  on  the  current  char  after  this  one  }  pos++  ;  }    if  (  pos  >  start  )  {  out  .  append  (  value  ,  start  ,  pos  )  ;  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^169^^^^^150^186^
[REPLACE]    c    =    'r';  	[BUGGY]  c  =  'n'  ;    ;  [FE]    (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    printAndEscape  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  escape  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  newLine  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out    [CONTEXT]    void  printAndEscape  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  escape  =  format  .  getEscape  (  )  ;    while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\r'  ||  c  =  =  '\n'  ||  c  =  =  delim  ||  c  =  =  escape  )  {    if  (  pos  >  start  )  {  out  .  append  (  value  ,  start  ,  pos  )  ;  }  if  (  c  =  =  '\n'  )  {  c  =  'n'  ;  }  else  if  (  c  =  =  '\r'  )  {  [ATTENTION]  c  =  'n'  ;    ;  }  out  .  append  (  escape  )  ;  out  .  append  (  c  )  ;    start  =  pos  +  1  ;  //  start  on  the  current  char  after  this  one  }  pos++  ;  }    if  (  pos  >  start  )  {  out  .  append  (  value  ,  start  ,  pos  )  ;  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^170^^^^^150^186^
[REPLACE]    c    =    'n';  	[BUGGY]  c  =  'r'  ;    ;  [FE]    (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    printAndEscape  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  escape  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  newLine  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out    [CONTEXT]    void  printAndEscape  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  escape  =  format  .  getEscape  (  )  ;    while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\r'  ||  c  =  =  '\n'  ||  c  =  =  delim  ||  c  =  =  escape  )  {    if  (  pos  >  start  )  {  out  .  append  (  value  ,  start  ,  pos  )  ;  }  if  (  c  =  =  '\n'  )  {  [ATTENTION]  c  =  'r'  ;    ;  }  else  if  (  c  =  =  '\r'  )  {  c  =  'r'  ;  }  out  .  append  (  escape  )  ;  out  .  append  (  c  )  ;    start  =  pos  +  1  ;  //  start  on  the  current  char  after  this  one  }  pos++  ;  }    if  (  pos  >  start  )  {  out  .  append  (  value  ,  start  ,  pos  )  ;  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^168^^^^^150^186^
[REPLACE]    }    else    if    (    c    ==    '\r'    )    {  	[BUGGY]    else  {[FE]    (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    printAndEscape  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  escape  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  newLine  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out    [CONTEXT]    void  printAndEscape  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  escape  =  format  .  getEscape  (  )  ;    while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\r'  ||  c  =  =  '\n'  ||  c  =  =  delim  ||  c  =  =  escape  )  {    if  (  pos  >  start  )  {  out  .  append  (  value  ,  start  ,  pos  )  ;  }  if  (  c  =  =  '\n'  )  {  c  =  'n'  ;  [ATTENTION]  }else  {  c  =  'r'  ;  }  out  .  append  (  escape  )  ;  out  .  append  (  c  )  ;    start  =  pos  +  1  ;  //  start  on  the  current  char  after  this  one  }  pos++  ;  }    if  (  pos  >  start  )  {  out  .  append  (  value  ,  start  ,  pos  )  ;  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^169^^^^^150^186^
[REPLACE]    start    =    pos    +    1;  	[BUGGY]  start  =  pos  !  =    2  ;  [CE]  incompatible  types    [METHOD]    printAndEscape  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  escape  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  newLine  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out    [CONTEXT]    void  printAndEscape  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  escape  =  format  .  getEscape  (  )  ;    while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\r'  ||  c  =  =  '\n'  ||  c  =  =  delim  ||  c  =  =  escape  )  {    if  (  pos  >  start  )  {  out  .  append  (  value  ,  start  ,  pos  )  ;  }  if  (  c  =  =  '\n'  )  {  c  =  'n'  ;  }  else  if  (  c  =  =  '\r'  )  {  c  =  'r'  ;  }  out  .  append  (  escape  )  ;  out  .  append  (  c  )  ;    [ATTENTION]  start  =  pos!  =  2  ;  }  pos++  ;  }    if  (  pos  >  start  )  {  out  .  append  (  value  ,  start  ,  pos  )  ;  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^176^^^^^150^186^
[REPLACE]    if    (    pos    >    start    )    {  	[BUGGY]  if  (  pos  >  =  offset  )  {[FE]    (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    printAndEscape  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  escape  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  newLine  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out    [CONTEXT]    void  printAndEscape  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  escape  =  format  .  getEscape  (  )  ;    while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\r'  ||  c  =  =  '\n'  ||  c  =  =  delim  ||  c  =  =  escape  )  {    [ATTENTION]  if  (  pos>  =  offset  )  {  out  .  append  (  value  ,  start  ,  pos  )  ;  }  if  (  c  =  =  '\n'  )  {  c  =  'n'  ;  }  else  if  (  c  =  =  '\r'  )  {  c  =  'r'  ;  }  out  .  append  (  escape  )  ;  out  .  append  (  c  )  ;    start  =  pos  +  1  ;  //  start  on  the  current  char  after  this  one  }  pos++  ;  }    if  (  pos  >  start  )  {  out  .  append  (  value  ,  start  ,  pos  )  ;  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^164^^^^^150^186^
[REPLACE]    out    .    append    (    value,    start,    pos    )    ;  	[BUGGY]  out  .  append  (  value  ,  offset  ,  pos  )  ;  [FE]    (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    printAndEscape  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  escape  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  newLine  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out    [CONTEXT]    void  printAndEscape  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  escape  =  format  .  getEscape  (  )  ;    while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\r'  ||  c  =  =  '\n'  ||  c  =  =  delim  ||  c  =  =  escape  )  {    if  (  pos  >  start  )  {  [ATTENTION]  out  .  append  (  value  ,  offset  ,  pos  )    ;  }  if  (  c  =  =  '\n'  )  {  c  =  'n'  ;  }  else  if  (  c  =  =  '\r'  )  {  c  =  'r'  ;  }  out  .  append  (  escape  )  ;  out  .  append  (  c  )  ;    start  =  pos  +  1  ;  //  start  on  the  current  char  after  this  one  }  pos++  ;  }    if  (  pos  >  start  )  {  out  .  append  (  value  ,  start  ,  pos  )  ;  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^165^^^^^150^186^
[ADD]    if    (    c    ==    '\n'    )    {    c    =    'n';    }    else    if    (    c    ==    '\r'    )    {    c    =    'r';    }  	[BUGGY]  [FE]    (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    printAndEscape  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  escape  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  newLine  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out    [CONTEXT]    void  printAndEscape  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  escape  =  format  .  getEscape  (  )  ;    while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\r'  ||  c  =  =  '\n'  ||  c  =  =  delim  ||  c  =  =  escape  )  {    if  (  pos  >  start  )  {  out  .  append  (  value  ,  start  ,  pos  )  ;  }  [ATTENTION]        out  .  append  (  escape  )  ;  out  .  append  (  c  )  ;    start  =  pos  +  1  ;  //  start  on  the  current  char  after  this  one  }  pos++  ;  }    if  (  pos  >  start  )  {  out  .  append  (  value  ,  start  ,  pos  )  ;  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^167^168^169^170^171^150^186^
[ADD]    else    if    (    c    ==    '\r'    )    {    c    =    'r';    }  	[BUGGY]    c  =  'r'  ;  [FE]    (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    printAndEscape  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  escape  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  newLine  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out    [CONTEXT]    void  printAndEscape  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  escape  =  format  .  getEscape  (  )  ;    while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\r'  ||  c  =  =  '\n'  ||  c  =  =  delim  ||  c  =  =  escape  )  {    if  (  pos  >  start  )  {  out  .  append  (  value  ,  start  ,  pos  )  ;  }  if  (  c  =  =  '\n'  )  {  c  =  'n'  ;  [ATTENTION]  }  c  =  'r'  ;      out  .  append  (  escape  )  ;  out  .  append  (  c  )  ;    start  =  pos  +  1  ;  //  start  on  the  current  char  after  this  one  }  pos++  ;  }    if  (  pos  >  start  )  {  out  .  append  (  value  ,  start  ,  pos  )  ;  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^169^170^171^^^150^186^
[ADD]    c    =    'r';  	[BUGGY]  [FE]    (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    printAndEscape  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  escape  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  newLine  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out    [CONTEXT]    void  printAndEscape  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  escape  =  format  .  getEscape  (  )  ;    while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\r'  ||  c  =  =  '\n'  ||  c  =  =  delim  ||  c  =  =  escape  )  {    if  (  pos  >  start  )  {  out  .  append  (  value  ,  start  ,  pos  )  ;  }  if  (  c  =  =  '\n'  )  {  c  =  'n'  ;  }  else  if  (  c  =  =  '\r'  )  {  [ATTENTION]  }  out  .  append  (  escape  )  ;  out  .  append  (  c  )  ;    start  =  pos  +  1  ;  //  start  on  the  current  char  after  this  one  }  pos++  ;  }    if  (  pos  >  start  )  {  out  .  append  (  value  ,  start  ,  pos  )  ;  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^170^^^^^150^186^
[REPLACE]    }    else    if    (    c    ==    '\r'    )    {  	[BUGGY]  else  if  (  c  &&  '\r'  )  {[CE]  bad  operand  types  for  binary  operator  '&&'    [METHOD]    printAndEscape  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  escape  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  newLine  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out    [CONTEXT]    void  printAndEscape  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  escape  =  format  .  getEscape  (  )  ;    while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\r'  ||  c  =  =  '\n'  ||  c  =  =  delim  ||  c  =  =  escape  )  {    if  (  pos  >  start  )  {  out  .  append  (  value  ,  start  ,  pos  )  ;  }  if  (  c  =  =  '\n'  )  {  c  =  'n'  ;  [ATTENTION]  }  else  if  (  c&&'\r'  )  {  c  =  'r'  ;  }  out  .  append  (  escape  )  ;  out  .  append  (  c  )  ;    start  =  pos  +  1  ;  //  start  on  the  current  char  after  this  one  }  pos++  ;  }    if  (  pos  >  start  )  {  out  .  append  (  value  ,  start  ,  pos  )  ;  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^169^^^^^150^186^
[REPLACE]    start    =    pos    +    1;  	[BUGGY]  start  =  offset  +  1  ;  [FE]    (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    printAndEscape  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  escape  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  newLine  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out    [CONTEXT]    void  printAndEscape  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  escape  =  format  .  getEscape  (  )  ;    while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\r'  ||  c  =  =  '\n'  ||  c  =  =  delim  ||  c  =  =  escape  )  {    if  (  pos  >  start  )  {  out  .  append  (  value  ,  start  ,  pos  )  ;  }  if  (  c  =  =  '\n'  )  {  c  =  'n'  ;  }  else  if  (  c  =  =  '\r'  )  {  c  =  'r'  ;  }  out  .  append  (  escape  )  ;  out  .  append  (  c  )  ;    [ATTENTION]  start  =  offset  +  1  ;  }  pos++  ;  }    if  (  pos  >  start  )  {  out  .  append  (  value  ,  start  ,  pos  )  ;  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^176^^^^^150^186^
[REPLACE]    char    c    =    value    .    charAt    (    pos    )    ;  	[BUGGY]  char  c  =  value  .  charAt  (  offset  )  ;  [FE]    (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    printAndEscape  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  escape  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  newLine  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out    [CONTEXT]    void  printAndEscape  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  escape  =  format  .  getEscape  (  )  ;    while  (  pos  <  end  )  {  [ATTENTION]  char  c  =  value  .  charAt  (  offset  )    ;  if  (  c  =  =  '\r'  ||  c  =  =  '\n'  ||  c  =  =  delim  ||  c  =  =  escape  )  {    if  (  pos  >  start  )  {  out  .  append  (  value  ,  start  ,  pos  )  ;  }  if  (  c  =  =  '\n'  )  {  c  =  'n'  ;  }  else  if  (  c  =  =  '\r'  )  {  c  =  'r'  ;  }  out  .  append  (  escape  )  ;  out  .  append  (  c  )  ;    start  =  pos  +  1  ;  //  start  on  the  current  char  after  this  one  }  pos++  ;  }    if  (  pos  >  start  )  {  out  .  append  (  value  ,  start  ,  pos  )  ;  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^161^^^^^150^186^
[REPLACE]    if    (    c    ==    '\r'    ||    c    ==    '\n'    ||    c    ==    delim    ||    c    ==    escape    )    {  	[BUGGY]  if  (  c  =  =  '\r'  )  {[FE]    (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    printAndEscape  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  escape  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  newLine  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out    [CONTEXT]    void  printAndEscape  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  escape  =  format  .  getEscape  (  )  ;    while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  [ATTENTION]  if  (  c  =  =  '\r'  )  {    if  (  pos  >  start  )  {  out  .  append  (  value  ,  start  ,  pos  )  ;  }  if  (  c  =  =  '\n'  )  {  c  =  'n'  ;  }  else  if  (  c  =  =  '\r'  )  {  c  =  'r'  ;  }  out  .  append  (  escape  )  ;  out  .  append  (  c  )  ;    start  =  pos  +  1  ;  //  start  on  the  current  char  after  this  one  }  pos++  ;  }    if  (  pos  >  start  )  {  out  .  append  (  value  ,  start  ,  pos  )  ;  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^162^^^^^150^186^
[ADD]    if    (    c    ==    '\r'    ||    c    ==    '\n'    ||    c    ==    delim    ||    c    ==    escape    )    {    if    (    pos    >    start    )    {    out    .    append    (    value,    start,    pos    )    ;    }  	[BUGGY]  [CE]  illegal  start  of  type    [METHOD]    printAndEscape  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  escape  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  newLine  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out    [CONTEXT]    void  printAndEscape  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  escape  =  format  .  getEscape  (  )  ;    while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  [ATTENTION]      if  (  c  =  =  '\n'  )  {  c  =  'n'  ;  }  else  if  (  c  =  =  '\r'  )  {  c  =  'r'  ;  }  out  .  append  (  escape  )  ;  out  .  append  (  c  )  ;    start  =  pos  +  1  ;  //  start  on  the  current  char  after  this  one  }  pos++  ;  }    if  (  pos  >  start  )  {  out  .  append  (  value  ,  start  ,  pos  )  ;  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^162^163^164^165^166^150^186^
[REPLACE]    if    (    pos    >    start    )    {  	[BUGGY]  if  (  pos  <  start  )  {[FE]    (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    printAndEscape  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  escape  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  newLine  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out    [CONTEXT]    void  printAndEscape  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  escape  =  format  .  getEscape  (  )  ;    while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\r'  ||  c  =  =  '\n'  ||  c  =  =  delim  ||  c  =  =  escape  )  {    [ATTENTION]  if  (  pos<start  )  {  out  .  append  (  value  ,  start  ,  pos  )  ;  }  if  (  c  =  =  '\n'  )  {  c  =  'n'  ;  }  else  if  (  c  =  =  '\r'  )  {  c  =  'r'  ;  }  out  .  append  (  escape  )  ;  out  .  append  (  c  )  ;    start  =  pos  +  1  ;  //  start  on  the  current  char  after  this  one  }  pos++  ;  }    if  (  pos  >  start  )  {  out  .  append  (  value  ,  start  ,  pos  )  ;  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^164^^^^^150^186^
[REMOVE]      	[BUGGY]  if  (  c  =  =  encapsulator  )  {      out  .  append  (  value  ,  start  ,    (  pos  +  1  )  )  ;      start  =  pos  ;  }[CE]  cannot  find  symbol  encapsulator    [METHOD]    printAndEscape  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  escape  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  newLine  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out    [CONTEXT]    void  printAndEscape  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  escape  =  format  .  getEscape  (  )  ;    while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\r'  ||  c  =  =  '\n'  ||  c  =  =  delim  ||  c  =  =  escape  )  {    [ATTENTION]  if  (  pos  >  start  )  {  if  (  c  =  =  encapsulator  )  {  out  .  append  (  value  ,  start  ,  (  pos  +  1  )  )    ;  start  =  pos  ;  }out  .  append  (  value  ,  start  ,  pos  )  ;  }  if  (  c  =  =  '\n'  )  {  c  =  'n'  ;  }  else  if  (  c  =  =  '\r'  )  {  c  =  'r'  ;  }  out  .  append  (  escape  )  ;  out  .  append  (  c  )  ;    start  =  pos  +  1  ;  //  start  on  the  current  char  after  this  one  }  pos++  ;  }    if  (  pos  >  start  )  {  out  .  append  (  value  ,  start  ,  pos  )  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^164^^^^^150^186^
[REPLACE]    if    (    c    ==    '\n'    )    {  	[BUGGY]  if  (  escape  !  =    '\n'  )  {[FE]    (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    printAndEscape  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  escape  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  newLine  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out    [CONTEXT]    void  printAndEscape  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  escape  =  format  .  getEscape  (  )  ;    while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\r'  ||  c  =  =  '\n'  ||  c  =  =  delim  ||  c  =  =  escape  )  {    if  (  pos  >  start  )  {  out  .  append  (  value  ,  start  ,  pos  )  ;  }  [ATTENTION]  if  (  escape!  =  '\n'  )  {  c  =  'n'  ;  }  else  if  (  c  =  =  '\r'  )  {  c  =  'r'  ;  }  out  .  append  (  escape  )  ;  out  .  append  (  c  )  ;    start  =  pos  +  1  ;  //  start  on  the  current  char  after  this  one  }  pos++  ;  }    if  (  pos  >  start  )  {  out  .  append  (  value  ,  start  ,  pos  )  ;  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^167^^^^^150^186^
[ADD]    c    =    'n';  	[BUGGY]  [FE]    (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    printAndEscape  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  escape  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  newLine  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out    [CONTEXT]    void  printAndEscape  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  escape  =  format  .  getEscape  (  )  ;    while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\r'  ||  c  =  =  '\n'  ||  c  =  =  delim  ||  c  =  =  escape  )  {    if  (  pos  >  start  )  {  out  .  append  (  value  ,  start  ,  pos  )  ;  }  if  (  c  =  =  '\n'  )  {  [ATTENTION]  }  else  if  (  c  =  =  '\r'  )  {  c  =  'r'  ;  }  out  .  append  (  escape  )  ;  out  .  append  (  c  )  ;    start  =  pos  +  1  ;  //  start  on  the  current  char  after  this  one  }  pos++  ;  }    if  (  pos  >  start  )  {  out  .  append  (  value  ,  start  ,  pos  )  ;  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^168^^^^^150^186^
[REPLACE]    start    =    pos    +    1;  	[BUGGY]  start  =  pos  +offset  ;  [FE]    (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    printAndEscape  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  escape  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  newLine  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out    [CONTEXT]    void  printAndEscape  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  escape  =  format  .  getEscape  (  )  ;    while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\r'  ||  c  =  =  '\n'  ||  c  =  =  delim  ||  c  =  =  escape  )  {    if  (  pos  >  start  )  {  out  .  append  (  value  ,  start  ,  pos  )  ;  }  if  (  c  =  =  '\n'  )  {  c  =  'n'  ;  }  else  if  (  c  =  =  '\r'  )  {  c  =  'r'  ;  }  out  .  append  (  escape  )  ;  out  .  append  (  c  )  ;    [ATTENTION]  start  =  pos  +offset  ;  }  pos++  ;  }    if  (  pos  >  start  )  {  out  .  append  (  value  ,  start  ,  pos  )  ;  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^176^^^^^150^186^
[REPLACE]    if    (    pos    >    start    )    {  	[BUGGY]  if  (  pos    =  =    start  )  {[FE]    (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    printAndEscape  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  escape  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  newLine  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out    [CONTEXT]    void  printAndEscape  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  escape  =  format  .  getEscape  (  )  ;    while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\r'  ||  c  =  =  '\n'  ||  c  =  =  delim  ||  c  =  =  escape  )  {    [ATTENTION]  if  (  pos  =  =  start  )  {  out  .  append  (  value  ,  start  ,  pos  )  ;  }  if  (  c  =  =  '\n'  )  {  c  =  'n'  ;  }  else  if  (  c  =  =  '\r'  )  {  c  =  'r'  ;  }  out  .  append  (  escape  )  ;  out  .  append  (  c  )  ;    start  =  pos  +  1  ;  //  start  on  the  current  char  after  this  one  }  pos++  ;  }    if  (  pos  >  start  )  {  out  .  append  (  value  ,  start  ,  pos  )  ;  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^164^^^^^150^186^
[REPLACE]    out    .    append    (    value,    start,    pos    )    ;  	[BUGGY]  out  .  append  (  value  ,  start  ,  offset  )  ;  [FE]    (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    printAndEscape  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  escape  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  newLine  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out    [CONTEXT]    void  printAndEscape  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  escape  =  format  .  getEscape  (  )  ;    while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\r'  ||  c  =  =  '\n'  ||  c  =  =  delim  ||  c  =  =  escape  )  {    if  (  pos  >  start  )  {  [ATTENTION]  out  .  append  (  value  ,  start  ,  offset  )    ;  }  if  (  c  =  =  '\n'  )  {  c  =  'n'  ;  }  else  if  (  c  =  =  '\r'  )  {  c  =  'r'  ;  }  out  .  append  (  escape  )  ;  out  .  append  (  c  )  ;    start  =  pos  +  1  ;  //  start  on  the  current  char  after  this  one  }  pos++  ;  }    if  (  pos  >  start  )  {  out  .  append  (  value  ,  start  ,  pos  )  ;  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^165^^^^^150^186^
[REPLACE]    if    (    c    ==    '\n'    )    {  	[BUGGY]  if  (escape  ||  '\n'  )  {[CE]  bad  operand  types  for  binary  operator  '||'    [METHOD]    printAndEscape  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  escape  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  newLine  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out    [CONTEXT]    void  printAndEscape  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  escape  =  format  .  getEscape  (  )  ;    while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\r'  ||  c  =  =  '\n'  ||  c  =  =  delim  ||  c  =  =  escape  )  {    if  (  pos  >  start  )  {  out  .  append  (  value  ,  start  ,  pos  )  ;  }  [ATTENTION]  if  (  escape||'\n'  )  {  c  =  'n'  ;  }  else  if  (  c  =  =  '\r'  )  {  c  =  'r'  ;  }  out  .  append  (  escape  )  ;  out  .  append  (  c  )  ;    start  =  pos  +  1  ;  //  start  on  the  current  char  after  this  one  }  pos++  ;  }    if  (  pos  >  start  )  {  out  .  append  (  value  ,  start  ,  pos  )  ;  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^167^^^^^150^186^
[REPLACE]    }    else    if    (    c    ==    '\r'    )    {  	[BUGGY]    if  (escape  !  =    '\r'  )  {[FE]    (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    printAndEscape  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  escape  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  newLine  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out    [CONTEXT]    void  printAndEscape  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  escape  =  format  .  getEscape  (  )  ;    while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\r'  ||  c  =  =  '\n'  ||  c  =  =  delim  ||  c  =  =  escape  )  {    if  (  pos  >  start  )  {  out  .  append  (  value  ,  start  ,  pos  )  ;  }  if  (  c  =  =  '\n'  )  {  c  =  'n'  ;  [ATTENTION]  }if  (  escape!  =  '\r'  )  {  c  =  'r'  ;  }  out  .  append  (  escape  )  ;  out  .  append  (  c  )  ;    start  =  pos  +  1  ;  //  start  on  the  current  char  after  this  one  }  pos++  ;  }    if  (  pos  >  start  )  {  out  .  append  (  value  ,  start  ,  pos  )  ;  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^169^^^^^150^186^
[REPLACE]    start    =    pos    +    1;  	[BUGGY]  start  =  pos  ;    ;  [FE]    (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    printAndEscape  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  escape  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  newLine  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out    [CONTEXT]    void  printAndEscape  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  escape  =  format  .  getEscape  (  )  ;    while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\r'  ||  c  =  =  '\n'  ||  c  =  =  delim  ||  c  =  =  escape  )  {    if  (  pos  >  start  )  {  out  .  append  (  value  ,  start  ,  pos  )  ;  }  if  (  c  =  =  '\n'  )  {  c  =  'n'  ;  }  else  if  (  c  =  =  '\r'  )  {  c  =  'r'  ;  }  out  .  append  (  escape  )  ;  out  .  append  (  c  )  ;    [ATTENTION]  start  =  pos  ;    ;  }  pos++  ;  }    if  (  pos  >  start  )  {  out  .  append  (  value  ,  start  ,  pos  )  ;  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^176^^^^^150^186^
[REPLACE]    char    c    =    value    .    charAt    (    pos    )    ;  	[BUGGY]  for  (  String  value  :  values  )  {  print  (  value  )  ;  [CE]  illegal  start  of  expression    [METHOD]    printAndEscape  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  escape  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  newLine  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out    [CONTEXT]    void  printAndEscape  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  escape  =  format  .  getEscape  (  )  ;    while  (  pos  <  end  )  {  [ATTENTION]  for  (  String  value  :  values  )  {  print  (  value  )    ;  if  (  c  =  =  '\r'  ||  c  =  =  '\n'  ||  c  =  =  delim  ||  c  =  =  escape  )  {    if  (  pos  >  start  )  {  out  .  append  (  value  ,  start  ,  pos  )  ;  }  if  (  c  =  =  '\n'  )  {  c  =  'n'  ;  }  else  if  (  c  =  =  '\r'  )  {  c  =  'r'  ;  }  out  .  append  (  escape  )  ;  out  .  append  (  c  )  ;    start  =  pos  +  1  ;  //  start  on  the  current  char  after  this  one  }  pos++  ;  }    if  (  pos  >  start  )  {  out  .  append  (  value  ,  start  ,  pos  )  ;  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^161^^^^^150^186^
[ADD]    char    c    =    value    .    charAt    (    pos    )    ;  	[BUGGY]  [CE]  cannot  find  symbol  c    [METHOD]    printAndEscape  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  escape  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  newLine  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out    [CONTEXT]    void  printAndEscape  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  escape  =  format  .  getEscape  (  )  ;    while  (  pos  <  end  )  {  [ATTENTION]  if  (  c  =  =  '\r'  ||  c  =  =  '\n'  ||  c  =  =  delim  ||  c  =  =  escape  )  {    if  (  pos  >  start  )  {  out  .  append  (  value  ,  start  ,  pos  )  ;  }  if  (  c  =  =  '\n'  )  {  c  =  'n'  ;  }  else  if  (  c  =  =  '\r'  )  {  c  =  'r'  ;  }  out  .  append  (  escape  )  ;  out  .  append  (  c  )  ;    start  =  pos  +  1  ;  //  start  on  the  current  char  after  this  one  }  pos++  ;  }    if  (  pos  >  start  )  {  out  .  append  (  value  ,  start  ,  pos  )  ;  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^161^^^^^150^186^
[REPLACE]    if    (    pos    >    start    )    {  	[BUGGY]  if  (offset    =  =    start  )  {[FE]    (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    printAndEscape  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  escape  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  newLine  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out    [CONTEXT]    void  printAndEscape  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  escape  =  format  .  getEscape  (  )  ;    while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\r'  ||  c  =  =  '\n'  ||  c  =  =  delim  ||  c  =  =  escape  )  {    if  (  pos  >  start  )  {  out  .  append  (  value  ,  start  ,  pos  )  ;  }  if  (  c  =  =  '\n'  )  {  c  =  'n'  ;  }  else  if  (  c  =  =  '\r'  )  {  c  =  'r'  ;  }  out  .  append  (  escape  )  ;  out  .  append  (  c  )  ;    start  =  pos  +  1  ;  //  start  on  the  current  char  after  this  one  }  pos++  ;  }    [ATTENTION]  if  (  offset  =  =  start  )  {  out  .  append  (  value  ,  start  ,  pos  )  ;  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^183^^^^^150^186^
[REPLACE]    out    .    append    (    value,    start,    pos    )    ;  	[BUGGY]  out  .  append  (  value  ,  start  ,  end  )  ;  [FE]    (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    printAndEscape  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  escape  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  newLine  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out    [CONTEXT]    void  printAndEscape  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  escape  =  format  .  getEscape  (  )  ;    while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\r'  ||  c  =  =  '\n'  ||  c  =  =  delim  ||  c  =  =  escape  )  {    if  (  pos  >  start  )  {  out  .  append  (  value  ,  start  ,  pos  )  ;  }  if  (  c  =  =  '\n'  )  {  c  =  'n'  ;  }  else  if  (  c  =  =  '\r'  )  {  c  =  'r'  ;  }  out  .  append  (  escape  )  ;  out  .  append  (  c  )  ;    start  =  pos  +  1  ;  //  start  on  the  current  char  after  this  one  }  pos++  ;  }    if  (  pos  >  start  )  {  [ATTENTION]  out  .  append  (  value  ,  start  ,  end  )    ;  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^184^^^^^150^186^
[ADD]    out    .    append    (    value,    start,    pos    )    ;  	[BUGGY]  [FE]    (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    printAndEscape  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  escape  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  newLine  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out    [CONTEXT]    void  printAndEscape  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  escape  =  format  .  getEscape  (  )  ;    while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\r'  ||  c  =  =  '\n'  ||  c  =  =  delim  ||  c  =  =  escape  )  {    if  (  pos  >  start  )  {  out  .  append  (  value  ,  start  ,  pos  )  ;  }  if  (  c  =  =  '\n'  )  {  c  =  'n'  ;  }  else  if  (  c  =  =  '\r'  )  {  c  =  'r'  ;  }  out  .  append  (  escape  )  ;  out  .  append  (  c  )  ;    start  =  pos  +  1  ;  //  start  on  the  current  char  after  this  one  }  pos++  ;  }    if  (  pos  >  start  )  {  [ATTENTION]  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^184^^^^^150^186^
[REPLACE]    boolean    first    =    newLine;  	[BUGGY]  boolean  quote  =  false  ;  [CE]  variable  quote  is  already  defined  in  method  printAndEncapsulate(CharSequence  ,  int  ,  int)    [METHOD]    printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out    [CONTEXT]    void  printAndEncapsulate  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  [ATTENTION]  boolean  quote  =  false  ;  boolean  quote  =  false  ;  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  encapsulator  =  format  .  getEncapsulator  (  )  ;    if  (  len  <  =  0  )  {          if  (  first  )  {  quote  =  true  ;  }  }  else  {  char  c  =  value  .  charAt  (  pos  )  ;      if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )  ||  (  c  >  'z'  )  )  )  {  quote  =  true  ;    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }  }  if  (  !quote  )  {    out  .  append  (  value  ,  start  ,  end  )  ;  return  ;  }    out  .  append  (  encapsulator  )  ;        while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  encapsulator  )  {      out  .  append  (  value  ,  start  ,  pos  +  1  )  ;      start  =  pos  ;  }  pos++  ;  }    out  .  append  (  value  ,  start  ,  pos  )  ;  out  .  append  (  encapsulator  )  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^189^^^^^188^275^
[REPLACE]    boolean    quote    =    false;  	[BUGGY]  boolean  quote  =  true  ;  [FE]    AssertionFailedError    expected:<[a  ,  b  ,  c]>  but  was:<[   "a   "  ,     "b   "  ,     "c   "]>  assertEquals(   "   "  ,  format.format())      [METHOD]    printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out    [CONTEXT]    void  printAndEncapsulate  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  boolean  first  =  newLine  ;  //  is  this  the  first  value  on  this  line?  [ATTENTION]  boolean  quote  =  true  ;  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  encapsulator  =  format  .  getEncapsulator  (  )  ;    if  (  len  <  =  0  )  {          if  (  first  )  {  quote  =  true  ;  }  }  else  {  char  c  =  value  .  charAt  (  pos  )  ;      if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )  ||  (  c  >  'z'  )  )  )  {  quote  =  true  ;    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }  }  if  (  !quote  )  {    out  .  append  (  value  ,  start  ,  end  )  ;  return  ;  }    out  .  append  (  encapsulator  )  ;        while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  encapsulator  )  {      out  .  append  (  value  ,  start  ,  pos  +  1  )  ;      start  =  pos  ;  }  pos++  ;  }    out  .  append  (  value  ,  start  ,  pos  )  ;  out  .  append  (  encapsulator  )  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^190^^^^^188^275^
[REPLACE]    int    start    =    offset;  	[BUGGY]  int  pos  =  offset  ;  [CE]  variable  pos  is  already  defined  in  method  printAndEncapsulate(CharSequence  ,  int  ,  int)    [METHOD]    printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out    [CONTEXT]    void  printAndEncapsulate  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  boolean  first  =  newLine  ;  //  is  this  the  first  value  on  this  line?  boolean  quote  =  false  ;  [ATTENTION]  int  pos  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  encapsulator  =  format  .  getEncapsulator  (  )  ;    if  (  len  <  =  0  )  {          if  (  first  )  {  quote  =  true  ;  }  }  else  {  char  c  =  value  .  charAt  (  pos  )  ;      if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )  ||  (  c  >  'z'  )  )  )  {  quote  =  true  ;    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }  }  if  (  !quote  )  {    out  .  append  (  value  ,  start  ,  end  )  ;  return  ;  }    out  .  append  (  encapsulator  )  ;        while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  encapsulator  )  {      out  .  append  (  value  ,  start  ,  pos  +  1  )  ;      start  =  pos  ;  }  pos++  ;  }    out  .  append  (  value  ,  start  ,  pos  )  ;  out  .  append  (  encapsulator  )  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^191^^^^^188^275^
[REPLACE]    int    pos    =    offset;  	[BUGGY]  int  pos  =  start  ;  [FE]    (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out    [CONTEXT]    void  printAndEncapsulate  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  boolean  first  =  newLine  ;  //  is  this  the  first  value  on  this  line?  boolean  quote  =  false  ;  int  start  =  offset  ;  [ATTENTION]  int  pos  =  start  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  encapsulator  =  format  .  getEncapsulator  (  )  ;    if  (  len  <  =  0  )  {          if  (  first  )  {  quote  =  true  ;  }  }  else  {  char  c  =  value  .  charAt  (  pos  )  ;      if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )  ||  (  c  >  'z'  )  )  )  {  quote  =  true  ;    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }  }  if  (  !quote  )  {    out  .  append  (  value  ,  start  ,  end  )  ;  return  ;  }    out  .  append  (  encapsulator  )  ;        while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  encapsulator  )  {      out  .  append  (  value  ,  start  ,  pos  +  1  )  ;      start  =  pos  ;  }  pos++  ;  }    out  .  append  (  value  ,  start  ,  pos  )  ;  out  .  append  (  encapsulator  )  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^192^^^^^188^275^
[REPLACE]    int    end    =    offset    +    len;  	[BUGGY]  int  end  =  start  +start  ;  [FE]    String  index  out  of  range:  -1  assertEquals(   "   "  ,  format.format())      [METHOD]    printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out    [CONTEXT]    void  printAndEncapsulate  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  boolean  first  =  newLine  ;  //  is  this  the  first  value  on  this  line?  boolean  quote  =  false  ;  int  start  =  offset  ;  int  pos  =  offset  ;  [ATTENTION]  int  end  =  start  +start  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  encapsulator  =  format  .  getEncapsulator  (  )  ;    if  (  len  <  =  0  )  {          if  (  first  )  {  quote  =  true  ;  }  }  else  {  char  c  =  value  .  charAt  (  pos  )  ;      if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )  ||  (  c  >  'z'  )  )  )  {  quote  =  true  ;    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }  }  if  (  !quote  )  {    out  .  append  (  value  ,  start  ,  end  )  ;  return  ;  }    out  .  append  (  encapsulator  )  ;        while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  encapsulator  )  {      out  .  append  (  value  ,  start  ,  pos  +  1  )  ;      start  =  pos  ;  }  pos++  ;  }    out  .  append  (  value  ,  start  ,  pos  )  ;  out  .  append  (  encapsulator  )  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^193^^^^^188^275^
[REPLACE]    printSep    (    )    ;  	[BUGGY]  out  .  append  (  '  '  )  ;  [FE]    AssertionFailedError    expected:<a[  ,  b  ,  ]c>  but  was:<a[  b  ]c>  assertEquals(   "   "  ,  format.format())      [METHOD]    printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out    [CONTEXT]    void  printAndEncapsulate  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  boolean  first  =  newLine  ;  //  is  this  the  first  value  on  this  line?  boolean  quote  =  false  ;  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    [ATTENTION]  out  .  append  (  '  '  )    ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  encapsulator  =  format  .  getEncapsulator  (  )  ;    if  (  len  <  =  0  )  {          if  (  first  )  {  quote  =  true  ;  }  }  else  {  char  c  =  value  .  charAt  (  pos  )  ;      if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )  ||  (  c  >  'z'  )  )  )  {  quote  =  true  ;    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }  }  if  (  !quote  )  {    out  .  append  (  value  ,  start  ,  end  )  ;  return  ;  }    out  .  append  (  encapsulator  )  ;        while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  encapsulator  )  {      out  .  append  (  value  ,  start  ,  pos  +  1  )  ;      start  =  pos  ;  }  pos++  ;  }    out  .  append  (  value  ,  start  ,  pos  )  ;  out  .  append  (  encapsulator  )  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^195^^^^^188^275^
[REPLACE]    char    delim    =    format    .    getDelimiter    (    )    ;  	[BUGGY]  char  delim  =  format  .  getEscape  (  )  ;  [FE]    AssertionFailedError    expected:<[   "x  ,  y   "]  ,  z>  but  was:<[x  ,  y]  ,  z>  assertEquals(   "   "  ,  format.format())      [METHOD]    printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out    [CONTEXT]    void  printAndEncapsulate  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  boolean  first  =  newLine  ;  //  is  this  the  first  value  on  this  line?  boolean  quote  =  false  ;  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    [ATTENTION]  char  delim  =  format  .  getEscape  (  )    ;  char  encapsulator  =  format  .  getEncapsulator  (  )  ;    if  (  len  <  =  0  )  {          if  (  first  )  {  quote  =  true  ;  }  }  else  {  char  c  =  value  .  charAt  (  pos  )  ;      if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )  ||  (  c  >  'z'  )  )  )  {  quote  =  true  ;    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }  }  if  (  !quote  )  {    out  .  append  (  value  ,  start  ,  end  )  ;  return  ;  }    out  .  append  (  encapsulator  )  ;        while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  encapsulator  )  {      out  .  append  (  value  ,  start  ,  pos  +  1  )  ;      start  =  pos  ;  }  pos++  ;  }    out  .  append  (  value  ,  start  ,  pos  )  ;  out  .  append  (  encapsulator  )  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^197^^^^^188^275^
[REPLACE]    char    encapsulator    =    format    .    getEncapsulator    (    )    ;  	[BUGGY]  char  encapsulator  =  format  .  isEncapsulating  (  )  ;  [CE]  incompatible  types    [METHOD]    printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out    [CONTEXT]    void  printAndEncapsulate  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  boolean  first  =  newLine  ;  //  is  this  the  first  value  on  this  line?  boolean  quote  =  false  ;  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  [ATTENTION]  char  encapsulator  =  format  .  isEncapsulating  (  )    ;    if  (  len  <  =  0  )  {          if  (  first  )  {  quote  =  true  ;  }  }  else  {  char  c  =  value  .  charAt  (  pos  )  ;      if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )  ||  (  c  >  'z'  )  )  )  {  quote  =  true  ;    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }  }  if  (  !quote  )  {    out  .  append  (  value  ,  start  ,  end  )  ;  return  ;  }    out  .  append  (  encapsulator  )  ;        while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  encapsulator  )  {      out  .  append  (  value  ,  start  ,  pos  +  1  )  ;      start  =  pos  ;  }  pos++  ;  }    out  .  append  (  value  ,  start  ,  pos  )  ;  out  .  append  (  encapsulator  )  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^198^^^^^188^275^
[REPLACE]    while    (    pos    <    end    )    {  	[BUGGY]  while  (  pos    =  =    end  )  {[FE]    AssertionFailedError    expected:<[   "x  ,  y   "]  ,  z>  but  was:<[x  ,  y]  ,  z>  assertEquals(   "   "  ,  format.format())      [METHOD]    printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out    [CONTEXT]    void  printAndEncapsulate  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  boolean  first  =  newLine  ;  //  is  this  the  first  value  on  this  line?  boolean  quote  =  false  ;  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  encapsulator  =  format  .  getEncapsulator  (  )  ;    if  (  len  <  =  0  )  {          if  (  first  )  {  quote  =  true  ;  }  }  else  {  char  c  =  value  .  charAt  (  pos  )  ;      if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )  ||  (  c  >  'z'  )  )  )  {  quote  =  true  ;    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  [ATTENTION]  while  (  pos  =  =  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }  }  if  (  !quote  )  {    out  .  append  (  value  ,  start  ,  end  )  ;  return  ;  }    out  .  append  (  encapsulator  )  ;        while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  encapsulator  )  {      out  .  append  (  value  ,  start  ,  pos  +  1  )  ;      start  =  pos  ;  }  pos++  ;  }    out  .  append  (  value  ,  start  ,  pos  )  ;  out  .  append  (  encapsulator  )  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^225^^^^^188^275^
[ADD]    while    (    pos    <    end    )    {    c    =    value    .    charAt    (    pos    )    ;  	[BUGGY]  [CE]  illegal  start  of  type    [METHOD]    printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out    [CONTEXT]    void  printAndEncapsulate  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  boolean  first  =  newLine  ;  //  is  this  the  first  value  on  this  line?  boolean  quote  =  false  ;  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  encapsulator  =  format  .  getEncapsulator  (  )  ;    if  (  len  <  =  0  )  {          if  (  first  )  {  quote  =  true  ;  }  }  else  {  char  c  =  value  .  charAt  (  pos  )  ;      if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )  ||  (  c  >  'z'  )  )  )  {  quote  =  true  ;    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  [ATTENTION]    if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }  }  if  (  !quote  )  {    out  .  append  (  value  ,  start  ,  end  )  ;  return  ;  }    out  .  append  (  encapsulator  )  ;        while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  encapsulator  )  {      out  .  append  (  value  ,  start  ,  pos  +  1  )  ;      start  =  pos  ;  }  pos++  ;  }    out  .  append  (  value  ,  start  ,  pos  )  ;  out  .  append  (  encapsulator  )  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^225^226^^^^188^275^
[REPLACE]    if    (    c    ==    '\n'    ||    c    ==    '\r'    ||    c    ==    encapsulator    ||    c    ==    delim    )    {  	[BUGGY]  if  (  c  =  =  '\n'  )  {[FE]    AssertionFailedError    expected:<[   "x  ,  y   "]  ,  z>  but  was:<[x  ,  y]  ,  z>  assertEquals(   "   "  ,  format.format())      [METHOD]    printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out    [CONTEXT]    void  printAndEncapsulate  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  boolean  first  =  newLine  ;  //  is  this  the  first  value  on  this  line?  boolean  quote  =  false  ;  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  encapsulator  =  format  .  getEncapsulator  (  )  ;    if  (  len  <  =  0  )  {          if  (  first  )  {  quote  =  true  ;  }  }  else  {  char  c  =  value  .  charAt  (  pos  )  ;      if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )  ||  (  c  >  'z'  )  )  )  {  quote  =  true  ;    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  [ATTENTION]  if  (  c  =  =  '\n'  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }  }  if  (  !quote  )  {    out  .  append  (  value  ,  start  ,  end  )  ;  return  ;  }    out  .  append  (  encapsulator  )  ;        while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  encapsulator  )  {      out  .  append  (  value  ,  start  ,  pos  +  1  )  ;      start  =  pos  ;  }  pos++  ;  }    out  .  append  (  value  ,  start  ,  pos  )  ;  out  .  append  (  encapsulator  )  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^227^^^^^188^275^
[ADD]    if    (    c    ==    '\n'    ||    c    ==    '\r'    ||    c    ==    encapsulator    ||    c    ==    delim    )    {    quote    =    true;    break;    }  	[BUGGY]  quote  =  true  ;  break  ;  [CE]  unreachable  statement    [METHOD]    printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out    [CONTEXT]    void  printAndEncapsulate  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  boolean  first  =  newLine  ;  //  is  this  the  first  value  on  this  line?  boolean  quote  =  false  ;  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  encapsulator  =  format  .  getEncapsulator  (  )  ;    if  (  len  <  =  0  )  {          if  (  first  )  {  quote  =  true  ;  }  }  else  {  char  c  =  value  .  charAt  (  pos  )  ;      if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )  ||  (  c  >  'z'  )  )  )  {  quote  =  true  ;    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  [ATTENTION]  quote  =  true  ;  break  ;      pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }  }  if  (  !quote  )  {    out  .  append  (  value  ,  start  ,  end  )  ;  return  ;  }    out  .  append  (  encapsulator  )  ;        while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  encapsulator  )  {      out  .  append  (  value  ,  start  ,  pos  +  1  )  ;      start  =  pos  ;  }  pos++  ;  }    out  .  append  (  value  ,  start  ,  pos  )  ;  out  .  append  (  encapsulator  )  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^227^228^229^230^^188^275^
[REPLACE]    quote    =    true;  	[BUGGY]  quote  =  false  ;  [FE]    AssertionFailedError    expected:<[   "x  ,  y   "]  ,  z>  but  was:<[x  ,  y]  ,  z>  assertEquals(   "   "  ,  format.format())      [METHOD]    printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out    [CONTEXT]    void  printAndEncapsulate  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  boolean  first  =  newLine  ;  //  is  this  the  first  value  on  this  line?  boolean  quote  =  false  ;  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  encapsulator  =  format  .  getEncapsulator  (  )  ;    if  (  len  <  =  0  )  {          if  (  first  )  {  quote  =  true  ;  }  }  else  {  char  c  =  value  .  charAt  (  pos  )  ;      if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )  ||  (  c  >  'z'  )  )  )  {  quote  =  true  ;    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  [ATTENTION]  quote  =  false  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }  }  if  (  !quote  )  {    out  .  append  (  value  ,  start  ,  end  )  ;  return  ;  }    out  .  append  (  encapsulator  )  ;        while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  encapsulator  )  {      out  .  append  (  value  ,  start  ,  pos  +  1  )  ;      start  =  pos  ;  }  pos++  ;  }    out  .  append  (  value  ,  start  ,  pos  )  ;  out  .  append  (  encapsulator  )  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^228^^^^^188^275^
[REPLACE]    c    =    value    .    charAt    (    pos    )    ;  	[BUGGY]  c  =    null  .  charAt  (  pos  )  ;  [CE]  <null>  cannot  be  dereferenced    [METHOD]    printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out    [CONTEXT]    void  printAndEncapsulate  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  boolean  first  =  newLine  ;  //  is  this  the  first  value  on  this  line?  boolean  quote  =  false  ;  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  encapsulator  =  format  .  getEncapsulator  (  )  ;    if  (  len  <  =  0  )  {          if  (  first  )  {  quote  =  true  ;  }  }  else  {  char  c  =  value  .  charAt  (  pos  )  ;      if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )  ||  (  c  >  'z'  )  )  )  {  quote  =  true  ;    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  [ATTENTION]  c  =  null  .  charAt  (  pos  )    ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }  }  if  (  !quote  )  {    out  .  append  (  value  ,  start  ,  end  )  ;  return  ;  }    out  .  append  (  encapsulator  )  ;        while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  encapsulator  )  {      out  .  append  (  value  ,  start  ,  pos  +  1  )  ;      start  =  pos  ;  }  pos++  ;  }    out  .  append  (  value  ,  start  ,  pos  )  ;  out  .  append  (  encapsulator  )  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^226^^^^^188^275^
[ADD]    c    =    value    .    charAt    (    pos    )    ;  	[BUGGY]  [FE]    AssertionFailedError    expected:<[   "x  ,  y   "]  ,  z>  but  was:<[x  ,  y]  ,  z>  assertEquals(   "   "  ,  format.format())      [METHOD]    printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out    [CONTEXT]    void  printAndEncapsulate  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  boolean  first  =  newLine  ;  //  is  this  the  first  value  on  this  line?  boolean  quote  =  false  ;  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  encapsulator  =  format  .  getEncapsulator  (  )  ;    if  (  len  <  =  0  )  {          if  (  first  )  {  quote  =  true  ;  }  }  else  {  char  c  =  value  .  charAt  (  pos  )  ;      if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )  ||  (  c  >  'z'  )  )  )  {  quote  =  true  ;    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  [ATTENTION]  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }  }  if  (  !quote  )  {    out  .  append  (  value  ,  start  ,  end  )  ;  return  ;  }    out  .  append  (  encapsulator  )  ;        while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  encapsulator  )  {      out  .  append  (  value  ,  start  ,  pos  +  1  )  ;      start  =  pos  ;  }  pos++  ;  }    out  .  append  (  value  ,  start  ,  pos  )  ;  out  .  append  (  encapsulator  )  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^226^^^^^188^275^
[ADD]    quote    =    true;    break;  	[BUGGY]  [FE]    AssertionFailedError    expected:<[   "x  ,  y   "]  ,  z>  but  was:<[x  ,  y]  ,  z>  assertEquals(   "   "  ,  format.format())      [METHOD]    printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out    [CONTEXT]    void  printAndEncapsulate  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  boolean  first  =  newLine  ;  //  is  this  the  first  value  on  this  line?  boolean  quote  =  false  ;  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  encapsulator  =  format  .  getEncapsulator  (  )  ;    if  (  len  <  =  0  )  {          if  (  first  )  {  quote  =  true  ;  }  }  else  {  char  c  =  value  .  charAt  (  pos  )  ;      if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )  ||  (  c  >  'z'  )  )  )  {  quote  =  true  ;    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  [ATTENTION]    }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }  }  if  (  !quote  )  {    out  .  append  (  value  ,  start  ,  end  )  ;  return  ;  }    out  .  append  (  encapsulator  )  ;        while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  encapsulator  )  {      out  .  append  (  value  ,  start  ,  pos  +  1  )  ;      start  =  pos  ;  }  pos++  ;  }    out  .  append  (  value  ,  start  ,  pos  )  ;  out  .  append  (  encapsulator  )  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^228^229^^^^188^275^
[REPLACE]    if    (    len    <=    0    )    {  	[BUGGY]  if  (offset  !  =    0  )  {[FE]    (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out    [CONTEXT]    void  printAndEncapsulate  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  boolean  first  =  newLine  ;  //  is  this  the  first  value  on  this  line?  boolean  quote  =  false  ;  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  encapsulator  =  format  .  getEncapsulator  (  )  ;    [ATTENTION]  if  (  offset!  =  0  )  {          if  (  first  )  {  quote  =  true  ;  }  }  else  {  char  c  =  value  .  charAt  (  pos  )  ;      if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )  ||  (  c  >  'z'  )  )  )  {  quote  =  true  ;    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }  }  if  (  !quote  )  {    out  .  append  (  value  ,  start  ,  end  )  ;  return  ;  }    out  .  append  (  encapsulator  )  ;        while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  encapsulator  )  {      out  .  append  (  value  ,  start  ,  pos  +  1  )  ;      start  =  pos  ;  }  pos++  ;  }    out  .  append  (  value  ,  start  ,  pos  )  ;  out  .  append  (  encapsulator  )  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^200^^^^^188^275^
[ADD]    if    (    len    <=    0    )    {  	[BUGGY]  [CE]  illegal  start  of  type    [METHOD]    printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out    [CONTEXT]    void  printAndEncapsulate  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  boolean  first  =  newLine  ;  //  is  this  the  first  value  on  this  line?  boolean  quote  =  false  ;  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  encapsulator  =  format  .  getEncapsulator  (  )  ;    [ATTENTION]          if  (  first  )  {  quote  =  true  ;  }  }  else  {  char  c  =  value  .  charAt  (  pos  )  ;      if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )  ||  (  c  >  'z'  )  )  )  {  quote  =  true  ;    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }  }  if  (  !quote  )  {    out  .  append  (  value  ,  start  ,  end  )  ;  return  ;  }    out  .  append  (  encapsulator  )  ;        while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  encapsulator  )  {      out  .  append  (  value  ,  start  ,  pos  +  1  )  ;      start  =  pos  ;  }  pos++  ;  }    out  .  append  (  value  ,  start  ,  pos  )  ;  out  .  append  (  encapsulator  )  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^200^201^^^^188^275^
[REPLACE]    while    (    pos    <    end    )    {  	[BUGGY]  while  (  pos  !  =    end  )  {[FE]    (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out    [CONTEXT]    if  (  len  <  =  0  )  {          if  (  first  )  {  quote  =  true  ;  }  }  else  {  char  c  =  value  .  charAt  (  pos  )  ;      if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )  ||  (  c  >  'z'  )  )  )  {  quote  =  true  ;    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  [ATTENTION]  while  (  pos!  =  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^225^^^^^200^245^
[REPLACE]    if    (    c    ==    '\n'    ||    c    ==    '\r'    ||    c    ==    encapsulator    ||    c    ==    delim    )    {  	[BUGGY]  if  (  c  =  =  '\n'  &&  c  =  =  '\r'  &&  c  =  =  encapsulator  &&  c  =  =  delim  )  {[FE]    AssertionFailedError    expected:<[   "x  ,  y   "]  ,  z>  but  was:<[x  ,  y]  ,  z>  assertEquals(   "   "  ,  format.format())      [METHOD]    printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out    [CONTEXT]    if  (  len  <  =  0  )  {          if  (  first  )  {  quote  =  true  ;  }  }  else  {  char  c  =  value  .  charAt  (  pos  )  ;      if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )  ||  (  c  >  'z'  )  )  )  {  quote  =  true  ;    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  [ATTENTION]  if  (  c  =  =  '\n'  &&  c  =  =  '\r'  &&  c  =  =  encapsulator  &&  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^227^^^^^200^245^
[ADD]    if    (    c    ==    '\n'    ||    c    ==    '\r'    ||    c    ==    encapsulator    ||    c    ==    delim    )    {    quote    =    true;    break;    }  	[BUGGY]  quote  =  true  ;  break  ;  [CE]  unreachable  statement    [METHOD]    printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out    [CONTEXT]    if  (  len  <  =  0  )  {          if  (  first  )  {  quote  =  true  ;  }  }  else  {  char  c  =  value  .  charAt  (  pos  )  ;      if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )  ||  (  c  >  'z'  )  )  )  {  quote  =  true  ;    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  [ATTENTION]  quote  =  true  ;  break  ;      pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^227^228^229^230^^200^245^
[REPLACE]    quote    =    true;  	[BUGGY]  quote  =  false  ;  [FE]    AssertionFailedError    expected:<[   "x  ,  y   "]  ,  z>  but  was:<[x  ,  y]  ,  z>  assertEquals(   "   "  ,  format.format())      [METHOD]    printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out    [CONTEXT]    if  (  len  <  =  0  )  {          if  (  first  )  {  quote  =  true  ;  }  }  else  {  char  c  =  value  .  charAt  (  pos  )  ;      if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )  ||  (  c  >  'z'  )  )  )  {  quote  =  true  ;    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  [ATTENTION]  quote  =  false  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^228^^^^^200^245^
[ADD]    quote    =    true;  	[BUGGY]  [FE]    AssertionFailedError    expected:<[   "x  ,  y   "]  ,  z>  but  was:<[x  ,  y]  ,  z>  assertEquals(   "   "  ,  format.format())      [METHOD]    printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out    [CONTEXT]    if  (  len  <  =  0  )  {          if  (  first  )  {  quote  =  true  ;  }  }  else  {  char  c  =  value  .  charAt  (  pos  )  ;      if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )  ||  (  c  >  'z'  )  )  )  {  quote  =  true  ;    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  [ATTENTION]  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^228^^^^^200^245^
[REPLACE]    c    =    value    .    charAt    (    pos    )    ;  	[BUGGY]  c  =    null  .  charAt  (  pos  )  ;  [CE]  <null>  cannot  be  dereferenced    [METHOD]    printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out    [CONTEXT]    if  (  len  <  =  0  )  {          if  (  first  )  {  quote  =  true  ;  }  }  else  {  char  c  =  value  .  charAt  (  pos  )  ;      if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )  ||  (  c  >  'z'  )  )  )  {  quote  =  true  ;    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  [ATTENTION]  c  =  null  .  charAt  (  pos  )    ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^226^^^^^200^245^
[ADD]    quote    =    true;    break;  	[BUGGY]  [FE]    AssertionFailedError    expected:<[   "x  ,  y   "]  ,  z>  but  was:<[x  ,  y]  ,  z>  assertEquals(   "   "  ,  format.format())      [METHOD]    printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out    [CONTEXT]    if  (  len  <  =  0  )  {          if  (  first  )  {  quote  =  true  ;  }  }  else  {  char  c  =  value  .  charAt  (  pos  )  ;      if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )  ||  (  c  >  'z'  )  )  )  {  quote  =  true  ;    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  [ATTENTION]    }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^228^229^^^^200^245^
[REPLACE]    if    (    first    &&    (    c    <    '0'    ||    (    c    >    '9'    &&    c    <    'A'    )    ||    (    c    >    'Z'    &&    c    <    'a'    )  	[BUGGY]  if  (  first  ||  (  c  <  '0'  ||  (  c  >  '9'  ||  c  <  'A'  )  ||  (  c  >  'Z'  ||  c  <  'a'  )[FE]    AssertionFailedError    expected:<[a  ,  b  ,  c]>  but  was:<[   "a   "  ,     "b   "  ,     "c   "]>  assertEquals(   "   "  ,  format.format())      [METHOD]    printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out    [CONTEXT]    if  (  len  <  =  0  )  {          if  (  first  )  {  quote  =  true  ;  }  }  else  {  char  c  =  value  .  charAt  (  pos  )  ;      [ATTENTION]  if  (  first  ||  (  c  <  '0'  ||  (  c  >  '9'  ||  c  <  'A'  )  ||  (  c  >  'Z'  ||  c  <  'a'  )      ||  (  c  >  'z'  )  )  )  {  quote  =  true  ;    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^212^213^214^215^^200^245^
[REPLACE]    while    (    pos    <    end    )    {  	[BUGGY]  while  (offset  >  =    end  )  {[FE]    AssertionFailedError    expected:<[   "x  ,  y   "]  ,  z>  but  was:<[x  ,  y]  ,  z>  assertEquals(   "   "  ,  format.format())      [METHOD]    printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out    [CONTEXT]    if  (  len  <  =  0  )  {          if  (  first  )  {  quote  =  true  ;  }  }  else  {  char  c  =  value  .  charAt  (  pos  )  ;      if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )  ||  (  c  >  'z'  )  )  )  {  quote  =  true  ;    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  [ATTENTION]  while  (  offset>  =  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^225^^^^^200^245^
[ADD]    c    =    value    .    charAt    (    pos    )    ;  	[BUGGY]  [FE]    AssertionFailedError    expected:<[   "x  ,  y   "]  ,  z>  but  was:<[x  ,  y]  ,  z>  assertEquals(   "   "  ,  format.format())      [METHOD]    printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out    [CONTEXT]    if  (  len  <  =  0  )  {          if  (  first  )  {  quote  =  true  ;  }  }  else  {  char  c  =  value  .  charAt  (  pos  )  ;      if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )  ||  (  c  >  'z'  )  )  )  {  quote  =  true  ;    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  [ATTENTION]  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^226^^^^^200^245^
[REPLACE]    }    else    if    (    c    <=    '#'    )    {  	[BUGGY]    if  (  c  >  =    '#'  )  {[FE]    AssertionFailedError    expected:<[a  ,  b  ,  c]>  but  was:<[   "a   "  ,     "b   "  ,     "c   "]>  assertEquals(   "   "  ,  format.format())      [METHOD]    printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out    [CONTEXT]    if  (  len  <  =  0  )  {          if  (  first  )  {  quote  =  true  ;  }  }  else  {  char  c  =  value  .  charAt  (  pos  )  ;      if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )  ||  (  c  >  'z'  )  )  )  {  quote  =  true  ;    [ATTENTION]  }if  (  c>  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^219^^^^^200^245^
[REPLACE]    while    (    pos    <    end    )    {  	[BUGGY]  while  (offset  <  =    end  )  {[FE]    String  index  out  of  range:  1  assertEquals(   "   "  ,  format.format())      [METHOD]    printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out    [CONTEXT]    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  [ATTENTION]  while  (  offset<  =  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^225^^^^^219^244^
[REPLACE]    if    (    c    ==    '\n'    ||    c    ==    '\r'    ||    c    ==    encapsulator    ||    c    ==    delim    )    {  	[BUGGY]  if  (  c  =  =  '\n'  )  {[FE]    AssertionFailedError    expected:<[   "x  ,  y   "]  ,  z>  but  was:<[x  ,  y]  ,  z>  assertEquals(   "   "  ,  format.format())      [METHOD]    printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out    [CONTEXT]    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  [ATTENTION]  if  (  c  =  =  '\n'  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^227^^^^^219^244^
[REPLACE]    quote    =    true;  	[BUGGY]  quote  =  false  ;  [FE]    AssertionFailedError    expected:<[   "x  ,  y   "]  ,  z>  but  was:<[x  ,  y]  ,  z>  assertEquals(   "   "  ,  format.format())      [METHOD]    printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out    [CONTEXT]    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  [ATTENTION]  quote  =  false  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^228^^^^^219^244^
[REPLACE]    c    =    value    .    charAt    (    pos    )    ;  	[BUGGY]  c  =    null  .  charAt  (  pos  )  ;  [CE]  <null>  cannot  be  dereferenced    [METHOD]    printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out    [CONTEXT]    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  [ATTENTION]  c  =  null  .  charAt  (  pos  )    ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^226^^^^^219^244^
[REPLACE]    if    (    !quote    )    {  	[BUGGY]  if  (  quote  )  {[FE]    (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out    [CONTEXT]    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  [ATTENTION]  if  (  quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^234^^^^^219^244^
[ADD]    if    (    !quote    )    {    pos    =    end    -    1;    c    =    value    .    charAt    (    pos    )    ;  	[BUGGY]  [CE]  illegal  start  of  type    [METHOD]    printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out    [CONTEXT]    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  [ATTENTION]          if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^234^235^236^^^219^244^
[REPLACE]    if    (    c    <=    '    '    )    {  	[BUGGY]  if  (  encapsulator  <  '  '  )  {[FE]    (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out    [CONTEXT]    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        [ATTENTION]  if  (  encapsulator<'  '  )  {  quote  =  true  ;  }  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^240^^^^^219^244^
[REPLACE]    quote    =    true;  	[BUGGY]  quote  =  false  ;  [FE]    (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out    [CONTEXT]    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  [ATTENTION]  quote  =  false  ;  }  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^241^^^^^219^244^
[REPLACE]    pos    =    end    -    1;  	[BUGGY]  pos  =  len  -  1  ;  [FE]    (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out    [CONTEXT]    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  [ATTENTION]  pos  =  len  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^235^^^^^219^244^
[REPLACE]    c    =    value    .    charAt    (    pos    )    ;  	[BUGGY]  c  =    null  .  charAt  (  pos  )  ;  [CE]  <null>  cannot  be  dereferenced    [METHOD]    printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out    [CONTEXT]    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  [ATTENTION]  c  =  null  .  charAt  (  pos  )    ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^236^^^^^219^244^
[ADD]    quote    =    true;  	[BUGGY]  [FE]    (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out    [CONTEXT]    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  [ATTENTION]  }  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^241^^^^^219^244^
[REPLACE]    if    (    c    <=    '    '    )    {  	[BUGGY]  if  (  c    =  =  encapsulator  )  {[FE]    (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out    [CONTEXT]    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        [ATTENTION]  if  (  c  =  =  encapsulator  )  {  quote  =  true  ;  }  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^240^^^^^219^244^
[ADD]    if    (    c    <=    '    '    )    {    quote    =    true;    }  	[BUGGY]  quote  =  true  ;  [FE]    AssertionFailedError    expected:<[a  ,  b  ,  c]>  but  was:<[   "a   "  ,     "b   "  ,     "c   "]>  assertEquals(   "   "  ,  format.format())      [METHOD]    printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out    [CONTEXT]    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        [ATTENTION]  quote  =  true  ;    }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^240^241^242^^^219^244^
[REPLACE]    pos    =    end    -    1;  	[BUGGY]  pos  =  len  -  1  /  1  ;  [FE]    (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out    [CONTEXT]    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  [ATTENTION]  pos  =  len  -  1  /  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^235^^^^^219^244^
[ADD]    c    =    value    .    charAt    (    pos    )    ;  	[BUGGY]  [FE]    (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out    [CONTEXT]    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  [ATTENTION]        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^236^^^^^219^244^
[REPLACE]    quote    =    true;  	[BUGGY]  quote  =  false  ;  [FE]    (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out    [CONTEXT]    if  (  len  <  =  0  )  {          if  (  first  )  {  quote  =  true  ;  }  }  else  {  char  c  =  value  .  charAt  (  pos  )  ;      if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )  ||  (  c  >  'z'  )  )  )  {  quote  =  true  ;    }  else  if  (  c  <  =  '#'  )  {        [ATTENTION]  quote  =  false  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^223^^^^^200^245^
[REPLACE]    if    (    c    ==    '\n'    ||    c    ==    '\r'    ||    c    ==    encapsulator    ||    c    ==    delim    )    {  	[BUGGY]  if  (  c  =  =  '\r'  &&  c  =  =  encapsulator  &&  c  =  =  delim  )  {[FE]    AssertionFailedError    expected:<[   "x  ,  y   "]  ,  z>  but  was:<[x  ,  y]  ,  z>  assertEquals(   "   "  ,  format.format())      [METHOD]    printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out    [CONTEXT]    if  (  len  <  =  0  )  {          if  (  first  )  {  quote  =  true  ;  }  }  else  {  char  c  =  value  .  charAt  (  pos  )  ;      if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )  ||  (  c  >  'z'  )  )  )  {  quote  =  true  ;    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  [ATTENTION]  if  (  c  =  =  '\r'  &&  c  =  =  encapsulator  &&  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^227^^^^^200^245^
[REPLACE]    if    (    !quote    )    {  	[BUGGY]  if  (  quote  )  {[FE]    (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out    [CONTEXT]    if  (  len  <  =  0  )  {          if  (  first  )  {  quote  =  true  ;  }  }  else  {  char  c  =  value  .  charAt  (  pos  )  ;      if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )  ||  (  c  >  'z'  )  )  )  {  quote  =  true  ;    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  [ATTENTION]  if  (  quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^234^^^^^200^245^
[REPLACE]    if    (    c    <=    '    '    )    {  	[BUGGY]  if  (  encapsulator    =  =    '  '  )  {[FE]    (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out    [CONTEXT]    if  (  len  <  =  0  )  {          if  (  first  )  {  quote  =  true  ;  }  }  else  {  char  c  =  value  .  charAt  (  pos  )  ;      if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )  ||  (  c  >  'z'  )  )  )  {  quote  =  true  ;    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        [ATTENTION]  if  (  encapsulator  =  =  '  '  )  {  quote  =  true  ;  }  }  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^240^^^^^200^245^
[REPLACE]    quote    =    true;  	[BUGGY]  quote  =  false  ;  [FE]    (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out    [CONTEXT]    if  (  len  <  =  0  )  {          if  (  first  )  {  quote  =  true  ;  }  }  else  {  char  c  =  value  .  charAt  (  pos  )  ;      if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )  ||  (  c  >  'z'  )  )  )  {  quote  =  true  ;    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  [ATTENTION]  quote  =  false  ;  }  }  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^241^^^^^200^245^
[REPLACE]    pos    =    end    -    1;  	[BUGGY]  pos  =  end  -len  ;  [FE]    (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out    [CONTEXT]    if  (  len  <  =  0  )  {          if  (  first  )  {  quote  =  true  ;  }  }  else  {  char  c  =  value  .  charAt  (  pos  )  ;      if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )  ||  (  c  >  'z'  )  )  )  {  quote  =  true  ;    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  [ATTENTION]  pos  =  end  -len  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^235^^^^^200^245^
[ADD]    pos    =    end    -    1;  	[BUGGY]  [FE]    String  index  out  of  range:  1  assertEquals(   "   "  ,  format.format())      [METHOD]    printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out    [CONTEXT]    if  (  len  <  =  0  )  {          if  (  first  )  {  quote  =  true  ;  }  }  else  {  char  c  =  value  .  charAt  (  pos  )  ;      if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )  ||  (  c  >  'z'  )  )  )  {  quote  =  true  ;    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  [ATTENTION]  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^235^^^^^200^245^
[REPLACE]    c    =    value    .    charAt    (    pos    )    ;  	[BUGGY]  c  =    null  .  charAt  (  pos  )  ;  [CE]  <null>  cannot  be  dereferenced    [METHOD]    printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out    [CONTEXT]    if  (  len  <  =  0  )  {          if  (  first  )  {  quote  =  true  ;  }  }  else  {  char  c  =  value  .  charAt  (  pos  )  ;      if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )  ||  (  c  >  'z'  )  )  )  {  quote  =  true  ;    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  [ATTENTION]  c  =  null  .  charAt  (  pos  )    ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^236^^^^^200^245^
[ADD]    c    =    value    .    charAt    (    pos    )    ;  	[BUGGY]  [FE]    (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out    [CONTEXT]    if  (  len  <  =  0  )  {          if  (  first  )  {  quote  =  true  ;  }  }  else  {  char  c  =  value  .  charAt  (  pos  )  ;      if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )  ||  (  c  >  'z'  )  )  )  {  quote  =  true  ;    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  [ATTENTION]        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^236^^^^^200^245^
[REPLACE]    if    (    c    <=    '    '    )    {  	[BUGGY]  if  (  c  !  =    '  '  )  {[FE]    AssertionFailedError    expected:<[a  ,  b  ,  c]>  but  was:<[   "a   "  ,     "b   "  ,     "c   "]>  assertEquals(   "   "  ,  format.format())      [METHOD]    printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out    [CONTEXT]    if  (  len  <  =  0  )  {          if  (  first  )  {  quote  =  true  ;  }  }  else  {  char  c  =  value  .  charAt  (  pos  )  ;      if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )  ||  (  c  >  'z'  )  )  )  {  quote  =  true  ;    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        [ATTENTION]  if  (  c!  =  '  '  )  {  quote  =  true  ;  }  }  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^240^^^^^200^245^
[ADD]    quote    =    true;    break;  	[BUGGY]  break  ;  [FE]    AssertionFailedError    expected:<[   "x  ,  y   "]  ,  z>  but  was:<[x  ,  y]  ,  z>  assertEquals(   "   "  ,  format.format())      [METHOD]    printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out    [CONTEXT]    if  (  len  <  =  0  )  {          if  (  first  )  {  quote  =  true  ;  }  }  else  {  char  c  =  value  .  charAt  (  pos  )  ;      if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )  ||  (  c  >  'z'  )  )  )  {  quote  =  true  ;    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  [ATTENTION]  break  ;    }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^228^229^^^^200^245^
[REPLACE]    pos    =    end    -    1;  	[BUGGY]  pos  =  len  -  1  ;  [FE]    (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out    [CONTEXT]    if  (  len  <  =  0  )  {          if  (  first  )  {  quote  =  true  ;  }  }  else  {  char  c  =  value  .  charAt  (  pos  )  ;      if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )  ||  (  c  >  'z'  )  )  )  {  quote  =  true  ;    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  [ATTENTION]  pos  =  len  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^235^^^^^200^245^
[REPLACE]    quote    =    true;  	[BUGGY]  quote  =  false  ;  [FE]    (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out    [CONTEXT]    if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )  ||  (  c  >  'z'  )  )  )  {  [ATTENTION]  quote  =  false  ;    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^217^^^^^212^244^
[REPLACE]    }    else    if    (    c    <=    '#'    )    {  	[BUGGY]    else  {[CE]  'else'  without  'if'    [METHOD]    printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out    [CONTEXT]    if  (  len  <  =  0  )  {          if  (  first  )  {  quote  =  true  ;  }  }  else  {  char  c  =  value  .  charAt  (  pos  )  ;      if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )  ||  (  c  >  'z'  )  )  )  {  quote  =  true  ;    [ATTENTION]  }else  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^219^^^^^200^245^
[REPLACE]    while    (    pos    <    end    )    {  	[BUGGY]  while  (offset  <  =    len  )  {[FE]    String  index  out  of  range:  1  assertEquals(   "   "  ,  format.format())      [METHOD]    printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out    [CONTEXT]    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  [ATTENTION]  while  (  offset<  =  len  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^225^^^^^219^244^
[REPLACE]    if    (    c    ==    '\n'    ||    c    ==    '\r'    ||    c    ==    encapsulator    ||    c    ==    delim    )    {  	[BUGGY]  if  (  c  =  =  '\r'  &&  c  =  =  encapsulator  &&  c  =  =  delim  )  {[FE]    AssertionFailedError    expected:<[   "x  ,  y   "]  ,  z>  but  was:<[x  ,  y]  ,  z>  assertEquals(   "   "  ,  format.format())      [METHOD]    printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out    [CONTEXT]    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  [ATTENTION]  if  (  c  =  =  '\r'  &&  c  =  =  encapsulator  &&  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^227^^^^^219^244^
[ADD]    if    (    c    ==    '\n'    ||    c    ==    '\r'    ||    c    ==    encapsulator    ||    c    ==    delim    )    {    quote    =    true;    break;    }  	[BUGGY]  [FE]    AssertionFailedError    expected:<[   "x  ,  y   "]  ,  z>  but  was:<[x  ,  y]  ,  z>  assertEquals(   "   "  ,  format.format())      [METHOD]    printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out    [CONTEXT]    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  [ATTENTION]      pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^227^228^229^230^^219^244^
[ADD]    quote    =    true;    break;  	[BUGGY]  [FE]    AssertionFailedError    expected:<[   "x  ,  y   "]  ,  z>  but  was:<[x  ,  y]  ,  z>  assertEquals(   "   "  ,  format.format())      [METHOD]    printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out    [CONTEXT]    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  [ATTENTION]    }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^228^229^^^^219^244^
[REPLACE]    if    (    c    <=    '    '    )    {  	[BUGGY]  if  (  encapsulator  >  =  encapsulator  )  {[FE]    AssertionFailedError    expected:<[a  ,  b  ,  c]>  but  was:<[   "a   "  ,     "b   "  ,     "c   "]>  assertEquals(   "   "  ,  format.format())      [METHOD]    printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out    [CONTEXT]    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        [ATTENTION]  if  (  encapsulator>  =  encapsulator  )  {  quote  =  true  ;  }  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^240^^^^^219^244^
[REPLACE]    pos    =    end    -    1;  	[BUGGY]  pos  =  end    =  =    1  ;  [CE]  incompatible  types    [METHOD]    printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out    [CONTEXT]    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  [ATTENTION]  pos  =  end  =  =  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^235^^^^^219^244^
[REPLACE]    if    (    c    <=    '    '    )    {  	[BUGGY]  if  (  encapsulator  >  encapsulator  )  {[FE]    (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out    [CONTEXT]    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        [ATTENTION]  if  (  encapsulator>  encapsulator  )  {  quote  =  true  ;  }  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^240^^^^^219^244^
[ADD]    c    =    value    .    charAt    (    pos    )    ;  	[BUGGY]  [FE]    AssertionFailedError    expected:<[   "x  ,  y   "]  ,  z>  but  was:<[x  ,  y]  ,  z>  assertEquals(   "   "  ,  format.format())      [METHOD]    printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out    [CONTEXT]    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  [ATTENTION]  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^226^^^^^219^244^
[REPLACE]    pos    =    end    -    1;  	[BUGGY]  pos  =  end  -len  ;  [FE]    (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out    [CONTEXT]    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  [ATTENTION]  pos  =  end  -len  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^235^^^^^219^244^
[REPLACE]    if    (    c    ==    '\n'    ||    c    ==    '\r'    ||    c    ==    encapsulator    ||    c    ==    delim    )    {  	[BUGGY]  if  (  c  =  =  '\n'  )  {[FE]    AssertionFailedError    expected:<[   "x  ,  y   "]  ,  z>  but  was:<[x  ,  y]  ,  z>  assertEquals(   "   "  ,  format.format())      [METHOD]    printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out    [CONTEXT]    if  (  len  <  =  0  )  {          if  (  first  )  {  quote  =  true  ;  }  }  else  {  char  c  =  value  .  charAt  (  pos  )  ;      if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )  ||  (  c  >  'z'  )  )  )  {  quote  =  true  ;    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  [ATTENTION]  if  (  c  =  =  '\n'  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^227^^^^^200^245^
[REMOVE]      	[BUGGY]  if  (  c  =  =  '\n'  )  {      c  =  'n'  ;  }else      if  (  c  =  =  '\r'  )  {          c  =  'r'  ;      }[FE]    (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out    [CONTEXT]    if  (  len  <  =  0  )  {          if  (  first  )  {  quote  =  true  ;  }  }  else  {  char  c  =  value  .  charAt  (  pos  )  ;      if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )  ||  (  c  >  'z'  )  )  )  {  quote  =  true  ;    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  [ATTENTION]  if  (  !quote  )  {  if  (  c  =  =  '\n'  )  {  c  =  'n'  ;  }else  if  (  c  =  =  '\r'  )  {  c  =  'r'  ;  }pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^234^^^^^200^245^
[REMOVE]      	[BUGGY]  if  (  first  )  {      quote  =  true  ;  }[FE]    (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out    [CONTEXT]    if  (  len  <  =  0  )  {          if  (  first  )  {  quote  =  true  ;  }  }  else  {  char  c  =  value  .  charAt  (  pos  )  ;      if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )  ||  (  c  >  'z'  )  )  )  {  quote  =  true  ;    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        [ATTENTION]  if  (  c  <  =  '  '  )  {  if  (  first  )  {  quote  =  true  ;  }quote  =  true  ;  }  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^240^^^^^200^245^
[REPLACE]    pos    =    end    -    1;  	[BUGGY]  pos  =  len  -  1  ;  [FE]    (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out    [CONTEXT]    if  (  len  <  =  0  )  {          if  (  first  )  {  quote  =  true  ;  }  }  else  {  char  c  =  value  .  charAt  (  pos  )  ;      if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )  ||  (  c  >  'z'  )  )  )  {  quote  =  true  ;    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  [ATTENTION]  pos  =  len  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^235^^^^^200^245^
[REPLACE]    if    (    c    <=    '    '    )    {  	[BUGGY]  if  (  c    =  =    '  '  )  {[FE]    (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out    [CONTEXT]    if  (  len  <  =  0  )  {          if  (  first  )  {  quote  =  true  ;  }  }  else  {  char  c  =  value  .  charAt  (  pos  )  ;      if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )  ||  (  c  >  'z'  )  )  )  {  quote  =  true  ;    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        [ATTENTION]  if  (  c  =  =  '  '  )  {  quote  =  true  ;  }  }  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^240^^^^^200^245^
[ADD]    if    (    c    <=    '    '    )    {    quote    =    true;    }  	[BUGGY]  [FE]    (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out    [CONTEXT]    if  (  len  <  =  0  )  {          if  (  first  )  {  quote  =  true  ;  }  }  else  {  char  c  =  value  .  charAt  (  pos  )  ;      if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )  ||  (  c  >  'z'  )  )  )  {  quote  =  true  ;    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        [ATTENTION]    }  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^240^241^242^^^200^245^
[ADD]    quote    =    true;  	[BUGGY]  [FE]    (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out    [CONTEXT]    if  (  len  <  =  0  )  {          if  (  first  )  {  quote  =  true  ;  }  }  else  {  char  c  =  value  .  charAt  (  pos  )  ;      if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )  ||  (  c  >  'z'  )  )  )  {  quote  =  true  ;    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  [ATTENTION]  }  }  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^241^^^^^200^245^
[REPLACE]    quote    =    true;  	[BUGGY]  quote  =  false  ;  [FE]    (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out    [CONTEXT]    if  (  len  <  =  0  )  {          if  (  first  )  {  quote  =  true  ;  }  }  else  {  char  c  =  value  .  charAt  (  pos  )  ;      if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )  ||  (  c  >  'z'  )  )  )  {  [ATTENTION]  quote  =  false  ;    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^217^^^^^200^245^
[ADD]    quote    =    true;  	[BUGGY]  [FE]    (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out    [CONTEXT]    if  (  len  <  =  0  )  {          if  (  first  )  {  quote  =  true  ;  }  }  else  {  char  c  =  value  .  charAt  (  pos  )  ;      if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )  ||  (  c  >  'z'  )  )  )  {  quote  =  true  ;    }  else  if  (  c  <  =  '#'  )  {        [ATTENTION]  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^223^^^^^200^245^
[REPLACE]    char    c    =    value    .    charAt    (    pos    )    ;  	[BUGGY]  for  (  String  value  :  values  )  {  print  (  value  )  ;  [CE]  illegal  start  of  expression    [METHOD]    printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out    [CONTEXT]    if  (  len  <  =  0  )  {          if  (  first  )  {  quote  =  true  ;  }  }  else  {  [ATTENTION]  for  (  String  value  :  values  )  {  print  (  value  )    ;      if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )  ||  (  c  >  'z'  )  )  )  {  quote  =  true  ;    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^209^^^^^200^245^
[REPLACE]    if    (    first    )    {  	[BUGGY]  if  (  true  )  {[FE]    (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out    [CONTEXT]    void  printAndEncapsulate  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  boolean  first  =  newLine  ;  //  is  this  the  first  value  on  this  line?  boolean  quote  =  false  ;  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  encapsulator  =  format  .  getEncapsulator  (  )  ;    if  (  len  <  =  0  )  {          [ATTENTION]  if  (  true  )  {  quote  =  true  ;  }  }  else  {  char  c  =  value  .  charAt  (  pos  )  ;      if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )  ||  (  c  >  'z'  )  )  )  {  quote  =  true  ;    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }  }  if  (  !quote  )  {    out  .  append  (  value  ,  start  ,  end  )  ;  return  ;  }    out  .  append  (  encapsulator  )  ;        while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  encapsulator  )  {      out  .  append  (  value  ,  start  ,  pos  +  1  )  ;      start  =  pos  ;  }  pos++  ;  }    out  .  append  (  value  ,  start  ,  pos  )  ;  out  .  append  (  encapsulator  )  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^205^^^^^188^275^
[REMOVE]      	[BUGGY]  if  (  c  <  =  '  '  )  {      quote  =  true  ;  }[CE]  cannot  find  symbol  c    [METHOD]    printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out    [CONTEXT]    void  printAndEncapsulate  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  boolean  first  =  newLine  ;  //  is  this  the  first  value  on  this  line?  boolean  quote  =  false  ;  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  encapsulator  =  format  .  getEncapsulator  (  )  ;    if  (  len  <  =  0  )  {          [ATTENTION]  if  (  first  )  {  if  (  c  <  =  '  '  )  {  quote  =  true  ;  }quote  =  true  ;  }  }  else  {  char  c  =  value  .  charAt  (  pos  )  ;      if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )  ||  (  c  >  'z'  )  )  )  {  quote  =  true  ;    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }  }  if  (  !quote  )  {    out  .  append  (  value  ,  start  ,  end  )  ;  return  ;  }    out  .  append  (  encapsulator  )  ;        while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  encapsulator  )  {      out  .  append  (  value  ,  start  ,  pos  +  1  )  ;      start  =  pos  ;  }  pos++  ;  }    out  .  append  (  value  ,  start  ,  pos  )  ;  out  .  append  (  encapsulator  )  ;      	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^205^^^^^188^275^
[REPLACE]    quote    =    true;  	[BUGGY]  quote  =  false  ;  [FE]    (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out    [CONTEXT]    void  printAndEncapsulate  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  boolean  first  =  newLine  ;  //  is  this  the  first  value  on  this  line?  boolean  quote  =  false  ;  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  encapsulator  =  format  .  getEncapsulator  (  )  ;    if  (  len  <  =  0  )  {          if  (  first  )  {  [ATTENTION]  quote  =  false  ;  }  }  else  {  char  c  =  value  .  charAt  (  pos  )  ;      if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )  ||  (  c  >  'z'  )  )  )  {  quote  =  true  ;    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }  }  if  (  !quote  )  {    out  .  append  (  value  ,  start  ,  end  )  ;  return  ;  }    out  .  append  (  encapsulator  )  ;        while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  encapsulator  )  {      out  .  append  (  value  ,  start  ,  pos  +  1  )  ;      start  =  pos  ;  }  pos++  ;  }    out  .  append  (  value  ,  start  ,  pos  )  ;  out  .  append  (  encapsulator  )  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^206^^^^^188^275^
[ADD]    quote    =    true;  	[BUGGY]  [FE]    (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out    [CONTEXT]    void  printAndEncapsulate  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  boolean  first  =  newLine  ;  //  is  this  the  first  value  on  this  line?  boolean  quote  =  false  ;  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  encapsulator  =  format  .  getEncapsulator  (  )  ;    if  (  len  <  =  0  )  {          if  (  first  )  {  [ATTENTION]  }  }  else  {  char  c  =  value  .  charAt  (  pos  )  ;      if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )  ||  (  c  >  'z'  )  )  )  {  quote  =  true  ;    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }  }  if  (  !quote  )  {    out  .  append  (  value  ,  start  ,  end  )  ;  return  ;  }    out  .  append  (  encapsulator  )  ;        while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  encapsulator  )  {      out  .  append  (  value  ,  start  ,  pos  +  1  )  ;      start  =  pos  ;  }  pos++  ;  }    out  .  append  (  value  ,  start  ,  pos  )  ;  out  .  append  (  encapsulator  )  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^206^^^^^188^275^
[REPLACE]    if    (    first    &&    (    c    <    '0'    ||    (    c    >    '9'    &&    c    <    'A'    )    ||    (    c    >    'Z'    &&    c    <    'a'    )  	[BUGGY]  if  (  first  ||  (  c  <  '0'  ||  (  c  >  '9'  ||  c  <  'A'  )  ||  (  c  >  'Z'  ||  c  <  'a'  )[FE]    AssertionFailedError    expected:<[a  ,  b  ,  c]>  but  was:<[   "a   "  ,     "b   "  ,     "c   "]>  assertEquals(   "   "  ,  format.format())      [METHOD]    printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out    [CONTEXT]    void  printAndEncapsulate  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  boolean  first  =  newLine  ;  //  is  this  the  first  value  on  this  line?  boolean  quote  =  false  ;  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  encapsulator  =  format  .  getEncapsulator  (  )  ;    if  (  len  <  =  0  )  {          if  (  first  )  {  quote  =  true  ;  }  }  else  {  char  c  =  value  .  charAt  (  pos  )  ;      [ATTENTION]  if  (  first  ||  (  c  <  '0'  ||  (  c  >  '9'  ||  c  <  'A'  )  ||  (  c  >  'Z'  ||  c  <  'a'  )      ||  (  c  >  'z'  )  )  )  {  quote  =  true  ;    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }  }  if  (  !quote  )  {    out  .  append  (  value  ,  start  ,  end  )  ;  return  ;  }    out  .  append  (  encapsulator  )  ;        while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  encapsulator  )  {      out  .  append  (  value  ,  start  ,  pos  +  1  )  ;      start  =  pos  ;  }  pos++  ;  }    out  .  append  (  value  ,  start  ,  pos  )  ;  out  .  append  (  encapsulator  )  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^212^213^214^215^^188^275^
[REPLACE]    while    (    pos    <    end    )    {  	[BUGGY]  while  (  pos  !  =    end  )  {[FE]    (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out    [CONTEXT]    void  printAndEncapsulate  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  boolean  first  =  newLine  ;  //  is  this  the  first  value  on  this  line?  boolean  quote  =  false  ;  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  encapsulator  =  format  .  getEncapsulator  (  )  ;    if  (  len  <  =  0  )  {          if  (  first  )  {  quote  =  true  ;  }  }  else  {  char  c  =  value  .  charAt  (  pos  )  ;      if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )  ||  (  c  >  'z'  )  )  )  {  quote  =  true  ;    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  [ATTENTION]  while  (  pos!  =  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }  }  if  (  !quote  )  {    out  .  append  (  value  ,  start  ,  end  )  ;  return  ;  }    out  .  append  (  encapsulator  )  ;        while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  encapsulator  )  {      out  .  append  (  value  ,  start  ,  pos  +  1  )  ;      start  =  pos  ;  }  pos++  ;  }    out  .  append  (  value  ,  start  ,  pos  )  ;  out  .  append  (  encapsulator  )  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^225^^^^^188^275^
[REPLACE]    if    (    c    ==    '\n'    ||    c    ==    '\r'    ||    c    ==    encapsulator    ||    c    ==    delim    )    {  	[BUGGY]  if  (  c  =  =  '\r'  &&  c  =  =  encapsulator  &&  c  =  =  delim  )  {[FE]    AssertionFailedError    expected:<[   "x  ,  y   "]  ,  z>  but  was:<[x  ,  y]  ,  z>  assertEquals(   "   "  ,  format.format())      [METHOD]    printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out    [CONTEXT]    void  printAndEncapsulate  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  boolean  first  =  newLine  ;  //  is  this  the  first  value  on  this  line?  boolean  quote  =  false  ;  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  encapsulator  =  format  .  getEncapsulator  (  )  ;    if  (  len  <  =  0  )  {          if  (  first  )  {  quote  =  true  ;  }  }  else  {  char  c  =  value  .  charAt  (  pos  )  ;      if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )  ||  (  c  >  'z'  )  )  )  {  quote  =  true  ;    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  [ATTENTION]  if  (  c  =  =  '\r'  &&  c  =  =  encapsulator  &&  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }  }  if  (  !quote  )  {    out  .  append  (  value  ,  start  ,  end  )  ;  return  ;  }    out  .  append  (  encapsulator  )  ;        while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  encapsulator  )  {      out  .  append  (  value  ,  start  ,  pos  +  1  )  ;      start  =  pos  ;  }  pos++  ;  }    out  .  append  (  value  ,  start  ,  pos  )  ;  out  .  append  (  encapsulator  )  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^227^^^^^188^275^
[REPLACE]    }    else    if    (    c    <=    '#'    )    {  	[BUGGY]    if  (encapsulator    =  =    '#'  )  {[FE]    (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out    [CONTEXT]    void  printAndEncapsulate  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  boolean  first  =  newLine  ;  //  is  this  the  first  value  on  this  line?  boolean  quote  =  false  ;  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  encapsulator  =  format  .  getEncapsulator  (  )  ;    if  (  len  <  =  0  )  {          if  (  first  )  {  quote  =  true  ;  }  }  else  {  char  c  =  value  .  charAt  (  pos  )  ;      if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )  ||  (  c  >  'z'  )  )  )  {  quote  =  true  ;    [ATTENTION]  }if  (  encapsulator  =  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }  }  if  (  !quote  )  {    out  .  append  (  value  ,  start  ,  end  )  ;  return  ;  }    out  .  append  (  encapsulator  )  ;        while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  encapsulator  )  {      out  .  append  (  value  ,  start  ,  pos  +  1  )  ;      start  =  pos  ;  }  pos++  ;  }    out  .  append  (  value  ,  start  ,  pos  )  ;  out  .  append  (  encapsulator  )  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^219^^^^^188^275^
[REPLACE]    while    (    pos    <    end    )    {  	[BUGGY]  while  (  pos  >  offset  )  {[FE]    AssertionFailedError    expected:<[   "x  ,  y   "]  ,  z>  but  was:<[x  ,  y]  ,  z>  assertEquals(   "   "  ,  format.format())      [METHOD]    printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out    [CONTEXT]    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  [ATTENTION]  while  (  pos>  offset  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^225^^^^^219^244^
[ADD]    quote    =    true;  	[BUGGY]  [FE]    AssertionFailedError    expected:<[   "x  ,  y   "]  ,  z>  but  was:<[x  ,  y]  ,  z>  assertEquals(   "   "  ,  format.format())      [METHOD]    printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out    [CONTEXT]    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  [ATTENTION]  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^228^^^^^219^244^
[REPLACE]    if    (    c    <=    '    '    )    {  	[BUGGY]  if  (  c    =  =    '  '  )  {[FE]    (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out    [CONTEXT]    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        [ATTENTION]  if  (  c  =  =  '  '  )  {  quote  =  true  ;  }  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^240^^^^^219^244^
[REPLACE]    if    (    c    <=    '    '    )    {  	[BUGGY]  if  (encapsulator  >  =    '  '  )  {[FE]    AssertionFailedError    expected:<[a  ,  b  ,  c]>  but  was:<[   "a   "  ,     "b   "  ,     "c   "]>  assertEquals(   "   "  ,  format.format())      [METHOD]    printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out    [CONTEXT]    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        [ATTENTION]  if  (  encapsulator>  =  '  '  )  {  quote  =  true  ;  }  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^240^^^^^219^244^
[REMOVE]      	[BUGGY]  if  (  first  )  {      quote  =  true  ;  }[FE]    (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out    [CONTEXT]    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        [ATTENTION]  if  (  c  <  =  '  '  )  {  if  (  first  )  {  quote  =  true  ;  }quote  =  true  ;  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^240^^^^^219^244^
[REPLACE]    quote    =    true;  	[BUGGY]  quote  =  false  ;  [FE]    (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out    [CONTEXT]    void  printAndEncapsulate  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  boolean  first  =  newLine  ;  //  is  this  the  first  value  on  this  line?  boolean  quote  =  false  ;  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  encapsulator  =  format  .  getEncapsulator  (  )  ;    if  (  len  <  =  0  )  {          if  (  first  )  {  quote  =  true  ;  }  }  else  {  char  c  =  value  .  charAt  (  pos  )  ;      if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )  ||  (  c  >  'z'  )  )  )  {  quote  =  true  ;    }  else  if  (  c  <  =  '#'  )  {        [ATTENTION]  quote  =  false  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }  }  if  (  !quote  )  {    out  .  append  (  value  ,  start  ,  end  )  ;  return  ;  }    out  .  append  (  encapsulator  )  ;        while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  encapsulator  )  {      out  .  append  (  value  ,  start  ,  pos  +  1  )  ;      start  =  pos  ;  }  pos++  ;  }    out  .  append  (  value  ,  start  ,  pos  )  ;  out  .  append  (  encapsulator  )  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^223^^^^^188^275^
[REPLACE]    if    (    !quote    )    {  	[BUGGY]  if  (  quote  )  {[FE]    (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out    [CONTEXT]    void  printAndEncapsulate  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  boolean  first  =  newLine  ;  //  is  this  the  first  value  on  this  line?  boolean  quote  =  false  ;  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  encapsulator  =  format  .  getEncapsulator  (  )  ;    if  (  len  <  =  0  )  {          if  (  first  )  {  quote  =  true  ;  }  }  else  {  char  c  =  value  .  charAt  (  pos  )  ;      if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )  ||  (  c  >  'z'  )  )  )  {  quote  =  true  ;    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  [ATTENTION]  if  (  quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }  }  if  (  !quote  )  {    out  .  append  (  value  ,  start  ,  end  )  ;  return  ;  }    out  .  append  (  encapsulator  )  ;        while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  encapsulator  )  {      out  .  append  (  value  ,  start  ,  pos  +  1  )  ;      start  =  pos  ;  }  pos++  ;  }    out  .  append  (  value  ,  start  ,  pos  )  ;  out  .  append  (  encapsulator  )  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^234^^^^^188^275^
[REMOVE]      	[BUGGY]  if  (  c  =  =  '\n'  )  {      c  =  'n'  ;  }else      if  (  c  =  =  '\r'  )  {          c  =  'r'  ;      }[FE]    (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out    [CONTEXT]    void  printAndEncapsulate  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  boolean  first  =  newLine  ;  //  is  this  the  first  value  on  this  line?  boolean  quote  =  false  ;  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  encapsulator  =  format  .  getEncapsulator  (  )  ;    if  (  len  <  =  0  )  {          if  (  first  )  {  quote  =  true  ;  }  }  else  {  char  c  =  value  .  charAt  (  pos  )  ;      if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )  ||  (  c  >  'z'  )  )  )  {  quote  =  true  ;    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  [ATTENTION]  if  (  !quote  )  {  if  (  c  =  =  '\n'  )  {  c  =  'n'  ;  }else  if  (  c  =  =  '\r'  )  {  c  =  'r'  ;  }pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }  }  if  (  !quote  )  {    out  .  append  (  value  ,  start  ,  end  )  ;  return  ;  }    out  .  append  (  encapsulator  )  ;        while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  encapsulator  )  {      out  .  append  (  value  ,  start  ,  pos  +  1  )  ;      start  =  pos  ;  }  pos++  ;  }    out  .  append  (  value  ,  start  ,  pos  )  ;  out  .  append  (  encapsulator  )  ;      	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^234^^^^^188^275^
[REPLACE]    if    (    c    <=    '    '    )    {  	[BUGGY]  if  (  c    =  =    '  '  )  {[FE]    (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out    [CONTEXT]    void  printAndEncapsulate  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  boolean  first  =  newLine  ;  //  is  this  the  first  value  on  this  line?  boolean  quote  =  false  ;  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  encapsulator  =  format  .  getEncapsulator  (  )  ;    if  (  len  <  =  0  )  {          if  (  first  )  {  quote  =  true  ;  }  }  else  {  char  c  =  value  .  charAt  (  pos  )  ;      if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )  ||  (  c  >  'z'  )  )  )  {  quote  =  true  ;    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        [ATTENTION]  if  (  c  =  =  '  '  )  {  quote  =  true  ;  }  }  }  }  if  (  !quote  )  {    out  .  append  (  value  ,  start  ,  end  )  ;  return  ;  }    out  .  append  (  encapsulator  )  ;        while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  encapsulator  )  {      out  .  append  (  value  ,  start  ,  pos  +  1  )  ;      start  =  pos  ;  }  pos++  ;  }    out  .  append  (  value  ,  start  ,  pos  )  ;  out  .  append  (  encapsulator  )  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^240^^^^^188^275^
[REPLACE]    quote    =    true;  	[BUGGY]  quote  =  false  ;  [FE]    (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out    [CONTEXT]    void  printAndEncapsulate  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  boolean  first  =  newLine  ;  //  is  this  the  first  value  on  this  line?  boolean  quote  =  false  ;  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  encapsulator  =  format  .  getEncapsulator  (  )  ;    if  (  len  <  =  0  )  {          if  (  first  )  {  quote  =  true  ;  }  }  else  {  char  c  =  value  .  charAt  (  pos  )  ;      if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )  ||  (  c  >  'z'  )  )  )  {  quote  =  true  ;    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  [ATTENTION]  quote  =  false  ;  }  }  }  }  if  (  !quote  )  {    out  .  append  (  value  ,  start  ,  end  )  ;  return  ;  }    out  .  append  (  encapsulator  )  ;        while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  encapsulator  )  {      out  .  append  (  value  ,  start  ,  pos  +  1  )  ;      start  =  pos  ;  }  pos++  ;  }    out  .  append  (  value  ,  start  ,  pos  )  ;  out  .  append  (  encapsulator  )  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^241^^^^^188^275^
[REPLACE]    pos    =    end    -    1;  	[BUGGY]  pos  =  end  |  2  ;  [FE]    String  index  out  of  range:  3  assertEquals(   "   "  ,  format.format())      [METHOD]    printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out    [CONTEXT]    void  printAndEncapsulate  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  boolean  first  =  newLine  ;  //  is  this  the  first  value  on  this  line?  boolean  quote  =  false  ;  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  encapsulator  =  format  .  getEncapsulator  (  )  ;    if  (  len  <  =  0  )  {          if  (  first  )  {  quote  =  true  ;  }  }  else  {  char  c  =  value  .  charAt  (  pos  )  ;      if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )  ||  (  c  >  'z'  )  )  )  {  quote  =  true  ;    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  [ATTENTION]  pos  =  end|2  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }  }  if  (  !quote  )  {    out  .  append  (  value  ,  start  ,  end  )  ;  return  ;  }    out  .  append  (  encapsulator  )  ;        while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  encapsulator  )  {      out  .  append  (  value  ,  start  ,  pos  +  1  )  ;      start  =  pos  ;  }  pos++  ;  }    out  .  append  (  value  ,  start  ,  pos  )  ;  out  .  append  (  encapsulator  )  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^235^^^^^188^275^
[ADD]    pos    =    end    -    1;  	[BUGGY]  [FE]    String  index  out  of  range:  1  assertEquals(   "   "  ,  format.format())      [METHOD]    printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out    [CONTEXT]    void  printAndEncapsulate  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  boolean  first  =  newLine  ;  //  is  this  the  first  value  on  this  line?  boolean  quote  =  false  ;  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  encapsulator  =  format  .  getEncapsulator  (  )  ;    if  (  len  <  =  0  )  {          if  (  first  )  {  quote  =  true  ;  }  }  else  {  char  c  =  value  .  charAt  (  pos  )  ;      if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )  ||  (  c  >  'z'  )  )  )  {  quote  =  true  ;    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  [ATTENTION]  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }  }  if  (  !quote  )  {    out  .  append  (  value  ,  start  ,  end  )  ;  return  ;  }    out  .  append  (  encapsulator  )  ;        while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  encapsulator  )  {      out  .  append  (  value  ,  start  ,  pos  +  1  )  ;      start  =  pos  ;  }  pos++  ;  }    out  .  append  (  value  ,  start  ,  pos  )  ;  out  .  append  (  encapsulator  )  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^235^^^^^188^275^
[REPLACE]    c    =    value    .    charAt    (    pos    )    ;  	[BUGGY]  c  =    null  .  charAt  (  pos  )  ;  [CE]  <null>  cannot  be  dereferenced    [METHOD]    printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out    [CONTEXT]    void  printAndEncapsulate  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  boolean  first  =  newLine  ;  //  is  this  the  first  value  on  this  line?  boolean  quote  =  false  ;  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  encapsulator  =  format  .  getEncapsulator  (  )  ;    if  (  len  <  =  0  )  {          if  (  first  )  {  quote  =  true  ;  }  }  else  {  char  c  =  value  .  charAt  (  pos  )  ;      if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )  ||  (  c  >  'z'  )  )  )  {  quote  =  true  ;    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  [ATTENTION]  c  =  null  .  charAt  (  pos  )    ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }  }  if  (  !quote  )  {    out  .  append  (  value  ,  start  ,  end  )  ;  return  ;  }    out  .  append  (  encapsulator  )  ;        while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  encapsulator  )  {      out  .  append  (  value  ,  start  ,  pos  +  1  )  ;      start  =  pos  ;  }  pos++  ;  }    out  .  append  (  value  ,  start  ,  pos  )  ;  out  .  append  (  encapsulator  )  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^236^^^^^188^275^
[REPLACE]    if    (    c    <=    '    '    )    {  	[BUGGY]  if  (  encapsulator  >  '  '  )  {[FE]    AssertionFailedError    expected:<[a  ,  b  ,  c]>  but  was:<[   "a   "  ,     "b   "  ,     "c   "]>  assertEquals(   "   "  ,  format.format())      [METHOD]    printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out    [CONTEXT]    void  printAndEncapsulate  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  boolean  first  =  newLine  ;  //  is  this  the  first  value  on  this  line?  boolean  quote  =  false  ;  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  encapsulator  =  format  .  getEncapsulator  (  )  ;    if  (  len  <  =  0  )  {          if  (  first  )  {  quote  =  true  ;  }  }  else  {  char  c  =  value  .  charAt  (  pos  )  ;      if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )  ||  (  c  >  'z'  )  )  )  {  quote  =  true  ;    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        [ATTENTION]  if  (  encapsulator>'  '  )  {  quote  =  true  ;  }  }  }  }  if  (  !quote  )  {    out  .  append  (  value  ,  start  ,  end  )  ;  return  ;  }    out  .  append  (  encapsulator  )  ;        while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  encapsulator  )  {      out  .  append  (  value  ,  start  ,  pos  +  1  )  ;      start  =  pos  ;  }  pos++  ;  }    out  .  append  (  value  ,  start  ,  pos  )  ;  out  .  append  (  encapsulator  )  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^240^^^^^188^275^
[ADD]    if    (    c    <=    '    '    )    {    quote    =    true;    }  	[BUGGY]  quote  =  true  ;  [FE]    AssertionFailedError    expected:<[a  ,  b  ,  c]>  but  was:<[   "a   "  ,     "b   "  ,     "c   "]>  assertEquals(   "   "  ,  format.format())      [METHOD]    printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out    [CONTEXT]    void  printAndEncapsulate  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  boolean  first  =  newLine  ;  //  is  this  the  first  value  on  this  line?  boolean  quote  =  false  ;  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  encapsulator  =  format  .  getEncapsulator  (  )  ;    if  (  len  <  =  0  )  {          if  (  first  )  {  quote  =  true  ;  }  }  else  {  char  c  =  value  .  charAt  (  pos  )  ;      if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )  ||  (  c  >  'z'  )  )  )  {  quote  =  true  ;    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        [ATTENTION]  quote  =  true  ;    }  }  }  if  (  !quote  )  {    out  .  append  (  value  ,  start  ,  end  )  ;  return  ;  }    out  .  append  (  encapsulator  )  ;        while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  encapsulator  )  {      out  .  append  (  value  ,  start  ,  pos  +  1  )  ;      start  =  pos  ;  }  pos++  ;  }    out  .  append  (  value  ,  start  ,  pos  )  ;  out  .  append  (  encapsulator  )  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^240^241^242^^^188^275^
[ADD]    quote    =    true;  	[BUGGY]  [FE]    (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out    [CONTEXT]    void  printAndEncapsulate  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  boolean  first  =  newLine  ;  //  is  this  the  first  value  on  this  line?  boolean  quote  =  false  ;  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  encapsulator  =  format  .  getEncapsulator  (  )  ;    if  (  len  <  =  0  )  {          if  (  first  )  {  quote  =  true  ;  }  }  else  {  char  c  =  value  .  charAt  (  pos  )  ;      if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )  ||  (  c  >  'z'  )  )  )  {  quote  =  true  ;    }  else  if  (  c  <  =  '#'  )  {        [ATTENTION]  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }  }  if  (  !quote  )  {    out  .  append  (  value  ,  start  ,  end  )  ;  return  ;  }    out  .  append  (  encapsulator  )  ;        while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  encapsulator  )  {      out  .  append  (  value  ,  start  ,  pos  +  1  )  ;      start  =  pos  ;  }  pos++  ;  }    out  .  append  (  value  ,  start  ,  pos  )  ;  out  .  append  (  encapsulator  )  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^223^^^^^188^275^
[ADD]    quote    =    true;  	[BUGGY]  [FE]    AssertionFailedError    expected:<[   "x  ,  y   "]  ,  z>  but  was:<[x  ,  y]  ,  z>  assertEquals(   "   "  ,  format.format())      [METHOD]    printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out    [CONTEXT]    void  printAndEncapsulate  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  boolean  first  =  newLine  ;  //  is  this  the  first  value  on  this  line?  boolean  quote  =  false  ;  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  encapsulator  =  format  .  getEncapsulator  (  )  ;    if  (  len  <  =  0  )  {          if  (  first  )  {  quote  =  true  ;  }  }  else  {  char  c  =  value  .  charAt  (  pos  )  ;      if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )  ||  (  c  >  'z'  )  )  )  {  quote  =  true  ;    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  [ATTENTION]  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }  }  if  (  !quote  )  {    out  .  append  (  value  ,  start  ,  end  )  ;  return  ;  }    out  .  append  (  encapsulator  )  ;        while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  encapsulator  )  {      out  .  append  (  value  ,  start  ,  pos  +  1  )  ;      start  =  pos  ;  }  pos++  ;  }    out  .  append  (  value  ,  start  ,  pos  )  ;  out  .  append  (  encapsulator  )  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^228^^^^^188^275^
[REPLACE]    pos    =    end    -    1;  	[BUGGY]  pos  =  len  -  0  ;  [FE]    String  index  out  of  range:  1  assertEquals(   "   "  ,  format.format())      [METHOD]    printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out    [CONTEXT]    void  printAndEncapsulate  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  boolean  first  =  newLine  ;  //  is  this  the  first  value  on  this  line?  boolean  quote  =  false  ;  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  encapsulator  =  format  .  getEncapsulator  (  )  ;    if  (  len  <  =  0  )  {          if  (  first  )  {  quote  =  true  ;  }  }  else  {  char  c  =  value  .  charAt  (  pos  )  ;      if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )  ||  (  c  >  'z'  )  )  )  {  quote  =  true  ;    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  [ATTENTION]  pos  =  len  -  0  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }  }  if  (  !quote  )  {    out  .  append  (  value  ,  start  ,  end  )  ;  return  ;  }    out  .  append  (  encapsulator  )  ;        while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  encapsulator  )  {      out  .  append  (  value  ,  start  ,  pos  +  1  )  ;      start  =  pos  ;  }  pos++  ;  }    out  .  append  (  value  ,  start  ,  pos  )  ;  out  .  append  (  encapsulator  )  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^235^^^^^188^275^
[REPLACE]    }    else    if    (    c    <=    '#'    )    {  	[BUGGY]    else  {[CE]  'else'  without  'if'    [METHOD]    printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out    [CONTEXT]    void  printAndEncapsulate  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  boolean  first  =  newLine  ;  //  is  this  the  first  value  on  this  line?  boolean  quote  =  false  ;  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  encapsulator  =  format  .  getEncapsulator  (  )  ;    if  (  len  <  =  0  )  {          if  (  first  )  {  quote  =  true  ;  }  }  else  {  char  c  =  value  .  charAt  (  pos  )  ;      if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )  ||  (  c  >  'z'  )  )  )  {  quote  =  true  ;    [ATTENTION]  }else  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }  }  if  (  !quote  )  {    out  .  append  (  value  ,  start  ,  end  )  ;  return  ;  }    out  .  append  (  encapsulator  )  ;        while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  encapsulator  )  {      out  .  append  (  value  ,  start  ,  pos  +  1  )  ;      start  =  pos  ;  }  pos++  ;  }    out  .  append  (  value  ,  start  ,  pos  )  ;  out  .  append  (  encapsulator  )  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^219^^^^^188^275^
[REPLACE]    while    (    pos    <    end    )    {  	[BUGGY]  while  (  pos  >  =  offset  )  {[FE]    String  index  out  of  range:  1  assertEquals(   "   "  ,  format.format())      [METHOD]    printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out    [CONTEXT]    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  [ATTENTION]  while  (  pos>  =  offset  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^225^^^^^219^244^
[REPLACE]    if    (    c    ==    '\n'    ||    c    ==    '\r'    ||    c    ==    encapsulator    ||    c    ==    delim    )    {  	[BUGGY]  if  (  encapsulator  =  =  '\n'  &&  c  =  =  '\r'  &&  c  =  =  encapsulator  &&  c  =  =  delim  )  {[FE]    AssertionFailedError    expected:<[   "x  ,  y   "]  ,  z>  but  was:<[x  ,  y]  ,  z>  assertEquals(   "   "  ,  format.format())      [METHOD]    printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out    [CONTEXT]    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  [ATTENTION]  if  (  encapsulator  =  =  '\n'  &&  c  =  =  '\r'  &&  c  =  =  encapsulator  &&  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^227^^^^^219^244^
[REPLACE]    if    (    c    ==    '\n'    ||    c    ==    '\r'    ||    c    ==    encapsulator    ||    c    ==    delim    )    {  	[BUGGY]  if  (  c  =  =  '\n'  &&  c  =  =  '\r'  &&  c  =  =  encapsulator  &&  quote  )  {[FE]    AssertionFailedError    expected:<[   "x  ,  y   "]  ,  z>  but  was:<[x  ,  y]  ,  z>  assertEquals(   "   "  ,  format.format())      [METHOD]    printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out    [CONTEXT]    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  [ATTENTION]  if  (  c  =  =  '\n'  &&  c  =  =  '\r'  &&  c  =  =  encapsulator  &&  quote  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^227^^^^^219^244^
[REPLACE]    if    (    c    <=    '    '    )    {  	[BUGGY]  if  (  c  >  =    '  '  )  {[FE]    AssertionFailedError    expected:<[a  ,  b  ,  c]>  but  was:<[   "a   "  ,     "b   "  ,     "c   "]>  assertEquals(   "   "  ,  format.format())      [METHOD]    printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out    [CONTEXT]    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        [ATTENTION]  if  (  c>  =  '  '  )  {  quote  =  true  ;  }  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^240^^^^^219^244^
[REPLACE]    if    (    c    <=    '    '    )    {  	[BUGGY]  if  (  c  !  =  encapsulator  )  {[FE]    AssertionFailedError    expected:<[a  ,  b  ,  c]>  but  was:<[   "a   "  ,     "b   "  ,     "c   "]>  assertEquals(   "   "  ,  format.format())      [METHOD]    printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out    [CONTEXT]    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        [ATTENTION]  if  (  c!  =  encapsulator  )  {  quote  =  true  ;  }  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^240^^^^^219^244^
[REPLACE]    pos    =    end    -    1;  	[BUGGY]  pos  =  end  !  =    1  ;  [CE]  incompatible  types    [METHOD]    printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out    [CONTEXT]    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  [ATTENTION]  pos  =  end!  =  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^235^^^^^219^244^
[ADD]    pos    =    end    -    1;  	[BUGGY]  [FE]    String  index  out  of  range:  1  assertEquals(   "   "  ,  format.format())      [METHOD]    printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out    [CONTEXT]    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  [ATTENTION]  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^235^^^^^219^244^
[REPLACE]    if    (    c    ==    '\n'    ||    c    ==    '\r'    ||    c    ==    encapsulator    ||    c    ==    delim    )    {  	[BUGGY]  if  (  c  =  =  '\n'  &&  c  =  =  '\r'  &&  c  =  =  encapsulator  &&  c  =  =  encapsulator  )  {[FE]    AssertionFailedError    expected:<[   "x  ,  y   "]  ,  z>  but  was:<[x  ,  y]  ,  z>  assertEquals(   "   "  ,  format.format())      [METHOD]    printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out    [CONTEXT]    void  printAndEncapsulate  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  boolean  first  =  newLine  ;  //  is  this  the  first  value  on  this  line?  boolean  quote  =  false  ;  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  encapsulator  =  format  .  getEncapsulator  (  )  ;    if  (  len  <  =  0  )  {          if  (  first  )  {  quote  =  true  ;  }  }  else  {  char  c  =  value  .  charAt  (  pos  )  ;      if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )  ||  (  c  >  'z'  )  )  )  {  quote  =  true  ;    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  [ATTENTION]  if  (  c  =  =  '\n'  &&  c  =  =  '\r'  &&  c  =  =  encapsulator  &&  c  =  =  encapsulator  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }  }  if  (  !quote  )  {    out  .  append  (  value  ,  start  ,  end  )  ;  return  ;  }    out  .  append  (  encapsulator  )  ;        while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  encapsulator  )  {      out  .  append  (  value  ,  start  ,  pos  +  1  )  ;      start  =  pos  ;  }  pos++  ;  }    out  .  append  (  value  ,  start  ,  pos  )  ;  out  .  append  (  encapsulator  )  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^227^^^^^188^275^
[ADD]    if    (    !quote    )    {    pos    =    end    -    1;    c    =    value    .    charAt    (    pos    )    ;  	[BUGGY]  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;  [CE]  illegal  start  of  type    [METHOD]    printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out    [CONTEXT]    void  printAndEncapsulate  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  boolean  first  =  newLine  ;  //  is  this  the  first  value  on  this  line?  boolean  quote  =  false  ;  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  encapsulator  =  format  .  getEncapsulator  (  )  ;    if  (  len  <  =  0  )  {          if  (  first  )  {  quote  =  true  ;  }  }  else  {  char  c  =  value  .  charAt  (  pos  )  ;      if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )  ||  (  c  >  'z'  )  )  )  {  quote  =  true  ;    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  [ATTENTION]  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )    ;          if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }  }  if  (  !quote  )  {    out  .  append  (  value  ,  start  ,  end  )  ;  return  ;  }    out  .  append  (  encapsulator  )  ;        while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  encapsulator  )  {      out  .  append  (  value  ,  start  ,  pos  +  1  )  ;      start  =  pos  ;  }  pos++  ;  }    out  .  append  (  value  ,  start  ,  pos  )  ;  out  .  append  (  encapsulator  )  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^234^235^236^^^188^275^
[REPLACE]    if    (    c    <=    '    '    )    {  	[BUGGY]  if  (encapsulator    =  =    '  '  )  {[FE]    (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out    [CONTEXT]    void  printAndEncapsulate  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  boolean  first  =  newLine  ;  //  is  this  the  first  value  on  this  line?  boolean  quote  =  false  ;  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  encapsulator  =  format  .  getEncapsulator  (  )  ;    if  (  len  <  =  0  )  {          if  (  first  )  {  quote  =  true  ;  }  }  else  {  char  c  =  value  .  charAt  (  pos  )  ;      if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )  ||  (  c  >  'z'  )  )  )  {  quote  =  true  ;    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        [ATTENTION]  if  (  encapsulator  =  =  '  '  )  {  quote  =  true  ;  }  }  }  }  if  (  !quote  )  {    out  .  append  (  value  ,  start  ,  end  )  ;  return  ;  }    out  .  append  (  encapsulator  )  ;        while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  encapsulator  )  {      out  .  append  (  value  ,  start  ,  pos  +  1  )  ;      start  =  pos  ;  }  pos++  ;  }    out  .  append  (  value  ,  start  ,  pos  )  ;  out  .  append  (  encapsulator  )  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^240^^^^^188^275^
[REPLACE]    pos    =    end    -    1;  	[BUGGY]  pos  =  end  -len  ;  [FE]    (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out    [CONTEXT]    void  printAndEncapsulate  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  boolean  first  =  newLine  ;  //  is  this  the  first  value  on  this  line?  boolean  quote  =  false  ;  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  encapsulator  =  format  .  getEncapsulator  (  )  ;    if  (  len  <  =  0  )  {          if  (  first  )  {  quote  =  true  ;  }  }  else  {  char  c  =  value  .  charAt  (  pos  )  ;      if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )  ||  (  c  >  'z'  )  )  )  {  quote  =  true  ;    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  [ATTENTION]  pos  =  end  -len  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }  }  if  (  !quote  )  {    out  .  append  (  value  ,  start  ,  end  )  ;  return  ;  }    out  .  append  (  encapsulator  )  ;        while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  encapsulator  )  {      out  .  append  (  value  ,  start  ,  pos  +  1  )  ;      start  =  pos  ;  }  pos++  ;  }    out  .  append  (  value  ,  start  ,  pos  )  ;  out  .  append  (  encapsulator  )  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^235^^^^^188^275^
[ADD]    c    =    value    .    charAt    (    pos    )    ;  	[BUGGY]  [FE]    (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out    [CONTEXT]    void  printAndEncapsulate  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  boolean  first  =  newLine  ;  //  is  this  the  first  value  on  this  line?  boolean  quote  =  false  ;  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  encapsulator  =  format  .  getEncapsulator  (  )  ;    if  (  len  <  =  0  )  {          if  (  first  )  {  quote  =  true  ;  }  }  else  {  char  c  =  value  .  charAt  (  pos  )  ;      if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )  ||  (  c  >  'z'  )  )  )  {  quote  =  true  ;    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  [ATTENTION]        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }  }  if  (  !quote  )  {    out  .  append  (  value  ,  start  ,  end  )  ;  return  ;  }    out  .  append  (  encapsulator  )  ;        while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  encapsulator  )  {      out  .  append  (  value  ,  start  ,  pos  +  1  )  ;      start  =  pos  ;  }  pos++  ;  }    out  .  append  (  value  ,  start  ,  pos  )  ;  out  .  append  (  encapsulator  )  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^236^^^^^188^275^
[ADD]    quote    =    true;  	[BUGGY]  [FE]    (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out    [CONTEXT]    void  printAndEncapsulate  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  boolean  first  =  newLine  ;  //  is  this  the  first  value  on  this  line?  boolean  quote  =  false  ;  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  encapsulator  =  format  .  getEncapsulator  (  )  ;    if  (  len  <  =  0  )  {          if  (  first  )  {  quote  =  true  ;  }  }  else  {  char  c  =  value  .  charAt  (  pos  )  ;      if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )  ||  (  c  >  'z'  )  )  )  {  quote  =  true  ;    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  [ATTENTION]  }  }  }  }  if  (  !quote  )  {    out  .  append  (  value  ,  start  ,  end  )  ;  return  ;  }    out  .  append  (  encapsulator  )  ;        while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  encapsulator  )  {      out  .  append  (  value  ,  start  ,  pos  +  1  )  ;      start  =  pos  ;  }  pos++  ;  }    out  .  append  (  value  ,  start  ,  pos  )  ;  out  .  append  (  encapsulator  )  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^241^^^^^188^275^
[REPLACE]    if    (    c    <=    '    '    )    {  	[BUGGY]  if  (encapsulator  <  '  '  )  {[FE]    (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out    [CONTEXT]    void  printAndEncapsulate  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  boolean  first  =  newLine  ;  //  is  this  the  first  value  on  this  line?  boolean  quote  =  false  ;  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  encapsulator  =  format  .  getEncapsulator  (  )  ;    if  (  len  <  =  0  )  {          if  (  first  )  {  quote  =  true  ;  }  }  else  {  char  c  =  value  .  charAt  (  pos  )  ;      if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )  ||  (  c  >  'z'  )  )  )  {  quote  =  true  ;    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        [ATTENTION]  if  (  encapsulator<'  '  )  {  quote  =  true  ;  }  }  }  }  if  (  !quote  )  {    out  .  append  (  value  ,  start  ,  end  )  ;  return  ;  }    out  .  append  (  encapsulator  )  ;        while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  encapsulator  )  {      out  .  append  (  value  ,  start  ,  pos  +  1  )  ;      start  =  pos  ;  }  pos++  ;  }    out  .  append  (  value  ,  start  ,  pos  )  ;  out  .  append  (  encapsulator  )  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^240^^^^^188^275^
[REPLACE]    quote    =    true;  	[BUGGY]  quote  =  false  ;  [FE]    (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out    [CONTEXT]    void  printAndEncapsulate  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  boolean  first  =  newLine  ;  //  is  this  the  first  value  on  this  line?  boolean  quote  =  false  ;  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  encapsulator  =  format  .  getEncapsulator  (  )  ;    if  (  len  <  =  0  )  {          if  (  first  )  {  quote  =  true  ;  }  }  else  {  char  c  =  value  .  charAt  (  pos  )  ;      if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )  ||  (  c  >  'z'  )  )  )  {  [ATTENTION]  quote  =  false  ;    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }  }  if  (  !quote  )  {    out  .  append  (  value  ,  start  ,  end  )  ;  return  ;  }    out  .  append  (  encapsulator  )  ;        while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  encapsulator  )  {      out  .  append  (  value  ,  start  ,  pos  +  1  )  ;      start  =  pos  ;  }  pos++  ;  }    out  .  append  (  value  ,  start  ,  pos  )  ;  out  .  append  (  encapsulator  )  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^217^^^^^188^275^
[REPLACE]    char    c    =    value    .    charAt    (    pos    )    ;  	[BUGGY]  char  c  =  value  .  charAt  (  offset  )  ;  [FE]    (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out    [CONTEXT]    void  printAndEncapsulate  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  boolean  first  =  newLine  ;  //  is  this  the  first  value  on  this  line?  boolean  quote  =  false  ;  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  encapsulator  =  format  .  getEncapsulator  (  )  ;    if  (  len  <  =  0  )  {          if  (  first  )  {  quote  =  true  ;  }  }  else  {  [ATTENTION]  char  c  =  value  .  charAt  (  offset  )    ;      if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )  ||  (  c  >  'z'  )  )  )  {  quote  =  true  ;    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }  }  if  (  !quote  )  {    out  .  append  (  value  ,  start  ,  end  )  ;  return  ;  }    out  .  append  (  encapsulator  )  ;        while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  encapsulator  )  {      out  .  append  (  value  ,  start  ,  pos  +  1  )  ;      start  =  pos  ;  }  pos++  ;  }    out  .  append  (  value  ,  start  ,  pos  )  ;  out  .  append  (  encapsulator  )  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^209^^^^^188^275^
[REPLACE]    if    (    !quote    )    {  	[BUGGY]  if  (  quote  )  {[FE]    AssertionFailedError    expected:<[a  ,  b  ,  c]>  but  was:<[   "a   "  ,     "b   "  ,     "c   "]>  assertEquals(   "   "  ,  format.format())      [METHOD]    printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out    [CONTEXT]    void  printAndEncapsulate  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  boolean  first  =  newLine  ;  //  is  this  the  first  value  on  this  line?  boolean  quote  =  false  ;  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  encapsulator  =  format  .  getEncapsulator  (  )  ;    if  (  len  <  =  0  )  {          if  (  first  )  {  quote  =  true  ;  }  }  else  {  char  c  =  value  .  charAt  (  pos  )  ;      if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )  ||  (  c  >  'z'  )  )  )  {  quote  =  true  ;    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }  }  [ATTENTION]  if  (  quote  )  {    out  .  append  (  value  ,  start  ,  end  )  ;  return  ;  }    out  .  append  (  encapsulator  )  ;        while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  encapsulator  )  {      out  .  append  (  value  ,  start  ,  pos  +  1  )  ;      start  =  pos  ;  }  pos++  ;  }    out  .  append  (  value  ,  start  ,  pos  )  ;  out  .  append  (  encapsulator  )  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^247^^^^^188^275^
[REPLACE]    out    .    append    (    encapsulator    )    ;  	[BUGGY]  out  .  append  (  delim  )  ;  [FE]    AssertionFailedError    expected:<[   "]x  ,  y   "  ,  z>  but  was:<[  ,  ]x  ,  y   "  ,  z>  assertEquals(   "   "  ,  format.format())      [METHOD]    printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out    [CONTEXT]    void  printAndEncapsulate  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  boolean  first  =  newLine  ;  //  is  this  the  first  value  on  this  line?  boolean  quote  =  false  ;  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  encapsulator  =  format  .  getEncapsulator  (  )  ;    if  (  len  <  =  0  )  {          if  (  first  )  {  quote  =  true  ;  }  }  else  {  char  c  =  value  .  charAt  (  pos  )  ;      if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )  ||  (  c  >  'z'  )  )  )  {  quote  =  true  ;    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }  }  if  (  !quote  )  {    out  .  append  (  value  ,  start  ,  end  )  ;  return  ;  }    [ATTENTION]  out  .  append  (  delim  )    ;        while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  encapsulator  )  {      out  .  append  (  value  ,  start  ,  pos  +  1  )  ;      start  =  pos  ;  }  pos++  ;  }    out  .  append  (  value  ,  start  ,  pos  )  ;  out  .  append  (  encapsulator  )  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^254^^^^^188^275^
[REPLACE]    while    (    pos    <    end    )    {  	[BUGGY]  while  (offset  >  end  )  {[FE]    AssertionFailedError    expected:<   "x[  ,  y]   "  ,  z>  but  was:<   "x[]   "  ,  z>  assertEquals(   "   "  ,  format.format())      [METHOD]    printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out    [CONTEXT]    void  printAndEncapsulate  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  boolean  first  =  newLine  ;  //  is  this  the  first  value  on  this  line?  boolean  quote  =  false  ;  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  encapsulator  =  format  .  getEncapsulator  (  )  ;    if  (  len  <  =  0  )  {          if  (  first  )  {  quote  =  true  ;  }  }  else  {  char  c  =  value  .  charAt  (  pos  )  ;      if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )  ||  (  c  >  'z'  )  )  )  {  quote  =  true  ;    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }  }  if  (  !quote  )  {    out  .  append  (  value  ,  start  ,  end  )  ;  return  ;  }    out  .  append  (  encapsulator  )  ;        [ATTENTION]  while  (  offset>end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  encapsulator  )  {      out  .  append  (  value  ,  start  ,  pos  +  1  )  ;      start  =  pos  ;  }  pos++  ;  }    out  .  append  (  value  ,  start  ,  pos  )  ;  out  .  append  (  encapsulator  )  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^258^^^^^188^275^
[REPLACE]    if    (    c    ==    encapsulator    )    {  	[BUGGY]  if  (  c  &&  encapsulator  )  {[CE]  bad  operand  types  for  binary  operator  '&&'    [METHOD]    printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out    [CONTEXT]    void  printAndEncapsulate  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  boolean  first  =  newLine  ;  //  is  this  the  first  value  on  this  line?  boolean  quote  =  false  ;  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  encapsulator  =  format  .  getEncapsulator  (  )  ;    if  (  len  <  =  0  )  {          if  (  first  )  {  quote  =  true  ;  }  }  else  {  char  c  =  value  .  charAt  (  pos  )  ;      if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )  ||  (  c  >  'z'  )  )  )  {  quote  =  true  ;    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }  }  if  (  !quote  )  {    out  .  append  (  value  ,  start  ,  end  )  ;  return  ;  }    out  .  append  (  encapsulator  )  ;        while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  [ATTENTION]  if  (  c&&encapsulator  )  {      out  .  append  (  value  ,  start  ,  pos  +  1  )  ;      start  =  pos  ;  }  pos++  ;  }    out  .  append  (  value  ,  start  ,  pos  )  ;  out  .  append  (  encapsulator  )  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^260^^^^^188^275^
[ADD]    if    (    c    ==    encapsulator    )    {    out    .    append    (    value,    start,    pos    +    1    )    ;  	[BUGGY]  [CE]  <identifier>  expected    [METHOD]    printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out    [CONTEXT]    void  printAndEncapsulate  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  boolean  first  =  newLine  ;  //  is  this  the  first  value  on  this  line?  boolean  quote  =  false  ;  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  encapsulator  =  format  .  getEncapsulator  (  )  ;    if  (  len  <  =  0  )  {          if  (  first  )  {  quote  =  true  ;  }  }  else  {  char  c  =  value  .  charAt  (  pos  )  ;      if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )  ||  (  c  >  'z'  )  )  )  {  quote  =  true  ;    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }  }  if  (  !quote  )  {    out  .  append  (  value  ,  start  ,  end  )  ;  return  ;  }    out  .  append  (  encapsulator  )  ;        while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  [ATTENTION]            start  =  pos  ;  }  pos++  ;  }    out  .  append  (  value  ,  start  ,  pos  )  ;  out  .  append  (  encapsulator  )  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^260^261^^^264^188^275^
[REPLACE]    start    =    pos;  	[BUGGY]  start  =  pos  +  1  ;    ;  [FE]    (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out    [CONTEXT]    void  printAndEncapsulate  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  boolean  first  =  newLine  ;  //  is  this  the  first  value  on  this  line?  boolean  quote  =  false  ;  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  encapsulator  =  format  .  getEncapsulator  (  )  ;    if  (  len  <  =  0  )  {          if  (  first  )  {  quote  =  true  ;  }  }  else  {  char  c  =  value  .  charAt  (  pos  )  ;      if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )  ||  (  c  >  'z'  )  )  )  {  quote  =  true  ;    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }  }  if  (  !quote  )  {    out  .  append  (  value  ,  start  ,  end  )  ;  return  ;  }    out  .  append  (  encapsulator  )  ;        while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  encapsulator  )  {      out  .  append  (  value  ,  start  ,  pos  +  1  )  ;      [ATTENTION]  start  =  pos  +  1  ;    ;  }  pos++  ;  }    out  .  append  (  value  ,  start  ,  pos  )  ;  out  .  append  (  encapsulator  )  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^267^^^^^188^275^
[REPLACE]    char    c    =    value    .    charAt    (    pos    )    ;  	[BUGGY]  char  c  =  value  .  charAt  (  offset  )  ;  [FE]    (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out    [CONTEXT]    void  printAndEncapsulate  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  boolean  first  =  newLine  ;  //  is  this  the  first  value  on  this  line?  boolean  quote  =  false  ;  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  encapsulator  =  format  .  getEncapsulator  (  )  ;    if  (  len  <  =  0  )  {          if  (  first  )  {  quote  =  true  ;  }  }  else  {  char  c  =  value  .  charAt  (  pos  )  ;      if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )  ||  (  c  >  'z'  )  )  )  {  quote  =  true  ;    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }  }  if  (  !quote  )  {    out  .  append  (  value  ,  start  ,  end  )  ;  return  ;  }    out  .  append  (  encapsulator  )  ;        while  (  pos  <  end  )  {  [ATTENTION]  char  c  =  value  .  charAt  (  offset  )    ;  if  (  c  =  =  encapsulator  )  {      out  .  append  (  value  ,  start  ,  pos  +  1  )  ;      start  =  pos  ;  }  pos++  ;  }    out  .  append  (  value  ,  start  ,  pos  )  ;  out  .  append  (  encapsulator  )  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^259^^^^^188^275^
[REPLACE]    out    .    append    (    value,    start,    pos    )    ;  	[BUGGY]  out  .  append  (  value  ,  start  ,  end  )  ;  [FE]    (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out    [CONTEXT]    void  printAndEncapsulate  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  boolean  first  =  newLine  ;  //  is  this  the  first  value  on  this  line?  boolean  quote  =  false  ;  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  encapsulator  =  format  .  getEncapsulator  (  )  ;    if  (  len  <  =  0  )  {          if  (  first  )  {  quote  =  true  ;  }  }  else  {  char  c  =  value  .  charAt  (  pos  )  ;      if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )  ||  (  c  >  'z'  )  )  )  {  quote  =  true  ;    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }  }  if  (  !quote  )  {    out  .  append  (  value  ,  start  ,  end  )  ;  return  ;  }    out  .  append  (  encapsulator  )  ;        while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  encapsulator  )  {      out  .  append  (  value  ,  start  ,  pos  +  1  )  ;      start  =  pos  ;  }  pos++  ;  }    [ATTENTION]  out  .  append  (  value  ,  start  ,  end  )    ;  out  .  append  (  encapsulator  )  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^273^^^^^188^275^
[ADD]    out    .    append    (    value,    start,    pos    )    ;    out    .    append    (    encapsulator    )    ;  	[BUGGY]  out  .  append  (  encapsulator  )  ;  [FE]    AssertionFailedError    expected:<   "[x  ,  y]   "  ,  z>  but  was:<   "[]   "  ,  z>  assertEquals(   "   "  ,  format.format())      [METHOD]    printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out    [CONTEXT]    void  printAndEncapsulate  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  boolean  first  =  newLine  ;  //  is  this  the  first  value  on  this  line?  boolean  quote  =  false  ;  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  encapsulator  =  format  .  getEncapsulator  (  )  ;    if  (  len  <  =  0  )  {          if  (  first  )  {  quote  =  true  ;  }  }  else  {  char  c  =  value  .  charAt  (  pos  )  ;      if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )  ||  (  c  >  'z'  )  )  )  {  quote  =  true  ;    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }  }  if  (  !quote  )  {    out  .  append  (  value  ,  start  ,  end  )  ;  return  ;  }    out  .  append  (  encapsulator  )  ;        while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  encapsulator  )  {      out  .  append  (  value  ,  start  ,  pos  +  1  )  ;      start  =  pos  ;  }  pos++  ;  }    [ATTENTION]  out  .  append  (  encapsulator  )    ;    }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^273^274^^^^188^275^
[REPLACE]    out    .    append    (    encapsulator    )    ;  	[BUGGY]  out  .  append  (  delim  )  ;  [FE]    AssertionFailedError    expected:<   "x  ,  y[   "]  ,  z>  but  was:<   "x  ,  y[  ,  ]  ,  z>  assertEquals(   "   "  ,  format.format())      [METHOD]    printAndEncapsulate  [TYPE]  void  [PARAMETER]  CharSequence  value  int  offset  int  len  [CLASS]  CSVPrinter    [TYPE]  CharSequence  value  [TYPE]  char  c  delim  encapsulator  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  first  newLine  quote  true  [TYPE]  int  end  len  offset  pos  start  [TYPE]  Appendable  out    [CONTEXT]    void  printAndEncapsulate  (  CharSequence  value  ,  int  offset  ,  int  len  )  throws  IOException  {  boolean  first  =  newLine  ;  //  is  this  the  first  value  on  this  line?  boolean  quote  =  false  ;  int  start  =  offset  ;  int  pos  =  offset  ;  int  end  =  offset  +  len  ;    printSep  (  )  ;    char  delim  =  format  .  getDelimiter  (  )  ;  char  encapsulator  =  format  .  getEncapsulator  (  )  ;    if  (  len  <  =  0  )  {          if  (  first  )  {  quote  =  true  ;  }  }  else  {  char  c  =  value  .  charAt  (  pos  )  ;      if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )  ||  (  c  >  'z'  )  )  )  {  quote  =  true  ;    }  else  if  (  c  <  =  '#'  )  {        quote  =  true  ;  }  else  {  while  (  pos  <  end  )  {  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  '\n'  ||  c  =  =  '\r'  ||  c  =  =  encapsulator  ||  c  =  =  delim  )  {  quote  =  true  ;  break  ;  }  pos++  ;  }  if  (  !quote  )  {  pos  =  end  -  1  ;  c  =  value  .  charAt  (  pos  )  ;        if  (  c  <  =  '  '  )  {  quote  =  true  ;  }  }  }  }  if  (  !quote  )  {    out  .  append  (  value  ,  start  ,  end  )  ;  return  ;  }    out  .  append  (  encapsulator  )  ;        while  (  pos  <  end  )  {  char  c  =  value  .  charAt  (  pos  )  ;  if  (  c  =  =  encapsulator  )  {      out  .  append  (  value  ,  start  ,  pos  +  1  )  ;      start  =  pos  ;  }  pos++  ;  }    out  .  append  (  value  ,  start  ,  pos  )  ;  [ATTENTION]  out  .  append  (  delim  )    ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^274^^^^^188^275^
[REPLACE]    if    (    value    ==    null    )    {  	[BUGGY]  if  (  value  !  =  null  )  {[FE]    AssertionFailedError    expected:<[a  ,  b  ,  c]>  but  was:<[   "   "  ,  ,  ]>  assertEquals(   "   "  ,  format.format())      [METHOD]    print  [TYPE]  void  [PARAMETER]  String  value  boolean  checkForEscape  [CLASS]  CSVPrinter    [TYPE]  CSVFormat  format  [TYPE]  boolean  checkForEscape  false  first  newLine  quote  true  [TYPE]  String  value  [TYPE]  Appendable  out    [CONTEXT]    public  void  print  (  String  value  ,  boolean  checkForEscape  )  throws  IOException  {  [ATTENTION]  if  (  value  !  =  null  )  {    value  =     "   "  ;  }  if  (  !checkForEscape  )  {    printSep  (  )  ;  out  .  append  (  value  )  ;  }  else  {  print  (  value  ,  0  ,  value  .  length  (  )  )  ;  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^284^^^^^283^296^
[REMOVE]      	[BUGGY]  if  (  first  )  {      quote  =  true  ;  }[CE]  cannot  find  symbol  first    [METHOD]    print  [TYPE]  void  [PARAMETER]  String  value  boolean  checkForEscape  [CLASS]  CSVPrinter    [TYPE]  CSVFormat  format  [TYPE]  boolean  checkForEscape  false  first  newLine  quote  true  [TYPE]  String  value  [TYPE]  Appendable  out    [CONTEXT]    public  void  print  (  String  value  ,  boolean  checkForEscape  )  throws  IOException  {  [ATTENTION]  if  (  value  =  =  null  )  {  if  (  first  )  {  quote  =  true  ;  }//  null  values  are  considered  empty  value  =     "   "  ;  }  if  (  !checkForEscape  )  {    printSep  (  )  ;  out  .  append  (  value  )  ;  }  else  {  print  (  value  ,  0  ,  value  .  length  (  )  )  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^284^^^^^283^296^
[REPLACE]    value    =       "   ";  	[BUGGY]  value    =    value  ;  [FE]    (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    print  [TYPE]  void  [PARAMETER]  String  value  boolean  checkForEscape  [CLASS]  CSVPrinter    [TYPE]  CSVFormat  format  [TYPE]  boolean  checkForEscape  false  first  newLine  quote  true  [TYPE]  String  value  [TYPE]  Appendable  out    [CONTEXT]    public  void  print  (  String  value  ,  boolean  checkForEscape  )  throws  IOException  {  if  (  value  =  =  null  )  {    [ATTENTION]  value  =  value  ;  }  if  (  !checkForEscape  )  {    printSep  (  )  ;  out  .  append  (  value  )  ;  }  else  {  print  (  value  ,  0  ,  value  .  length  (  )  )  ;  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^286^^^^^283^296^
[REPLACE]    if    (    !checkForEscape    )    {  	[BUGGY]  if  (  newLine  )  {[FE]    AssertionFailedError    expected:<[   "x  ,  y   "]  ,  z>  but  was:<[x  ,  y]  ,  z>  assertEquals(   "   "  ,  format.format())      [METHOD]    print  [TYPE]  void  [PARAMETER]  String  value  boolean  checkForEscape  [CLASS]  CSVPrinter    [TYPE]  CSVFormat  format  [TYPE]  boolean  checkForEscape  false  first  newLine  quote  true  [TYPE]  String  value  [TYPE]  Appendable  out    [CONTEXT]    public  void  print  (  String  value  ,  boolean  checkForEscape  )  throws  IOException  {  if  (  value  =  =  null  )  {    value  =     "   "  ;  }  [ATTENTION]  if  (  newLine  )  {    printSep  (  )  ;  out  .  append  (  value  )  ;  }  else  {  print  (  value  ,  0  ,  value  .  length  (  )  )  ;  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^289^^^^^283^296^
[REPLACE]    print    (    value,    0,    value    .    length    (    )    )    ;  	[BUGGY]  print  (  value  ,  0  ,  value  .  length  (  )  )  ;  [FE]    (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    print  [TYPE]  void  [PARAMETER]  String  value  boolean  checkForEscape  [CLASS]  CSVPrinter    [TYPE]  CSVFormat  format  [TYPE]  boolean  checkForEscape  false  first  newLine  quote  true  [TYPE]  String  value  [TYPE]  Appendable  out    [CONTEXT]    public  void  print  (  String  value  ,  boolean  checkForEscape  )  throws  IOException  {  if  (  value  =  =  null  )  {    value  =     "   "  ;  }  if  (  !checkForEscape  )  {    printSep  (  )  ;  out  .  append  (  value  )  ;  }  else  {  [ATTENTION]  print  (  value  ,  0  ,  value  .  length  (  )  )    ;  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^294^^^^^283^296^
[REPLACE]    print    (    value,    0,    value    .    length    (    )    )    ;  	[BUGGY]  char  c  =  value  .  charAt  (  pos  )  ;  [CE]  cannot  find  symbol  pos    [METHOD]    print  [TYPE]  void  [PARAMETER]  String  value  boolean  checkForEscape  [CLASS]  CSVPrinter    [TYPE]  CSVFormat  format  [TYPE]  boolean  checkForEscape  false  first  newLine  quote  true  [TYPE]  String  value  [TYPE]  Appendable  out    [CONTEXT]    public  void  print  (  String  value  ,  boolean  checkForEscape  )  throws  IOException  {  if  (  value  =  =  null  )  {    value  =     "   "  ;  }  if  (  !checkForEscape  )  {    printSep  (  )  ;  out  .  append  (  value  )  ;  }  else  {  [ATTENTION]  char  c  =  value  .  charAt  (  pos  )    ;  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^294^^^^^283^296^
[REPLACE]    printSep    (    )    ;  	[BUGGY]  out  .  append  (  '  '  )  ;  [FE]    (startline  6)  EOF  reached  before  encapsulated  token  finished  assertTokenEquals(TOKEN  ,     "a   "  ,  parser.nextToken(new  Token()))      [METHOD]    print  [TYPE]  void  [PARAMETER]  String  value  boolean  checkForEscape  [CLASS]  CSVPrinter    [TYPE]  CSVFormat  format  [TYPE]  boolean  checkForEscape  false  first  newLine  quote  true  [TYPE]  String  value  [TYPE]  Appendable  out    [CONTEXT]    public  void  print  (  String  value  ,  boolean  checkForEscape  )  throws  IOException  {  if  (  value  =  =  null  )  {    value  =     "   "  ;  }  if  (  !checkForEscape  )  {    [ATTENTION]  out  .  append  (  '  '  )    ;  out  .  append  (  value  )  ;  }  else  {  print  (  value  ,  0  ,  value  .  length  (  )  )  ;  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^291^^^^^283^296^
[REPLACE]    out    .    append    (    value    )    ;  	[BUGGY]  out  .  append  (  null  ,  null  ,  null  )    ;  [CE]  no  suitable  method  found  for  append(<null>  ,  <null>  ,  <null>)    [METHOD]    print  [TYPE]  void  [PARAMETER]  String  value  boolean  checkForEscape  [CLASS]  CSVPrinter    [TYPE]  CSVFormat  format  [TYPE]  boolean  checkForEscape  false  first  newLine  quote  true  [TYPE]  String  value  [TYPE]  Appendable  out    [CONTEXT]    public  void  print  (  String  value  ,  boolean  checkForEscape  )  throws  IOException  {  if  (  value  =  =  null  )  {    value  =     "   "  ;  }  if  (  !checkForEscape  )  {    printSep  (  )  ;  [ATTENTION]  out  .  append  (  null  ,  null  ,  null  )  ;  }  else  {  print  (  value  ,  0  ,  value  .  length  (  )  )  ;  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^292^^^^^283^296^
[REPLACE]    print    (    value,    true    )    ;  	[BUGGY]  print  (  value  ,  false  )  ;  [FE]    AssertionFailedError    expected:<[   "x  ,  y   "]  ,  z>  but  was:<[x  ,  y]  ,  z>  assertEquals(   "   "  ,  format.format())      [METHOD]    print  [TYPE]  void  [PARAMETER]  String  value  [CLASS]  CSVPrinter    [TYPE]  CSVFormat  format  [TYPE]  boolean  checkForEscape  false  first  newLine  quote  true  [TYPE]  String  value  [TYPE]  Appendable  out    [CONTEXT]    public  void  print  (  String  value  )  throws  IOException  {  [ATTENTION]  print  (  value  ,  false  )    ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVPrinter.java^305^^^^^304^306^
[REPLACE]    static    final    int    END_OF_STREAM    =    -1;  	[BUGGY]  static  final  int  END_OF_STREAM  =  -1L  ;  [CE]  possible  loss  of  precision    [CONTEXT]        [CLASS]  ExtendedBufferedReader    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java^37^^^^^^^
[REPLACE]    static    final    int    UNDEFINED    =    -2;  	[BUGGY]  static  final  int  UNDEFINED    =  null  ;  [CE]  incompatible  types    [CONTEXT]        [CLASS]  ExtendedBufferedReader    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java^40^^^^^^^
[REPLACE]    private    int    lastChar    =    UNDEFINED;  	[BUGGY]  private  int  lastChar    =  null  ;  [CE]  incompatible  types    [CONTEXT]        [CLASS]  ExtendedBufferedReader    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java^43^^^^^^^
[REPLACE]    private    int    lineCounter    =    0;  	[BUGGY]  private  int  lineCounter  ;  [FE]    AssertionFailedError    expected:<[   "x  ,  y   "]  ,  z>  but  was:<[x  ,  y]  ,  z>  assertEquals(   "   "  ,  format.format())      [CONTEXT]        [CLASS]  ExtendedBufferedReader    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java^46^^^^^^^
[REPLACE]    super    (    r    )    ;  	[BUGGY]  super  .  reset  (  )  ;  [CE]  no  suitable  constructor  found  for  BufferedReader()    [METHOD]    <init>  [TYPE]  Reader)  [PARAMETER]  Reader  r  [CLASS]  ExtendedBufferedReader    [TYPE]  Reader  r  [TYPE]  int  END_OF_STREAM  UNDEFINED  lastChar  lineCounter  [TYPE]  boolean  false  true    [CONTEXT]    ExtendedBufferedReader  (  Reader  r  )  {  [ATTENTION]  super  .  reset  (  )    ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java^52^^^^^51^53^
[REPLACE]    int    current    =    super    .    read    (    )    ;  	[BUGGY]  int  current  =  super  .  reset  (  )  ;  [CE]  incompatible  types    [METHOD]    read  [TYPE]  int  [PARAMETER]  [CLASS]  ExtendedBufferedReader    [TYPE]  int  END_OF_STREAM  UNDEFINED  current  lastChar  lineCounter  [TYPE]  boolean  false  true    [CONTEXT]    public  int  read  (  )  throws  IOException  {  [ATTENTION]  int  current  =  super  .  reset  (  )    ;  if  (  current  =  =  '\r'  ||  (  current  =  =  '\n'  &&  lastChar  !  =  '\r'  )  )  {  lineCounter++  ;  }  lastChar  =  current  ;  return  lastChar  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java^57^^^^^56^63^
[REPLACE]    if    (    current    ==    '\r'    ||    (    current    ==    '\n'    &&    lastChar    !=    '\r'    )    )    {  	[BUGGY]  if  (    (  current  =  =  '\n'  &&  lastChar  !  =  '\r'  )  )  {[FE]    AssertionFailedError    expected:<[   "x  ,  y   "]  ,  z>  but  was:<[x  ,  y]  ,  z>  assertEquals(   "   "  ,  format.format())      [METHOD]    read  [TYPE]  int  [PARAMETER]  [CLASS]  ExtendedBufferedReader    [TYPE]  int  END_OF_STREAM  UNDEFINED  current  lastChar  lineCounter  [TYPE]  boolean  false  true    [CONTEXT]    public  int  read  (  )  throws  IOException  {  int  current  =  super  .  read  (  )  ;  [ATTENTION]  if  (    (  current  =  =  '\n'  &&  lastChar  !  =  '\r'  )  )  {  lineCounter++  ;  }  lastChar  =  current  ;  return  lastChar  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java^58^^^^^56^63^
[REPLACE]    lastChar    =    current;  	[BUGGY]  lastChar  =    lineCounter  ;  [FE]  [METHOD]    read  [TYPE]  int  [PARAMETER]  [CLASS]  ExtendedBufferedReader    [TYPE]  int  END_OF_STREAM  UNDEFINED  current  lastChar  lineCounter  [TYPE]  boolean  false  true    [CONTEXT]    public  int  read  (  )  throws  IOException  {  int  current  =  super  .  read  (  )  ;  if  (  current  =  =  '\r'  ||  (  current  =  =  '\n'  &&  lastChar  !  =  '\r'  )  )  {  lineCounter++  ;  }  [ATTENTION]  lastChar  =  lineCounter  ;  return  lastChar  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java^61^^^^^56^63^
[ADD]    lastChar    =    current;    return    lastChar;  	[BUGGY]  return  lastChar  ;  [FE]  [METHOD]    read  [TYPE]  int  [PARAMETER]  [CLASS]  ExtendedBufferedReader    [TYPE]  int  END_OF_STREAM  UNDEFINED  current  lastChar  lineCounter  [TYPE]  boolean  false  true    [CONTEXT]    public  int  read  (  )  throws  IOException  {  int  current  =  super  .  read  (  )  ;  if  (  current  =  =  '\r'  ||  (  current  =  =  '\n'  &&  lastChar  !  =  '\r'  )  )  {  lineCounter++  ;  }  [ATTENTION]  return  lastChar  ;    }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java^61^62^^^^56^63^
[REPLACE]    return    lastChar;  	[BUGGY]  return  line  ;  [CE]  cannot  find  symbol  line    [METHOD]    read  [TYPE]  int  [PARAMETER]  [CLASS]  ExtendedBufferedReader    [TYPE]  int  END_OF_STREAM  UNDEFINED  current  lastChar  lineCounter  [TYPE]  boolean  false  true    [CONTEXT]    public  int  read  (  )  throws  IOException  {  int  current  =  super  .  read  (  )  ;  if  (  current  =  =  '\r'  ||  (  current  =  =  '\n'  &&  lastChar  !  =  '\r'  )  )  {  lineCounter++  ;  }  lastChar  =  current  ;  [ATTENTION]  return  line  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java^62^^^^^56^63^
[REPLACE]    return    lastChar;  	[BUGGY]  return  line  ;  [CE]  cannot  find  symbol  line    [METHOD]    readAgain  [TYPE]  int  [PARAMETER]  [CLASS]  ExtendedBufferedReader    [TYPE]  int  END_OF_STREAM  UNDEFINED  current  lastChar  lineCounter  [TYPE]  boolean  false  true    [CONTEXT]    int  readAgain  (  )  {  [ATTENTION]  return  line  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java^76^^^^^75^77^
[REPLACE]    if    (    length    ==    0    )    {  	[BUGGY]  if  (  length  -  4  =  =  0  )  {[FE]    AssertionFailedError    expected:<[   "x  ,  y   "]  ,  z>  but  was:<[x  ,  y]  ,  z>  assertEquals(   "   "  ,  format.format())      [METHOD]    read  [TYPE]  int  [PARAMETER]  char[]  buf  int  offset  int  length  [CLASS]  ExtendedBufferedReader    [TYPE]  char  ch  [TYPE]  boolean  false  true  [TYPE]  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  [TYPE]  char[]  buf    [CONTEXT]    public  int  read  (  char[]  buf  ,  int  offset  ,  int  length  )  throws  IOException  {  [ATTENTION]  if  (  length  -  4  =  =  0  )  {  return  0  ;  }  int  len  =  super  .  read  (  buf  ,  offset  ,  length  )  ;    if  (  len  >  0  )  {  for  (  int  i  =  offset  ;  i  <  offset  +  len  ;  i++  )  {  char  ch  =  buf[i]  ;  if  (  ch  =  =  '\n'  )  {  if  (  '\r'  !  =    (  i  >  0  ?  buf[i-1]:  lastChar  )  )  {  lineCounter++  ;  }  }  else  if  (  ch  =  =  '\r'  )  {  lineCounter++  ;  }  }  lastChar  =  buf[offset  +  len  -  1]  ;    }  else  if  (  len  =  =  -1  )  {  lastChar  =  END_OF_STREAM  ;  }  return  len  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java^81^^^^^80^107^
[REPLACE]    return    0;  	[BUGGY]  return  0  /  3  ;  [FE]    AssertionFailedError    expected:<[   "x  ,  y   "]  ,  z>  but  was:<[x  ,  y]  ,  z>  assertEquals(   "   "  ,  format.format())      [METHOD]    read  [TYPE]  int  [PARAMETER]  char[]  buf  int  offset  int  length  [CLASS]  ExtendedBufferedReader    [TYPE]  char  ch  [TYPE]  boolean  false  true  [TYPE]  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  [TYPE]  char[]  buf    [CONTEXT]    public  int  read  (  char[]  buf  ,  int  offset  ,  int  length  )  throws  IOException  {  if  (  length  =  =  0  )  {  [ATTENTION]  return  0  /  3  ;  }  int  len  =  super  .  read  (  buf  ,  offset  ,  length  )  ;    if  (  len  >  0  )  {  for  (  int  i  =  offset  ;  i  <  offset  +  len  ;  i++  )  {  char  ch  =  buf[i]  ;  if  (  ch  =  =  '\n'  )  {  if  (  '\r'  !  =    (  i  >  0  ?  buf[i-1]:  lastChar  )  )  {  lineCounter++  ;  }  }  else  if  (  ch  =  =  '\r'  )  {  lineCounter++  ;  }  }  lastChar  =  buf[offset  +  len  -  1]  ;    }  else  if  (  len  =  =  -1  )  {  lastChar  =  END_OF_STREAM  ;  }  return  len  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java^82^^^^^80^107^
[REPLACE]    return    0;  	[BUGGY]  return  1  ;  [FE]    AssertionFailedError    expected:<[   "x  ,  y   "]  ,  z>  but  was:<[x  ,  y]  ,  z>  assertEquals(   "   "  ,  format.format())      [METHOD]    read  [TYPE]  int  [PARAMETER]  char[]  buf  int  offset  int  length  [CLASS]  ExtendedBufferedReader    [TYPE]  char  ch  [TYPE]  boolean  false  true  [TYPE]  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  [TYPE]  char[]  buf    [CONTEXT]    public  int  read  (  char[]  buf  ,  int  offset  ,  int  length  )  throws  IOException  {  if  (  length  =  =  0  )  {  [ATTENTION]  return  1  ;  }  int  len  =  super  .  read  (  buf  ,  offset  ,  length  )  ;    if  (  len  >  0  )  {  for  (  int  i  =  offset  ;  i  <  offset  +  len  ;  i++  )  {  char  ch  =  buf[i]  ;  if  (  ch  =  =  '\n'  )  {  if  (  '\r'  !  =    (  i  >  0  ?  buf[i-1]:  lastChar  )  )  {  lineCounter++  ;  }  }  else  if  (  ch  =  =  '\r'  )  {  lineCounter++  ;  }  }  lastChar  =  buf[offset  +  len  -  1]  ;    }  else  if  (  len  =  =  -1  )  {  lastChar  =  END_OF_STREAM  ;  }  return  len  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java^82^^^^^80^107^
[REPLACE]    int    len    =    super    .    read    (    buf,    offset,    length    )    ;  	[BUGGY]  int  len  =  super  .  read  (  buf  ,  lineCounter  ,  length  )  ;  [FE]    AssertionFailedError    expected:<[   "x  ,  y   "]  ,  z>  but  was:<[x  ,  y]  ,  z>  assertEquals(   "   "  ,  format.format())      [METHOD]    read  [TYPE]  int  [PARAMETER]  char[]  buf  int  offset  int  length  [CLASS]  ExtendedBufferedReader    [TYPE]  char  ch  [TYPE]  boolean  false  true  [TYPE]  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  [TYPE]  char[]  buf    [CONTEXT]    public  int  read  (  char[]  buf  ,  int  offset  ,  int  length  )  throws  IOException  {  if  (  length  =  =  0  )  {  return  0  ;  }  [ATTENTION]  int  len  =  super  .  read  (  buf  ,  lineCounter  ,  length  )    ;    if  (  len  >  0  )  {  for  (  int  i  =  offset  ;  i  <  offset  +  len  ;  i++  )  {  char  ch  =  buf[i]  ;  if  (  ch  =  =  '\n'  )  {  if  (  '\r'  !  =    (  i  >  0  ?  buf[i-1]:  lastChar  )  )  {  lineCounter++  ;  }  }  else  if  (  ch  =  =  '\r'  )  {  lineCounter++  ;  }  }  lastChar  =  buf[offset  +  len  -  1]  ;    }  else  if  (  len  =  =  -1  )  {  lastChar  =  END_OF_STREAM  ;  }  return  len  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java^85^^^^^80^107^
[REPLACE]    if    (    len    >    0    )    {  	[BUGGY]  if  (  len  >  =    0  )  {[FE]    AssertionFailedError    expected:<[   "x  ,  y   "]  ,  z>  but  was:<[x  ,  y]  ,  z>  assertEquals(   "   "  ,  format.format())      [METHOD]    read  [TYPE]  int  [PARAMETER]  char[]  buf  int  offset  int  length  [CLASS]  ExtendedBufferedReader    [TYPE]  char  ch  [TYPE]  boolean  false  true  [TYPE]  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  [TYPE]  char[]  buf    [CONTEXT]    public  int  read  (  char[]  buf  ,  int  offset  ,  int  length  )  throws  IOException  {  if  (  length  =  =  0  )  {  return  0  ;  }  int  len  =  super  .  read  (  buf  ,  offset  ,  length  )  ;    [ATTENTION]  if  (  len>  =  0  )  {  for  (  int  i  =  offset  ;  i  <  offset  +  len  ;  i++  )  {  char  ch  =  buf[i]  ;  if  (  ch  =  =  '\n'  )  {  if  (  '\r'  !  =    (  i  >  0  ?  buf[i-1]:  lastChar  )  )  {  lineCounter++  ;  }  }  else  if  (  ch  =  =  '\r'  )  {  lineCounter++  ;  }  }  lastChar  =  buf[offset  +  len  -  1]  ;    }  else  if  (  len  =  =  -1  )  {  lastChar  =  END_OF_STREAM  ;  }  return  len  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java^87^^^^^80^107^
[REPLACE]    }    else    if    (    len    ==    -1    )    {  	[BUGGY]    if  (  len  !  =  offset  )  {[FE]    AssertionFailedError    expected:<[   "x  ,  y   "]  ,  z>  but  was:<[x  ,  y]  ,  z>  assertEquals(   "   "  ,  format.format())      [METHOD]    read  [TYPE]  int  [PARAMETER]  char[]  buf  int  offset  int  length  [CLASS]  ExtendedBufferedReader    [TYPE]  char  ch  [TYPE]  boolean  false  true  [TYPE]  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  [TYPE]  char[]  buf    [CONTEXT]    public  int  read  (  char[]  buf  ,  int  offset  ,  int  length  )  throws  IOException  {  if  (  length  =  =  0  )  {  return  0  ;  }  int  len  =  super  .  read  (  buf  ,  offset  ,  length  )  ;    if  (  len  >  0  )  {  for  (  int  i  =  offset  ;  i  <  offset  +  len  ;  i++  )  {  char  ch  =  buf[i]  ;  if  (  ch  =  =  '\n'  )  {  if  (  '\r'  !  =    (  i  >  0  ?  buf[i-1]:  lastChar  )  )  {  lineCounter++  ;  }  }  else  if  (  ch  =  =  '\r'  )  {  lineCounter++  ;  }  }  lastChar  =  buf[offset  +  len  -  1]  ;    [ATTENTION]  }if  (  len!  =  offset  )  {  lastChar  =  END_OF_STREAM  ;  }  return  len  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java^102^^^^^80^107^
[ADD]    else    if    (    len    ==    -1    )    {    lastChar    =    END_OF_STREAM;    }  	[BUGGY]    lastChar  =  END_OF_STREAM  ;  [FE]    AssertionFailedError    expected:<[   "x  ,  y   "]  ,  z>  but  was:<[x  ,  y]  ,  z>  assertEquals(   "   "  ,  format.format())      [METHOD]    read  [TYPE]  int  [PARAMETER]  char[]  buf  int  offset  int  length  [CLASS]  ExtendedBufferedReader    [TYPE]  char  ch  [TYPE]  boolean  false  true  [TYPE]  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  [TYPE]  char[]  buf    [CONTEXT]    public  int  read  (  char[]  buf  ,  int  offset  ,  int  length  )  throws  IOException  {  if  (  length  =  =  0  )  {  return  0  ;  }  int  len  =  super  .  read  (  buf  ,  offset  ,  length  )  ;    if  (  len  >  0  )  {  for  (  int  i  =  offset  ;  i  <  offset  +  len  ;  i++  )  {  char  ch  =  buf[i]  ;  if  (  ch  =  =  '\n'  )  {  if  (  '\r'  !  =    (  i  >  0  ?  buf[i-1]:  lastChar  )  )  {  lineCounter++  ;  }  }  else  if  (  ch  =  =  '\r'  )  {  lineCounter++  ;  }  }  lastChar  =  buf[offset  +  len  -  1]  ;    [ATTENTION]  }  lastChar  =  END_OF_STREAM  ;      return  len  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java^102^103^104^^^80^107^
[REPLACE]    lastChar    =    END_OF_STREAM;  	[BUGGY]  lastChar  ;  [CE]  not  a  statement    [METHOD]    read  [TYPE]  int  [PARAMETER]  char[]  buf  int  offset  int  length  [CLASS]  ExtendedBufferedReader    [TYPE]  char  ch  [TYPE]  boolean  false  true  [TYPE]  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  [TYPE]  char[]  buf    [CONTEXT]    public  int  read  (  char[]  buf  ,  int  offset  ,  int  length  )  throws  IOException  {  if  (  length  =  =  0  )  {  return  0  ;  }  int  len  =  super  .  read  (  buf  ,  offset  ,  length  )  ;    if  (  len  >  0  )  {  for  (  int  i  =  offset  ;  i  <  offset  +  len  ;  i++  )  {  char  ch  =  buf[i]  ;  if  (  ch  =  =  '\n'  )  {  if  (  '\r'  !  =    (  i  >  0  ?  buf[i-1]:  lastChar  )  )  {  lineCounter++  ;  }  }  else  if  (  ch  =  =  '\r'  )  {  lineCounter++  ;  }  }  lastChar  =  buf[offset  +  len  -  1]  ;    }  else  if  (  len  =  =  -1  )  {  [ATTENTION]  lastChar  ;  }  return  len  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java^103^^^^^80^107^
[REPLACE]    lastChar    =    END_OF_STREAM;  	[BUGGY]  lastChar    =    lastChar  ;  [FE]    AssertionFailedError    expected:<[   "x  ,  y   "]  ,  z>  but  was:<[x  ,  y]  ,  z>  assertEquals(   "   "  ,  format.format())      [METHOD]    read  [TYPE]  int  [PARAMETER]  char[]  buf  int  offset  int  length  [CLASS]  ExtendedBufferedReader    [TYPE]  char  ch  [TYPE]  boolean  false  true  [TYPE]  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  [TYPE]  char[]  buf    [CONTEXT]    public  int  read  (  char[]  buf  ,  int  offset  ,  int  length  )  throws  IOException  {  if  (  length  =  =  0  )  {  return  0  ;  }  int  len  =  super  .  read  (  buf  ,  offset  ,  length  )  ;    if  (  len  >  0  )  {  for  (  int  i  =  offset  ;  i  <  offset  +  len  ;  i++  )  {  char  ch  =  buf[i]  ;  if  (  ch  =  =  '\n'  )  {  if  (  '\r'  !  =    (  i  >  0  ?  buf[i-1]:  lastChar  )  )  {  lineCounter++  ;  }  }  else  if  (  ch  =  =  '\r'  )  {  lineCounter++  ;  }  }  lastChar  =  buf[offset  +  len  -  1]  ;    }  else  if  (  len  =  =  -1  )  {  [ATTENTION]  lastChar  =  lastChar  ;  }  return  len  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java^103^^^^^80^107^
[REPLACE]    if    (    ch    ==    '\n'    )    {  	[BUGGY]  if  (  ch  ||  '\n'  )  {[CE]  bad  operand  types  for  binary  operator  '||'    [METHOD]    read  [TYPE]  int  [PARAMETER]  char[]  buf  int  offset  int  length  [CLASS]  ExtendedBufferedReader    [TYPE]  char  ch  [TYPE]  boolean  false  true  [TYPE]  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  [TYPE]  char[]  buf    [CONTEXT]    public  int  read  (  char[]  buf  ,  int  offset  ,  int  length  )  throws  IOException  {  if  (  length  =  =  0  )  {  return  0  ;  }  int  len  =  super  .  read  (  buf  ,  offset  ,  length  )  ;    if  (  len  >  0  )  {  for  (  int  i  =  offset  ;  i  <  offset  +  len  ;  i++  )  {  char  ch  =  buf[i]  ;  [ATTENTION]  if  (  ch||'\n'  )  {  if  (  '\r'  !  =    (  i  >  0  ?  buf[i-1]:  lastChar  )  )  {  lineCounter++  ;  }  }  else  if  (  ch  =  =  '\r'  )  {  lineCounter++  ;  }  }  lastChar  =  buf[offset  +  len  -  1]  ;    }  else  if  (  len  =  =  -1  )  {  lastChar  =  END_OF_STREAM  ;  }  return  len  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java^91^^^^^80^107^
[REPLACE]    }    else    if    (    ch    ==    '\r'    )    {  	[BUGGY]    if  (  ch  !  =    '\r'  )  {[FE]    AssertionFailedError    expected:<[   "x  ,  y   "]  ,  z>  but  was:<[x  ,  y]  ,  z>  assertEquals(   "   "  ,  format.format())      [METHOD]    read  [TYPE]  int  [PARAMETER]  char[]  buf  int  offset  int  length  [CLASS]  ExtendedBufferedReader    [TYPE]  char  ch  [TYPE]  boolean  false  true  [TYPE]  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  [TYPE]  char[]  buf    [CONTEXT]    public  int  read  (  char[]  buf  ,  int  offset  ,  int  length  )  throws  IOException  {  if  (  length  =  =  0  )  {  return  0  ;  }  int  len  =  super  .  read  (  buf  ,  offset  ,  length  )  ;    if  (  len  >  0  )  {  for  (  int  i  =  offset  ;  i  <  offset  +  len  ;  i++  )  {  char  ch  =  buf[i]  ;  if  (  ch  =  =  '\n'  )  {  if  (  '\r'  !  =    (  i  >  0  ?  buf[i-1]:  lastChar  )  )  {  lineCounter++  ;  }  [ATTENTION]  }if  (  ch!  =  '\r'  )  {  lineCounter++  ;  }  }  lastChar  =  buf[offset  +  len  -  1]  ;    }  else  if  (  len  =  =  -1  )  {  lastChar  =  END_OF_STREAM  ;  }  return  len  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java^95^^^^^80^107^
[ADD]    else    if    (    ch    ==    '\r'    )    {    lineCounter++;    }  	[BUGGY]    lineCounter++  ;  [FE]    AssertionFailedError    expected:<[   "x  ,  y   "]  ,  z>  but  was:<[x  ,  y]  ,  z>  assertEquals(   "   "  ,  format.format())      [METHOD]    read  [TYPE]  int  [PARAMETER]  char[]  buf  int  offset  int  length  [CLASS]  ExtendedBufferedReader    [TYPE]  char  ch  [TYPE]  boolean  false  true  [TYPE]  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  [TYPE]  char[]  buf    [CONTEXT]    public  int  read  (  char[]  buf  ,  int  offset  ,  int  length  )  throws  IOException  {  if  (  length  =  =  0  )  {  return  0  ;  }  int  len  =  super  .  read  (  buf  ,  offset  ,  length  )  ;    if  (  len  >  0  )  {  for  (  int  i  =  offset  ;  i  <  offset  +  len  ;  i++  )  {  char  ch  =  buf[i]  ;  if  (  ch  =  =  '\n'  )  {  if  (  '\r'  !  =    (  i  >  0  ?  buf[i-1]:  lastChar  )  )  {  lineCounter++  ;  }  [ATTENTION]  }  lineCounter++  ;    }  lastChar  =  buf[offset  +  len  -  1]  ;    }  else  if  (  len  =  =  -1  )  {  lastChar  =  END_OF_STREAM  ;  }  return  len  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java^95^96^97^^^80^107^
[REPLACE]    if    (    '\r'    !=    (    i    >    0    ?    buf[i-1]:    lastChar    )    )    {  	[BUGGY]  if  (  '\r'    =    buf[i-1]  ;  [CE]  ')'  expected    [METHOD]    read  [TYPE]  int  [PARAMETER]  char[]  buf  int  offset  int  length  [CLASS]  ExtendedBufferedReader    [TYPE]  char  ch  [TYPE]  boolean  false  true  [TYPE]  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  [TYPE]  char[]  buf    [CONTEXT]    public  int  read  (  char[]  buf  ,  int  offset  ,  int  length  )  throws  IOException  {  if  (  length  =  =  0  )  {  return  0  ;  }  int  len  =  super  .  read  (  buf  ,  offset  ,  length  )  ;    if  (  len  >  0  )  {  for  (  int  i  =  offset  ;  i  <  offset  +  len  ;  i++  )  {  char  ch  =  buf[i]  ;  if  (  ch  =  =  '\n'  )  {  [ATTENTION]  if  (  '\r'  =  buf[i-1]  ;  lineCounter++  ;  }  }  else  if  (  ch  =  =  '\r'  )  {  lineCounter++  ;  }  }  lastChar  =  buf[offset  +  len  -  1]  ;    }  else  if  (  len  =  =  -1  )  {  lastChar  =  END_OF_STREAM  ;  }  return  len  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java^92^^^^^80^107^
[REPLACE]    if    (    '\r'    !=    (    i    >    0    ?    buf[i-1]:    lastChar    )    )    {  	[BUGGY]  if  (  '\r'  !  =    lastChar  )  )  {[CE]  ')'  expected    [METHOD]    read  [TYPE]  int  [PARAMETER]  char[]  buf  int  offset  int  length  [CLASS]  ExtendedBufferedReader    [TYPE]  char  ch  [TYPE]  boolean  false  true  [TYPE]  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  [TYPE]  char[]  buf    [CONTEXT]    public  int  read  (  char[]  buf  ,  int  offset  ,  int  length  )  throws  IOException  {  if  (  length  =  =  0  )  {  return  0  ;  }  int  len  =  super  .  read  (  buf  ,  offset  ,  length  )  ;    if  (  len  >  0  )  {  for  (  int  i  =  offset  ;  i  <  offset  +  len  ;  i++  )  {  char  ch  =  buf[i]  ;  if  (  ch  =  =  '\n'  )  {  [ATTENTION]  if  (  '\r'  !  =  lastChar  )  )  {  lineCounter++  ;  }  }  else  if  (  ch  =  =  '\r'  )  {  lineCounter++  ;  }  }  lastChar  =  buf[offset  +  len  -  1]  ;    }  else  if  (  len  =  =  -1  )  {  lastChar  =  END_OF_STREAM  ;  }  return  len  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java^92^^^^^80^107^
[REPLACE]    }    else    if    (    ch    ==    '\r'    )    {  	[BUGGY]    else  {[FE]    AssertionFailedError    expected:<[   "x  ,  y   "]  ,  z>  but  was:<[x  ,  y]  ,  z>  assertEquals(   "   "  ,  format.format())      [METHOD]    read  [TYPE]  int  [PARAMETER]  char[]  buf  int  offset  int  length  [CLASS]  ExtendedBufferedReader    [TYPE]  char  ch  [TYPE]  boolean  false  true  [TYPE]  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  [TYPE]  char[]  buf    [CONTEXT]    public  int  read  (  char[]  buf  ,  int  offset  ,  int  length  )  throws  IOException  {  if  (  length  =  =  0  )  {  return  0  ;  }  int  len  =  super  .  read  (  buf  ,  offset  ,  length  )  ;    if  (  len  >  0  )  {  for  (  int  i  =  offset  ;  i  <  offset  +  len  ;  i++  )  {  char  ch  =  buf[i]  ;  if  (  ch  =  =  '\n'  )  {  if  (  '\r'  !  =    (  i  >  0  ?  buf[i-1]:  lastChar  )  )  {  lineCounter++  ;  }  [ATTENTION]  }else  {  lineCounter++  ;  }  }  lastChar  =  buf[offset  +  len  -  1]  ;    }  else  if  (  len  =  =  -1  )  {  lastChar  =  END_OF_STREAM  ;  }  return  len  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java^95^^^^^80^107^
[REPLACE]    for    (    int    i    =    offset;    i    <    offset    +    len;    i++    )    {  	[BUGGY]  for  (  int  i  =  offset  ;  i  >  =    offset  +  len  ;  i++  )  {[FE]    AssertionFailedError    expected:<[   "x  ,  y   "]  ,  z>  but  was:<[x  ,  y]  ,  z>  assertEquals(   "   "  ,  format.format())      [METHOD]    read  [TYPE]  int  [PARAMETER]  char[]  buf  int  offset  int  length  [CLASS]  ExtendedBufferedReader    [TYPE]  char  ch  [TYPE]  boolean  false  true  [TYPE]  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  [TYPE]  char[]  buf    [CONTEXT]    public  int  read  (  char[]  buf  ,  int  offset  ,  int  length  )  throws  IOException  {  if  (  length  =  =  0  )  {  return  0  ;  }  int  len  =  super  .  read  (  buf  ,  offset  ,  length  )  ;    if  (  len  >  0  )  {  [ATTENTION]  for  (  int  i  =  offset  ;  i>  =  offset  +  len  ;  i++  )  {  char  ch  =  buf[i]  ;  if  (  ch  =  =  '\n'  )  {  if  (  '\r'  !  =    (  i  >  0  ?  buf[i-1]:  lastChar  )  )  {  lineCounter++  ;  }  }  else  if  (  ch  =  =  '\r'  )  {  lineCounter++  ;  }  }  lastChar  =  buf[offset  +  len  -  1]  ;    }  else  if  (  len  =  =  -1  )  {  lastChar  =  END_OF_STREAM  ;  }  return  len  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java^89^^^^^80^107^
[ADD]    if    (    '\r'    !=    (    i    >    0    ?    buf[i-1]:    lastChar    )    )    {    lineCounter++;    }  	[BUGGY]  [FE]    AssertionFailedError    expected:<[   "x  ,  y   "]  ,  z>  but  was:<[x  ,  y]  ,  z>  assertEquals(   "   "  ,  format.format())      [METHOD]    read  [TYPE]  int  [PARAMETER]  char[]  buf  int  offset  int  length  [CLASS]  ExtendedBufferedReader    [TYPE]  char  ch  [TYPE]  boolean  false  true  [TYPE]  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  [TYPE]  char[]  buf    [CONTEXT]    public  int  read  (  char[]  buf  ,  int  offset  ,  int  length  )  throws  IOException  {  if  (  length  =  =  0  )  {  return  0  ;  }  int  len  =  super  .  read  (  buf  ,  offset  ,  length  )  ;    if  (  len  >  0  )  {  for  (  int  i  =  offset  ;  i  <  offset  +  len  ;  i++  )  {  char  ch  =  buf[i]  ;  if  (  ch  =  =  '\n'  )  {  [ATTENTION]    }  else  if  (  ch  =  =  '\r'  )  {  lineCounter++  ;  }  }  lastChar  =  buf[offset  +  len  -  1]  ;    }  else  if  (  len  =  =  -1  )  {  lastChar  =  END_OF_STREAM  ;  }  return  len  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java^92^93^94^^^80^107^
[REPLACE]    if    (    '\r'    !=    (    i    >    0    ?    buf[i-1]:    lastChar    )    )    {  	[BUGGY]  if  (  '\r'  !  =    buf[i-1]  ;  [CE]  ')'  expected    [METHOD]    read  [TYPE]  int  [PARAMETER]  char[]  buf  int  offset  int  length  [CLASS]  ExtendedBufferedReader    [TYPE]  char  ch  [TYPE]  boolean  false  true  [TYPE]  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  [TYPE]  char[]  buf    [CONTEXT]    public  int  read  (  char[]  buf  ,  int  offset  ,  int  length  )  throws  IOException  {  if  (  length  =  =  0  )  {  return  0  ;  }  int  len  =  super  .  read  (  buf  ,  offset  ,  length  )  ;    if  (  len  >  0  )  {  for  (  int  i  =  offset  ;  i  <  offset  +  len  ;  i++  )  {  char  ch  =  buf[i]  ;  if  (  ch  =  =  '\n'  )  {  [ATTENTION]  if  (  '\r'  !  =  buf[i-1]  ;  lineCounter++  ;  }  }  else  if  (  ch  =  =  '\r'  )  {  lineCounter++  ;  }  }  lastChar  =  buf[offset  +  len  -  1]  ;    }  else  if  (  len  =  =  -1  )  {  lastChar  =  END_OF_STREAM  ;  }  return  len  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java^92^^^^^80^107^
[ADD]    if    (    '\r'    !=    (    i    >    0    ?    buf[i-1]:    lastChar    )    )    {    lineCounter++;    }  	[BUGGY]  lineCounter++  ;  [FE]    AssertionFailedError    expected:<[   "x  ,  y   "]  ,  z>  but  was:<[x  ,  y]  ,  z>  assertEquals(   "   "  ,  format.format())      [METHOD]    read  [TYPE]  int  [PARAMETER]  char[]  buf  int  offset  int  length  [CLASS]  ExtendedBufferedReader    [TYPE]  char  ch  [TYPE]  boolean  false  true  [TYPE]  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  [TYPE]  char[]  buf    [CONTEXT]    public  int  read  (  char[]  buf  ,  int  offset  ,  int  length  )  throws  IOException  {  if  (  length  =  =  0  )  {  return  0  ;  }  int  len  =  super  .  read  (  buf  ,  offset  ,  length  )  ;    if  (  len  >  0  )  {  for  (  int  i  =  offset  ;  i  <  offset  +  len  ;  i++  )  {  char  ch  =  buf[i]  ;  if  (  ch  =  =  '\n'  )  {  [ATTENTION]  lineCounter++  ;    }  else  if  (  ch  =  =  '\r'  )  {  lineCounter++  ;  }  }  lastChar  =  buf[offset  +  len  -  1]  ;    }  else  if  (  len  =  =  -1  )  {  lastChar  =  END_OF_STREAM  ;  }  return  len  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java^92^93^94^^^80^107^
[REPLACE]    char    ch    =    buf[i];  	[BUGGY]  for  (  int  i  =  offset  ;  i  <  offset  +  len  ;  i++  )  {  char  ch  =  buf[i]  ;  [CE]  'else'  without  'if'    [METHOD]    read  [TYPE]  int  [PARAMETER]  char[]  buf  int  offset  int  length  [CLASS]  ExtendedBufferedReader    [TYPE]  char  ch  [TYPE]  boolean  false  true  [TYPE]  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  [TYPE]  char[]  buf    [CONTEXT]    public  int  read  (  char[]  buf  ,  int  offset  ,  int  length  )  throws  IOException  {  if  (  length  =  =  0  )  {  return  0  ;  }  int  len  =  super  .  read  (  buf  ,  offset  ,  length  )  ;    if  (  len  >  0  )  {  for  (  int  i  =  offset  ;  i  <  offset  +  len  ;  i++  )  {  [ATTENTION]  for  (  int  i  =  offset  ;  i  <  offset  +  len  ;  i++  )  {  char  ch  =  buf[i]  ;  if  (  ch  =  =  '\n'  )  {  if  (  '\r'  !  =    (  i  >  0  ?  buf[i-1]:  lastChar  )  )  {  lineCounter++  ;  }  }  else  if  (  ch  =  =  '\r'  )  {  lineCounter++  ;  }  }  lastChar  =  buf[offset  +  len  -  1]  ;    }  else  if  (  len  =  =  -1  )  {  lastChar  =  END_OF_STREAM  ;  }  return  len  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java^90^^^^^80^107^
[REPLACE]    lastChar    =    buf[offset    +    len    -    1];  	[BUGGY]  lastChar  =  buf[offset  +  len  -offset]  ;  [FE]    AssertionFailedError    expected:<[   "x  ,  y   "]  ,  z>  but  was:<[x  ,  y]  ,  z>  assertEquals(   "   "  ,  format.format())      [METHOD]    read  [TYPE]  int  [PARAMETER]  char[]  buf  int  offset  int  length  [CLASS]  ExtendedBufferedReader    [TYPE]  char  ch  [TYPE]  boolean  false  true  [TYPE]  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  [TYPE]  char[]  buf    [CONTEXT]    public  int  read  (  char[]  buf  ,  int  offset  ,  int  length  )  throws  IOException  {  if  (  length  =  =  0  )  {  return  0  ;  }  int  len  =  super  .  read  (  buf  ,  offset  ,  length  )  ;    if  (  len  >  0  )  {  for  (  int  i  =  offset  ;  i  <  offset  +  len  ;  i++  )  {  char  ch  =  buf[i]  ;  if  (  ch  =  =  '\n'  )  {  if  (  '\r'  !  =    (  i  >  0  ?  buf[i-1]:  lastChar  )  )  {  lineCounter++  ;  }  }  else  if  (  ch  =  =  '\r'  )  {  lineCounter++  ;  }  }  [ATTENTION]  lastChar  =  buf[offset  +  len  -offset]  ;    }  else  if  (  len  =  =  -1  )  {  lastChar  =  END_OF_STREAM  ;  }  return  len  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java^100^^^^^80^107^
[REPLACE]    for    (    int    i    =    offset;    i    <    offset    +    len;    i++    )    {  	[BUGGY]  for  (  int  i  =  lineCounter  ;  i  <  offset  +  len  ;  i++  )  {[FE]    AssertionFailedError    expected:<[   "x  ,  y   "]  ,  z>  but  was:<[x  ,  y]  ,  z>  assertEquals(   "   "  ,  format.format())      [METHOD]    read  [TYPE]  int  [PARAMETER]  char[]  buf  int  offset  int  length  [CLASS]  ExtendedBufferedReader    [TYPE]  char  ch  [TYPE]  boolean  false  true  [TYPE]  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  [TYPE]  char[]  buf    [CONTEXT]    public  int  read  (  char[]  buf  ,  int  offset  ,  int  length  )  throws  IOException  {  if  (  length  =  =  0  )  {  return  0  ;  }  int  len  =  super  .  read  (  buf  ,  offset  ,  length  )  ;    if  (  len  >  0  )  {  [ATTENTION]  for  (  int  i  =  lineCounter  ;  i  <  offset  +  len  ;  i++  )  {  char  ch  =  buf[i]  ;  if  (  ch  =  =  '\n'  )  {  if  (  '\r'  !  =    (  i  >  0  ?  buf[i-1]:  lastChar  )  )  {  lineCounter++  ;  }  }  else  if  (  ch  =  =  '\r'  )  {  lineCounter++  ;  }  }  lastChar  =  buf[offset  +  len  -  1]  ;    }  else  if  (  len  =  =  -1  )  {  lastChar  =  END_OF_STREAM  ;  }  return  len  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java^89^^^^^80^107^
[REPLACE]    }    else    if    (    ch    ==    '\r'    )    {  	[BUGGY]    if  (  ch  ||  '\r'  )  {[CE]  bad  operand  types  for  binary  operator  '||'    [METHOD]    read  [TYPE]  int  [PARAMETER]  char[]  buf  int  offset  int  length  [CLASS]  ExtendedBufferedReader    [TYPE]  char  ch  [TYPE]  boolean  false  true  [TYPE]  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  [TYPE]  char[]  buf    [CONTEXT]    public  int  read  (  char[]  buf  ,  int  offset  ,  int  length  )  throws  IOException  {  if  (  length  =  =  0  )  {  return  0  ;  }  int  len  =  super  .  read  (  buf  ,  offset  ,  length  )  ;    if  (  len  >  0  )  {  for  (  int  i  =  offset  ;  i  <  offset  +  len  ;  i++  )  {  char  ch  =  buf[i]  ;  if  (  ch  =  =  '\n'  )  {  if  (  '\r'  !  =    (  i  >  0  ?  buf[i-1]:  lastChar  )  )  {  lineCounter++  ;  }  [ATTENTION]  }if  (  ch||'\r'  )  {  lineCounter++  ;  }  }  lastChar  =  buf[offset  +  len  -  1]  ;    }  else  if  (  len  =  =  -1  )  {  lastChar  =  END_OF_STREAM  ;  }  return  len  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java^95^^^^^80^107^
[REMOVE]      	[BUGGY]  if  (  (  current  =  =  '\r'  )  ||  (  (  current  =  =  '\n'  )  &&  (  (  lastChar  )  !  =  '\r'  )  )  )  {      (  lineCounter  )  ++  ;  }[CE]  cannot  find  symbol  current    [METHOD]    read  [TYPE]  int  [PARAMETER]  char[]  buf  int  offset  int  length  [CLASS]  ExtendedBufferedReader    [TYPE]  char  ch  [TYPE]  boolean  false  true  [TYPE]  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  [TYPE]  char[]  buf    [CONTEXT]    public  int  read  (  char[]  buf  ,  int  offset  ,  int  length  )  throws  IOException  {  if  (  length  =  =  0  )  {  return  0  ;  }  int  len  =  super  .  read  (  buf  ,  offset  ,  length  )  ;    if  (  len  >  0  )  {  for  (  int  i  =  offset  ;  i  <  offset  +  len  ;  i++  )  {  char  ch  =  buf[i]  ;  if  (  ch  =  =  '\n'  )  {  [ATTENTION]  if  (  '\r'  !  =    (  i  >  0  ?  buf[i-1]:  lastChar  )  )  {  if  (  (  current  =  =  '\r'  )  ||  (  (  current  =  =  '\n'  )  &&  (  (  lastChar  )  !  =  '\r'  )  )  )  {  (  lineCounter  )  ++  ;  }lineCounter++  ;  }  }  else  if  (  ch  =  =  '\r'  )  {  lineCounter++  ;  }  }  lastChar  =  buf[offset  +  len  -  1]  ;    }  else  if  (  len  =  =  -1  )  {  lastChar  =  END_OF_STREAM  ;  }  return  len  ;      	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java^92^^^^^80^107^
[REPLACE]    }    else    if    (    ch    ==    '\r'    )    {  	[BUGGY]    if  (  ch  &&  '\r'  )  {[CE]  bad  operand  types  for  binary  operator  '&&'    [METHOD]    read  [TYPE]  int  [PARAMETER]  char[]  buf  int  offset  int  length  [CLASS]  ExtendedBufferedReader    [TYPE]  char  ch  [TYPE]  boolean  false  true  [TYPE]  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  [TYPE]  char[]  buf    [CONTEXT]    public  int  read  (  char[]  buf  ,  int  offset  ,  int  length  )  throws  IOException  {  if  (  length  =  =  0  )  {  return  0  ;  }  int  len  =  super  .  read  (  buf  ,  offset  ,  length  )  ;    if  (  len  >  0  )  {  for  (  int  i  =  offset  ;  i  <  offset  +  len  ;  i++  )  {  char  ch  =  buf[i]  ;  if  (  ch  =  =  '\n'  )  {  if  (  '\r'  !  =    (  i  >  0  ?  buf[i-1]:  lastChar  )  )  {  lineCounter++  ;  }  [ATTENTION]  }if  (  ch&&'\r'  )  {  lineCounter++  ;  }  }  lastChar  =  buf[offset  +  len  -  1]  ;    }  else  if  (  len  =  =  -1  )  {  lastChar  =  END_OF_STREAM  ;  }  return  len  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java^95^^^^^80^107^
[REPLACE]    }    else    if    (    len    ==    -1    )    {  	[BUGGY]    else  {[FE]    AssertionFailedError    expected:<[   "x  ,  y   "]  ,  z>  but  was:<[x  ,  y]  ,  z>  assertEquals(   "   "  ,  format.format())      [METHOD]    read  [TYPE]  int  [PARAMETER]  char[]  buf  int  offset  int  length  [CLASS]  ExtendedBufferedReader    [TYPE]  char  ch  [TYPE]  boolean  false  true  [TYPE]  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  [TYPE]  char[]  buf    [CONTEXT]    public  int  read  (  char[]  buf  ,  int  offset  ,  int  length  )  throws  IOException  {  if  (  length  =  =  0  )  {  return  0  ;  }  int  len  =  super  .  read  (  buf  ,  offset  ,  length  )  ;    if  (  len  >  0  )  {  for  (  int  i  =  offset  ;  i  <  offset  +  len  ;  i++  )  {  char  ch  =  buf[i]  ;  if  (  ch  =  =  '\n'  )  {  if  (  '\r'  !  =    (  i  >  0  ?  buf[i-1]:  lastChar  )  )  {  lineCounter++  ;  }  }  else  if  (  ch  =  =  '\r'  )  {  lineCounter++  ;  }  }  lastChar  =  buf[offset  +  len  -  1]  ;    [ATTENTION]  }else  {  lastChar  =  END_OF_STREAM  ;  }  return  len  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java^102^^^^^80^107^
[REPLACE]    lastChar    =    END_OF_STREAM;  	[BUGGY]  lastChar    =  null  ;  [CE]  incompatible  types    [METHOD]    read  [TYPE]  int  [PARAMETER]  char[]  buf  int  offset  int  length  [CLASS]  ExtendedBufferedReader    [TYPE]  char  ch  [TYPE]  boolean  false  true  [TYPE]  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  [TYPE]  char[]  buf    [CONTEXT]    public  int  read  (  char[]  buf  ,  int  offset  ,  int  length  )  throws  IOException  {  if  (  length  =  =  0  )  {  return  0  ;  }  int  len  =  super  .  read  (  buf  ,  offset  ,  length  )  ;    if  (  len  >  0  )  {  for  (  int  i  =  offset  ;  i  <  offset  +  len  ;  i++  )  {  char  ch  =  buf[i]  ;  if  (  ch  =  =  '\n'  )  {  if  (  '\r'  !  =    (  i  >  0  ?  buf[i-1]:  lastChar  )  )  {  lineCounter++  ;  }  }  else  if  (  ch  =  =  '\r'  )  {  lineCounter++  ;  }  }  lastChar  =  buf[offset  +  len  -  1]  ;    }  else  if  (  len  =  =  -1  )  {  [ATTENTION]  lastChar  =  null  ;  }  return  len  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java^103^^^^^80^107^
[REPLACE]    for    (    int    i    =    offset;    i    <    offset    +    len;    i++    )    {  	[BUGGY]  for  (lineCounternt  i  =  offset  ;  i  >  =    offset  +  len  ;  i++  )  {[CE]  cannot  find  symbol    [METHOD]    read  [TYPE]  int  [PARAMETER]  char[]  buf  int  offset  int  length  [CLASS]  ExtendedBufferedReader    [TYPE]  char  ch  [TYPE]  boolean  false  true  [TYPE]  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  [TYPE]  char[]  buf    [CONTEXT]    public  int  read  (  char[]  buf  ,  int  offset  ,  int  length  )  throws  IOException  {  if  (  length  =  =  0  )  {  return  0  ;  }  int  len  =  super  .  read  (  buf  ,  offset  ,  length  )  ;    if  (  len  >  0  )  {  [ATTENTION]  for  (  lineCounternt  i  =  offset  ;  i>  =  offset  +  len  ;  i++  )  {  char  ch  =  buf[i]  ;  if  (  ch  =  =  '\n'  )  {  if  (  '\r'  !  =    (  i  >  0  ?  buf[i-1]:  lastChar  )  )  {  lineCounter++  ;  }  }  else  if  (  ch  =  =  '\r'  )  {  lineCounter++  ;  }  }  lastChar  =  buf[offset  +  len  -  1]  ;    }  else  if  (  len  =  =  -1  )  {  lastChar  =  END_OF_STREAM  ;  }  return  len  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java^89^^^^^80^107^
[ADD]    if    (    ch    ==    '\n'    )    {    if    (    '\r'    !=    (    i    >    0    ?    buf[i-1]:    lastChar    )    )    {    lineCounter++;    }  	[BUGGY]  [CE]  'else'  without  'if'    [METHOD]    read  [TYPE]  int  [PARAMETER]  char[]  buf  int  offset  int  length  [CLASS]  ExtendedBufferedReader    [TYPE]  char  ch  [TYPE]  boolean  false  true  [TYPE]  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  [TYPE]  char[]  buf    [CONTEXT]    public  int  read  (  char[]  buf  ,  int  offset  ,  int  length  )  throws  IOException  {  if  (  length  =  =  0  )  {  return  0  ;  }  int  len  =  super  .  read  (  buf  ,  offset  ,  length  )  ;    if  (  len  >  0  )  {  for  (  int  i  =  offset  ;  i  <  offset  +  len  ;  i++  )  {  char  ch  =  buf[i]  ;  [ATTENTION]      }  else  if  (  ch  =  =  '\r'  )  {  lineCounter++  ;  }  }  lastChar  =  buf[offset  +  len  -  1]  ;    }  else  if  (  len  =  =  -1  )  {  lastChar  =  END_OF_STREAM  ;  }  return  len  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java^91^92^93^94^^80^107^
[REMOVE]      	[BUGGY]  if  (  (  current  =  =  '\r'  )  ||  (  (  current  =  =  '\n'  )  &&  (  (  lastChar  )  !  =  '\r'  )  )  )  {      (  lineCounter  )  ++  ;  }[CE]  cannot  find  symbol  current    [METHOD]    read  [TYPE]  int  [PARAMETER]  char[]  buf  int  offset  int  length  [CLASS]  ExtendedBufferedReader    [TYPE]  char  ch  [TYPE]  boolean  false  true  [TYPE]  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  [TYPE]  char[]  buf    [CONTEXT]    public  int  read  (  char[]  buf  ,  int  offset  ,  int  length  )  throws  IOException  {  if  (  length  =  =  0  )  {  return  0  ;  }  int  len  =  super  .  read  (  buf  ,  offset  ,  length  )  ;    if  (  len  >  0  )  {  for  (  int  i  =  offset  ;  i  <  offset  +  len  ;  i++  )  {  char  ch  =  buf[i]  ;  if  (  ch  =  =  '\n'  )  {  if  (  '\r'  !  =    (  i  >  0  ?  buf[i-1]:  lastChar  )  )  {  lineCounter++  ;  }  [ATTENTION]  }  else  if  (  ch  =  =  '\r'  )  {  if  (  (  current  =  =  '\r'  )  ||  (  (  current  =  =  '\n'  )  &&  (  (  lastChar  )  !  =  '\r'  )  )  )  {  (  lineCounter  )  ++  ;  }lineCounter++  ;  }  }  lastChar  =  buf[offset  +  len  -  1]  ;    }  else  if  (  len  =  =  -1  )  {  lastChar  =  END_OF_STREAM  ;  }  return  len  ;      	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java^95^^^^^80^107^
[ADD]    else    if    (    ch    ==    '\r'    )    {    lineCounter++;    }  	[BUGGY]  [FE]    AssertionFailedError    expected:<[   "x  ,  y   "]  ,  z>  but  was:<[x  ,  y]  ,  z>  assertEquals(   "   "  ,  format.format())      [METHOD]    read  [TYPE]  int  [PARAMETER]  char[]  buf  int  offset  int  length  [CLASS]  ExtendedBufferedReader    [TYPE]  char  ch  [TYPE]  boolean  false  true  [TYPE]  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  [TYPE]  char[]  buf    [CONTEXT]    public  int  read  (  char[]  buf  ,  int  offset  ,  int  length  )  throws  IOException  {  if  (  length  =  =  0  )  {  return  0  ;  }  int  len  =  super  .  read  (  buf  ,  offset  ,  length  )  ;    if  (  len  >  0  )  {  for  (  int  i  =  offset  ;  i  <  offset  +  len  ;  i++  )  {  char  ch  =  buf[i]  ;  if  (  ch  =  =  '\n'  )  {  if  (  '\r'  !  =    (  i  >  0  ?  buf[i-1]:  lastChar  )  )  {  lineCounter++  ;  }  [ATTENTION]  }    }  lastChar  =  buf[offset  +  len  -  1]  ;    }  else  if  (  len  =  =  -1  )  {  lastChar  =  END_OF_STREAM  ;  }  return  len  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java^95^96^97^^^80^107^
[REPLACE]    lastChar    =    buf[offset    +    len    -    1];  	[BUGGY]  lastChar  =  buf[offset  +  len  ||  1]  ;  [CE]  bad  operand  types  for  binary  operator  '||'    [METHOD]    read  [TYPE]  int  [PARAMETER]  char[]  buf  int  offset  int  length  [CLASS]  ExtendedBufferedReader    [TYPE]  char  ch  [TYPE]  boolean  false  true  [TYPE]  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  [TYPE]  char[]  buf    [CONTEXT]    public  int  read  (  char[]  buf  ,  int  offset  ,  int  length  )  throws  IOException  {  if  (  length  =  =  0  )  {  return  0  ;  }  int  len  =  super  .  read  (  buf  ,  offset  ,  length  )  ;    if  (  len  >  0  )  {  for  (  int  i  =  offset  ;  i  <  offset  +  len  ;  i++  )  {  char  ch  =  buf[i]  ;  if  (  ch  =  =  '\n'  )  {  if  (  '\r'  !  =    (  i  >  0  ?  buf[i-1]:  lastChar  )  )  {  lineCounter++  ;  }  }  else  if  (  ch  =  =  '\r'  )  {  lineCounter++  ;  }  }  [ATTENTION]  lastChar  =  buf[offset  +  len||1]  ;    }  else  if  (  len  =  =  -1  )  {  lastChar  =  END_OF_STREAM  ;  }  return  len  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java^100^^^^^80^107^
[ADD]    lastChar    =    END_OF_STREAM;  	[BUGGY]  [FE]    AssertionFailedError    expected:<[   "x  ,  y   "]  ,  z>  but  was:<[x  ,  y]  ,  z>  assertEquals(   "   "  ,  format.format())      [METHOD]    read  [TYPE]  int  [PARAMETER]  char[]  buf  int  offset  int  length  [CLASS]  ExtendedBufferedReader    [TYPE]  char  ch  [TYPE]  boolean  false  true  [TYPE]  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  [TYPE]  char[]  buf    [CONTEXT]    public  int  read  (  char[]  buf  ,  int  offset  ,  int  length  )  throws  IOException  {  if  (  length  =  =  0  )  {  return  0  ;  }  int  len  =  super  .  read  (  buf  ,  offset  ,  length  )  ;    if  (  len  >  0  )  {  for  (  int  i  =  offset  ;  i  <  offset  +  len  ;  i++  )  {  char  ch  =  buf[i]  ;  if  (  ch  =  =  '\n'  )  {  if  (  '\r'  !  =    (  i  >  0  ?  buf[i-1]:  lastChar  )  )  {  lineCounter++  ;  }  }  else  if  (  ch  =  =  '\r'  )  {  lineCounter++  ;  }  }  lastChar  =  buf[offset  +  len  -  1]  ;    }  else  if  (  len  =  =  -1  )  {  [ATTENTION]  }  return  len  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java^103^^^^^80^107^
[REPLACE]    return    len;  	[BUGGY]  return  lineCounter  ;  [FE]    AssertionFailedError    expected:<[   "x  ,  y   "]  ,  z>  but  was:<[x  ,  y]  ,  z>  assertEquals(   "   "  ,  format.format())      [METHOD]    read  [TYPE]  int  [PARAMETER]  char[]  buf  int  offset  int  length  [CLASS]  ExtendedBufferedReader    [TYPE]  char  ch  [TYPE]  boolean  false  true  [TYPE]  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  [TYPE]  char[]  buf    [CONTEXT]    public  int  read  (  char[]  buf  ,  int  offset  ,  int  length  )  throws  IOException  {  if  (  length  =  =  0  )  {  return  0  ;  }  int  len  =  super  .  read  (  buf  ,  offset  ,  length  )  ;    if  (  len  >  0  )  {  for  (  int  i  =  offset  ;  i  <  offset  +  len  ;  i++  )  {  char  ch  =  buf[i]  ;  if  (  ch  =  =  '\n'  )  {  if  (  '\r'  !  =    (  i  >  0  ?  buf[i-1]:  lastChar  )  )  {  lineCounter++  ;  }  }  else  if  (  ch  =  =  '\r'  )  {  lineCounter++  ;  }  }  lastChar  =  buf[offset  +  len  -  1]  ;    }  else  if  (  len  =  =  -1  )  {  lastChar  =  END_OF_STREAM  ;  }  [ATTENTION]  return  lineCounter  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java^106^^^^^80^107^
[REPLACE]    String    line    =    super    .    readLine    (    )    ;  	[BUGGY]  String  line  =  super  .  read  (  )    ;  [CE]  incompatible  types    [METHOD]    readLine  [TYPE]  String  [PARAMETER]  [CLASS]  ExtendedBufferedReader    [TYPE]  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  [TYPE]  String  line  [TYPE]  boolean  false  true    [CONTEXT]    public  String  readLine  (  )  throws  IOException  {  [ATTENTION]  String  line  =  super  .  read  (  )  ;    if  (  line  !  =  null  )  {  if  (  line  .  length  (  )  >  0  )  {  lastChar  =  line  .  charAt  (  line  .  length  (  )  -  1  )  ;  }  lineCounter++  ;  }  else  {  lastChar  =  END_OF_STREAM  ;  }  return  line  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java^123^^^^^122^135^
[ADD]    String    line    =    super    .    readLine    (    )    ;  	[BUGGY]  [CE]  cannot  find  symbol  line    [METHOD]    readLine  [TYPE]  String  [PARAMETER]  [CLASS]  ExtendedBufferedReader    [TYPE]  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  [TYPE]  String  line  [TYPE]  boolean  false  true    [CONTEXT]    public  String  readLine  (  )  throws  IOException  {  [ATTENTION]    if  (  line  !  =  null  )  {  if  (  line  .  length  (  )  >  0  )  {  lastChar  =  line  .  charAt  (  line  .  length  (  )  -  1  )  ;  }  lineCounter++  ;  }  else  {  lastChar  =  END_OF_STREAM  ;  }  return  line  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java^123^^^^^122^135^
[REPLACE]    if    (    line    !=    null    )    {  	[BUGGY]  if  (  line  =  =  null  )  {[FE]    AssertionFailedError    expected:<[   "x  ,  y   "]  ,  z>  but  was:<[x  ,  y]  ,  z>  assertEquals(   "   "  ,  format.format())      [METHOD]    readLine  [TYPE]  String  [PARAMETER]  [CLASS]  ExtendedBufferedReader    [TYPE]  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  [TYPE]  String  line  [TYPE]  boolean  false  true    [CONTEXT]    public  String  readLine  (  )  throws  IOException  {  String  line  =  super  .  readLine  (  )  ;    [ATTENTION]  if  (  line  =  =  null  )  {  if  (  line  .  length  (  )  >  0  )  {  lastChar  =  line  .  charAt  (  line  .  length  (  )  -  1  )  ;  }  lineCounter++  ;  }  else  {  lastChar  =  END_OF_STREAM  ;  }  return  line  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java^125^^^^^122^135^
[REPLACE]    lastChar    =    END_OF_STREAM;  	[BUGGY]  lastChar    =  null  ;  [CE]  incompatible  types    [METHOD]    readLine  [TYPE]  String  [PARAMETER]  [CLASS]  ExtendedBufferedReader    [TYPE]  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  [TYPE]  String  line  [TYPE]  boolean  false  true    [CONTEXT]    public  String  readLine  (  )  throws  IOException  {  String  line  =  super  .  readLine  (  )  ;    if  (  line  !  =  null  )  {  if  (  line  .  length  (  )  >  0  )  {  lastChar  =  line  .  charAt  (  line  .  length  (  )  -  1  )  ;  }  lineCounter++  ;  }  else  {  [ATTENTION]  lastChar  =  null  ;  }  return  line  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java^131^^^^^122^135^
[REPLACE]    if    (    line    .    length    (    )    >    0    )    {  	[BUGGY]  if  (  line  .  length  (  )  *  0  .  5  >  0  )  {[FE]    AssertionFailedError    expected:<[   "x  ,  y   "]  ,  z>  but  was:<[x  ,  y]  ,  z>  assertEquals(   "   "  ,  format.format())      [METHOD]    readLine  [TYPE]  String  [PARAMETER]  [CLASS]  ExtendedBufferedReader    [TYPE]  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  [TYPE]  String  line  [TYPE]  boolean  false  true    [CONTEXT]    public  String  readLine  (  )  throws  IOException  {  String  line  =  super  .  readLine  (  )  ;    if  (  line  !  =  null  )  {  [ATTENTION]  if  (  line  .  length  (  )  *0  .  5>  0  )  {  lastChar  =  line  .  charAt  (  line  .  length  (  )  -  1  )  ;  }  lineCounter++  ;  }  else  {  lastChar  =  END_OF_STREAM  ;  }  return  line  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java^126^^^^^122^135^
[REPLACE]    lastChar    =    line    .    charAt    (    line    .    length    (    )    -    1    )    ;  	[BUGGY]  lastChar  =  line  .  charAt  (  line  .  length  (  )  +  4  -  1  )  ;  [FE]    AssertionFailedError    expected:<[   "x  ,  y   "]  ,  z>  but  was:<[x  ,  y]  ,  z>  assertEquals(   "   "  ,  format.format())      [METHOD]    readLine  [TYPE]  String  [PARAMETER]  [CLASS]  ExtendedBufferedReader    [TYPE]  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  [TYPE]  String  line  [TYPE]  boolean  false  true    [CONTEXT]    public  String  readLine  (  )  throws  IOException  {  String  line  =  super  .  readLine  (  )  ;    if  (  line  !  =  null  )  {  if  (  line  .  length  (  )  >  0  )  {  [ATTENTION]  lastChar  =  line  .  charAt  (  line  .  length  (  )  +  4  -  1  )    ;  }  lineCounter++  ;  }  else  {  lastChar  =  END_OF_STREAM  ;  }  return  line  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java^127^^^^^122^135^
[REPLACE]    lastChar    =    line    .    charAt    (    line    .    length    (    )    -    1    )    ;  	[BUGGY]  lastChar  =  line  .  charAt  (  line  .  length  (  )  *  0  .  5  -  0  )  ;  [CE]  method  charAt  in  class  String  cannot  be  applied  to  given  types  ;    [METHOD]    readLine  [TYPE]  String  [PARAMETER]  [CLASS]  ExtendedBufferedReader    [TYPE]  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  [TYPE]  String  line  [TYPE]  boolean  false  true    [CONTEXT]    public  String  readLine  (  )  throws  IOException  {  String  line  =  super  .  readLine  (  )  ;    if  (  line  !  =  null  )  {  if  (  line  .  length  (  )  >  0  )  {  [ATTENTION]  lastChar  =  line  .  charAt  (  line  .  length  (  )  *0  .  5-  0  )    ;  }  lineCounter++  ;  }  else  {  lastChar  =  END_OF_STREAM  ;  }  return  line  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java^127^^^^^122^135^
[REPLACE]    if    (    line    .    length    (    )    >    0    )    {  	[BUGGY]  if  (  line  .  length  (  )  -  1  >  0  )  {[FE]    AssertionFailedError    expected:<[   "x  ,  y   "]  ,  z>  but  was:<[x  ,  y]  ,  z>  assertEquals(   "   "  ,  format.format())      [METHOD]    readLine  [TYPE]  String  [PARAMETER]  [CLASS]  ExtendedBufferedReader    [TYPE]  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  [TYPE]  String  line  [TYPE]  boolean  false  true    [CONTEXT]    public  String  readLine  (  )  throws  IOException  {  String  line  =  super  .  readLine  (  )  ;    if  (  line  !  =  null  )  {  [ATTENTION]  if  (  line  .  length  (  )  -  1  >  0  )  {  lastChar  =  line  .  charAt  (  line  .  length  (  )  -  1  )  ;  }  lineCounter++  ;  }  else  {  lastChar  =  END_OF_STREAM  ;  }  return  line  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java^126^^^^^122^135^
[REPLACE]    lastChar    =    line    .    charAt    (    line    .    length    (    )    -    1    )    ;  	[BUGGY]  lastChar  =  line  .  charAt  (  line  .  length  (  )  %  2  -  1  )  ;  [FE]    AssertionFailedError    expected:<[   "x  ,  y   "]  ,  z>  but  was:<[x  ,  y]  ,  z>  assertEquals(   "   "  ,  format.format())      [METHOD]    readLine  [TYPE]  String  [PARAMETER]  [CLASS]  ExtendedBufferedReader    [TYPE]  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  [TYPE]  String  line  [TYPE]  boolean  false  true    [CONTEXT]    public  String  readLine  (  )  throws  IOException  {  String  line  =  super  .  readLine  (  )  ;    if  (  line  !  =  null  )  {  if  (  line  .  length  (  )  >  0  )  {  [ATTENTION]  lastChar  =  line  .  charAt  (  line  .  length  (  )  %2  -  1  )    ;  }  lineCounter++  ;  }  else  {  lastChar  =  END_OF_STREAM  ;  }  return  line  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java^127^^^^^122^135^
[REPLACE]    lastChar    =    line    .    charAt    (    line    .    length    (    )    -    1    )    ;  	[BUGGY]  lastChar  =  line  .  charAt  (  line  .  length  (  )  -  4  -  1  )  ;  [FE]    AssertionFailedError    expected:<[   "x  ,  y   "]  ,  z>  but  was:<[x  ,  y]  ,  z>  assertEquals(   "   "  ,  format.format())      [METHOD]    readLine  [TYPE]  String  [PARAMETER]  [CLASS]  ExtendedBufferedReader    [TYPE]  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  [TYPE]  String  line  [TYPE]  boolean  false  true    [CONTEXT]    public  String  readLine  (  )  throws  IOException  {  String  line  =  super  .  readLine  (  )  ;    if  (  line  !  =  null  )  {  if  (  line  .  length  (  )  >  0  )  {  [ATTENTION]  lastChar  =  line  .  charAt  (  line  .  length  (  )  -  4  -  1  )    ;  }  lineCounter++  ;  }  else  {  lastChar  =  END_OF_STREAM  ;  }  return  line  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java^127^^^^^122^135^
[REPLACE]    lastChar    =    END_OF_STREAM;  	[BUGGY]  lastChar    =    lastChar  ;  [FE]    AssertionFailedError    expected:<[   "x  ,  y   "]  ,  z>  but  was:<[x  ,  y]  ,  z>  assertEquals(   "   "  ,  format.format())      [METHOD]    readLine  [TYPE]  String  [PARAMETER]  [CLASS]  ExtendedBufferedReader    [TYPE]  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  [TYPE]  String  line  [TYPE]  boolean  false  true    [CONTEXT]    public  String  readLine  (  )  throws  IOException  {  String  line  =  super  .  readLine  (  )  ;    if  (  line  !  =  null  )  {  if  (  line  .  length  (  )  >  0  )  {  lastChar  =  line  .  charAt  (  line  .  length  (  )  -  1  )  ;  }  lineCounter++  ;  }  else  {  [ATTENTION]  lastChar  =  lastChar  ;  }  return  line  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java^131^^^^^122^135^
[REPLACE]    return    line;  	[BUGGY]  return  len  ;  [CE]  cannot  find  symbol  len    [METHOD]    readLine  [TYPE]  String  [PARAMETER]  [CLASS]  ExtendedBufferedReader    [TYPE]  int  END_OF_STREAM  UNDEFINED  current  i  lastChar  len  length  lineCounter  offset  [TYPE]  String  line  [TYPE]  boolean  false  true    [CONTEXT]    public  String  readLine  (  )  throws  IOException  {  String  line  =  super  .  readLine  (  )  ;    if  (  line  !  =  null  )  {  if  (  line  .  length  (  )  >  0  )  {  lastChar  =  line  .  charAt  (  line  .  length  (  )  -  1  )  ;  }  lineCounter++  ;  }  else  {  lastChar  =  END_OF_STREAM  ;  }  [ATTENTION]  return  len  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java^134^^^^^122^135^
[REPLACE]    super    .    mark    (    1    )    ;  	[BUGGY]  super  .  readLine  (  )    ;  [FE]    AssertionFailedError    expected:<[   "x  ,  y   "]  ,  z>  but  was:<[x  ,  y]  ,  z>  assertEquals(   "   "  ,  format.format())      [METHOD]    lookAhead  [TYPE]  int  [PARAMETER]  [CLASS]  ExtendedBufferedReader    [TYPE]  int  END_OF_STREAM  UNDEFINED  c  current  i  lastChar  len  length  lineCounter  offset  [TYPE]  boolean  false  true    [CONTEXT]    int  lookAhead  (  )  throws  IOException  {  [ATTENTION]  super  .  readLine  (  )  ;  int  c  =  super  .  read  (  )  ;  super  .  reset  (  )  ;    return  c  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java^146^^^^^145^151^
[REPLACE]    int    c    =    super    .    read    (    )    ;  	[BUGGY]  int  c  =  super  .  read  (  )    ;  [FE]    AssertionFailedError    expected:<[   "x  ,  y   "]  ,  z>  but  was:<[x  ,  y]  ,  z>  assertEquals(   "   "  ,  format.format())      [METHOD]    lookAhead  [TYPE]  int  [PARAMETER]  [CLASS]  ExtendedBufferedReader    [TYPE]  int  END_OF_STREAM  UNDEFINED  c  current  i  lastChar  len  length  lineCounter  offset  [TYPE]  boolean  false  true    [CONTEXT]    int  lookAhead  (  )  throws  IOException  {  super  .  mark  (  1  )  ;  [ATTENTION]  int  c  =  super  .  read  (  )  ;  super  .  reset  (  )  ;    return  c  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java^147^^^^^145^151^
[REPLACE]    super    .    reset    (    )    ;  	[BUGGY]  super  .  read  (  )    ;  [FE]    AssertionFailedError    expected:<[   "x  ,  y   "]  ,  z>  but  was:<[x  ,  y]  ,  z>  assertEquals(   "   "  ,  format.format())      [METHOD]    lookAhead  [TYPE]  int  [PARAMETER]  [CLASS]  ExtendedBufferedReader    [TYPE]  int  END_OF_STREAM  UNDEFINED  c  current  i  lastChar  len  length  lineCounter  offset  [TYPE]  boolean  false  true    [CONTEXT]    int  lookAhead  (  )  throws  IOException  {  super  .  mark  (  1  )  ;  int  c  =  super  .  read  (  )  ;  [ATTENTION]  super  .  read  (  )  ;    return  c  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java^148^^^^^145^151^
[ADD]    super    .    reset    (    )    ;  	[BUGGY]  [FE]    AssertionFailedError    expected:<[   "x  ,  y   "]  ,  z>  but  was:<[x  ,  y]  ,  z>  assertEquals(   "   "  ,  format.format())      [METHOD]    lookAhead  [TYPE]  int  [PARAMETER]  [CLASS]  ExtendedBufferedReader    [TYPE]  int  END_OF_STREAM  UNDEFINED  c  current  i  lastChar  len  length  lineCounter  offset  [TYPE]  boolean  false  true    [CONTEXT]    int  lookAhead  (  )  throws  IOException  {  super  .  mark  (  1  )  ;  int  c  =  super  .  read  (  )  ;  [ATTENTION]    return  c  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java^148^^^^^145^151^
[REPLACE]    return    c;  	[BUGGY]  return  lineCounter  ;  [FE]    AssertionFailedError    expected:<[   "x  ,  y   "]  ,  z>  but  was:<[x  ,  y]  ,  z>  assertEquals(   "   "  ,  format.format())      [METHOD]    lookAhead  [TYPE]  int  [PARAMETER]  [CLASS]  ExtendedBufferedReader    [TYPE]  int  END_OF_STREAM  UNDEFINED  c  current  i  lastChar  len  length  lineCounter  offset  [TYPE]  boolean  false  true    [CONTEXT]    int  lookAhead  (  )  throws  IOException  {  super  .  mark  (  1  )  ;  int  c  =  super  .  read  (  )  ;  super  .  reset  (  )  ;    [ATTENTION]  return  lineCounter  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java^150^^^^^145^151^
[REPLACE]    return    lineCounter;  	[BUGGY]  return  line  ;  [CE]  cannot  find  symbol  line    [METHOD]    getLineNumber  [TYPE]  int  [PARAMETER]  [CLASS]  ExtendedBufferedReader    [TYPE]  int  END_OF_STREAM  UNDEFINED  c  current  i  lastChar  len  length  lineCounter  offset  [TYPE]  boolean  false  true    [CONTEXT]    int  getLineNumber  (  )  {  [ATTENTION]  return  line  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java^159^^^^^158^160^
[REPLACE]    private    static    final    String    CRLF    =       "\r\n   ";  	[BUGGY]  private  static  final  String  CRLF  ;  [CE]  variable  CRLF  might  not  have  been  initialized    [CONTEXT]        [CLASS]  CSVFormat    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVFormat.java^33^^^^^^^
[REPLACE]    private    final    char    commentStart;  	[BUGGY]  private  char  commentStart  ;  [FE]    AssertionFailedError    expected:<[   "x  ,  y   "]  ,  z>  but  was:<[x  ,  y]  ,  z>  assertEquals(   "   "  ,  format.format())      [CONTEXT]        [CLASS]  CSVFormat    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVFormat.java^37^^^^^^^
[REPLACE]    private    final    char    escape;  	[BUGGY]  private  char  escape  ;  [FE]    AssertionFailedError    expected:<[   "x  ,  y   "]  ,  z>  but  was:<[x  ,  y]  ,  z>  assertEquals(   "   "  ,  format.format())      [CONTEXT]        [CLASS]  CSVFormat    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVFormat.java^38^^^^^^^
[REPLACE]    private    final    boolean    surroundingSpacesIgnored;  	[BUGGY]  private  boolean  surroundingSpacesIgnored  ;  [FE]    AssertionFailedError    expected:<[   "x  ,  y   "]  ,  z>  but  was:<[x  ,  y]  ,  z>  assertEquals(   "   "  ,  format.format())      [CONTEXT]        [CLASS]  CSVFormat    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVFormat.java^39^^^^^^^
[REPLACE]    static    final    char    DISABLED    =    '\ufffe';  	[BUGGY]  final  char  DISABLED  =  '\ufffe'  ;  [CE]  non-static  variable  DISABLED  cannot  be  referenced  from  a  static  context    [CONTEXT]        [CLASS]  CSVFormat    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVFormat.java^51^^^^^^^
[REPLACE]    private    static    CSVFormat    PRISTINE    =    new    CSVFormat    (    DISABLED,    DISABLED,    DISABLED,    DISABLED,    false,    false,    null,    null    )    ;  	[BUGGY]  private  static  CSVFormat  PRISTINE    =  null  ;  [FE]    null  assertNotNull(format)      [CONTEXT]        [CLASS]  CSVFormat    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVFormat.java^56^^^^^^^
[REPLACE]    public    static    final    CSVFormat    DEFAULT    =    PRISTINE    .        withDelimiter    (    ','    )        .    withEncapsulator    (    '   "'    )  	[BUGGY]  public  static  CSVFormat  DEFAULT  =  PRISTINE  .  withDelimiter  (  '  ,  '  )  .  withEncapsulator  (  '   "'  )[NO-ERROR]    [CONTEXT]    [ATTENTION]  public  staticCSVFormat  DEFAULT  =  PRISTINE  .  withDelimiter  (  '  ,  '  )    .  withEncapsulator  (  '   "'  )      .  withEmptyLinesIgnored  (  true  )    .  withLineSeparator  (  CRLF  )  ;      [CLASS]  CSVFormat    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVFormat.java^67^68^69^70^^67^72^
[REPLACE]    public    static    final    CSVFormat    RFC4180    =    PRISTINE    .        withDelimiter    (    ','    )        .    withEncapsulator    (    '   "'    )  	[BUGGY]  public  static  final  CSVFormat  RFC4180  ;  [CE]  illegal  start  of  type    [CONTEXT]    [ATTENTION]  public  static  final  CSVFormat  RFC4180  ;      .  withLineSeparator  (  CRLF  )  ;      [CLASS]  CSVFormat    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVFormat.java^83^84^85^86^^83^87^
[REPLACE]    public    static    final    CSVFormat    EXCEL    =    PRISTINE        .    withDelimiter    (    ','    )        .    withEncapsulator    (    '   "'    )  	[BUGGY]  public  static  final  CSVFormat  EXCEL  ;  [CE]  illegal  start  of  type    [CONTEXT]    [ATTENTION]  public  static  final  CSVFormat  EXCEL  ;      .  withLineSeparator  (  CRLF  )  ;      [CLASS]  CSVFormat    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVFormat.java^100^101^102^103^^100^104^
[REPLACE]    public    static    final    CSVFormat    TDF    =    PRISTINE        .    withDelimiter    (    '\t'    )        .    withEncapsulator    (    '   "'    )  	[BUGGY]  public  static  final  CSVFormat  TDF  ;  [CE]  illegal  start  of  type    [CONTEXT]    [ATTENTION]  public  static  final  CSVFormat  TDF  ;      .  withSurroundingSpacesIgnored  (  true  )    .  withEmptyLinesIgnored  (  true  )    .  withLineSeparator  (  CRLF  )  ;      [CLASS]  CSVFormat    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVFormat.java^107^108^109^110^^107^113^
[REPLACE]    public    static    final    CSVFormat    MYSQL    =    PRISTINE        .    withDelimiter    (    '\t'    )        .    withEscape    (    '\\'    )  	[BUGGY]  public  static  final  CSVFormat  MYSQL  ;  [CE]  illegal  start  of  type    [CONTEXT]    [ATTENTION]  public  static  final  CSVFormat  MYSQL  ;      .  withLineSeparator  (     "\n   "  )  ;      [CLASS]  CSVFormat    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVFormat.java^123^124^125^126^^123^127^
[REPLACE]    this    .    delimiter    =    delimiter;  	[BUGGY]  this  .  delimiter  =    escape  ;  [FE]  [METHOD]    <init>  [TYPE]  String[])  [PARAMETER]  char  delimiter  char  encapsulator  char  commentStart  char  escape  boolean  surroundingSpacesIgnored  boolean  emptyLinesIgnored  String  lineSeparator  String[]  header  [CLASS]  CSVFormat    [TYPE]  char  DISABLED  commentStart  delimiter  encapsulator  escape  [TYPE]  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  [TYPE]  boolean  emptyLinesIgnored  false  surroundingSpacesIgnored  true  [TYPE]  String  CRLF  lineSeparator  [TYPE]  String[]  header    [CONTEXT]    CSVFormat  (  char  delimiter  ,  char  encapsulator  ,  char  commentStart  ,  char  escape  ,  boolean  surroundingSpacesIgnored  ,  boolean  emptyLinesIgnored  ,  String  lineSeparator  ,  String[]  header  )  {  [ATTENTION]  this  .  delimiter  =  escape  ;  this  .  encapsulator  =  encapsulator  ;  this  .  commentStart  =  commentStart  ;  this  .  escape  =  escape  ;  this  .  surroundingSpacesIgnored  =  surroundingSpacesIgnored  ;  this  .  emptyLinesIgnored  =  emptyLinesIgnored  ;  this  .  lineSeparator  =  lineSeparator  ;  this  .  header  =  header  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVFormat.java^151^^^^^142^159^
[REPLACE]    this    .    encapsulator    =    encapsulator;  	[BUGGY]  this  .  encapsulator  =    escape  ;  [FE]  [METHOD]    <init>  [TYPE]  String[])  [PARAMETER]  char  delimiter  char  encapsulator  char  commentStart  char  escape  boolean  surroundingSpacesIgnored  boolean  emptyLinesIgnored  String  lineSeparator  String[]  header  [CLASS]  CSVFormat    [TYPE]  char  DISABLED  commentStart  delimiter  encapsulator  escape  [TYPE]  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  [TYPE]  boolean  emptyLinesIgnored  false  surroundingSpacesIgnored  true  [TYPE]  String  CRLF  lineSeparator  [TYPE]  String[]  header    [CONTEXT]    CSVFormat  (  char  delimiter  ,  char  encapsulator  ,  char  commentStart  ,  char  escape  ,  boolean  surroundingSpacesIgnored  ,  boolean  emptyLinesIgnored  ,  String  lineSeparator  ,  String[]  header  )  {  this  .  delimiter  =  delimiter  ;  [ATTENTION]  this  .  encapsulator  =  escape  ;  this  .  commentStart  =  commentStart  ;  this  .  escape  =  escape  ;  this  .  surroundingSpacesIgnored  =  surroundingSpacesIgnored  ;  this  .  emptyLinesIgnored  =  emptyLinesIgnored  ;  this  .  lineSeparator  =  lineSeparator  ;  this  .  header  =  header  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVFormat.java^152^^^^^142^159^
[REPLACE]    this    .    commentStart    =    commentStart;  	[BUGGY]  this  .  commentStart  =    null  ;  [CE]  incompatible  types    [METHOD]    <init>  [TYPE]  String[])  [PARAMETER]  char  delimiter  char  encapsulator  char  commentStart  char  escape  boolean  surroundingSpacesIgnored  boolean  emptyLinesIgnored  String  lineSeparator  String[]  header  [CLASS]  CSVFormat    [TYPE]  char  DISABLED  commentStart  delimiter  encapsulator  escape  [TYPE]  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  [TYPE]  boolean  emptyLinesIgnored  false  surroundingSpacesIgnored  true  [TYPE]  String  CRLF  lineSeparator  [TYPE]  String[]  header    [CONTEXT]    CSVFormat  (  char  delimiter  ,  char  encapsulator  ,  char  commentStart  ,  char  escape  ,  boolean  surroundingSpacesIgnored  ,  boolean  emptyLinesIgnored  ,  String  lineSeparator  ,  String[]  header  )  {  this  .  delimiter  =  delimiter  ;  this  .  encapsulator  =  encapsulator  ;  [ATTENTION]  this  .  commentStart  =  null  ;  this  .  escape  =  escape  ;  this  .  surroundingSpacesIgnored  =  surroundingSpacesIgnored  ;  this  .  emptyLinesIgnored  =  emptyLinesIgnored  ;  this  .  lineSeparator  =  lineSeparator  ;  this  .  header  =  header  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVFormat.java^153^^^^^142^159^
[REPLACE]    this    .    escape    =    escape;  	[BUGGY]  this  .  escape  =    encapsulator  ;  [FE]  [METHOD]    <init>  [TYPE]  String[])  [PARAMETER]  char  delimiter  char  encapsulator  char  commentStart  char  escape  boolean  surroundingSpacesIgnored  boolean  emptyLinesIgnored  String  lineSeparator  String[]  header  [CLASS]  CSVFormat    [TYPE]  char  DISABLED  commentStart  delimiter  encapsulator  escape  [TYPE]  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  [TYPE]  boolean  emptyLinesIgnored  false  surroundingSpacesIgnored  true  [TYPE]  String  CRLF  lineSeparator  [TYPE]  String[]  header    [CONTEXT]    CSVFormat  (  char  delimiter  ,  char  encapsulator  ,  char  commentStart  ,  char  escape  ,  boolean  surroundingSpacesIgnored  ,  boolean  emptyLinesIgnored  ,  String  lineSeparator  ,  String[]  header  )  {  this  .  delimiter  =  delimiter  ;  this  .  encapsulator  =  encapsulator  ;  this  .  commentStart  =  commentStart  ;  [ATTENTION]  this  .  escape  =  encapsulator  ;  this  .  surroundingSpacesIgnored  =  surroundingSpacesIgnored  ;  this  .  emptyLinesIgnored  =  emptyLinesIgnored  ;  this  .  lineSeparator  =  lineSeparator  ;  this  .  header  =  header  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVFormat.java^154^^^^^142^159^
[ADD]    this    .    escape    =    escape;    this    .    surroundingSpacesIgnored    =    surroundingSpacesIgnored;  	[BUGGY]  this  .  surroundingSpacesIgnored  =  surroundingSpacesIgnored  ;  [CE]  variable  escape  might  not  have  been  initialized    [METHOD]    <init>  [TYPE]  String[])  [PARAMETER]  char  delimiter  char  encapsulator  char  commentStart  char  escape  boolean  surroundingSpacesIgnored  boolean  emptyLinesIgnored  String  lineSeparator  String[]  header  [CLASS]  CSVFormat    [TYPE]  char  DISABLED  commentStart  delimiter  encapsulator  escape  [TYPE]  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  [TYPE]  boolean  emptyLinesIgnored  false  surroundingSpacesIgnored  true  [TYPE]  String  CRLF  lineSeparator  [TYPE]  String[]  header    [CONTEXT]    CSVFormat  (  char  delimiter  ,  char  encapsulator  ,  char  commentStart  ,  char  escape  ,  boolean  surroundingSpacesIgnored  ,  boolean  emptyLinesIgnored  ,  String  lineSeparator  ,  String[]  header  )  {  this  .  delimiter  =  delimiter  ;  this  .  encapsulator  =  encapsulator  ;  this  .  commentStart  =  commentStart  ;  [ATTENTION]  this  .  surroundingSpacesIgnored  =  surroundingSpacesIgnored  ;    this  .  emptyLinesIgnored  =  emptyLinesIgnored  ;  this  .  lineSeparator  =  lineSeparator  ;  this  .  header  =  header  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVFormat.java^154^155^^^^142^159^
[REPLACE]    this    .    surroundingSpacesIgnored    =    surroundingSpacesIgnored;  	[BUGGY]  this  .  surroundingSpacesIgnored  =    true  ;  [FE]    null  assertEquals('?'  ,  format.withDelimiter('?').getDelimiter())      [METHOD]    <init>  [TYPE]  String[])  [PARAMETER]  char  delimiter  char  encapsulator  char  commentStart  char  escape  boolean  surroundingSpacesIgnored  boolean  emptyLinesIgnored  String  lineSeparator  String[]  header  [CLASS]  CSVFormat    [TYPE]  char  DISABLED  commentStart  delimiter  encapsulator  escape  [TYPE]  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  [TYPE]  boolean  emptyLinesIgnored  false  surroundingSpacesIgnored  true  [TYPE]  String  CRLF  lineSeparator  [TYPE]  String[]  header    [CONTEXT]    CSVFormat  (  char  delimiter  ,  char  encapsulator  ,  char  commentStart  ,  char  escape  ,  boolean  surroundingSpacesIgnored  ,  boolean  emptyLinesIgnored  ,  String  lineSeparator  ,  String[]  header  )  {  this  .  delimiter  =  delimiter  ;  this  .  encapsulator  =  encapsulator  ;  this  .  commentStart  =  commentStart  ;  this  .  escape  =  escape  ;  [ATTENTION]  this  .  surroundingSpacesIgnored  =  true  ;  this  .  emptyLinesIgnored  =  emptyLinesIgnored  ;  this  .  lineSeparator  =  lineSeparator  ;  this  .  header  =  header  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVFormat.java^155^^^^^142^159^
[REPLACE]    this    .    emptyLinesIgnored    =    emptyLinesIgnored;  	[BUGGY]  this  .  emptyLinesIgnored  =    true  ;  [FE]    null  assertEquals('?'  ,  format.withDelimiter('?').getDelimiter())      [METHOD]    <init>  [TYPE]  String[])  [PARAMETER]  char  delimiter  char  encapsulator  char  commentStart  char  escape  boolean  surroundingSpacesIgnored  boolean  emptyLinesIgnored  String  lineSeparator  String[]  header  [CLASS]  CSVFormat    [TYPE]  char  DISABLED  commentStart  delimiter  encapsulator  escape  [TYPE]  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  [TYPE]  boolean  emptyLinesIgnored  false  surroundingSpacesIgnored  true  [TYPE]  String  CRLF  lineSeparator  [TYPE]  String[]  header    [CONTEXT]    CSVFormat  (  char  delimiter  ,  char  encapsulator  ,  char  commentStart  ,  char  escape  ,  boolean  surroundingSpacesIgnored  ,  boolean  emptyLinesIgnored  ,  String  lineSeparator  ,  String[]  header  )  {  this  .  delimiter  =  delimiter  ;  this  .  encapsulator  =  encapsulator  ;  this  .  commentStart  =  commentStart  ;  this  .  escape  =  escape  ;  this  .  surroundingSpacesIgnored  =  surroundingSpacesIgnored  ;  [ATTENTION]  this  .  emptyLinesIgnored  =  true  ;  this  .  lineSeparator  =  lineSeparator  ;  this  .  header  =  header  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVFormat.java^156^^^^^142^159^
[REPLACE]    this    .    lineSeparator    =    lineSeparator;  	[BUGGY]  this  .  lineSeparator  =    CRLF  ;  [FE]    AssertionFailedError    expected:<[?]>  but  was:<[  assertEquals('?'  ,  format.withDelimiter('?').getDelimiter())      [METHOD]    <init>  [TYPE]  String[])  [PARAMETER]  char  delimiter  char  encapsulator  char  commentStart  char  escape  boolean  surroundingSpacesIgnored  boolean  emptyLinesIgnored  String  lineSeparator  String[]  header  [CLASS]  CSVFormat    [TYPE]  char  DISABLED  commentStart  delimiter  encapsulator  escape  [TYPE]  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  [TYPE]  boolean  emptyLinesIgnored  false  surroundingSpacesIgnored  true  [TYPE]  String  CRLF  lineSeparator  [TYPE]  String[]  header    [CONTEXT]    CSVFormat  (  char  delimiter  ,  char  encapsulator  ,  char  commentStart  ,  char  escape  ,  boolean  surroundingSpacesIgnored  ,  boolean  emptyLinesIgnored  ,  String  lineSeparator  ,  String[]  header  )  {  this  .  delimiter  =  delimiter  ;  this  .  encapsulator  =  encapsulator  ;  this  .  commentStart  =  commentStart  ;  this  .  escape  =  escape  ;  this  .  surroundingSpacesIgnored  =  surroundingSpacesIgnored  ;  this  .  emptyLinesIgnored  =  emptyLinesIgnored  ;  [ATTENTION]  this  .  lineSeparator  =  CRLF  ;  this  .  header  =  header  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVFormat.java^157^^^^^142^159^
[REPLACE]    this    .    header    =    header;  	[BUGGY]  this  .  header  =    null  ;  [FE]    No  header  was  specified  ,  the  record  values  can't  be  accessed  by  name  assertTrue(records.hasNext())      [METHOD]    <init>  [TYPE]  String[])  [PARAMETER]  char  delimiter  char  encapsulator  char  commentStart  char  escape  boolean  surroundingSpacesIgnored  boolean  emptyLinesIgnored  String  lineSeparator  String[]  header  [CLASS]  CSVFormat    [TYPE]  char  DISABLED  commentStart  delimiter  encapsulator  escape  [TYPE]  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  [TYPE]  boolean  emptyLinesIgnored  false  surroundingSpacesIgnored  true  [TYPE]  String  CRLF  lineSeparator  [TYPE]  String[]  header    [CONTEXT]    CSVFormat  (  char  delimiter  ,  char  encapsulator  ,  char  commentStart  ,  char  escape  ,  boolean  surroundingSpacesIgnored  ,  boolean  emptyLinesIgnored  ,  String  lineSeparator  ,  String[]  header  )  {  this  .  delimiter  =  delimiter  ;  this  .  encapsulator  =  encapsulator  ;  this  .  commentStart  =  commentStart  ;  this  .  escape  =  escape  ;  this  .  surroundingSpacesIgnored  =  surroundingSpacesIgnored  ;  this  .  emptyLinesIgnored  =  emptyLinesIgnored  ;  this  .  lineSeparator  =  lineSeparator  ;  [ATTENTION]  this  .  header  =  null  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVFormat.java^158^^^^^142^159^
[REPLACE]    return    c    ==    '\n'    ||    c    ==    '\r';  	[BUGGY]  return  c  ;  [CE]  incompatible  types    [METHOD]    isLineBreak  [TYPE]  boolean  [PARAMETER]  char  c  [CLASS]  CSVFormat    [TYPE]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  [TYPE]  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  [TYPE]  boolean  emptyLinesIgnored  false  surroundingSpacesIgnored  true  [TYPE]  String  CRLF  lineSeparator  [TYPE]  String[]  header    [CONTEXT]    private  static  boolean  isLineBreak  (  char  c  )  {  [ATTENTION]  return  c  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVFormat.java^169^^^^^168^170^
[REPLACE]    if    (    delimiter    ==    encapsulator    )    {  	[BUGGY]  if  (  delimiter  &&  encapsulator  )  {[CE]  bad  operand  types  for  binary  operator  '&&'    [METHOD]    validate  [TYPE]  void  [PARAMETER]  [CLASS]  CSVFormat    [TYPE]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  [TYPE]  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  [TYPE]  boolean  emptyLinesIgnored  false  surroundingSpacesIgnored  true  [TYPE]  String  CRLF  lineSeparator  [TYPE]  String[]  header    [CONTEXT]    void  validate  (  )  throws  IllegalArgumentException  {  [ATTENTION]  if  (  delimiter&&encapsulator  )  {  throw  new  IllegalArgumentException  (     "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (  \   "   "  +  encapsulator  +     "\   "  )     "  )  ;  }  if  (  delimiter  =  =  escape  )  {  throw  new  IllegalArgumentException  (     "The  escape  character  and  the  delimiter  cannot  be  the  same  (  \   "   "  +  escape  +     "\   "  )     "  )  ;  }  if  (  delimiter  =  =  commentStart  )  {  throw  new  IllegalArgumentException  (     "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (  \   "   "  +  commentStart  +     "\   "  )     "  )  ;  }  if  (  encapsulator  !  =  DISABLED  &&  encapsulator  =  =  commentStart  )  {  throw  new  IllegalArgumentException  (     "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (  \   "   "  +  commentStart  +     "\   "  )     "  )  ;  }  if  (  escape  !  =  DISABLED  &&  escape  =  =  commentStart  )  {  throw  new  IllegalArgumentException  (     "The  comment  start  and  the  escape  character  cannot  be  the  same  (  \   "   "  +  commentStart  +     "\   "  )     "  )  ;  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVFormat.java^176^^^^^175^195^
[REPLACE]    throw    new    IllegalArgumentException    (   "       ")    ;  	[BUGGY]  return  ;  [FE]  [METHOD]    validate  [TYPE]  void  [PARAMETER]  [CLASS]  CSVFormat    [TYPE]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  [TYPE]  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  [TYPE]  boolean  emptyLinesIgnored  false  surroundingSpacesIgnored  true  [TYPE]  String  CRLF  lineSeparator  [TYPE]  String[]  header    [CONTEXT]    void  validate  (  )  throws  IllegalArgumentException  {  if  (  delimiter  =  =  encapsulator  )  {  [ATTENTION]  return  ;  }  if  (  delimiter  =  =  escape  )  {  throw  new  IllegalArgumentException  (     "The  escape  character  and  the  delimiter  cannot  be  the  same  (  \   "   "  +  escape  +     "\   "  )     "  )  ;  }  if  (  delimiter  =  =  commentStart  )  {  throw  new  IllegalArgumentException  (     "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (  \   "   "  +  commentStart  +     "\   "  )     "  )  ;  }  if  (  encapsulator  !  =  DISABLED  &&  encapsulator  =  =  commentStart  )  {  throw  new  IllegalArgumentException  (     "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (  \   "   "  +  commentStart  +     "\   "  )     "  )  ;  }  if  (  escape  !  =  DISABLED  &&  escape  =  =  commentStart  )  {  throw  new  IllegalArgumentException  (     "The  comment  start  and  the  escape  character  cannot  be  the  same  (  \   "   "  +  commentStart  +     "\   "  )     "  )  ;  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVFormat.java^177^^^^^175^195^
[ADD]    throw    new    IllegalArgumentException    (   "       ")    ;  	[BUGGY]  [FE]  [METHOD]    validate  [TYPE]  void  [PARAMETER]  [CLASS]  CSVFormat    [TYPE]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  [TYPE]  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  [TYPE]  boolean  emptyLinesIgnored  false  surroundingSpacesIgnored  true  [TYPE]  String  CRLF  lineSeparator  [TYPE]  String[]  header    [CONTEXT]    void  validate  (  )  throws  IllegalArgumentException  {  if  (  delimiter  =  =  encapsulator  )  {  [ATTENTION]  }  if  (  delimiter  =  =  escape  )  {  throw  new  IllegalArgumentException  (     "The  escape  character  and  the  delimiter  cannot  be  the  same  (  \   "   "  +  escape  +     "\   "  )     "  )  ;  }  if  (  delimiter  =  =  commentStart  )  {  throw  new  IllegalArgumentException  (     "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (  \   "   "  +  commentStart  +     "\   "  )     "  )  ;  }  if  (  encapsulator  !  =  DISABLED  &&  encapsulator  =  =  commentStart  )  {  throw  new  IllegalArgumentException  (     "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (  \   "   "  +  commentStart  +     "\   "  )     "  )  ;  }  if  (  escape  !  =  DISABLED  &&  escape  =  =  commentStart  )  {  throw  new  IllegalArgumentException  (     "The  comment  start  and  the  escape  character  cannot  be  the  same  (  \   "   "  +  commentStart  +     "\   "  )     "  )  ;  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVFormat.java^177^^^^^175^195^
[REPLACE]    if    (    delimiter    ==    escape    )    {  	[BUGGY]  if  (encapsulator  !  =    escape  )  {[FE]  [METHOD]    validate  [TYPE]  void  [PARAMETER]  [CLASS]  CSVFormat    [TYPE]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  [TYPE]  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  [TYPE]  boolean  emptyLinesIgnored  false  surroundingSpacesIgnored  true  [TYPE]  String  CRLF  lineSeparator  [TYPE]  String[]  header    [CONTEXT]    void  validate  (  )  throws  IllegalArgumentException  {  if  (  delimiter  =  =  encapsulator  )  {  throw  new  IllegalArgumentException  (     "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (  \   "   "  +  encapsulator  +     "\   "  )     "  )  ;  }  [ATTENTION]  if  (  encapsulator!  =  escape  )  {  throw  new  IllegalArgumentException  (     "The  escape  character  and  the  delimiter  cannot  be  the  same  (  \   "   "  +  escape  +     "\   "  )     "  )  ;  }  if  (  delimiter  =  =  commentStart  )  {  throw  new  IllegalArgumentException  (     "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (  \   "   "  +  commentStart  +     "\   "  )     "  )  ;  }  if  (  encapsulator  !  =  DISABLED  &&  encapsulator  =  =  commentStart  )  {  throw  new  IllegalArgumentException  (     "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (  \   "   "  +  commentStart  +     "\   "  )     "  )  ;  }  if  (  escape  !  =  DISABLED  &&  escape  =  =  commentStart  )  {  throw  new  IllegalArgumentException  (     "The  comment  start  and  the  escape  character  cannot  be  the  same  (  \   "   "  +  commentStart  +     "\   "  )     "  )  ;  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVFormat.java^180^^^^^175^195^
[REPLACE]    throw    new    IllegalArgumentException    (   "       ")    ;  	[BUGGY]  return  ;  [FE]  [METHOD]    validate  [TYPE]  void  [PARAMETER]  [CLASS]  CSVFormat    [TYPE]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  [TYPE]  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  [TYPE]  boolean  emptyLinesIgnored  false  surroundingSpacesIgnored  true  [TYPE]  String  CRLF  lineSeparator  [TYPE]  String[]  header    [CONTEXT]    void  validate  (  )  throws  IllegalArgumentException  {  if  (  delimiter  =  =  encapsulator  )  {  throw  new  IllegalArgumentException  (     "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (  \   "   "  +  encapsulator  +     "\   "  )     "  )  ;  }  if  (  delimiter  =  =  escape  )  {  [ATTENTION]  return  ;  }  if  (  delimiter  =  =  commentStart  )  {  throw  new  IllegalArgumentException  (     "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (  \   "   "  +  commentStart  +     "\   "  )     "  )  ;  }  if  (  encapsulator  !  =  DISABLED  &&  encapsulator  =  =  commentStart  )  {  throw  new  IllegalArgumentException  (     "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (  \   "   "  +  commentStart  +     "\   "  )     "  )  ;  }  if  (  escape  !  =  DISABLED  &&  escape  =  =  commentStart  )  {  throw  new  IllegalArgumentException  (     "The  comment  start  and  the  escape  character  cannot  be  the  same  (  \   "   "  +  commentStart  +     "\   "  )     "  )  ;  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVFormat.java^181^^^^^175^195^
[REPLACE]    if    (    delimiter    ==    commentStart    )    {  	[BUGGY]  if  (  delimiter  ||  commentStart  )  {[CE]  bad  operand  types  for  binary  operator  '||'    [METHOD]    validate  [TYPE]  void  [PARAMETER]  [CLASS]  CSVFormat    [TYPE]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  [TYPE]  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  [TYPE]  boolean  emptyLinesIgnored  false  surroundingSpacesIgnored  true  [TYPE]  String  CRLF  lineSeparator  [TYPE]  String[]  header    [CONTEXT]    void  validate  (  )  throws  IllegalArgumentException  {  if  (  delimiter  =  =  encapsulator  )  {  throw  new  IllegalArgumentException  (     "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (  \   "   "  +  encapsulator  +     "\   "  )     "  )  ;  }  if  (  delimiter  =  =  escape  )  {  throw  new  IllegalArgumentException  (     "The  escape  character  and  the  delimiter  cannot  be  the  same  (  \   "   "  +  escape  +     "\   "  )     "  )  ;  }  [ATTENTION]  if  (  delimiter||commentStart  )  {  throw  new  IllegalArgumentException  (     "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (  \   "   "  +  commentStart  +     "\   "  )     "  )  ;  }  if  (  encapsulator  !  =  DISABLED  &&  encapsulator  =  =  commentStart  )  {  throw  new  IllegalArgumentException  (     "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (  \   "   "  +  commentStart  +     "\   "  )     "  )  ;  }  if  (  escape  !  =  DISABLED  &&  escape  =  =  commentStart  )  {  throw  new  IllegalArgumentException  (     "The  comment  start  and  the  escape  character  cannot  be  the  same  (  \   "   "  +  commentStart  +     "\   "  )     "  )  ;  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVFormat.java^184^^^^^175^195^
[REPLACE]    throw    new    IllegalArgumentException    (   "       ")    ;  	[BUGGY]  return  ;  [FE]  [METHOD]    validate  [TYPE]  void  [PARAMETER]  [CLASS]  CSVFormat    [TYPE]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  [TYPE]  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  [TYPE]  boolean  emptyLinesIgnored  false  surroundingSpacesIgnored  true  [TYPE]  String  CRLF  lineSeparator  [TYPE]  String[]  header    [CONTEXT]    void  validate  (  )  throws  IllegalArgumentException  {  if  (  delimiter  =  =  encapsulator  )  {  throw  new  IllegalArgumentException  (     "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (  \   "   "  +  encapsulator  +     "\   "  )     "  )  ;  }  if  (  delimiter  =  =  escape  )  {  throw  new  IllegalArgumentException  (     "The  escape  character  and  the  delimiter  cannot  be  the  same  (  \   "   "  +  escape  +     "\   "  )     "  )  ;  }  if  (  delimiter  =  =  commentStart  )  {  [ATTENTION]  return  ;  }  if  (  encapsulator  !  =  DISABLED  &&  encapsulator  =  =  commentStart  )  {  throw  new  IllegalArgumentException  (     "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (  \   "   "  +  commentStart  +     "\   "  )     "  )  ;  }  if  (  escape  !  =  DISABLED  &&  escape  =  =  commentStart  )  {  throw  new  IllegalArgumentException  (     "The  comment  start  and  the  escape  character  cannot  be  the  same  (  \   "   "  +  commentStart  +     "\   "  )     "  )  ;  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVFormat.java^185^^^^^175^195^
[REPLACE]    if    (    encapsulator    !=    DISABLED    &&    encapsulator    ==    commentStart    )    {  	[BUGGY]  if  (  encapsulator  !  =  DISABLED  ||  encapsulator  =  =  commentStart  )  {[FE]  [METHOD]    validate  [TYPE]  void  [PARAMETER]  [CLASS]  CSVFormat    [TYPE]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  [TYPE]  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  [TYPE]  boolean  emptyLinesIgnored  false  surroundingSpacesIgnored  true  [TYPE]  String  CRLF  lineSeparator  [TYPE]  String[]  header    [CONTEXT]    void  validate  (  )  throws  IllegalArgumentException  {  if  (  delimiter  =  =  encapsulator  )  {  throw  new  IllegalArgumentException  (     "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (  \   "   "  +  encapsulator  +     "\   "  )     "  )  ;  }  if  (  delimiter  =  =  escape  )  {  throw  new  IllegalArgumentException  (     "The  escape  character  and  the  delimiter  cannot  be  the  same  (  \   "   "  +  escape  +     "\   "  )     "  )  ;  }  if  (  delimiter  =  =  commentStart  )  {  throw  new  IllegalArgumentException  (     "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (  \   "   "  +  commentStart  +     "\   "  )     "  )  ;  }  [ATTENTION]  if  (  encapsulator  !  =  DISABLED  ||  encapsulator  =  =  commentStart  )  {  throw  new  IllegalArgumentException  (     "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (  \   "   "  +  commentStart  +     "\   "  )     "  )  ;  }  if  (  escape  !  =  DISABLED  &&  escape  =  =  commentStart  )  {  throw  new  IllegalArgumentException  (     "The  comment  start  and  the  escape  character  cannot  be  the  same  (  \   "   "  +  commentStart  +     "\   "  )     "  )  ;  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVFormat.java^188^^^^^175^195^
[REPLACE]    throw    new    IllegalArgumentException    (   "       ")    ;  	[BUGGY]  return  ;  [FE]  [METHOD]    validate  [TYPE]  void  [PARAMETER]  [CLASS]  CSVFormat    [TYPE]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  [TYPE]  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  [TYPE]  boolean  emptyLinesIgnored  false  surroundingSpacesIgnored  true  [TYPE]  String  CRLF  lineSeparator  [TYPE]  String[]  header    [CONTEXT]    void  validate  (  )  throws  IllegalArgumentException  {  if  (  delimiter  =  =  encapsulator  )  {  throw  new  IllegalArgumentException  (     "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (  \   "   "  +  encapsulator  +     "\   "  )     "  )  ;  }  if  (  delimiter  =  =  escape  )  {  throw  new  IllegalArgumentException  (     "The  escape  character  and  the  delimiter  cannot  be  the  same  (  \   "   "  +  escape  +     "\   "  )     "  )  ;  }  if  (  delimiter  =  =  commentStart  )  {  throw  new  IllegalArgumentException  (     "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (  \   "   "  +  commentStart  +     "\   "  )     "  )  ;  }  if  (  encapsulator  !  =  DISABLED  &&  encapsulator  =  =  commentStart  )  {  [ATTENTION]  return  ;  }  if  (  escape  !  =  DISABLED  &&  escape  =  =  commentStart  )  {  throw  new  IllegalArgumentException  (     "The  comment  start  and  the  escape  character  cannot  be  the  same  (  \   "   "  +  commentStart  +     "\   "  )     "  )  ;  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVFormat.java^189^^^^^175^195^
[REPLACE]    if    (    escape    !=    DISABLED    &&    escape    ==    commentStart    )    {  	[BUGGY]  if  (  true  )  {[FE]  [METHOD]    validate  [TYPE]  void  [PARAMETER]  [CLASS]  CSVFormat    [TYPE]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  [TYPE]  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  [TYPE]  boolean  emptyLinesIgnored  false  surroundingSpacesIgnored  true  [TYPE]  String  CRLF  lineSeparator  [TYPE]  String[]  header    [CONTEXT]    void  validate  (  )  throws  IllegalArgumentException  {  if  (  delimiter  =  =  encapsulator  )  {  throw  new  IllegalArgumentException  (     "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (  \   "   "  +  encapsulator  +     "\   "  )     "  )  ;  }  if  (  delimiter  =  =  escape  )  {  throw  new  IllegalArgumentException  (     "The  escape  character  and  the  delimiter  cannot  be  the  same  (  \   "   "  +  escape  +     "\   "  )     "  )  ;  }  if  (  delimiter  =  =  commentStart  )  {  throw  new  IllegalArgumentException  (     "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (  \   "   "  +  commentStart  +     "\   "  )     "  )  ;  }  if  (  encapsulator  !  =  DISABLED  &&  encapsulator  =  =  commentStart  )  {  throw  new  IllegalArgumentException  (     "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (  \   "   "  +  commentStart  +     "\   "  )     "  )  ;  }  [ATTENTION]  if  (  true  )  {  throw  new  IllegalArgumentException  (     "The  comment  start  and  the  escape  character  cannot  be  the  same  (  \   "   "  +  commentStart  +     "\   "  )     "  )  ;  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVFormat.java^192^^^^^175^195^
[ADD]    if    (    escape    !=    DISABLED    &&    escape    ==    commentStart    )    {    throw    new    IllegalArgumentException    (   "       ")    ;    }  	[BUGGY]  [FE]  [METHOD]    validate  [TYPE]  void  [PARAMETER]  [CLASS]  CSVFormat    [TYPE]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  [TYPE]  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  [TYPE]  boolean  emptyLinesIgnored  false  surroundingSpacesIgnored  true  [TYPE]  String  CRLF  lineSeparator  [TYPE]  String[]  header    [CONTEXT]    void  validate  (  )  throws  IllegalArgumentException  {  if  (  delimiter  =  =  encapsulator  )  {  throw  new  IllegalArgumentException  (     "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (  \   "   "  +  encapsulator  +     "\   "  )     "  )  ;  }  if  (  delimiter  =  =  escape  )  {  throw  new  IllegalArgumentException  (     "The  escape  character  and  the  delimiter  cannot  be  the  same  (  \   "   "  +  escape  +     "\   "  )     "  )  ;  }  if  (  delimiter  =  =  commentStart  )  {  throw  new  IllegalArgumentException  (     "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (  \   "   "  +  commentStart  +     "\   "  )     "  )  ;  }  if  (  encapsulator  !  =  DISABLED  &&  encapsulator  =  =  commentStart  )  {  throw  new  IllegalArgumentException  (     "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (  \   "   "  +  commentStart  +     "\   "  )     "  )  ;  }  [ATTENTION]    }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVFormat.java^192^193^194^^^175^195^
[REPLACE]    throw    new    IllegalArgumentException    (   "       ")    ;  	[BUGGY]  return  ;  [FE]  [METHOD]    validate  [TYPE]  void  [PARAMETER]  [CLASS]  CSVFormat    [TYPE]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  [TYPE]  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  [TYPE]  boolean  emptyLinesIgnored  false  surroundingSpacesIgnored  true  [TYPE]  String  CRLF  lineSeparator  [TYPE]  String[]  header    [CONTEXT]    void  validate  (  )  throws  IllegalArgumentException  {  if  (  delimiter  =  =  encapsulator  )  {  throw  new  IllegalArgumentException  (     "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (  \   "   "  +  encapsulator  +     "\   "  )     "  )  ;  }  if  (  delimiter  =  =  escape  )  {  throw  new  IllegalArgumentException  (     "The  escape  character  and  the  delimiter  cannot  be  the  same  (  \   "   "  +  escape  +     "\   "  )     "  )  ;  }  if  (  delimiter  =  =  commentStart  )  {  throw  new  IllegalArgumentException  (     "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (  \   "   "  +  commentStart  +     "\   "  )     "  )  ;  }  if  (  encapsulator  !  =  DISABLED  &&  encapsulator  =  =  commentStart  )  {  throw  new  IllegalArgumentException  (     "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (  \   "   "  +  commentStart  +     "\   "  )     "  )  ;  }  if  (  escape  !  =  DISABLED  &&  escape  =  =  commentStart  )  {  [ATTENTION]  return  ;  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVFormat.java^193^^^^^175^195^
[REPLACE]    return    delimiter;  	[BUGGY]  return  lineSeparator  ;  [CE]  incompatible  types    [METHOD]    getDelimiter  [TYPE]  char  [PARAMETER]  [CLASS]  CSVFormat    [TYPE]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  [TYPE]  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  [TYPE]  boolean  emptyLinesIgnored  false  surroundingSpacesIgnored  true  [TYPE]  String  CRLF  lineSeparator  [TYPE]  String[]  header    [CONTEXT]    public  char  getDelimiter  (  )  {  [ATTENTION]  return  lineSeparator  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVFormat.java^203^^^^^202^204^
[REPLACE]    if    (    isLineBreak    (    delimiter    )    )    {  	[BUGGY]  if  (  isLineBreak  (  escape  )  )  {[FE]  [METHOD]    withDelimiter  [TYPE]  CSVFormat  [PARAMETER]  char  delimiter  [CLASS]  CSVFormat    [TYPE]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  [TYPE]  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  [TYPE]  boolean  emptyLinesIgnored  false  surroundingSpacesIgnored  true  [TYPE]  String  CRLF  lineSeparator  [TYPE]  String[]  header    [CONTEXT]    public  CSVFormat  withDelimiter  (  char  delimiter  )  {  [ATTENTION]  if  (  isLineBreak  (  escape  )  )  {  throw  new  IllegalArgumentException  (     "The  delimiter  cannot  be  a  line  break   "  )  ;  }  return  new  CSVFormat  (  delimiter  ,  encapsulator  ,  commentStart  ,  escape  ,  surroundingSpacesIgnored  ,  emptyLinesIgnored  ,  lineSeparator  ,  header  )  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVFormat.java^214^^^^^213^219^
[ADD]    if    (    isLineBreak    (    delimiter    )    )    {    throw    new    IllegalArgumentException    (   "       ")    ;    }  	[BUGGY]  [FE]  [METHOD]    withDelimiter  [TYPE]  CSVFormat  [PARAMETER]  char  delimiter  [CLASS]  CSVFormat    [TYPE]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  [TYPE]  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  [TYPE]  boolean  emptyLinesIgnored  false  surroundingSpacesIgnored  true  [TYPE]  String  CRLF  lineSeparator  [TYPE]  String[]  header    [CONTEXT]    public  CSVFormat  withDelimiter  (  char  delimiter  )  {  [ATTENTION]      return  new  CSVFormat  (  delimiter  ,  encapsulator  ,  commentStart  ,  escape  ,  surroundingSpacesIgnored  ,  emptyLinesIgnored  ,  lineSeparator  ,  header  )  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVFormat.java^214^215^216^^^213^219^
[REPLACE]    throw    new    IllegalArgumentException    (   "       ")    ;  	[BUGGY]  return  ;  [CE]  missing  return  value    [METHOD]    withDelimiter  [TYPE]  CSVFormat  [PARAMETER]  char  delimiter  [CLASS]  CSVFormat    [TYPE]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  [TYPE]  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  [TYPE]  boolean  emptyLinesIgnored  false  surroundingSpacesIgnored  true  [TYPE]  String  CRLF  lineSeparator  [TYPE]  String[]  header    [CONTEXT]    public  CSVFormat  withDelimiter  (  char  delimiter  )  {  if  (  isLineBreak  (  delimiter  )  )  {  [ATTENTION]  return  ;  }  return  new  CSVFormat  (  delimiter  ,  encapsulator  ,  commentStart  ,  escape  ,  surroundingSpacesIgnored  ,  emptyLinesIgnored  ,  lineSeparator  ,  header  )  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVFormat.java^215^^^^^213^219^
[REPLACE]    return    new    CSVFormat    (    delimiter,    encapsulator,    commentStart,    escape,    surroundingSpacesIgnored,    emptyLinesIgnored,    lineSeparator,    header    )    ;  	[BUGGY]  return  new  CSVFormat  (  escape  ,  encapsulator  ,  commentStart  ,  escape  ,  surroundingSpacesIgnored  ,  emptyLinesIgnored  ,  lineSeparator  ,  header  )  ;  [FE]  [METHOD]    withDelimiter  [TYPE]  CSVFormat  [PARAMETER]  char  delimiter  [CLASS]  CSVFormat    [TYPE]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  [TYPE]  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  [TYPE]  boolean  emptyLinesIgnored  false  surroundingSpacesIgnored  true  [TYPE]  String  CRLF  lineSeparator  [TYPE]  String[]  header    [CONTEXT]    public  CSVFormat  withDelimiter  (  char  delimiter  )  {  if  (  isLineBreak  (  delimiter  )  )  {  throw  new  IllegalArgumentException  (     "The  delimiter  cannot  be  a  line  break   "  )  ;  }  [ATTENTION]  return  new  CSVFormat  (  escape  ,  encapsulator  ,  commentStart  ,  escape  ,  surroundingSpacesIgnored  ,  emptyLinesIgnored  ,  lineSeparator  ,  header  )    ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVFormat.java^218^^^^^213^219^
[REPLACE]    return    encapsulator;  	[BUGGY]  return  lineSeparator  ;  [CE]  incompatible  types    [METHOD]    getEncapsulator  [TYPE]  char  [PARAMETER]  [CLASS]  CSVFormat    [TYPE]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  [TYPE]  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  [TYPE]  boolean  emptyLinesIgnored  false  surroundingSpacesIgnored  true  [TYPE]  String  CRLF  lineSeparator  [TYPE]  String[]  header    [CONTEXT]    public  char  getEncapsulator  (  )  {  [ATTENTION]  return  lineSeparator  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVFormat.java^227^^^^^226^228^
[REPLACE]    if    (    isLineBreak    (    encapsulator    )    )    {  	[BUGGY]  if  (  isLineBreak  (  escape  )  )  {[FE]  [METHOD]    withEncapsulator  [TYPE]  CSVFormat  [PARAMETER]  char  encapsulator  [CLASS]  CSVFormat    [TYPE]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  [TYPE]  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  [TYPE]  boolean  emptyLinesIgnored  false  surroundingSpacesIgnored  true  [TYPE]  String  CRLF  lineSeparator  [TYPE]  String[]  header    [CONTEXT]    public  CSVFormat  withEncapsulator  (  char  encapsulator  )  {  [ATTENTION]  if  (  isLineBreak  (  escape  )  )  {  throw  new  IllegalArgumentException  (     "The  encapsulator  cannot  be  a  line  break   "  )  ;  }  return  new  CSVFormat  (  delimiter  ,  encapsulator  ,  commentStart  ,  escape  ,  surroundingSpacesIgnored  ,  emptyLinesIgnored  ,  lineSeparator  ,  header  )  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVFormat.java^238^^^^^237^243^
[REPLACE]    throw    new    IllegalArgumentException    (   "       ")    ;  	[BUGGY]  return  ;  [CE]  missing  return  value    [METHOD]    withEncapsulator  [TYPE]  CSVFormat  [PARAMETER]  char  encapsulator  [CLASS]  CSVFormat    [TYPE]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  [TYPE]  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  [TYPE]  boolean  emptyLinesIgnored  false  surroundingSpacesIgnored  true  [TYPE]  String  CRLF  lineSeparator  [TYPE]  String[]  header    [CONTEXT]    public  CSVFormat  withEncapsulator  (  char  encapsulator  )  {  if  (  isLineBreak  (  encapsulator  )  )  {  [ATTENTION]  return  ;  }  return  new  CSVFormat  (  delimiter  ,  encapsulator  ,  commentStart  ,  escape  ,  surroundingSpacesIgnored  ,  emptyLinesIgnored  ,  lineSeparator  ,  header  )  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVFormat.java^239^^^^^237^243^
[ADD]    throw    new    IllegalArgumentException    (   "       ")    ;  	[BUGGY]  [FE]  [METHOD]    withEncapsulator  [TYPE]  CSVFormat  [PARAMETER]  char  encapsulator  [CLASS]  CSVFormat    [TYPE]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  [TYPE]  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  [TYPE]  boolean  emptyLinesIgnored  false  surroundingSpacesIgnored  true  [TYPE]  String  CRLF  lineSeparator  [TYPE]  String[]  header    [CONTEXT]    public  CSVFormat  withEncapsulator  (  char  encapsulator  )  {  if  (  isLineBreak  (  encapsulator  )  )  {  [ATTENTION]  }  return  new  CSVFormat  (  delimiter  ,  encapsulator  ,  commentStart  ,  escape  ,  surroundingSpacesIgnored  ,  emptyLinesIgnored  ,  lineSeparator  ,  header  )  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVFormat.java^239^^^^^237^243^
[REPLACE]    return    new    CSVFormat    (    delimiter,    encapsulator,    commentStart,    escape,    surroundingSpacesIgnored,    emptyLinesIgnored,    lineSeparator,    header    )    ;  	[BUGGY]  return  new  CSVFormat  (  delimiter  ,  escape  ,  commentStart  ,  escape  ,  surroundingSpacesIgnored  ,  emptyLinesIgnored  ,  lineSeparator  ,  header  )  ;  [FE]  [METHOD]    withEncapsulator  [TYPE]  CSVFormat  [PARAMETER]  char  encapsulator  [CLASS]  CSVFormat    [TYPE]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  [TYPE]  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  [TYPE]  boolean  emptyLinesIgnored  false  surroundingSpacesIgnored  true  [TYPE]  String  CRLF  lineSeparator  [TYPE]  String[]  header    [CONTEXT]    public  CSVFormat  withEncapsulator  (  char  encapsulator  )  {  if  (  isLineBreak  (  encapsulator  )  )  {  throw  new  IllegalArgumentException  (     "The  encapsulator  cannot  be  a  line  break   "  )  ;  }  [ATTENTION]  return  new  CSVFormat  (  delimiter  ,  escape  ,  commentStart  ,  escape  ,  surroundingSpacesIgnored  ,  emptyLinesIgnored  ,  lineSeparator  ,  header  )    ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVFormat.java^242^^^^^237^243^
[REPLACE]    return    this    .    encapsulator    !=    DISABLED;  	[BUGGY]  return  this  .  encapsulator    ;  [CE]  incompatible  types    [METHOD]    isEncapsulating  [TYPE]  boolean  [PARAMETER]  [CLASS]  CSVFormat    [TYPE]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  [TYPE]  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  [TYPE]  boolean  emptyLinesIgnored  false  surroundingSpacesIgnored  true  [TYPE]  String  CRLF  lineSeparator  [TYPE]  String[]  header    [CONTEXT]    boolean  isEncapsulating  (  )  {  [ATTENTION]  return  this  .  encapsulator  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVFormat.java^246^^^^^245^247^
[REPLACE]    return    commentStart;  	[BUGGY]  return  lineSeparator  ;  [CE]  incompatible  types    [METHOD]    getCommentStart  [TYPE]  char  [PARAMETER]  [CLASS]  CSVFormat    [TYPE]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  [TYPE]  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  [TYPE]  boolean  emptyLinesIgnored  false  surroundingSpacesIgnored  true  [TYPE]  String  CRLF  lineSeparator  [TYPE]  String[]  header    [CONTEXT]    public  char  getCommentStart  (  )  {  [ATTENTION]  return  lineSeparator  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVFormat.java^255^^^^^254^256^
[REPLACE]    if    (    isLineBreak    (    commentStart    )    )    {  	[BUGGY]  if  (  isLineBreak  (  escape  )  )  {[FE]  [METHOD]    withCommentStart  [TYPE]  CSVFormat  [PARAMETER]  char  commentStart  [CLASS]  CSVFormat    [TYPE]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  [TYPE]  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  [TYPE]  boolean  emptyLinesIgnored  false  surroundingSpacesIgnored  true  [TYPE]  String  CRLF  lineSeparator  [TYPE]  String[]  header    [CONTEXT]    public  CSVFormat  withCommentStart  (  char  commentStart  )  {  [ATTENTION]  if  (  isLineBreak  (  escape  )  )  {  throw  new  IllegalArgumentException  (     "The  comment  start  character  cannot  be  a  line  break   "  )  ;  }  return  new  CSVFormat  (  delimiter  ,  encapsulator  ,  commentStart  ,  escape  ,  surroundingSpacesIgnored  ,  emptyLinesIgnored  ,  lineSeparator  ,  header  )  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVFormat.java^266^^^^^265^271^
[ADD]    if    (    isLineBreak    (    commentStart    )    )    {    throw    new    IllegalArgumentException    (   "       ")    ;    }  	[BUGGY]  [FE]  [METHOD]    withCommentStart  [TYPE]  CSVFormat  [PARAMETER]  char  commentStart  [CLASS]  CSVFormat    [TYPE]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  [TYPE]  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  [TYPE]  boolean  emptyLinesIgnored  false  surroundingSpacesIgnored  true  [TYPE]  String  CRLF  lineSeparator  [TYPE]  String[]  header    [CONTEXT]    public  CSVFormat  withCommentStart  (  char  commentStart  )  {  [ATTENTION]      return  new  CSVFormat  (  delimiter  ,  encapsulator  ,  commentStart  ,  escape  ,  surroundingSpacesIgnored  ,  emptyLinesIgnored  ,  lineSeparator  ,  header  )  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVFormat.java^266^267^268^^^265^271^
[REPLACE]    throw    new    IllegalArgumentException    (   "       ")    ;  	[BUGGY]  return  ;  [CE]  missing  return  value    [METHOD]    withCommentStart  [TYPE]  CSVFormat  [PARAMETER]  char  commentStart  [CLASS]  CSVFormat    [TYPE]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  [TYPE]  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  [TYPE]  boolean  emptyLinesIgnored  false  surroundingSpacesIgnored  true  [TYPE]  String  CRLF  lineSeparator  [TYPE]  String[]  header    [CONTEXT]    public  CSVFormat  withCommentStart  (  char  commentStart  )  {  if  (  isLineBreak  (  commentStart  )  )  {  [ATTENTION]  return  ;  }  return  new  CSVFormat  (  delimiter  ,  encapsulator  ,  commentStart  ,  escape  ,  surroundingSpacesIgnored  ,  emptyLinesIgnored  ,  lineSeparator  ,  header  )  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVFormat.java^267^^^^^265^271^
[ADD]    throw    new    IllegalArgumentException    (   "       ")    ;  	[BUGGY]  [FE]  [METHOD]    withCommentStart  [TYPE]  CSVFormat  [PARAMETER]  char  commentStart  [CLASS]  CSVFormat    [TYPE]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  [TYPE]  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  [TYPE]  boolean  emptyLinesIgnored  false  surroundingSpacesIgnored  true  [TYPE]  String  CRLF  lineSeparator  [TYPE]  String[]  header    [CONTEXT]    public  CSVFormat  withCommentStart  (  char  commentStart  )  {  if  (  isLineBreak  (  commentStart  )  )  {  [ATTENTION]  }  return  new  CSVFormat  (  delimiter  ,  encapsulator  ,  commentStart  ,  escape  ,  surroundingSpacesIgnored  ,  emptyLinesIgnored  ,  lineSeparator  ,  header  )  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVFormat.java^267^^^^^265^271^
[REPLACE]    return    new    CSVFormat    (    delimiter,    encapsulator,    commentStart,    escape,    surroundingSpacesIgnored,    emptyLinesIgnored,    lineSeparator,    header    )    ;  	[BUGGY]  return  new  CSVFormat  (  delimiter  ,  encapsulator  ,  escape  ,  escape  ,  surroundingSpacesIgnored  ,  emptyLinesIgnored  ,  lineSeparator  ,  header  )  ;  [FE]  [METHOD]    withCommentStart  [TYPE]  CSVFormat  [PARAMETER]  char  commentStart  [CLASS]  CSVFormat    [TYPE]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  [TYPE]  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  [TYPE]  boolean  emptyLinesIgnored  false  surroundingSpacesIgnored  true  [TYPE]  String  CRLF  lineSeparator  [TYPE]  String[]  header    [CONTEXT]    public  CSVFormat  withCommentStart  (  char  commentStart  )  {  if  (  isLineBreak  (  commentStart  )  )  {  throw  new  IllegalArgumentException  (     "The  comment  start  character  cannot  be  a  line  break   "  )  ;  }  [ATTENTION]  return  new  CSVFormat  (  delimiter  ,  encapsulator  ,  escape  ,  escape  ,  surroundingSpacesIgnored  ,  emptyLinesIgnored  ,  lineSeparator  ,  header  )    ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVFormat.java^270^^^^^265^271^
[REPLACE]    return    this    .    commentStart    !=    DISABLED;  	[BUGGY]  return  this  .  commentStart    ;  [CE]  incompatible  types    [METHOD]    isCommentingEnabled  [TYPE]  boolean  [PARAMETER]  [CLASS]  CSVFormat    [TYPE]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  [TYPE]  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  [TYPE]  boolean  emptyLinesIgnored  false  surroundingSpacesIgnored  true  [TYPE]  String  CRLF  lineSeparator  [TYPE]  String[]  header    [CONTEXT]    public  boolean  isCommentingEnabled  (  )  {  [ATTENTION]  return  this  .  commentStart  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVFormat.java^279^^^^^278^280^
[REPLACE]    return    escape;  	[BUGGY]  return  lineSeparator  ;  [CE]  incompatible  types    [METHOD]    getEscape  [TYPE]  char  [PARAMETER]  [CLASS]  CSVFormat    [TYPE]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  [TYPE]  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  [TYPE]  boolean  emptyLinesIgnored  false  surroundingSpacesIgnored  true  [TYPE]  String  CRLF  lineSeparator  [TYPE]  String[]  header    [CONTEXT]    public  char  getEscape  (  )  {  [ATTENTION]  return  lineSeparator  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVFormat.java^288^^^^^287^289^
[REPLACE]    if    (    isLineBreak    (    escape    )    )    {  	[BUGGY]  if  (  isLineBreak  (  encapsulator  )  )  {[FE]  [METHOD]    withEscape  [TYPE]  CSVFormat  [PARAMETER]  char  escape  [CLASS]  CSVFormat    [TYPE]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  [TYPE]  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  [TYPE]  boolean  emptyLinesIgnored  false  surroundingSpacesIgnored  true  [TYPE]  String  CRLF  lineSeparator  [TYPE]  String[]  header    [CONTEXT]    public  CSVFormat  withEscape  (  char  escape  )  {  [ATTENTION]  if  (  isLineBreak  (  encapsulator  )  )  {  throw  new  IllegalArgumentException  (     "The  escape  character  cannot  be  a  line  break   "  )  ;  }  return  new  CSVFormat  (  delimiter  ,  encapsulator  ,  commentStart  ,  escape  ,  surroundingSpacesIgnored  ,  emptyLinesIgnored  ,  lineSeparator  ,  header  )  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVFormat.java^299^^^^^298^304^
[ADD]    if    (    isLineBreak    (    escape    )    )    {    throw    new    IllegalArgumentException    (   "       ")    ;    }  	[BUGGY]  [FE]  [METHOD]    withEscape  [TYPE]  CSVFormat  [PARAMETER]  char  escape  [CLASS]  CSVFormat    [TYPE]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  [TYPE]  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  [TYPE]  boolean  emptyLinesIgnored  false  surroundingSpacesIgnored  true  [TYPE]  String  CRLF  lineSeparator  [TYPE]  String[]  header    [CONTEXT]    public  CSVFormat  withEscape  (  char  escape  )  {  [ATTENTION]      return  new  CSVFormat  (  delimiter  ,  encapsulator  ,  commentStart  ,  escape  ,  surroundingSpacesIgnored  ,  emptyLinesIgnored  ,  lineSeparator  ,  header  )  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVFormat.java^299^300^301^^^298^304^
[REPLACE]    throw    new    IllegalArgumentException    (   "       ")    ;  	[BUGGY]  return  ;  [CE]  missing  return  value    [METHOD]    withEscape  [TYPE]  CSVFormat  [PARAMETER]  char  escape  [CLASS]  CSVFormat    [TYPE]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  [TYPE]  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  [TYPE]  boolean  emptyLinesIgnored  false  surroundingSpacesIgnored  true  [TYPE]  String  CRLF  lineSeparator  [TYPE]  String[]  header    [CONTEXT]    public  CSVFormat  withEscape  (  char  escape  )  {  if  (  isLineBreak  (  escape  )  )  {  [ATTENTION]  return  ;  }  return  new  CSVFormat  (  delimiter  ,  encapsulator  ,  commentStart  ,  escape  ,  surroundingSpacesIgnored  ,  emptyLinesIgnored  ,  lineSeparator  ,  header  )  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVFormat.java^300^^^^^298^304^
[ADD]    throw    new    IllegalArgumentException    (   "       ")    ;  	[BUGGY]  [FE]  [METHOD]    withEscape  [TYPE]  CSVFormat  [PARAMETER]  char  escape  [CLASS]  CSVFormat    [TYPE]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  [TYPE]  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  [TYPE]  boolean  emptyLinesIgnored  false  surroundingSpacesIgnored  true  [TYPE]  String  CRLF  lineSeparator  [TYPE]  String[]  header    [CONTEXT]    public  CSVFormat  withEscape  (  char  escape  )  {  if  (  isLineBreak  (  escape  )  )  {  [ATTENTION]  }  return  new  CSVFormat  (  delimiter  ,  encapsulator  ,  commentStart  ,  escape  ,  surroundingSpacesIgnored  ,  emptyLinesIgnored  ,  lineSeparator  ,  header  )  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVFormat.java^300^^^^^298^304^
[REPLACE]    return    new    CSVFormat    (    delimiter,    encapsulator,    commentStart,    escape,    surroundingSpacesIgnored,    emptyLinesIgnored,    lineSeparator,    header    )    ;  	[BUGGY]  return  new  CSVFormat  (  delimiter  ,  encapsulator  ,  commentStart  ,  encapsulator  ,  surroundingSpacesIgnored  ,  emptyLinesIgnored  ,  lineSeparator  ,  header  )  ;  [FE]  [METHOD]    withEscape  [TYPE]  CSVFormat  [PARAMETER]  char  escape  [CLASS]  CSVFormat    [TYPE]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  [TYPE]  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  [TYPE]  boolean  emptyLinesIgnored  false  surroundingSpacesIgnored  true  [TYPE]  String  CRLF  lineSeparator  [TYPE]  String[]  header    [CONTEXT]    public  CSVFormat  withEscape  (  char  escape  )  {  if  (  isLineBreak  (  escape  )  )  {  throw  new  IllegalArgumentException  (     "The  escape  character  cannot  be  a  line  break   "  )  ;  }  [ATTENTION]  return  new  CSVFormat  (  delimiter  ,  encapsulator  ,  commentStart  ,  encapsulator  ,  surroundingSpacesIgnored  ,  emptyLinesIgnored  ,  lineSeparator  ,  header  )    ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVFormat.java^303^^^^^298^304^
[REPLACE]    return    this    .    escape    !=    DISABLED;  	[BUGGY]  return  this  .  escape    ;  [CE]  incompatible  types    [METHOD]    isEscaping  [TYPE]  boolean  [PARAMETER]  [CLASS]  CSVFormat    [TYPE]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  [TYPE]  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  [TYPE]  boolean  emptyLinesIgnored  false  surroundingSpacesIgnored  true  [TYPE]  String  CRLF  lineSeparator  [TYPE]  String[]  header    [CONTEXT]    boolean  isEscaping  (  )  {  [ATTENTION]  return  this  .  escape  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVFormat.java^307^^^^^306^308^
[REPLACE]    return    surroundingSpacesIgnored;  	[BUGGY]  return  lineSeparator  ;  [CE]  incompatible  types    [METHOD]    isSurroundingSpacesIgnored  [TYPE]  boolean  [PARAMETER]  [CLASS]  CSVFormat    [TYPE]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  [TYPE]  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  [TYPE]  boolean  emptyLinesIgnored  false  surroundingSpacesIgnored  true  [TYPE]  String  CRLF  lineSeparator  [TYPE]  String[]  header    [CONTEXT]    public  boolean  isSurroundingSpacesIgnored  (  )  {  [ATTENTION]  return  lineSeparator  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVFormat.java^316^^^^^315^317^
[REPLACE]    return    new    CSVFormat    (    delimiter,    encapsulator,    commentStart,    escape,    surroundingSpacesIgnored,    emptyLinesIgnored,    lineSeparator,    header    )    ;  	[BUGGY]  return  new  CSVFormat  (  delimiter  ,  encapsulator  ,  commentStart  ,  escape  ,  true  ,  emptyLinesIgnored  ,  lineSeparator  ,  header  )  ;  [FE]    null  assertEquals('?'  ,  format.withDelimiter('?').getDelimiter())      [METHOD]    withSurroundingSpacesIgnored  [TYPE]  CSVFormat  [PARAMETER]  boolean  surroundingSpacesIgnored  [CLASS]  CSVFormat    [TYPE]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  [TYPE]  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  [TYPE]  boolean  emptyLinesIgnored  false  surroundingSpacesIgnored  true  [TYPE]  String  CRLF  lineSeparator  [TYPE]  String[]  header    [CONTEXT]    public  CSVFormat  withSurroundingSpacesIgnored  (  boolean  surroundingSpacesIgnored  )  {  [ATTENTION]  return  new  CSVFormat  (  delimiter  ,  encapsulator  ,  commentStart  ,  escape  ,  true  ,  emptyLinesIgnored  ,  lineSeparator  ,  header  )    ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVFormat.java^327^^^^^326^328^
[REPLACE]    return    emptyLinesIgnored;  	[BUGGY]  return  lineSeparator  ;  [CE]  incompatible  types    [METHOD]    isEmptyLinesIgnored  [TYPE]  boolean  [PARAMETER]  [CLASS]  CSVFormat    [TYPE]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  [TYPE]  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  [TYPE]  boolean  emptyLinesIgnored  false  surroundingSpacesIgnored  true  [TYPE]  String  CRLF  lineSeparator  [TYPE]  String[]  header    [CONTEXT]    public  boolean  isEmptyLinesIgnored  (  )  {  [ATTENTION]  return  lineSeparator  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVFormat.java^336^^^^^335^337^
[REPLACE]    return    new    CSVFormat    (    delimiter,    encapsulator,    commentStart,    escape,    surroundingSpacesIgnored,    emptyLinesIgnored,    lineSeparator,    header    )    ;  	[BUGGY]  return  new  CSVFormat  (  delimiter  ,  encapsulator  ,  commentStart  ,  escape  ,  surroundingSpacesIgnored  ,  true  ,  lineSeparator  ,  header  )  ;  [FE]    null  assertEquals('?'  ,  format.withDelimiter('?').getDelimiter())      [METHOD]    withEmptyLinesIgnored  [TYPE]  CSVFormat  [PARAMETER]  boolean  emptyLinesIgnored  [CLASS]  CSVFormat    [TYPE]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  [TYPE]  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  [TYPE]  boolean  emptyLinesIgnored  false  surroundingSpacesIgnored  true  [TYPE]  String  CRLF  lineSeparator  [TYPE]  String[]  header    [CONTEXT]    public  CSVFormat  withEmptyLinesIgnored  (  boolean  emptyLinesIgnored  )  {  [ATTENTION]  return  new  CSVFormat  (  delimiter  ,  encapsulator  ,  commentStart  ,  escape  ,  surroundingSpacesIgnored  ,  true  ,  lineSeparator  ,  header  )    ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVFormat.java^347^^^^^346^348^
[REPLACE]    return    lineSeparator;  	[BUGGY]  return  new  CSVParser  (  in  ,  this  )  ;  [CE]  cannot  find  symbol  in    [METHOD]    getLineSeparator  [TYPE]  String  [PARAMETER]  [CLASS]  CSVFormat    [TYPE]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  [TYPE]  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  [TYPE]  boolean  emptyLinesIgnored  false  surroundingSpacesIgnored  true  [TYPE]  String  CRLF  lineSeparator  [TYPE]  String[]  header    [CONTEXT]    public  String  getLineSeparator  (  )  {  [ATTENTION]  return  new  CSVParser  (  in  ,  this  )    ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVFormat.java^356^^^^^355^357^
[REPLACE]    return    new    CSVFormat    (    delimiter,    encapsulator,    commentStart,    escape,    surroundingSpacesIgnored,    emptyLinesIgnored,    lineSeparator,    header    )    ;  	[BUGGY]  return  new  CSVFormat  (  delimiter  ,  encapsulator  ,  commentStart  ,  escape  ,  surroundingSpacesIgnored  ,  emptyLinesIgnored  ,  CRLF  ,  header  )  ;  [FE]    AssertionFailedError    expected:<[?]>  but  was:<[  assertEquals('?'  ,  format.withDelimiter('?').getDelimiter())      [METHOD]    withLineSeparator  [TYPE]  CSVFormat  [PARAMETER]  String  lineSeparator  [CLASS]  CSVFormat    [TYPE]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  [TYPE]  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  [TYPE]  boolean  emptyLinesIgnored  false  surroundingSpacesIgnored  true  [TYPE]  String  CRLF  lineSeparator  [TYPE]  String[]  header    [CONTEXT]    public  CSVFormat  withLineSeparator  (  String  lineSeparator  )  {  [ATTENTION]  return  new  CSVFormat  (  delimiter  ,  encapsulator  ,  commentStart  ,  escape  ,  surroundingSpacesIgnored  ,  emptyLinesIgnored  ,  CRLF  ,  header  )    ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVFormat.java^367^^^^^366^368^
[REPLACE]    return    header;  	[BUGGY]  return  lineSeparator  ;  [CE]  incompatible  types    [METHOD]    getHeader  [TYPE]  String[]  [PARAMETER]  [CLASS]  CSVFormat    [TYPE]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  [TYPE]  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  [TYPE]  boolean  emptyLinesIgnored  false  surroundingSpacesIgnored  true  [TYPE]  String  CRLF  lineSeparator  [TYPE]  String[]  header    [CONTEXT]    String[]  getHeader  (  )  {  [ATTENTION]  return  lineSeparator  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVFormat.java^371^^^^^370^372^
[REPLACE]    return    new    CSVFormat    (    delimiter,    encapsulator,    commentStart,    escape,    surroundingSpacesIgnored,    emptyLinesIgnored,    lineSeparator,    header    )    ;  	[BUGGY]  return  lineSeparator  ;  [CE]  incompatible  types    [METHOD]    withHeader  [TYPE]  CSVFormat  [PARAMETER]  header  [CLASS]  CSVFormat    [TYPE]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  [TYPE]  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  [TYPE]  boolean  emptyLinesIgnored  false  surroundingSpacesIgnored  true  [TYPE]  String  CRLF  lineSeparator  [TYPE]  String[]  header    [CONTEXT]    public  CSVFormat  withHeader  (  String  .  .  .  header  )  {  [ATTENTION]  return  lineSeparator  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVFormat.java^389^^^^^388^390^
[REPLACE]    return    new    CSVParser    (    in,    this    )    ;  	[BUGGY]  return  new  CSVPrinter  (  out  ,  this  )    ;  [CE]  cannot  find  symbol  out    [METHOD]    parse  [TYPE]  Iterable  [PARAMETER]  Reader  in  [CLASS]  CSVFormat    [TYPE]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  [TYPE]  Reader  in  [TYPE]  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  [TYPE]  boolean  emptyLinesIgnored  false  surroundingSpacesIgnored  true  [TYPE]  String  CRLF  lineSeparator  [TYPE]  String[]  header    [CONTEXT]    public  Iterable<CSVRecord>  parse  (  Reader  in  )  throws  IOException  {  [ATTENTION]  returnnew  CSVPrinter  (  out  ,  this  )  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVFormat.java^398^^^^^397^399^
[REPLACE]    StringWriter    out    =    new    StringWriter    (    )    ;  	[BUGGY]  StringBuilder  sb  =  new  StringBuilder  (  )  ;  [CE]  cannot  find  symbol  out    [METHOD]    format  [TYPE]  String  [PARAMETER]  values  [CLASS]  CSVFormat    [TYPE]  boolean  emptyLinesIgnored  false  surroundingSpacesIgnored  true  [TYPE]  StringWriter  out  [TYPE]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  [TYPE]  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  [TYPE]  String  CRLF  lineSeparator  [TYPE]  String[]  header  values  [TYPE]  IOException  e    [CONTEXT]    public  String  format  (  String  .  .  .  values  )  {  [ATTENTION]  StringBuilder  sb  =  new  StringBuilder  (  )    ;  try  {  new  CSVPrinter  (  out  ,  this  )  .  println  (  values  )  ;  }  catch  (  IOException  e  )  {    }  return  out  .  toString  (  )  .  trim  (  )  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVFormat.java^407^^^^^406^415^
[ADD]    try    {    new    CSVPrinter    (    out,    this    )        .    println    (    values    )    ;    }    catch    (    IOException    e    )    {    }  	[BUGGY]  new  CSVPrinter  (  out  ,  this  )  .  println  (  values  )  ;  [CE]  unreported  exception  IOException  ;  must  be  caught  or  declared  to  be  thrown    [METHOD]    format  [TYPE]  String  [PARAMETER]  values  [CLASS]  CSVFormat    [TYPE]  boolean  emptyLinesIgnored  false  surroundingSpacesIgnored  true  [TYPE]  StringWriter  out  [TYPE]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  [TYPE]  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  [TYPE]  String  CRLF  lineSeparator  [TYPE]  String[]  header  values  [TYPE]  IOException  e    [CONTEXT]    public  String  format  (  String  .  .  .  values  )  {  StringWriter  out  =  new  StringWriter  (  )  ;  [ATTENTION]  new  CSVPrinter  (  out  ,  this  )    .  println  (  values  )    ;        return  out  .  toString  (  )  .  trim  (  )  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVFormat.java^408^409^410^^412^406^415^
[REPLACE]    new    CSVPrinter    (    out,    this    )        .    println    (    values    )    ;  	[BUGGY]  new  CSVPrinter  (  out  ,  this  )  .  CSVPrinter  (  header  )  ;  [CE]  cannot  find  symbol    [METHOD]    format  [TYPE]  String  [PARAMETER]  values  [CLASS]  CSVFormat    [TYPE]  boolean  emptyLinesIgnored  false  surroundingSpacesIgnored  true  [TYPE]  StringWriter  out  [TYPE]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  [TYPE]  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  [TYPE]  String  CRLF  lineSeparator  [TYPE]  String[]  header  values  [TYPE]  IOException  e    [CONTEXT]    public  String  format  (  String  .  .  .  values  )  {  StringWriter  out  =  new  StringWriter  (  )  ;  try  {  [ATTENTION]  new  CSVPrinter  (  out  ,  this  )    .  CSVPrinter  (  header  )    ;  }  catch  (  IOException  e  )  {    }  return  out  .  toString  (  )  .  trim  (  )  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVFormat.java^409^^^^^406^415^
[ADD]    new    CSVPrinter    (    out,    this    )        .    println    (    values    )    ;  	[BUGGY]  [CE]  exception  IOException  is  never  thrown  in  body  of  corresponding  try  statement    [METHOD]    format  [TYPE]  String  [PARAMETER]  values  [CLASS]  CSVFormat    [TYPE]  boolean  emptyLinesIgnored  false  surroundingSpacesIgnored  true  [TYPE]  StringWriter  out  [TYPE]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  [TYPE]  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  [TYPE]  String  CRLF  lineSeparator  [TYPE]  String[]  header  values  [TYPE]  IOException  e    [CONTEXT]    public  String  format  (  String  .  .  .  values  )  {  StringWriter  out  =  new  StringWriter  (  )  ;  try  {  [ATTENTION]  }  catch  (  IOException  e  )  {    }  return  out  .  toString  (  )  .  trim  (  )  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVFormat.java^409^^^^^406^415^
[REPLACE]    return    out    .    toString    (    )        .    trim    (    )    ;  	[BUGGY]  return  out  .  StringWriter  (  )  .  trim  (  )  ;  [CE]  cannot  find  symbol    [METHOD]    format  [TYPE]  String  [PARAMETER]  values  [CLASS]  CSVFormat    [TYPE]  boolean  emptyLinesIgnored  false  surroundingSpacesIgnored  true  [TYPE]  StringWriter  out  [TYPE]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  [TYPE]  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  [TYPE]  String  CRLF  lineSeparator  [TYPE]  String[]  header  values  [TYPE]  IOException  e    [CONTEXT]    public  String  format  (  String  .  .  .  values  )  {  StringWriter  out  =  new  StringWriter  (  )  ;  try  {  new  CSVPrinter  (  out  ,  this  )  .  println  (  values  )  ;  }  catch  (  IOException  e  )  {    }  [ATTENTION]  return  out  .  StringWriter  (  )    .  trim  (  )    ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVFormat.java^414^^^^^406^415^
[REPLACE]    StringBuilder    sb    =    new    StringBuilder    (    )    ;  	[BUGGY]  StringWriter  out  =  new  StringWriter  (  )  ;  [CE]  cannot  find  symbol  sb    [METHOD]    toString  [TYPE]  String  [PARAMETER]  [CLASS]  CSVFormat    [TYPE]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  [TYPE]  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  [TYPE]  boolean  emptyLinesIgnored  false  surroundingSpacesIgnored  true  [TYPE]  String  CRLF  lineSeparator  [TYPE]  String[]  header  values  [TYPE]  StringBuilder  sb    [CONTEXT]    public  String  toString  (  )  {  [ATTENTION]  StringWriter  out  =  new  StringWriter  (  )    ;  sb  .  append  (     "Delimiter  =  <   "  )  .  append  (  delimiter  )  .  append  (  '>'  )  ;  if  (  isEscaping  (  )  )  {  sb  .  append  (  '  '  )  ;  sb  .  append  (     "Escape  =  <   "  )  .  append  (  escape  )  .  append  (  '>'  )  ;  }  if  (  isEncapsulating  (  )  )  {  sb  .  append  (  '  '  )  ;  sb  .  append  (     "Encapsulator  =  <   "  )  .  append  (  encapsulator  )  .  append  (  '>'  )  ;  }  if  (  isCommentingEnabled  (  )  )  {  sb  .  append  (  '  '  )  ;  sb  .  append  (     "CommentStart  =  <   "  )  .  append  (  commentStart  )  .  append  (  '>'  )  ;  }  if  (  isEmptyLinesIgnored  (  )  )  {  sb  .  append  (     "  EmptyLines:ignored   "  )  ;  }  if  (  isSurroundingSpacesIgnored  (  )  )  {  sb  .  append  (     "  SurroundingSpaces:ignored   "  )  ;  }  return  sb  .  toString  (  )  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVFormat.java^419^^^^^418^440^
[REPLACE]    sb    .    append    (       "Delimiter=<   "    )        .    append    (    delimiter    )        .    append    (    '>'    )    ;  	[BUGGY]  sb  .  StringBuilder  (  )[CE]  '  ;  '  expected    [METHOD]    toString  [TYPE]  String  [PARAMETER]  [CLASS]  CSVFormat    [TYPE]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  [TYPE]  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  [TYPE]  boolean  emptyLinesIgnored  false  surroundingSpacesIgnored  true  [TYPE]  String  CRLF  lineSeparator  [TYPE]  String[]  header  values  [TYPE]  StringBuilder  sb    [CONTEXT]    public  String  toString  (  )  {  StringBuilder  sb  =  new  StringBuilder  (  )  ;  [ATTENTION]  sb  .  StringBuilder  (  )  if  (  isEscaping  (  )  )  {  sb  .  append  (  '  '  )  ;  sb  .  append  (     "Escape  =  <   "  )  .  append  (  escape  )  .  append  (  '>'  )  ;  }  if  (  isEncapsulating  (  )  )  {  sb  .  append  (  '  '  )  ;  sb  .  append  (     "Encapsulator  =  <   "  )  .  append  (  encapsulator  )  .  append  (  '>'  )  ;  }  if  (  isCommentingEnabled  (  )  )  {  sb  .  append  (  '  '  )  ;  sb  .  append  (     "CommentStart  =  <   "  )  .  append  (  commentStart  )  .  append  (  '>'  )  ;  }  if  (  isEmptyLinesIgnored  (  )  )  {  sb  .  append  (     "  EmptyLines:ignored   "  )  ;  }  if  (  isSurroundingSpacesIgnored  (  )  )  {  sb  .  append  (     "  SurroundingSpaces:ignored   "  )  ;  }  return  sb  .  toString  (  )  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVFormat.java^420^^^^^418^440^
[REPLACE]    sb    .    append    (       "Delimiter=<   "    )        .    append    (    delimiter    )        .    append    (    '>'    )    ;  	[BUGGY]  sb  .  append  (     "CommentStart  =  <   "  )  .  append  (  commentStart  )  .  append  (  '>'  )  ;  [NO-ERROR]    [METHOD]    toString  [TYPE]  String  [PARAMETER]  [CLASS]  CSVFormat    [TYPE]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  [TYPE]  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  [TYPE]  boolean  emptyLinesIgnored  false  surroundingSpacesIgnored  true  [TYPE]  String  CRLF  lineSeparator  [TYPE]  String[]  header  values  [TYPE]  StringBuilder  sb    [CONTEXT]    public  String  toString  (  )  {  StringBuilder  sb  =  new  StringBuilder  (  )  ;  [ATTENTION]  sb  .  append  (     "CommentStart  =  <   "  )    .  append  (  commentStart  )    .  append  (  '>'  )    ;  if  (  isEscaping  (  )  )  {  sb  .  append  (  '  '  )  ;  sb  .  append  (     "Escape  =  <   "  )  .  append  (  escape  )  .  append  (  '>'  )  ;  }  if  (  isEncapsulating  (  )  )  {  sb  .  append  (  '  '  )  ;  sb  .  append  (     "Encapsulator  =  <   "  )  .  append  (  encapsulator  )  .  append  (  '>'  )  ;  }  if  (  isCommentingEnabled  (  )  )  {  sb  .  append  (  '  '  )  ;  sb  .  append  (     "CommentStart  =  <   "  )  .  append  (  commentStart  )  .  append  (  '>'  )  ;  }  if  (  isEmptyLinesIgnored  (  )  )  {  sb  .  append  (     "  EmptyLines:ignored   "  )  ;  }  if  (  isSurroundingSpacesIgnored  (  )  )  {  sb  .  append  (     "  SurroundingSpaces:ignored   "  )  ;  }  return  sb  .  toString  (  )  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVFormat.java^420^^^^^418^440^
[REPLACE]    if    (    isEscaping    (    )    )    {  	[BUGGY]  if  (  isEncapsulating  (  )  )  {[NO-ERROR]    [METHOD]    toString  [TYPE]  String  [PARAMETER]  [CLASS]  CSVFormat    [TYPE]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  [TYPE]  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  [TYPE]  boolean  emptyLinesIgnored  false  surroundingSpacesIgnored  true  [TYPE]  String  CRLF  lineSeparator  [TYPE]  String[]  header  values  [TYPE]  StringBuilder  sb    [CONTEXT]    public  String  toString  (  )  {  StringBuilder  sb  =  new  StringBuilder  (  )  ;  sb  .  append  (     "Delimiter  =  <   "  )  .  append  (  delimiter  )  .  append  (  '>'  )  ;  [ATTENTION]  if  (  isEncapsulating  (  )  )  {  sb  .  append  (  '  '  )  ;  sb  .  append  (     "Escape  =  <   "  )  .  append  (  escape  )  .  append  (  '>'  )  ;  }  if  (  isEncapsulating  (  )  )  {  sb  .  append  (  '  '  )  ;  sb  .  append  (     "Encapsulator  =  <   "  )  .  append  (  encapsulator  )  .  append  (  '>'  )  ;  }  if  (  isCommentingEnabled  (  )  )  {  sb  .  append  (  '  '  )  ;  sb  .  append  (     "CommentStart  =  <   "  )  .  append  (  commentStart  )  .  append  (  '>'  )  ;  }  if  (  isEmptyLinesIgnored  (  )  )  {  sb  .  append  (     "  EmptyLines:ignored   "  )  ;  }  if  (  isSurroundingSpacesIgnored  (  )  )  {  sb  .  append  (     "  SurroundingSpaces:ignored   "  )  ;  }  return  sb  .  toString  (  )  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVFormat.java^421^^^^^418^440^
[REPLACE]    sb    .    append    (    '    '    )    ;  	[BUGGY]  sb  .  StringBuilder  (  )    ;  [CE]  cannot  find  symbol    [METHOD]    toString  [TYPE]  String  [PARAMETER]  [CLASS]  CSVFormat    [TYPE]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  [TYPE]  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  [TYPE]  boolean  emptyLinesIgnored  false  surroundingSpacesIgnored  true  [TYPE]  String  CRLF  lineSeparator  [TYPE]  String[]  header  values  [TYPE]  StringBuilder  sb    [CONTEXT]    public  String  toString  (  )  {  StringBuilder  sb  =  new  StringBuilder  (  )  ;  sb  .  append  (     "Delimiter  =  <   "  )  .  append  (  delimiter  )  .  append  (  '>'  )  ;  if  (  isEscaping  (  )  )  {  [ATTENTION]  sb  .  StringBuilder  (  )  ;  sb  .  append  (     "Escape  =  <   "  )  .  append  (  escape  )  .  append  (  '>'  )  ;  }  if  (  isEncapsulating  (  )  )  {  sb  .  append  (  '  '  )  ;  sb  .  append  (     "Encapsulator  =  <   "  )  .  append  (  encapsulator  )  .  append  (  '>'  )  ;  }  if  (  isCommentingEnabled  (  )  )  {  sb  .  append  (  '  '  )  ;  sb  .  append  (     "CommentStart  =  <   "  )  .  append  (  commentStart  )  .  append  (  '>'  )  ;  }  if  (  isEmptyLinesIgnored  (  )  )  {  sb  .  append  (     "  EmptyLines:ignored   "  )  ;  }  if  (  isSurroundingSpacesIgnored  (  )  )  {  sb  .  append  (     "  SurroundingSpaces:ignored   "  )  ;  }  return  sb  .  toString  (  )  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVFormat.java^422^^^^^418^440^
[ADD]    sb    .    append    (    '    '    )    ;  	[BUGGY]  [NO-ERROR]    [METHOD]    toString  [TYPE]  String  [PARAMETER]  [CLASS]  CSVFormat    [TYPE]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  [TYPE]  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  [TYPE]  boolean  emptyLinesIgnored  false  surroundingSpacesIgnored  true  [TYPE]  String  CRLF  lineSeparator  [TYPE]  String[]  header  values  [TYPE]  StringBuilder  sb    [CONTEXT]    public  String  toString  (  )  {  StringBuilder  sb  =  new  StringBuilder  (  )  ;  sb  .  append  (     "Delimiter  =  <   "  )  .  append  (  delimiter  )  .  append  (  '>'  )  ;  if  (  isEscaping  (  )  )  {  [ATTENTION]  sb  .  append  (     "Escape  =  <   "  )  .  append  (  escape  )  .  append  (  '>'  )  ;  }  if  (  isEncapsulating  (  )  )  {  sb  .  append  (  '  '  )  ;  sb  .  append  (     "Encapsulator  =  <   "  )  .  append  (  encapsulator  )  .  append  (  '>'  )  ;  }  if  (  isCommentingEnabled  (  )  )  {  sb  .  append  (  '  '  )  ;  sb  .  append  (     "CommentStart  =  <   "  )  .  append  (  commentStart  )  .  append  (  '>'  )  ;  }  if  (  isEmptyLinesIgnored  (  )  )  {  sb  .  append  (     "  EmptyLines:ignored   "  )  ;  }  if  (  isSurroundingSpacesIgnored  (  )  )  {  sb  .  append  (     "  SurroundingSpaces:ignored   "  )  ;  }  return  sb  .  toString  (  )  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVFormat.java^422^^^^^418^440^
[REPLACE]    sb    .    append    (       "Escape=<   "    )        .    append    (    escape    )        .    append    (    '>'    )    ;  	[BUGGY]  sb  .  append  (     "Delimiter  =  <   "  )  .  append  (  delimiter  )  .  append  (  '>'  )  ;  [NO-ERROR]    [METHOD]    toString  [TYPE]  String  [PARAMETER]  [CLASS]  CSVFormat    [TYPE]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  [TYPE]  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  [TYPE]  boolean  emptyLinesIgnored  false  surroundingSpacesIgnored  true  [TYPE]  String  CRLF  lineSeparator  [TYPE]  String[]  header  values  [TYPE]  StringBuilder  sb    [CONTEXT]    public  String  toString  (  )  {  StringBuilder  sb  =  new  StringBuilder  (  )  ;  sb  .  append  (     "Delimiter  =  <   "  )  .  append  (  delimiter  )  .  append  (  '>'  )  ;  if  (  isEscaping  (  )  )  {  sb  .  append  (  '  '  )  ;  [ATTENTION]  sb  .  append  (     "Delimiter  =  <   "  )    .  append  (  delimiter  )    .  append  (  '>'  )    ;  }  if  (  isEncapsulating  (  )  )  {  sb  .  append  (  '  '  )  ;  sb  .  append  (     "Encapsulator  =  <   "  )  .  append  (  encapsulator  )  .  append  (  '>'  )  ;  }  if  (  isCommentingEnabled  (  )  )  {  sb  .  append  (  '  '  )  ;  sb  .  append  (     "CommentStart  =  <   "  )  .  append  (  commentStart  )  .  append  (  '>'  )  ;  }  if  (  isEmptyLinesIgnored  (  )  )  {  sb  .  append  (     "  EmptyLines:ignored   "  )  ;  }  if  (  isSurroundingSpacesIgnored  (  )  )  {  sb  .  append  (     "  SurroundingSpaces:ignored   "  )  ;  }  return  sb  .  toString  (  )  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVFormat.java^423^^^^^418^440^
[REPLACE]    sb    .    append    (       "Escape=<   "    )        .    append    (    escape    )        .    append    (    '>'    )    ;  	[BUGGY]  sb  .  StringBuilder  (  )[CE]  '  ;  '  expected    [METHOD]    toString  [TYPE]  String  [PARAMETER]  [CLASS]  CSVFormat    [TYPE]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  [TYPE]  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  [TYPE]  boolean  emptyLinesIgnored  false  surroundingSpacesIgnored  true  [TYPE]  String  CRLF  lineSeparator  [TYPE]  String[]  header  values  [TYPE]  StringBuilder  sb    [CONTEXT]    public  String  toString  (  )  {  StringBuilder  sb  =  new  StringBuilder  (  )  ;  sb  .  append  (     "Delimiter  =  <   "  )  .  append  (  delimiter  )  .  append  (  '>'  )  ;  if  (  isEscaping  (  )  )  {  sb  .  append  (  '  '  )  ;  [ATTENTION]  sb  .  StringBuilder  (  )  }  if  (  isEncapsulating  (  )  )  {  sb  .  append  (  '  '  )  ;  sb  .  append  (     "Encapsulator  =  <   "  )  .  append  (  encapsulator  )  .  append  (  '>'  )  ;  }  if  (  isCommentingEnabled  (  )  )  {  sb  .  append  (  '  '  )  ;  sb  .  append  (     "CommentStart  =  <   "  )  .  append  (  commentStart  )  .  append  (  '>'  )  ;  }  if  (  isEmptyLinesIgnored  (  )  )  {  sb  .  append  (     "  EmptyLines:ignored   "  )  ;  }  if  (  isSurroundingSpacesIgnored  (  )  )  {  sb  .  append  (     "  SurroundingSpaces:ignored   "  )  ;  }  return  sb  .  toString  (  )  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVFormat.java^423^^^^^418^440^
[REPLACE]    if    (    isEncapsulating    (    )    )    {  	[BUGGY]  if  (  isEscaping  (  )  )  {[NO-ERROR]    [METHOD]    toString  [TYPE]  String  [PARAMETER]  [CLASS]  CSVFormat    [TYPE]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  [TYPE]  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  [TYPE]  boolean  emptyLinesIgnored  false  surroundingSpacesIgnored  true  [TYPE]  String  CRLF  lineSeparator  [TYPE]  String[]  header  values  [TYPE]  StringBuilder  sb    [CONTEXT]    public  String  toString  (  )  {  StringBuilder  sb  =  new  StringBuilder  (  )  ;  sb  .  append  (     "Delimiter  =  <   "  )  .  append  (  delimiter  )  .  append  (  '>'  )  ;  if  (  isEscaping  (  )  )  {  sb  .  append  (  '  '  )  ;  sb  .  append  (     "Escape  =  <   "  )  .  append  (  escape  )  .  append  (  '>'  )  ;  }  [ATTENTION]  if  (  isEscaping  (  )  )  {  sb  .  append  (  '  '  )  ;  sb  .  append  (     "Encapsulator  =  <   "  )  .  append  (  encapsulator  )  .  append  (  '>'  )  ;  }  if  (  isCommentingEnabled  (  )  )  {  sb  .  append  (  '  '  )  ;  sb  .  append  (     "CommentStart  =  <   "  )  .  append  (  commentStart  )  .  append  (  '>'  )  ;  }  if  (  isEmptyLinesIgnored  (  )  )  {  sb  .  append  (     "  EmptyLines:ignored   "  )  ;  }  if  (  isSurroundingSpacesIgnored  (  )  )  {  sb  .  append  (     "  SurroundingSpaces:ignored   "  )  ;  }  return  sb  .  toString  (  )  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVFormat.java^425^^^^^418^440^
[ADD]    if    (    isEncapsulating    (    )    )    {    sb    .    append    (    '    '    )    ;    sb    .    append    (       "Encapsulator=<   "    )        .    append    (    encapsulator    )        .    append    (    '>'    )    ;    }  	[BUGGY]  [NO-ERROR]    [METHOD]    toString  [TYPE]  String  [PARAMETER]  [CLASS]  CSVFormat    [TYPE]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  [TYPE]  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  [TYPE]  boolean  emptyLinesIgnored  false  surroundingSpacesIgnored  true  [TYPE]  String  CRLF  lineSeparator  [TYPE]  String[]  header  values  [TYPE]  StringBuilder  sb    [CONTEXT]    public  String  toString  (  )  {  StringBuilder  sb  =  new  StringBuilder  (  )  ;  sb  .  append  (     "Delimiter  =  <   "  )  .  append  (  delimiter  )  .  append  (  '>'  )  ;  if  (  isEscaping  (  )  )  {  sb  .  append  (  '  '  )  ;  sb  .  append  (     "Escape  =  <   "  )  .  append  (  escape  )  .  append  (  '>'  )  ;  }  [ATTENTION]      if  (  isCommentingEnabled  (  )  )  {  sb  .  append  (  '  '  )  ;  sb  .  append  (     "CommentStart  =  <   "  )  .  append  (  commentStart  )  .  append  (  '>'  )  ;  }  if  (  isEmptyLinesIgnored  (  )  )  {  sb  .  append  (     "  EmptyLines:ignored   "  )  ;  }  if  (  isSurroundingSpacesIgnored  (  )  )  {  sb  .  append  (     "  SurroundingSpaces:ignored   "  )  ;  }  return  sb  .  toString  (  )  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVFormat.java^425^426^427^428^^418^440^
[REPLACE]    sb    .    append    (    '    '    )    ;  	[BUGGY]  sb  .  StringBuilder  (  )    ;  [CE]  cannot  find  symbol    [METHOD]    toString  [TYPE]  String  [PARAMETER]  [CLASS]  CSVFormat    [TYPE]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  [TYPE]  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  [TYPE]  boolean  emptyLinesIgnored  false  surroundingSpacesIgnored  true  [TYPE]  String  CRLF  lineSeparator  [TYPE]  String[]  header  values  [TYPE]  StringBuilder  sb    [CONTEXT]    public  String  toString  (  )  {  StringBuilder  sb  =  new  StringBuilder  (  )  ;  sb  .  append  (     "Delimiter  =  <   "  )  .  append  (  delimiter  )  .  append  (  '>'  )  ;  if  (  isEscaping  (  )  )  {  sb  .  append  (  '  '  )  ;  sb  .  append  (     "Escape  =  <   "  )  .  append  (  escape  )  .  append  (  '>'  )  ;  }  if  (  isEncapsulating  (  )  )  {  [ATTENTION]  sb  .  StringBuilder  (  )  ;  sb  .  append  (     "Encapsulator  =  <   "  )  .  append  (  encapsulator  )  .  append  (  '>'  )  ;  }  if  (  isCommentingEnabled  (  )  )  {  sb  .  append  (  '  '  )  ;  sb  .  append  (     "CommentStart  =  <   "  )  .  append  (  commentStart  )  .  append  (  '>'  )  ;  }  if  (  isEmptyLinesIgnored  (  )  )  {  sb  .  append  (     "  EmptyLines:ignored   "  )  ;  }  if  (  isSurroundingSpacesIgnored  (  )  )  {  sb  .  append  (     "  SurroundingSpaces:ignored   "  )  ;  }  return  sb  .  toString  (  )  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVFormat.java^426^^^^^418^440^
[REPLACE]    sb    .    append    (       "Encapsulator=<   "    )        .    append    (    encapsulator    )        .    append    (    '>'    )    ;  	[BUGGY]  sb  .  append  (     "Delimiter  =  <   "  )  .  append  (  delimiter  )  .  append  (  '>'  )  ;  [NO-ERROR]    [METHOD]    toString  [TYPE]  String  [PARAMETER]  [CLASS]  CSVFormat    [TYPE]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  [TYPE]  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  [TYPE]  boolean  emptyLinesIgnored  false  surroundingSpacesIgnored  true  [TYPE]  String  CRLF  lineSeparator  [TYPE]  String[]  header  values  [TYPE]  StringBuilder  sb    [CONTEXT]    public  String  toString  (  )  {  StringBuilder  sb  =  new  StringBuilder  (  )  ;  sb  .  append  (     "Delimiter  =  <   "  )  .  append  (  delimiter  )  .  append  (  '>'  )  ;  if  (  isEscaping  (  )  )  {  sb  .  append  (  '  '  )  ;  sb  .  append  (     "Escape  =  <   "  )  .  append  (  escape  )  .  append  (  '>'  )  ;  }  if  (  isEncapsulating  (  )  )  {  sb  .  append  (  '  '  )  ;  [ATTENTION]  sb  .  append  (     "Delimiter  =  <   "  )    .  append  (  delimiter  )    .  append  (  '>'  )    ;  }  if  (  isCommentingEnabled  (  )  )  {  sb  .  append  (  '  '  )  ;  sb  .  append  (     "CommentStart  =  <   "  )  .  append  (  commentStart  )  .  append  (  '>'  )  ;  }  if  (  isEmptyLinesIgnored  (  )  )  {  sb  .  append  (     "  EmptyLines:ignored   "  )  ;  }  if  (  isSurroundingSpacesIgnored  (  )  )  {  sb  .  append  (     "  SurroundingSpaces:ignored   "  )  ;  }  return  sb  .  toString  (  )  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVFormat.java^427^^^^^418^440^
[ADD]    sb    .    append    (       "Encapsulator=<   "    )        .    append    (    encapsulator    )        .    append    (    '>'    )    ;  	[BUGGY]  [NO-ERROR]    [METHOD]    toString  [TYPE]  String  [PARAMETER]  [CLASS]  CSVFormat    [TYPE]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  [TYPE]  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  [TYPE]  boolean  emptyLinesIgnored  false  surroundingSpacesIgnored  true  [TYPE]  String  CRLF  lineSeparator  [TYPE]  String[]  header  values  [TYPE]  StringBuilder  sb    [CONTEXT]    public  String  toString  (  )  {  StringBuilder  sb  =  new  StringBuilder  (  )  ;  sb  .  append  (     "Delimiter  =  <   "  )  .  append  (  delimiter  )  .  append  (  '>'  )  ;  if  (  isEscaping  (  )  )  {  sb  .  append  (  '  '  )  ;  sb  .  append  (     "Escape  =  <   "  )  .  append  (  escape  )  .  append  (  '>'  )  ;  }  if  (  isEncapsulating  (  )  )  {  sb  .  append  (  '  '  )  ;  [ATTENTION]  }  if  (  isCommentingEnabled  (  )  )  {  sb  .  append  (  '  '  )  ;  sb  .  append  (     "CommentStart  =  <   "  )  .  append  (  commentStart  )  .  append  (  '>'  )  ;  }  if  (  isEmptyLinesIgnored  (  )  )  {  sb  .  append  (     "  EmptyLines:ignored   "  )  ;  }  if  (  isSurroundingSpacesIgnored  (  )  )  {  sb  .  append  (     "  SurroundingSpaces:ignored   "  )  ;  }  return  sb  .  toString  (  )  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVFormat.java^427^^^^^418^440^
[REPLACE]    sb    .    append    (       "Encapsulator=<   "    )        .    append    (    encapsulator    )        .    append    (    '>'    )    ;  	[BUGGY]  sb  .  StringBuilder  (  )[CE]  '  ;  '  expected    [METHOD]    toString  [TYPE]  String  [PARAMETER]  [CLASS]  CSVFormat    [TYPE]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  [TYPE]  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  [TYPE]  boolean  emptyLinesIgnored  false  surroundingSpacesIgnored  true  [TYPE]  String  CRLF  lineSeparator  [TYPE]  String[]  header  values  [TYPE]  StringBuilder  sb    [CONTEXT]    public  String  toString  (  )  {  StringBuilder  sb  =  new  StringBuilder  (  )  ;  sb  .  append  (     "Delimiter  =  <   "  )  .  append  (  delimiter  )  .  append  (  '>'  )  ;  if  (  isEscaping  (  )  )  {  sb  .  append  (  '  '  )  ;  sb  .  append  (     "Escape  =  <   "  )  .  append  (  escape  )  .  append  (  '>'  )  ;  }  if  (  isEncapsulating  (  )  )  {  sb  .  append  (  '  '  )  ;  [ATTENTION]  sb  .  StringBuilder  (  )  }  if  (  isCommentingEnabled  (  )  )  {  sb  .  append  (  '  '  )  ;  sb  .  append  (     "CommentStart  =  <   "  )  .  append  (  commentStart  )  .  append  (  '>'  )  ;  }  if  (  isEmptyLinesIgnored  (  )  )  {  sb  .  append  (     "  EmptyLines:ignored   "  )  ;  }  if  (  isSurroundingSpacesIgnored  (  )  )  {  sb  .  append  (     "  SurroundingSpaces:ignored   "  )  ;  }  return  sb  .  toString  (  )  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVFormat.java^427^^^^^418^440^
[REPLACE]    if    (    isCommentingEnabled    (    )    )    {  	[BUGGY]  if  (  isLineBreak  (  escape  )  )  {[NO-ERROR]    [METHOD]    toString  [TYPE]  String  [PARAMETER]  [CLASS]  CSVFormat    [TYPE]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  [TYPE]  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  [TYPE]  boolean  emptyLinesIgnored  false  surroundingSpacesIgnored  true  [TYPE]  String  CRLF  lineSeparator  [TYPE]  String[]  header  values  [TYPE]  StringBuilder  sb    [CONTEXT]    public  String  toString  (  )  {  StringBuilder  sb  =  new  StringBuilder  (  )  ;  sb  .  append  (     "Delimiter  =  <   "  )  .  append  (  delimiter  )  .  append  (  '>'  )  ;  if  (  isEscaping  (  )  )  {  sb  .  append  (  '  '  )  ;  sb  .  append  (     "Escape  =  <   "  )  .  append  (  escape  )  .  append  (  '>'  )  ;  }  if  (  isEncapsulating  (  )  )  {  sb  .  append  (  '  '  )  ;  sb  .  append  (     "Encapsulator  =  <   "  )  .  append  (  encapsulator  )  .  append  (  '>'  )  ;  }  [ATTENTION]  if  (  isLineBreak  (  escape  )  )  {  sb  .  append  (  '  '  )  ;  sb  .  append  (     "CommentStart  =  <   "  )  .  append  (  commentStart  )  .  append  (  '>'  )  ;  }  if  (  isEmptyLinesIgnored  (  )  )  {  sb  .  append  (     "  EmptyLines:ignored   "  )  ;  }  if  (  isSurroundingSpacesIgnored  (  )  )  {  sb  .  append  (     "  SurroundingSpaces:ignored   "  )  ;  }  return  sb  .  toString  (  )  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVFormat.java^429^^^^^418^440^
[REPLACE]    sb    .    append    (    '    '    )    ;  	[BUGGY]  sb  .  append  (     "  EmptyLines:ignored   "  )  ;  [NO-ERROR]    [METHOD]    toString  [TYPE]  String  [PARAMETER]  [CLASS]  CSVFormat    [TYPE]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  [TYPE]  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  [TYPE]  boolean  emptyLinesIgnored  false  surroundingSpacesIgnored  true  [TYPE]  String  CRLF  lineSeparator  [TYPE]  String[]  header  values  [TYPE]  StringBuilder  sb    [CONTEXT]    public  String  toString  (  )  {  StringBuilder  sb  =  new  StringBuilder  (  )  ;  sb  .  append  (     "Delimiter  =  <   "  )  .  append  (  delimiter  )  .  append  (  '>'  )  ;  if  (  isEscaping  (  )  )  {  sb  .  append  (  '  '  )  ;  sb  .  append  (     "Escape  =  <   "  )  .  append  (  escape  )  .  append  (  '>'  )  ;  }  if  (  isEncapsulating  (  )  )  {  sb  .  append  (  '  '  )  ;  sb  .  append  (     "Encapsulator  =  <   "  )  .  append  (  encapsulator  )  .  append  (  '>'  )  ;  }  if  (  isCommentingEnabled  (  )  )  {  [ATTENTION]  sb  .  append  (     "  EmptyLines:ignored   "  )    ;  sb  .  append  (     "CommentStart  =  <   "  )  .  append  (  commentStart  )  .  append  (  '>'  )  ;  }  if  (  isEmptyLinesIgnored  (  )  )  {  sb  .  append  (     "  EmptyLines:ignored   "  )  ;  }  if  (  isSurroundingSpacesIgnored  (  )  )  {  sb  .  append  (     "  SurroundingSpaces:ignored   "  )  ;  }  return  sb  .  toString  (  )  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVFormat.java^430^^^^^418^440^
[REPLACE]    sb    .    append    (       "CommentStart=<   "    )        .    append    (    commentStart    )        .    append    (    '>'    )    ;  	[BUGGY]  sb  .  append  (     "Delimiter  =  <   "  )  .  append  (  delimiter  )  .  append  (  '>'  )  ;  [NO-ERROR]    [METHOD]    toString  [TYPE]  String  [PARAMETER]  [CLASS]  CSVFormat    [TYPE]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  [TYPE]  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  [TYPE]  boolean  emptyLinesIgnored  false  surroundingSpacesIgnored  true  [TYPE]  String  CRLF  lineSeparator  [TYPE]  String[]  header  values  [TYPE]  StringBuilder  sb    [CONTEXT]    public  String  toString  (  )  {  StringBuilder  sb  =  new  StringBuilder  (  )  ;  sb  .  append  (     "Delimiter  =  <   "  )  .  append  (  delimiter  )  .  append  (  '>'  )  ;  if  (  isEscaping  (  )  )  {  sb  .  append  (  '  '  )  ;  sb  .  append  (     "Escape  =  <   "  )  .  append  (  escape  )  .  append  (  '>'  )  ;  }  if  (  isEncapsulating  (  )  )  {  sb  .  append  (  '  '  )  ;  sb  .  append  (     "Encapsulator  =  <   "  )  .  append  (  encapsulator  )  .  append  (  '>'  )  ;  }  if  (  isCommentingEnabled  (  )  )  {  sb  .  append  (  '  '  )  ;  [ATTENTION]  sb  .  append  (     "Delimiter  =  <   "  )    .  append  (  delimiter  )    .  append  (  '>'  )    ;  }  if  (  isEmptyLinesIgnored  (  )  )  {  sb  .  append  (     "  EmptyLines:ignored   "  )  ;  }  if  (  isSurroundingSpacesIgnored  (  )  )  {  sb  .  append  (     "  SurroundingSpaces:ignored   "  )  ;  }  return  sb  .  toString  (  )  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVFormat.java^431^^^^^418^440^
[REPLACE]    if    (    isEmptyLinesIgnored    (    )    )    {  	[BUGGY]  if  (  isLineBreak  (  escape  )  )  {[NO-ERROR]    [METHOD]    toString  [TYPE]  String  [PARAMETER]  [CLASS]  CSVFormat    [TYPE]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  [TYPE]  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  [TYPE]  boolean  emptyLinesIgnored  false  surroundingSpacesIgnored  true  [TYPE]  String  CRLF  lineSeparator  [TYPE]  String[]  header  values  [TYPE]  StringBuilder  sb    [CONTEXT]    public  String  toString  (  )  {  StringBuilder  sb  =  new  StringBuilder  (  )  ;  sb  .  append  (     "Delimiter  =  <   "  )  .  append  (  delimiter  )  .  append  (  '>'  )  ;  if  (  isEscaping  (  )  )  {  sb  .  append  (  '  '  )  ;  sb  .  append  (     "Escape  =  <   "  )  .  append  (  escape  )  .  append  (  '>'  )  ;  }  if  (  isEncapsulating  (  )  )  {  sb  .  append  (  '  '  )  ;  sb  .  append  (     "Encapsulator  =  <   "  )  .  append  (  encapsulator  )  .  append  (  '>'  )  ;  }  if  (  isCommentingEnabled  (  )  )  {  sb  .  append  (  '  '  )  ;  sb  .  append  (     "CommentStart  =  <   "  )  .  append  (  commentStart  )  .  append  (  '>'  )  ;  }  [ATTENTION]  if  (  isLineBreak  (  escape  )  )  {  sb  .  append  (     "  EmptyLines:ignored   "  )  ;  }  if  (  isSurroundingSpacesIgnored  (  )  )  {  sb  .  append  (     "  SurroundingSpaces:ignored   "  )  ;  }  return  sb  .  toString  (  )  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVFormat.java^433^^^^^418^440^
[REPLACE]    sb    .    append    (       "    EmptyLines:ignored   "    )    ;  	[BUGGY]  sb  .  StringBuilder  (  )    ;  [CE]  cannot  find  symbol    [METHOD]    toString  [TYPE]  String  [PARAMETER]  [CLASS]  CSVFormat    [TYPE]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  [TYPE]  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  [TYPE]  boolean  emptyLinesIgnored  false  surroundingSpacesIgnored  true  [TYPE]  String  CRLF  lineSeparator  [TYPE]  String[]  header  values  [TYPE]  StringBuilder  sb    [CONTEXT]    public  String  toString  (  )  {  StringBuilder  sb  =  new  StringBuilder  (  )  ;  sb  .  append  (     "Delimiter  =  <   "  )  .  append  (  delimiter  )  .  append  (  '>'  )  ;  if  (  isEscaping  (  )  )  {  sb  .  append  (  '  '  )  ;  sb  .  append  (     "Escape  =  <   "  )  .  append  (  escape  )  .  append  (  '>'  )  ;  }  if  (  isEncapsulating  (  )  )  {  sb  .  append  (  '  '  )  ;  sb  .  append  (     "Encapsulator  =  <   "  )  .  append  (  encapsulator  )  .  append  (  '>'  )  ;  }  if  (  isCommentingEnabled  (  )  )  {  sb  .  append  (  '  '  )  ;  sb  .  append  (     "CommentStart  =  <   "  )  .  append  (  commentStart  )  .  append  (  '>'  )  ;  }  if  (  isEmptyLinesIgnored  (  )  )  {  [ATTENTION]  sb  .  StringBuilder  (  )  ;  }  if  (  isSurroundingSpacesIgnored  (  )  )  {  sb  .  append  (     "  SurroundingSpaces:ignored   "  )  ;  }  return  sb  .  toString  (  )  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVFormat.java^434^^^^^418^440^
[REPLACE]    if    (    isSurroundingSpacesIgnored    (    )    )    {  	[BUGGY]  if  (  isLineBreak  (  escape  )  )  {[NO-ERROR]    [METHOD]    toString  [TYPE]  String  [PARAMETER]  [CLASS]  CSVFormat    [TYPE]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  [TYPE]  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  [TYPE]  boolean  emptyLinesIgnored  false  surroundingSpacesIgnored  true  [TYPE]  String  CRLF  lineSeparator  [TYPE]  String[]  header  values  [TYPE]  StringBuilder  sb    [CONTEXT]    public  String  toString  (  )  {  StringBuilder  sb  =  new  StringBuilder  (  )  ;  sb  .  append  (     "Delimiter  =  <   "  )  .  append  (  delimiter  )  .  append  (  '>'  )  ;  if  (  isEscaping  (  )  )  {  sb  .  append  (  '  '  )  ;  sb  .  append  (     "Escape  =  <   "  )  .  append  (  escape  )  .  append  (  '>'  )  ;  }  if  (  isEncapsulating  (  )  )  {  sb  .  append  (  '  '  )  ;  sb  .  append  (     "Encapsulator  =  <   "  )  .  append  (  encapsulator  )  .  append  (  '>'  )  ;  }  if  (  isCommentingEnabled  (  )  )  {  sb  .  append  (  '  '  )  ;  sb  .  append  (     "CommentStart  =  <   "  )  .  append  (  commentStart  )  .  append  (  '>'  )  ;  }  if  (  isEmptyLinesIgnored  (  )  )  {  sb  .  append  (     "  EmptyLines:ignored   "  )  ;  }  [ATTENTION]  if  (  isLineBreak  (  escape  )  )  {  sb  .  append  (     "  SurroundingSpaces:ignored   "  )  ;  }  return  sb  .  toString  (  )  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVFormat.java^436^^^^^418^440^
[ADD]    if    (    isSurroundingSpacesIgnored    (    )    )    {    sb    .    append    (       "    SurroundingSpaces:ignored   "    )    ;    }  	[BUGGY]  [NO-ERROR]    [METHOD]    toString  [TYPE]  String  [PARAMETER]  [CLASS]  CSVFormat    [TYPE]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  [TYPE]  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  [TYPE]  boolean  emptyLinesIgnored  false  surroundingSpacesIgnored  true  [TYPE]  String  CRLF  lineSeparator  [TYPE]  String[]  header  values  [TYPE]  StringBuilder  sb    [CONTEXT]    public  String  toString  (  )  {  StringBuilder  sb  =  new  StringBuilder  (  )  ;  sb  .  append  (     "Delimiter  =  <   "  )  .  append  (  delimiter  )  .  append  (  '>'  )  ;  if  (  isEscaping  (  )  )  {  sb  .  append  (  '  '  )  ;  sb  .  append  (     "Escape  =  <   "  )  .  append  (  escape  )  .  append  (  '>'  )  ;  }  if  (  isEncapsulating  (  )  )  {  sb  .  append  (  '  '  )  ;  sb  .  append  (     "Encapsulator  =  <   "  )  .  append  (  encapsulator  )  .  append  (  '>'  )  ;  }  if  (  isCommentingEnabled  (  )  )  {  sb  .  append  (  '  '  )  ;  sb  .  append  (     "CommentStart  =  <   "  )  .  append  (  commentStart  )  .  append  (  '>'  )  ;  }  if  (  isEmptyLinesIgnored  (  )  )  {  sb  .  append  (     "  EmptyLines:ignored   "  )  ;  }  [ATTENTION]    return  sb  .  toString  (  )  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVFormat.java^436^437^438^^^418^440^
[REPLACE]    sb    .    append    (       "    SurroundingSpaces:ignored   "    )    ;  	[BUGGY]  sb  .  StringBuilder  (  )    ;  [CE]  cannot  find  symbol    [METHOD]    toString  [TYPE]  String  [PARAMETER]  [CLASS]  CSVFormat    [TYPE]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  [TYPE]  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  [TYPE]  boolean  emptyLinesIgnored  false  surroundingSpacesIgnored  true  [TYPE]  String  CRLF  lineSeparator  [TYPE]  String[]  header  values  [TYPE]  StringBuilder  sb    [CONTEXT]    public  String  toString  (  )  {  StringBuilder  sb  =  new  StringBuilder  (  )  ;  sb  .  append  (     "Delimiter  =  <   "  )  .  append  (  delimiter  )  .  append  (  '>'  )  ;  if  (  isEscaping  (  )  )  {  sb  .  append  (  '  '  )  ;  sb  .  append  (     "Escape  =  <   "  )  .  append  (  escape  )  .  append  (  '>'  )  ;  }  if  (  isEncapsulating  (  )  )  {  sb  .  append  (  '  '  )  ;  sb  .  append  (     "Encapsulator  =  <   "  )  .  append  (  encapsulator  )  .  append  (  '>'  )  ;  }  if  (  isCommentingEnabled  (  )  )  {  sb  .  append  (  '  '  )  ;  sb  .  append  (     "CommentStart  =  <   "  )  .  append  (  commentStart  )  .  append  (  '>'  )  ;  }  if  (  isEmptyLinesIgnored  (  )  )  {  sb  .  append  (     "  EmptyLines:ignored   "  )  ;  }  if  (  isSurroundingSpacesIgnored  (  )  )  {  [ATTENTION]  sb  .  StringBuilder  (  )  ;  }  return  sb  .  toString  (  )  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVFormat.java^437^^^^^418^440^
[ADD]    sb    .    append    (       "    SurroundingSpaces:ignored   "    )    ;  	[BUGGY]  [NO-ERROR]    [METHOD]    toString  [TYPE]  String  [PARAMETER]  [CLASS]  CSVFormat    [TYPE]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  [TYPE]  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  [TYPE]  boolean  emptyLinesIgnored  false  surroundingSpacesIgnored  true  [TYPE]  String  CRLF  lineSeparator  [TYPE]  String[]  header  values  [TYPE]  StringBuilder  sb    [CONTEXT]    public  String  toString  (  )  {  StringBuilder  sb  =  new  StringBuilder  (  )  ;  sb  .  append  (     "Delimiter  =  <   "  )  .  append  (  delimiter  )  .  append  (  '>'  )  ;  if  (  isEscaping  (  )  )  {  sb  .  append  (  '  '  )  ;  sb  .  append  (     "Escape  =  <   "  )  .  append  (  escape  )  .  append  (  '>'  )  ;  }  if  (  isEncapsulating  (  )  )  {  sb  .  append  (  '  '  )  ;  sb  .  append  (     "Encapsulator  =  <   "  )  .  append  (  encapsulator  )  .  append  (  '>'  )  ;  }  if  (  isCommentingEnabled  (  )  )  {  sb  .  append  (  '  '  )  ;  sb  .  append  (     "CommentStart  =  <   "  )  .  append  (  commentStart  )  .  append  (  '>'  )  ;  }  if  (  isEmptyLinesIgnored  (  )  )  {  sb  .  append  (     "  EmptyLines:ignored   "  )  ;  }  if  (  isSurroundingSpacesIgnored  (  )  )  {  [ATTENTION]  }  return  sb  .  toString  (  )  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVFormat.java^437^^^^^418^440^
[REPLACE]    return    sb    .    toString    (    )    ;  	[BUGGY]  return  sb  .  StringBuilder  (  )  ;  [CE]  cannot  find  symbol    [METHOD]    toString  [TYPE]  String  [PARAMETER]  [CLASS]  CSVFormat    [TYPE]  char  DISABLED  c  commentStart  delimiter  encapsulator  escape  [TYPE]  CSVFormat  DEFAULT  EXCEL  MYSQL  PRISTINE  RFC4180  TDF  [TYPE]  boolean  emptyLinesIgnored  false  surroundingSpacesIgnored  true  [TYPE]  String  CRLF  lineSeparator  [TYPE]  String[]  header  values  [TYPE]  StringBuilder  sb    [CONTEXT]    public  String  toString  (  )  {  StringBuilder  sb  =  new  StringBuilder  (  )  ;  sb  .  append  (     "Delimiter  =  <   "  )  .  append  (  delimiter  )  .  append  (  '>'  )  ;  if  (  isEscaping  (  )  )  {  sb  .  append  (  '  '  )  ;  sb  .  append  (     "Escape  =  <   "  )  .  append  (  escape  )  .  append  (  '>'  )  ;  }  if  (  isEncapsulating  (  )  )  {  sb  .  append  (  '  '  )  ;  sb  .  append  (     "Encapsulator  =  <   "  )  .  append  (  encapsulator  )  .  append  (  '>'  )  ;  }  if  (  isCommentingEnabled  (  )  )  {  sb  .  append  (  '  '  )  ;  sb  .  append  (     "CommentStart  =  <   "  )  .  append  (  commentStart  )  .  append  (  '>'  )  ;  }  if  (  isEmptyLinesIgnored  (  )  )  {  sb  .  append  (     "  EmptyLines:ignored   "  )  ;  }  if  (  isSurroundingSpacesIgnored  (  )  )  {  sb  .  append  (     "  SurroundingSpaces:ignored   "  )  ;  }  [ATTENTION]  return  sb  .  StringBuilder  (  )    ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVFormat.java^439^^^^^418^440^
[REPLACE]    private    static    final    int    INITIAL_TOKEN_LENGTH    =    50;  	[BUGGY]  private  static  final  int  INITIAL_TOKEN_LENGTH    =  null  ;  [CE]  incompatible  types    [CONTEXT]        [CLASS]  Token  Type    	None^31^^^^^^^
[REPLACE]    Token    .    Type    type    =    INVALID;  	[BUGGY]  Token  .  Type  type  ;  [FE]    AssertionFailedError    Token  type  expected:<TOKEN>  but  was:<null>  assertTokenEquals(TOKEN  ,     "abc   "  ,  parser.nextToken(new  Token()))      [CONTEXT]        [CLASS]  Token  Type    	None^48^^^^^^^
[REPLACE]    StringBuilder    content    =    new    StringBuilder    (    INITIAL_TOKEN_LENGTH    )    ;  	[BUGGY]  StringBuilder  content  ;  [FE]    null  assertTokenEquals(TOKEN  ,     "abc   "  ,  parser.nextToken(new  Token()))      [CONTEXT]        [CLASS]  Token  Type    	None^51^^^^^^^
[REPLACE]    content    .    setLength    (    0    )    ;  	[BUGGY]  content  .  setLength  (  4  )  ;  [FE]    AssertionFailedError    Token  content  expected:<[]>  but  was:<[  assertTokenEquals(TOKEN  ,     "1   "  ,  parser.nextToken(new  Token()))      [METHOD]    reset  [TYPE]  Token  [PARAMETER]  [CLASS]  Token  Type    [TYPE]  Type  EOF  EORECORD  INVALID  TOKEN  type  [TYPE]  boolean  false  isReady  true  [TYPE]  StringBuilder  content  [TYPE]  int  INITIAL_TOKEN_LENGTH    [CONTEXT]    Token  reset  (  )  {  [ATTENTION]  content  .  setLength  (  4  )    ;  type  =  INVALID  ;  isReady  =  false  ;  return  this  ;  }    	None^57^^^^^56^61^
[REPLACE]    type    =    INVALID;  	[BUGGY]  type    =    type  ;  [FE]    null  assertEquals(CSVFormat.DISABLED  ,  format.getCommentStart())      [METHOD]    reset  [TYPE]  Token  [PARAMETER]  [CLASS]  Token  Type    [TYPE]  Type  EOF  EORECORD  INVALID  TOKEN  type  [TYPE]  boolean  false  isReady  true  [TYPE]  StringBuilder  content  [TYPE]  int  INITIAL_TOKEN_LENGTH    [CONTEXT]    Token  reset  (  )  {  content  .  setLength  (  0  )  ;  [ATTENTION]  type  =  type  ;  isReady  =  false  ;  return  this  ;  }    	None^58^^^^^56^61^
[ADD]    type    =    INVALID;  	[BUGGY]  [FE]    null  assertEquals(CSVFormat.DISABLED  ,  format.getCommentStart())      [METHOD]    reset  [TYPE]  Token  [PARAMETER]  [CLASS]  Token  Type    [TYPE]  Type  EOF  EORECORD  INVALID  TOKEN  type  [TYPE]  boolean  false  isReady  true  [TYPE]  StringBuilder  content  [TYPE]  int  INITIAL_TOKEN_LENGTH    [CONTEXT]    Token  reset  (  )  {  content  .  setLength  (  0  )  ;  [ATTENTION]  isReady  =  false  ;  return  this  ;  }    	None^58^^^^^56^61^
[REPLACE]    isReady    =    false;  	[BUGGY]  isReady  =  true  ;  [FE]  [METHOD]    reset  [TYPE]  Token  [PARAMETER]  [CLASS]  Token  Type    [TYPE]  Type  EOF  EORECORD  INVALID  TOKEN  type  [TYPE]  boolean  false  isReady  true  [TYPE]  StringBuilder  content  [TYPE]  int  INITIAL_TOKEN_LENGTH    [CONTEXT]    Token  reset  (  )  {  content  .  setLength  (  0  )  ;  type  =  INVALID  ;  [ATTENTION]  isReady  =  true  ;  return  this  ;  }    	None^59^^^^^56^61^
[REPLACE]    return    this;  	[BUGGY]  return  null  ;  [FE]    null  assertTokenEquals(TOKEN  ,     "1   "  ,  parser.nextToken(new  Token()))      [METHOD]    reset  [TYPE]  Token  [PARAMETER]  [CLASS]  Token  Type    [TYPE]  Type  EOF  EORECORD  INVALID  TOKEN  type  [TYPE]  boolean  false  isReady  true  [TYPE]  StringBuilder  content  [TYPE]  int  INITIAL_TOKEN_LENGTH    [CONTEXT]    Token  reset  (  )  {  content  .  setLength  (  0  )  ;  type  =  INVALID  ;  isReady  =  false  ;  [ATTENTION]  return  null  ;  }    	None^60^^^^^56^61^
[REPLACE]    private    static    final    String[]    EMPTY_STRING_ARRAY    =    new    String[0];  	[BUGGY]  private  static  final  String[]  EMPTY_STRING_ARRAY    =  null  ;  [FE]    null  assertTokenEquals(TOKEN  ,     "1   "  ,  parser.nextToken(new  Token()))      [CONTEXT]        [CLASS]  CSVRecord    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVRecord.java^30^^^^^^^
[REPLACE]    this    .    values    =    values    !=    null    ?    values    :    EMPTY_STRING_ARRAY;  	[BUGGY]  this  .  values    =    values  ;  [FE]    null  assertTokenEquals(TOKEN  ,     "1   "  ,  parser.nextToken(new  Token()))      [METHOD]    <init>  [TYPE]  Map)  [PARAMETER]  String[]  values  Integer>  mapping  [CLASS]  CSVRecord    [TYPE]  Map  mapping  [TYPE]  String[]  EMPTY_STRING_ARRAY  values  [TYPE]  boolean  false  true    [CONTEXT]    CSVRecord  (  String[]  values  ,  Map<String  ,  Integer>  mapping  )  {  [ATTENTION]  this  .  values  =  values  ;  this  .  mapping  =  mapping  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVRecord.java^39^^^^^38^41^
[REPLACE]    this    .    mapping    =    mapping;  	[BUGGY]  this  .  mapping  =    0  ;  [CE]  incompatible  types    [METHOD]    <init>  [TYPE]  Map)  [PARAMETER]  String[]  values  Integer>  mapping  [CLASS]  CSVRecord    [TYPE]  Map  mapping  [TYPE]  String[]  EMPTY_STRING_ARRAY  values  [TYPE]  boolean  false  true    [CONTEXT]    CSVRecord  (  String[]  values  ,  Map<String  ,  Integer>  mapping  )  {  this  .  values  =  values  !  =  null  ?  values  :  EMPTY_STRING_ARRAY  ;  [ATTENTION]  this  .  mapping  =  0  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVRecord.java^40^^^^^38^41^
[ADD]    this    .    mapping    =    mapping;  	[BUGGY]  [CE]  variable  mapping  might  not  have  been  initialized    [METHOD]    <init>  [TYPE]  Map)  [PARAMETER]  String[]  values  Integer>  mapping  [CLASS]  CSVRecord    [TYPE]  Map  mapping  [TYPE]  String[]  EMPTY_STRING_ARRAY  values  [TYPE]  boolean  false  true    [CONTEXT]    CSVRecord  (  String[]  values  ,  Map<String  ,  Integer>  mapping  )  {  this  .  values  =  values  !  =  null  ?  values  :  EMPTY_STRING_ARRAY  ;  [ATTENTION]  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVRecord.java^40^^^^^38^41^
[REPLACE]    return    values[i];  	[BUGGY]  return  values  ;  [CE]  incompatible  types    [METHOD]    get  [TYPE]  String  [PARAMETER]  int  i  [CLASS]  CSVRecord    [TYPE]  String[]  EMPTY_STRING_ARRAY  values  [TYPE]  boolean  false  true  [TYPE]  Map  mapping  [TYPE]  int  i    [CONTEXT]    public  String  get  (  int  i  )  {  [ATTENTION]  return  values  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVRecord.java^49^^^^^48^50^
[REPLACE]    if    (    mapping    ==    null    )    {  	[BUGGY]  if  (  mapping  !  =  false  )  {[CE]  incomparable  types:  Map<String  ,  Integer>  and  boolean    [METHOD]    get  [TYPE]  String  [PARAMETER]  String  name  [CLASS]  CSVRecord    [TYPE]  Integer  index  [TYPE]  String[]  EMPTY_STRING_ARRAY  values  [TYPE]  String  name  [TYPE]  boolean  false  true  [TYPE]  Map  mapping    [CONTEXT]    public  String  get  (  String  name  )  {  [ATTENTION]  if  (  mapping  !  =  false  )  {  throw  new  IllegalStateException  (     "No  header  was  specified  ,  the  record  values  can't  be  accessed  by  name   "  )  ;  }  Integer  index  =  mapping  .  get  (  name  )  ;    return  index  !  =  null  ?  values[index  .  intValue  (  )  ]  :  null  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVRecord.java^60^^^^^59^67^
[REPLACE]    throw    new    IllegalStateException    (   "       ")    ;  	[BUGGY]  return  ;  [CE]  missing  return  value    [METHOD]    get  [TYPE]  String  [PARAMETER]  String  name  [CLASS]  CSVRecord    [TYPE]  Integer  index  [TYPE]  String[]  EMPTY_STRING_ARRAY  values  [TYPE]  String  name  [TYPE]  boolean  false  true  [TYPE]  Map  mapping    [CONTEXT]    public  String  get  (  String  name  )  {  if  (  mapping  =  =  null  )  {  [ATTENTION]  return  ;  }  Integer  index  =  mapping  .  get  (  name  )  ;    return  index  !  =  null  ?  values[index  .  intValue  (  )  ]  :  null  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVRecord.java^61^^^^^59^67^
[REPLACE]    Integer    index    =    mapping    .    get    (    name    )    ;  	[BUGGY]  Integer  index  =  mapping  .  CSVRecord  (  values  ,  null  )    ;  [CE]  cannot  find  symbol    [METHOD]    get  [TYPE]  String  [PARAMETER]  String  name  [CLASS]  CSVRecord    [TYPE]  Integer  index  [TYPE]  String[]  EMPTY_STRING_ARRAY  values  [TYPE]  String  name  [TYPE]  boolean  false  true  [TYPE]  Map  mapping    [CONTEXT]    public  String  get  (  String  name  )  {  if  (  mapping  =  =  null  )  {  throw  new  IllegalStateException  (     "No  header  was  specified  ,  the  record  values  can't  be  accessed  by  name   "  )  ;  }  [ATTENTION]  Integer  index  =  mapping  .  CSVRecord  (  values  ,  null  )  ;    return  index  !  =  null  ?  values[index  .  intValue  (  )  ]  :  null  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVRecord.java^64^^^^^59^67^
[REPLACE]    return    index    !=    null    ?    values[index    .    intValue    (    )    ]    :    null;  	[BUGGY]  return  index  ;  [CE]  incompatible  types    [METHOD]    get  [TYPE]  String  [PARAMETER]  String  name  [CLASS]  CSVRecord    [TYPE]  Integer  index  [TYPE]  String[]  EMPTY_STRING_ARRAY  values  [TYPE]  String  name  [TYPE]  boolean  false  true  [TYPE]  Map  mapping    [CONTEXT]    public  String  get  (  String  name  )  {  if  (  mapping  =  =  null  )  {  throw  new  IllegalStateException  (     "No  header  was  specified  ,  the  record  values  can't  be  accessed  by  name   "  )  ;  }  Integer  index  =  mapping  .  get  (  name  )  ;    [ATTENTION]  return  index  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVRecord.java^66^^^^^59^67^
[REPLACE]    return    Arrays    .    asList    (    values    )        .    iterator    (    )    ;  	[BUGGY]  return  values[i]  ;  [CE]  cannot  find  symbol  i    [METHOD]    iterator  [TYPE]  Iterator  [PARAMETER]  [CLASS]  CSVRecord    [TYPE]  Map  mapping  [TYPE]  String[]  EMPTY_STRING_ARRAY  values  [TYPE]  boolean  false  true    [CONTEXT]    public  Iterator<String>  iterator  (  )  {  [ATTENTION]  return  values[i]  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVRecord.java^70^^^^^69^71^
[REPLACE]    return    values;  	[BUGGY]  return  values[i]  ;  [CE]  cannot  find  symbol  i    [METHOD]    values  [TYPE]  String[]  [PARAMETER]  [CLASS]  CSVRecord    [TYPE]  Map  mapping  [TYPE]  String[]  EMPTY_STRING_ARRAY  values  [TYPE]  boolean  false  true    [CONTEXT]    String[]  values  (  )  {  [ATTENTION]  return  values[i]  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVRecord.java^74^^^^^73^75^
[REPLACE]    return    values    .    length;  	[BUGGY]  return  values  ;  [CE]  incompatible  types    [METHOD]    size  [TYPE]  int  [PARAMETER]  [CLASS]  CSVRecord    [TYPE]  Map  mapping  [TYPE]  String[]  EMPTY_STRING_ARRAY  values  [TYPE]  boolean  false  true    [CONTEXT]    public  int  size  (  )  {  [ATTENTION]  return  values  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVRecord.java^81^^^^^80^82^
[REPLACE]    return    Arrays    .    toString    (    values    )    ;  	[BUGGY]  return  Arrays  .  asList  (  true  )    ;  [CE]  incompatible  types    [METHOD]    toString  [TYPE]  String  [PARAMETER]  [CLASS]  CSVRecord    [TYPE]  Map  mapping  [TYPE]  String[]  EMPTY_STRING_ARRAY  values  [TYPE]  boolean  false  true    [CONTEXT]    public  String  toString  (  )  {  [ATTENTION]  return  Arrays  .  asList  (  true  )  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/CSVRecord.java^86^^^^^85^87^
[REPLACE]    private    final    char    delimiter;  	[BUGGY]  private  String  delimiter  ;  [CE]  incompatible  types    [CONTEXT]        [CLASS]  Lexer    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/Lexer.java^32^^^^^^^
[REPLACE]    private    final    char    escape;  	[BUGGY]  private  final  String  escape  ;  [CE]  incompatible  types    [CONTEXT]        [CLASS]  Lexer    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/Lexer.java^33^^^^^^^
[REPLACE]    private    final    char    encapsulator;  	[BUGGY]  private  String  encapsulator  ;  [CE]  incompatible  types    [CONTEXT]        [CLASS]  Lexer    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/Lexer.java^34^^^^^^^
[REPLACE]    final    boolean    surroundingSpacesIgnored;  	[BUGGY]  boolean  surroundingSpacesIgnored  ;  [FE]    null  assertTokenEquals(TOKEN  ,     "1   "  ,  parser.nextToken(new  Token()))      [CONTEXT]        [CLASS]  Lexer    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/Lexer.java^37^^^^^^^
[REPLACE]    final    CSVFormat    format;  	[BUGGY]  CSVFormat  format  ;  [FE]    null  assertTokenEquals(TOKEN  ,     "1   "  ,  parser.nextToken(new  Token()))      [CONTEXT]        [CLASS]  Lexer    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/Lexer.java^40^^^^^^^
[REPLACE]    this    .    format    =    format;  	[BUGGY]  this  .  format  =    null  ;  [FE]    null  assertTokenEquals(TOKEN  ,     "abc   "  ,  parser.nextToken(new  Token()))      [METHOD]    <init>  [TYPE]  ExtendedBufferedReader)  [PARAMETER]  CSVFormat  format  ExtendedBufferedReader  in  [CLASS]  Lexer    [TYPE]  char  commmentStart  delimiter  encapsulator  escape  [TYPE]  ExtendedBufferedReader  in  [TYPE]  CSVFormat  format  [TYPE]  boolean  emptyLinesIgnored  false  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored  true    [CONTEXT]    Lexer  (  CSVFormat  format  ,  ExtendedBufferedReader  in  )  {  [ATTENTION]  this  .  format  =  null  ;  this  .  in  =  in  ;  this  .  isEncapsulating  =  format  .  isEncapsulating  (  )  ;  this  .  isEscaping  =  format  .  isEscaping  (  )  ;  this  .  isCommentEnabled  =  format  .  isCommentingEnabled  (  )  ;  this  .  delimiter  =  format  .  getDelimiter  (  )  ;  this  .  escape  =  format  .  getEscape  (  )  ;  this  .  encapsulator  =  format  .  getEncapsulator  (  )  ;  this  .  commmentStart  =  format  .  getCommentStart  (  )  ;  this  .  surroundingSpacesIgnored  =  format  .  isSurroundingSpacesIgnored  (  )  ;  this  .  emptyLinesIgnored  =  format  .  isEmptyLinesIgnored  (  )  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/Lexer.java^46^^^^^45^57^
[REPLACE]    this    .    in    =    in;  	[BUGGY]  this  .  in  =    null  ;  [FE]    null  assertTokenEquals(TOKEN  ,     "abc   "  ,  parser.nextToken(new  Token()))      [METHOD]    <init>  [TYPE]  ExtendedBufferedReader)  [PARAMETER]  CSVFormat  format  ExtendedBufferedReader  in  [CLASS]  Lexer    [TYPE]  char  commmentStart  delimiter  encapsulator  escape  [TYPE]  ExtendedBufferedReader  in  [TYPE]  CSVFormat  format  [TYPE]  boolean  emptyLinesIgnored  false  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored  true    [CONTEXT]    Lexer  (  CSVFormat  format  ,  ExtendedBufferedReader  in  )  {  this  .  format  =  format  ;  [ATTENTION]  this  .  in  =  null  ;  this  .  isEncapsulating  =  format  .  isEncapsulating  (  )  ;  this  .  isEscaping  =  format  .  isEscaping  (  )  ;  this  .  isCommentEnabled  =  format  .  isCommentingEnabled  (  )  ;  this  .  delimiter  =  format  .  getDelimiter  (  )  ;  this  .  escape  =  format  .  getEscape  (  )  ;  this  .  encapsulator  =  format  .  getEncapsulator  (  )  ;  this  .  commmentStart  =  format  .  getCommentStart  (  )  ;  this  .  surroundingSpacesIgnored  =  format  .  isSurroundingSpacesIgnored  (  )  ;  this  .  emptyLinesIgnored  =  format  .  isEmptyLinesIgnored  (  )  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/Lexer.java^47^^^^^45^57^
[REPLACE]    this    .    isEncapsulating    =    format    .    isEncapsulating    (    )    ;  	[BUGGY]  this  .  encapsulator  =  format  .  getEncapsulator  (  )  ;    ;  [CE]  variable  encapsulator  might  already  have  been  assigned    [METHOD]    <init>  [TYPE]  ExtendedBufferedReader)  [PARAMETER]  CSVFormat  format  ExtendedBufferedReader  in  [CLASS]  Lexer    [TYPE]  char  commmentStart  delimiter  encapsulator  escape  [TYPE]  ExtendedBufferedReader  in  [TYPE]  CSVFormat  format  [TYPE]  boolean  emptyLinesIgnored  false  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored  true    [CONTEXT]    Lexer  (  CSVFormat  format  ,  ExtendedBufferedReader  in  )  {  this  .  format  =  format  ;  this  .  in  =  in  ;  [ATTENTION]  this  .  encapsulator  =  format  .  getEncapsulator  (  )    ;    ;  this  .  isEscaping  =  format  .  isEscaping  (  )  ;  this  .  isCommentEnabled  =  format  .  isCommentingEnabled  (  )  ;  this  .  delimiter  =  format  .  getDelimiter  (  )  ;  this  .  escape  =  format  .  getEscape  (  )  ;  this  .  encapsulator  =  format  .  getEncapsulator  (  )  ;  this  .  commmentStart  =  format  .  getCommentStart  (  )  ;  this  .  surroundingSpacesIgnored  =  format  .  isSurroundingSpacesIgnored  (  )  ;  this  .  emptyLinesIgnored  =  format  .  isEmptyLinesIgnored  (  )  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/Lexer.java^48^^^^^45^57^
[REPLACE]    this    .    isEscaping    =    format    .    isEscaping    (    )    ;  	[BUGGY]  this  .  escape  =  format  .  getEscape  (  )  ;    ;  [CE]  variable  escape  might  already  have  been  assigned    [METHOD]    <init>  [TYPE]  ExtendedBufferedReader)  [PARAMETER]  CSVFormat  format  ExtendedBufferedReader  in  [CLASS]  Lexer    [TYPE]  char  commmentStart  delimiter  encapsulator  escape  [TYPE]  ExtendedBufferedReader  in  [TYPE]  CSVFormat  format  [TYPE]  boolean  emptyLinesIgnored  false  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored  true    [CONTEXT]    Lexer  (  CSVFormat  format  ,  ExtendedBufferedReader  in  )  {  this  .  format  =  format  ;  this  .  in  =  in  ;  this  .  isEncapsulating  =  format  .  isEncapsulating  (  )  ;  [ATTENTION]  this  .  escape  =  format  .  getEscape  (  )    ;    ;  this  .  isCommentEnabled  =  format  .  isCommentingEnabled  (  )  ;  this  .  delimiter  =  format  .  getDelimiter  (  )  ;  this  .  escape  =  format  .  getEscape  (  )  ;  this  .  encapsulator  =  format  .  getEncapsulator  (  )  ;  this  .  commmentStart  =  format  .  getCommentStart  (  )  ;  this  .  surroundingSpacesIgnored  =  format  .  isSurroundingSpacesIgnored  (  )  ;  this  .  emptyLinesIgnored  =  format  .  isEmptyLinesIgnored  (  )  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/Lexer.java^49^^^^^45^57^
[ADD]    this    .    isEscaping    =    format    .    isEscaping    (    )    ;    this    .    isCommentEnabled    =    format    .    isCommentingEnabled    (    )    ;    this    .    delimiter    =    format    .    getDelimiter    (    )    ;    this    .    escape    =    format    .    getEscape    (    )    ;    this    .    encapsulator    =    format    .    getEncapsulator    (    )    ;  	[BUGGY]  [CE]  variable  isEscaping  might  not  have  been  initialized    [METHOD]    <init>  [TYPE]  ExtendedBufferedReader)  [PARAMETER]  CSVFormat  format  ExtendedBufferedReader  in  [CLASS]  Lexer    [TYPE]  char  commmentStart  delimiter  encapsulator  escape  [TYPE]  ExtendedBufferedReader  in  [TYPE]  CSVFormat  format  [TYPE]  boolean  emptyLinesIgnored  false  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored  true    [CONTEXT]    Lexer  (  CSVFormat  format  ,  ExtendedBufferedReader  in  )  {  this  .  format  =  format  ;  this  .  in  =  in  ;  this  .  isEncapsulating  =  format  .  isEncapsulating  (  )  ;  [ATTENTION]      this  .  commmentStart  =  format  .  getCommentStart  (  )  ;  this  .  surroundingSpacesIgnored  =  format  .  isSurroundingSpacesIgnored  (  )  ;  this  .  emptyLinesIgnored  =  format  .  isEmptyLinesIgnored  (  )  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/Lexer.java^49^50^51^52^53^45^57^
[REPLACE]    this    .    isCommentEnabled    =    format    .    isCommentingEnabled    (    )    ;  	[BUGGY]  this  .  isCommentEnabled  =    null  .  isCommentingEnabled  (  )  ;  [CE]  <null>  cannot  be  dereferenced    [METHOD]    <init>  [TYPE]  ExtendedBufferedReader)  [PARAMETER]  CSVFormat  format  ExtendedBufferedReader  in  [CLASS]  Lexer    [TYPE]  char  commmentStart  delimiter  encapsulator  escape  [TYPE]  ExtendedBufferedReader  in  [TYPE]  CSVFormat  format  [TYPE]  boolean  emptyLinesIgnored  false  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored  true    [CONTEXT]    Lexer  (  CSVFormat  format  ,  ExtendedBufferedReader  in  )  {  this  .  format  =  format  ;  this  .  in  =  in  ;  this  .  isEncapsulating  =  format  .  isEncapsulating  (  )  ;  this  .  isEscaping  =  format  .  isEscaping  (  )  ;  [ATTENTION]  this  .  isCommentEnabled  =  null  .  isCommentingEnabled  (  )    ;  this  .  delimiter  =  format  .  getDelimiter  (  )  ;  this  .  escape  =  format  .  getEscape  (  )  ;  this  .  encapsulator  =  format  .  getEncapsulator  (  )  ;  this  .  commmentStart  =  format  .  getCommentStart  (  )  ;  this  .  surroundingSpacesIgnored  =  format  .  isSurroundingSpacesIgnored  (  )  ;  this  .  emptyLinesIgnored  =  format  .  isEmptyLinesIgnored  (  )  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/Lexer.java^50^^^^^45^57^
[REPLACE]    this    .    delimiter    =    format    .    getDelimiter    (    )    ;  	[BUGGY]  this  .  delimiter  =    null  .  getDelimiter  (  )  ;  [CE]  <null>  cannot  be  dereferenced    [METHOD]    <init>  [TYPE]  ExtendedBufferedReader)  [PARAMETER]  CSVFormat  format  ExtendedBufferedReader  in  [CLASS]  Lexer    [TYPE]  char  commmentStart  delimiter  encapsulator  escape  [TYPE]  ExtendedBufferedReader  in  [TYPE]  CSVFormat  format  [TYPE]  boolean  emptyLinesIgnored  false  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored  true    [CONTEXT]    Lexer  (  CSVFormat  format  ,  ExtendedBufferedReader  in  )  {  this  .  format  =  format  ;  this  .  in  =  in  ;  this  .  isEncapsulating  =  format  .  isEncapsulating  (  )  ;  this  .  isEscaping  =  format  .  isEscaping  (  )  ;  this  .  isCommentEnabled  =  format  .  isCommentingEnabled  (  )  ;  [ATTENTION]  this  .  delimiter  =  null  .  getDelimiter  (  )    ;  this  .  escape  =  format  .  getEscape  (  )  ;  this  .  encapsulator  =  format  .  getEncapsulator  (  )  ;  this  .  commmentStart  =  format  .  getCommentStart  (  )  ;  this  .  surroundingSpacesIgnored  =  format  .  isSurroundingSpacesIgnored  (  )  ;  this  .  emptyLinesIgnored  =  format  .  isEmptyLinesIgnored  (  )  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/Lexer.java^51^^^^^45^57^
[REPLACE]    this    .    escape    =    format    .    getEscape    (    )    ;  	[BUGGY]  this  .  isEscaping  =  format  .  isEscaping  (  )  ;    ;  [CE]  variable  isEscaping  might  already  have  been  assigned    [METHOD]    <init>  [TYPE]  ExtendedBufferedReader)  [PARAMETER]  CSVFormat  format  ExtendedBufferedReader  in  [CLASS]  Lexer    [TYPE]  char  commmentStart  delimiter  encapsulator  escape  [TYPE]  ExtendedBufferedReader  in  [TYPE]  CSVFormat  format  [TYPE]  boolean  emptyLinesIgnored  false  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored  true    [CONTEXT]    Lexer  (  CSVFormat  format  ,  ExtendedBufferedReader  in  )  {  this  .  format  =  format  ;  this  .  in  =  in  ;  this  .  isEncapsulating  =  format  .  isEncapsulating  (  )  ;  this  .  isEscaping  =  format  .  isEscaping  (  )  ;  this  .  isCommentEnabled  =  format  .  isCommentingEnabled  (  )  ;  this  .  delimiter  =  format  .  getDelimiter  (  )  ;  [ATTENTION]  this  .  isEscaping  =  format  .  isEscaping  (  )    ;    ;  this  .  encapsulator  =  format  .  getEncapsulator  (  )  ;  this  .  commmentStart  =  format  .  getCommentStart  (  )  ;  this  .  surroundingSpacesIgnored  =  format  .  isSurroundingSpacesIgnored  (  )  ;  this  .  emptyLinesIgnored  =  format  .  isEmptyLinesIgnored  (  )  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/Lexer.java^52^^^^^45^57^
[ADD]    this    .    escape    =    format    .    getEscape    (    )    ;    this    .    encapsulator    =    format    .    getEncapsulator    (    )    ;    this    .    commmentStart    =    format    .    getCommentStart    (    )    ;    this    .    surroundingSpacesIgnored    =    format    .    isSurroundingSpacesIgnored    (    )    ;    this    .    emptyLinesIgnored    =    format    .    isEmptyLinesIgnored    (    )    ;  	[BUGGY]  [CE]  variable  escape  might  not  have  been  initialized    [METHOD]    <init>  [TYPE]  ExtendedBufferedReader)  [PARAMETER]  CSVFormat  format  ExtendedBufferedReader  in  [CLASS]  Lexer    [TYPE]  char  commmentStart  delimiter  encapsulator  escape  [TYPE]  ExtendedBufferedReader  in  [TYPE]  CSVFormat  format  [TYPE]  boolean  emptyLinesIgnored  false  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored  true    [CONTEXT]    Lexer  (  CSVFormat  format  ,  ExtendedBufferedReader  in  )  {  this  .  format  =  format  ;  this  .  in  =  in  ;  this  .  isEncapsulating  =  format  .  isEncapsulating  (  )  ;  this  .  isEscaping  =  format  .  isEscaping  (  )  ;  this  .  isCommentEnabled  =  format  .  isCommentingEnabled  (  )  ;  this  .  delimiter  =  format  .  getDelimiter  (  )  ;  [ATTENTION]      }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/Lexer.java^52^53^54^55^56^45^57^
[REPLACE]    this    .    encapsulator    =    format    .    getEncapsulator    (    )    ;  	[BUGGY]  this  .  isEncapsulating  =  format  .  isEncapsulating  (  )  ;    ;  [CE]  variable  isEncapsulating  might  already  have  been  assigned    [METHOD]    <init>  [TYPE]  ExtendedBufferedReader)  [PARAMETER]  CSVFormat  format  ExtendedBufferedReader  in  [CLASS]  Lexer    [TYPE]  char  commmentStart  delimiter  encapsulator  escape  [TYPE]  ExtendedBufferedReader  in  [TYPE]  CSVFormat  format  [TYPE]  boolean  emptyLinesIgnored  false  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored  true    [CONTEXT]    Lexer  (  CSVFormat  format  ,  ExtendedBufferedReader  in  )  {  this  .  format  =  format  ;  this  .  in  =  in  ;  this  .  isEncapsulating  =  format  .  isEncapsulating  (  )  ;  this  .  isEscaping  =  format  .  isEscaping  (  )  ;  this  .  isCommentEnabled  =  format  .  isCommentingEnabled  (  )  ;  this  .  delimiter  =  format  .  getDelimiter  (  )  ;  this  .  escape  =  format  .  getEscape  (  )  ;  [ATTENTION]  this  .  isEncapsulating  =  format  .  isEncapsulating  (  )    ;    ;  this  .  commmentStart  =  format  .  getCommentStart  (  )  ;  this  .  surroundingSpacesIgnored  =  format  .  isSurroundingSpacesIgnored  (  )  ;  this  .  emptyLinesIgnored  =  format  .  isEmptyLinesIgnored  (  )  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/Lexer.java^53^^^^^45^57^
[REPLACE]    this    .    commmentStart    =    format    .    getCommentStart    (    )    ;  	[BUGGY]  this  .  commmentStart  =    null  .  getCommentStart  (  )  ;  [CE]  <null>  cannot  be  dereferenced    [METHOD]    <init>  [TYPE]  ExtendedBufferedReader)  [PARAMETER]  CSVFormat  format  ExtendedBufferedReader  in  [CLASS]  Lexer    [TYPE]  char  commmentStart  delimiter  encapsulator  escape  [TYPE]  ExtendedBufferedReader  in  [TYPE]  CSVFormat  format  [TYPE]  boolean  emptyLinesIgnored  false  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored  true    [CONTEXT]    Lexer  (  CSVFormat  format  ,  ExtendedBufferedReader  in  )  {  this  .  format  =  format  ;  this  .  in  =  in  ;  this  .  isEncapsulating  =  format  .  isEncapsulating  (  )  ;  this  .  isEscaping  =  format  .  isEscaping  (  )  ;  this  .  isCommentEnabled  =  format  .  isCommentingEnabled  (  )  ;  this  .  delimiter  =  format  .  getDelimiter  (  )  ;  this  .  escape  =  format  .  getEscape  (  )  ;  this  .  encapsulator  =  format  .  getEncapsulator  (  )  ;  [ATTENTION]  this  .  commmentStart  =  null  .  getCommentStart  (  )    ;  this  .  surroundingSpacesIgnored  =  format  .  isSurroundingSpacesIgnored  (  )  ;  this  .  emptyLinesIgnored  =  format  .  isEmptyLinesIgnored  (  )  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/Lexer.java^54^^^^^45^57^
[ADD]    this    .    commmentStart    =    format    .    getCommentStart    (    )    ;    this    .    surroundingSpacesIgnored    =    format    .    isSurroundingSpacesIgnored    (    )    ;    this    .    emptyLinesIgnored    =    format    .    isEmptyLinesIgnored    (    )    ;    }  	[BUGGY]  [CE]  '  ;  '  expected    [METHOD]    <init>  [TYPE]  ExtendedBufferedReader)  [PARAMETER]  CSVFormat  format  ExtendedBufferedReader  in  [CLASS]  Lexer    [TYPE]  char  commmentStart  delimiter  encapsulator  escape  [TYPE]  ExtendedBufferedReader  in  [TYPE]  CSVFormat  format  [TYPE]  boolean  emptyLinesIgnored  false  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored  true    [CONTEXT]    Lexer  (  CSVFormat  format  ,  ExtendedBufferedReader  in  )  {  this  .  format  =  format  ;  this  .  in  =  in  ;  this  .  isEncapsulating  =  format  .  isEncapsulating  (  )  ;  this  .  isEscaping  =  format  .  isEscaping  (  )  ;  this  .  isCommentEnabled  =  format  .  isCommentingEnabled  (  )  ;  this  .  delimiter  =  format  .  getDelimiter  (  )  ;  this  .  escape  =  format  .  getEscape  (  )  ;  this  .  encapsulator  =  format  .  getEncapsulator  (  )  ;  [ATTENTION]        	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/Lexer.java^54^55^56^57^^45^57^
[REPLACE]    this    .    surroundingSpacesIgnored    =    format    .    isSurroundingSpacesIgnored    (    )    ;  	[BUGGY]  this  .  surroundingSpacesIgnored  =    null  .  isSurroundingSpacesIgnored  (  )  ;  [CE]  <null>  cannot  be  dereferenced    [METHOD]    <init>  [TYPE]  ExtendedBufferedReader)  [PARAMETER]  CSVFormat  format  ExtendedBufferedReader  in  [CLASS]  Lexer    [TYPE]  char  commmentStart  delimiter  encapsulator  escape  [TYPE]  ExtendedBufferedReader  in  [TYPE]  CSVFormat  format  [TYPE]  boolean  emptyLinesIgnored  false  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored  true    [CONTEXT]    Lexer  (  CSVFormat  format  ,  ExtendedBufferedReader  in  )  {  this  .  format  =  format  ;  this  .  in  =  in  ;  this  .  isEncapsulating  =  format  .  isEncapsulating  (  )  ;  this  .  isEscaping  =  format  .  isEscaping  (  )  ;  this  .  isCommentEnabled  =  format  .  isCommentingEnabled  (  )  ;  this  .  delimiter  =  format  .  getDelimiter  (  )  ;  this  .  escape  =  format  .  getEscape  (  )  ;  this  .  encapsulator  =  format  .  getEncapsulator  (  )  ;  this  .  commmentStart  =  format  .  getCommentStart  (  )  ;  [ATTENTION]  this  .  surroundingSpacesIgnored  =  null  .  isSurroundingSpacesIgnored  (  )    ;  this  .  emptyLinesIgnored  =  format  .  isEmptyLinesIgnored  (  )  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/Lexer.java^55^^^^^45^57^
[ADD]    this    .    surroundingSpacesIgnored    =    format    .    isSurroundingSpacesIgnored    (    )    ;    this    .    emptyLinesIgnored    =    format    .    isEmptyLinesIgnored    (    )    ;    }  	[BUGGY]  [CE]  '  ;  '  expected    [METHOD]    <init>  [TYPE]  ExtendedBufferedReader)  [PARAMETER]  CSVFormat  format  ExtendedBufferedReader  in  [CLASS]  Lexer    [TYPE]  char  commmentStart  delimiter  encapsulator  escape  [TYPE]  ExtendedBufferedReader  in  [TYPE]  CSVFormat  format  [TYPE]  boolean  emptyLinesIgnored  false  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored  true    [CONTEXT]    Lexer  (  CSVFormat  format  ,  ExtendedBufferedReader  in  )  {  this  .  format  =  format  ;  this  .  in  =  in  ;  this  .  isEncapsulating  =  format  .  isEncapsulating  (  )  ;  this  .  isEscaping  =  format  .  isEscaping  (  )  ;  this  .  isCommentEnabled  =  format  .  isCommentingEnabled  (  )  ;  this  .  delimiter  =  format  .  getDelimiter  (  )  ;  this  .  escape  =  format  .  getEscape  (  )  ;  this  .  encapsulator  =  format  .  getEncapsulator  (  )  ;  this  .  commmentStart  =  format  .  getCommentStart  (  )  ;  [ATTENTION]        	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/Lexer.java^55^56^57^^^45^57^
[REPLACE]    this    .    emptyLinesIgnored    =    format    .    isEmptyLinesIgnored    (    )    ;  	[BUGGY]  this  .  emptyLinesIgnored  =    null  .  isEmptyLinesIgnored  (  )  ;  [CE]  <null>  cannot  be  dereferenced    [METHOD]    <init>  [TYPE]  ExtendedBufferedReader)  [PARAMETER]  CSVFormat  format  ExtendedBufferedReader  in  [CLASS]  Lexer    [TYPE]  char  commmentStart  delimiter  encapsulator  escape  [TYPE]  ExtendedBufferedReader  in  [TYPE]  CSVFormat  format  [TYPE]  boolean  emptyLinesIgnored  false  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored  true    [CONTEXT]    Lexer  (  CSVFormat  format  ,  ExtendedBufferedReader  in  )  {  this  .  format  =  format  ;  this  .  in  =  in  ;  this  .  isEncapsulating  =  format  .  isEncapsulating  (  )  ;  this  .  isEscaping  =  format  .  isEscaping  (  )  ;  this  .  isCommentEnabled  =  format  .  isCommentingEnabled  (  )  ;  this  .  delimiter  =  format  .  getDelimiter  (  )  ;  this  .  escape  =  format  .  getEscape  (  )  ;  this  .  encapsulator  =  format  .  getEncapsulator  (  )  ;  this  .  commmentStart  =  format  .  getCommentStart  (  )  ;  this  .  surroundingSpacesIgnored  =  format  .  isSurroundingSpacesIgnored  (  )  ;  [ATTENTION]  this  .  emptyLinesIgnored  =  null  .  isEmptyLinesIgnored  (  )    ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/Lexer.java^56^^^^^45^57^
[REPLACE]    return    in    .    getLineNumber    (    )    ;  	[BUGGY]  return  in  .  read  (  )    ;  [CE]  unreported  exception  IOException  ;  must  be  caught  or  declared  to  be  thrown    [METHOD]    getLineNumber  [TYPE]  int  [PARAMETER]  [CLASS]  Lexer    [TYPE]  char  commmentStart  delimiter  encapsulator  escape  [TYPE]  ExtendedBufferedReader  in  [TYPE]  CSVFormat  format  [TYPE]  boolean  emptyLinesIgnored  false  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored  true    [CONTEXT]    int  getLineNumber  (  )  {  [ATTENTION]  return  in  .  read  (  )  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/Lexer.java^60^^^^^59^61^
[REPLACE]    c    =    in    .    read    (    )    ;  	[BUGGY]  c    =    c  ;  [FE]    null  assertTokenEquals(TOKEN  ,     "1   "  ,  parser.nextToken(new  Token()))      [METHOD]    readEscape  [TYPE]  int  [PARAMETER]  int  c  [CLASS]  Lexer    [TYPE]  char  commmentStart  delimiter  encapsulator  escape  [TYPE]  ExtendedBufferedReader  in  [TYPE]  CSVFormat  format  [TYPE]  boolean  emptyLinesIgnored  false  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored  true  [TYPE]  int  c    [CONTEXT]    int  readEscape  (  int  c  )  throws  IOException  {    [ATTENTION]  c  =  c  ;  switch  (  c  )  {  case  'r':  return  '\r'  ;  case  'n':  return  '\n'  ;  case  't':  return  '\t'  ;  case  'b':  return  '\b'  ;  case  'f':  return  '\f'  ;  default:  return  c  ;  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/Lexer.java^65^^^^^63^80^
[ADD]    c    =    in    .    read    (    )    ;  	[BUGGY]  [FE]    null  assertTokenEquals(TOKEN  ,     "1   "  ,  parser.nextToken(new  Token()))      [METHOD]    readEscape  [TYPE]  int  [PARAMETER]  int  c  [CLASS]  Lexer    [TYPE]  char  commmentStart  delimiter  encapsulator  escape  [TYPE]  ExtendedBufferedReader  in  [TYPE]  CSVFormat  format  [TYPE]  boolean  emptyLinesIgnored  false  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored  true  [TYPE]  int  c    [CONTEXT]    int  readEscape  (  int  c  )  throws  IOException  {    [ATTENTION]  switch  (  c  )  {  case  'r':  return  '\r'  ;  case  'n':  return  '\n'  ;  case  't':  return  '\t'  ;  case  'b':  return  '\b'  ;  case  'f':  return  '\f'  ;  default:  return  c  ;  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/Lexer.java^65^^^^^63^80^
[REPLACE]    return    '\r';  	[BUGGY]  return  '\t'  ;  [FE]    null  assertTokenEquals(TOKEN  ,     "1   "  ,  parser.nextToken(new  Token()))      [METHOD]    readEscape  [TYPE]  int  [PARAMETER]  int  c  [CLASS]  Lexer    [TYPE]  char  commmentStart  delimiter  encapsulator  escape  [TYPE]  ExtendedBufferedReader  in  [TYPE]  CSVFormat  format  [TYPE]  boolean  emptyLinesIgnored  false  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored  true  [TYPE]  int  c    [CONTEXT]    int  readEscape  (  int  c  )  throws  IOException  {    c  =  in  .  read  (  )  ;  switch  (  c  )  {  case  'r':  [ATTENTION]  return  '\t'  ;  case  'n':  return  '\n'  ;  case  't':  return  '\t'  ;  case  'b':  return  '\b'  ;  case  'f':  return  '\f'  ;  default:  return  c  ;  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/Lexer.java^68^^^^^63^80^
[REPLACE]    return    '\n';  	[BUGGY]  return  '\t'  ;  [FE]    null  assertTokenEquals(TOKEN  ,     "1   "  ,  parser.nextToken(new  Token()))      [METHOD]    readEscape  [TYPE]  int  [PARAMETER]  int  c  [CLASS]  Lexer    [TYPE]  char  commmentStart  delimiter  encapsulator  escape  [TYPE]  ExtendedBufferedReader  in  [TYPE]  CSVFormat  format  [TYPE]  boolean  emptyLinesIgnored  false  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored  true  [TYPE]  int  c    [CONTEXT]    int  readEscape  (  int  c  )  throws  IOException  {    c  =  in  .  read  (  )  ;  switch  (  c  )  {  case  'r':  return  '\r'  ;  case  'n':  [ATTENTION]  return  '\t'  ;  case  't':  return  '\t'  ;  case  'b':  return  '\b'  ;  case  'f':  return  '\f'  ;  default:  return  c  ;  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/Lexer.java^70^^^^^63^80^
[REPLACE]    return    '\t';  	[BUGGY]  return  '\r'  ;  [FE]    null  assertTokenEquals(TOKEN  ,     "1   "  ,  parser.nextToken(new  Token()))      [METHOD]    readEscape  [TYPE]  int  [PARAMETER]  int  c  [CLASS]  Lexer    [TYPE]  char  commmentStart  delimiter  encapsulator  escape  [TYPE]  ExtendedBufferedReader  in  [TYPE]  CSVFormat  format  [TYPE]  boolean  emptyLinesIgnored  false  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored  true  [TYPE]  int  c    [CONTEXT]    int  readEscape  (  int  c  )  throws  IOException  {    c  =  in  .  read  (  )  ;  switch  (  c  )  {  case  'r':  return  '\r'  ;  case  'n':  return  '\n'  ;  case  't':  [ATTENTION]  return  '\r'  ;  case  'b':  return  '\b'  ;  case  'f':  return  '\f'  ;  default:  return  c  ;  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/Lexer.java^72^^^^^63^80^
[REPLACE]    return    '\b';  	[BUGGY]  return  '\t'  ;  [FE]    null  assertTokenEquals(TOKEN  ,     "1   "  ,  parser.nextToken(new  Token()))      [METHOD]    readEscape  [TYPE]  int  [PARAMETER]  int  c  [CLASS]  Lexer    [TYPE]  char  commmentStart  delimiter  encapsulator  escape  [TYPE]  ExtendedBufferedReader  in  [TYPE]  CSVFormat  format  [TYPE]  boolean  emptyLinesIgnored  false  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored  true  [TYPE]  int  c    [CONTEXT]    int  readEscape  (  int  c  )  throws  IOException  {    c  =  in  .  read  (  )  ;  switch  (  c  )  {  case  'r':  return  '\r'  ;  case  'n':  return  '\n'  ;  case  't':  return  '\t'  ;  case  'b':  [ATTENTION]  return  '\t'  ;  case  'f':  return  '\f'  ;  default:  return  c  ;  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/Lexer.java^74^^^^^63^80^
[REPLACE]    return    '\f';  	[BUGGY]  return  '\t'  ;  [FE]    null  assertTokenEquals(TOKEN  ,     "1   "  ,  parser.nextToken(new  Token()))      [METHOD]    readEscape  [TYPE]  int  [PARAMETER]  int  c  [CLASS]  Lexer    [TYPE]  char  commmentStart  delimiter  encapsulator  escape  [TYPE]  ExtendedBufferedReader  in  [TYPE]  CSVFormat  format  [TYPE]  boolean  emptyLinesIgnored  false  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored  true  [TYPE]  int  c    [CONTEXT]    int  readEscape  (  int  c  )  throws  IOException  {    c  =  in  .  read  (  )  ;  switch  (  c  )  {  case  'r':  return  '\r'  ;  case  'n':  return  '\n'  ;  case  't':  return  '\t'  ;  case  'b':  return  '\b'  ;  case  'f':  [ATTENTION]  return  '\t'  ;  default:  return  c  ;  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/Lexer.java^76^^^^^63^80^
[REPLACE]    return    c;  	[BUGGY]  return  '\t'  ;  [FE]    null  assertTokenEquals(TOKEN  ,     "1   "  ,  parser.nextToken(new  Token()))      [METHOD]    readEscape  [TYPE]  int  [PARAMETER]  int  c  [CLASS]  Lexer    [TYPE]  char  commmentStart  delimiter  encapsulator  escape  [TYPE]  ExtendedBufferedReader  in  [TYPE]  CSVFormat  format  [TYPE]  boolean  emptyLinesIgnored  false  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored  true  [TYPE]  int  c    [CONTEXT]    int  readEscape  (  int  c  )  throws  IOException  {    c  =  in  .  read  (  )  ;  switch  (  c  )  {  case  'r':  return  '\r'  ;  case  'n':  return  '\n'  ;  case  't':  return  '\t'  ;  case  'b':  return  '\b'  ;  case  'f':  return  '\f'  ;  default:  [ATTENTION]  return  '\t'  ;  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/Lexer.java^78^^^^^63^80^
[REPLACE]    int    length    =    buffer    .    length    (    )    ;  	[BUGGY]  int  length  =  buffer  .  setLength  (  length  )    ;  [CE]  incompatible  types    [METHOD]    trimTrailingSpaces  [TYPE]  void  [PARAMETER]  StringBuilder  buffer  [CLASS]  Lexer    [TYPE]  char  commmentStart  delimiter  encapsulator  escape  [TYPE]  ExtendedBufferedReader  in  [TYPE]  CSVFormat  format  [TYPE]  boolean  emptyLinesIgnored  false  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored  true  [TYPE]  StringBuilder  buffer  [TYPE]  int  length    [CONTEXT]    void  trimTrailingSpaces  (  StringBuilder  buffer  )  {  [ATTENTION]  int  length  =  buffer  .  setLength  (  length  )  ;  while  (  length  >  0  &&  Character  .  isWhitespace  (  buffer  .  charAt  (  length  -  1  )  )  )  {  length  =  length  -  1  ;  }  if  (  length  !  =  buffer  .  length  (  )  )  {  buffer  .  setLength  (  length  )  ;  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/Lexer.java^83^^^^^82^90^
[REPLACE]    while    (    length    >    0    &&    Character    .    isWhitespace    (    buffer    .    charAt    (    length    -    1    )    )    )    {  	[BUGGY]  while  (  length  +  3  >  0  &&  Character  .  isWhitespace  (  buffer  .  charAt  (  length  +  3  -  1  )  )  )  {[FE]    String  index  out  of  range:  5  assertTokenEquals(TOKEN  ,     "abc   "  ,  parser.nextToken(new  Token()))      [METHOD]    trimTrailingSpaces  [TYPE]  void  [PARAMETER]  StringBuilder  buffer  [CLASS]  Lexer    [TYPE]  char  commmentStart  delimiter  encapsulator  escape  [TYPE]  ExtendedBufferedReader  in  [TYPE]  CSVFormat  format  [TYPE]  boolean  emptyLinesIgnored  false  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored  true  [TYPE]  StringBuilder  buffer  [TYPE]  int  length    [CONTEXT]    void  trimTrailingSpaces  (  StringBuilder  buffer  )  {  int  length  =  buffer  .  length  (  )  ;  [ATTENTION]  while  (  length  +  3  >  0&&  Character  .  isWhitespace  (  buffer  .  charAt  (  length  +  3  -  1  )  )  )  {  length  =  length  -  1  ;  }  if  (  length  !  =  buffer  .  length  (  )  )  {  buffer  .  setLength  (  length  )  ;  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/Lexer.java^84^^^^^82^90^
[REPLACE]    length    =    length    -    1;  	[BUGGY]  length  +  5  =  length  +  5  -  0  ;  [CE]  unexpected  type    [METHOD]    trimTrailingSpaces  [TYPE]  void  [PARAMETER]  StringBuilder  buffer  [CLASS]  Lexer    [TYPE]  char  commmentStart  delimiter  encapsulator  escape  [TYPE]  ExtendedBufferedReader  in  [TYPE]  CSVFormat  format  [TYPE]  boolean  emptyLinesIgnored  false  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored  true  [TYPE]  StringBuilder  buffer  [TYPE]  int  length    [CONTEXT]    void  trimTrailingSpaces  (  StringBuilder  buffer  )  {  int  length  =  buffer  .  length  (  )  ;  while  (  length  >  0  &&  Character  .  isWhitespace  (  buffer  .  charAt  (  length  -  1  )  )  )  {  [ATTENTION]  length  +  5  =  length  +  5  -  0  ;  }  if  (  length  !  =  buffer  .  length  (  )  )  {  buffer  .  setLength  (  length  )  ;  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/Lexer.java^85^^^^^82^90^
[REPLACE]    length    =    length    -    1;  	[BUGGY]  length  %  0  .  5    =  length  %  0  .  5  -  1  ;  [CE]  unexpected  type    [METHOD]    trimTrailingSpaces  [TYPE]  void  [PARAMETER]  StringBuilder  buffer  [CLASS]  Lexer    [TYPE]  char  commmentStart  delimiter  encapsulator  escape  [TYPE]  ExtendedBufferedReader  in  [TYPE]  CSVFormat  format  [TYPE]  boolean  emptyLinesIgnored  false  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored  true  [TYPE]  StringBuilder  buffer  [TYPE]  int  length    [CONTEXT]    void  trimTrailingSpaces  (  StringBuilder  buffer  )  {  int  length  =  buffer  .  length  (  )  ;  while  (  length  >  0  &&  Character  .  isWhitespace  (  buffer  .  charAt  (  length  -  1  )  )  )  {  [ATTENTION]  length  %0  .  5  =  length  %0  .  5-  1  ;  }  if  (  length  !  =  buffer  .  length  (  )  )  {  buffer  .  setLength  (  length  )  ;  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/Lexer.java^85^^^^^82^90^
[REPLACE]    if    (    length    !=    buffer    .    length    (    )    )    {  	[BUGGY]  if  (  length  !  =  buffer  .  length  (  )  *  2  )  {[FE]    null  assertTokenEquals(TOKEN  ,     "1   "  ,  parser.nextToken(new  Token()))      [METHOD]    trimTrailingSpaces  [TYPE]  void  [PARAMETER]  StringBuilder  buffer  [CLASS]  Lexer    [TYPE]  char  commmentStart  delimiter  encapsulator  escape  [TYPE]  ExtendedBufferedReader  in  [TYPE]  CSVFormat  format  [TYPE]  boolean  emptyLinesIgnored  false  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored  true  [TYPE]  StringBuilder  buffer  [TYPE]  int  length    [CONTEXT]    void  trimTrailingSpaces  (  StringBuilder  buffer  )  {  int  length  =  buffer  .  length  (  )  ;  while  (  length  >  0  &&  Character  .  isWhitespace  (  buffer  .  charAt  (  length  -  1  )  )  )  {  length  =  length  -  1  ;  }  [ATTENTION]  if  (  length  !  =  buffer  .  length  (  )  *2  )  {  buffer  .  setLength  (  length  )  ;  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/Lexer.java^87^^^^^82^90^
[REPLACE]    buffer    .    setLength    (    length    )    ;  	[BUGGY]  buffer  .  charAt  (  length  )  ;  [FE]    AssertionFailedError    Token  content  expected:<uv[]>  but  was:<uv[  ]>  assertTokenEquals(TOKEN  ,     "abc   "  ,  parser.nextToken(new  Token()))      [METHOD]    trimTrailingSpaces  [TYPE]  void  [PARAMETER]  StringBuilder  buffer  [CLASS]  Lexer    [TYPE]  char  commmentStart  delimiter  encapsulator  escape  [TYPE]  ExtendedBufferedReader  in  [TYPE]  CSVFormat  format  [TYPE]  boolean  emptyLinesIgnored  false  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored  true  [TYPE]  StringBuilder  buffer  [TYPE]  int  length    [CONTEXT]    void  trimTrailingSpaces  (  StringBuilder  buffer  )  {  int  length  =  buffer  .  length  (  )  ;  while  (  length  >  0  &&  Character  .  isWhitespace  (  buffer  .  charAt  (  length  -  1  )  )  )  {  length  =  length  -  1  ;  }  if  (  length  !  =  buffer  .  length  (  )  )  {  [ATTENTION]  buffer  .  charAt  (  length  )    ;  }  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/Lexer.java^88^^^^^82^90^
[REPLACE]    return    (    c    !=    format    .    getDelimiter    (    )    )    &&    Character    .    isWhitespace    (    (    char    )    c    )    ;  	[BUGGY]  return  (  c  !  =  format  .  getDelimiter  (  )  )    ;  ;  [CE]  unreachable  statement    [METHOD]    isWhitespace  [TYPE]  boolean  [PARAMETER]  int  c  [CLASS]  Lexer    [TYPE]  char  commmentStart  delimiter  encapsulator  escape  [TYPE]  ExtendedBufferedReader  in  [TYPE]  CSVFormat  format  [TYPE]  boolean  emptyLinesIgnored  false  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored  true  [TYPE]  int  c    [CONTEXT]    boolean  isWhitespace  (  int  c  )  {  [ATTENTION]  return  (  c  !  =  format  .  getDelimiter  (  )  )  ;  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/Lexer.java^96^^^^^95^97^
[REPLACE]    if    (    c    ==    '\r'    &&    in    .    lookAhead    (    )    ==    '\n'    )    {  	[BUGGY]  if  (  c  =  =  '\r'  )  {[FE]    null  assertTokenEquals(TOKEN  ,     "1   "  ,  parser.nextToken(new  Token()))      [METHOD]    isEndOfLine  [TYPE]  boolean  [PARAMETER]  int  c  [CLASS]  Lexer    [TYPE]  char  commmentStart  delimiter  encapsulator  escape  [TYPE]  ExtendedBufferedReader  in  [TYPE]  CSVFormat  format  [TYPE]  boolean  emptyLinesIgnored  false  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored  true  [TYPE]  int  c    [CONTEXT]    boolean  isEndOfLine  (  int  c  )  throws  IOException  {    [ATTENTION]  if  (  c  =  =  '\r'  )  {    c  =  in  .  read  (  )  ;  }  return  (  c  =  =  '\n'  ||  c  =  =  '\r'  )  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/Lexer.java^107^^^^^105^112^
[REPLACE]    c    =    in    .    read    (    )    ;  	[BUGGY]  c    =    c  ;  [FE]    null  assertTokenEquals(TOKEN  ,     "1   "  ,  parser.nextToken(new  Token()))      [METHOD]    isEndOfLine  [TYPE]  boolean  [PARAMETER]  int  c  [CLASS]  Lexer    [TYPE]  char  commmentStart  delimiter  encapsulator  escape  [TYPE]  ExtendedBufferedReader  in  [TYPE]  CSVFormat  format  [TYPE]  boolean  emptyLinesIgnored  false  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored  true  [TYPE]  int  c    [CONTEXT]    boolean  isEndOfLine  (  int  c  )  throws  IOException  {    if  (  c  =  =  '\r'  &&  in  .  lookAhead  (  )    =  =  '\n'  )  {    [ATTENTION]  c  =  c  ;  }  return  (  c  =  =  '\n'  ||  c  =  =  '\r'  )  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/Lexer.java^109^^^^^105^112^
[REPLACE]    c    =    in    .    read    (    )    ;  	[BUGGY]  c  ;  [CE]  not  a  statement    [METHOD]    isEndOfLine  [TYPE]  boolean  [PARAMETER]  int  c  [CLASS]  Lexer    [TYPE]  char  commmentStart  delimiter  encapsulator  escape  [TYPE]  ExtendedBufferedReader  in  [TYPE]  CSVFormat  format  [TYPE]  boolean  emptyLinesIgnored  false  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored  true  [TYPE]  int  c    [CONTEXT]    boolean  isEndOfLine  (  int  c  )  throws  IOException  {    if  (  c  =  =  '\r'  &&  in  .  lookAhead  (  )    =  =  '\n'  )  {    [ATTENTION]  c  ;  }  return  (  c  =  =  '\n'  ||  c  =  =  '\r'  )  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/Lexer.java^109^^^^^105^112^
[REPLACE]    return    (    c    ==    '\n'    ||    c    ==    '\r'    )    ;  	[BUGGY]  return  (  c  ;  [CE]  ')'  expected    [METHOD]    isEndOfLine  [TYPE]  boolean  [PARAMETER]  int  c  [CLASS]  Lexer    [TYPE]  char  commmentStart  delimiter  encapsulator  escape  [TYPE]  ExtendedBufferedReader  in  [TYPE]  CSVFormat  format  [TYPE]  boolean  emptyLinesIgnored  false  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored  true  [TYPE]  int  c    [CONTEXT]    boolean  isEndOfLine  (  int  c  )  throws  IOException  {    if  (  c  =  =  '\r'  &&  in  .  lookAhead  (  )    =  =  '\n'  )  {    c  =  in  .  read  (  )  ;  }  [ATTENTION]  return  (  c  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/Lexer.java^111^^^^^105^112^
[REPLACE]    return    c    ==    ExtendedBufferedReader    .    END_OF_STREAM;  	[BUGGY]  return  true  ;  [FE]    AssertionFailedError    Token  type  expected:<TOKEN>  but  was:<EOF>  assertTokenEquals(TOKEN  ,     "abc   "  ,  parser.nextToken(new  Token()))      [METHOD]    isEndOfFile  [TYPE]  boolean  [PARAMETER]  int  c  [CLASS]  Lexer    [TYPE]  char  commmentStart  delimiter  encapsulator  escape  [TYPE]  ExtendedBufferedReader  in  [TYPE]  CSVFormat  format  [TYPE]  boolean  emptyLinesIgnored  false  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored  true  [TYPE]  int  c    [CONTEXT]    boolean  isEndOfFile  (  int  c  )  {  [ATTENTION]  return  true  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/Lexer.java^118^^^^^117^119^
[REPLACE]    return    c    ==    delimiter;  	[BUGGY]  return  c  ||  delimiter  ;  [CE]  bad  operand  types  for  binary  operator  '||'    [METHOD]    isDelimiter  [TYPE]  boolean  [PARAMETER]  int  c  [CLASS]  Lexer    [TYPE]  char  commmentStart  delimiter  encapsulator  escape  [TYPE]  ExtendedBufferedReader  in  [TYPE]  CSVFormat  format  [TYPE]  boolean  emptyLinesIgnored  false  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored  true  [TYPE]  int  c    [CONTEXT]    boolean  isDelimiter  (  int  c  )  {  [ATTENTION]  return  c||delimiter  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/Lexer.java^124^^^^^123^125^
[REPLACE]    return    isEscaping    &&    c    ==    escape;  	[BUGGY]  return    c  ;  [CE]  incompatible  types    [METHOD]    isEscape  [TYPE]  boolean  [PARAMETER]  int  c  [CLASS]  Lexer    [TYPE]  char  commmentStart  delimiter  encapsulator  escape  [TYPE]  ExtendedBufferedReader  in  [TYPE]  CSVFormat  format  [TYPE]  boolean  emptyLinesIgnored  false  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored  true  [TYPE]  int  c    [CONTEXT]    boolean  isEscape  (  int  c  )  {  [ATTENTION]  return  c  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/Lexer.java^128^^^^^127^129^
[REPLACE]    return    isEncapsulating    &&    c    ==    encapsulator;  	[BUGGY]  return  false  ;  [FE]    null  assertTokenEquals(TOKEN  ,     "1   "  ,  parser.nextToken(new  Token()))      [METHOD]    isEncapsulator  [TYPE]  boolean  [PARAMETER]  int  c  [CLASS]  Lexer    [TYPE]  char  commmentStart  delimiter  encapsulator  escape  [TYPE]  ExtendedBufferedReader  in  [TYPE]  CSVFormat  format  [TYPE]  boolean  emptyLinesIgnored  false  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored  true  [TYPE]  int  c    [CONTEXT]    boolean  isEncapsulator  (  int  c  )  {  [ATTENTION]  return  false  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/Lexer.java^132^^^^^131^133^
[REPLACE]    return    isCommentEnabled    &&    c    ==    commmentStart;  	[BUGGY]  return  isCommentEnabled  ;  [FE]    null  assertTokenEquals(TOKEN  ,     "1   "  ,  parser.nextToken(new  Token()))      [METHOD]    isCommentStart  [TYPE]  boolean  [PARAMETER]  int  c  [CLASS]  Lexer    [TYPE]  char  commmentStart  delimiter  encapsulator  escape  [TYPE]  ExtendedBufferedReader  in  [TYPE]  CSVFormat  format  [TYPE]  boolean  emptyLinesIgnored  false  isCommentEnabled  isEncapsulating  isEscaping  surroundingSpacesIgnored  true  [TYPE]  int  c    [CONTEXT]    boolean  isCommentStart  (  int  c  )  {  [ATTENTION]  return  isCommentEnabled  ;  }    	./Perturbation-Csv-1/src/main/java/org/apache/commons/csv/Lexer.java^136^^^^^135^137^
