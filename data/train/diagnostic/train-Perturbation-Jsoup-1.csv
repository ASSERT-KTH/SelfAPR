[REPLACE]  Validate  .  isTrue  (  args  .  length  ==  1,   "usage:  supply  url  to  fetch "  )  ;	[BUGGY]  Validate  .  isTrue  (  args  .  length  *  2  =  =  1  ,   "usage:  supply  url  to  fetch "  )  ;  [NO-ERROR]  [CONTEXT]  public  static  void  main  (  String[]  args  )  throws  IOException  {  [ATTENTION]  Validate  .  isTrue  (  args  .  length  *2  =  =  1  ,   "usage:  supply  url  to  fetch "  )    ;  URL  url  =  new  URL  (  args[0]  )  ;  print  (   "Fetching  %s  .  .  .   "  ,  url  .  toExternalForm  (  )  )  ;    Document  doc  =  Jsoup  .  parse  (  url  ,  3*1000  )  ;  Elements  links  =  doc  .  select  (   "a[href] "  )  ;  Elements  media  =  doc  .  select  (   "[src] "  )  ;  Elements  imports  =  doc  .  select  (   "link[href] "  )  ;    print  (   "\nMedia:  (  %d  )   "  ,  media  .  size  (  )  )  ;  for  (  Element  src  :  media  )  {  if  (  src  .  tagName  (  )  .  equals  (   "img "  )  )  print  (   "  *  %s:  <%s>  %sx%s  (  %s  )   "  ,  src  .  tagName  (  )  ,  src  .  attr  (   "abs:src "  )  ,  src  .  attr  (   "width "  )  ,  src  .  attr  (   "height "  )  ,  trim  (  src  .  attr  (   "alt "  )  ,  20  )  )  ;  else  print  (   "  *  %s:  <%s> "  ,  src  .  tagName  (  )  ,  src  .  attr  (   "abs:src "  )  )  ;  }  print  (   "\nImports:  (  %d  )   "  ,  imports  .  size  (  )  )  ;  for  (  Element  link  :  imports  )  {  print  (   "  *  %s  <%s>  (  %s  )   "  ,  link  .  tagName  (  )  ,  link  .  attr  (   "abs:href "  )  ,  link  .  attr  (   "rel "  )  )  ;  }  print  (   "\nLinks:  (  %d  )   "  ,  links  .  size  (  )  )  ;  for  (  Element  link  :  links  )  {  print  (   "  *  a:  <%s>  (  %s  )   "  ,  link  .  attr  (   "abs:href "  )  ,  trim  (  link  .  text  (  )  ,  35  )  )  ;  }  }    [METHOD]  main  [TYPE]  void  [PARAMETER]  String[]  args  [CLASS]  ListLinks    [TYPE]  boolean  false  true  [TYPE]  Element  link  src  [TYPE]  String[]  args  [TYPE]  Document  doc  [TYPE]  Elements  imports  links  media  [TYPE]  URL  url  
[REPLACE]  URL  url  =  new  URL  (  args[0]  )  ;	[BUGGY]  URL  url  =  new  URL  (  args[1]  )  ;  [NO-ERROR]  [CONTEXT]  public  static  void  main  (  String[]  args  )  throws  IOException  {  Validate  .  isTrue  (  args  .  length  =  =  1  ,   "usage:  supply  url  to  fetch "  )  ;  [ATTENTION]  URL  url  =  new  URL  (  args[1]  )    ;  print  (   "Fetching  %s  .  .  .   "  ,  url  .  toExternalForm  (  )  )  ;    Document  doc  =  Jsoup  .  parse  (  url  ,  3*1000  )  ;  Elements  links  =  doc  .  select  (   "a[href] "  )  ;  Elements  media  =  doc  .  select  (   "[src] "  )  ;  Elements  imports  =  doc  .  select  (   "link[href] "  )  ;    print  (   "\nMedia:  (  %d  )   "  ,  media  .  size  (  )  )  ;  for  (  Element  src  :  media  )  {  if  (  src  .  tagName  (  )  .  equals  (   "img "  )  )  print  (   "  *  %s:  <%s>  %sx%s  (  %s  )   "  ,  src  .  tagName  (  )  ,  src  .  attr  (   "abs:src "  )  ,  src  .  attr  (   "width "  )  ,  src  .  attr  (   "height "  )  ,  trim  (  src  .  attr  (   "alt "  )  ,  20  )  )  ;  else  print  (   "  *  %s:  <%s> "  ,  src  .  tagName  (  )  ,  src  .  attr  (   "abs:src "  )  )  ;  }  print  (   "\nImports:  (  %d  )   "  ,  imports  .  size  (  )  )  ;  for  (  Element  link  :  imports  )  {  print  (   "  *  %s  <%s>  (  %s  )   "  ,  link  .  tagName  (  )  ,  link  .  attr  (   "abs:href "  )  ,  link  .  attr  (   "rel "  )  )  ;  }  print  (   "\nLinks:  (  %d  )   "  ,  links  .  size  (  )  )  ;  for  (  Element  link  :  links  )  {  print  (   "  *  a:  <%s>  (  %s  )   "  ,  link  .  attr  (   "abs:href "  )  ,  trim  (  link  .  text  (  )  ,  35  )  )  ;  }  }    [METHOD]  main  [TYPE]  void  [PARAMETER]  String[]  args  [CLASS]  ListLinks    [TYPE]  boolean  false  true  [TYPE]  Element  link  src  [TYPE]  String[]  args  [TYPE]  Document  doc  [TYPE]  Elements  imports  links  media  [TYPE]  URL  url  
[REPLACE]  print  (   "Fetching  %s  .    .    .   ",  url  .  toExternalForm  (  )  )  ;	[BUGGY]  print  (   "  *  %s:  <%s>  %sx%s  (  %s  )   "  ,  [CE]  ')'  expected  [CONTEXT]  public  static  void  main  (  String[]  args  )  throws  IOException  {  Validate  .  isTrue  (  args  .  length  =  =  1  ,   "usage:  supply  url  to  fetch "  )  ;  URL  url  =  new  URL  (  args[0]  )  ;  [ATTENTION]  print  (   "  *  %s:  <%s>  %sx%s  (  %s  )   "  ,    Document  doc  =  Jsoup  .  parse  (  url  ,  3*1000  )  ;  Elements  links  =  doc  .  select  (   "a[href] "  )  ;  Elements  media  =  doc  .  select  (   "[src] "  )  ;  Elements  imports  =  doc  .  select  (   "link[href] "  )  ;    print  (   "\nMedia:  (  %d  )   "  ,  media  .  size  (  )  )  ;  for  (  Element  src  :  media  )  {  if  (  src  .  tagName  (  )  .  equals  (   "img "  )  )  print  (   "  *  %s:  <%s>  %sx%s  (  %s  )   "  ,  src  .  tagName  (  )  ,  src  .  attr  (   "abs:src "  )  ,  src  .  attr  (   "width "  )  ,  src  .  attr  (   "height "  )  ,  trim  (  src  .  attr  (   "alt "  )  ,  20  )  )  ;  else  print  (   "  *  %s:  <%s> "  ,  src  .  tagName  (  )  ,  src  .  attr  (   "abs:src "  )  )  ;  }  print  (   "\nImports:  (  %d  )   "  ,  imports  .  size  (  )  )  ;  for  (  Element  link  :  imports  )  {  print  (   "  *  %s  <%s>  (  %s  )   "  ,  link  .  tagName  (  )  ,  link  .  attr  (   "abs:href "  )  ,  link  .  attr  (   "rel "  )  )  ;  }  print  (   "\nLinks:  (  %d  )   "  ,  links  .  size  (  )  )  ;  for  (  Element  link  :  links  )  {  print  (   "  *  a:  <%s>  (  %s  )   "  ,  link  .  attr  (   "abs:href "  )  ,  trim  (  link  .  text  (  )  ,  35  )  )  ;  }  }    [METHOD]  main  [TYPE]  void  [PARAMETER]  String[]  args  [CLASS]  ListLinks    [TYPE]  boolean  false  true  [TYPE]  Element  link  src  [TYPE]  String[]  args  [TYPE]  Document  doc  [TYPE]  Elements  imports  links  media  [TYPE]  URL  url  
[REPLACE]  Elements  links  =  doc  .  select  (   "a[href] "  )  ;	[BUGGY]  Elements  media  =  doc  .  select  (   "[src] "  )  ;  [CE]  variable  media  is  already  defined  in  method  main(String[])  [CONTEXT]  public  static  void  main  (  String[]  args  )  throws  IOException  {  Validate  .  isTrue  (  args  .  length  =  =  1  ,   "usage:  supply  url  to  fetch "  )  ;  URL  url  =  new  URL  (  args[0]  )  ;  print  (   "Fetching  %s  .  .  .   "  ,  url  .  toExternalForm  (  )  )  ;    Document  doc  =  Jsoup  .  parse  (  url  ,  3*1000  )  ;  [ATTENTION]  Elements  media  =  doc  .  select  (   "[src] "  )    ;  Elements  media  =  doc  .  select  (   "[src] "  )  ;  Elements  imports  =  doc  .  select  (   "link[href] "  )  ;    print  (   "\nMedia:  (  %d  )   "  ,  media  .  size  (  )  )  ;  for  (  Element  src  :  media  )  {  if  (  src  .  tagName  (  )  .  equals  (   "img "  )  )  print  (   "  *  %s:  <%s>  %sx%s  (  %s  )   "  ,  src  .  tagName  (  )  ,  src  .  attr  (   "abs:src "  )  ,  src  .  attr  (   "width "  )  ,  src  .  attr  (   "height "  )  ,  trim  (  src  .  attr  (   "alt "  )  ,  20  )  )  ;  else  print  (   "  *  %s:  <%s> "  ,  src  .  tagName  (  )  ,  src  .  attr  (   "abs:src "  )  )  ;  }  print  (   "\nImports:  (  %d  )   "  ,  imports  .  size  (  )  )  ;  for  (  Element  link  :  imports  )  {  print  (   "  *  %s  <%s>  (  %s  )   "  ,  link  .  tagName  (  )  ,  link  .  attr  (   "abs:href "  )  ,  link  .  attr  (   "rel "  )  )  ;  }  print  (   "\nLinks:  (  %d  )   "  ,  links  .  size  (  )  )  ;  for  (  Element  link  :  links  )  {  print  (   "  *  a:  <%s>  (  %s  )   "  ,  link  .  attr  (   "abs:href "  )  ,  trim  (  link  .  text  (  )  ,  35  )  )  ;  }  }    [METHOD]  main  [TYPE]  void  [PARAMETER]  String[]  args  [CLASS]  ListLinks    [TYPE]  boolean  false  true  [TYPE]  Element  link  src  [TYPE]  String[]  args  [TYPE]  Document  doc  [TYPE]  Elements  imports  links  media  [TYPE]  URL  url  
[ADD]  Elements  links  =  doc  .  select  (   "a[href] "  )  ;  Elements  media  =  doc  .  select  (   "[src] "  )  ;	[BUGGY]  [CE]  cannot  find  symbol  media  [CONTEXT]  public  static  void  main  (  String[]  args  )  throws  IOException  {  Validate  .  isTrue  (  args  .  length  =  =  1  ,   "usage:  supply  url  to  fetch "  )  ;  URL  url  =  new  URL  (  args[0]  )  ;  print  (   "Fetching  %s  .  .  .   "  ,  url  .  toExternalForm  (  )  )  ;    Document  doc  =  Jsoup  .  parse  (  url  ,  3*1000  )  ;  [ATTENTION]    Elements  imports  =  doc  .  select  (   "link[href] "  )  ;    print  (   "\nMedia:  (  %d  )   "  ,  media  .  size  (  )  )  ;  for  (  Element  src  :  media  )  {  if  (  src  .  tagName  (  )  .  equals  (   "img "  )  )  print  (   "  *  %s:  <%s>  %sx%s  (  %s  )   "  ,  src  .  tagName  (  )  ,  src  .  attr  (   "abs:src "  )  ,  src  .  attr  (   "width "  )  ,  src  .  attr  (   "height "  )  ,  trim  (  src  .  attr  (   "alt "  )  ,  20  )  )  ;  else  print  (   "  *  %s:  <%s> "  ,  src  .  tagName  (  )  ,  src  .  attr  (   "abs:src "  )  )  ;  }  print  (   "\nImports:  (  %d  )   "  ,  imports  .  size  (  )  )  ;  for  (  Element  link  :  imports  )  {  print  (   "  *  %s  <%s>  (  %s  )   "  ,  link  .  tagName  (  )  ,  link  .  attr  (   "abs:href "  )  ,  link  .  attr  (   "rel "  )  )  ;  }  print  (   "\nLinks:  (  %d  )   "  ,  links  .  size  (  )  )  ;  for  (  Element  link  :  links  )  {  print  (   "  *  a:  <%s>  (  %s  )   "  ,  link  .  attr  (   "abs:href "  )  ,  trim  (  link  .  text  (  )  ,  35  )  )  ;  }  }    [METHOD]  main  [TYPE]  void  [PARAMETER]  String[]  args  [CLASS]  ListLinks    [TYPE]  boolean  false  true  [TYPE]  Element  link  src  [TYPE]  String[]  args  [TYPE]  Document  doc  [TYPE]  Elements  imports  links  media  [TYPE]  URL  url  
[REPLACE]  Elements  media  =  doc  .  select  (   "[src] "  )  ;	[BUGGY]  Elements  links  =  doc  .  select  (   "a[href] "  )  ;  [CE]  variable  links  is  already  defined  in  method  main(String[])  [CONTEXT]  public  static  void  main  (  String[]  args  )  throws  IOException  {  Validate  .  isTrue  (  args  .  length  =  =  1  ,   "usage:  supply  url  to  fetch "  )  ;  URL  url  =  new  URL  (  args[0]  )  ;  print  (   "Fetching  %s  .  .  .   "  ,  url  .  toExternalForm  (  )  )  ;    Document  doc  =  Jsoup  .  parse  (  url  ,  3*1000  )  ;  Elements  links  =  doc  .  select  (   "a[href] "  )  ;  [ATTENTION]  Elements  links  =  doc  .  select  (   "a[href] "  )    ;  Elements  imports  =  doc  .  select  (   "link[href] "  )  ;    print  (   "\nMedia:  (  %d  )   "  ,  media  .  size  (  )  )  ;  for  (  Element  src  :  media  )  {  if  (  src  .  tagName  (  )  .  equals  (   "img "  )  )  print  (   "  *  %s:  <%s>  %sx%s  (  %s  )   "  ,  src  .  tagName  (  )  ,  src  .  attr  (   "abs:src "  )  ,  src  .  attr  (   "width "  )  ,  src  .  attr  (   "height "  )  ,  trim  (  src  .  attr  (   "alt "  )  ,  20  )  )  ;  else  print  (   "  *  %s:  <%s> "  ,  src  .  tagName  (  )  ,  src  .  attr  (   "abs:src "  )  )  ;  }  print  (   "\nImports:  (  %d  )   "  ,  imports  .  size  (  )  )  ;  for  (  Element  link  :  imports  )  {  print  (   "  *  %s  <%s>  (  %s  )   "  ,  link  .  tagName  (  )  ,  link  .  attr  (   "abs:href "  )  ,  link  .  attr  (   "rel "  )  )  ;  }  print  (   "\nLinks:  (  %d  )   "  ,  links  .  size  (  )  )  ;  for  (  Element  link  :  links  )  {  print  (   "  *  a:  <%s>  (  %s  )   "  ,  link  .  attr  (   "abs:href "  )  ,  trim  (  link  .  text  (  )  ,  35  )  )  ;  }  }    [METHOD]  main  [TYPE]  void  [PARAMETER]  String[]  args  [CLASS]  ListLinks    [TYPE]  boolean  false  true  [TYPE]  Element  link  src  [TYPE]  String[]  args  [TYPE]  Document  doc  [TYPE]  Elements  imports  links  media  [TYPE]  URL  url  
[REPLACE]  Elements  imports  =  doc  .  select  (   "link[href] "  )  ;	[BUGGY]  Elements  media  =  doc  .  select  (   "[src] "  )  ;  [CE]  variable  media  is  already  defined  in  method  main(String[])  [CONTEXT]  public  static  void  main  (  String[]  args  )  throws  IOException  {  Validate  .  isTrue  (  args  .  length  =  =  1  ,   "usage:  supply  url  to  fetch "  )  ;  URL  url  =  new  URL  (  args[0]  )  ;  print  (   "Fetching  %s  .  .  .   "  ,  url  .  toExternalForm  (  )  )  ;    Document  doc  =  Jsoup  .  parse  (  url  ,  3*1000  )  ;  Elements  links  =  doc  .  select  (   "a[href] "  )  ;  Elements  media  =  doc  .  select  (   "[src] "  )  ;  [ATTENTION]  Elements  media  =  doc  .  select  (   "[src] "  )    ;    print  (   "\nMedia:  (  %d  )   "  ,  media  .  size  (  )  )  ;  for  (  Element  src  :  media  )  {  if  (  src  .  tagName  (  )  .  equals  (   "img "  )  )  print  (   "  *  %s:  <%s>  %sx%s  (  %s  )   "  ,  src  .  tagName  (  )  ,  src  .  attr  (   "abs:src "  )  ,  src  .  attr  (   "width "  )  ,  src  .  attr  (   "height "  )  ,  trim  (  src  .  attr  (   "alt "  )  ,  20  )  )  ;  else  print  (   "  *  %s:  <%s> "  ,  src  .  tagName  (  )  ,  src  .  attr  (   "abs:src "  )  )  ;  }  print  (   "\nImports:  (  %d  )   "  ,  imports  .  size  (  )  )  ;  for  (  Element  link  :  imports  )  {  print  (   "  *  %s  <%s>  (  %s  )   "  ,  link  .  tagName  (  )  ,  link  .  attr  (   "abs:href "  )  ,  link  .  attr  (   "rel "  )  )  ;  }  print  (   "\nLinks:  (  %d  )   "  ,  links  .  size  (  )  )  ;  for  (  Element  link  :  links  )  {  print  (   "  *  a:  <%s>  (  %s  )   "  ,  link  .  attr  (   "abs:href "  )  ,  trim  (  link  .  text  (  )  ,  35  )  )  ;  }  }    [METHOD]  main  [TYPE]  void  [PARAMETER]  String[]  args  [CLASS]  ListLinks    [TYPE]  boolean  false  true  [TYPE]  Element  link  src  [TYPE]  String[]  args  [TYPE]  Document  doc  [TYPE]  Elements  imports  links  media  [TYPE]  URL  url  
[ADD]  Elements  imports  =  doc  .  select  (   "link[href] "  )  ;	[BUGGY]  [CE]  cannot  find  symbol  imports  [CONTEXT]  public  static  void  main  (  String[]  args  )  throws  IOException  {  Validate  .  isTrue  (  args  .  length  =  =  1  ,   "usage:  supply  url  to  fetch "  )  ;  URL  url  =  new  URL  (  args[0]  )  ;  print  (   "Fetching  %s  .  .  .   "  ,  url  .  toExternalForm  (  )  )  ;    Document  doc  =  Jsoup  .  parse  (  url  ,  3*1000  )  ;  Elements  links  =  doc  .  select  (   "a[href] "  )  ;  Elements  media  =  doc  .  select  (   "[src] "  )  ;  [ATTENTION]    print  (   "\nMedia:  (  %d  )   "  ,  media  .  size  (  )  )  ;  for  (  Element  src  :  media  )  {  if  (  src  .  tagName  (  )  .  equals  (   "img "  )  )  print  (   "  *  %s:  <%s>  %sx%s  (  %s  )   "  ,  src  .  tagName  (  )  ,  src  .  attr  (   "abs:src "  )  ,  src  .  attr  (   "width "  )  ,  src  .  attr  (   "height "  )  ,  trim  (  src  .  attr  (   "alt "  )  ,  20  )  )  ;  else  print  (   "  *  %s:  <%s> "  ,  src  .  tagName  (  )  ,  src  .  attr  (   "abs:src "  )  )  ;  }  print  (   "\nImports:  (  %d  )   "  ,  imports  .  size  (  )  )  ;  for  (  Element  link  :  imports  )  {  print  (   "  *  %s  <%s>  (  %s  )   "  ,  link  .  tagName  (  )  ,  link  .  attr  (   "abs:href "  )  ,  link  .  attr  (   "rel "  )  )  ;  }  print  (   "\nLinks:  (  %d  )   "  ,  links  .  size  (  )  )  ;  for  (  Element  link  :  links  )  {  print  (   "  *  a:  <%s>  (  %s  )   "  ,  link  .  attr  (   "abs:href "  )  ,  trim  (  link  .  text  (  )  ,  35  )  )  ;  }  }    [METHOD]  main  [TYPE]  void  [PARAMETER]  String[]  args  [CLASS]  ListLinks    [TYPE]  boolean  false  true  [TYPE]  Element  link  src  [TYPE]  String[]  args  [TYPE]  Document  doc  [TYPE]  Elements  imports  links  media  [TYPE]  URL  url  
[REPLACE]  print  (   "\nMedia:  (  %d  )   ",  media  .  size  (  )  )  ;	[BUGGY]  print  (   "\nMedia:  (  %d  )   "  ,  imports  .  size  (  )  )  ;  [NO-ERROR]  [CONTEXT]  public  static  void  main  (  String[]  args  )  throws  IOException  {  Validate  .  isTrue  (  args  .  length  =  =  1  ,   "usage:  supply  url  to  fetch "  )  ;  URL  url  =  new  URL  (  args[0]  )  ;  print  (   "Fetching  %s  .  .  .   "  ,  url  .  toExternalForm  (  )  )  ;    Document  doc  =  Jsoup  .  parse  (  url  ,  3*1000  )  ;  Elements  links  =  doc  .  select  (   "a[href] "  )  ;  Elements  media  =  doc  .  select  (   "[src] "  )  ;  Elements  imports  =  doc  .  select  (   "link[href] "  )  ;    [ATTENTION]  print  (   "\nMedia:  (  %d  )   "  ,  imports  .  size  (  )  )    ;  for  (  Element  src  :  media  )  {  if  (  src  .  tagName  (  )  .  equals  (   "img "  )  )  print  (   "  *  %s:  <%s>  %sx%s  (  %s  )   "  ,  src  .  tagName  (  )  ,  src  .  attr  (   "abs:src "  )  ,  src  .  attr  (   "width "  )  ,  src  .  attr  (   "height "  )  ,  trim  (  src  .  attr  (   "alt "  )  ,  20  )  )  ;  else  print  (   "  *  %s:  <%s> "  ,  src  .  tagName  (  )  ,  src  .  attr  (   "abs:src "  )  )  ;  }  print  (   "\nImports:  (  %d  )   "  ,  imports  .  size  (  )  )  ;  for  (  Element  link  :  imports  )  {  print  (   "  *  %s  <%s>  (  %s  )   "  ,  link  .  tagName  (  )  ,  link  .  attr  (   "abs:href "  )  ,  link  .  attr  (   "rel "  )  )  ;  }  print  (   "\nLinks:  (  %d  )   "  ,  links  .  size  (  )  )  ;  for  (  Element  link  :  links  )  {  print  (   "  *  a:  <%s>  (  %s  )   "  ,  link  .  attr  (   "abs:href "  )  ,  trim  (  link  .  text  (  )  ,  35  )  )  ;  }  }    [METHOD]  main  [TYPE]  void  [PARAMETER]  String[]  args  [CLASS]  ListLinks    [TYPE]  boolean  false  true  [TYPE]  Element  link  src  [TYPE]  String[]  args  [TYPE]  Document  doc  [TYPE]  Elements  imports  links  media  [TYPE]  URL  url  
[ADD]  print  (   "\nMedia:  (  %d  )   ",  media  .  size  (  )  )  ;	[BUGGY]  [NO-ERROR]  [CONTEXT]  public  static  void  main  (  String[]  args  )  throws  IOException  {  Validate  .  isTrue  (  args  .  length  =  =  1  ,   "usage:  supply  url  to  fetch "  )  ;  URL  url  =  new  URL  (  args[0]  )  ;  print  (   "Fetching  %s  .  .  .   "  ,  url  .  toExternalForm  (  )  )  ;    Document  doc  =  Jsoup  .  parse  (  url  ,  3*1000  )  ;  Elements  links  =  doc  .  select  (   "a[href] "  )  ;  Elements  media  =  doc  .  select  (   "[src] "  )  ;  Elements  imports  =  doc  .  select  (   "link[href] "  )  ;    [ATTENTION]  for  (  Element  src  :  media  )  {  if  (  src  .  tagName  (  )  .  equals  (   "img "  )  )  print  (   "  *  %s:  <%s>  %sx%s  (  %s  )   "  ,  src  .  tagName  (  )  ,  src  .  attr  (   "abs:src "  )  ,  src  .  attr  (   "width "  )  ,  src  .  attr  (   "height "  )  ,  trim  (  src  .  attr  (   "alt "  )  ,  20  )  )  ;  else  print  (   "  *  %s:  <%s> "  ,  src  .  tagName  (  )  ,  src  .  attr  (   "abs:src "  )  )  ;  }  print  (   "\nImports:  (  %d  )   "  ,  imports  .  size  (  )  )  ;  for  (  Element  link  :  imports  )  {  print  (   "  *  %s  <%s>  (  %s  )   "  ,  link  .  tagName  (  )  ,  link  .  attr  (   "abs:href "  )  ,  link  .  attr  (   "rel "  )  )  ;  }  print  (   "\nLinks:  (  %d  )   "  ,  links  .  size  (  )  )  ;  for  (  Element  link  :  links  )  {  print  (   "  *  a:  <%s>  (  %s  )   "  ,  link  .  attr  (   "abs:href "  )  ,  trim  (  link  .  text  (  )  ,  35  )  )  ;  }  }    [METHOD]  main  [TYPE]  void  [PARAMETER]  String[]  args  [CLASS]  ListLinks    [TYPE]  boolean  false  true  [TYPE]  Element  link  src  [TYPE]  String[]  args  [TYPE]  Document  doc  [TYPE]  Elements  imports  links  media  [TYPE]  URL  url  
[ADD]  if  (  src  .  tagName  (  )    .  equals  (   "img "  )  )  print  (   "  *  %s:  <%s>  %sx%s  (  %s  )   ",  src  .  tagName  (  )  ,  src  .  attr  (   "abs:src "  )  ,  src  .  attr  (   "width "  )  ,  src  .  attr  (   "height "  )  ,  trim  (  src  .  attr  (   "alt "  )  ,  20  )  )  ;  else	[BUGGY]  [NO-ERROR]  [CONTEXT]  public  static  void  main  (  String[]  args  )  throws  IOException  {  Validate  .  isTrue  (  args  .  length  =  =  1  ,   "usage:  supply  url  to  fetch "  )  ;  URL  url  =  new  URL  (  args[0]  )  ;  print  (   "Fetching  %s  .  .  .   "  ,  url  .  toExternalForm  (  )  )  ;    Document  doc  =  Jsoup  .  parse  (  url  ,  3*1000  )  ;  Elements  links  =  doc  .  select  (   "a[href] "  )  ;  Elements  media  =  doc  .  select  (   "[src] "  )  ;  Elements  imports  =  doc  .  select  (   "link[href] "  )  ;    print  (   "\nMedia:  (  %d  )   "  ,  media  .  size  (  )  )  ;  for  (  Element  src  :  media  )  {  [ATTENTION]      print  (   "  *  %s:  <%s> "  ,  src  .  tagName  (  )  ,  src  .  attr  (   "abs:src "  )  )  ;  }  print  (   "\nImports:  (  %d  )   "  ,  imports  .  size  (  )  )  ;  for  (  Element  link  :  imports  )  {  print  (   "  *  %s  <%s>  (  %s  )   "  ,  link  .  tagName  (  )  ,  link  .  attr  (   "abs:href "  )  ,  link  .  attr  (   "rel "  )  )  ;  }  print  (   "\nLinks:  (  %d  )   "  ,  links  .  size  (  )  )  ;  for  (  Element  link  :  links  )  {  print  (   "  *  a:  <%s>  (  %s  )   "  ,  link  .  attr  (   "abs:href "  )  ,  trim  (  link  .  text  (  )  ,  35  )  )  ;  }  }    [METHOD]  main  [TYPE]  void  [PARAMETER]  String[]  args  [CLASS]  ListLinks    [TYPE]  boolean  false  true  [TYPE]  Element  link  src  [TYPE]  String[]  args  [TYPE]  Document  doc  [TYPE]  Elements  imports  links  media  [TYPE]  URL  url  
[REPLACE]  print  (   "  *  %s:  <%s> ",  src  .  tagName  (  )  ,  src  .  attr  (   "abs:src "  )  )  ;	[BUGGY]  print  (   "  *  %s:  <%s> "  ,  src  .  text  (  )  ,  src  .  attr  (   "abs:src "  )  )  ;  [NO-ERROR]  [CONTEXT]  public  static  void  main  (  String[]  args  )  throws  IOException  {  Validate  .  isTrue  (  args  .  length  =  =  1  ,   "usage:  supply  url  to  fetch "  )  ;  URL  url  =  new  URL  (  args[0]  )  ;  print  (   "Fetching  %s  .  .  .   "  ,  url  .  toExternalForm  (  )  )  ;    Document  doc  =  Jsoup  .  parse  (  url  ,  3*1000  )  ;  Elements  links  =  doc  .  select  (   "a[href] "  )  ;  Elements  media  =  doc  .  select  (   "[src] "  )  ;  Elements  imports  =  doc  .  select  (   "link[href] "  )  ;    print  (   "\nMedia:  (  %d  )   "  ,  media  .  size  (  )  )  ;  for  (  Element  src  :  media  )  {  if  (  src  .  tagName  (  )  .  equals  (   "img "  )  )  print  (   "  *  %s:  <%s>  %sx%s  (  %s  )   "  ,  src  .  tagName  (  )  ,  src  .  attr  (   "abs:src "  )  ,  src  .  attr  (   "width "  )  ,  src  .  attr  (   "height "  )  ,  trim  (  src  .  attr  (   "alt "  )  ,  20  )  )  ;  else  [ATTENTION]  print  (   "  *  %s:  <%s> "  ,  src  .  text  (  )    ,  src  .  attr  (   "abs:src "  )  )    ;  }  print  (   "\nImports:  (  %d  )   "  ,  imports  .  size  (  )  )  ;  for  (  Element  link  :  imports  )  {  print  (   "  *  %s  <%s>  (  %s  )   "  ,  link  .  tagName  (  )  ,  link  .  attr  (   "abs:href "  )  ,  link  .  attr  (   "rel "  )  )  ;  }  print  (   "\nLinks:  (  %d  )   "  ,  links  .  size  (  )  )  ;  for  (  Element  link  :  links  )  {  print  (   "  *  a:  <%s>  (  %s  )   "  ,  link  .  attr  (   "abs:href "  )  ,  trim  (  link  .  text  (  )  ,  35  )  )  ;  }  }    [METHOD]  main  [TYPE]  void  [PARAMETER]  String[]  args  [CLASS]  ListLinks    [TYPE]  boolean  false  true  [TYPE]  Element  link  src  [TYPE]  String[]  args  [TYPE]  Document  doc  [TYPE]  Elements  imports  links  media  [TYPE]  URL  url  
[ADD]  print  (   "  *  %s:  <%s> ",  src  .  tagName  (  )  ,  src  .  attr  (   "abs:src "  )  )  ;	[BUGGY]  [CE]  illegal  start  of  expression  [CONTEXT]  public  static  void  main  (  String[]  args  )  throws  IOException  {  Validate  .  isTrue  (  args  .  length  =  =  1  ,   "usage:  supply  url  to  fetch "  )  ;  URL  url  =  new  URL  (  args[0]  )  ;  print  (   "Fetching  %s  .  .  .   "  ,  url  .  toExternalForm  (  )  )  ;    Document  doc  =  Jsoup  .  parse  (  url  ,  3*1000  )  ;  Elements  links  =  doc  .  select  (   "a[href] "  )  ;  Elements  media  =  doc  .  select  (   "[src] "  )  ;  Elements  imports  =  doc  .  select  (   "link[href] "  )  ;    print  (   "\nMedia:  (  %d  )   "  ,  media  .  size  (  )  )  ;  for  (  Element  src  :  media  )  {  if  (  src  .  tagName  (  )  .  equals  (   "img "  )  )  print  (   "  *  %s:  <%s>  %sx%s  (  %s  )   "  ,  src  .  tagName  (  )  ,  src  .  attr  (   "abs:src "  )  ,  src  .  attr  (   "width "  )  ,  src  .  attr  (   "height "  )  ,  trim  (  src  .  attr  (   "alt "  )  ,  20  )  )  ;  else  [ATTENTION]  }  print  (   "\nImports:  (  %d  )   "  ,  imports  .  size  (  )  )  ;  for  (  Element  link  :  imports  )  {  print  (   "  *  %s  <%s>  (  %s  )   "  ,  link  .  tagName  (  )  ,  link  .  attr  (   "abs:href "  )  ,  link  .  attr  (   "rel "  )  )  ;  }  print  (   "\nLinks:  (  %d  )   "  ,  links  .  size  (  )  )  ;  for  (  Element  link  :  links  )  {  print  (   "  *  a:  <%s>  (  %s  )   "  ,  link  .  attr  (   "abs:href "  )  ,  trim  (  link  .  text  (  )  ,  35  )  )  ;  }  }    [METHOD]  main  [TYPE]  void  [PARAMETER]  String[]  args  [CLASS]  ListLinks    [TYPE]  boolean  false  true  [TYPE]  Element  link  src  [TYPE]  String[]  args  [TYPE]  Document  doc  [TYPE]  Elements  imports  links  media  [TYPE]  URL  url  
[REPLACE]  print  (   "  *  %s:  <%s> ",  src  .  tagName  (  )  ,  src  .  attr  (   "abs:src "  )  )  ;	[BUGGY]  print  (   "  *  %s:  <%s> "  ,  src  .  tagName  (  )  ,  src  .  tagName  (  )    )  ;  [NO-ERROR]  [CONTEXT]  public  static  void  main  (  String[]  args  )  throws  IOException  {  Validate  .  isTrue  (  args  .  length  =  =  1  ,   "usage:  supply  url  to  fetch "  )  ;  URL  url  =  new  URL  (  args[0]  )  ;  print  (   "Fetching  %s  .  .  .   "  ,  url  .  toExternalForm  (  )  )  ;    Document  doc  =  Jsoup  .  parse  (  url  ,  3*1000  )  ;  Elements  links  =  doc  .  select  (   "a[href] "  )  ;  Elements  media  =  doc  .  select  (   "[src] "  )  ;  Elements  imports  =  doc  .  select  (   "link[href] "  )  ;    print  (   "\nMedia:  (  %d  )   "  ,  media  .  size  (  )  )  ;  for  (  Element  src  :  media  )  {  if  (  src  .  tagName  (  )  .  equals  (   "img "  )  )  print  (   "  *  %s:  <%s>  %sx%s  (  %s  )   "  ,  src  .  tagName  (  )  ,  src  .  attr  (   "abs:src "  )  ,  src  .  attr  (   "width "  )  ,  src  .  attr  (   "height "  )  ,  trim  (  src  .  attr  (   "alt "  )  ,  20  )  )  ;  else  [ATTENTION]  print  (   "  *  %s:  <%s> "  ,  src  .  tagName  (  )    ,  src  .  tagName  (  )    )    ;  }  print  (   "\nImports:  (  %d  )   "  ,  imports  .  size  (  )  )  ;  for  (  Element  link  :  imports  )  {  print  (   "  *  %s  <%s>  (  %s  )   "  ,  link  .  tagName  (  )  ,  link  .  attr  (   "abs:href "  )  ,  link  .  attr  (   "rel "  )  )  ;  }  print  (   "\nLinks:  (  %d  )   "  ,  links  .  size  (  )  )  ;  for  (  Element  link  :  links  )  {  print  (   "  *  a:  <%s>  (  %s  )   "  ,  link  .  attr  (   "abs:href "  )  ,  trim  (  link  .  text  (  )  ,  35  )  )  ;  }  }    [METHOD]  main  [TYPE]  void  [PARAMETER]  String[]  args  [CLASS]  ListLinks    [TYPE]  boolean  false  true  [TYPE]  Element  link  src  [TYPE]  String[]  args  [TYPE]  Document  doc  [TYPE]  Elements  imports  links  media  [TYPE]  URL  url  
[REMOVE]  	[BUGGY]  print  (   "  *  %s:  <%s>  %sx%s  (  %s  )   "  ,  [CE]  illegal  start  of  expression  [CONTEXT]  public  static  void  main  (  String[]  args  )  throws  IOException  {  Validate  .  isTrue  (  args  .  length  =  =  1  ,   "usage:  supply  url  to  fetch "  )  ;  URL  url  =  new  URL  (  args[0]  )  ;  print  (   "Fetching  %s  .  .  .   "  ,  url  .  toExternalForm  (  )  )  ;    Document  doc  =  Jsoup  .  parse  (  url  ,  3*1000  )  ;  Elements  links  =  doc  .  select  (   "a[href] "  )  ;  Elements  media  =  doc  .  select  (   "[src] "  )  ;  Elements  imports  =  doc  .  select  (   "link[href] "  )  ;    print  (   "\nMedia:  (  %d  )   "  ,  media  .  size  (  )  )  ;  for  (  Element  src  :  media  )  {  if  (  src  .  tagName  (  )  .  equals  (   "img "  )  )  print  (   "  *  %s:  <%s>  %sx%s  (  %s  )   "  ,  src  .  tagName  (  )  ,  src  .  attr  (   "abs:src "  )  ,  src  .  attr  (   "width "  )  ,  src  .  attr  (   "height "  )  ,  trim  (  src  .  attr  (   "alt "  )  ,  20  )  )  ;  else  [ATTENTION]  print  (   "  *  %s:  <%s> "  ,  src  .  tagName  (  )  ,  src  .  attr  (   "abs:src "  )  )  ;    print  (   "  *  %s:  <%s>  %sx%s  (  %s  )   "  ,  }  print  (   "\nImports:  (  %d  )   "  ,  imports  .  size  (  )  )  ;  for  (  Element  link  :  imports  )  {  print  (   "  *  %s  <%s>  (  %s  )   "  ,  link  .  tagName  (  )  ,  link  .  attr  (   "abs:href "  )  ,  link  .  attr  (   "rel "  )  )  ;  }  print  (   "\nLinks:  (  %d  )   "  ,  links  .  size  (  )  )  ;  for  (  Element  link  :  links  )  {  print  (   "  *  a:  <%s>  (  %s  )   "  ,  link  .  attr  (   "abs:href "  )  ,  trim  (  link  .  text  (  )  ,  35  )  )  ;  }    [METHOD]  main  [TYPE]  void  [PARAMETER]  String[]  args  [CLASS]  ListLinks    [TYPE]  boolean  false  true  [TYPE]  Element  link  src  [TYPE]  String[]  args  [TYPE]  Document  doc  [TYPE]  Elements  imports  links  media  [TYPE]  URL  url  
[REPLACE]  print  (   "  *  %s:  <%s>  %sx%s  (  %s  )   ",  src  .  tagName  (  )  ,  src  .  attr  (   "abs:src "  )  ,  src  .  attr  (   "width "  )  ,  src  .  attr  (   "height "  )  ,  trim  (  src  .  attr  (   "alt "  )  ,  20  )  )  ;	[BUGGY]  print  (   "  *  %s:  <%s>  %sx%s  (  %s  )   "  ,  src  .  text  (  )  ,  src  .  attr  (   "abs:src "  )  ,  src  .  attr  (   "width "  )  ,  src  .  attr  (   "height "  )  ,  trim  (  src  .  attr  (   "alt "  )  ,  20  )  )  ;  [NO-ERROR]  [CONTEXT]  public  static  void  main  (  String[]  args  )  throws  IOException  {  Validate  .  isTrue  (  args  .  length  =  =  1  ,   "usage:  supply  url  to  fetch "  )  ;  URL  url  =  new  URL  (  args[0]  )  ;  print  (   "Fetching  %s  .  .  .   "  ,  url  .  toExternalForm  (  )  )  ;    Document  doc  =  Jsoup  .  parse  (  url  ,  3*1000  )  ;  Elements  links  =  doc  .  select  (   "a[href] "  )  ;  Elements  media  =  doc  .  select  (   "[src] "  )  ;  Elements  imports  =  doc  .  select  (   "link[href] "  )  ;    print  (   "\nMedia:  (  %d  )   "  ,  media  .  size  (  )  )  ;  for  (  Element  src  :  media  )  {  if  (  src  .  tagName  (  )  .  equals  (   "img "  )  )  [ATTENTION]  print  (   "  *  %s:  <%s>  %sx%s  (  %s  )   "  ,  src  .  text  (  )    ,  src  .  attr  (   "abs:src "  )    ,  src  .  attr  (   "width "  )    ,  src  .  attr  (   "height "  )    ,  trim  (  src  .  attr  (   "alt "  )    ,  20  )  )    ;    else  print  (   "  *  %s:  <%s> "  ,  src  .  tagName  (  )  ,  src  .  attr  (   "abs:src "  )  )  ;  }  print  (   "\nImports:  (  %d  )   "  ,  imports  .  size  (  )  )  ;  for  (  Element  link  :  imports  )  {  print  (   "  *  %s  <%s>  (  %s  )   "  ,  link  .  tagName  (  )  ,  link  .  attr  (   "abs:href "  )  ,  link  .  attr  (   "rel "  )  )  ;  }  print  (   "\nLinks:  (  %d  )   "  ,  links  .  size  (  )  )  ;  for  (  Element  link  :  links  )  {  print  (   "  *  a:  <%s>  (  %s  )   "  ,  link  .  attr  (   "abs:href "  )  ,  trim  (  link  .  text  (  )  ,  35  )  )  ;  }  }    [METHOD]  main  [TYPE]  void  [PARAMETER]  String[]  args  [CLASS]  ListLinks    [TYPE]  boolean  false  true  [TYPE]  Element  link  src  [TYPE]  String[]  args  [TYPE]  Document  doc  [TYPE]  Elements  imports  links  media  [TYPE]  URL  url  
[ADD]  print  (   "  *  %s:  <%s>  %sx%s  (  %s  )   ",  src  .  tagName  (  )  ,  src  .  attr  (   "abs:src "  )  ,  src  .  attr  (   "width "  )  ,  src  .  attr  (   "height "  )  ,  trim  (  src  .  attr  (   "alt "  )  ,  20  )  )  ;	[BUGGY]  [CE]  'else'  without  'if'  [CONTEXT]  public  static  void  main  (  String[]  args  )  throws  IOException  {  Validate  .  isTrue  (  args  .  length  =  =  1  ,   "usage:  supply  url  to  fetch "  )  ;  URL  url  =  new  URL  (  args[0]  )  ;  print  (   "Fetching  %s  .  .  .   "  ,  url  .  toExternalForm  (  )  )  ;    Document  doc  =  Jsoup  .  parse  (  url  ,  3*1000  )  ;  Elements  links  =  doc  .  select  (   "a[href] "  )  ;  Elements  media  =  doc  .  select  (   "[src] "  )  ;  Elements  imports  =  doc  .  select  (   "link[href] "  )  ;    print  (   "\nMedia:  (  %d  )   "  ,  media  .  size  (  )  )  ;  for  (  Element  src  :  media  )  {  if  (  src  .  tagName  (  )  .  equals  (   "img "  )  )  [ATTENTION]    else  print  (   "  *  %s:  <%s> "  ,  src  .  tagName  (  )  ,  src  .  attr  (   "abs:src "  )  )  ;  }  print  (   "\nImports:  (  %d  )   "  ,  imports  .  size  (  )  )  ;  for  (  Element  link  :  imports  )  {  print  (   "  *  %s  <%s>  (  %s  )   "  ,  link  .  tagName  (  )  ,  link  .  attr  (   "abs:href "  )  ,  link  .  attr  (   "rel "  )  )  ;  }  print  (   "\nLinks:  (  %d  )   "  ,  links  .  size  (  )  )  ;  for  (  Element  link  :  links  )  {  print  (   "  *  a:  <%s>  (  %s  )   "  ,  link  .  attr  (   "abs:href "  )  ,  trim  (  link  .  text  (  )  ,  35  )  )  ;  }  }    [METHOD]  main  [TYPE]  void  [PARAMETER]  String[]  args  [CLASS]  ListLinks    [TYPE]  boolean  false  true  [TYPE]  Element  link  src  [TYPE]  String[]  args  [TYPE]  Document  doc  [TYPE]  Elements  imports  links  media  [TYPE]  URL  url  
[REPLACE]  src  .  tagName  (  )  ,  src  .  attr  (   "abs:src "  )  ,  src  .  attr  (   "width "  )  ,  src  .  attr  (   "height "  )  ,  trim  (  src  .  attr  (   "alt "  )  ,  20  )  )  ;	[BUGGY]  src  .  text  (  )  ,  src  .  attr  (   "abs:src "  )  ,  src  .  attr  (   "width "  )  ,  src  .  attr  (   "height "  )  ,  trim  (  src  .  attr  (   "alt "  )  ,  20  )  )  ;  [NO-ERROR]  [CONTEXT]  public  static  void  main  (  String[]  args  )  throws  IOException  {  Validate  .  isTrue  (  args  .  length  =  =  1  ,   "usage:  supply  url  to  fetch "  )  ;  URL  url  =  new  URL  (  args[0]  )  ;  print  (   "Fetching  %s  .  .  .   "  ,  url  .  toExternalForm  (  )  )  ;    Document  doc  =  Jsoup  .  parse  (  url  ,  3*1000  )  ;  Elements  links  =  doc  .  select  (   "a[href] "  )  ;  Elements  media  =  doc  .  select  (   "[src] "  )  ;  Elements  imports  =  doc  .  select  (   "link[href] "  )  ;    print  (   "\nMedia:  (  %d  )   "  ,  media  .  size  (  )  )  ;  for  (  Element  src  :  media  )  {  if  (  src  .  tagName  (  )  .  equals  (   "img "  )  )  print  (   "  *  %s:  <%s>  %sx%s  (  %s  )   "  ,  [ATTENTION]  src  .  text  (  )    ,  src  .  attr  (   "abs:src "  )    ,  src  .  attr  (   "width "  )    ,  src  .  attr  (   "height "  )    ,  trim  (  src  .  attr  (   "alt "  )    ,  20  )  )    ;    else  print  (   "  *  %s:  <%s> "  ,  src  .  tagName  (  )  ,  src  .  attr  (   "abs:src "  )  )  ;  }  print  (   "\nImports:  (  %d  )   "  ,  imports  .  size  (  )  )  ;  for  (  Element  link  :  imports  )  {  print  (   "  *  %s  <%s>  (  %s  )   "  ,  link  .  tagName  (  )  ,  link  .  attr  (   "abs:href "  )  ,  link  .  attr  (   "rel "  )  )  ;  }  print  (   "\nLinks:  (  %d  )   "  ,  links  .  size  (  )  )  ;  for  (  Element  link  :  links  )  {  print  (   "  *  a:  <%s>  (  %s  )   "  ,  link  .  attr  (   "abs:href "  )  ,  trim  (  link  .  text  (  )  ,  35  )  )  ;  }  }    [METHOD]  main  [TYPE]  void  [PARAMETER]  String[]  args  [CLASS]  ListLinks    [TYPE]  boolean  false  true  [TYPE]  Element  link  src  [TYPE]  String[]  args  [TYPE]  Document  doc  [TYPE]  Elements  imports  links  media  [TYPE]  URL  url  
[REPLACE]  src  .  tagName  (  )  ,  src  .  attr  (   "abs:src "  )  ,  src  .  attr  (   "width "  )  ,  src  .  attr  (   "height "  )  ,  trim  (  src  .  attr  (   "alt "  )  ,  20  )  )  ;	[BUGGY]  src  .  tagName  (  )  ,  src  .  tagName  (  )    ,  src[CE]  ')'  expected  [CONTEXT]  public  static  void  main  (  String[]  args  )  throws  IOException  {  Validate  .  isTrue  (  args  .  length  =  =  1  ,   "usage:  supply  url  to  fetch "  )  ;  URL  url  =  new  URL  (  args[0]  )  ;  print  (   "Fetching  %s  .  .  .   "  ,  url  .  toExternalForm  (  )  )  ;    Document  doc  =  Jsoup  .  parse  (  url  ,  3*1000  )  ;  Elements  links  =  doc  .  select  (   "a[href] "  )  ;  Elements  media  =  doc  .  select  (   "[src] "  )  ;  Elements  imports  =  doc  .  select  (   "link[href] "  )  ;    print  (   "\nMedia:  (  %d  )   "  ,  media  .  size  (  )  )  ;  for  (  Element  src  :  media  )  {  if  (  src  .  tagName  (  )  .  equals  (   "img "  )  )  print  (   "  *  %s:  <%s>  %sx%s  (  %s  )   "  ,  [ATTENTION]  src  .  tagName  (  )    ,  src  .  tagName  (  )  ,  src  else  print  (   "  *  %s:  <%s> "  ,  src  .  tagName  (  )  ,  src  .  attr  (   "abs:src "  )  )  ;  }  print  (   "\nImports:  (  %d  )   "  ,  imports  .  size  (  )  )  ;  for  (  Element  link  :  imports  )  {  print  (   "  *  %s  <%s>  (  %s  )   "  ,  link  .  tagName  (  )  ,  link  .  attr  (   "abs:href "  )  ,  link  .  attr  (   "rel "  )  )  ;  }  print  (   "\nLinks:  (  %d  )   "  ,  links  .  size  (  )  )  ;  for  (  Element  link  :  links  )  {  print  (   "  *  a:  <%s>  (  %s  )   "  ,  link  .  attr  (   "abs:href "  )  ,  trim  (  link  .  text  (  )  ,  35  )  )  ;  }  }    [METHOD]  main  [TYPE]  void  [PARAMETER]  String[]  args  [CLASS]  ListLinks    [TYPE]  boolean  false  true  [TYPE]  Element  link  src  [TYPE]  String[]  args  [TYPE]  Document  doc  [TYPE]  Elements  imports  links  media  [TYPE]  URL  url  
[ADD]  src  .  tagName  (  )  ,  src  .  attr  (   "abs:src "  )  ,  src  .  attr  (   "width "  )  ,  src  .  attr  (   "height "  )  ,  trim  (  src  .  attr  (   "alt "  )  ,  20  )  )  ;	[BUGGY]  [CE]  illegal  start  of  expression  [CONTEXT]  public  static  void  main  (  String[]  args  )  throws  IOException  {  Validate  .  isTrue  (  args  .  length  =  =  1  ,   "usage:  supply  url  to  fetch "  )  ;  URL  url  =  new  URL  (  args[0]  )  ;  print  (   "Fetching  %s  .  .  .   "  ,  url  .  toExternalForm  (  )  )  ;    Document  doc  =  Jsoup  .  parse  (  url  ,  3*1000  )  ;  Elements  links  =  doc  .  select  (   "a[href] "  )  ;  Elements  media  =  doc  .  select  (   "[src] "  )  ;  Elements  imports  =  doc  .  select  (   "link[href] "  )  ;    print  (   "\nMedia:  (  %d  )   "  ,  media  .  size  (  )  )  ;  for  (  Element  src  :  media  )  {  if  (  src  .  tagName  (  )  .  equals  (   "img "  )  )  print  (   "  *  %s:  <%s>  %sx%s  (  %s  )   "  ,  [ATTENTION]    else  print  (   "  *  %s:  <%s> "  ,  src  .  tagName  (  )  ,  src  .  attr  (   "abs:src "  )  )  ;  }  print  (   "\nImports:  (  %d  )   "  ,  imports  .  size  (  )  )  ;  for  (  Element  link  :  imports  )  {  print  (   "  *  %s  <%s>  (  %s  )   "  ,  link  .  tagName  (  )  ,  link  .  attr  (   "abs:href "  )  ,  link  .  attr  (   "rel "  )  )  ;  }  print  (   "\nLinks:  (  %d  )   "  ,  links  .  size  (  )  )  ;  for  (  Element  link  :  links  )  {  print  (   "  *  a:  <%s>  (  %s  )   "  ,  link  .  attr  (   "abs:href "  )  ,  trim  (  link  .  text  (  )  ,  35  )  )  ;  }  }    [METHOD]  main  [TYPE]  void  [PARAMETER]  String[]  args  [CLASS]  ListLinks    [TYPE]  boolean  false  true  [TYPE]  Element  link  src  [TYPE]  String[]  args  [TYPE]  Document  doc  [TYPE]  Elements  imports  links  media  [TYPE]  URL  url  
[REPLACE]  trim  (  src  .  attr  (   "alt "  )  ,  20  )  )  ;	[BUGGY]  trim  (  src  .  tagName  (  )    ,  20  )  )  ;  [NO-ERROR]  [CONTEXT]  public  static  void  main  (  String[]  args  )  throws  IOException  {  Validate  .  isTrue  (  args  .  length  =  =  1  ,   "usage:  supply  url  to  fetch "  )  ;  URL  url  =  new  URL  (  args[0]  )  ;  print  (   "Fetching  %s  .  .  .   "  ,  url  .  toExternalForm  (  )  )  ;    Document  doc  =  Jsoup  .  parse  (  url  ,  3*1000  )  ;  Elements  links  =  doc  .  select  (   "a[href] "  )  ;  Elements  media  =  doc  .  select  (   "[src] "  )  ;  Elements  imports  =  doc  .  select  (   "link[href] "  )  ;    print  (   "\nMedia:  (  %d  )   "  ,  media  .  size  (  )  )  ;  for  (  Element  src  :  media  )  {  if  (  src  .  tagName  (  )  .  equals  (   "img "  )  )  print  (   "  *  %s:  <%s>  %sx%s  (  %s  )   "  ,  src  .  tagName  (  )  ,  src  .  attr  (   "abs:src "  )  ,  src  .  attr  (   "width "  )  ,  src  .  attr  (   "height "  )  ,  [ATTENTION]  trim  (  src  .  tagName  (  )  ,  20  )  )    ;  else  print  (   "  *  %s:  <%s> "  ,  src  .  tagName  (  )  ,  src  .  attr  (   "abs:src "  )  )  ;  }  print  (   "\nImports:  (  %d  )   "  ,  imports  .  size  (  )  )  ;  for  (  Element  link  :  imports  )  {  print  (   "  *  %s  <%s>  (  %s  )   "  ,  link  .  tagName  (  )  ,  link  .  attr  (   "abs:href "  )  ,  link  .  attr  (   "rel "  )  )  ;  }  print  (   "\nLinks:  (  %d  )   "  ,  links  .  size  (  )  )  ;  for  (  Element  link  :  links  )  {  print  (   "  *  a:  <%s>  (  %s  )   "  ,  link  .  attr  (   "abs:href "  )  ,  trim  (  link  .  text  (  )  ,  35  )  )  ;  }  }    [METHOD]  main  [TYPE]  void  [PARAMETER]  String[]  args  [CLASS]  ListLinks    [TYPE]  boolean  false  true  [TYPE]  Element  link  src  [TYPE]  String[]  args  [TYPE]  Document  doc  [TYPE]  Elements  imports  links  media  [TYPE]  URL  url  
[REPLACE]  trim  (  src  .  attr  (   "alt "  )  ,  20  )  )  ;	[BUGGY]  print  (   "\nImports:  (  %d  )   "  ,  imports  .  size  (  )  )  ;  [CE]  [CONTEXT]  public  static  void  main  (  String[]  args  )  throws  IOException  {  Validate  .  isTrue  (  args  .  length  =  =  1  ,   "usage:  supply  url  to  fetch "  )  ;  URL  url  =  new  URL  (  args[0]  )  ;  print  (   "Fetching  %s  .  .  .   "  ,  url  .  toExternalForm  (  )  )  ;    Document  doc  =  Jsoup  .  parse  (  url  ,  3*1000  )  ;  Elements  links  =  doc  .  select  (   "a[href] "  )  ;  Elements  media  =  doc  .  select  (   "[src] "  )  ;  Elements  imports  =  doc  .  select  (   "link[href] "  )  ;    print  (   "\nMedia:  (  %d  )   "  ,  media  .  size  (  )  )  ;  for  (  Element  src  :  media  )  {  if  (  src  .  tagName  (  )  .  equals  (   "img "  )  )  print  (   "  *  %s:  <%s>  %sx%s  (  %s  )   "  ,  src  .  tagName  (  )  ,  src  .  attr  (   "abs:src "  )  ,  src  .  attr  (   "width "  )  ,  src  .  attr  (   "height "  )  ,  [ATTENTION]  print  (   "\nImports:  (  %d  )   "  ,  imports  .  size  (  )  )    ;  else  print  (   "  *  %s:  <%s> "  ,  src  .  tagName  (  )  ,  src  .  attr  (   "abs:src "  )  )  ;  }  print  (   "\nImports:  (  %d  )   "  ,  imports  .  size  (  )  )  ;  for  (  Element  link  :  imports  )  {  print  (   "  *  %s  <%s>  (  %s  )   "  ,  link  .  tagName  (  )  ,  link  .  attr  (   "abs:href "  )  ,  link  .  attr  (   "rel "  )  )  ;  }  print  (   "\nLinks:  (  %d  )   "  ,  links  .  size  (  )  )  ;  for  (  Element  link  :  links  )  {  print  (   "  *  a:  <%s>  (  %s  )   "  ,  link  .  attr  (   "abs:href "  )  ,  trim  (  link  .  text  (  )  ,  35  )  )  ;  }  }    [METHOD]  main  [TYPE]  void  [PARAMETER]  String[]  args  [CLASS]  ListLinks    [TYPE]  boolean  false  true  [TYPE]  Element  link  src  [TYPE]  String[]  args  [TYPE]  Document  doc  [TYPE]  Elements  imports  links  media  [TYPE]  URL  url  
[REPLACE]  for  (  Element  src  :  media  )  {	[BUGGY]  for  (  Element  src  :  media  )  {  if  (  src  .  tagName  (  )  .  equals  (   "img "  )  )[NO-ERROR]  [CONTEXT]  public  static  void  main  (  String[]  args  )  throws  IOException  {  Validate  .  isTrue  (  args  .  length  =  =  1  ,   "usage:  supply  url  to  fetch "  )  ;  URL  url  =  new  URL  (  args[0]  )  ;  print  (   "Fetching  %s  .  .  .   "  ,  url  .  toExternalForm  (  )  )  ;    Document  doc  =  Jsoup  .  parse  (  url  ,  3*1000  )  ;  Elements  links  =  doc  .  select  (   "a[href] "  )  ;  Elements  media  =  doc  .  select  (   "[src] "  )  ;  Elements  imports  =  doc  .  select  (   "link[href] "  )  ;    print  (   "\nMedia:  (  %d  )   "  ,  media  .  size  (  )  )  ;  [ATTENTION]  for  (  Element  src  :  media  )  {  if  (  src  .  tagName  (  )    .  equals  (   "img "  )  )  if  (  src  .  tagName  (  )  .  equals  (   "img "  )  )  print  (   "  *  %s:  <%s>  %sx%s  (  %s  )   "  ,  src  .  tagName  (  )  ,  src  .  attr  (   "abs:src "  )  ,  src  .  attr  (   "width "  )  ,  src  .  attr  (   "height "  )  ,  trim  (  src  .  attr  (   "alt "  )  ,  20  )  )  ;  else  print  (   "  *  %s:  <%s> "  ,  src  .  tagName  (  )  ,  src  .  attr  (   "abs:src "  )  )  ;  }  print  (   "\nImports:  (  %d  )   "  ,  imports  .  size  (  )  )  ;  for  (  Element  link  :  imports  )  {  print  (   "  *  %s  <%s>  (  %s  )   "  ,  link  .  tagName  (  )  ,  link  .  attr  (   "abs:href "  )  ,  link  .  attr  (   "rel "  )  )  ;  }  print  (   "\nLinks:  (  %d  )   "  ,  links  .  size  (  )  )  ;  for  (  Element  link  :  links  )  {  print  (   "  *  a:  <%s>  (  %s  )   "  ,  link  .  attr  (   "abs:href "  )  ,  trim  (  link  .  text  (  )  ,  35  )  )  ;  }  }    [METHOD]  main  [TYPE]  void  [PARAMETER]  String[]  args  [CLASS]  ListLinks    [TYPE]  boolean  false  true  [TYPE]  Element  link  src  [TYPE]  String[]  args  [TYPE]  Document  doc  [TYPE]  Elements  imports  links  media  [TYPE]  URL  url  
[REPLACE]  print  (   "\nImports:  (  %d  )   ",  imports  .  size  (  )  )  ;	[BUGGY]  print  (   "\nImports:  (  %d  )   "  ,  media  .  size  (  )  )  ;  [NO-ERROR]  [CONTEXT]  public  static  void  main  (  String[]  args  )  throws  IOException  {  Validate  .  isTrue  (  args  .  length  =  =  1  ,   "usage:  supply  url  to  fetch "  )  ;  URL  url  =  new  URL  (  args[0]  )  ;  print  (   "Fetching  %s  .  .  .   "  ,  url  .  toExternalForm  (  )  )  ;    Document  doc  =  Jsoup  .  parse  (  url  ,  3*1000  )  ;  Elements  links  =  doc  .  select  (   "a[href] "  )  ;  Elements  media  =  doc  .  select  (   "[src] "  )  ;  Elements  imports  =  doc  .  select  (   "link[href] "  )  ;    print  (   "\nMedia:  (  %d  )   "  ,  media  .  size  (  )  )  ;  for  (  Element  src  :  media  )  {  if  (  src  .  tagName  (  )  .  equals  (   "img "  )  )  print  (   "  *  %s:  <%s>  %sx%s  (  %s  )   "  ,  src  .  tagName  (  )  ,  src  .  attr  (   "abs:src "  )  ,  src  .  attr  (   "width "  )  ,  src  .  attr  (   "height "  )  ,  trim  (  src  .  attr  (   "alt "  )  ,  20  )  )  ;  else  print  (   "  *  %s:  <%s> "  ,  src  .  tagName  (  )  ,  src  .  attr  (   "abs:src "  )  )  ;  }  [ATTENTION]  print  (   "\nImports:  (  %d  )   "  ,  media  .  size  (  )  )    ;  for  (  Element  link  :  imports  )  {  print  (   "  *  %s  <%s>  (  %s  )   "  ,  link  .  tagName  (  )  ,  link  .  attr  (   "abs:href "  )  ,  link  .  attr  (   "rel "  )  )  ;  }  print  (   "\nLinks:  (  %d  )   "  ,  links  .  size  (  )  )  ;  for  (  Element  link  :  links  )  {  print  (   "  *  a:  <%s>  (  %s  )   "  ,  link  .  attr  (   "abs:href "  )  ,  trim  (  link  .  text  (  )  ,  35  )  )  ;  }  }    [METHOD]  main  [TYPE]  void  [PARAMETER]  String[]  args  [CLASS]  ListLinks    [TYPE]  boolean  false  true  [TYPE]  Element  link  src  [TYPE]  String[]  args  [TYPE]  Document  doc  [TYPE]  Elements  imports  links  media  [TYPE]  URL  url  
[REPLACE]  for  (  Element  link  :  imports  )  {	[BUGGY]  for  (  Element  src  :  media  )  {  if  (  src  .  tagName  (  )  .  equals  (   "img "  )  )[CE]  cannot  find  symbol  link  [CONTEXT]  public  static  void  main  (  String[]  args  )  throws  IOException  {  Validate  .  isTrue  (  args  .  length  =  =  1  ,   "usage:  supply  url  to  fetch "  )  ;  URL  url  =  new  URL  (  args[0]  )  ;  print  (   "Fetching  %s  .  .  .   "  ,  url  .  toExternalForm  (  )  )  ;    Document  doc  =  Jsoup  .  parse  (  url  ,  3*1000  )  ;  Elements  links  =  doc  .  select  (   "a[href] "  )  ;  Elements  media  =  doc  .  select  (   "[src] "  )  ;  Elements  imports  =  doc  .  select  (   "link[href] "  )  ;    print  (   "\nMedia:  (  %d  )   "  ,  media  .  size  (  )  )  ;  for  (  Element  src  :  media  )  {  if  (  src  .  tagName  (  )  .  equals  (   "img "  )  )  print  (   "  *  %s:  <%s>  %sx%s  (  %s  )   "  ,  src  .  tagName  (  )  ,  src  .  attr  (   "abs:src "  )  ,  src  .  attr  (   "width "  )  ,  src  .  attr  (   "height "  )  ,  trim  (  src  .  attr  (   "alt "  )  ,  20  )  )  ;  else  print  (   "  *  %s:  <%s> "  ,  src  .  tagName  (  )  ,  src  .  attr  (   "abs:src "  )  )  ;  }  print  (   "\nImports:  (  %d  )   "  ,  imports  .  size  (  )  )  ;  [ATTENTION]  for  (  Element  src  :  media  )  {  if  (  src  .  tagName  (  )    .  equals  (   "img "  )  )  print  (   "  *  %s  <%s>  (  %s  )   "  ,  link  .  tagName  (  )  ,  link  .  attr  (   "abs:href "  )  ,  link  .  attr  (   "rel "  )  )  ;  }  print  (   "\nLinks:  (  %d  )   "  ,  links  .  size  (  )  )  ;  for  (  Element  link  :  links  )  {  print  (   "  *  a:  <%s>  (  %s  )   "  ,  link  .  attr  (   "abs:href "  )  ,  trim  (  link  .  text  (  )  ,  35  )  )  ;  }  }    [METHOD]  main  [TYPE]  void  [PARAMETER]  String[]  args  [CLASS]  ListLinks    [TYPE]  boolean  false  true  [TYPE]  Element  link  src  [TYPE]  String[]  args  [TYPE]  Document  doc  [TYPE]  Elements  imports  links  media  [TYPE]  URL  url  
[ADD]  for  (  Element  link  :  imports  )  {  print  (   "  *  %s  <%s>  (  %s  )   ",  link  .  tagName  (  )  ,link  .  attr  (   "abs:href "  )  ,  link  .  attr  (   "rel "  )  )  ;  }	[BUGGY]  [NO-ERROR]  [CONTEXT]  public  static  void  main  (  String[]  args  )  throws  IOException  {  Validate  .  isTrue  (  args  .  length  =  =  1  ,   "usage:  supply  url  to  fetch "  )  ;  URL  url  =  new  URL  (  args[0]  )  ;  print  (   "Fetching  %s  .  .  .   "  ,  url  .  toExternalForm  (  )  )  ;    Document  doc  =  Jsoup  .  parse  (  url  ,  3*1000  )  ;  Elements  links  =  doc  .  select  (   "a[href] "  )  ;  Elements  media  =  doc  .  select  (   "[src] "  )  ;  Elements  imports  =  doc  .  select  (   "link[href] "  )  ;    print  (   "\nMedia:  (  %d  )   "  ,  media  .  size  (  )  )  ;  for  (  Element  src  :  media  )  {  if  (  src  .  tagName  (  )  .  equals  (   "img "  )  )  print  (   "  *  %s:  <%s>  %sx%s  (  %s  )   "  ,  src  .  tagName  (  )  ,  src  .  attr  (   "abs:src "  )  ,  src  .  attr  (   "width "  )  ,  src  .  attr  (   "height "  )  ,  trim  (  src  .  attr  (   "alt "  )  ,  20  )  )  ;  else  print  (   "  *  %s:  <%s> "  ,  src  .  tagName  (  )  ,  src  .  attr  (   "abs:src "  )  )  ;  }  print  (   "\nImports:  (  %d  )   "  ,  imports  .  size  (  )  )  ;  [ATTENTION]      print  (   "\nLinks:  (  %d  )   "  ,  links  .  size  (  )  )  ;  for  (  Element  link  :  links  )  {  print  (   "  *  a:  <%s>  (  %s  )   "  ,  link  .  attr  (   "abs:href "  )  ,  trim  (  link  .  text  (  )  ,  35  )  )  ;  }  }    [METHOD]  main  [TYPE]  void  [PARAMETER]  String[]  args  [CLASS]  ListLinks    [TYPE]  boolean  false  true  [TYPE]  Element  link  src  [TYPE]  String[]  args  [TYPE]  Document  doc  [TYPE]  Elements  imports  links  media  [TYPE]  URL  url  
[REPLACE]  print  (   "\nLinks:  (  %d  )   ",  links  .  size  (  )  )  ;	[BUGGY]  print  (   "\nLinks:  (  %d  )   "  ,  imports  .  size  (  )  )  ;  [NO-ERROR]  [CONTEXT]  public  static  void  main  (  String[]  args  )  throws  IOException  {  Validate  .  isTrue  (  args  .  length  =  =  1  ,   "usage:  supply  url  to  fetch "  )  ;  URL  url  =  new  URL  (  args[0]  )  ;  print  (   "Fetching  %s  .  .  .   "  ,  url  .  toExternalForm  (  )  )  ;    Document  doc  =  Jsoup  .  parse  (  url  ,  3*1000  )  ;  Elements  links  =  doc  .  select  (   "a[href] "  )  ;  Elements  media  =  doc  .  select  (   "[src] "  )  ;  Elements  imports  =  doc  .  select  (   "link[href] "  )  ;    print  (   "\nMedia:  (  %d  )   "  ,  media  .  size  (  )  )  ;  for  (  Element  src  :  media  )  {  if  (  src  .  tagName  (  )  .  equals  (   "img "  )  )  print  (   "  *  %s:  <%s>  %sx%s  (  %s  )   "  ,  src  .  tagName  (  )  ,  src  .  attr  (   "abs:src "  )  ,  src  .  attr  (   "width "  )  ,  src  .  attr  (   "height "  )  ,  trim  (  src  .  attr  (   "alt "  )  ,  20  )  )  ;  else  print  (   "  *  %s:  <%s> "  ,  src  .  tagName  (  )  ,  src  .  attr  (   "abs:src "  )  )  ;  }  print  (   "\nImports:  (  %d  )   "  ,  imports  .  size  (  )  )  ;  for  (  Element  link  :  imports  )  {  print  (   "  *  %s  <%s>  (  %s  )   "  ,  link  .  tagName  (  )  ,  link  .  attr  (   "abs:href "  )  ,  link  .  attr  (   "rel "  )  )  ;  }  [ATTENTION]  print  (   "\nLinks:  (  %d  )   "  ,  imports  .  size  (  )  )    ;  for  (  Element  link  :  links  )  {  print  (   "  *  a:  <%s>  (  %s  )   "  ,  link  .  attr  (   "abs:href "  )  ,  trim  (  link  .  text  (  )  ,  35  )  )  ;  }  }    [METHOD]  main  [TYPE]  void  [PARAMETER]  String[]  args  [CLASS]  ListLinks    [TYPE]  boolean  false  true  [TYPE]  Element  link  src  [TYPE]  String[]  args  [TYPE]  Document  doc  [TYPE]  Elements  imports  links  media  [TYPE]  URL  url  
[ADD]  print  (   "\nLinks:  (  %d  )   ",  links  .  size  (  )  )  ;	[BUGGY]  [NO-ERROR]  [CONTEXT]  public  static  void  main  (  String[]  args  )  throws  IOException  {  Validate  .  isTrue  (  args  .  length  =  =  1  ,   "usage:  supply  url  to  fetch "  )  ;  URL  url  =  new  URL  (  args[0]  )  ;  print  (   "Fetching  %s  .  .  .   "  ,  url  .  toExternalForm  (  )  )  ;    Document  doc  =  Jsoup  .  parse  (  url  ,  3*1000  )  ;  Elements  links  =  doc  .  select  (   "a[href] "  )  ;  Elements  media  =  doc  .  select  (   "[src] "  )  ;  Elements  imports  =  doc  .  select  (   "link[href] "  )  ;    print  (   "\nMedia:  (  %d  )   "  ,  media  .  size  (  )  )  ;  for  (  Element  src  :  media  )  {  if  (  src  .  tagName  (  )  .  equals  (   "img "  )  )  print  (   "  *  %s:  <%s>  %sx%s  (  %s  )   "  ,  src  .  tagName  (  )  ,  src  .  attr  (   "abs:src "  )  ,  src  .  attr  (   "width "  )  ,  src  .  attr  (   "height "  )  ,  trim  (  src  .  attr  (   "alt "  )  ,  20  )  )  ;  else  print  (   "  *  %s:  <%s> "  ,  src  .  tagName  (  )  ,  src  .  attr  (   "abs:src "  )  )  ;  }  print  (   "\nImports:  (  %d  )   "  ,  imports  .  size  (  )  )  ;  for  (  Element  link  :  imports  )  {  print  (   "  *  %s  <%s>  (  %s  )   "  ,  link  .  tagName  (  )  ,  link  .  attr  (   "abs:href "  )  ,  link  .  attr  (   "rel "  )  )  ;  }  [ATTENTION]  for  (  Element  link  :  links  )  {  print  (   "  *  a:  <%s>  (  %s  )   "  ,  link  .  attr  (   "abs:href "  )  ,  trim  (  link  .  text  (  )  ,  35  )  )  ;  }  }    [METHOD]  main  [TYPE]  void  [PARAMETER]  String[]  args  [CLASS]  ListLinks    [TYPE]  boolean  false  true  [TYPE]  Element  link  src  [TYPE]  String[]  args  [TYPE]  Document  doc  [TYPE]  Elements  imports  links  media  [TYPE]  URL  url  
[REPLACE]  for  (  Element  link  :  links  )  {	[BUGGY]  for  (  Element  src  :  media  )  {  if  (  src  .  tagName  (  )  .  equals  (   "img "  )  )[CE]  cannot  find  symbol  link  [CONTEXT]  public  static  void  main  (  String[]  args  )  throws  IOException  {  Validate  .  isTrue  (  args  .  length  =  =  1  ,   "usage:  supply  url  to  fetch "  )  ;  URL  url  =  new  URL  (  args[0]  )  ;  print  (   "Fetching  %s  .  .  .   "  ,  url  .  toExternalForm  (  )  )  ;    Document  doc  =  Jsoup  .  parse  (  url  ,  3*1000  )  ;  Elements  links  =  doc  .  select  (   "a[href] "  )  ;  Elements  media  =  doc  .  select  (   "[src] "  )  ;  Elements  imports  =  doc  .  select  (   "link[href] "  )  ;    print  (   "\nMedia:  (  %d  )   "  ,  media  .  size  (  )  )  ;  for  (  Element  src  :  media  )  {  if  (  src  .  tagName  (  )  .  equals  (   "img "  )  )  print  (   "  *  %s:  <%s>  %sx%s  (  %s  )   "  ,  src  .  tagName  (  )  ,  src  .  attr  (   "abs:src "  )  ,  src  .  attr  (   "width "  )  ,  src  .  attr  (   "height "  )  ,  trim  (  src  .  attr  (   "alt "  )  ,  20  )  )  ;  else  print  (   "  *  %s:  <%s> "  ,  src  .  tagName  (  )  ,  src  .  attr  (   "abs:src "  )  )  ;  }  print  (   "\nImports:  (  %d  )   "  ,  imports  .  size  (  )  )  ;  for  (  Element  link  :  imports  )  {  print  (   "  *  %s  <%s>  (  %s  )   "  ,  link  .  tagName  (  )  ,  link  .  attr  (   "abs:href "  )  ,  link  .  attr  (   "rel "  )  )  ;  }  print  (   "\nLinks:  (  %d  )   "  ,  links  .  size  (  )  )  ;  [ATTENTION]  for  (  Element  src  :  media  )  {  if  (  src  .  tagName  (  )    .  equals  (   "img "  )  )  print  (   "  *  a:  <%s>  (  %s  )   "  ,  link  .  attr  (   "abs:href "  )  ,  trim  (  link  .  text  (  )  ,  35  )  )  ;  }  }    [METHOD]  main  [TYPE]  void  [PARAMETER]  String[]  args  [CLASS]  ListLinks    [TYPE]  boolean  false  true  [TYPE]  Element  link  src  [TYPE]  String[]  args  [TYPE]  Document  doc  [TYPE]  Elements  imports  links  media  [TYPE]  URL  url  
[REPLACE]  System  .  out  .  println  (  String  .  format  (  msg,  args  )  )  ;	[BUGGY]  System  .  out  .  println  (  String  .  substring  (  null  ,  true  )    )  ;  [CE]  no  suitable  method  found  for  substring(<null>  ,  boolean)  [CONTEXT]  private  static  void  print  (  String  msg  ,  Object  .  .  .  args  )  {  [ATTENTION]  System  .  out  .  println  (  String  .  substring  (  null  ,  true  )    )    ;  }    [METHOD]  print  [TYPE]  void  [PARAMETER]  String  msg  args  [CLASS]  ListLinks    [TYPE]  boolean  false  true  [TYPE]  String  msg  [TYPE]  Object[]  args  
[REPLACE]  System  .  out  .  println  (  String  .  format  (  msg,  args  )  )  ;	[BUGGY]  System  .  out  .  println  (  String  .  substring  (  msg  ,  args  )  )  ;  [CE]  no  suitable  method  found  for  substring(String  ,  Object[])  [CONTEXT]  private  static  void  print  (  String  msg  ,  Object  .  .  .  args  )  {  [ATTENTION]  System  .  out  .  println  (  String  .  substring  (  msg  ,  args  )  )    ;  }    [METHOD]  print  [TYPE]  void  [PARAMETER]  String  msg  args  [CLASS]  ListLinks    [TYPE]  boolean  false  true  [TYPE]  String  msg  [TYPE]  Object[]  args  
[REPLACE]  if  (  s  .  length  (  )  >  width  )  return  s  .  substring  (  0,  width-1  )  +   "  .   ";	[BUGGY]  if  (  s  .  length  (  )  +  3  >  width  )  return  s  .  substring  (  0  ,  width-1  )  +   "  .   "  ;  [NO-ERROR]  [CONTEXT]  private  static  String  trim  (  String  s  ,  int  width  )  {  [ATTENTION]  if  (  s  .  length  (  )  +  3  >  width  )  return  s  .  substring  (  0  ,  width-1  )  +   "  .   "  ;    else  return  s  ;  }    [METHOD]  trim  [TYPE]  String  [PARAMETER]  String  s  int  width  [CLASS]  ListLinks    [TYPE]  boolean  false  true  [TYPE]  String  s  [TYPE]  int  width  
[ADD]  if  (  s  .  length  (  )  >  width  )  return  s  .  substring  (  0,  width-1  )  +   "  .   ";  else  return  s;  }	[BUGGY]  return  s  .  substring  (  0  ,  width-1  )  +   "  .   "  ;  return  s  ;  [CE]  reached  end  of  file  while  parsing  [CONTEXT]  private  static  String  trim  (  String  s  ,  int  width  )  {  [ATTENTION]  return  s  .  substring  (  0  ,  width-1  )  +   "  .   "  ;  return  s  ;          [METHOD]  trim  [TYPE]  String  [PARAMETER]  String  s  int  width  [CLASS]  ListLinks    [TYPE]  boolean  false  true  [TYPE]  String  s  [TYPE]  int  width  
[REPLACE]  return  s  .  substring  (  0,  width-1  )  +   "  .   ";	[BUGGY]  return  s  .  substring  (  3  ,  width-1  )    &&   "  .   "  ;  [CE]  bad  operand  types  for  binary  operator  [CONTEXT]  private  static  String  trim  (  String  s  ,  int  width  )  {  if  (  s  .  length  (  )  >  width  )  [ATTENTION]  return  s  .  substring  (  3  ,  width-1  )  && "  .   "  ;  else  return  s  ;  }    [METHOD]  trim  [TYPE]  String  [PARAMETER]  String  s  int  width  [CLASS]  ListLinks    [TYPE]  boolean  false  true  [TYPE]  String  s  [TYPE]  int  width  
[REPLACE]  return  s  .  substring  (  0,  width-1  )  +   "  .   ";	[BUGGY]  return  s  .  substring  (  0  ,  width-1  )  +s  ;  [NO-ERROR]  [CONTEXT]  private  static  String  trim  (  String  s  ,  int  width  )  {  if  (  s  .  length  (  )  >  width  )  [ATTENTION]  return  s  .  substring  (  0  ,  width-1  )  +s  ;  else  return  s  ;  }    [METHOD]  trim  [TYPE]  String  [PARAMETER]  String  s  int  width  [CLASS]  ListLinks    [TYPE]  boolean  false  true  [TYPE]  String  s  [TYPE]  int  width  
[REPLACE]  return  s;	[BUGGY]  return  s  .  substring  (  0  ,  width-1  )  +   "  .   "  ;  [NO-ERROR]  [CONTEXT]  private  static  String  trim  (  String  s  ,  int  width  )  {  if  (  s  .  length  (  )  >  width  )  return  s  .  substring  (  0  ,  width-1  )  +   "  .   "  ;  else  [ATTENTION]  return  s  .  substring  (  0  ,  width-1  )  +   "  .   "  ;  }    [METHOD]  trim  [TYPE]  String  [PARAMETER]  String  s  int  width  [CLASS]  ListLinks    [TYPE]  boolean  false  true  [TYPE]  String  s  [TYPE]  int  width  
[REPLACE]  Validate  .  notNull  (  whitelist  )  ;	[BUGGY]  whitelist    ;  [CE]  not  a  statement  [CONTEXT]  public  Cleaner  (  Whitelist  whitelist  )  {  [ATTENTION]  whitelist  ;  this  .  whitelist  =  whitelist  ;  }    [METHOD]  <init>  [TYPE]  Whitelist)  [PARAMETER]  Whitelist  whitelist  [CLASS]  Cleaner  ElementMeta    [TYPE]  Whitelist  whitelist  [TYPE]  boolean  false  true  [TYPE]  int  numAttribsDiscarded  [TYPE]  Element  el  
[REPLACE]  this  .  whitelist  =  whitelist;	[BUGGY]  this  .  whitelist  =    null  ;  [FE]  null  assertEquals( "<img  alt  =  \ "\ "  /> "  ,  cleanHtml)  ;  [CONTEXT]  public  Cleaner  (  Whitelist  whitelist  )  {  Validate  .  notNull  (  whitelist  )  ;  [ATTENTION]  this  .  whitelist  =  null  ;  }    [METHOD]  <init>  [TYPE]  Whitelist)  [PARAMETER]  Whitelist  whitelist  [CLASS]  Cleaner  ElementMeta    [TYPE]  Whitelist  whitelist  [TYPE]  boolean  false  true  [TYPE]  int  numAttribsDiscarded  [TYPE]  Element  el  
[REPLACE]  this  .  el  =  el;	[BUGGY]  this  .  el  =    null  ;  [FE]  The  validated  object  is  null  assertEquals( "<img  alt  =  \ "\ "  /> "  ,  cleanHtml)  ;  [CONTEXT]  ElementMeta  (  Element  el  ,  int  numAttribsDiscarded  )  {  [ATTENTION]  this  .  el  =  null  ;  this  .  numAttribsDiscarded  =  numAttribsDiscarded  ;  }    [METHOD]  <init>  [TYPE]  Element  ,  int)  [PARAMETER]  Element  el  int  numAttribsDiscarded  [CLASS]  Cleaner  ElementMeta    [TYPE]  Whitelist  whitelist  [TYPE]  boolean  false  true  [TYPE]  int  numAttribsDiscarded  [TYPE]  Element  el  
[ADD]  this  .  el  =  el;  this  .  numAttribsDiscarded  =  numAttribsDiscarded;	[BUGGY]  [FE]  The  validated  object  is  null  assertEquals( "<img  alt  =  \ "\ "  /> "  ,  cleanHtml)  ;  [CONTEXT]  ElementMeta  (  Element  el  ,  int  numAttribsDiscarded  )  {  [ATTENTION]    }    [METHOD]  <init>  [TYPE]  Element  ,  int)  [PARAMETER]  Element  el  int  numAttribsDiscarded  [CLASS]  Cleaner  ElementMeta    [TYPE]  Whitelist  whitelist  [TYPE]  boolean  false  true  [TYPE]  int  numAttribsDiscarded  [TYPE]  Element  el  
[REPLACE]  this  .  numAttribsDiscarded  =  numAttribsDiscarded;	[BUGGY]  this  .  numAttribsDiscarded  =    null  ;  [CE]  incompatible  types  [CONTEXT]  ElementMeta  (  Element  el  ,  int  numAttribsDiscarded  )  {  this  .  el  =  el  ;  [ATTENTION]  this  .  numAttribsDiscarded  =  null  ;  }    [METHOD]  <init>  [TYPE]  Element  ,  int)  [PARAMETER]  Element  el  int  numAttribsDiscarded  [CLASS]  Cleaner  ElementMeta    [TYPE]  Whitelist  whitelist  [TYPE]  boolean  false  true  [TYPE]  int  numAttribsDiscarded  [TYPE]  Element  el  
[REPLACE]  Validate  .  notNull  (  dirtyDocument  )  ;	[BUGGY]  Validate  .  notNull  (  clean  )  ;  [CE]  cannot  find  symbol  clean  [CONTEXT]  public  Document  clean  (  Document  dirtyDocument  )  {  [ATTENTION]  Validate  .  notNull  (  clean  )    ;    Document  clean  =  Document  .  createShell  (  dirtyDocument  .  baseUri  (  )  )  ;  copySafeNodes  (  dirtyDocument  .  body  (  )  ,  clean  .  body  (  )  )  ;    return  clean  ;  }    [METHOD]  clean  [TYPE]  Document  [PARAMETER]  Document  dirtyDocument  [CLASS]  Cleaner  ElementMeta    [TYPE]  Whitelist  whitelist  [TYPE]  boolean  false  true  [TYPE]  Document  clean  dirtyDocument  [TYPE]  int  numAttribsDiscarded  [TYPE]  Element  el  
[ADD]  Validate  .  notNull  (  dirtyDocument  )  ;	[BUGGY]  [NO-ERROR]  [CONTEXT]  public  Document  clean  (  Document  dirtyDocument  )  {  [ATTENTION]    Document  clean  =  Document  .  createShell  (  dirtyDocument  .  baseUri  (  )  )  ;  copySafeNodes  (  dirtyDocument  .  body  (  )  ,  clean  .  body  (  )  )  ;    return  clean  ;  }    [METHOD]  clean  [TYPE]  Document  [PARAMETER]  Document  dirtyDocument  [CLASS]  Cleaner  ElementMeta    [TYPE]  Whitelist  whitelist  [TYPE]  boolean  false  true  [TYPE]  Document  clean  dirtyDocument  [TYPE]  int  numAttribsDiscarded  [TYPE]  Element  el  
[REPLACE]  Document  clean  =  Document  .  createShell  (  dirtyDocument  .  baseUri  (  )  )  ;	[BUGGY]  Document  clean  =  Document  .  createShell  (  dirtyDocument  .  createShell  (  )    )  ;  [CE]  method  createShell  in  class  Document  cannot  be  applied  to  given  types  ;  [CONTEXT]  public  Document  clean  (  Document  dirtyDocument  )  {  Validate  .  notNull  (  dirtyDocument  )  ;    [ATTENTION]  Document  clean  =  Document  .  createShell  (  dirtyDocument  .  createShell  (  )    )    ;  copySafeNodes  (  dirtyDocument  .  body  (  )  ,  clean  .  body  (  )  )  ;    return  clean  ;  }    [METHOD]  clean  [TYPE]  Document  [PARAMETER]  Document  dirtyDocument  [CLASS]  Cleaner  ElementMeta    [TYPE]  Whitelist  whitelist  [TYPE]  boolean  false  true  [TYPE]  Document  clean  dirtyDocument  [TYPE]  int  numAttribsDiscarded  [TYPE]  Element  el  
[ADD]  Document  clean  =  Document  .  createShell  (  dirtyDocument  .  baseUri  (  )  )  ;  copySafeNodes  (  dirtyDocument  .  body  (  )  ,  clean  .  body  (  )  )  ;	[BUGGY]  [CE]  cannot  find  symbol  clean  [CONTEXT]  public  Document  clean  (  Document  dirtyDocument  )  {  Validate  .  notNull  (  dirtyDocument  )  ;    [ATTENTION]    return  clean  ;  }    [METHOD]  clean  [TYPE]  Document  [PARAMETER]  Document  dirtyDocument  [CLASS]  Cleaner  ElementMeta    [TYPE]  Whitelist  whitelist  [TYPE]  boolean  false  true  [TYPE]  Document  clean  dirtyDocument  [TYPE]  int  numAttribsDiscarded  [TYPE]  Element  el  
[REPLACE]  copySafeNodes  (  dirtyDocument  .  body  (  )  ,  clean  .  body  (  )  )  ;	[BUGGY]  copySafeNodes  (  dirtyDocument  .  baseUri  (  )  ,  clean  .  body  (  )  )  ;  [CE]  method  copySafeNodes  in  class  Cleaner  cannot  be  applied  to  given  types  ;  [CONTEXT]  public  Document  clean  (  Document  dirtyDocument  )  {  Validate  .  notNull  (  dirtyDocument  )  ;    Document  clean  =  Document  .  createShell  (  dirtyDocument  .  baseUri  (  )  )  ;  [ATTENTION]  copySafeNodes  (  dirtyDocument  .  baseUri  (  )    ,  clean  .  body  (  )  )    ;    return  clean  ;  }    [METHOD]  clean  [TYPE]  Document  [PARAMETER]  Document  dirtyDocument  [CLASS]  Cleaner  ElementMeta    [TYPE]  Whitelist  whitelist  [TYPE]  boolean  false  true  [TYPE]  Document  clean  dirtyDocument  [TYPE]  int  numAttribsDiscarded  [TYPE]  Element  el  
[REPLACE]  copySafeNodes  (  dirtyDocument  .  body  (  )  ,  clean  .  body  (  )  )  ;	[BUGGY]  copySafeNodes  (  clean  .  body  (  )  ,  clean  .  body  (  )  )  ;  [FE]  AssertionFailedError    expected:<[<img  alt  =   " "  />]>  but  was:<[]>  assertEquals( "<img  alt  =  \ "\ "  /> "  ,  cleanHtml)  ;  [CONTEXT]  public  Document  clean  (  Document  dirtyDocument  )  {  Validate  .  notNull  (  dirtyDocument  )  ;    Document  clean  =  Document  .  createShell  (  dirtyDocument  .  baseUri  (  )  )  ;  [ATTENTION]  copySafeNodes  (  clean  .  body  (  )    ,  clean  .  body  (  )  )    ;    return  clean  ;  }    [METHOD]  clean  [TYPE]  Document  [PARAMETER]  Document  dirtyDocument  [CLASS]  Cleaner  ElementMeta    [TYPE]  Whitelist  whitelist  [TYPE]  boolean  false  true  [TYPE]  Document  clean  dirtyDocument  [TYPE]  int  numAttribsDiscarded  [TYPE]  Element  el  
[ADD]  copySafeNodes  (  dirtyDocument  .  body  (  )  ,  clean  .  body  (  )  )  ;	[BUGGY]  [FE]  AssertionFailedError    expected:<[<img  alt  =   " "  />]>  but  was:<[]>  assertEquals( "<img  alt  =  \ "\ "  /> "  ,  cleanHtml)  ;  [CONTEXT]  public  Document  clean  (  Document  dirtyDocument  )  {  Validate  .  notNull  (  dirtyDocument  )  ;    Document  clean  =  Document  .  createShell  (  dirtyDocument  .  baseUri  (  )  )  ;  [ATTENTION]    return  clean  ;  }    [METHOD]  clean  [TYPE]  Document  [PARAMETER]  Document  dirtyDocument  [CLASS]  Cleaner  ElementMeta    [TYPE]  Whitelist  whitelist  [TYPE]  boolean  false  true  [TYPE]  Document  clean  dirtyDocument  [TYPE]  int  numAttribsDiscarded  [TYPE]  Element  el  
[REPLACE]  copySafeNodes  (  dirtyDocument  .  body  (  )  ,  clean  .  body  (  )  )  ;	[BUGGY]  copySafeNodes  (  dirtyDocument  .  baseUri  (  )    ,  dirtyDocument[CE]  ')'  expected  [CONTEXT]  public  Document  clean  (  Document  dirtyDocument  )  {  Validate  .  notNull  (  dirtyDocument  )  ;    Document  clean  =  Document  .  createShell  (  dirtyDocument  .  baseUri  (  )  )  ;  [ATTENTION]  copySafeNodes  (  dirtyDocument  .  baseUri  (  )  ,  dirtyDocument  return  clean  ;  }    [METHOD]  clean  [TYPE]  Document  [PARAMETER]  Document  dirtyDocument  [CLASS]  Cleaner  ElementMeta    [TYPE]  Whitelist  whitelist  [TYPE]  boolean  false  true  [TYPE]  Document  clean  dirtyDocument  [TYPE]  int  numAttribsDiscarded  [TYPE]  Element  el  
[REPLACE]  return  clean;	[BUGGY]  return  dirtyDocument  ;  [FE]  AssertionFailedError    expected:<<img  alt  =   " "  []/>>  but  was:<<img  alt  =   " "  [src  =   " "  ]/>>  assertEquals( "<img  alt  =  \ "\ "  /> "  ,  cleanHtml)  ;  [CONTEXT]  public  Document  clean  (  Document  dirtyDocument  )  {  Validate  .  notNull  (  dirtyDocument  )  ;    Document  clean  =  Document  .  createShell  (  dirtyDocument  .  baseUri  (  )  )  ;  copySafeNodes  (  dirtyDocument  .  body  (  )  ,  clean  .  body  (  )  )  ;    [ATTENTION]  return  dirtyDocument  ;  }    [METHOD]  clean  [TYPE]  Document  [PARAMETER]  Document  dirtyDocument  [CLASS]  Cleaner  ElementMeta    [TYPE]  Whitelist  whitelist  [TYPE]  boolean  false  true  [TYPE]  Document  clean  dirtyDocument  [TYPE]  int  numAttribsDiscarded  [TYPE]  Element  el  
[REPLACE]  Validate  .  notNull  (  dirtyDocument  )  ;	[BUGGY]  Validate  .  notNull  (  clean  )  ;  [CE]  cannot  find  symbol  clean  [CONTEXT]  public  boolean  isValid  (  Document  dirtyDocument  )  {  [ATTENTION]  Validate  .  notNull  (  clean  )    ;    Document  clean  =  Document  .  createShell  (  dirtyDocument  .  baseUri  (  )  )  ;  int  numDiscarded  =  copySafeNodes  (  dirtyDocument  .  body  (  )  ,  clean  .  body  (  )  )  ;  return  numDiscarded  =  =  0  ;  }    [METHOD]  isValid  [TYPE]  boolean  [PARAMETER]  Document  dirtyDocument  [CLASS]  Cleaner  ElementMeta    [TYPE]  Whitelist  whitelist  [TYPE]  boolean  false  true  [TYPE]  Document  clean  dirtyDocument  [TYPE]  int  numAttribsDiscarded  numDiscarded  [TYPE]  Element  el  
[REPLACE]  Document  clean  =  Document  .  createShell  (  dirtyDocument  .  baseUri  (  )  )  ;	[BUGGY]  Document  clean  =  Document  .  createShell  (  dirtyDocument  .  createShell  (  )    )  ;  [CE]  method  createShell  in  class  Document  cannot  be  applied  to  given  types  ;  [CONTEXT]  public  boolean  isValid  (  Document  dirtyDocument  )  {  Validate  .  notNull  (  dirtyDocument  )  ;    [ATTENTION]  Document  clean  =  Document  .  createShell  (  dirtyDocument  .  createShell  (  )    )    ;  int  numDiscarded  =  copySafeNodes  (  dirtyDocument  .  body  (  )  ,  clean  .  body  (  )  )  ;  return  numDiscarded  =  =  0  ;  }    [METHOD]  isValid  [TYPE]  boolean  [PARAMETER]  Document  dirtyDocument  [CLASS]  Cleaner  ElementMeta    [TYPE]  Whitelist  whitelist  [TYPE]  boolean  false  true  [TYPE]  Document  clean  dirtyDocument  [TYPE]  int  numAttribsDiscarded  numDiscarded  [TYPE]  Element  el  
[REPLACE]  int  numDiscarded  =  copySafeNodes  (  dirtyDocument  .  body  (  )  ,  clean  .  body  (  )  )  ;	[BUGGY]  TextNode  destText  =  new  TextNode  (  sourceText  .  getWholeText  (  )  ,  sourceChild  .  baseUri  (  )  )  ;  [CE]  cannot  find  symbol  sourceText  [CONTEXT]  public  boolean  isValid  (  Document  dirtyDocument  )  {  Validate  .  notNull  (  dirtyDocument  )  ;    Document  clean  =  Document  .  createShell  (  dirtyDocument  .  baseUri  (  )  )  ;  [ATTENTION]  TextNode  destText  =  new  TextNode  (  sourceText  .  getWholeText  (  )    ,  sourceChild  .  baseUri  (  )  )    ;  return  numDiscarded  =  =  0  ;  }    [METHOD]  isValid  [TYPE]  boolean  [PARAMETER]  Document  dirtyDocument  [CLASS]  Cleaner  ElementMeta    [TYPE]  Whitelist  whitelist  [TYPE]  boolean  false  true  [TYPE]  Document  clean  dirtyDocument  [TYPE]  int  numAttribsDiscarded  numDiscarded  [TYPE]  Element  el  
[REPLACE]  return  numDiscarded  ==  0;	[BUGGY]  return  numDiscarded  !  =    1  ;  ;  [CE]  unreachable  statement  [CONTEXT]  public  boolean  isValid  (  Document  dirtyDocument  )  {  Validate  .  notNull  (  dirtyDocument  )  ;    Document  clean  =  Document  .  createShell  (  dirtyDocument  .  baseUri  (  )  )  ;  int  numDiscarded  =  copySafeNodes  (  dirtyDocument  .  body  (  )  ,  clean  .  body  (  )  )  ;  [ATTENTION]  return  numDiscarded!  =  1  ;  ;  }    [METHOD]  isValid  [TYPE]  boolean  [PARAMETER]  Document  dirtyDocument  [CLASS]  Cleaner  ElementMeta    [TYPE]  Whitelist  whitelist  [TYPE]  boolean  false  true  [TYPE]  Document  clean  dirtyDocument  [TYPE]  int  numAttribsDiscarded  numDiscarded  [TYPE]  Element  el  
[REPLACE]  List<Node>  sourceChildren  =  source  .  childNodes  (  )  ;	[BUGGY]  List<Node>  sourceElChildren  =  source  .  tagName  (  )    ;  [CE]  incompatible  types  [CONTEXT]  private  int  copySafeNodes  (  Element  source  ,  Element  dest  )  {  [ATTENTION]  List<Node>  sourceElChildren  =  source  .  tagName  (  )  ;  int  numDiscarded  =  0  ;    for  (  Node  sourceChild  :  sourceChildren  )  {  if  (  sourceChild  instanceof  Element  )  {  Element  sourceEl  =    (  Element  )  sourceChild  ;    if  (  whitelist  .  isSafeTag  (  sourceEl  .  tagName  (  )  )  )  {  //  safe  ,  clone  and  copy  safe  attrs  ElementMeta  meta  =  createSafeElement  (  sourceEl  )  ;  Element  destChild  =  meta  .  el  ;  dest  .  appendChild  (  destChild  )  ;    numDiscarded  +  =  meta  .  numAttribsDiscarded  ;  numDiscarded  +  =  copySafeNodes  (  sourceEl  ,  destChild  )  ;  //  recurs  }  else  {  //  not  a  safe  tag  ,  but  it  may  have  children  (  els  or  text  )  that  are  ,  so  recurse  numDiscarded++  ;  numDiscarded  +  =  copySafeNodes  (  sourceEl  ,  dest  )  ;  }  }  else  if  (  sourceChild  instanceof  TextNode  )  {  TextNode  sourceText  =    (  TextNode  )  sourceChild  ;  TextNode  destText  =  new  TextNode  (  sourceText  .  getWholeText  (  )  ,  sourceChild  .  baseUri  (  )  )  ;  dest  .  appendChild  (  destText  )  ;  }  //  else  ,  we  don't  care  about  comments  ,  xml  proc  instructions  ,  etc  }  return  numDiscarded  ;  }    [METHOD]  copySafeNodes  [TYPE]  int  [PARAMETER]  Element  source  Element  dest  [CLASS]  Cleaner  ElementMeta    [TYPE]  ElementMeta  meta  [TYPE]  boolean  false  true  [TYPE]  Element  dest  destChild  el  source  sourceEl  [TYPE]  Node  sourceChild  [TYPE]  Whitelist  whitelist  [TYPE]  List  sourceChildren  [TYPE]  TextNode  destText  sourceText  [TYPE]  int  numAttribsDiscarded  numDiscarded  
[REPLACE]  int  numDiscarded  =  0;	[BUGGY]  int  numDiscarded  =  4  ;  [FE]  null  assertTrue(Jsoup.isValid(ok  ,  Whitelist.basic()))  ;  assertFalse(Jsoup.isValid(nok1  ,  Whitelist.basic()))  ;  assertFalse(Jsoup.isValid(nok2  ,  Whitelist.basic()))  ;  [CONTEXT]  private  int  copySafeNodes  (  Element  source  ,  Element  dest  )  {  List<Node>  sourceChildren  =  source  .  childNodes  (  )  ;  [ATTENTION]  int  numDiscarded  =  4  ;    for  (  Node  sourceChild  :  sourceChildren  )  {  if  (  sourceChild  instanceof  Element  )  {  Element  sourceEl  =    (  Element  )  sourceChild  ;    if  (  whitelist  .  isSafeTag  (  sourceEl  .  tagName  (  )  )  )  {  //  safe  ,  clone  and  copy  safe  attrs  ElementMeta  meta  =  createSafeElement  (  sourceEl  )  ;  Element  destChild  =  meta  .  el  ;  dest  .  appendChild  (  destChild  )  ;    numDiscarded  +  =  meta  .  numAttribsDiscarded  ;  numDiscarded  +  =  copySafeNodes  (  sourceEl  ,  destChild  )  ;  //  recurs  }  else  {  //  not  a  safe  tag  ,  but  it  may  have  children  (  els  or  text  )  that  are  ,  so  recurse  numDiscarded++  ;  numDiscarded  +  =  copySafeNodes  (  sourceEl  ,  dest  )  ;  }  }  else  if  (  sourceChild  instanceof  TextNode  )  {  TextNode  sourceText  =    (  TextNode  )  sourceChild  ;  TextNode  destText  =  new  TextNode  (  sourceText  .  getWholeText  (  )  ,  sourceChild  .  baseUri  (  )  )  ;  dest  .  appendChild  (  destText  )  ;  }  //  else  ,  we  don't  care  about  comments  ,  xml  proc  instructions  ,  etc  }  return  numDiscarded  ;  }    [METHOD]  copySafeNodes  [TYPE]  int  [PARAMETER]  Element  source  Element  dest  [CLASS]  Cleaner  ElementMeta    [TYPE]  ElementMeta  meta  [TYPE]  boolean  false  true  [TYPE]  Element  dest  destChild  el  source  sourceEl  [TYPE]  Node  sourceChild  [TYPE]  Whitelist  whitelist  [TYPE]  List  sourceChildren  [TYPE]  TextNode  destText  sourceText  [TYPE]  int  numAttribsDiscarded  numDiscarded  
[REPLACE]  if  (  sourceChild  instanceof  Element  )  {	[BUGGY]  if  (  !  sourceChild  instanceof  Element  )  {[CE]  bad  operand  type  Node  for  unary  operator  '!'  [CONTEXT]  private  int  copySafeNodes  (  Element  source  ,  Element  dest  )  {  List<Node>  sourceChildren  =  source  .  childNodes  (  )  ;  int  numDiscarded  =  0  ;    for  (  Node  sourceChild  :  sourceChildren  )  {  [ATTENTION]  if  (  !  sourceChild  instanceof  Element  )  {  Element  sourceEl  =    (  Element  )  sourceChild  ;    if  (  whitelist  .  isSafeTag  (  sourceEl  .  tagName  (  )  )  )  {  //  safe  ,  clone  and  copy  safe  attrs  ElementMeta  meta  =  createSafeElement  (  sourceEl  )  ;  Element  destChild  =  meta  .  el  ;  dest  .  appendChild  (  destChild  )  ;    numDiscarded  +  =  meta  .  numAttribsDiscarded  ;  numDiscarded  +  =  copySafeNodes  (  sourceEl  ,  destChild  )  ;  //  recurs  }  else  {  //  not  a  safe  tag  ,  but  it  may  have  children  (  els  or  text  )  that  are  ,  so  recurse  numDiscarded++  ;  numDiscarded  +  =  copySafeNodes  (  sourceEl  ,  dest  )  ;  }  }  else  if  (  sourceChild  instanceof  TextNode  )  {  TextNode  sourceText  =    (  TextNode  )  sourceChild  ;  TextNode  destText  =  new  TextNode  (  sourceText  .  getWholeText  (  )  ,  sourceChild  .  baseUri  (  )  )  ;  dest  .  appendChild  (  destText  )  ;  }  //  else  ,  we  don't  care  about  comments  ,  xml  proc  instructions  ,  etc  }  return  numDiscarded  ;  }    [METHOD]  copySafeNodes  [TYPE]  int  [PARAMETER]  Element  source  Element  dest  [CLASS]  Cleaner  ElementMeta    [TYPE]  ElementMeta  meta  [TYPE]  boolean  false  true  [TYPE]  Element  dest  destChild  el  source  sourceEl  [TYPE]  Node  sourceChild  [TYPE]  Whitelist  whitelist  [TYPE]  List  sourceChildren  [TYPE]  TextNode  destText  sourceText  [TYPE]  int  numAttribsDiscarded  numDiscarded  
[REPLACE]  }  else  if  (  sourceChild  instanceof  TextNode  )  {	[BUGGY]    if  (  !  sourceChild  instanceof  TextNode  )  {[CE]  bad  operand  type  Node  for  unary  operator  '!'  [CONTEXT]  private  int  copySafeNodes  (  Element  source  ,  Element  dest  )  {  List<Node>  sourceChildren  =  source  .  childNodes  (  )  ;  int  numDiscarded  =  0  ;    for  (  Node  sourceChild  :  sourceChildren  )  {  if  (  sourceChild  instanceof  Element  )  {  Element  sourceEl  =    (  Element  )  sourceChild  ;    if  (  whitelist  .  isSafeTag  (  sourceEl  .  tagName  (  )  )  )  {  //  safe  ,  clone  and  copy  safe  attrs  ElementMeta  meta  =  createSafeElement  (  sourceEl  )  ;  Element  destChild  =  meta  .  el  ;  dest  .  appendChild  (  destChild  )  ;    numDiscarded  +  =  meta  .  numAttribsDiscarded  ;  numDiscarded  +  =  copySafeNodes  (  sourceEl  ,  destChild  )  ;  //  recurs  }  else  {  //  not  a  safe  tag  ,  but  it  may  have  children  (  els  or  text  )  that  are  ,  so  recurse  numDiscarded++  ;  numDiscarded  +  =  copySafeNodes  (  sourceEl  ,  dest  )  ;  }  [ATTENTION]  }if  (  !  sourceChild  instanceof  TextNode  )  {  TextNode  sourceText  =    (  TextNode  )  sourceChild  ;  TextNode  destText  =  new  TextNode  (  sourceText  .  getWholeText  (  )  ,  sourceChild  .  baseUri  (  )  )  ;  dest  .  appendChild  (  destText  )  ;  }  //  else  ,  we  don't  care  about  comments  ,  xml  proc  instructions  ,  etc  }  return  numDiscarded  ;  }    [METHOD]  copySafeNodes  [TYPE]  int  [PARAMETER]  Element  source  Element  dest  [CLASS]  Cleaner  ElementMeta    [TYPE]  ElementMeta  meta  [TYPE]  boolean  false  true  [TYPE]  Element  dest  destChild  el  source  sourceEl  [TYPE]  Node  sourceChild  [TYPE]  Whitelist  whitelist  [TYPE]  List  sourceChildren  [TYPE]  TextNode  destText  sourceText  [TYPE]  int  numAttribsDiscarded  numDiscarded  
[REPLACE]  TextNode  sourceText  =  (  TextNode  )  sourceChild;	[BUGGY]  for  (  Node  sourceChild  :  sourceChildren  )  {  if  (  sourceChild  instanceof  Element  )  {[CE]  illegal  start  of  expression  [CONTEXT]  private  int  copySafeNodes  (  Element  source  ,  Element  dest  )  {  List<Node>  sourceChildren  =  source  .  childNodes  (  )  ;  int  numDiscarded  =  0  ;    for  (  Node  sourceChild  :  sourceChildren  )  {  if  (  sourceChild  instanceof  Element  )  {  Element  sourceEl  =    (  Element  )  sourceChild  ;    if  (  whitelist  .  isSafeTag  (  sourceEl  .  tagName  (  )  )  )  {  //  safe  ,  clone  and  copy  safe  attrs  ElementMeta  meta  =  createSafeElement  (  sourceEl  )  ;  Element  destChild  =  meta  .  el  ;  dest  .  appendChild  (  destChild  )  ;    numDiscarded  +  =  meta  .  numAttribsDiscarded  ;  numDiscarded  +  =  copySafeNodes  (  sourceEl  ,  destChild  )  ;  //  recurs  }  else  {  //  not  a  safe  tag  ,  but  it  may  have  children  (  els  or  text  )  that  are  ,  so  recurse  numDiscarded++  ;  numDiscarded  +  =  copySafeNodes  (  sourceEl  ,  dest  )  ;  }  }  else  if  (  sourceChild  instanceof  TextNode  )  {  [ATTENTION]  for  (  Node  sourceChild  :  sourceChildren  )  {  if  (  sourceChild  instanceof  Element  )  {  TextNode  destText  =  new  TextNode  (  sourceText  .  getWholeText  (  )  ,  sourceChild  .  baseUri  (  )  )  ;  dest  .  appendChild  (  destText  )  ;  }  //  else  ,  we  don't  care  about  comments  ,  xml  proc  instructions  ,  etc  }  return  numDiscarded  ;  }    [METHOD]  copySafeNodes  [TYPE]  int  [PARAMETER]  Element  source  Element  dest  [CLASS]  Cleaner  ElementMeta    [TYPE]  ElementMeta  meta  [TYPE]  boolean  false  true  [TYPE]  Element  dest  destChild  el  source  sourceEl  [TYPE]  Node  sourceChild  [TYPE]  Whitelist  whitelist  [TYPE]  List  sourceChildren  [TYPE]  TextNode  destText  sourceText  [TYPE]  int  numAttribsDiscarded  numDiscarded  
[ADD]  TextNode  sourceText  =  (  TextNode  )  sourceChild;  TextNode  destText  =  new  TextNode  (  sourceText  .  getWholeText  (  )  ,  sourceChild  .  baseUri  (  )  )  ;	[BUGGY]  TextNode  destText  =  new  TextNode  (  sourceText  .  getWholeText  (  )  ,  sourceChild  .  baseUri  (  )  )  ;  [CE]  cannot  find  symbol  sourceText  [CONTEXT]  private  int  copySafeNodes  (  Element  source  ,  Element  dest  )  {  List<Node>  sourceChildren  =  source  .  childNodes  (  )  ;  int  numDiscarded  =  0  ;    for  (  Node  sourceChild  :  sourceChildren  )  {  if  (  sourceChild  instanceof  Element  )  {  Element  sourceEl  =    (  Element  )  sourceChild  ;    if  (  whitelist  .  isSafeTag  (  sourceEl  .  tagName  (  )  )  )  {  //  safe  ,  clone  and  copy  safe  attrs  ElementMeta  meta  =  createSafeElement  (  sourceEl  )  ;  Element  destChild  =  meta  .  el  ;  dest  .  appendChild  (  destChild  )  ;    numDiscarded  +  =  meta  .  numAttribsDiscarded  ;  numDiscarded  +  =  copySafeNodes  (  sourceEl  ,  destChild  )  ;  //  recurs  }  else  {  //  not  a  safe  tag  ,  but  it  may  have  children  (  els  or  text  )  that  are  ,  so  recurse  numDiscarded++  ;  numDiscarded  +  =  copySafeNodes  (  sourceEl  ,  dest  )  ;  }  }  else  if  (  sourceChild  instanceof  TextNode  )  {  [ATTENTION]  TextNode  destText  =  new  TextNode  (  sourceText  .  getWholeText  (  )    ,  sourceChild  .  baseUri  (  )  )    ;    dest  .  appendChild  (  destText  )  ;  }  //  else  ,  we  don't  care  about  comments  ,  xml  proc  instructions  ,  etc  }  return  numDiscarded  ;  }    [METHOD]  copySafeNodes  [TYPE]  int  [PARAMETER]  Element  source  Element  dest  [CLASS]  Cleaner  ElementMeta    [TYPE]  ElementMeta  meta  [TYPE]  boolean  false  true  [TYPE]  Element  dest  destChild  el  source  sourceEl  [TYPE]  Node  sourceChild  [TYPE]  Whitelist  whitelist  [TYPE]  List  sourceChildren  [TYPE]  TextNode  destText  sourceText  [TYPE]  int  numAttribsDiscarded  numDiscarded  
[REPLACE]  TextNode  destText  =  new  TextNode  (  sourceText  .  getWholeText  (  )  ,  sourceChild  .  baseUri  (  )  )  ;	[BUGGY]  TextNode  destText  =  new  TextNode  (  destText  .  getWholeText  (  )  ,  sourceChild  .  baseUri  (  )  )  ;  [CE]  variable  destText  might  not  have  been  initialized  [CONTEXT]  private  int  copySafeNodes  (  Element  source  ,  Element  dest  )  {  List<Node>  sourceChildren  =  source  .  childNodes  (  )  ;  int  numDiscarded  =  0  ;    for  (  Node  sourceChild  :  sourceChildren  )  {  if  (  sourceChild  instanceof  Element  )  {  Element  sourceEl  =    (  Element  )  sourceChild  ;    if  (  whitelist  .  isSafeTag  (  sourceEl  .  tagName  (  )  )  )  {  //  safe  ,  clone  and  copy  safe  attrs  ElementMeta  meta  =  createSafeElement  (  sourceEl  )  ;  Element  destChild  =  meta  .  el  ;  dest  .  appendChild  (  destChild  )  ;    numDiscarded  +  =  meta  .  numAttribsDiscarded  ;  numDiscarded  +  =  copySafeNodes  (  sourceEl  ,  destChild  )  ;  //  recurs  }  else  {  //  not  a  safe  tag  ,  but  it  may  have  children  (  els  or  text  )  that  are  ,  so  recurse  numDiscarded++  ;  numDiscarded  +  =  copySafeNodes  (  sourceEl  ,  dest  )  ;  }  }  else  if  (  sourceChild  instanceof  TextNode  )  {  TextNode  sourceText  =    (  TextNode  )  sourceChild  ;  [ATTENTION]  TextNode  destText  =  new  TextNode  (  destText  .  getWholeText  (  )    ,  sourceChild  .  baseUri  (  )  )    ;  dest  .  appendChild  (  destText  )  ;  }  //  else  ,  we  don't  care  about  comments  ,  xml  proc  instructions  ,  etc  }  return  numDiscarded  ;  }    [METHOD]  copySafeNodes  [TYPE]  int  [PARAMETER]  Element  source  Element  dest  [CLASS]  Cleaner  ElementMeta    [TYPE]  ElementMeta  meta  [TYPE]  boolean  false  true  [TYPE]  Element  dest  destChild  el  source  sourceEl  [TYPE]  Node  sourceChild  [TYPE]  Whitelist  whitelist  [TYPE]  List  sourceChildren  [TYPE]  TextNode  destText  sourceText  [TYPE]  int  numAttribsDiscarded  numDiscarded  
[REPLACE]  if  (  whitelist  .  isSafeTag  (  sourceEl  .  tagName  (  )  )  )  {	[BUGGY]  if  (  whitelist  .  isSafeTag  (  source  .  tagName  (  )  )  )  {[FE]  AssertionFailedError    expected:<[<img  alt  =   " "  />]>  but  was:<[]>  assertEquals( "<img  alt  =  \ "\ "  /> "  ,  cleanHtml)  ;  [CONTEXT]  private  int  copySafeNodes  (  Element  source  ,  Element  dest  )  {  List<Node>  sourceChildren  =  source  .  childNodes  (  )  ;  int  numDiscarded  =  0  ;    for  (  Node  sourceChild  :  sourceChildren  )  {  if  (  sourceChild  instanceof  Element  )  {  Element  sourceEl  =    (  Element  )  sourceChild  ;    [ATTENTION]  if  (  whitelist  .  isSafeTag  (  source  .  tagName  (  )  )  )  {  ElementMeta  meta  =  createSafeElement  (  sourceEl  )  ;  Element  destChild  =  meta  .  el  ;  dest  .  appendChild  (  destChild  )  ;    numDiscarded  +  =  meta  .  numAttribsDiscarded  ;  numDiscarded  +  =  copySafeNodes  (  sourceEl  ,  destChild  )  ;  //  recurs  }  else  {  //  not  a  safe  tag  ,  but  it  may  have  children  (  els  or  text  )  that  are  ,  so  recurse  numDiscarded++  ;  numDiscarded  +  =  copySafeNodes  (  sourceEl  ,  dest  )  ;  }  }  else  if  (  sourceChild  instanceof  TextNode  )  {  TextNode  sourceText  =    (  TextNode  )  sourceChild  ;  TextNode  destText  =  new  TextNode  (  sourceText  .  getWholeText  (  )  ,  sourceChild  .  baseUri  (  )  )  ;  dest  .  appendChild  (  destText  )  ;  }  //  else  ,  we  don't  care  about  comments  ,  xml  proc  instructions  ,  etc  }  return  numDiscarded  ;  }    [METHOD]  copySafeNodes  [TYPE]  int  [PARAMETER]  Element  source  Element  dest  [CLASS]  Cleaner  ElementMeta    [TYPE]  ElementMeta  meta  [TYPE]  boolean  false  true  [TYPE]  Element  dest  destChild  el  source  sourceEl  [TYPE]  Node  sourceChild  [TYPE]  Whitelist  whitelist  [TYPE]  List  sourceChildren  [TYPE]  TextNode  destText  sourceText  [TYPE]  int  numAttribsDiscarded  numDiscarded  
[ADD]  if  (  whitelist  .  isSafeTag  (  sourceEl  .  tagName  (  )  )  )  {  ElementMeta  meta  =  createSafeElement  (  sourceEl  )  ;  Element  destChild  =  meta  .  el;  dest  .  appendChild  (  destChild  )  ;	[BUGGY]  [CE]  'else'  without  'if'  [CONTEXT]  private  int  copySafeNodes  (  Element  source  ,  Element  dest  )  {  List<Node>  sourceChildren  =  source  .  childNodes  (  )  ;  int  numDiscarded  =  0  ;    for  (  Node  sourceChild  :  sourceChildren  )  {  if  (  sourceChild  instanceof  Element  )  {  Element  sourceEl  =    (  Element  )  sourceChild  ;    [ATTENTION]      numDiscarded  +  =  meta  .  numAttribsDiscarded  ;  numDiscarded  +  =  copySafeNodes  (  sourceEl  ,  destChild  )  ;  //  recurs  }  else  {  //  not  a  safe  tag  ,  but  it  may  have  children  (  els  or  text  )  that  are  ,  so  recurse  numDiscarded++  ;  numDiscarded  +  =  copySafeNodes  (  sourceEl  ,  dest  )  ;  }  }  else  if  (  sourceChild  instanceof  TextNode  )  {  TextNode  sourceText  =    (  TextNode  )  sourceChild  ;  TextNode  destText  =  new  TextNode  (  sourceText  .  getWholeText  (  )  ,  sourceChild  .  baseUri  (  )  )  ;  dest  .  appendChild  (  destText  )  ;  }  //  else  ,  we  don't  care  about  comments  ,  xml  proc  instructions  ,  etc  }  return  numDiscarded  ;  }    [METHOD]  copySafeNodes  [TYPE]  int  [PARAMETER]  Element  source  Element  dest  [CLASS]  Cleaner  ElementMeta    [TYPE]  ElementMeta  meta  [TYPE]  boolean  false  true  [TYPE]  Element  dest  destChild  el  source  sourceEl  [TYPE]  Node  sourceChild  [TYPE]  Whitelist  whitelist  [TYPE]  List  sourceChildren  [TYPE]  TextNode  destText  sourceText  [TYPE]  int  numAttribsDiscarded  numDiscarded  
[REPLACE]  numDiscarded  +=  copySafeNodes  (  sourceEl,  dest  )  ;	[BUGGY]  numDiscarded  +  =  copySafeNodes  (  sourceEl  ,  destChild  )  ;    ;  [CE]  cannot  find  symbol  destChild  [CONTEXT]  if  (  whitelist  .  isSafeTag  (  sourceEl  .  tagName  (  )  )  )  {  //  safe  ,  clone  and  copy  safe  attrs  ElementMeta  meta  =  createSafeElement  (  sourceEl  )  ;  Element  destChild  =  meta  .  el  ;  dest  .  appendChild  (  destChild  )  ;    numDiscarded  +  =  meta  .  numAttribsDiscarded  ;  numDiscarded  +  =  copySafeNodes  (  sourceEl  ,  destChild  )  ;  //  recurs  }  else  {  //  not  a  safe  tag  ,  but  it  may  have  children  (  els  or  text  )  that  are  ,  so  recurse  numDiscarded++  ;  [ATTENTION]  numDiscarded  +  =  copySafeNodes  (  sourceEl  ,  destChild  )    ;    ;  }    [METHOD]  copySafeNodes  [TYPE]  int  [PARAMETER]  Element  source  Element  dest  [CLASS]  Cleaner  ElementMeta    [TYPE]  ElementMeta  meta  [TYPE]  boolean  false  true  [TYPE]  Element  dest  destChild  el  source  sourceEl  [TYPE]  Node  sourceChild  [TYPE]  Whitelist  whitelist  [TYPE]  List  sourceChildren  [TYPE]  TextNode  destText  sourceText  [TYPE]  int  numAttribsDiscarded  numDiscarded  
[REPLACE]  numDiscarded  +=  meta  .  numAttribsDiscarded;	[BUGGY]  numDiscarded  +  =    null  .  numAttribsDiscarded  ;  [CE]  <null>  cannot  be  dereferenced  [CONTEXT]  private  int  copySafeNodes  (  Element  source  ,  Element  dest  )  {  List<Node>  sourceChildren  =  source  .  childNodes  (  )  ;  int  numDiscarded  =  0  ;    for  (  Node  sourceChild  :  sourceChildren  )  {  if  (  sourceChild  instanceof  Element  )  {  Element  sourceEl  =    (  Element  )  sourceChild  ;    if  (  whitelist  .  isSafeTag  (  sourceEl  .  tagName  (  )  )  )  {  //  safe  ,  clone  and  copy  safe  attrs  ElementMeta  meta  =  createSafeElement  (  sourceEl  )  ;  Element  destChild  =  meta  .  el  ;  dest  .  appendChild  (  destChild  )  ;    [ATTENTION]  numDiscarded  +  =  null  .  numAttribsDiscarded  ;  numDiscarded  +  =  copySafeNodes  (  sourceEl  ,  destChild  )  ;  //  recurs  }  else  {  //  not  a  safe  tag  ,  but  it  may  have  children  (  els  or  text  )  that  are  ,  so  recurse  numDiscarded++  ;  numDiscarded  +  =  copySafeNodes  (  sourceEl  ,  dest  )  ;  }  }  else  if  (  sourceChild  instanceof  TextNode  )  {  TextNode  sourceText  =    (  TextNode  )  sourceChild  ;  TextNode  destText  =  new  TextNode  (  sourceText  .  getWholeText  (  )  ,  sourceChild  .  baseUri  (  )  )  ;  dest  .  appendChild  (  destText  )  ;  }  //  else  ,  we  don't  care  about  comments  ,  xml  proc  instructions  ,  etc  }  return  numDiscarded  ;  }    [METHOD]  copySafeNodes  [TYPE]  int  [PARAMETER]  Element  source  Element  dest  [CLASS]  Cleaner  ElementMeta    [TYPE]  ElementMeta  meta  [TYPE]  boolean  false  true  [TYPE]  Element  dest  destChild  el  source  sourceEl  [TYPE]  Node  sourceChild  [TYPE]  Whitelist  whitelist  [TYPE]  List  sourceChildren  [TYPE]  TextNode  destText  sourceText  [TYPE]  int  numAttribsDiscarded  numDiscarded  
[REPLACE]  numDiscarded  +=  copySafeNodes  (  sourceEl,  destChild  )  ;	[BUGGY]  numDiscarded  +  =  copySafeNodes  (  sourceEl  ,  dest  )  ;    ;  [FE]  AssertionFailedError    expected:<<p><[a  rel  =   "nofollow ">Dodgy</a>  <a  href  =   "http://nice.com "  rel  =   "nofollow ">Nice</a></p><blockquote>Hello</blockquote>]>  but  was:<<p><[/p><a  rel  =   "nofollow "></a>Dodgy  <a  href  =   "http://nice.com "  rel  =   "nofollow "></a>Nice<blockquote></blockquote>Hello]>  assertEquals( "<p><a  rel  =  \ "nofollow\ ">Dodgy</a>  <a  href  =  \ "http://nice.com\ "  rel  =  \ "nofollow\ ">Nice</a></p><blockquote>Hello</blockquote> "  ,  [CONTEXT]  private  int  copySafeNodes  (  Element  source  ,  Element  dest  )  {  List<Node>  sourceChildren  =  source  .  childNodes  (  )  ;  int  numDiscarded  =  0  ;    for  (  Node  sourceChild  :  sourceChildren  )  {  if  (  sourceChild  instanceof  Element  )  {  Element  sourceEl  =    (  Element  )  sourceChild  ;    if  (  whitelist  .  isSafeTag  (  sourceEl  .  tagName  (  )  )  )  {  //  safe  ,  clone  and  copy  safe  attrs  ElementMeta  meta  =  createSafeElement  (  sourceEl  )  ;  Element  destChild  =  meta  .  el  ;  dest  .  appendChild  (  destChild  )  ;    numDiscarded  +  =  meta  .  numAttribsDiscarded  ;  [ATTENTION]  numDiscarded  +  =  copySafeNodes  (  sourceEl  ,  dest  )    ;    ;  }  else  {  //  not  a  safe  tag  ,  but  it  may  have  children  (  els  or  text  )  that  are  ,  so  recurse  numDiscarded++  ;  numDiscarded  +  =  copySafeNodes  (  sourceEl  ,  dest  )  ;  }  }  else  if  (  sourceChild  instanceof  TextNode  )  {  TextNode  sourceText  =    (  TextNode  )  sourceChild  ;  TextNode  destText  =  new  TextNode  (  sourceText  .  getWholeText  (  )  ,  sourceChild  .  baseUri  (  )  )  ;  dest  .  appendChild  (  destText  )  ;  }  //  else  ,  we  don't  care  about  comments  ,  xml  proc  instructions  ,  etc  }  return  numDiscarded  ;  }    [METHOD]  copySafeNodes  [TYPE]  int  [PARAMETER]  Element  source  Element  dest  [CLASS]  Cleaner  ElementMeta    [TYPE]  ElementMeta  meta  [TYPE]  boolean  false  true  [TYPE]  Element  dest  destChild  el  source  sourceEl  [TYPE]  Node  sourceChild  [TYPE]  Whitelist  whitelist  [TYPE]  List  sourceChildren  [TYPE]  TextNode  destText  sourceText  [TYPE]  int  numAttribsDiscarded  numDiscarded  
[ADD]  numDiscarded  +=  copySafeNodes  (  sourceEl,  destChild  )  ;	[BUGGY]  [FE]  AssertionFailedError    expected:<<p><[a  rel  =   "nofollow ">Dodgy</a>  <a  href  =   "http://nice.com "  rel  =   "nofollow ">Nice</a></p><blockquote>Hello]</blockquote>>  but  was:<<p><[/p><blockquote>]</blockquote>>  assertEquals( "<p><a  rel  =  \ "nofollow\ ">Dodgy</a>  <a  href  =  \ "http://nice.com\ "  rel  =  \ "nofollow\ ">Nice</a></p><blockquote>Hello</blockquote> "  ,  [CONTEXT]  private  int  copySafeNodes  (  Element  source  ,  Element  dest  )  {  List<Node>  sourceChildren  =  source  .  childNodes  (  )  ;  int  numDiscarded  =  0  ;    for  (  Node  sourceChild  :  sourceChildren  )  {  if  (  sourceChild  instanceof  Element  )  {  Element  sourceEl  =    (  Element  )  sourceChild  ;    if  (  whitelist  .  isSafeTag  (  sourceEl  .  tagName  (  )  )  )  {  //  safe  ,  clone  and  copy  safe  attrs  ElementMeta  meta  =  createSafeElement  (  sourceEl  )  ;  Element  destChild  =  meta  .  el  ;  dest  .  appendChild  (  destChild  )  ;    numDiscarded  +  =  meta  .  numAttribsDiscarded  ;  [ATTENTION]  }  else  {  //  not  a  safe  tag  ,  but  it  may  have  children  (  els  or  text  )  that  are  ,  so  recurse  numDiscarded++  ;  numDiscarded  +  =  copySafeNodes  (  sourceEl  ,  dest  )  ;  }  }  else  if  (  sourceChild  instanceof  TextNode  )  {  TextNode  sourceText  =    (  TextNode  )  sourceChild  ;  TextNode  destText  =  new  TextNode  (  sourceText  .  getWholeText  (  )  ,  sourceChild  .  baseUri  (  )  )  ;  dest  .  appendChild  (  destText  )  ;  }  //  else  ,  we  don't  care  about  comments  ,  xml  proc  instructions  ,  etc  }  return  numDiscarded  ;  }    [METHOD]  copySafeNodes  [TYPE]  int  [PARAMETER]  Element  source  Element  dest  [CLASS]  Cleaner  ElementMeta    [TYPE]  ElementMeta  meta  [TYPE]  boolean  false  true  [TYPE]  Element  dest  destChild  el  source  sourceEl  [TYPE]  Node  sourceChild  [TYPE]  Whitelist  whitelist  [TYPE]  List  sourceChildren  [TYPE]  TextNode  destText  sourceText  [TYPE]  int  numAttribsDiscarded  numDiscarded  
[REPLACE]  ElementMeta  meta  =  createSafeElement  (  sourceEl  )  ;	[BUGGY]  ElementMeta  meta  =  createSafeElement  (  el  )  ;  [CE]  cannot  find  symbol  el  [CONTEXT]  private  int  copySafeNodes  (  Element  source  ,  Element  dest  )  {  List<Node>  sourceChildren  =  source  .  childNodes  (  )  ;  int  numDiscarded  =  0  ;    for  (  Node  sourceChild  :  sourceChildren  )  {  if  (  sourceChild  instanceof  Element  )  {  Element  sourceEl  =    (  Element  )  sourceChild  ;    if  (  whitelist  .  isSafeTag  (  sourceEl  .  tagName  (  )  )  )  {  //  safe  ,  clone  and  copy  safe  attrs  [ATTENTION]  ElementMeta  meta  =  createSafeElement  (  el  )    ;  Element  destChild  =  meta  .  el  ;  dest  .  appendChild  (  destChild  )  ;    numDiscarded  +  =  meta  .  numAttribsDiscarded  ;  numDiscarded  +  =  copySafeNodes  (  sourceEl  ,  destChild  )  ;  //  recurs  }  else  {  //  not  a  safe  tag  ,  but  it  may  have  children  (  els  or  text  )  that  are  ,  so  recurse  numDiscarded++  ;  numDiscarded  +  =  copySafeNodes  (  sourceEl  ,  dest  )  ;  }  }  else  if  (  sourceChild  instanceof  TextNode  )  {  TextNode  sourceText  =    (  TextNode  )  sourceChild  ;  TextNode  destText  =  new  TextNode  (  sourceText  .  getWholeText  (  )  ,  sourceChild  .  baseUri  (  )  )  ;  dest  .  appendChild  (  destText  )  ;  }  //  else  ,  we  don't  care  about  comments  ,  xml  proc  instructions  ,  etc  }  return  numDiscarded  ;  }    [METHOD]  copySafeNodes  [TYPE]  int  [PARAMETER]  Element  source  Element  dest  [CLASS]  Cleaner  ElementMeta    [TYPE]  ElementMeta  meta  [TYPE]  boolean  false  true  [TYPE]  Element  dest  destChild  el  source  sourceEl  [TYPE]  Node  sourceChild  [TYPE]  Whitelist  whitelist  [TYPE]  List  sourceChildren  [TYPE]  TextNode  destText  sourceText  [TYPE]  int  numAttribsDiscarded  numDiscarded  
[REPLACE]  Element  destChild  =  meta  .  el;	[BUGGY]  Element  sourceEl  =    (  Element  )  sourceChild  ;  [CE]  variable  sourceEl  is  already  defined  in  method  copySafeNodes(Element  ,  Element)  [CONTEXT]  private  int  copySafeNodes  (  Element  source  ,  Element  dest  )  {  List<Node>  sourceChildren  =  source  .  childNodes  (  )  ;  int  numDiscarded  =  0  ;    for  (  Node  sourceChild  :  sourceChildren  )  {  if  (  sourceChild  instanceof  Element  )  {  Element  sourceEl  =    (  Element  )  sourceChild  ;    if  (  whitelist  .  isSafeTag  (  sourceEl  .  tagName  (  )  )  )  {  //  safe  ,  clone  and  copy  safe  attrs  ElementMeta  meta  =  createSafeElement  (  sourceEl  )  ;  [ATTENTION]  Element  sourceEl  =  (  Element  )  sourceChild  ;  dest  .  appendChild  (  destChild  )  ;    numDiscarded  +  =  meta  .  numAttribsDiscarded  ;  numDiscarded  +  =  copySafeNodes  (  sourceEl  ,  destChild  )  ;  //  recurs  }  else  {  //  not  a  safe  tag  ,  but  it  may  have  children  (  els  or  text  )  that  are  ,  so  recurse  numDiscarded++  ;  numDiscarded  +  =  copySafeNodes  (  sourceEl  ,  dest  )  ;  }  }  else  if  (  sourceChild  instanceof  TextNode  )  {  TextNode  sourceText  =    (  TextNode  )  sourceChild  ;  TextNode  destText  =  new  TextNode  (  sourceText  .  getWholeText  (  )  ,  sourceChild  .  baseUri  (  )  )  ;  dest  .  appendChild  (  destText  )  ;  }  //  else  ,  we  don't  care  about  comments  ,  xml  proc  instructions  ,  etc  }  return  numDiscarded  ;  }    [METHOD]  copySafeNodes  [TYPE]  int  [PARAMETER]  Element  source  Element  dest  [CLASS]  Cleaner  ElementMeta    [TYPE]  ElementMeta  meta  [TYPE]  boolean  false  true  [TYPE]  Element  dest  destChild  el  source  sourceEl  [TYPE]  Node  sourceChild  [TYPE]  Whitelist  whitelist  [TYPE]  List  sourceChildren  [TYPE]  TextNode  destText  sourceText  [TYPE]  int  numAttribsDiscarded  numDiscarded  
[ADD]  Element  destChild  =  meta  .  el;  dest  .  appendChild  (  destChild  )  ;	[BUGGY]  [CE]  cannot  find  symbol  destChild  [CONTEXT]  private  int  copySafeNodes  (  Element  source  ,  Element  dest  )  {  List<Node>  sourceChildren  =  source  .  childNodes  (  )  ;  int  numDiscarded  =  0  ;    for  (  Node  sourceChild  :  sourceChildren  )  {  if  (  sourceChild  instanceof  Element  )  {  Element  sourceEl  =    (  Element  )  sourceChild  ;    if  (  whitelist  .  isSafeTag  (  sourceEl  .  tagName  (  )  )  )  {  //  safe  ,  clone  and  copy  safe  attrs  ElementMeta  meta  =  createSafeElement  (  sourceEl  )  ;  [ATTENTION]    numDiscarded  +  =  meta  .  numAttribsDiscarded  ;  numDiscarded  +  =  copySafeNodes  (  sourceEl  ,  destChild  )  ;  //  recurs  }  else  {  //  not  a  safe  tag  ,  but  it  may  have  children  (  els  or  text  )  that  are  ,  so  recurse  numDiscarded++  ;  numDiscarded  +  =  copySafeNodes  (  sourceEl  ,  dest  )  ;  }  }  else  if  (  sourceChild  instanceof  TextNode  )  {  TextNode  sourceText  =    (  TextNode  )  sourceChild  ;  TextNode  destText  =  new  TextNode  (  sourceText  .  getWholeText  (  )  ,  sourceChild  .  baseUri  (  )  )  ;  dest  .  appendChild  (  destText  )  ;  }  //  else  ,  we  don't  care  about  comments  ,  xml  proc  instructions  ,  etc  }  return  numDiscarded  ;  }    [METHOD]  copySafeNodes  [TYPE]  int  [PARAMETER]  Element  source  Element  dest  [CLASS]  Cleaner  ElementMeta    [TYPE]  ElementMeta  meta  [TYPE]  boolean  false  true  [TYPE]  Element  dest  destChild  el  source  sourceEl  [TYPE]  Node  sourceChild  [TYPE]  Whitelist  whitelist  [TYPE]  List  sourceChildren  [TYPE]  TextNode  destText  sourceText  [TYPE]  int  numAttribsDiscarded  numDiscarded  
[REPLACE]  numDiscarded  +=  copySafeNodes  (  sourceEl,  dest  )  ;	[BUGGY]  numDiscarded  +  =  copySafeNodes  (  sourceEl  ,  destChild  )  ;    ;  [CE]  cannot  find  symbol  destChild  [CONTEXT]  private  int  copySafeNodes  (  Element  source  ,  Element  dest  )  {  List<Node>  sourceChildren  =  source  .  childNodes  (  )  ;  int  numDiscarded  =  0  ;    for  (  Node  sourceChild  :  sourceChildren  )  {  if  (  sourceChild  instanceof  Element  )  {  Element  sourceEl  =    (  Element  )  sourceChild  ;    if  (  whitelist  .  isSafeTag  (  sourceEl  .  tagName  (  )  )  )  {  //  safe  ,  clone  and  copy  safe  attrs  ElementMeta  meta  =  createSafeElement  (  sourceEl  )  ;  Element  destChild  =  meta  .  el  ;  dest  .  appendChild  (  destChild  )  ;    numDiscarded  +  =  meta  .  numAttribsDiscarded  ;  numDiscarded  +  =  copySafeNodes  (  sourceEl  ,  destChild  )  ;  //  recurs  }  else  {  //  not  a  safe  tag  ,  but  it  may  have  children  (  els  or  text  )  that  are  ,  so  recurse  numDiscarded++  ;  [ATTENTION]  numDiscarded  +  =  copySafeNodes  (  sourceEl  ,  destChild  )    ;    ;  }  }  else  if  (  sourceChild  instanceof  TextNode  )  {  TextNode  sourceText  =    (  TextNode  )  sourceChild  ;  TextNode  destText  =  new  TextNode  (  sourceText  .  getWholeText  (  )  ,  sourceChild  .  baseUri  (  )  )  ;  dest  .  appendChild  (  destText  )  ;  }  //  else  ,  we  don't  care  about  comments  ,  xml  proc  instructions  ,  etc  }  return  numDiscarded  ;  }    [METHOD]  copySafeNodes  [TYPE]  int  [PARAMETER]  Element  source  Element  dest  [CLASS]  Cleaner  ElementMeta    [TYPE]  ElementMeta  meta  [TYPE]  boolean  false  true  [TYPE]  Element  dest  destChild  el  source  sourceEl  [TYPE]  Node  sourceChild  [TYPE]  Whitelist  whitelist  [TYPE]  List  sourceChildren  [TYPE]  TextNode  destText  sourceText  [TYPE]  int  numAttribsDiscarded  numDiscarded  
[REPLACE]  Element  sourceEl  =  (  Element  )  sourceChild;	[BUGGY]  TextNode  sourceText  =    (  TextNode  )  sourceChild  ;  [CE]  cannot  find  symbol  sourceEl  [CONTEXT]  private  int  copySafeNodes  (  Element  source  ,  Element  dest  )  {  List<Node>  sourceChildren  =  source  .  childNodes  (  )  ;  int  numDiscarded  =  0  ;    for  (  Node  sourceChild  :  sourceChildren  )  {  if  (  sourceChild  instanceof  Element  )  {  [ATTENTION]  TextNode  sourceText  =  (  TextNode  )  sourceChild  ;    if  (  whitelist  .  isSafeTag  (  sourceEl  .  tagName  (  )  )  )  {  //  safe  ,  clone  and  copy  safe  attrs  ElementMeta  meta  =  createSafeElement  (  sourceEl  )  ;  Element  destChild  =  meta  .  el  ;  dest  .  appendChild  (  destChild  )  ;    numDiscarded  +  =  meta  .  numAttribsDiscarded  ;  numDiscarded  +  =  copySafeNodes  (  sourceEl  ,  destChild  )  ;  //  recurs  }  else  {  //  not  a  safe  tag  ,  but  it  may  have  children  (  els  or  text  )  that  are  ,  so  recurse  numDiscarded++  ;  numDiscarded  +  =  copySafeNodes  (  sourceEl  ,  dest  )  ;  }  }  else  if  (  sourceChild  instanceof  TextNode  )  {  TextNode  sourceText  =    (  TextNode  )  sourceChild  ;  TextNode  destText  =  new  TextNode  (  sourceText  .  getWholeText  (  )  ,  sourceChild  .  baseUri  (  )  )  ;  dest  .  appendChild  (  destText  )  ;  }  //  else  ,  we  don't  care  about  comments  ,  xml  proc  instructions  ,  etc  }  return  numDiscarded  ;  }    [METHOD]  copySafeNodes  [TYPE]  int  [PARAMETER]  Element  source  Element  dest  [CLASS]  Cleaner  ElementMeta    [TYPE]  ElementMeta  meta  [TYPE]  boolean  false  true  [TYPE]  Element  dest  destChild  el  source  sourceEl  [TYPE]  Node  sourceChild  [TYPE]  Whitelist  whitelist  [TYPE]  List  sourceChildren  [TYPE]  TextNode  destText  sourceText  [TYPE]  int  numAttribsDiscarded  numDiscarded  
[ADD]  Element  sourceEl  =  (  Element  )  sourceChild;	[BUGGY]  [CE]  cannot  find  symbol  sourceEl  [CONTEXT]  private  int  copySafeNodes  (  Element  source  ,  Element  dest  )  {  List<Node>  sourceChildren  =  source  .  childNodes  (  )  ;  int  numDiscarded  =  0  ;    for  (  Node  sourceChild  :  sourceChildren  )  {  if  (  sourceChild  instanceof  Element  )  {  [ATTENTION]    if  (  whitelist  .  isSafeTag  (  sourceEl  .  tagName  (  )  )  )  {  //  safe  ,  clone  and  copy  safe  attrs  ElementMeta  meta  =  createSafeElement  (  sourceEl  )  ;  Element  destChild  =  meta  .  el  ;  dest  .  appendChild  (  destChild  )  ;    numDiscarded  +  =  meta  .  numAttribsDiscarded  ;  numDiscarded  +  =  copySafeNodes  (  sourceEl  ,  destChild  )  ;  //  recurs  }  else  {  //  not  a  safe  tag  ,  but  it  may  have  children  (  els  or  text  )  that  are  ,  so  recurse  numDiscarded++  ;  numDiscarded  +  =  copySafeNodes  (  sourceEl  ,  dest  )  ;  }  }  else  if  (  sourceChild  instanceof  TextNode  )  {  TextNode  sourceText  =    (  TextNode  )  sourceChild  ;  TextNode  destText  =  new  TextNode  (  sourceText  .  getWholeText  (  )  ,  sourceChild  .  baseUri  (  )  )  ;  dest  .  appendChild  (  destText  )  ;  }  //  else  ,  we  don't  care  about  comments  ,  xml  proc  instructions  ,  etc  }  return  numDiscarded  ;  }    [METHOD]  copySafeNodes  [TYPE]  int  [PARAMETER]  Element  source  Element  dest  [CLASS]  Cleaner  ElementMeta    [TYPE]  ElementMeta  meta  [TYPE]  boolean  false  true  [TYPE]  Element  dest  destChild  el  source  sourceEl  [TYPE]  Node  sourceChild  [TYPE]  Whitelist  whitelist  [TYPE]  List  sourceChildren  [TYPE]  TextNode  destText  sourceText  [TYPE]  int  numAttribsDiscarded  numDiscarded  
[ADD]  numDiscarded  +=  meta  .  numAttribsDiscarded;	[BUGGY]  [FE]  null  assertTrue(Jsoup.isValid(ok  ,  Whitelist.basic()))  ;  assertFalse(Jsoup.isValid(nok1  ,  Whitelist.basic()))  ;  assertFalse(Jsoup.isValid(nok2  ,  Whitelist.basic()))  ;  [CONTEXT]  private  int  copySafeNodes  (  Element  source  ,  Element  dest  )  {  List<Node>  sourceChildren  =  source  .  childNodes  (  )  ;  int  numDiscarded  =  0  ;    for  (  Node  sourceChild  :  sourceChildren  )  {  if  (  sourceChild  instanceof  Element  )  {  Element  sourceEl  =    (  Element  )  sourceChild  ;    if  (  whitelist  .  isSafeTag  (  sourceEl  .  tagName  (  )  )  )  {  //  safe  ,  clone  and  copy  safe  attrs  ElementMeta  meta  =  createSafeElement  (  sourceEl  )  ;  Element  destChild  =  meta  .  el  ;  dest  .  appendChild  (  destChild  )  ;    [ATTENTION]  numDiscarded  +  =  copySafeNodes  (  sourceEl  ,  destChild  )  ;  //  recurs  }  else  {  //  not  a  safe  tag  ,  but  it  may  have  children  (  els  or  text  )  that  are  ,  so  recurse  numDiscarded++  ;  numDiscarded  +  =  copySafeNodes  (  sourceEl  ,  dest  )  ;  }  }  else  if  (  sourceChild  instanceof  TextNode  )  {  TextNode  sourceText  =    (  TextNode  )  sourceChild  ;  TextNode  destText  =  new  TextNode  (  sourceText  .  getWholeText  (  )  ,  sourceChild  .  baseUri  (  )  )  ;  dest  .  appendChild  (  destText  )  ;  }  //  else  ,  we  don't  care  about  comments  ,  xml  proc  instructions  ,  etc  }  return  numDiscarded  ;  }    [METHOD]  copySafeNodes  [TYPE]  int  [PARAMETER]  Element  source  Element  dest  [CLASS]  Cleaner  ElementMeta    [TYPE]  ElementMeta  meta  [TYPE]  boolean  false  true  [TYPE]  Element  dest  destChild  el  source  sourceEl  [TYPE]  Node  sourceChild  [TYPE]  Whitelist  whitelist  [TYPE]  List  sourceChildren  [TYPE]  TextNode  destText  sourceText  [TYPE]  int  numAttribsDiscarded  numDiscarded  
[REPLACE]  }  else  if  (  sourceChild  instanceof  TextNode  )  {	[BUGGY]    else  {[FE]  org.jsoup.nodes.DataNode  cannot  be  cast  to  org.jsoup.nodes.TextNode  assertEquals( " "  ,  cleanHtml)  ;  [CONTEXT]  private  int  copySafeNodes  (  Element  source  ,  Element  dest  )  {  List<Node>  sourceChildren  =  source  .  childNodes  (  )  ;  int  numDiscarded  =  0  ;    for  (  Node  sourceChild  :  sourceChildren  )  {  if  (  sourceChild  instanceof  Element  )  {  Element  sourceEl  =    (  Element  )  sourceChild  ;    if  (  whitelist  .  isSafeTag  (  sourceEl  .  tagName  (  )  )  )  {  //  safe  ,  clone  and  copy  safe  attrs  ElementMeta  meta  =  createSafeElement  (  sourceEl  )  ;  Element  destChild  =  meta  .  el  ;  dest  .  appendChild  (  destChild  )  ;    numDiscarded  +  =  meta  .  numAttribsDiscarded  ;  numDiscarded  +  =  copySafeNodes  (  sourceEl  ,  destChild  )  ;  //  recurs  }  else  {  //  not  a  safe  tag  ,  but  it  may  have  children  (  els  or  text  )  that  are  ,  so  recurse  numDiscarded++  ;  numDiscarded  +  =  copySafeNodes  (  sourceEl  ,  dest  )  ;  }  [ATTENTION]  }else  {  TextNode  sourceText  =    (  TextNode  )  sourceChild  ;  TextNode  destText  =  new  TextNode  (  sourceText  .  getWholeText  (  )  ,  sourceChild  .  baseUri  (  )  )  ;  dest  .  appendChild  (  destText  )  ;  }  //  else  ,  we  don't  care  about  comments  ,  xml  proc  instructions  ,  etc  }  return  numDiscarded  ;  }    [METHOD]  copySafeNodes  [TYPE]  int  [PARAMETER]  Element  source  Element  dest  [CLASS]  Cleaner  ElementMeta    [TYPE]  ElementMeta  meta  [TYPE]  boolean  false  true  [TYPE]  Element  dest  destChild  el  source  sourceEl  [TYPE]  Node  sourceChild  [TYPE]  Whitelist  whitelist  [TYPE]  List  sourceChildren  [TYPE]  TextNode  destText  sourceText  [TYPE]  int  numAttribsDiscarded  numDiscarded  
[REPLACE]  TextNode  destText  =  new  TextNode  (  sourceText  .  getWholeText  (  )  ,  sourceChild  .  baseUri  (  )  )  ;	[BUGGY]  TextNode  destText  =  new  TextNode  (  sourceText  .  getWholeText  (  )  ,  sourceChild  .  createShell  (  )    )  ;  [CE]  cannot  find  symbol  [CONTEXT]  private  int  copySafeNodes  (  Element  source  ,  Element  dest  )  {  List<Node>  sourceChildren  =  source  .  childNodes  (  )  ;  int  numDiscarded  =  0  ;    for  (  Node  sourceChild  :  sourceChildren  )  {  if  (  sourceChild  instanceof  Element  )  {  Element  sourceEl  =    (  Element  )  sourceChild  ;    if  (  whitelist  .  isSafeTag  (  sourceEl  .  tagName  (  )  )  )  {  //  safe  ,  clone  and  copy  safe  attrs  ElementMeta  meta  =  createSafeElement  (  sourceEl  )  ;  Element  destChild  =  meta  .  el  ;  dest  .  appendChild  (  destChild  )  ;    numDiscarded  +  =  meta  .  numAttribsDiscarded  ;  numDiscarded  +  =  copySafeNodes  (  sourceEl  ,  destChild  )  ;  //  recurs  }  else  {  //  not  a  safe  tag  ,  but  it  may  have  children  (  els  or  text  )  that  are  ,  so  recurse  numDiscarded++  ;  numDiscarded  +  =  copySafeNodes  (  sourceEl  ,  dest  )  ;  }  }  else  if  (  sourceChild  instanceof  TextNode  )  {  TextNode  sourceText  =    (  TextNode  )  sourceChild  ;  [ATTENTION]  TextNode  destText  =  new  TextNode  (  sourceText  .  getWholeText  (  )    ,  sourceChild  .  createShell  (  )    )    ;  dest  .  appendChild  (  destText  )  ;  }  //  else  ,  we  don't  care  about  comments  ,  xml  proc  instructions  ,  etc  }  return  numDiscarded  ;  }    [METHOD]  copySafeNodes  [TYPE]  int  [PARAMETER]  Element  source  Element  dest  [CLASS]  Cleaner  ElementMeta    [TYPE]  ElementMeta  meta  [TYPE]  boolean  false  true  [TYPE]  Element  dest  destChild  el  source  sourceEl  [TYPE]  Node  sourceChild  [TYPE]  Whitelist  whitelist  [TYPE]  List  sourceChildren  [TYPE]  TextNode  destText  sourceText  [TYPE]  int  numAttribsDiscarded  numDiscarded  
[REPLACE]  for  (  Node  sourceChild  :  sourceChildren  )  {	[BUGGY]  String  sourceTag  =  sourceEl  .  tagName  (  )  ;  [CE]  illegal  start  of  type  [CONTEXT]  private  int  copySafeNodes  (  Element  source  ,  Element  dest  )  {  List<Node>  sourceChildren  =  source  .  childNodes  (  )  ;  int  numDiscarded  =  0  ;    [ATTENTION]  String  sourceTag  =  sourceEl  .  tagName  (  )    ;  if  (  sourceChild  instanceof  Element  )  {  Element  sourceEl  =    (  Element  )  sourceChild  ;    if  (  whitelist  .  isSafeTag  (  sourceEl  .  tagName  (  )  )  )  {  //  safe  ,  clone  and  copy  safe  attrs  ElementMeta  meta  =  createSafeElement  (  sourceEl  )  ;  Element  destChild  =  meta  .  el  ;  dest  .  appendChild  (  destChild  )  ;    numDiscarded  +  =  meta  .  numAttribsDiscarded  ;  numDiscarded  +  =  copySafeNodes  (  sourceEl  ,  destChild  )  ;  //  recurs  }  else  {  //  not  a  safe  tag  ,  but  it  may  have  children  (  els  or  text  )  that  are  ,  so  recurse  numDiscarded++  ;  numDiscarded  +  =  copySafeNodes  (  sourceEl  ,  dest  )  ;  }  }  else  if  (  sourceChild  instanceof  TextNode  )  {  TextNode  sourceText  =    (  TextNode  )  sourceChild  ;  TextNode  destText  =  new  TextNode  (  sourceText  .  getWholeText  (  )  ,  sourceChild  .  baseUri  (  )  )  ;  dest  .  appendChild  (  destText  )  ;  }  //  else  ,  we  don't  care  about  comments  ,  xml  proc  instructions  ,  etc  }  return  numDiscarded  ;  }    [METHOD]  copySafeNodes  [TYPE]  int  [PARAMETER]  Element  source  Element  dest  [CLASS]  Cleaner  ElementMeta    [TYPE]  ElementMeta  meta  [TYPE]  boolean  false  true  [TYPE]  Element  dest  destChild  el  source  sourceEl  [TYPE]  Node  sourceChild  [TYPE]  Whitelist  whitelist  [TYPE]  List  sourceChildren  [TYPE]  TextNode  destText  sourceText  [TYPE]  int  numAttribsDiscarded  numDiscarded  
[REPLACE]  ElementMeta  meta  =  createSafeElement  (  sourceEl  )  ;	[BUGGY]  ElementMeta  meta  =  createSafeElement  (  source  )  ;  [FE]  AssertionFailedError    expected:<<[img  alt  =   " "  /]>>  but  was:<<[body>  assertEquals( "<img  alt  =  \ "\ "  /> "  ,  cleanHtml)  ;  [CONTEXT]  private  int  copySafeNodes  (  Element  source  ,  Element  dest  )  {  List<Node>  sourceChildren  =  source  .  childNodes  (  )  ;  int  numDiscarded  =  0  ;    for  (  Node  sourceChild  :  sourceChildren  )  {  if  (  sourceChild  instanceof  Element  )  {  Element  sourceEl  =    (  Element  )  sourceChild  ;    if  (  whitelist  .  isSafeTag  (  sourceEl  .  tagName  (  )  )  )  {  //  safe  ,  clone  and  copy  safe  attrs  [ATTENTION]  ElementMeta  meta  =  createSafeElement  (  source  )    ;  Element  destChild  =  meta  .  el  ;  dest  .  appendChild  (  destChild  )  ;    numDiscarded  +  =  meta  .  numAttribsDiscarded  ;  numDiscarded  +  =  copySafeNodes  (  sourceEl  ,  destChild  )  ;  //  recurs  }  else  {  //  not  a  safe  tag  ,  but  it  may  have  children  (  els  or  text  )  that  are  ,  so  recurse  numDiscarded++  ;  numDiscarded  +  =  copySafeNodes  (  sourceEl  ,  dest  )  ;  }  }  else  if  (  sourceChild  instanceof  TextNode  )  {  TextNode  sourceText  =    (  TextNode  )  sourceChild  ;  TextNode  destText  =  new  TextNode  (  sourceText  .  getWholeText  (  )  ,  sourceChild  .  baseUri  (  )  )  ;  dest  .  appendChild  (  destText  )  ;  }  //  else  ,  we  don't  care  about  comments  ,  xml  proc  instructions  ,  etc  }  return  numDiscarded  ;  }    [METHOD]  copySafeNodes  [TYPE]  int  [PARAMETER]  Element  source  Element  dest  [CLASS]  Cleaner  ElementMeta    [TYPE]  ElementMeta  meta  [TYPE]  boolean  false  true  [TYPE]  Element  dest  destChild  el  source  sourceEl  [TYPE]  Node  sourceChild  [TYPE]  Whitelist  whitelist  [TYPE]  List  sourceChildren  [TYPE]  TextNode  destText  sourceText  [TYPE]  int  numAttribsDiscarded  numDiscarded  
[REPLACE]  return  numDiscarded;	[BUGGY]  return  numAttribsDiscarded  ;  [CE]  cannot  find  symbol  numAttribsDiscarded  [CONTEXT]  private  int  copySafeNodes  (  Element  source  ,  Element  dest  )  {  List<Node>  sourceChildren  =  source  .  childNodes  (  )  ;  int  numDiscarded  =  0  ;    for  (  Node  sourceChild  :  sourceChildren  )  {  if  (  sourceChild  instanceof  Element  )  {  Element  sourceEl  =    (  Element  )  sourceChild  ;    if  (  whitelist  .  isSafeTag  (  sourceEl  .  tagName  (  )  )  )  {  //  safe  ,  clone  and  copy  safe  attrs  ElementMeta  meta  =  createSafeElement  (  sourceEl  )  ;  Element  destChild  =  meta  .  el  ;  dest  .  appendChild  (  destChild  )  ;    numDiscarded  +  =  meta  .  numAttribsDiscarded  ;  numDiscarded  +  =  copySafeNodes  (  sourceEl  ,  destChild  )  ;  //  recurs  }  else  {  //  not  a  safe  tag  ,  but  it  may  have  children  (  els  or  text  )  that  are  ,  so  recurse  numDiscarded++  ;  numDiscarded  +  =  copySafeNodes  (  sourceEl  ,  dest  )  ;  }  }  else  if  (  sourceChild  instanceof  TextNode  )  {  TextNode  sourceText  =    (  TextNode  )  sourceChild  ;  TextNode  destText  =  new  TextNode  (  sourceText  .  getWholeText  (  )  ,  sourceChild  .  baseUri  (  )  )  ;  dest  .  appendChild  (  destText  )  ;  }  //  else  ,  we  don't  care  about  comments  ,  xml  proc  instructions  ,  etc  }  [ATTENTION]  return  numAttribsDiscarded  ;  }    [METHOD]  copySafeNodes  [TYPE]  int  [PARAMETER]  Element  source  Element  dest  [CLASS]  Cleaner  ElementMeta    [TYPE]  ElementMeta  meta  [TYPE]  boolean  false  true  [TYPE]  Element  dest  destChild  el  source  sourceEl  [TYPE]  Node  sourceChild  [TYPE]  Whitelist  whitelist  [TYPE]  List  sourceChildren  [TYPE]  TextNode  destText  sourceText  [TYPE]  int  numAttribsDiscarded  numDiscarded  
[REPLACE]  String  sourceTag  =  sourceEl  .  tagName  (  )  ;	[BUGGY]  String  sourceTag  =  source  .  tagName  (  )  ;  [CE]  cannot  find  symbol  source  [CONTEXT]  private  ElementMeta  createSafeElement  (  Element  sourceEl  )  {  [ATTENTION]  String  sourceTag  =  source  .  tagName  (  )    ;  Attributes  destAttrs  =  new  Attributes  (  )  ;  Element  dest  =  new  Element  (  Tag  .  valueOf  (  sourceTag  )  ,  sourceEl  .  baseUri  (  )  ,  destAttrs  )  ;  int  numDiscarded  =  0  ;    Attributes  sourceAttrs  =  sourceEl  .  attributes  (  )  ;  for  (  Attribute  sourceAttr  :  sourceAttrs  )  {  if  (  whitelist  .  isSafeAttribute  (  sourceTag  ,  sourceEl  ,  sourceAttr  )  )  destAttrs  .  put  (  sourceAttr  )  ;  else  numDiscarded++  ;  }  Attributes  enforcedAttrs  =  whitelist  .  getEnforcedAttributes  (  sourceTag  )  ;  destAttrs  .  addAll  (  enforcedAttrs  )  ;    return  new  ElementMeta  (  dest  ,  numDiscarded  )  ;  }    [METHOD]  createSafeElement  [TYPE]  Cleaner$ElementMeta  [PARAMETER]  Element  sourceEl  [CLASS]  Cleaner  ElementMeta    [TYPE]  boolean  false  true  [TYPE]  Attribute  sourceAttr  [TYPE]  Element  dest  destChild  el  source  sourceEl  [TYPE]  Attributes  destAttrs  enforcedAttrs  sourceAttrs  [TYPE]  Whitelist  whitelist  [TYPE]  String  sourceTag  [TYPE]  int  numAttribsDiscarded  numDiscarded  
[REPLACE]  Attributes  destAttrs  =  new  Attributes  (  )  ;	[BUGGY]  Attributes  enforcedAttrs  =  whitelist  .  getEnforcedAttributes  (  sourceTag  )  ;  [CE]  cannot  find  symbol  destAttrs  [CONTEXT]  private  ElementMeta  createSafeElement  (  Element  sourceEl  )  {  String  sourceTag  =  sourceEl  .  tagName  (  )  ;  [ATTENTION]  Attributes  enforcedAttrs  =  whitelist  .  getEnforcedAttributes  (  sourceTag  )    ;  Element  dest  =  new  Element  (  Tag  .  valueOf  (  sourceTag  )  ,  sourceEl  .  baseUri  (  )  ,  destAttrs  )  ;  int  numDiscarded  =  0  ;    Attributes  sourceAttrs  =  sourceEl  .  attributes  (  )  ;  for  (  Attribute  sourceAttr  :  sourceAttrs  )  {  if  (  whitelist  .  isSafeAttribute  (  sourceTag  ,  sourceEl  ,  sourceAttr  )  )  destAttrs  .  put  (  sourceAttr  )  ;  else  numDiscarded++  ;  }  Attributes  enforcedAttrs  =  whitelist  .  getEnforcedAttributes  (  sourceTag  )  ;  destAttrs  .  addAll  (  enforcedAttrs  )  ;    return  new  ElementMeta  (  dest  ,  numDiscarded  )  ;  }    [METHOD]  createSafeElement  [TYPE]  Cleaner$ElementMeta  [PARAMETER]  Element  sourceEl  [CLASS]  Cleaner  ElementMeta    [TYPE]  boolean  false  true  [TYPE]  Attribute  sourceAttr  [TYPE]  Element  dest  destChild  el  source  sourceEl  [TYPE]  Attributes  destAttrs  enforcedAttrs  sourceAttrs  [TYPE]  Whitelist  whitelist  [TYPE]  String  sourceTag  [TYPE]  int  numAttribsDiscarded  numDiscarded  
[REPLACE]  Element  dest  =  new  Element  (  Tag  .  valueOf  (  sourceTag  )  ,  sourceEl  .  baseUri  (  )  ,  destAttrs  )  ;	[BUGGY]  Element  dest  =  new  Element  (  Tag  .  valueOf  (  sourceTag  )  ,  sourceEl  .  baseUri  (  )  ,  sourceAttrs  )  ;  [CE]  cannot  find  symbol  sourceAttrs  [CONTEXT]  private  ElementMeta  createSafeElement  (  Element  sourceEl  )  {  String  sourceTag  =  sourceEl  .  tagName  (  )  ;  Attributes  destAttrs  =  new  Attributes  (  )  ;  [ATTENTION]  Element  dest  =  new  Element  (  Tag  .  valueOf  (  sourceTag  )    ,  sourceEl  .  baseUri  (  )    ,  sourceAttrs  )    ;  int  numDiscarded  =  0  ;    Attributes  sourceAttrs  =  sourceEl  .  attributes  (  )  ;  for  (  Attribute  sourceAttr  :  sourceAttrs  )  {  if  (  whitelist  .  isSafeAttribute  (  sourceTag  ,  sourceEl  ,  sourceAttr  )  )  destAttrs  .  put  (  sourceAttr  )  ;  else  numDiscarded++  ;  }  Attributes  enforcedAttrs  =  whitelist  .  getEnforcedAttributes  (  sourceTag  )  ;  destAttrs  .  addAll  (  enforcedAttrs  )  ;    return  new  ElementMeta  (  dest  ,  numDiscarded  )  ;  }    [METHOD]  createSafeElement  [TYPE]  Cleaner$ElementMeta  [PARAMETER]  Element  sourceEl  [CLASS]  Cleaner  ElementMeta    [TYPE]  boolean  false  true  [TYPE]  Attribute  sourceAttr  [TYPE]  Element  dest  destChild  el  source  sourceEl  [TYPE]  Attributes  destAttrs  enforcedAttrs  sourceAttrs  [TYPE]  Whitelist  whitelist  [TYPE]  String  sourceTag  [TYPE]  int  numAttribsDiscarded  numDiscarded  
[REPLACE]  int  numDiscarded  =  0;	[BUGGY]  int  numDiscarded  =  3  ;  [FE]  null  assertTrue(Jsoup.isValid(ok  ,  Whitelist.basic()))  ;  assertFalse(Jsoup.isValid(nok1  ,  Whitelist.basic()))  ;  assertFalse(Jsoup.isValid(nok2  ,  Whitelist.basic()))  ;  [CONTEXT]  private  ElementMeta  createSafeElement  (  Element  sourceEl  )  {  String  sourceTag  =  sourceEl  .  tagName  (  )  ;  Attributes  destAttrs  =  new  Attributes  (  )  ;  Element  dest  =  new  Element  (  Tag  .  valueOf  (  sourceTag  )  ,  sourceEl  .  baseUri  (  )  ,  destAttrs  )  ;  [ATTENTION]  int  numDiscarded  =  3  ;    Attributes  sourceAttrs  =  sourceEl  .  attributes  (  )  ;  for  (  Attribute  sourceAttr  :  sourceAttrs  )  {  if  (  whitelist  .  isSafeAttribute  (  sourceTag  ,  sourceEl  ,  sourceAttr  )  )  destAttrs  .  put  (  sourceAttr  )  ;  else  numDiscarded++  ;  }  Attributes  enforcedAttrs  =  whitelist  .  getEnforcedAttributes  (  sourceTag  )  ;  destAttrs  .  addAll  (  enforcedAttrs  )  ;    return  new  ElementMeta  (  dest  ,  numDiscarded  )  ;  }    [METHOD]  createSafeElement  [TYPE]  Cleaner$ElementMeta  [PARAMETER]  Element  sourceEl  [CLASS]  Cleaner  ElementMeta    [TYPE]  boolean  false  true  [TYPE]  Attribute  sourceAttr  [TYPE]  Element  dest  destChild  el  source  sourceEl  [TYPE]  Attributes  destAttrs  enforcedAttrs  sourceAttrs  [TYPE]  Whitelist  whitelist  [TYPE]  String  sourceTag  [TYPE]  int  numAttribsDiscarded  numDiscarded  
[REPLACE]  Attributes  sourceAttrs  =  sourceEl  .  attributes  (  )  ;	[BUGGY]  Attributes  sourceAttrs  =  sourceEl  .  childNodes  (  )    ;  [CE]  incompatible  types  [CONTEXT]  private  ElementMeta  createSafeElement  (  Element  sourceEl  )  {  String  sourceTag  =  sourceEl  .  tagName  (  )  ;  Attributes  destAttrs  =  new  Attributes  (  )  ;  Element  dest  =  new  Element  (  Tag  .  valueOf  (  sourceTag  )  ,  sourceEl  .  baseUri  (  )  ,  destAttrs  )  ;  int  numDiscarded  =  0  ;    [ATTENTION]  Attributes  sourceAttrs  =  sourceEl  .  childNodes  (  )  ;  for  (  Attribute  sourceAttr  :  sourceAttrs  )  {  if  (  whitelist  .  isSafeAttribute  (  sourceTag  ,  sourceEl  ,  sourceAttr  )  )  destAttrs  .  put  (  sourceAttr  )  ;  else  numDiscarded++  ;  }  Attributes  enforcedAttrs  =  whitelist  .  getEnforcedAttributes  (  sourceTag  )  ;  destAttrs  .  addAll  (  enforcedAttrs  )  ;    return  new  ElementMeta  (  dest  ,  numDiscarded  )  ;  }    [METHOD]  createSafeElement  [TYPE]  Cleaner$ElementMeta  [PARAMETER]  Element  sourceEl  [CLASS]  Cleaner  ElementMeta    [TYPE]  boolean  false  true  [TYPE]  Attribute  sourceAttr  [TYPE]  Element  dest  destChild  el  source  sourceEl  [TYPE]  Attributes  destAttrs  enforcedAttrs  sourceAttrs  [TYPE]  Whitelist  whitelist  [TYPE]  String  sourceTag  [TYPE]  int  numAttribsDiscarded  numDiscarded  
[REPLACE]  if  (  whitelist  .  isSafeAttribute  (  sourceTag,  sourceEl,  sourceAttr  )  )  destAttrs  .  put  (  sourceAttr  )  ;	[BUGGY]  if  (  whitelist  .  isSafeAttribute  (  sourceTag  ,  source  ,  sourceAttr  )  )  destAttrs  .  put  (  sourceAttr  )  ;  [CE]  cannot  find  symbol  source  [CONTEXT]  private  ElementMeta  createSafeElement  (  Element  sourceEl  )  {  String  sourceTag  =  sourceEl  .  tagName  (  )  ;  Attributes  destAttrs  =  new  Attributes  (  )  ;  Element  dest  =  new  Element  (  Tag  .  valueOf  (  sourceTag  )  ,  sourceEl  .  baseUri  (  )  ,  destAttrs  )  ;  int  numDiscarded  =  0  ;    Attributes  sourceAttrs  =  sourceEl  .  attributes  (  )  ;  for  (  Attribute  sourceAttr  :  sourceAttrs  )  {  [ATTENTION]  if  (  whitelist  .  isSafeAttribute  (  sourceTag  ,  source  ,  sourceAttr  )  )  destAttrs  .  put  (  sourceAttr  )    ;    else  numDiscarded++  ;  }  Attributes  enforcedAttrs  =  whitelist  .  getEnforcedAttributes  (  sourceTag  )  ;  destAttrs  .  addAll  (  enforcedAttrs  )  ;    return  new  ElementMeta  (  dest  ,  numDiscarded  )  ;  }    [METHOD]  createSafeElement  [TYPE]  Cleaner$ElementMeta  [PARAMETER]  Element  sourceEl  [CLASS]  Cleaner  ElementMeta    [TYPE]  boolean  false  true  [TYPE]  Attribute  sourceAttr  [TYPE]  Element  dest  destChild  el  source  sourceEl  [TYPE]  Attributes  destAttrs  enforcedAttrs  sourceAttrs  [TYPE]  Whitelist  whitelist  [TYPE]  String  sourceTag  [TYPE]  int  numAttribsDiscarded  numDiscarded  
[ADD]  if  (  whitelist  .  isSafeAttribute  (  sourceTag,  sourceEl,  sourceAttr  )  )  destAttrs  .  put  (  sourceAttr  )  ;  else  numDiscarded++;  }	[BUGGY]  destAttrs  .  put  (  sourceAttr  )  ;  numDiscarded++  ;  [CE]  illegal  start  of  expression  [CONTEXT]  private  ElementMeta  createSafeElement  (  Element  sourceEl  )  {  String  sourceTag  =  sourceEl  .  tagName  (  )  ;  Attributes  destAttrs  =  new  Attributes  (  )  ;  Element  dest  =  new  Element  (  Tag  .  valueOf  (  sourceTag  )  ,  sourceEl  .  baseUri  (  )  ,  destAttrs  )  ;  int  numDiscarded  =  0  ;    Attributes  sourceAttrs  =  sourceEl  .  attributes  (  )  ;  for  (  Attribute  sourceAttr  :  sourceAttrs  )  {  [ATTENTION]  destAttrs  .  put  (  sourceAttr  )    ;  numDiscarded++  ;      Attributes  enforcedAttrs  =  whitelist  .  getEnforcedAttributes  (  sourceTag  )  ;  destAttrs  .  addAll  (  enforcedAttrs  )  ;    return  new  ElementMeta  (  dest  ,  numDiscarded  )  ;  }    [METHOD]  createSafeElement  [TYPE]  Cleaner$ElementMeta  [PARAMETER]  Element  sourceEl  [CLASS]  Cleaner  ElementMeta    [TYPE]  boolean  false  true  [TYPE]  Attribute  sourceAttr  [TYPE]  Element  dest  destChild  el  source  sourceEl  [TYPE]  Attributes  destAttrs  enforcedAttrs  sourceAttrs  [TYPE]  Whitelist  whitelist  [TYPE]  String  sourceTag  [TYPE]  int  numAttribsDiscarded  numDiscarded  
[REPLACE]  destAttrs  .  put  (  sourceAttr  )  ;	[BUGGY]  destAttrs  .  addAll  (  sourceAttr  )  ;  [CE]  method  addAll  in  class  Attributes  cannot  be  applied  to  given  types  ;  [CONTEXT]  private  ElementMeta  createSafeElement  (  Element  sourceEl  )  {  String  sourceTag  =  sourceEl  .  tagName  (  )  ;  Attributes  destAttrs  =  new  Attributes  (  )  ;  Element  dest  =  new  Element  (  Tag  .  valueOf  (  sourceTag  )  ,  sourceEl  .  baseUri  (  )  ,  destAttrs  )  ;  int  numDiscarded  =  0  ;    Attributes  sourceAttrs  =  sourceEl  .  attributes  (  )  ;  for  (  Attribute  sourceAttr  :  sourceAttrs  )  {  if  (  whitelist  .  isSafeAttribute  (  sourceTag  ,  sourceEl  ,  sourceAttr  )  )  [ATTENTION]  destAttrs  .  addAll  (  sourceAttr  )    ;  else  numDiscarded++  ;  }  Attributes  enforcedAttrs  =  whitelist  .  getEnforcedAttributes  (  sourceTag  )  ;  destAttrs  .  addAll  (  enforcedAttrs  )  ;    return  new  ElementMeta  (  dest  ,  numDiscarded  )  ;  }    [METHOD]  createSafeElement  [TYPE]  Cleaner$ElementMeta  [PARAMETER]  Element  sourceEl  [CLASS]  Cleaner  ElementMeta    [TYPE]  boolean  false  true  [TYPE]  Attribute  sourceAttr  [TYPE]  Element  dest  destChild  el  source  sourceEl  [TYPE]  Attributes  destAttrs  enforcedAttrs  sourceAttrs  [TYPE]  Whitelist  whitelist  [TYPE]  String  sourceTag  [TYPE]  int  numAttribsDiscarded  numDiscarded  
[ADD]  destAttrs  .  put  (  sourceAttr  )  ;	[BUGGY]  [CE]  'else'  without  'if'  [CONTEXT]  private  ElementMeta  createSafeElement  (  Element  sourceEl  )  {  String  sourceTag  =  sourceEl  .  tagName  (  )  ;  Attributes  destAttrs  =  new  Attributes  (  )  ;  Element  dest  =  new  Element  (  Tag  .  valueOf  (  sourceTag  )  ,  sourceEl  .  baseUri  (  )  ,  destAttrs  )  ;  int  numDiscarded  =  0  ;    Attributes  sourceAttrs  =  sourceEl  .  attributes  (  )  ;  for  (  Attribute  sourceAttr  :  sourceAttrs  )  {  if  (  whitelist  .  isSafeAttribute  (  sourceTag  ,  sourceEl  ,  sourceAttr  )  )  [ATTENTION]  else  numDiscarded++  ;  }  Attributes  enforcedAttrs  =  whitelist  .  getEnforcedAttributes  (  sourceTag  )  ;  destAttrs  .  addAll  (  enforcedAttrs  )  ;    return  new  ElementMeta  (  dest  ,  numDiscarded  )  ;  }    [METHOD]  createSafeElement  [TYPE]  Cleaner$ElementMeta  [PARAMETER]  Element  sourceEl  [CLASS]  Cleaner  ElementMeta    [TYPE]  boolean  false  true  [TYPE]  Attribute  sourceAttr  [TYPE]  Element  dest  destChild  el  source  sourceEl  [TYPE]  Attributes  destAttrs  enforcedAttrs  sourceAttrs  [TYPE]  Whitelist  whitelist  [TYPE]  String  sourceTag  [TYPE]  int  numAttribsDiscarded  numDiscarded  
[REPLACE]  for  (  Attribute  sourceAttr  :  sourceAttrs  )  {	[BUGGY]  for  (  Node  sourceChild  :  sourceChildren  )  {  if  (  sourceChild  instanceof  Element  )  {[CE]  illegal  start  of  expression  [CONTEXT]  private  ElementMeta  createSafeElement  (  Element  sourceEl  )  {  String  sourceTag  =  sourceEl  .  tagName  (  )  ;  Attributes  destAttrs  =  new  Attributes  (  )  ;  Element  dest  =  new  Element  (  Tag  .  valueOf  (  sourceTag  )  ,  sourceEl  .  baseUri  (  )  ,  destAttrs  )  ;  int  numDiscarded  =  0  ;    Attributes  sourceAttrs  =  sourceEl  .  attributes  (  )  ;  [ATTENTION]  for  (  Node  sourceChild  :  sourceChildren  )  {  if  (  sourceChild  instanceof  Element  )  {  if  (  whitelist  .  isSafeAttribute  (  sourceTag  ,  sourceEl  ,  sourceAttr  )  )  destAttrs  .  put  (  sourceAttr  )  ;  else  numDiscarded++  ;  }  Attributes  enforcedAttrs  =  whitelist  .  getEnforcedAttributes  (  sourceTag  )  ;  destAttrs  .  addAll  (  enforcedAttrs  )  ;    return  new  ElementMeta  (  dest  ,  numDiscarded  )  ;  }    [METHOD]  createSafeElement  [TYPE]  Cleaner$ElementMeta  [PARAMETER]  Element  sourceEl  [CLASS]  Cleaner  ElementMeta    [TYPE]  boolean  false  true  [TYPE]  Attribute  sourceAttr  [TYPE]  Element  dest  destChild  el  source  sourceEl  [TYPE]  Attributes  destAttrs  enforcedAttrs  sourceAttrs  [TYPE]  Whitelist  whitelist  [TYPE]  String  sourceTag  [TYPE]  int  numAttribsDiscarded  numDiscarded  
[REPLACE]  Attributes  enforcedAttrs  =  whitelist  .  getEnforcedAttributes  (  sourceTag  )  ;	[BUGGY]  Attributes  enforcedAttrs  =  whitelist  .  isSafeAttribute  (  sourceTag  ,  source  ,  sourceAttr  )    ;  [CE]  cannot  find  symbol  source  [CONTEXT]  private  ElementMeta  createSafeElement  (  Element  sourceEl  )  {  String  sourceTag  =  sourceEl  .  tagName  (  )  ;  Attributes  destAttrs  =  new  Attributes  (  )  ;  Element  dest  =  new  Element  (  Tag  .  valueOf  (  sourceTag  )  ,  sourceEl  .  baseUri  (  )  ,  destAttrs  )  ;  int  numDiscarded  =  0  ;    Attributes  sourceAttrs  =  sourceEl  .  attributes  (  )  ;  for  (  Attribute  sourceAttr  :  sourceAttrs  )  {  if  (  whitelist  .  isSafeAttribute  (  sourceTag  ,  sourceEl  ,  sourceAttr  )  )  destAttrs  .  put  (  sourceAttr  )  ;  else  numDiscarded++  ;  }  [ATTENTION]  Attributes  enforcedAttrs  =  whitelist  .  isSafeAttribute  (  sourceTag  ,  source  ,  sourceAttr  )  ;  destAttrs  .  addAll  (  enforcedAttrs  )  ;    return  new  ElementMeta  (  dest  ,  numDiscarded  )  ;  }    [METHOD]  createSafeElement  [TYPE]  Cleaner$ElementMeta  [PARAMETER]  Element  sourceEl  [CLASS]  Cleaner  ElementMeta    [TYPE]  boolean  false  true  [TYPE]  Attribute  sourceAttr  [TYPE]  Element  dest  destChild  el  source  sourceEl  [TYPE]  Attributes  destAttrs  enforcedAttrs  sourceAttrs  [TYPE]  Whitelist  whitelist  [TYPE]  String  sourceTag  [TYPE]  int  numAttribsDiscarded  numDiscarded  
[REPLACE]  destAttrs  .  addAll  (  enforcedAttrs  )  ;	[BUGGY]  destAttrs  .  addAll  (  sourceAttrs  )  ;  [FE]  AssertionFailedError    expected:<<img  alt  =   " "  []/>>  but  was:<<img  alt  =   " "  [src  =   " "  ]/>>  assertEquals( "<img  alt  =  \ "\ "  /> "  ,  cleanHtml)  ;  [CONTEXT]  private  ElementMeta  createSafeElement  (  Element  sourceEl  )  {  String  sourceTag  =  sourceEl  .  tagName  (  )  ;  Attributes  destAttrs  =  new  Attributes  (  )  ;  Element  dest  =  new  Element  (  Tag  .  valueOf  (  sourceTag  )  ,  sourceEl  .  baseUri  (  )  ,  destAttrs  )  ;  int  numDiscarded  =  0  ;    Attributes  sourceAttrs  =  sourceEl  .  attributes  (  )  ;  for  (  Attribute  sourceAttr  :  sourceAttrs  )  {  if  (  whitelist  .  isSafeAttribute  (  sourceTag  ,  sourceEl  ,  sourceAttr  )  )  destAttrs  .  put  (  sourceAttr  )  ;  else  numDiscarded++  ;  }  Attributes  enforcedAttrs  =  whitelist  .  getEnforcedAttributes  (  sourceTag  )  ;  [ATTENTION]  destAttrs  .  addAll  (  sourceAttrs  )    ;    return  new  ElementMeta  (  dest  ,  numDiscarded  )  ;  }    [METHOD]  createSafeElement  [TYPE]  Cleaner$ElementMeta  [PARAMETER]  Element  sourceEl  [CLASS]  Cleaner  ElementMeta    [TYPE]  boolean  false  true  [TYPE]  Attribute  sourceAttr  [TYPE]  Element  dest  destChild  el  source  sourceEl  [TYPE]  Attributes  destAttrs  enforcedAttrs  sourceAttrs  [TYPE]  Whitelist  whitelist  [TYPE]  String  sourceTag  [TYPE]  int  numAttribsDiscarded  numDiscarded  
[REPLACE]  return  new  ElementMeta  (  dest,  numDiscarded  )  ;	[BUGGY]  return  new  ElementMeta  (  sourceEl  ,  numDiscarded  )  ;  [FE]  Cannot  (yet)  move  nodes  in  tree  assertEquals( "<img  alt  =  \ "\ "  /> "  ,  cleanHtml)  ;  [CONTEXT]  private  ElementMeta  createSafeElement  (  Element  sourceEl  )  {  String  sourceTag  =  sourceEl  .  tagName  (  )  ;  Attributes  destAttrs  =  new  Attributes  (  )  ;  Element  dest  =  new  Element  (  Tag  .  valueOf  (  sourceTag  )  ,  sourceEl  .  baseUri  (  )  ,  destAttrs  )  ;  int  numDiscarded  =  0  ;    Attributes  sourceAttrs  =  sourceEl  .  attributes  (  )  ;  for  (  Attribute  sourceAttr  :  sourceAttrs  )  {  if  (  whitelist  .  isSafeAttribute  (  sourceTag  ,  sourceEl  ,  sourceAttr  )  )  destAttrs  .  put  (  sourceAttr  )  ;  else  numDiscarded++  ;  }  Attributes  enforcedAttrs  =  whitelist  .  getEnforcedAttributes  (  sourceTag  )  ;  destAttrs  .  addAll  (  enforcedAttrs  )  ;    [ATTENTION]  return  new  ElementMeta  (  sourceEl  ,  numDiscarded  )    ;  }    [METHOD]  createSafeElement  [TYPE]  Cleaner$ElementMeta  [PARAMETER]  Element  sourceEl  [CLASS]  Cleaner  ElementMeta    [TYPE]  boolean  false  true  [TYPE]  Attribute  sourceAttr  [TYPE]  Element  dest  destChild  el  source  sourceEl  [TYPE]  Attributes  destAttrs  enforcedAttrs  sourceAttrs  [TYPE]  Whitelist  whitelist  [TYPE]  String  sourceTag  [TYPE]  int  numAttribsDiscarded  numDiscarded  
[REPLACE]  int  numAttribsDiscarded;	[BUGGY]  long  numAttribsDiscarded  ;  [NO-ERROR]  [CONTEXT]    [METHOD]  createSafeElement  [TYPE]  Cleaner$ElementMeta  [PARAMETER]  Element  sourceEl  [CLASS]  ElementMeta    [TYPE]  boolean  false  true  [TYPE]  Attribute  sourceAttr  [TYPE]  Element  dest  destChild  el  source  sourceEl  [TYPE]  Attributes  destAttrs  enforcedAttrs  sourceAttrs  [TYPE]  Whitelist  whitelist  [TYPE]  String  sourceTag  [TYPE]  int  numAttribsDiscarded  numDiscarded  
[REPLACE]  this  .  el  =  el;	[BUGGY]  this  .  el  =    null  ;  [FE]  The  validated  object  is  null  assertEquals( "<img  alt  =  \ "\ "  /> "  ,  cleanHtml)  ;  [CONTEXT]  ElementMeta  (  Element  el  ,  int  numAttribsDiscarded  )  {  [ATTENTION]  this  .  el  =  null  ;  this  .  numAttribsDiscarded  =  numAttribsDiscarded  ;  }    [METHOD]  <init>  [TYPE]  Element  ,  int)  [PARAMETER]  Element  el  int  numAttribsDiscarded  [CLASS]  ElementMeta    [TYPE]  int  numAttribsDiscarded  [TYPE]  Element  el  [TYPE]  boolean  false  true  
[REPLACE]  this  .  numAttribsDiscarded  =  numAttribsDiscarded;	[BUGGY]  this  .  numAttribsDiscarded  =    null  ;  [CE]  incompatible  types  [CONTEXT]  ElementMeta  (  Element  el  ,  int  numAttribsDiscarded  )  {  this  .  el  =  el  ;  [ATTENTION]  this  .  numAttribsDiscarded  =  null  ;  }    [METHOD]  <init>  [TYPE]  Element  ,  int)  [PARAMETER]  Element  el  int  numAttribsDiscarded  [CLASS]  ElementMeta    [TYPE]  int  numAttribsDiscarded  [TYPE]  Element  el  [TYPE]  boolean  false  true  
[REPLACE]  tagNames  =  new  HashSet<TagName>  (  )  ;	[BUGGY]  tagNames  =    new  Protocol>  (  )    ;  [CE]  '('  or  '['  expected  [CONTEXT]  public  Whitelist  (  )  {  [ATTENTION]  tagNames  =  new  Protocol>  (  )  ;  attributes  =  new  HashMap<TagName  ,  Set<AttributeKey>>  (  )  ;  enforcedAttributes  =  new  HashMap<TagName  ,  Map<AttributeKey  ,  AttributeValue>>  (  )  ;  protocols  =  new  HashMap<TagName  ,  Map<AttributeKey  ,  Set<Protocol>>>  (  )  ;  }    [METHOD]  <init>  [TYPE]  Whitelist()  [PARAMETER]  [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [TYPE]  Set  tagNames  [TYPE]  String  value  [TYPE]  boolean  false  true  [TYPE]  Map  attributes  enforcedAttributes  protocols  
[ADD]  tagNames  =  new  HashSet<TagName>  (  )  ;	[BUGGY]  [FE]  null  assertEquals( "<img  alt  =  \ "\ "  /> "  ,  cleanHtml)  ;  [CONTEXT]  public  Whitelist  (  )  {  [ATTENTION]  attributes  =  new  HashMap<TagName  ,  Set<AttributeKey>>  (  )  ;  enforcedAttributes  =  new  HashMap<TagName  ,  Map<AttributeKey  ,  AttributeValue>>  (  )  ;  protocols  =  new  HashMap<TagName  ,  Map<AttributeKey  ,  Set<Protocol>>>  (  )  ;  }    [METHOD]  <init>  [TYPE]  Whitelist()  [PARAMETER]  [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [TYPE]  Set  tagNames  [TYPE]  String  value  [TYPE]  boolean  false  true  [TYPE]  Map  attributes  enforcedAttributes  protocols  
[REPLACE]  attributes  =  new  HashMap<TagName,  Set<AttributeKey>>  (  )  ;	[BUGGY]  attributes  =    new  AttributeKey  ,  AttributeValue>  (  )    ;  [CE]  '('  or  '['  expected  [CONTEXT]  public  Whitelist  (  )  {  tagNames  =  new  HashSet<TagName>  (  )  ;  [ATTENTION]  attributes  =  new  AttributeKey  ,  AttributeValue>  (  )  ;  enforcedAttributes  =  new  HashMap<TagName  ,  Map<AttributeKey  ,  AttributeValue>>  (  )  ;  protocols  =  new  HashMap<TagName  ,  Map<AttributeKey  ,  Set<Protocol>>>  (  )  ;  }    [METHOD]  <init>  [TYPE]  Whitelist()  [PARAMETER]  [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [TYPE]  Set  tagNames  [TYPE]  String  value  [TYPE]  boolean  false  true  [TYPE]  Map  attributes  enforcedAttributes  protocols  
[REPLACE]  enforcedAttributes  =  new  HashMap<TagName,  Map<AttributeKey,  AttributeValue>>  (  )  ;	[BUGGY]  enforcedAttributes  =    new  AttributeKey  ,  AttributeValue>  (  )    ;  [CE]  '('  or  '['  expected  [CONTEXT]  public  Whitelist  (  )  {  tagNames  =  new  HashSet<TagName>  (  )  ;  attributes  =  new  HashMap<TagName  ,  Set<AttributeKey>>  (  )  ;  [ATTENTION]  enforcedAttributes  =  new  AttributeKey  ,  AttributeValue>  (  )  ;  protocols  =  new  HashMap<TagName  ,  Map<AttributeKey  ,  Set<Protocol>>>  (  )  ;  }    [METHOD]  <init>  [TYPE]  Whitelist()  [PARAMETER]  [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [TYPE]  Set  tagNames  [TYPE]  String  value  [TYPE]  boolean  false  true  [TYPE]  Map  attributes  enforcedAttributes  protocols  
[REPLACE]  protocols  =  new  HashMap<TagName,  Map<AttributeKey,  Set<Protocol>>>  (  )  ;	[BUGGY]  protocols  =    new  TagName  ,  AttributeKey>>  (  )    ;  [CE]  '('  or  '['  expected  [CONTEXT]  public  Whitelist  (  )  {  tagNames  =  new  HashSet<TagName>  (  )  ;  attributes  =  new  HashMap<TagName  ,  Set<AttributeKey>>  (  )  ;  enforcedAttributes  =  new  HashMap<TagName  ,  Map<AttributeKey  ,  AttributeValue>>  (  )  ;  [ATTENTION]  protocols  =  new  TagName  ,  AttributeKey>>  (  )  ;  }    [METHOD]  <init>  [TYPE]  Whitelist()  [PARAMETER]  [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [TYPE]  Set  tagNames  [TYPE]  String  value  [TYPE]  boolean  false  true  [TYPE]  Map  attributes  enforcedAttributes  protocols  
[REPLACE]  super  (  value  )  ;	[BUGGY]  attr  .  setValue  (  value  )  ;  [CE]  constructor  TypedValue  in  class  TypedValue  cannot  be  applied  to  given  types  ;  [CONTEXT]  TagName  (  String  value  )  {  [ATTENTION]  attr  .  setValue  (  value  )    ;  }    [METHOD]  <init>  [TYPE]  String)  [PARAMETER]  String  value  [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [TYPE]  Set  tagNames  [TYPE]  String  value  [TYPE]  boolean  false  true  [TYPE]  Map  attributes  enforcedAttributes  protocols  
[REPLACE]  super  (  value  )  ;	[BUGGY]  attr  .  setValue  (  value  )  ;  [CE]  constructor  TypedValue  in  class  TypedValue  cannot  be  applied  to  given  types  ;  [CONTEXT]  AttributeKey  (  String  value  )  {  [ATTENTION]  attr  .  setValue  (  value  )    ;  }    [METHOD]  <init>  [TYPE]  String)  [PARAMETER]  String  value  [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [TYPE]  Set  tagNames  [TYPE]  String  value  [TYPE]  boolean  false  true  [TYPE]  Map  attributes  enforcedAttributes  protocols  
[REPLACE]  super  (  value  )  ;	[BUGGY]  attr  .  setValue  (  value  )  ;  [CE]  constructor  TypedValue  in  class  TypedValue  cannot  be  applied  to  given  types  ;  [CONTEXT]  AttributeValue  (  String  value  )  {  [ATTENTION]  attr  .  setValue  (  value  )    ;  }    [METHOD]  <init>  [TYPE]  String)  [PARAMETER]  String  value  [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [TYPE]  Set  tagNames  [TYPE]  String  value  [TYPE]  boolean  false  true  [TYPE]  Map  attributes  enforcedAttributes  protocols  
[REPLACE]  super  (  value  )  ;	[BUGGY]  attr  .  setValue  (  value  )  ;  [CE]  constructor  TypedValue  in  class  TypedValue  cannot  be  applied  to  given  types  ;  [CONTEXT]  Protocol  (  String  value  )  {  [ATTENTION]  attr  .  setValue  (  value  )    ;  }    [METHOD]  <init>  [TYPE]  String)  [PARAMETER]  String  value  [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [TYPE]  Set  tagNames  [TYPE]  String  value  [TYPE]  boolean  false  true  [TYPE]  Map  attributes  enforcedAttributes  protocols  
[REMOVE]  	[BUGGY]  protSet  .  add  (  prot  )  ;  [CE]  cannot  find  symbol  prot  [CONTEXT]  Protocol  (  String  value  )  {  [ATTENTION]  super  (  value  )  ;      [METHOD]  <init>  [TYPE]  String)  [PARAMETER]  String  value  [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [TYPE]  Set  tagNames  [TYPE]  String  value  [TYPE]  boolean  false  true  [TYPE]  Map  attributes  enforcedAttributes  protocols  
[REPLACE]  Validate  .  notNull  (  value  )  ;	[BUGGY]  Validate  .  notNull  (  tags  )  ;  [CE]  cannot  find  symbol  tags  [CONTEXT]  TypedValue  (  String  value  )  {  [ATTENTION]  Validate  .  notNull  (  tags  )    ;  this  .  value  =  value  ;  }    [METHOD]  <init>  [TYPE]  String)  [PARAMETER]  String  value  [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [TYPE]  Set  tagNames  [TYPE]  String  value  [TYPE]  boolean  false  true  [TYPE]  Map  attributes  enforcedAttributes  protocols  
[REPLACE]  this  .  value  =  value;	[BUGGY]  this  .  value  =    null  ;  [FE]  The  validated  string  is  empty  assertEquals( "<img  alt  =  \ "\ "  /> "  ,  cleanHtml)  ;  [CONTEXT]  TypedValue  (  String  value  )  {  Validate  .  notNull  (  value  )  ;  [ATTENTION]  this  .  value  =  null  ;  }    [METHOD]  <init>  [TYPE]  String)  [PARAMETER]  String  value  [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [TYPE]  Set  tagNames  [TYPE]  String  value  [TYPE]  boolean  false  true  [TYPE]  Map  attributes  enforcedAttributes  protocols  
[REPLACE]  return  new  Whitelist  (  )  ;	[BUGGY]  return  new  TagName  (  value  )    ;  [CE]  cannot  find  symbol  value  [CONTEXT]  public  static  Whitelist  none  (  )  {  [ATTENTION]  returnnew  TagName  (  value  )  ;  }    [METHOD]  none  [TYPE]  Whitelist  [PARAMETER]  [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [TYPE]  Set  tagNames  [TYPE]  String  value  [TYPE]  boolean  false  true  [TYPE]  Map  attributes  enforcedAttributes  protocols  
[REPLACE]  return  new  Whitelist  (  )    .  addTags  (   "b ",   "em ",   "i ",   "strong ",   "u "  )  ;	[BUGGY]  return  new  Whitelist  (  )    .  addProtocols  (  value  ,  value  ,  false  )    ;  [CE]  cannot  find  symbol  value  [CONTEXT]  public  static  Whitelist  simpleText  (  )  {  [ATTENTION]  return  new  Whitelist  (  )  .  addProtocols  (  value  ,  value  ,  false  )  ;    }    [METHOD]  simpleText  [TYPE]  Whitelist  [PARAMETER]  [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [TYPE]  Set  tagNames  [TYPE]  String  value  [TYPE]  boolean  false  true  [TYPE]  Map  attributes  enforcedAttributes  protocols  
[REPLACE]  return  new  Whitelist  (  )    .  addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "cite ",   "code ",   "dd ",   "dl ",   "dt ",   "em ",   "i ",   "li ",   "ol ",   "p ",   "pre ",   "q ",   "small ",   "strike ",   "strong ",   "sub ",	[BUGGY]  return  new  TagName  (  value  )    .  addTags  (   "a "  ,   "b "  ,   "blockquote "  ,   "br "  ,   "cite "  ,   "code "  ,   "dd "  ,   "dl "  ,   "dt "  ,   "em "  ,   "i "  ,   "li "  ,   "ol "  ,   "p "  ,   "pre "  ,   "q "  ,   "small "  ,   "strike "  ,   "strong "  ,   "sub "  ,  [CE]  cannot  find  symbol  value  [CONTEXT]  public  static  Whitelist  basic  (  )  {  [ATTENTION]  returnnew  TagName  (  value  )  .  addTags  (   "a "  ,   "b "  ,   "blockquote "  ,   "br "  ,   "cite "  ,   "code "  ,   "dd "  ,   "dl "  ,   "dt "  ,   "em "  ,   "i "  ,   "li "  ,   "ol "  ,   "p "  ,   "pre "  ,   "q "  ,   "small "  ,   "strike "  ,   "strong "  ,   "sub "  ,       "sup "  ,   "u "  ,   "ul "  )    .  addAttributes  (   "a "  ,   "href "  )    .  addAttributes  (   "blockquote "  ,   "cite "  )    .  addAttributes  (   "q "  ,   "cite "  )    .  addProtocols  (   "a "  ,   "href "  ,   "ftp "  ,   "http "  ,   "https "  ,   "mailto "  )    .  addProtocols  (   "blockquote "  ,   "cite "  ,   "http "  ,   "https "  )    .  addProtocols  (   "cite "  ,   "cite "  ,   "http "  ,   "https "  )    .  addEnforcedAttribute  (   "a "  ,   "rel "  ,   "nofollow "  )    ;    }    [METHOD]  basic  [TYPE]  Whitelist  [PARAMETER]  [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [TYPE]  Set  tagNames  [TYPE]  String  value  [TYPE]  boolean  false  true  [TYPE]  Map  attributes  enforcedAttributes  protocols  
[REPLACE]  return  basic  (  )    .  addTags  (   "img "  )    .  addAttributes  (   "img ",   "align ",   "alt ",   "height ",   "src ",   "title ",   "width "  )    .  addProtocols  (   "img ",   "src ",   "http ",   "https "  )	[BUGGY]  return  basic  (  )  .  addTags  (   "img "  )  .  addAttributes  (   "img "  ,   "align "  ,   "alt "  ,   "height "  ,   "src "  ,   "title "  ,   "width "  )  .  addTags  (   "img "  ,   "src "  ,   "http "  ,   "https "  )[FE]  AssertionFailedError    expected:<<img  alt  =   " "  []/>>  but  was:<<img  alt  =   " "  [src  =   "unknown  =  assertEquals( "<img  alt  =  \ "\ "  /> "  ,  cleanHtml)  ;  [CONTEXT]  public  static  Whitelist  basicWithImages  (  )  {  [ATTENTION]  return  basic  (  )    .  addTags  (   "img "  )    .  addAttributes  (   "img "  ,   "align "  ,   "alt "  ,   "height "  ,   "src "  ,   "title "  ,   "width "  )    .  addTags  (   "img "  ,   "src "  ,   "http "  ,   "https "  )      ;  }    [METHOD]  basicWithImages  [TYPE]  Whitelist  [PARAMETER]  [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [TYPE]  Set  tagNames  [TYPE]  String  value  [TYPE]  boolean  false  true  [TYPE]  Map  attributes  enforcedAttributes  protocols  
[REPLACE]  return  new  Whitelist  (  )    .  addTags  (   "a ",   "b ",   "blockquote ",   "br ",   "caption ",   "cite ",   "code ",   "col ",   "colgroup ",   "dd ",   "div ",   "dl ",   "dt ",   "em ",   "h1 ",   "h2 ",   "h3 ",   "h4 ",   "h5 ",   "h6 ",	[BUGGY]  return  new  TagName  (  value  )    .  addTags  (   "a "  ,   "b "  ,   "blockquote "  ,   "br "  ,   "caption "  ,   "cite "  ,   "code "  ,   "col "  ,   "colgroup "  ,   "dd "  ,   "div "  ,   "dl "  ,   "dt "  ,   "em "  ,   "h1 "  ,   "h2 "  ,   "h3 "  ,   "h4 "  ,   "h5 "  ,   "h6 "  ,  [CE]  cannot  find  symbol  value  [CONTEXT]  public  static  Whitelist  relaxed  (  )  {  [ATTENTION]  returnnew  TagName  (  value  )  .  addTags  (   "a "  ,   "b "  ,   "blockquote "  ,   "br "  ,   "caption "  ,   "cite "  ,   "code "  ,   "col "  ,   "colgroup "  ,   "dd "  ,   "div "  ,   "dl "  ,   "dt "  ,   "em "  ,   "h1 "  ,   "h2 "  ,   "h3 "  ,   "h4 "  ,   "h5 "  ,   "h6 "  ,       "i "  ,   "img "  ,   "li "  ,   "ol "  ,   "p "  ,   "pre "  ,   "q "  ,   "small "  ,   "strike "  ,   "strong "  ,   "sub "  ,   "sup "  ,   "table "  ,   "tbody "  ,   "td "  ,   "tfoot "  ,   "th "  ,   "thead "  ,   "tr "  ,   "u "  ,   "ul "  )    .  addAttributes  (   "a "  ,   "href "  ,   "title "  )    .  addAttributes  (   "blockquote "  ,   "cite "  )    .  addAttributes  (   "col "  ,   "span "  ,   "width "  )    .  addAttributes  (   "colgroup "  ,   "span "  ,   "width "  )    .  addAttributes  (   "img "  ,   "align "  ,   "alt "  ,   "height "  ,   "src "  ,   "title "  ,   "width "  )    .  addAttributes  (   "ol "  ,   "start "  ,   "type "  )    .  addAttributes  (   "q "  ,   "cite "  )    .  addAttributes  (   "table "  ,   "summary "  ,   "width "  )    .  addAttributes  (   "td "  ,   "abbr "  ,   "axis "  ,   "colspan "  ,   "rowspan "  ,   "width "  )    .  addAttributes  (   "th "  ,   "abbr "  ,   "axis "  ,   "colspan "  ,   "rowspan "  ,   "scope "  ,   "width "  )    .  addAttributes  (   "ul "  ,   "type "  )    .  addProtocols  (   "a "  ,   "href "  ,   "ftp "  ,   "http "  ,   "https "  ,   "mailto "  )    .  addProtocols  (   "blockquote "  ,   "cite "  ,   "http "  ,   "https "  )    .  addProtocols  (   "img "  ,   "src "  ,   "http "  ,   "https "  )    .  addProtocols  (   "q "  ,   "cite "  ,   "http "  ,   "https "  )    ;  }    [METHOD]  relaxed  [TYPE]  Whitelist  [PARAMETER]  [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [TYPE]  Set  tagNames  [TYPE]  String  value  [TYPE]  boolean  false  true  [TYPE]  Map  attributes  enforcedAttributes  protocols  
[REPLACE]  Validate  .  notNull  (  tags  )  ;	[BUGGY]  Validate  .  notNull  (  value  )  ;  [CE]  cannot  find  symbol  value  [CONTEXT]  public  Whitelist  addTags  (  String  .  .  .  tags  )  {  [ATTENTION]  Validate  .  notNull  (  value  )    ;    for  (  String  tagName  :  tags  )  {  Validate  .  notEmpty  (  tagName  )  ;  tagNames  .  add  (  TagName  .  valueOf  (  tagName  )  )  ;  }  return  this  ;  }    [METHOD]  addTags  [TYPE]  Whitelist  [PARAMETER]  tags  [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [TYPE]  Set  tagNames  [TYPE]  String  tagName  value  [TYPE]  String[]  tags  [TYPE]  boolean  false  true  [TYPE]  Map  attributes  enforcedAttributes  protocols  
[REPLACE]  for  (  String  tagName  :  tags  )  {	[BUGGY]  TagName  tag  =  TagName  .  valueOf  (  tagName  )  ;  [CE]  illegal  start  of  type  [CONTEXT]  public  Whitelist  addTags  (  String  .  .  .  tags  )  {  Validate  .  notNull  (  tags  )  ;    [ATTENTION]  TagName  tag  =  TagName  .  valueOf  (  tagName  )    ;  Validate  .  notEmpty  (  tagName  )  ;  tagNames  .  add  (  TagName  .  valueOf  (  tagName  )  )  ;  }  return  this  ;  }    [METHOD]  addTags  [TYPE]  Whitelist  [PARAMETER]  tags  [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [TYPE]  Set  tagNames  [TYPE]  String  tagName  value  [TYPE]  String[]  tags  [TYPE]  boolean  false  true  [TYPE]  Map  attributes  enforcedAttributes  protocols  
[REPLACE]  return  this;	[BUGGY]  return  null  ;  [FE]  null  assertEquals( "<img  alt  =  \ "\ "  /> "  ,  cleanHtml)  ;  [CONTEXT]  public  Whitelist  addTags  (  String  .  .  .  tags  )  {  Validate  .  notNull  (  tags  )  ;    for  (  String  tagName  :  tags  )  {  Validate  .  notEmpty  (  tagName  )  ;  tagNames  .  add  (  TagName  .  valueOf  (  tagName  )  )  ;  }  [ATTENTION]  return  null  ;  }    [METHOD]  addTags  [TYPE]  Whitelist  [PARAMETER]  tags  [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [TYPE]  Set  tagNames  [TYPE]  String  tagName  value  [TYPE]  String[]  tags  [TYPE]  boolean  false  true  [TYPE]  Map  attributes  enforcedAttributes  protocols  
[REPLACE]  Validate  .  notEmpty  (  tag  )  ;	[BUGGY]  Validate  .  notEmpty  (  value  )  ;  [CE]  cannot  find  symbol  value  [CONTEXT]  public  Whitelist  addAttributes  (  String  tag  ,  String  .  .  .  keys  )  {  [ATTENTION]  Validate  .  notEmpty  (  value  )    ;  Validate  .  notNull  (  keys  )  ;    TagName  tagName  =  TagName  .  valueOf  (  tag  )  ;  Set<AttributeKey>  attributeSet  =  new  HashSet<AttributeKey>  (  )  ;  for  (  String  key  :  keys  )  {  Validate  .  notEmpty  (  key  )  ;  attributeSet  .  add  (  AttributeKey  .  valueOf  (  key  )  )  ;  }  if  (  attributes  .  containsKey  (  tagName  )  )  {  Set<AttributeKey>  currentSet  =  attributes  .  get  (  tagName  )  ;  currentSet  .  addAll  (  attributeSet  )  ;  }  else  {  attributes  .  put  (  tagName  ,  attributeSet  )  ;  }  return  this  ;  }    [METHOD]  addAttributes  [TYPE]  Whitelist  [PARAMETER]  String  tag  keys  [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [TYPE]  Set  attributeSet  currentSet  tagNames  [TYPE]  String  key  tag  tagName  value  [TYPE]  String[]  keys  [TYPE]  boolean  false  true  [TYPE]  TagName  tagName  [TYPE]  Map  attributes  enforcedAttributes  protocols  
[REPLACE]  Validate  .  notNull  (  keys  )  ;	[BUGGY]  Validate  .  notNull  (  tags  )  ;  [CE]  cannot  find  symbol  tags  [CONTEXT]  public  Whitelist  addAttributes  (  String  tag  ,  String  .  .  .  keys  )  {  Validate  .  notEmpty  (  tag  )  ;  [ATTENTION]  Validate  .  notNull  (  tags  )    ;    TagName  tagName  =  TagName  .  valueOf  (  tag  )  ;  Set<AttributeKey>  attributeSet  =  new  HashSet<AttributeKey>  (  )  ;  for  (  String  key  :  keys  )  {  Validate  .  notEmpty  (  key  )  ;  attributeSet  .  add  (  AttributeKey  .  valueOf  (  key  )  )  ;  }  if  (  attributes  .  containsKey  (  tagName  )  )  {  Set<AttributeKey>  currentSet  =  attributes  .  get  (  tagName  )  ;  currentSet  .  addAll  (  attributeSet  )  ;  }  else  {  attributes  .  put  (  tagName  ,  attributeSet  )  ;  }  return  this  ;  }    [METHOD]  addAttributes  [TYPE]  Whitelist  [PARAMETER]  String  tag  keys  [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [TYPE]  Set  attributeSet  currentSet  tagNames  [TYPE]  String  key  tag  tagName  value  [TYPE]  String[]  keys  [TYPE]  boolean  false  true  [TYPE]  TagName  tagName  [TYPE]  Map  attributes  enforcedAttributes  protocols  
[REPLACE]  TagName  tagName  =  TagName  .  valueOf  (  tag  )  ;	[BUGGY]  TagName  valueName  =  TagName  .  TagName  (  tag  )  ;  [CE]  cannot  find  symbol  [CONTEXT]  public  Whitelist  addAttributes  (  String  tag  ,  String  .  .  .  keys  )  {  Validate  .  notEmpty  (  tag  )  ;  Validate  .  notNull  (  keys  )  ;    [ATTENTION]  TagName  valueName  =  TagName  .  TagName  (  tag  )    ;  Set<AttributeKey>  attributeSet  =  new  HashSet<AttributeKey>  (  )  ;  for  (  String  key  :  keys  )  {  Validate  .  notEmpty  (  key  )  ;  attributeSet  .  add  (  AttributeKey  .  valueOf  (  key  )  )  ;  }  if  (  attributes  .  containsKey  (  tagName  )  )  {  Set<AttributeKey>  currentSet  =  attributes  .  get  (  tagName  )  ;  currentSet  .  addAll  (  attributeSet  )  ;  }  else  {  attributes  .  put  (  tagName  ,  attributeSet  )  ;  }  return  this  ;  }    [METHOD]  addAttributes  [TYPE]  Whitelist  [PARAMETER]  String  tag  keys  [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [TYPE]  Set  attributeSet  currentSet  tagNames  [TYPE]  String  key  tag  tagName  value  [TYPE]  String[]  keys  [TYPE]  boolean  false  true  [TYPE]  TagName  tagName  [TYPE]  Map  attributes  enforcedAttributes  protocols  
[REPLACE]  Set<AttributeKey>  attributeSet  =  new  HashSet<AttributeKey>  (  )  ;	[BUGGY]  AttributeKey  attrKey  =  AttributeKey  .  valueOf  (  key  )  ;  [CE]  cannot  find  symbol  key  [CONTEXT]  public  Whitelist  addAttributes  (  String  tag  ,  String  .  .  .  keys  )  {  Validate  .  notEmpty  (  tag  )  ;  Validate  .  notNull  (  keys  )  ;    TagName  tagName  =  TagName  .  valueOf  (  tag  )  ;  [ATTENTION]  AttributeKey  attrKey  =  AttributeKey  .  valueOf  (  key  )    ;  for  (  String  key  :  keys  )  {  Validate  .  notEmpty  (  key  )  ;  attributeSet  .  add  (  AttributeKey  .  valueOf  (  key  )  )  ;  }  if  (  attributes  .  containsKey  (  tagName  )  )  {  Set<AttributeKey>  currentSet  =  attributes  .  get  (  tagName  )  ;  currentSet  .  addAll  (  attributeSet  )  ;  }  else  {  attributes  .  put  (  tagName  ,  attributeSet  )  ;  }  return  this  ;  }    [METHOD]  addAttributes  [TYPE]  Whitelist  [PARAMETER]  String  tag  keys  [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [TYPE]  Set  attributeSet  currentSet  tagNames  [TYPE]  String  key  tag  tagName  value  [TYPE]  String[]  keys  [TYPE]  boolean  false  true  [TYPE]  TagName  tagName  [TYPE]  Map  attributes  enforcedAttributes  protocols  
[REPLACE]  for  (  String  key  :  keys  )  {	[BUGGY]  for  (  String  key  :  keys  )  {  Validate  .  notEmpty  (  key  )  ;  [NO-ERROR]  [CONTEXT]  public  Whitelist  addAttributes  (  String  tag  ,  String  .  .  .  keys  )  {  Validate  .  notEmpty  (  tag  )  ;  Validate  .  notNull  (  keys  )  ;    TagName  tagName  =  TagName  .  valueOf  (  tag  )  ;  Set<AttributeKey>  attributeSet  =  new  HashSet<AttributeKey>  (  )  ;  [ATTENTION]  for  (  String  key  :  keys  )  {  Validate  .  notEmpty  (  key  )    ;  Validate  .  notEmpty  (  key  )  ;  attributeSet  .  add  (  AttributeKey  .  valueOf  (  key  )  )  ;  }  if  (  attributes  .  containsKey  (  tagName  )  )  {  Set<AttributeKey>  currentSet  =  attributes  .  get  (  tagName  )  ;  currentSet  .  addAll  (  attributeSet  )  ;  }  else  {  attributes  .  put  (  tagName  ,  attributeSet  )  ;  }  return  this  ;  }    [METHOD]  addAttributes  [TYPE]  Whitelist  [PARAMETER]  String  tag  keys  [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [TYPE]  Set  attributeSet  currentSet  tagNames  [TYPE]  String  key  tag  tagName  value  [TYPE]  String[]  keys  [TYPE]  boolean  false  true  [TYPE]  TagName  tagName  [TYPE]  Map  attributes  enforcedAttributes  protocols  
[ADD]  for  (  String  key  :  keys  )  {  Validate  .  notEmpty  (  key  )  ;  attributeSet  .  add  (  AttributeKey  .  valueOf  (  key  )  )  ;  }	[BUGGY]  [FE]  AssertionFailedError    expected:<<img  [alt  =   " "  ]/>>  but  was:<<img  []/>>  assertEquals( "<img  alt  =  \ "\ "  /> "  ,  cleanHtml)  ;  [CONTEXT]  public  Whitelist  addAttributes  (  String  tag  ,  String  .  .  .  keys  )  {  Validate  .  notEmpty  (  tag  )  ;  Validate  .  notNull  (  keys  )  ;    TagName  tagName  =  TagName  .  valueOf  (  tag  )  ;  Set<AttributeKey>  attributeSet  =  new  HashSet<AttributeKey>  (  )  ;  [ATTENTION]      if  (  attributes  .  containsKey  (  tagName  )  )  {  Set<AttributeKey>  currentSet  =  attributes  .  get  (  tagName  )  ;  currentSet  .  addAll  (  attributeSet  )  ;  }  else  {  attributes  .  put  (  tagName  ,  attributeSet  )  ;  }  return  this  ;  }    [METHOD]  addAttributes  [TYPE]  Whitelist  [PARAMETER]  String  tag  keys  [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [TYPE]  Set  attributeSet  currentSet  tagNames  [TYPE]  String  key  tag  tagName  value  [TYPE]  String[]  keys  [TYPE]  boolean  false  true  [TYPE]  TagName  tagName  [TYPE]  Map  attributes  enforcedAttributes  protocols  
[REPLACE]  if  (  attributes  .  containsKey  (  tagName  )  )  {	[BUGGY]  if  (  enforcedAttributes  .  containsKey  (  tagName  )  )  {[NO-ERROR]  [CONTEXT]  public  Whitelist  addAttributes  (  String  tag  ,  String  .  .  .  keys  )  {  Validate  .  notEmpty  (  tag  )  ;  Validate  .  notNull  (  keys  )  ;    TagName  tagName  =  TagName  .  valueOf  (  tag  )  ;  Set<AttributeKey>  attributeSet  =  new  HashSet<AttributeKey>  (  )  ;  for  (  String  key  :  keys  )  {  Validate  .  notEmpty  (  key  )  ;  attributeSet  .  add  (  AttributeKey  .  valueOf  (  key  )  )  ;  }  [ATTENTION]  if  (  enforcedAttributes  .  containsKey  (  tagName  )  )  {  Set<AttributeKey>  currentSet  =  attributes  .  get  (  tagName  )  ;  currentSet  .  addAll  (  attributeSet  )  ;  }  else  {  attributes  .  put  (  tagName  ,  attributeSet  )  ;  }  return  this  ;  }    [METHOD]  addAttributes  [TYPE]  Whitelist  [PARAMETER]  String  tag  keys  [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [TYPE]  Set  attributeSet  currentSet  tagNames  [TYPE]  String  key  tag  tagName  value  [TYPE]  String[]  keys  [TYPE]  boolean  false  true  [TYPE]  TagName  tagName  [TYPE]  Map  attributes  enforcedAttributes  protocols  
[REPLACE]  attributes  .  put  (  tagName,  attributeSet  )  ;	[BUGGY]  attributes  .  get  (  null  )    ;  [FE]  AssertionFailedError    expected:<<img  [alt  =   " "  ]/>>  but  was:<<img  []/>>  assertEquals( "<img  alt  =  \ "\ "  /> "  ,  cleanHtml)  ;  [CONTEXT]  public  Whitelist  addAttributes  (  String  tag  ,  String  .  .  .  keys  )  {  Validate  .  notEmpty  (  tag  )  ;  Validate  .  notNull  (  keys  )  ;    TagName  tagName  =  TagName  .  valueOf  (  tag  )  ;  Set<AttributeKey>  attributeSet  =  new  HashSet<AttributeKey>  (  )  ;  for  (  String  key  :  keys  )  {  Validate  .  notEmpty  (  key  )  ;  attributeSet  .  add  (  AttributeKey  .  valueOf  (  key  )  )  ;  }  if  (  attributes  .  containsKey  (  tagName  )  )  {  Set<AttributeKey>  currentSet  =  attributes  .  get  (  tagName  )  ;  currentSet  .  addAll  (  attributeSet  )  ;  }  else  {  [ATTENTION]  attributes  .  get  (  null  )  ;  }  return  this  ;  }    [METHOD]  addAttributes  [TYPE]  Whitelist  [PARAMETER]  String  tag  keys  [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [TYPE]  Set  attributeSet  currentSet  tagNames  [TYPE]  String  key  tag  tagName  value  [TYPE]  String[]  keys  [TYPE]  boolean  false  true  [TYPE]  TagName  tagName  [TYPE]  Map  attributes  enforcedAttributes  protocols  
[ADD]  attributes  .  put  (  tagName,  attributeSet  )  ;	[BUGGY]  [FE]  AssertionFailedError    expected:<<img  [alt  =   " "  ]/>>  but  was:<<img  []/>>  assertEquals( "<img  alt  =  \ "\ "  /> "  ,  cleanHtml)  ;  [CONTEXT]  public  Whitelist  addAttributes  (  String  tag  ,  String  .  .  .  keys  )  {  Validate  .  notEmpty  (  tag  )  ;  Validate  .  notNull  (  keys  )  ;    TagName  tagName  =  TagName  .  valueOf  (  tag  )  ;  Set<AttributeKey>  attributeSet  =  new  HashSet<AttributeKey>  (  )  ;  for  (  String  key  :  keys  )  {  Validate  .  notEmpty  (  key  )  ;  attributeSet  .  add  (  AttributeKey  .  valueOf  (  key  )  )  ;  }  if  (  attributes  .  containsKey  (  tagName  )  )  {  Set<AttributeKey>  currentSet  =  attributes  .  get  (  tagName  )  ;  currentSet  .  addAll  (  attributeSet  )  ;  }  else  {  [ATTENTION]  }  return  this  ;  }    [METHOD]  addAttributes  [TYPE]  Whitelist  [PARAMETER]  String  tag  keys  [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [TYPE]  Set  attributeSet  currentSet  tagNames  [TYPE]  String  key  tag  tagName  value  [TYPE]  String[]  keys  [TYPE]  boolean  false  true  [TYPE]  TagName  tagName  [TYPE]  Map  attributes  enforcedAttributes  protocols  
[REPLACE]  Set<AttributeKey>  currentSet  =  attributes  .  get  (  tagName  )  ;	[BUGGY]  Set<AttributeKey>  currentSet  =  attributes  .  containsKey  (  tagName  )  ;  [CE]  incompatible  types  [CONTEXT]  public  Whitelist  addAttributes  (  String  tag  ,  String  .  .  .  keys  )  {  Validate  .  notEmpty  (  tag  )  ;  Validate  .  notNull  (  keys  )  ;    TagName  tagName  =  TagName  .  valueOf  (  tag  )  ;  Set<AttributeKey>  attributeSet  =  new  HashSet<AttributeKey>  (  )  ;  for  (  String  key  :  keys  )  {  Validate  .  notEmpty  (  key  )  ;  attributeSet  .  add  (  AttributeKey  .  valueOf  (  key  )  )  ;  }  if  (  attributes  .  containsKey  (  tagName  )  )  {  [ATTENTION]  Set<AttributeKey>  currentSet  =  attributes  .  containsKey  (  tagName  )    ;  currentSet  .  addAll  (  attributeSet  )  ;  }  else  {  attributes  .  put  (  tagName  ,  attributeSet  )  ;  }  return  this  ;  }    [METHOD]  addAttributes  [TYPE]  Whitelist  [PARAMETER]  String  tag  keys  [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [TYPE]  Set  attributeSet  currentSet  tagNames  [TYPE]  String  key  tag  tagName  value  [TYPE]  String[]  keys  [TYPE]  boolean  false  true  [TYPE]  TagName  tagName  [TYPE]  Map  attributes  enforcedAttributes  protocols  
[ADD]  Set<AttributeKey>  currentSet  =  attributes  .  get  (  tagName  )  ;  currentSet  .  addAll  (  attributeSet  )  ;	[BUGGY]  [NO-ERROR]  [CONTEXT]  public  Whitelist  addAttributes  (  String  tag  ,  String  .  .  .  keys  )  {  Validate  .  notEmpty  (  tag  )  ;  Validate  .  notNull  (  keys  )  ;    TagName  tagName  =  TagName  .  valueOf  (  tag  )  ;  Set<AttributeKey>  attributeSet  =  new  HashSet<AttributeKey>  (  )  ;  for  (  String  key  :  keys  )  {  Validate  .  notEmpty  (  key  )  ;  attributeSet  .  add  (  AttributeKey  .  valueOf  (  key  )  )  ;  }  if  (  attributes  .  containsKey  (  tagName  )  )  {  [ATTENTION]    }  else  {  attributes  .  put  (  tagName  ,  attributeSet  )  ;  }  return  this  ;  }    [METHOD]  addAttributes  [TYPE]  Whitelist  [PARAMETER]  String  tag  keys  [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [TYPE]  Set  attributeSet  currentSet  tagNames  [TYPE]  String  key  tag  tagName  value  [TYPE]  String[]  keys  [TYPE]  boolean  false  true  [TYPE]  TagName  tagName  [TYPE]  Map  attributes  enforcedAttributes  protocols  
[REPLACE]  return  this;	[BUGGY]  return  null  ;  [FE]  null  assertEquals( "<img  alt  =  \ "\ "  /> "  ,  cleanHtml)  ;  [CONTEXT]  public  Whitelist  addAttributes  (  String  tag  ,  String  .  .  .  keys  )  {  Validate  .  notEmpty  (  tag  )  ;  Validate  .  notNull  (  keys  )  ;    TagName  tagName  =  TagName  .  valueOf  (  tag  )  ;  Set<AttributeKey>  attributeSet  =  new  HashSet<AttributeKey>  (  )  ;  for  (  String  key  :  keys  )  {  Validate  .  notEmpty  (  key  )  ;  attributeSet  .  add  (  AttributeKey  .  valueOf  (  key  )  )  ;  }  if  (  attributes  .  containsKey  (  tagName  )  )  {  Set<AttributeKey>  currentSet  =  attributes  .  get  (  tagName  )  ;  currentSet  .  addAll  (  attributeSet  )  ;  }  else  {  attributes  .  put  (  tagName  ,  attributeSet  )  ;  }  [ATTENTION]  return  null  ;  }    [METHOD]  addAttributes  [TYPE]  Whitelist  [PARAMETER]  String  tag  keys  [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [TYPE]  Set  attributeSet  currentSet  tagNames  [TYPE]  String  key  tag  tagName  value  [TYPE]  String[]  keys  [TYPE]  boolean  false  true  [TYPE]  TagName  tagName  [TYPE]  Map  attributes  enforcedAttributes  protocols  
[REPLACE]  Validate  .  notEmpty  (  tag  )  ;	[BUGGY]  Validate  .  notNull  (  null  )    ;  [FE]  The  validated  object  is  null  assertEquals( "<img  alt  =  \ "\ "  /> "  ,  cleanHtml)  ;  [CONTEXT]  public  Whitelist  addEnforcedAttribute  (  String  tag  ,  String  key  ,  String  value  )  {  [ATTENTION]  Validate  .  notNull  (  null  )  ;  Validate  .  notEmpty  (  key  )  ;  Validate  .  notEmpty  (  value  )  ;    TagName  tagName  =  TagName  .  valueOf  (  tag  )  ;  AttributeKey  attrKey  =  AttributeKey  .  valueOf  (  key  )  ;  AttributeValue  attrVal  =  AttributeValue  .  valueOf  (  value  )  ;    if  (  enforcedAttributes  .  containsKey  (  tagName  )  )  {  enforcedAttributes  .  get  (  tagName  )  .  put  (  attrKey  ,  attrVal  )  ;  }  else  {  Map<AttributeKey  ,  AttributeValue>  attrMap  =  new  HashMap<AttributeKey  ,  AttributeValue>  (  )  ;  attrMap  .  put  (  attrKey  ,  attrVal  )  ;  enforcedAttributes  .  put  (  tagName  ,  attrMap  )  ;  }  return  this  ;  }    [METHOD]  addEnforcedAttribute  [TYPE]  Whitelist  [PARAMETER]  String  tag  String  key  String  value  [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [TYPE]  AttributeKey  attrKey  [TYPE]  AttributeValue  attrVal  [TYPE]  Set  attributeSet  currentSet  tagNames  [TYPE]  boolean  false  true  [TYPE]  TagName  tagName  [TYPE]  String  key  tag  tagName  value  [TYPE]  Map  attrMap  attributes  enforcedAttributes  protocols  
[REPLACE]  Validate  .  notEmpty  (  key  )  ;	[BUGGY]  Validate  .  notNull  (  key  )  ;  [NO-ERROR]  [CONTEXT]  public  Whitelist  addEnforcedAttribute  (  String  tag  ,  String  key  ,  String  value  )  {  Validate  .  notEmpty  (  tag  )  ;  [ATTENTION]  Validate  .  notNull  (  key  )    ;  Validate  .  notEmpty  (  value  )  ;    TagName  tagName  =  TagName  .  valueOf  (  tag  )  ;  AttributeKey  attrKey  =  AttributeKey  .  valueOf  (  key  )  ;  AttributeValue  attrVal  =  AttributeValue  .  valueOf  (  value  )  ;    if  (  enforcedAttributes  .  containsKey  (  tagName  )  )  {  enforcedAttributes  .  get  (  tagName  )  .  put  (  attrKey  ,  attrVal  )  ;  }  else  {  Map<AttributeKey  ,  AttributeValue>  attrMap  =  new  HashMap<AttributeKey  ,  AttributeValue>  (  )  ;  attrMap  .  put  (  attrKey  ,  attrVal  )  ;  enforcedAttributes  .  put  (  tagName  ,  attrMap  )  ;  }  return  this  ;  }    [METHOD]  addEnforcedAttribute  [TYPE]  Whitelist  [PARAMETER]  String  tag  String  key  String  value  [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [TYPE]  AttributeKey  attrKey  [TYPE]  AttributeValue  attrVal  [TYPE]  Set  attributeSet  currentSet  tagNames  [TYPE]  boolean  false  true  [TYPE]  TagName  tagName  [TYPE]  String  key  tag  tagName  value  [TYPE]  Map  attrMap  attributes  enforcedAttributes  protocols  
[ADD]  Validate  .  notEmpty  (  key  )  ;	[BUGGY]  [NO-ERROR]  [CONTEXT]  public  Whitelist  addEnforcedAttribute  (  String  tag  ,  String  key  ,  String  value  )  {  Validate  .  notEmpty  (  tag  )  ;  [ATTENTION]  Validate  .  notEmpty  (  value  )  ;    TagName  tagName  =  TagName  .  valueOf  (  tag  )  ;  AttributeKey  attrKey  =  AttributeKey  .  valueOf  (  key  )  ;  AttributeValue  attrVal  =  AttributeValue  .  valueOf  (  value  )  ;    if  (  enforcedAttributes  .  containsKey  (  tagName  )  )  {  enforcedAttributes  .  get  (  tagName  )  .  put  (  attrKey  ,  attrVal  )  ;  }  else  {  Map<AttributeKey  ,  AttributeValue>  attrMap  =  new  HashMap<AttributeKey  ,  AttributeValue>  (  )  ;  attrMap  .  put  (  attrKey  ,  attrVal  )  ;  enforcedAttributes  .  put  (  tagName  ,  attrMap  )  ;  }  return  this  ;  }    [METHOD]  addEnforcedAttribute  [TYPE]  Whitelist  [PARAMETER]  String  tag  String  key  String  value  [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [TYPE]  AttributeKey  attrKey  [TYPE]  AttributeValue  attrVal  [TYPE]  Set  attributeSet  currentSet  tagNames  [TYPE]  boolean  false  true  [TYPE]  TagName  tagName  [TYPE]  String  key  tag  tagName  value  [TYPE]  Map  attrMap  attributes  enforcedAttributes  protocols  
[REPLACE]  Validate  .  notEmpty  (  value  )  ;	[BUGGY]  Validate  .  notNull  (  tagName  )  ;  [CE]  cannot  find  symbol  tagName  [CONTEXT]  public  Whitelist  addEnforcedAttribute  (  String  tag  ,  String  key  ,  String  value  )  {  Validate  .  notEmpty  (  tag  )  ;  Validate  .  notEmpty  (  key  )  ;  [ATTENTION]  Validate  .  notNull  (  tagName  )    ;    TagName  tagName  =  TagName  .  valueOf  (  tag  )  ;  AttributeKey  attrKey  =  AttributeKey  .  valueOf  (  key  )  ;  AttributeValue  attrVal  =  AttributeValue  .  valueOf  (  value  )  ;    if  (  enforcedAttributes  .  containsKey  (  tagName  )  )  {  enforcedAttributes  .  get  (  tagName  )  .  put  (  attrKey  ,  attrVal  )  ;  }  else  {  Map<AttributeKey  ,  AttributeValue>  attrMap  =  new  HashMap<AttributeKey  ,  AttributeValue>  (  )  ;  attrMap  .  put  (  attrKey  ,  attrVal  )  ;  enforcedAttributes  .  put  (  tagName  ,  attrMap  )  ;  }  return  this  ;  }    [METHOD]  addEnforcedAttribute  [TYPE]  Whitelist  [PARAMETER]  String  tag  String  key  String  value  [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [TYPE]  AttributeKey  attrKey  [TYPE]  AttributeValue  attrVal  [TYPE]  Set  attributeSet  currentSet  tagNames  [TYPE]  boolean  false  true  [TYPE]  TagName  tagName  [TYPE]  String  key  tag  tagName  value  [TYPE]  Map  attrMap  attributes  enforcedAttributes  protocols  
[REPLACE]  TagName  tagName  =  TagName  .  valueOf  (  tag  )  ;	[BUGGY]  TagName  valueName  =  TagName  .  valueOf  (  tag  )  ;  [CE]  cannot  find  symbol  tagName  [CONTEXT]  public  Whitelist  addEnforcedAttribute  (  String  tag  ,  String  key  ,  String  value  )  {  Validate  .  notEmpty  (  tag  )  ;  Validate  .  notEmpty  (  key  )  ;  Validate  .  notEmpty  (  value  )  ;    [ATTENTION]  TagName  valueName  =  TagName  .  valueOf  (  tag  )    ;  AttributeKey  attrKey  =  AttributeKey  .  valueOf  (  key  )  ;  AttributeValue  attrVal  =  AttributeValue  .  valueOf  (  value  )  ;    if  (  enforcedAttributes  .  containsKey  (  tagName  )  )  {  enforcedAttributes  .  get  (  tagName  )  .  put  (  attrKey  ,  attrVal  )  ;  }  else  {  Map<AttributeKey  ,  AttributeValue>  attrMap  =  new  HashMap<AttributeKey  ,  AttributeValue>  (  )  ;  attrMap  .  put  (  attrKey  ,  attrVal  )  ;  enforcedAttributes  .  put  (  tagName  ,  attrMap  )  ;  }  return  this  ;  }    [METHOD]  addEnforcedAttribute  [TYPE]  Whitelist  [PARAMETER]  String  tag  String  key  String  value  [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [TYPE]  AttributeKey  attrKey  [TYPE]  AttributeValue  attrVal  [TYPE]  Set  attributeSet  currentSet  tagNames  [TYPE]  boolean  false  true  [TYPE]  TagName  tagName  [TYPE]  String  key  tag  tagName  value  [TYPE]  Map  attrMap  attributes  enforcedAttributes  protocols  
[REPLACE]  AttributeKey  attrKey  =  AttributeKey  .  valueOf  (  key  )  ;	[BUGGY]  AttributeKey  attrKey  =  AttributeKey  .  AttributeKey  (  key  )  ;  [CE]  cannot  find  symbol  [CONTEXT]  public  Whitelist  addEnforcedAttribute  (  String  tag  ,  String  key  ,  String  value  )  {  Validate  .  notEmpty  (  tag  )  ;  Validate  .  notEmpty  (  key  )  ;  Validate  .  notEmpty  (  value  )  ;    TagName  tagName  =  TagName  .  valueOf  (  tag  )  ;  [ATTENTION]  AttributeKey  attrKey  =  AttributeKey  .  AttributeKey  (  key  )    ;  AttributeValue  attrVal  =  AttributeValue  .  valueOf  (  value  )  ;    if  (  enforcedAttributes  .  containsKey  (  tagName  )  )  {  enforcedAttributes  .  get  (  tagName  )  .  put  (  attrKey  ,  attrVal  )  ;  }  else  {  Map<AttributeKey  ,  AttributeValue>  attrMap  =  new  HashMap<AttributeKey  ,  AttributeValue>  (  )  ;  attrMap  .  put  (  attrKey  ,  attrVal  )  ;  enforcedAttributes  .  put  (  tagName  ,  attrMap  )  ;  }  return  this  ;  }    [METHOD]  addEnforcedAttribute  [TYPE]  Whitelist  [PARAMETER]  String  tag  String  key  String  value  [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [TYPE]  AttributeKey  attrKey  [TYPE]  AttributeValue  attrVal  [TYPE]  Set  attributeSet  currentSet  tagNames  [TYPE]  boolean  false  true  [TYPE]  TagName  tagName  [TYPE]  String  key  tag  tagName  value  [TYPE]  Map  attrMap  attributes  enforcedAttributes  protocols  
[ADD]  AttributeKey  attrKey  =  AttributeKey  .  valueOf  (  key  )  ;  AttributeValue  attrVal  =  AttributeValue  .  valueOf  (  value  )  ;	[BUGGY]  [CE]  cannot  find  symbol  attrKey  [CONTEXT]  public  Whitelist  addEnforcedAttribute  (  String  tag  ,  String  key  ,  String  value  )  {  Validate  .  notEmpty  (  tag  )  ;  Validate  .  notEmpty  (  key  )  ;  Validate  .  notEmpty  (  value  )  ;    TagName  tagName  =  TagName  .  valueOf  (  tag  )  ;  [ATTENTION]    if  (  enforcedAttributes  .  containsKey  (  tagName  )  )  {  enforcedAttributes  .  get  (  tagName  )  .  put  (  attrKey  ,  attrVal  )  ;  }  else  {  Map<AttributeKey  ,  AttributeValue>  attrMap  =  new  HashMap<AttributeKey  ,  AttributeValue>  (  )  ;  attrMap  .  put  (  attrKey  ,  attrVal  )  ;  enforcedAttributes  .  put  (  tagName  ,  attrMap  )  ;  }  return  this  ;  }    [METHOD]  addEnforcedAttribute  [TYPE]  Whitelist  [PARAMETER]  String  tag  String  key  String  value  [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [TYPE]  AttributeKey  attrKey  [TYPE]  AttributeValue  attrVal  [TYPE]  Set  attributeSet  currentSet  tagNames  [TYPE]  boolean  false  true  [TYPE]  TagName  tagName  [TYPE]  String  key  tag  tagName  value  [TYPE]  Map  attrMap  attributes  enforcedAttributes  protocols  
[REPLACE]  AttributeValue  attrVal  =  AttributeValue  .  valueOf  (  value  )  ;	[BUGGY]  AttributeValue  attrVal  =  AttributeValue  .  AttributeValue  (  tagName  )  ;  [CE]  cannot  find  symbol  [CONTEXT]  public  Whitelist  addEnforcedAttribute  (  String  tag  ,  String  key  ,  String  value  )  {  Validate  .  notEmpty  (  tag  )  ;  Validate  .  notEmpty  (  key  )  ;  Validate  .  notEmpty  (  value  )  ;    TagName  tagName  =  TagName  .  valueOf  (  tag  )  ;  AttributeKey  attrKey  =  AttributeKey  .  valueOf  (  key  )  ;  [ATTENTION]  AttributeValue  attrVal  =  AttributeValue  .  AttributeValue  (  tagName  )    ;    if  (  enforcedAttributes  .  containsKey  (  tagName  )  )  {  enforcedAttributes  .  get  (  tagName  )  .  put  (  attrKey  ,  attrVal  )  ;  }  else  {  Map<AttributeKey  ,  AttributeValue>  attrMap  =  new  HashMap<AttributeKey  ,  AttributeValue>  (  )  ;  attrMap  .  put  (  attrKey  ,  attrVal  )  ;  enforcedAttributes  .  put  (  tagName  ,  attrMap  )  ;  }  return  this  ;  }    [METHOD]  addEnforcedAttribute  [TYPE]  Whitelist  [PARAMETER]  String  tag  String  key  String  value  [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [TYPE]  AttributeKey  attrKey  [TYPE]  AttributeValue  attrVal  [TYPE]  Set  attributeSet  currentSet  tagNames  [TYPE]  boolean  false  true  [TYPE]  TagName  tagName  [TYPE]  String  key  tag  tagName  value  [TYPE]  Map  attrMap  attributes  enforcedAttributes  protocols  
[REPLACE]  if  (  enforcedAttributes  .  containsKey  (  tagName  )  )  {	[BUGGY]  if  (  enforcedAttributes  .  entrySet  (  )    )  {[CE]  incompatible  types  [CONTEXT]  public  Whitelist  addEnforcedAttribute  (  String  tag  ,  String  key  ,  String  value  )  {  Validate  .  notEmpty  (  tag  )  ;  Validate  .  notEmpty  (  key  )  ;  Validate  .  notEmpty  (  value  )  ;    TagName  tagName  =  TagName  .  valueOf  (  tag  )  ;  AttributeKey  attrKey  =  AttributeKey  .  valueOf  (  key  )  ;  AttributeValue  attrVal  =  AttributeValue  .  valueOf  (  value  )  ;    [ATTENTION]  if  (  enforcedAttributes  .  entrySet  (  )    )  {  enforcedAttributes  .  get  (  tagName  )  .  put  (  attrKey  ,  attrVal  )  ;  }  else  {  Map<AttributeKey  ,  AttributeValue>  attrMap  =  new  HashMap<AttributeKey  ,  AttributeValue>  (  )  ;  attrMap  .  put  (  attrKey  ,  attrVal  )  ;  enforcedAttributes  .  put  (  tagName  ,  attrMap  )  ;  }  return  this  ;  }    [METHOD]  addEnforcedAttribute  [TYPE]  Whitelist  [PARAMETER]  String  tag  String  key  String  value  [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [TYPE]  AttributeKey  attrKey  [TYPE]  AttributeValue  attrVal  [TYPE]  Set  attributeSet  currentSet  tagNames  [TYPE]  boolean  false  true  [TYPE]  TagName  tagName  [TYPE]  String  key  tag  tagName  value  [TYPE]  Map  attrMap  attributes  enforcedAttributes  protocols  
[REPLACE]  Map<AttributeKey,  AttributeValue>  attrMap  =  new  HashMap<AttributeKey,  AttributeValue>  (  )  ;	[BUGGY]  AttributeKey  attrKey  =  AttributeKey  .  valueOf  (  key  )  ;  [CE]  variable  attrKey  is  already  defined  in  method  addEnforcedAttribute(String  ,  String  ,  String)  [CONTEXT]  public  Whitelist  addEnforcedAttribute  (  String  tag  ,  String  key  ,  String  value  )  {  Validate  .  notEmpty  (  tag  )  ;  Validate  .  notEmpty  (  key  )  ;  Validate  .  notEmpty  (  value  )  ;    TagName  tagName  =  TagName  .  valueOf  (  tag  )  ;  AttributeKey  attrKey  =  AttributeKey  .  valueOf  (  key  )  ;  AttributeValue  attrVal  =  AttributeValue  .  valueOf  (  value  )  ;    if  (  enforcedAttributes  .  containsKey  (  tagName  )  )  {  enforcedAttributes  .  get  (  tagName  )  .  put  (  attrKey  ,  attrVal  )  ;  }  else  {  [ATTENTION]  AttributeKey  attrKey  =  AttributeKey  .  valueOf  (  key  )    ;  attrMap  .  put  (  attrKey  ,  attrVal  )  ;  enforcedAttributes  .  put  (  tagName  ,  attrMap  )  ;  }  return  this  ;  }    [METHOD]  addEnforcedAttribute  [TYPE]  Whitelist  [PARAMETER]  String  tag  String  key  String  value  [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [TYPE]  AttributeKey  attrKey  [TYPE]  AttributeValue  attrVal  [TYPE]  Set  attributeSet  currentSet  tagNames  [TYPE]  boolean  false  true  [TYPE]  TagName  tagName  [TYPE]  String  key  tag  tagName  value  [TYPE]  Map  attrMap  attributes  enforcedAttributes  protocols  
[ADD]  Map<AttributeKey,  AttributeValue>  attrMap  =  new  HashMap<AttributeKey,  AttributeValue>  (  )  ;	[BUGGY]  [CE]  cannot  find  symbol  attrMap  [CONTEXT]  public  Whitelist  addEnforcedAttribute  (  String  tag  ,  String  key  ,  String  value  )  {  Validate  .  notEmpty  (  tag  )  ;  Validate  .  notEmpty  (  key  )  ;  Validate  .  notEmpty  (  value  )  ;    TagName  tagName  =  TagName  .  valueOf  (  tag  )  ;  AttributeKey  attrKey  =  AttributeKey  .  valueOf  (  key  )  ;  AttributeValue  attrVal  =  AttributeValue  .  valueOf  (  value  )  ;    if  (  enforcedAttributes  .  containsKey  (  tagName  )  )  {  enforcedAttributes  .  get  (  tagName  )  .  put  (  attrKey  ,  attrVal  )  ;  }  else  {  [ATTENTION]  attrMap  .  put  (  attrKey  ,  attrVal  )  ;  enforcedAttributes  .  put  (  tagName  ,  attrMap  )  ;  }  return  this  ;  }    [METHOD]  addEnforcedAttribute  [TYPE]  Whitelist  [PARAMETER]  String  tag  String  key  String  value  [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [TYPE]  AttributeKey  attrKey  [TYPE]  AttributeValue  attrVal  [TYPE]  Set  attributeSet  currentSet  tagNames  [TYPE]  boolean  false  true  [TYPE]  TagName  tagName  [TYPE]  String  key  tag  tagName  value  [TYPE]  Map  attrMap  attributes  enforcedAttributes  protocols  
[REPLACE]  enforcedAttributes  .  get  (  tagName  )    .  put  (  attrKey,  attrVal  )  ;	[BUGGY]  enforcedAttributes  .  get  (  tagName  )  .  get  (  attrKey  ,  attrVal  )  ;  [CE]  method  get  in  interface  Map<K  ,  V>  cannot  be  applied  to  given  types  ;  [CONTEXT]  public  Whitelist  addEnforcedAttribute  (  String  tag  ,  String  key  ,  String  value  )  {  Validate  .  notEmpty  (  tag  )  ;  Validate  .  notEmpty  (  key  )  ;  Validate  .  notEmpty  (  value  )  ;    TagName  tagName  =  TagName  .  valueOf  (  tag  )  ;  AttributeKey  attrKey  =  AttributeKey  .  valueOf  (  key  )  ;  AttributeValue  attrVal  =  AttributeValue  .  valueOf  (  value  )  ;    if  (  enforcedAttributes  .  containsKey  (  tagName  )  )  {  [ATTENTION]  enforcedAttributes  .  get  (  tagName  )    .  get  (  attrKey  ,  attrVal  )    ;  }  else  {  Map<AttributeKey  ,  AttributeValue>  attrMap  =  new  HashMap<AttributeKey  ,  AttributeValue>  (  )  ;  attrMap  .  put  (  attrKey  ,  attrVal  )  ;  enforcedAttributes  .  put  (  tagName  ,  attrMap  )  ;  }  return  this  ;  }    [METHOD]  addEnforcedAttribute  [TYPE]  Whitelist  [PARAMETER]  String  tag  String  key  String  value  [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [TYPE]  AttributeKey  attrKey  [TYPE]  AttributeValue  attrVal  [TYPE]  Set  attributeSet  currentSet  tagNames  [TYPE]  boolean  false  true  [TYPE]  TagName  tagName  [TYPE]  String  key  tag  tagName  value  [TYPE]  Map  attrMap  attributes  enforcedAttributes  protocols  
[REPLACE]  enforcedAttributes  .  get  (  tagName  )    .  put  (  attrKey,  attrVal  )  ;	[BUGGY]  enforcedAttributes  .  put  (  null  ,  null  )    .  put  (  attrKey  ,  attrVal  )  ;  [NO-ERROR]  [CONTEXT]  public  Whitelist  addEnforcedAttribute  (  String  tag  ,  String  key  ,  String  value  )  {  Validate  .  notEmpty  (  tag  )  ;  Validate  .  notEmpty  (  key  )  ;  Validate  .  notEmpty  (  value  )  ;    TagName  tagName  =  TagName  .  valueOf  (  tag  )  ;  AttributeKey  attrKey  =  AttributeKey  .  valueOf  (  key  )  ;  AttributeValue  attrVal  =  AttributeValue  .  valueOf  (  value  )  ;    if  (  enforcedAttributes  .  containsKey  (  tagName  )  )  {  [ATTENTION]  enforcedAttributes  .  put  (  null  ,  null  )  .  put  (  attrKey  ,  attrVal  )    ;  }  else  {  Map<AttributeKey  ,  AttributeValue>  attrMap  =  new  HashMap<AttributeKey  ,  AttributeValue>  (  )  ;  attrMap  .  put  (  attrKey  ,  attrVal  )  ;  enforcedAttributes  .  put  (  tagName  ,  attrMap  )  ;  }  return  this  ;  }    [METHOD]  addEnforcedAttribute  [TYPE]  Whitelist  [PARAMETER]  String  tag  String  key  String  value  [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [TYPE]  AttributeKey  attrKey  [TYPE]  AttributeValue  attrVal  [TYPE]  Set  attributeSet  currentSet  tagNames  [TYPE]  boolean  false  true  [TYPE]  TagName  tagName  [TYPE]  String  key  tag  tagName  value  [TYPE]  Map  attrMap  attributes  enforcedAttributes  protocols  
[REPLACE]  return  this;	[BUGGY]  return  null  ;  [FE]  null  assertEquals( "<img  alt  =  \ "\ "  /> "  ,  cleanHtml)  ;  [CONTEXT]  public  Whitelist  addEnforcedAttribute  (  String  tag  ,  String  key  ,  String  value  )  {  Validate  .  notEmpty  (  tag  )  ;  Validate  .  notEmpty  (  key  )  ;  Validate  .  notEmpty  (  value  )  ;    TagName  tagName  =  TagName  .  valueOf  (  tag  )  ;  AttributeKey  attrKey  =  AttributeKey  .  valueOf  (  key  )  ;  AttributeValue  attrVal  =  AttributeValue  .  valueOf  (  value  )  ;    if  (  enforcedAttributes  .  containsKey  (  tagName  )  )  {  enforcedAttributes  .  get  (  tagName  )  .  put  (  attrKey  ,  attrVal  )  ;  }  else  {  Map<AttributeKey  ,  AttributeValue>  attrMap  =  new  HashMap<AttributeKey  ,  AttributeValue>  (  )  ;  attrMap  .  put  (  attrKey  ,  attrVal  )  ;  enforcedAttributes  .  put  (  tagName  ,  attrMap  )  ;  }  [ATTENTION]  return  null  ;  }    [METHOD]  addEnforcedAttribute  [TYPE]  Whitelist  [PARAMETER]  String  tag  String  key  String  value  [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [TYPE]  AttributeKey  attrKey  [TYPE]  AttributeValue  attrVal  [TYPE]  Set  attributeSet  currentSet  tagNames  [TYPE]  boolean  false  true  [TYPE]  TagName  tagName  [TYPE]  String  key  tag  tagName  value  [TYPE]  Map  attrMap  attributes  enforcedAttributes  protocols  
[REPLACE]  Validate  .  notEmpty  (  tag  )  ;	[BUGGY]  Validate  .  notNull  (  tag  )  ;  [NO-ERROR]  [CONTEXT]  public  Whitelist  addProtocols  (  String  tag  ,  String  key  ,  String  .  .  .  protocols  )  {  [ATTENTION]  Validate  .  notNull  (  tag  )    ;  Validate  .  notEmpty  (  key  )  ;  Validate  .  notNull  (  protocols  )  ;    TagName  tagName  =  TagName  .  valueOf  (  tag  )  ;  AttributeKey  attrKey  =  AttributeKey  .  valueOf  (  key  )  ;  Map<AttributeKey  ,  Set<Protocol>>  attrMap  ;  Set<Protocol>  protSet  ;    if  (  this  .  protocols  .  containsKey  (  tagName  )  )  {  attrMap  =  this  .  protocols  .  get  (  tagName  )  ;  }  else  {  attrMap  =  new  HashMap<AttributeKey  ,  Set<Protocol>>  (  )  ;  this  .  protocols  .  put  (  tagName  ,  attrMap  )  ;  }  if  (  attrMap  .  containsKey  (  attrKey  )  )  {  protSet  =  attrMap  .  get  (  attrKey  )  ;  }  else  {  protSet  =  new  HashSet<Protocol>  (  )  ;  attrMap  .  put  (  attrKey  ,  protSet  )  ;  }  for  (  String  protocol  :  protocols  )  {  Validate  .  notEmpty  (  protocol  )  ;  Protocol  prot  =  Protocol  .  valueOf  (  protocol  )  ;  protSet  .  add  (  prot  )  ;  }  return  this  ;  }    [METHOD]  addProtocols  [TYPE]  Whitelist  [PARAMETER]  String  tag  String  key  protocols  [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [TYPE]  AttributeKey  attrKey  [TYPE]  Set  attributeSet  currentSet  protSet  tagNames  [TYPE]  boolean  false  true  [TYPE]  TagName  tagName  [TYPE]  String  key  protocol  tag  tagName  value  [TYPE]  String[]  protocols  [TYPE]  Protocol  prot  [TYPE]  Map  attrMap  attributes  enforcedAttributes  protocols  
[REPLACE]  Validate  .  notEmpty  (  key  )  ;	[BUGGY]  Validate  .  notNull  (  key  )  ;  [NO-ERROR]  [CONTEXT]  public  Whitelist  addProtocols  (  String  tag  ,  String  key  ,  String  .  .  .  protocols  )  {  Validate  .  notEmpty  (  tag  )  ;  [ATTENTION]  Validate  .  notNull  (  key  )    ;  Validate  .  notNull  (  protocols  )  ;    TagName  tagName  =  TagName  .  valueOf  (  tag  )  ;  AttributeKey  attrKey  =  AttributeKey  .  valueOf  (  key  )  ;  Map<AttributeKey  ,  Set<Protocol>>  attrMap  ;  Set<Protocol>  protSet  ;    if  (  this  .  protocols  .  containsKey  (  tagName  )  )  {  attrMap  =  this  .  protocols  .  get  (  tagName  )  ;  }  else  {  attrMap  =  new  HashMap<AttributeKey  ,  Set<Protocol>>  (  )  ;  this  .  protocols  .  put  (  tagName  ,  attrMap  )  ;  }  if  (  attrMap  .  containsKey  (  attrKey  )  )  {  protSet  =  attrMap  .  get  (  attrKey  )  ;  }  else  {  protSet  =  new  HashSet<Protocol>  (  )  ;  attrMap  .  put  (  attrKey  ,  protSet  )  ;  }  for  (  String  protocol  :  protocols  )  {  Validate  .  notEmpty  (  protocol  )  ;  Protocol  prot  =  Protocol  .  valueOf  (  protocol  )  ;  protSet  .  add  (  prot  )  ;  }  return  this  ;  }    [METHOD]  addProtocols  [TYPE]  Whitelist  [PARAMETER]  String  tag  String  key  protocols  [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [TYPE]  AttributeKey  attrKey  [TYPE]  Set  attributeSet  currentSet  protSet  tagNames  [TYPE]  boolean  false  true  [TYPE]  TagName  tagName  [TYPE]  String  key  protocol  tag  tagName  value  [TYPE]  String[]  protocols  [TYPE]  Protocol  prot  [TYPE]  Map  attrMap  attributes  enforcedAttributes  protocols  
[REPLACE]  Validate  .  notNull  (  protocols  )  ;	[BUGGY]  protSet  .  add  (  prot  )  ;  [CE]  cannot  find  symbol  prot  [CONTEXT]  public  Whitelist  addProtocols  (  String  tag  ,  String  key  ,  String  .  .  .  protocols  )  {  Validate  .  notEmpty  (  tag  )  ;  Validate  .  notEmpty  (  key  )  ;  [ATTENTION]  protSet  .  add  (  prot  )    ;    TagName  tagName  =  TagName  .  valueOf  (  tag  )  ;  AttributeKey  attrKey  =  AttributeKey  .  valueOf  (  key  )  ;  Map<AttributeKey  ,  Set<Protocol>>  attrMap  ;  Set<Protocol>  protSet  ;    if  (  this  .  protocols  .  containsKey  (  tagName  )  )  {  attrMap  =  this  .  protocols  .  get  (  tagName  )  ;  }  else  {  attrMap  =  new  HashMap<AttributeKey  ,  Set<Protocol>>  (  )  ;  this  .  protocols  .  put  (  tagName  ,  attrMap  )  ;  }  if  (  attrMap  .  containsKey  (  attrKey  )  )  {  protSet  =  attrMap  .  get  (  attrKey  )  ;  }  else  {  protSet  =  new  HashSet<Protocol>  (  )  ;  attrMap  .  put  (  attrKey  ,  protSet  )  ;  }  for  (  String  protocol  :  protocols  )  {  Validate  .  notEmpty  (  protocol  )  ;  Protocol  prot  =  Protocol  .  valueOf  (  protocol  )  ;  protSet  .  add  (  prot  )  ;  }  return  this  ;  }    [METHOD]  addProtocols  [TYPE]  Whitelist  [PARAMETER]  String  tag  String  key  protocols  [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [TYPE]  AttributeKey  attrKey  [TYPE]  Set  attributeSet  currentSet  protSet  tagNames  [TYPE]  boolean  false  true  [TYPE]  TagName  tagName  [TYPE]  String  key  protocol  tag  tagName  value  [TYPE]  String[]  protocols  [TYPE]  Protocol  prot  [TYPE]  Map  attrMap  attributes  enforcedAttributes  protocols  
[REPLACE]  TagName  tagName  =  TagName  .  valueOf  (  tag  )  ;	[BUGGY]  TagName  valueName  =  TagName  .  TagName  (  tag  )  ;  [CE]  cannot  find  symbol  [CONTEXT]  public  Whitelist  addProtocols  (  String  tag  ,  String  key  ,  String  .  .  .  protocols  )  {  Validate  .  notEmpty  (  tag  )  ;  Validate  .  notEmpty  (  key  )  ;  Validate  .  notNull  (  protocols  )  ;    [ATTENTION]  TagName  valueName  =  TagName  .  TagName  (  tag  )    ;  AttributeKey  attrKey  =  AttributeKey  .  valueOf  (  key  )  ;  Map<AttributeKey  ,  Set<Protocol>>  attrMap  ;  Set<Protocol>  protSet  ;    if  (  this  .  protocols  .  containsKey  (  tagName  )  )  {  attrMap  =  this  .  protocols  .  get  (  tagName  )  ;  }  else  {  attrMap  =  new  HashMap<AttributeKey  ,  Set<Protocol>>  (  )  ;  this  .  protocols  .  put  (  tagName  ,  attrMap  )  ;  }  if  (  attrMap  .  containsKey  (  attrKey  )  )  {  protSet  =  attrMap  .  get  (  attrKey  )  ;  }  else  {  protSet  =  new  HashSet<Protocol>  (  )  ;  attrMap  .  put  (  attrKey  ,  protSet  )  ;  }  for  (  String  protocol  :  protocols  )  {  Validate  .  notEmpty  (  protocol  )  ;  Protocol  prot  =  Protocol  .  valueOf  (  protocol  )  ;  protSet  .  add  (  prot  )  ;  }  return  this  ;  }    [METHOD]  addProtocols  [TYPE]  Whitelist  [PARAMETER]  String  tag  String  key  protocols  [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [TYPE]  AttributeKey  attrKey  [TYPE]  Set  attributeSet  currentSet  protSet  tagNames  [TYPE]  boolean  false  true  [TYPE]  TagName  tagName  [TYPE]  String  key  protocol  tag  tagName  value  [TYPE]  String[]  protocols  [TYPE]  Protocol  prot  [TYPE]  Map  attrMap  attributes  enforcedAttributes  protocols  
[ADD]  TagName  tagName  =  TagName  .  valueOf  (  tag  )  ;  AttributeKey  attrKey  =  AttributeKey  .  valueOf  (  key  )  ;	[BUGGY]  [CE]  cannot  find  symbol  tagName  [CONTEXT]  public  Whitelist  addProtocols  (  String  tag  ,  String  key  ,  String  .  .  .  protocols  )  {  Validate  .  notEmpty  (  tag  )  ;  Validate  .  notEmpty  (  key  )  ;  Validate  .  notNull  (  protocols  )  ;    [ATTENTION]    Map<AttributeKey  ,  Set<Protocol>>  attrMap  ;  Set<Protocol>  protSet  ;    if  (  this  .  protocols  .  containsKey  (  tagName  )  )  {  attrMap  =  this  .  protocols  .  get  (  tagName  )  ;  }  else  {  attrMap  =  new  HashMap<AttributeKey  ,  Set<Protocol>>  (  )  ;  this  .  protocols  .  put  (  tagName  ,  attrMap  )  ;  }  if  (  attrMap  .  containsKey  (  attrKey  )  )  {  protSet  =  attrMap  .  get  (  attrKey  )  ;  }  else  {  protSet  =  new  HashSet<Protocol>  (  )  ;  attrMap  .  put  (  attrKey  ,  protSet  )  ;  }  for  (  String  protocol  :  protocols  )  {  Validate  .  notEmpty  (  protocol  )  ;  Protocol  prot  =  Protocol  .  valueOf  (  protocol  )  ;  protSet  .  add  (  prot  )  ;  }  return  this  ;  }    [METHOD]  addProtocols  [TYPE]  Whitelist  [PARAMETER]  String  tag  String  key  protocols  [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [TYPE]  AttributeKey  attrKey  [TYPE]  Set  attributeSet  currentSet  protSet  tagNames  [TYPE]  boolean  false  true  [TYPE]  TagName  tagName  [TYPE]  String  key  protocol  tag  tagName  value  [TYPE]  String[]  protocols  [TYPE]  Protocol  prot  [TYPE]  Map  attrMap  attributes  enforcedAttributes  protocols  
[REPLACE]  AttributeKey  attrKey  =  AttributeKey  .  valueOf  (  key  )  ;	[BUGGY]  AttributeKey  attrKey  =  AttributeKey  .  TagName  (  key  )    ;  [CE]  cannot  find  symbol  [CONTEXT]  public  Whitelist  addProtocols  (  String  tag  ,  String  key  ,  String  .  .  .  protocols  )  {  Validate  .  notEmpty  (  tag  )  ;  Validate  .  notEmpty  (  key  )  ;  Validate  .  notNull  (  protocols  )  ;    TagName  tagName  =  TagName  .  valueOf  (  tag  )  ;  [ATTENTION]  AttributeKey  attrKey  =  AttributeKey  .  TagName  (  key  )  ;  Map<AttributeKey  ,  Set<Protocol>>  attrMap  ;  Set<Protocol>  protSet  ;    if  (  this  .  protocols  .  containsKey  (  tagName  )  )  {  attrMap  =  this  .  protocols  .  get  (  tagName  )  ;  }  else  {  attrMap  =  new  HashMap<AttributeKey  ,  Set<Protocol>>  (  )  ;  this  .  protocols  .  put  (  tagName  ,  attrMap  )  ;  }  if  (  attrMap  .  containsKey  (  attrKey  )  )  {  protSet  =  attrMap  .  get  (  attrKey  )  ;  }  else  {  protSet  =  new  HashSet<Protocol>  (  )  ;  attrMap  .  put  (  attrKey  ,  protSet  )  ;  }  for  (  String  protocol  :  protocols  )  {  Validate  .  notEmpty  (  protocol  )  ;  Protocol  prot  =  Protocol  .  valueOf  (  protocol  )  ;  protSet  .  add  (  prot  )  ;  }  return  this  ;  }    [METHOD]  addProtocols  [TYPE]  Whitelist  [PARAMETER]  String  tag  String  key  protocols  [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [TYPE]  AttributeKey  attrKey  [TYPE]  Set  attributeSet  currentSet  protSet  tagNames  [TYPE]  boolean  false  true  [TYPE]  TagName  tagName  [TYPE]  String  key  protocol  tag  tagName  value  [TYPE]  String[]  protocols  [TYPE]  Protocol  prot  [TYPE]  Map  attrMap  attributes  enforcedAttributes  protocols  
[REPLACE]  Map<AttributeKey,  Set<Protocol>>  attrMap;	[BUGGY]  Set<AttributeKey>  currentSet  =  attributes  .  get  (  tagName  )  ;  [CE]  cannot  find  symbol  attrMap  [CONTEXT]  public  Whitelist  addProtocols  (  String  tag  ,  String  key  ,  String  .  .  .  protocols  )  {  Validate  .  notEmpty  (  tag  )  ;  Validate  .  notEmpty  (  key  )  ;  Validate  .  notNull  (  protocols  )  ;    TagName  tagName  =  TagName  .  valueOf  (  tag  )  ;  AttributeKey  attrKey  =  AttributeKey  .  valueOf  (  key  )  ;  [ATTENTION]  Set<AttributeKey>  currentSet  =  attributes  .  get  (  tagName  )    ;  Set<Protocol>  protSet  ;    if  (  this  .  protocols  .  containsKey  (  tagName  )  )  {  attrMap  =  this  .  protocols  .  get  (  tagName  )  ;  }  else  {  attrMap  =  new  HashMap<AttributeKey  ,  Set<Protocol>>  (  )  ;  this  .  protocols  .  put  (  tagName  ,  attrMap  )  ;  }  if  (  attrMap  .  containsKey  (  attrKey  )  )  {  protSet  =  attrMap  .  get  (  attrKey  )  ;  }  else  {  protSet  =  new  HashSet<Protocol>  (  )  ;  attrMap  .  put  (  attrKey  ,  protSet  )  ;  }  for  (  String  protocol  :  protocols  )  {  Validate  .  notEmpty  (  protocol  )  ;  Protocol  prot  =  Protocol  .  valueOf  (  protocol  )  ;  protSet  .  add  (  prot  )  ;  }  return  this  ;  }    [METHOD]  addProtocols  [TYPE]  Whitelist  [PARAMETER]  String  tag  String  key  protocols  [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [TYPE]  AttributeKey  attrKey  [TYPE]  Set  attributeSet  currentSet  protSet  tagNames  [TYPE]  boolean  false  true  [TYPE]  TagName  tagName  [TYPE]  String  key  protocol  tag  tagName  value  [TYPE]  String[]  protocols  [TYPE]  Protocol  prot  [TYPE]  Map  attrMap  attributes  enforcedAttributes  protocols  
[REPLACE]  Set<Protocol>  protSet;	[BUGGY]  Map<AttributeKey  ,  Set<Protocol>>  attrMap  ;  [CE]  variable  attrMap  is  already  defined  in  method  addProtocols(String  ,  String  ,  String...)  [CONTEXT]  public  Whitelist  addProtocols  (  String  tag  ,  String  key  ,  String  .  .  .  protocols  )  {  Validate  .  notEmpty  (  tag  )  ;  Validate  .  notEmpty  (  key  )  ;  Validate  .  notNull  (  protocols  )  ;    TagName  tagName  =  TagName  .  valueOf  (  tag  )  ;  AttributeKey  attrKey  =  AttributeKey  .  valueOf  (  key  )  ;  Map<AttributeKey  ,  Set<Protocol>>  attrMap  ;  [ATTENTION]  Map<AttributeKey  ,  Set<Protocol>>  attrMap  ;    if  (  this  .  protocols  .  containsKey  (  tagName  )  )  {  attrMap  =  this  .  protocols  .  get  (  tagName  )  ;  }  else  {  attrMap  =  new  HashMap<AttributeKey  ,  Set<Protocol>>  (  )  ;  this  .  protocols  .  put  (  tagName  ,  attrMap  )  ;  }  if  (  attrMap  .  containsKey  (  attrKey  )  )  {  protSet  =  attrMap  .  get  (  attrKey  )  ;  }  else  {  protSet  =  new  HashSet<Protocol>  (  )  ;  attrMap  .  put  (  attrKey  ,  protSet  )  ;  }  for  (  String  protocol  :  protocols  )  {  Validate  .  notEmpty  (  protocol  )  ;  Protocol  prot  =  Protocol  .  valueOf  (  protocol  )  ;  protSet  .  add  (  prot  )  ;  }  return  this  ;  }    [METHOD]  addProtocols  [TYPE]  Whitelist  [PARAMETER]  String  tag  String  key  protocols  [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [TYPE]  AttributeKey  attrKey  [TYPE]  Set  attributeSet  currentSet  protSet  tagNames  [TYPE]  boolean  false  true  [TYPE]  TagName  tagName  [TYPE]  String  key  protocol  tag  tagName  value  [TYPE]  String[]  protocols  [TYPE]  Protocol  prot  [TYPE]  Map  attrMap  attributes  enforcedAttributes  protocols  
[REPLACE]  if  (  this  .  protocols  .  containsKey  (  tagName  )  )  {	[BUGGY]  if  (  this  .  protocols  .  get  (  tagName  )  )  {[CE]  incompatible  types  [CONTEXT]  public  Whitelist  addProtocols  (  String  tag  ,  String  key  ,  String  .  .  .  protocols  )  {  Validate  .  notEmpty  (  tag  )  ;  Validate  .  notEmpty  (  key  )  ;  Validate  .  notNull  (  protocols  )  ;    TagName  tagName  =  TagName  .  valueOf  (  tag  )  ;  AttributeKey  attrKey  =  AttributeKey  .  valueOf  (  key  )  ;  Map<AttributeKey  ,  Set<Protocol>>  attrMap  ;  Set<Protocol>  protSet  ;    [ATTENTION]  if  (  this  .  protocols  .  get  (  tagName  )  )  {  attrMap  =  this  .  protocols  .  get  (  tagName  )  ;  }  else  {  attrMap  =  new  HashMap<AttributeKey  ,  Set<Protocol>>  (  )  ;  this  .  protocols  .  put  (  tagName  ,  attrMap  )  ;  }  if  (  attrMap  .  containsKey  (  attrKey  )  )  {  protSet  =  attrMap  .  get  (  attrKey  )  ;  }  else  {  protSet  =  new  HashSet<Protocol>  (  )  ;  attrMap  .  put  (  attrKey  ,  protSet  )  ;  }  for  (  String  protocol  :  protocols  )  {  Validate  .  notEmpty  (  protocol  )  ;  Protocol  prot  =  Protocol  .  valueOf  (  protocol  )  ;  protSet  .  add  (  prot  )  ;  }  return  this  ;  }    [METHOD]  addProtocols  [TYPE]  Whitelist  [PARAMETER]  String  tag  String  key  protocols  [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [TYPE]  AttributeKey  attrKey  [TYPE]  Set  attributeSet  currentSet  protSet  tagNames  [TYPE]  boolean  false  true  [TYPE]  TagName  tagName  [TYPE]  String  key  protocol  tag  tagName  value  [TYPE]  String[]  protocols  [TYPE]  Protocol  prot  [TYPE]  Map  attrMap  attributes  enforcedAttributes  protocols  
[REPLACE]  attrMap  =  new  HashMap<AttributeKey,  Set<Protocol>>  (  )  ;	[BUGGY]  attrMap  =    new  AttributeKey  ,  AttributeValue>  (  )    ;  [CE]  '('  or  '['  expected  [CONTEXT]  if  (  this  .  protocols  .  containsKey  (  tagName  )  )  {  attrMap  =  this  .  protocols  .  get  (  tagName  )  ;  }  else  {  [ATTENTION]  attrMap  =  new  AttributeKey  ,  AttributeValue>  (  )  ;  this  .  protocols  .  put  (  tagName  ,  attrMap  )  ;  }    [METHOD]  addProtocols  [TYPE]  Whitelist  [PARAMETER]  String  tag  String  key  protocols  [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [TYPE]  AttributeKey  attrKey  [TYPE]  Set  attributeSet  currentSet  protSet  tagNames  [TYPE]  boolean  false  true  [TYPE]  TagName  tagName  [TYPE]  String  key  protocol  tag  tagName  value  [TYPE]  String[]  protocols  [TYPE]  Protocol  prot  [TYPE]  Map  attrMap  attributes  enforcedAttributes  protocols  
[REPLACE]  attrMap  =  this  .  protocols  .  get  (  tagName  )  ;	[BUGGY]  attrMap  =    this  .  protocols  .  get  (  null  )  ;  [NO-ERROR]  [CONTEXT]  public  Whitelist  addProtocols  (  String  tag  ,  String  key  ,  String  .  .  .  protocols  )  {  Validate  .  notEmpty  (  tag  )  ;  Validate  .  notEmpty  (  key  )  ;  Validate  .  notNull  (  protocols  )  ;    TagName  tagName  =  TagName  .  valueOf  (  tag  )  ;  AttributeKey  attrKey  =  AttributeKey  .  valueOf  (  key  )  ;  Map<AttributeKey  ,  Set<Protocol>>  attrMap  ;  Set<Protocol>  protSet  ;    if  (  this  .  protocols  .  containsKey  (  tagName  )  )  {  [ATTENTION]  attrMap  =  this  .  protocols  .  get  (  null  )    ;  }  else  {  attrMap  =  new  HashMap<AttributeKey  ,  Set<Protocol>>  (  )  ;  this  .  protocols  .  put  (  tagName  ,  attrMap  )  ;  }  if  (  attrMap  .  containsKey  (  attrKey  )  )  {  protSet  =  attrMap  .  get  (  attrKey  )  ;  }  else  {  protSet  =  new  HashSet<Protocol>  (  )  ;  attrMap  .  put  (  attrKey  ,  protSet  )  ;  }  for  (  String  protocol  :  protocols  )  {  Validate  .  notEmpty  (  protocol  )  ;  Protocol  prot  =  Protocol  .  valueOf  (  protocol  )  ;  protSet  .  add  (  prot  )  ;  }  return  this  ;  }    [METHOD]  addProtocols  [TYPE]  Whitelist  [PARAMETER]  String  tag  String  key  protocols  [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [TYPE]  AttributeKey  attrKey  [TYPE]  Set  attributeSet  currentSet  protSet  tagNames  [TYPE]  boolean  false  true  [TYPE]  TagName  tagName  [TYPE]  String  key  protocol  tag  tagName  value  [TYPE]  String[]  protocols  [TYPE]  Protocol  prot  [TYPE]  Map  attrMap  attributes  enforcedAttributes  protocols  
[REPLACE]  attrMap  =  new  HashMap<AttributeKey,  Set<Protocol>>  (  )  ;	[BUGGY]  attrMap  =    new  AttributeKey  ,  AttributeValue>  (  )    ;  [CE]  '('  or  '['  expected  [CONTEXT]  public  Whitelist  addProtocols  (  String  tag  ,  String  key  ,  String  .  .  .  protocols  )  {  Validate  .  notEmpty  (  tag  )  ;  Validate  .  notEmpty  (  key  )  ;  Validate  .  notNull  (  protocols  )  ;    TagName  tagName  =  TagName  .  valueOf  (  tag  )  ;  AttributeKey  attrKey  =  AttributeKey  .  valueOf  (  key  )  ;  Map<AttributeKey  ,  Set<Protocol>>  attrMap  ;  Set<Protocol>  protSet  ;    if  (  this  .  protocols  .  containsKey  (  tagName  )  )  {  attrMap  =  this  .  protocols  .  get  (  tagName  )  ;  }  else  {  [ATTENTION]  attrMap  =  new  AttributeKey  ,  AttributeValue>  (  )  ;  this  .  protocols  .  put  (  tagName  ,  attrMap  )  ;  }  if  (  attrMap  .  containsKey  (  attrKey  )  )  {  protSet  =  attrMap  .  get  (  attrKey  )  ;  }  else  {  protSet  =  new  HashSet<Protocol>  (  )  ;  attrMap  .  put  (  attrKey  ,  protSet  )  ;  }  for  (  String  protocol  :  protocols  )  {  Validate  .  notEmpty  (  protocol  )  ;  Protocol  prot  =  Protocol  .  valueOf  (  protocol  )  ;  protSet  .  add  (  prot  )  ;  }  return  this  ;  }    [METHOD]  addProtocols  [TYPE]  Whitelist  [PARAMETER]  String  tag  String  key  protocols  [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [TYPE]  AttributeKey  attrKey  [TYPE]  Set  attributeSet  currentSet  protSet  tagNames  [TYPE]  boolean  false  true  [TYPE]  TagName  tagName  [TYPE]  String  key  protocol  tag  tagName  value  [TYPE]  String[]  protocols  [TYPE]  Protocol  prot  [TYPE]  Map  attrMap  attributes  enforcedAttributes  protocols  
[REPLACE]  if  (  attrMap  .  containsKey  (  attrKey  )  )  {	[BUGGY]  if  (  attrMap  .  entrySet  (  )    )  {[CE]  incompatible  types  [CONTEXT]  public  Whitelist  addProtocols  (  String  tag  ,  String  key  ,  String  .  .  .  protocols  )  {  Validate  .  notEmpty  (  tag  )  ;  Validate  .  notEmpty  (  key  )  ;  Validate  .  notNull  (  protocols  )  ;    TagName  tagName  =  TagName  .  valueOf  (  tag  )  ;  AttributeKey  attrKey  =  AttributeKey  .  valueOf  (  key  )  ;  Map<AttributeKey  ,  Set<Protocol>>  attrMap  ;  Set<Protocol>  protSet  ;    if  (  this  .  protocols  .  containsKey  (  tagName  )  )  {  attrMap  =  this  .  protocols  .  get  (  tagName  )  ;  }  else  {  attrMap  =  new  HashMap<AttributeKey  ,  Set<Protocol>>  (  )  ;  this  .  protocols  .  put  (  tagName  ,  attrMap  )  ;  }  [ATTENTION]  if  (  attrMap  .  entrySet  (  )    )  {  protSet  =  attrMap  .  get  (  attrKey  )  ;  }  else  {  protSet  =  new  HashSet<Protocol>  (  )  ;  attrMap  .  put  (  attrKey  ,  protSet  )  ;  }  for  (  String  protocol  :  protocols  )  {  Validate  .  notEmpty  (  protocol  )  ;  Protocol  prot  =  Protocol  .  valueOf  (  protocol  )  ;  protSet  .  add  (  prot  )  ;  }  return  this  ;  }    [METHOD]  addProtocols  [TYPE]  Whitelist  [PARAMETER]  String  tag  String  key  protocols  [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [TYPE]  AttributeKey  attrKey  [TYPE]  Set  attributeSet  currentSet  protSet  tagNames  [TYPE]  boolean  false  true  [TYPE]  TagName  tagName  [TYPE]  String  key  protocol  tag  tagName  value  [TYPE]  String[]  protocols  [TYPE]  Protocol  prot  [TYPE]  Map  attrMap  attributes  enforcedAttributes  protocols  
[REPLACE]  protSet  =  new  HashSet<Protocol>  (  )  ;	[BUGGY]  protSet  =    new  TagName>  (  )    ;  [CE]  '('  or  '['  expected  [CONTEXT]  if  (  attrMap  .  containsKey  (  attrKey  )  )  {  protSet  =  attrMap  .  get  (  attrKey  )  ;  }  else  {  [ATTENTION]  protSet  =  new  TagName>  (  )  ;  attrMap  .  put  (  attrKey  ,  protSet  )  ;  }    [METHOD]  addProtocols  [TYPE]  Whitelist  [PARAMETER]  String  tag  String  key  protocols  [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [TYPE]  AttributeKey  attrKey  [TYPE]  Set  attributeSet  currentSet  protSet  tagNames  [TYPE]  boolean  false  true  [TYPE]  TagName  tagName  [TYPE]  String  key  protocol  tag  tagName  value  [TYPE]  String[]  protocols  [TYPE]  Protocol  prot  [TYPE]  Map  attrMap  attributes  enforcedAttributes  protocols  
[REPLACE]  protSet  =  attrMap  .  get  (  attrKey  )  ;	[BUGGY]  protSet  =    this  .  get  (  attrKey  )  ;  [CE]  cannot  find  symbol  [CONTEXT]  public  Whitelist  addProtocols  (  String  tag  ,  String  key  ,  String  .  .  .  protocols  )  {  Validate  .  notEmpty  (  tag  )  ;  Validate  .  notEmpty  (  key  )  ;  Validate  .  notNull  (  protocols  )  ;    TagName  tagName  =  TagName  .  valueOf  (  tag  )  ;  AttributeKey  attrKey  =  AttributeKey  .  valueOf  (  key  )  ;  Map<AttributeKey  ,  Set<Protocol>>  attrMap  ;  Set<Protocol>  protSet  ;    if  (  this  .  protocols  .  containsKey  (  tagName  )  )  {  attrMap  =  this  .  protocols  .  get  (  tagName  )  ;  }  else  {  attrMap  =  new  HashMap<AttributeKey  ,  Set<Protocol>>  (  )  ;  this  .  protocols  .  put  (  tagName  ,  attrMap  )  ;  }  if  (  attrMap  .  containsKey  (  attrKey  )  )  {  [ATTENTION]  protSet  =  this  .  get  (  attrKey  )    ;  }  else  {  protSet  =  new  HashSet<Protocol>  (  )  ;  attrMap  .  put  (  attrKey  ,  protSet  )  ;  }  for  (  String  protocol  :  protocols  )  {  Validate  .  notEmpty  (  protocol  )  ;  Protocol  prot  =  Protocol  .  valueOf  (  protocol  )  ;  protSet  .  add  (  prot  )  ;  }  return  this  ;  }    [METHOD]  addProtocols  [TYPE]  Whitelist  [PARAMETER]  String  tag  String  key  protocols  [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [TYPE]  AttributeKey  attrKey  [TYPE]  Set  attributeSet  currentSet  protSet  tagNames  [TYPE]  boolean  false  true  [TYPE]  TagName  tagName  [TYPE]  String  key  protocol  tag  tagName  value  [TYPE]  String[]  protocols  [TYPE]  Protocol  prot  [TYPE]  Map  attrMap  attributes  enforcedAttributes  protocols  
[ADD]  protSet  =  attrMap  .  get  (  attrKey  )  ;	[BUGGY]  [CE]  variable  protSet  might  not  have  been  initialized  [CONTEXT]  public  Whitelist  addProtocols  (  String  tag  ,  String  key  ,  String  .  .  .  protocols  )  {  Validate  .  notEmpty  (  tag  )  ;  Validate  .  notEmpty  (  key  )  ;  Validate  .  notNull  (  protocols  )  ;    TagName  tagName  =  TagName  .  valueOf  (  tag  )  ;  AttributeKey  attrKey  =  AttributeKey  .  valueOf  (  key  )  ;  Map<AttributeKey  ,  Set<Protocol>>  attrMap  ;  Set<Protocol>  protSet  ;    if  (  this  .  protocols  .  containsKey  (  tagName  )  )  {  attrMap  =  this  .  protocols  .  get  (  tagName  )  ;  }  else  {  attrMap  =  new  HashMap<AttributeKey  ,  Set<Protocol>>  (  )  ;  this  .  protocols  .  put  (  tagName  ,  attrMap  )  ;  }  if  (  attrMap  .  containsKey  (  attrKey  )  )  {  [ATTENTION]  }  else  {  protSet  =  new  HashSet<Protocol>  (  )  ;  attrMap  .  put  (  attrKey  ,  protSet  )  ;  }  for  (  String  protocol  :  protocols  )  {  Validate  .  notEmpty  (  protocol  )  ;  Protocol  prot  =  Protocol  .  valueOf  (  protocol  )  ;  protSet  .  add  (  prot  )  ;  }  return  this  ;  }    [METHOD]  addProtocols  [TYPE]  Whitelist  [PARAMETER]  String  tag  String  key  protocols  [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [TYPE]  AttributeKey  attrKey  [TYPE]  Set  attributeSet  currentSet  protSet  tagNames  [TYPE]  boolean  false  true  [TYPE]  TagName  tagName  [TYPE]  String  key  protocol  tag  tagName  value  [TYPE]  String[]  protocols  [TYPE]  Protocol  prot  [TYPE]  Map  attrMap  attributes  enforcedAttributes  protocols  
[REPLACE]  protSet  =  attrMap  .  get  (  attrKey  )  ;	[BUGGY]  protSet  =    null  .  get  (  attrKey  )  ;  [CE]  <null>  cannot  be  dereferenced  [CONTEXT]  public  Whitelist  addProtocols  (  String  tag  ,  String  key  ,  String  .  .  .  protocols  )  {  Validate  .  notEmpty  (  tag  )  ;  Validate  .  notEmpty  (  key  )  ;  Validate  .  notNull  (  protocols  )  ;    TagName  tagName  =  TagName  .  valueOf  (  tag  )  ;  AttributeKey  attrKey  =  AttributeKey  .  valueOf  (  key  )  ;  Map<AttributeKey  ,  Set<Protocol>>  attrMap  ;  Set<Protocol>  protSet  ;    if  (  this  .  protocols  .  containsKey  (  tagName  )  )  {  attrMap  =  this  .  protocols  .  get  (  tagName  )  ;  }  else  {  attrMap  =  new  HashMap<AttributeKey  ,  Set<Protocol>>  (  )  ;  this  .  protocols  .  put  (  tagName  ,  attrMap  )  ;  }  if  (  attrMap  .  containsKey  (  attrKey  )  )  {  [ATTENTION]  protSet  =  null  .  get  (  attrKey  )    ;  }  else  {  protSet  =  new  HashSet<Protocol>  (  )  ;  attrMap  .  put  (  attrKey  ,  protSet  )  ;  }  for  (  String  protocol  :  protocols  )  {  Validate  .  notEmpty  (  protocol  )  ;  Protocol  prot  =  Protocol  .  valueOf  (  protocol  )  ;  protSet  .  add  (  prot  )  ;  }  return  this  ;  }    [METHOD]  addProtocols  [TYPE]  Whitelist  [PARAMETER]  String  tag  String  key  protocols  [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [TYPE]  AttributeKey  attrKey  [TYPE]  Set  attributeSet  currentSet  protSet  tagNames  [TYPE]  boolean  false  true  [TYPE]  TagName  tagName  [TYPE]  String  key  protocol  tag  tagName  value  [TYPE]  String[]  protocols  [TYPE]  Protocol  prot  [TYPE]  Map  attrMap  attributes  enforcedAttributes  protocols  
[REPLACE]  protSet  =  new  HashSet<Protocol>  (  )  ;	[BUGGY]  protSet  =    new  TagName>  (  )    ;  [CE]  '('  or  '['  expected  [CONTEXT]  public  Whitelist  addProtocols  (  String  tag  ,  String  key  ,  String  .  .  .  protocols  )  {  Validate  .  notEmpty  (  tag  )  ;  Validate  .  notEmpty  (  key  )  ;  Validate  .  notNull  (  protocols  )  ;    TagName  tagName  =  TagName  .  valueOf  (  tag  )  ;  AttributeKey  attrKey  =  AttributeKey  .  valueOf  (  key  )  ;  Map<AttributeKey  ,  Set<Protocol>>  attrMap  ;  Set<Protocol>  protSet  ;    if  (  this  .  protocols  .  containsKey  (  tagName  )  )  {  attrMap  =  this  .  protocols  .  get  (  tagName  )  ;  }  else  {  attrMap  =  new  HashMap<AttributeKey  ,  Set<Protocol>>  (  )  ;  this  .  protocols  .  put  (  tagName  ,  attrMap  )  ;  }  if  (  attrMap  .  containsKey  (  attrKey  )  )  {  protSet  =  attrMap  .  get  (  attrKey  )  ;  }  else  {  [ATTENTION]  protSet  =  new  TagName>  (  )  ;  attrMap  .  put  (  attrKey  ,  protSet  )  ;  }  for  (  String  protocol  :  protocols  )  {  Validate  .  notEmpty  (  protocol  )  ;  Protocol  prot  =  Protocol  .  valueOf  (  protocol  )  ;  protSet  .  add  (  prot  )  ;  }  return  this  ;  }    [METHOD]  addProtocols  [TYPE]  Whitelist  [PARAMETER]  String  tag  String  key  protocols  [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [TYPE]  AttributeKey  attrKey  [TYPE]  Set  attributeSet  currentSet  protSet  tagNames  [TYPE]  boolean  false  true  [TYPE]  TagName  tagName  [TYPE]  String  key  protocol  tag  tagName  value  [TYPE]  String[]  protocols  [TYPE]  Protocol  prot  [TYPE]  Map  attrMap  attributes  enforcedAttributes  protocols  
[REPLACE]  for  (  String  protocol  :  protocols  )  {	[BUGGY]  for  (  String  key  :  keys  )  {  Validate  .  notEmpty  (  key  )  ;  [CE]  variable  key  is  already  defined  in  method  addProtocols(String  ,  String  ,  String...)  [CONTEXT]  public  Whitelist  addProtocols  (  String  tag  ,  String  key  ,  String  .  .  .  protocols  )  {  Validate  .  notEmpty  (  tag  )  ;  Validate  .  notEmpty  (  key  )  ;  Validate  .  notNull  (  protocols  )  ;    TagName  tagName  =  TagName  .  valueOf  (  tag  )  ;  AttributeKey  attrKey  =  AttributeKey  .  valueOf  (  key  )  ;  Map<AttributeKey  ,  Set<Protocol>>  attrMap  ;  Set<Protocol>  protSet  ;    if  (  this  .  protocols  .  containsKey  (  tagName  )  )  {  attrMap  =  this  .  protocols  .  get  (  tagName  )  ;  }  else  {  attrMap  =  new  HashMap<AttributeKey  ,  Set<Protocol>>  (  )  ;  this  .  protocols  .  put  (  tagName  ,  attrMap  )  ;  }  if  (  attrMap  .  containsKey  (  attrKey  )  )  {  protSet  =  attrMap  .  get  (  attrKey  )  ;  }  else  {  protSet  =  new  HashSet<Protocol>  (  )  ;  attrMap  .  put  (  attrKey  ,  protSet  )  ;  }  [ATTENTION]  for  (  String  key  :  keys  )  {  Validate  .  notEmpty  (  key  )    ;  Validate  .  notEmpty  (  protocol  )  ;  Protocol  prot  =  Protocol  .  valueOf  (  protocol  )  ;  protSet  .  add  (  prot  )  ;  }  return  this  ;  }    [METHOD]  addProtocols  [TYPE]  Whitelist  [PARAMETER]  String  tag  String  key  protocols  [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [TYPE]  AttributeKey  attrKey  [TYPE]  Set  attributeSet  currentSet  protSet  tagNames  [TYPE]  boolean  false  true  [TYPE]  TagName  tagName  [TYPE]  String  key  protocol  tag  tagName  value  [TYPE]  String[]  protocols  [TYPE]  Protocol  prot  [TYPE]  Map  attrMap  attributes  enforcedAttributes  protocols  
[REPLACE]  Protocol  prot  =  Protocol  .  valueOf  (  protocol  )  ;	[BUGGY]  Protocol  prot  =  Protocol  .  valueOf  (  tag  )  ;  [FE]  AssertionFailedError    expected:<...ollow ">Dodgy</a>  <a  [href  =   "http://nice.com "  ]rel  =   "nofollow ">Nice<...>  but  was:<...ollow ">Dodgy</a>  <a  []rel  =   "nofollow ">Nice<...>  assertEquals( "<p><a  rel  =  \ "nofollow\ ">Dodgy</a>  <a  href  =  \ "http://nice.com\ "  rel  =  \ "nofollow\ ">Nice</a></p><blockquote>Hello</blockquote> "  ,  [CONTEXT]  public  Whitelist  addProtocols  (  String  tag  ,  String  key  ,  String  .  .  .  protocols  )  {  Validate  .  notEmpty  (  tag  )  ;  Validate  .  notEmpty  (  key  )  ;  Validate  .  notNull  (  protocols  )  ;    TagName  tagName  =  TagName  .  valueOf  (  tag  )  ;  AttributeKey  attrKey  =  AttributeKey  .  valueOf  (  key  )  ;  Map<AttributeKey  ,  Set<Protocol>>  attrMap  ;  Set<Protocol>  protSet  ;    if  (  this  .  protocols  .  containsKey  (  tagName  )  )  {  attrMap  =  this  .  protocols  .  get  (  tagName  )  ;  }  else  {  attrMap  =  new  HashMap<AttributeKey  ,  Set<Protocol>>  (  )  ;  this  .  protocols  .  put  (  tagName  ,  attrMap  )  ;  }  if  (  attrMap  .  containsKey  (  attrKey  )  )  {  protSet  =  attrMap  .  get  (  attrKey  )  ;  }  else  {  protSet  =  new  HashSet<Protocol>  (  )  ;  attrMap  .  put  (  attrKey  ,  protSet  )  ;  }  for  (  String  protocol  :  protocols  )  {  Validate  .  notEmpty  (  protocol  )  ;  [ATTENTION]  Protocol  prot  =  Protocol  .  valueOf  (  tag  )    ;  protSet  .  add  (  prot  )  ;  }  return  this  ;  }    [METHOD]  addProtocols  [TYPE]  Whitelist  [PARAMETER]  String  tag  String  key  protocols  [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [TYPE]  AttributeKey  attrKey  [TYPE]  Set  attributeSet  currentSet  protSet  tagNames  [TYPE]  boolean  false  true  [TYPE]  TagName  tagName  [TYPE]  String  key  protocol  tag  tagName  value  [TYPE]  String[]  protocols  [TYPE]  Protocol  prot  [TYPE]  Map  attrMap  attributes  enforcedAttributes  protocols  
[ADD]  Protocol  prot  =  Protocol  .  valueOf  (  protocol  )  ;	[BUGGY]  [CE]  cannot  find  symbol  prot  [CONTEXT]  public  Whitelist  addProtocols  (  String  tag  ,  String  key  ,  String  .  .  .  protocols  )  {  Validate  .  notEmpty  (  tag  )  ;  Validate  .  notEmpty  (  key  )  ;  Validate  .  notNull  (  protocols  )  ;    TagName  tagName  =  TagName  .  valueOf  (  tag  )  ;  AttributeKey  attrKey  =  AttributeKey  .  valueOf  (  key  )  ;  Map<AttributeKey  ,  Set<Protocol>>  attrMap  ;  Set<Protocol>  protSet  ;    if  (  this  .  protocols  .  containsKey  (  tagName  )  )  {  attrMap  =  this  .  protocols  .  get  (  tagName  )  ;  }  else  {  attrMap  =  new  HashMap<AttributeKey  ,  Set<Protocol>>  (  )  ;  this  .  protocols  .  put  (  tagName  ,  attrMap  )  ;  }  if  (  attrMap  .  containsKey  (  attrKey  )  )  {  protSet  =  attrMap  .  get  (  attrKey  )  ;  }  else  {  protSet  =  new  HashSet<Protocol>  (  )  ;  attrMap  .  put  (  attrKey  ,  protSet  )  ;  }  for  (  String  protocol  :  protocols  )  {  Validate  .  notEmpty  (  protocol  )  ;  [ATTENTION]  protSet  .  add  (  prot  )  ;  }  return  this  ;  }    [METHOD]  addProtocols  [TYPE]  Whitelist  [PARAMETER]  String  tag  String  key  protocols  [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [TYPE]  AttributeKey  attrKey  [TYPE]  Set  attributeSet  currentSet  protSet  tagNames  [TYPE]  boolean  false  true  [TYPE]  TagName  tagName  [TYPE]  String  key  protocol  tag  tagName  value  [TYPE]  String[]  protocols  [TYPE]  Protocol  prot  [TYPE]  Map  attrMap  attributes  enforcedAttributes  protocols  
[REPLACE]  return  this;	[BUGGY]  return  null  ;  [FE]  null  assertEquals( "<img  alt  =  \ "\ "  /> "  ,  cleanHtml)  ;  [CONTEXT]  public  Whitelist  addProtocols  (  String  tag  ,  String  key  ,  String  .  .  .  protocols  )  {  Validate  .  notEmpty  (  tag  )  ;  Validate  .  notEmpty  (  key  )  ;  Validate  .  notNull  (  protocols  )  ;    TagName  tagName  =  TagName  .  valueOf  (  tag  )  ;  AttributeKey  attrKey  =  AttributeKey  .  valueOf  (  key  )  ;  Map<AttributeKey  ,  Set<Protocol>>  attrMap  ;  Set<Protocol>  protSet  ;    if  (  this  .  protocols  .  containsKey  (  tagName  )  )  {  attrMap  =  this  .  protocols  .  get  (  tagName  )  ;  }  else  {  attrMap  =  new  HashMap<AttributeKey  ,  Set<Protocol>>  (  )  ;  this  .  protocols  .  put  (  tagName  ,  attrMap  )  ;  }  if  (  attrMap  .  containsKey  (  attrKey  )  )  {  protSet  =  attrMap  .  get  (  attrKey  )  ;  }  else  {  protSet  =  new  HashSet<Protocol>  (  )  ;  attrMap  .  put  (  attrKey  ,  protSet  )  ;  }  for  (  String  protocol  :  protocols  )  {  Validate  .  notEmpty  (  protocol  )  ;  Protocol  prot  =  Protocol  .  valueOf  (  protocol  )  ;  protSet  .  add  (  prot  )  ;  }  [ATTENTION]  return  null  ;  }    [METHOD]  addProtocols  [TYPE]  Whitelist  [PARAMETER]  String  tag  String  key  protocols  [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [TYPE]  AttributeKey  attrKey  [TYPE]  Set  attributeSet  currentSet  protSet  tagNames  [TYPE]  boolean  false  true  [TYPE]  TagName  tagName  [TYPE]  String  key  protocol  tag  tagName  value  [TYPE]  String[]  protocols  [TYPE]  Protocol  prot  [TYPE]  Map  attrMap  attributes  enforcedAttributes  protocols  
[REPLACE]  return  tagNames  .  contains  (  TagName  .  valueOf  (  tag  )  )  ;	[BUGGY]  return  tagNames  .  addAll  (  TagName  .  valueOf  (  tag  )  )  ;  [CE]  no  suitable  method  found  for  addAll(TagName)  [CONTEXT]  boolean  isSafeTag  (  String  tag  )  {  [ATTENTION]  return  tagNames  .  addAll  (  TagName  .  valueOf  (  tag  )  )    ;  }    [METHOD]  isSafeTag  [TYPE]  boolean  [PARAMETER]  String  tag  [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [TYPE]  Set  attributeSet  currentSet  protSet  tagNames  [TYPE]  String  key  protocol  tag  tagName  value  [TYPE]  boolean  false  true  [TYPE]  Map  attrMap  attributes  enforcedAttributes  protocols  
[REPLACE]  TagName  tag  =  TagName  .  valueOf  (  tagName  )  ;	[BUGGY]  TagName  tag  =  TagName  .  valueOf  (  value  )  ;  [CE]  cannot  find  symbol  value  [CONTEXT]  boolean  isSafeAttribute  (  String  tagName  ,  Element  el  ,  Attribute  attr  )  {  [ATTENTION]  TagName  tag  =  TagName  .  valueOf  (  value  )    ;  AttributeKey  key  =  AttributeKey  .  valueOf  (  attr  .  getKey  (  )  )  ;    if  (  attributes  .  containsKey  (  tag  )  )  {  if  (  attributes  .  get  (  tag  )  .  contains  (  key  )  )  {  if  (  protocols  .  containsKey  (  tag  )  )  {  Map<AttributeKey  ,  Set<Protocol>>  attrProts  =  protocols  .  get  (  tag  )  ;    return  !attrProts  .  containsKey  (  key  )  ||  testValidProtocol  (  el  ,  attr  ,  attrProts  .  get  (  key  )  )  ;  }  else  {  //  attribute  found  ,  no  protocols  defined  ,  so  OK  return  true  ;  }  }  }  else  {  //  no  attributes  defined  for  tag  ,  try  :all  tag  return  !tagName  .  equals  (   ":all "  )  &&  isSafeAttribute  (   ":all "  ,  el  ,  attr  )  ;  }  return  false  ;  }    [METHOD]  isSafeAttribute  [TYPE]  boolean  [PARAMETER]  String  tagName  Element  el  Attribute  attr  [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [TYPE]  AttributeKey  key  [TYPE]  Set  attributeSet  currentSet  protSet  tagNames  [TYPE]  boolean  false  true  [TYPE]  TagName  tag  [TYPE]  Attribute  attr  [TYPE]  Element  el  [TYPE]  String  key  protocol  tag  tagName  value  [TYPE]  Map  attrMap  attrProts  attributes  enforcedAttributes  protocols  
[REPLACE]  AttributeKey  key  =  AttributeKey  .  valueOf  (  attr  .  getKey  (  )  )  ;	[BUGGY]  AttributeKey  key  =  AttributeKey  .  TagName  (  tag  )    ;  [CE]  cannot  find  symbol  [CONTEXT]  boolean  isSafeAttribute  (  String  tagName  ,  Element  el  ,  Attribute  attr  )  {  TagName  tag  =  TagName  .  valueOf  (  tagName  )  ;  [ATTENTION]  AttributeKey  key  =  AttributeKey  .  TagName  (  tag  )  ;    if  (  attributes  .  containsKey  (  tag  )  )  {  if  (  attributes  .  get  (  tag  )  .  contains  (  key  )  )  {  if  (  protocols  .  containsKey  (  tag  )  )  {  Map<AttributeKey  ,  Set<Protocol>>  attrProts  =  protocols  .  get  (  tag  )  ;    return  !attrProts  .  containsKey  (  key  )  ||  testValidProtocol  (  el  ,  attr  ,  attrProts  .  get  (  key  )  )  ;  }  else  {  //  attribute  found  ,  no  protocols  defined  ,  so  OK  return  true  ;  }  }  }  else  {  //  no  attributes  defined  for  tag  ,  try  :all  tag  return  !tagName  .  equals  (   ":all "  )  &&  isSafeAttribute  (   ":all "  ,  el  ,  attr  )  ;  }  return  false  ;  }    [METHOD]  isSafeAttribute  [TYPE]  boolean  [PARAMETER]  String  tagName  Element  el  Attribute  attr  [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [TYPE]  AttributeKey  key  [TYPE]  Set  attributeSet  currentSet  protSet  tagNames  [TYPE]  boolean  false  true  [TYPE]  TagName  tag  [TYPE]  Attribute  attr  [TYPE]  Element  el  [TYPE]  String  key  protocol  tag  tagName  value  [TYPE]  Map  attrMap  attrProts  attributes  enforcedAttributes  protocols  
[REPLACE]  if  (  attributes  .  containsKey  (  tag  )  )  {	[BUGGY]  if  (  enforcedAttributes  .  containsKey  (  tagName  )  )  {[FE]  AssertionFailedError    expected:<<img  [alt  =   " "  ]/>>  but  was:<<img  []/>>  assertEquals( "<img  alt  =  \ "\ "  /> "  ,  cleanHtml)  ;  [CONTEXT]  boolean  isSafeAttribute  (  String  tagName  ,  Element  el  ,  Attribute  attr  )  {  TagName  tag  =  TagName  .  valueOf  (  tagName  )  ;  AttributeKey  key  =  AttributeKey  .  valueOf  (  attr  .  getKey  (  )  )  ;    [ATTENTION]  if  (  enforcedAttributes  .  containsKey  (  tagName  )  )  {  if  (  attributes  .  get  (  tag  )  .  contains  (  key  )  )  {  if  (  protocols  .  containsKey  (  tag  )  )  {  Map<AttributeKey  ,  Set<Protocol>>  attrProts  =  protocols  .  get  (  tag  )  ;    return  !attrProts  .  containsKey  (  key  )  ||  testValidProtocol  (  el  ,  attr  ,  attrProts  .  get  (  key  )  )  ;  }  else  {  //  attribute  found  ,  no  protocols  defined  ,  so  OK  return  true  ;  }  }  }  else  {  //  no  attributes  defined  for  tag  ,  try  :all  tag  return  !tagName  .  equals  (   ":all "  )  &&  isSafeAttribute  (   ":all "  ,  el  ,  attr  )  ;  }  return  false  ;  }    [METHOD]  isSafeAttribute  [TYPE]  boolean  [PARAMETER]  String  tagName  Element  el  Attribute  attr  [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [TYPE]  AttributeKey  key  [TYPE]  Set  attributeSet  currentSet  protSet  tagNames  [TYPE]  boolean  false  true  [TYPE]  TagName  tag  [TYPE]  Attribute  attr  [TYPE]  Element  el  [TYPE]  String  key  protocol  tag  tagName  value  [TYPE]  Map  attrMap  attrProts  attributes  enforcedAttributes  protocols  
[REPLACE]  return  !tagName  .  equals  (   ":all "  )  &&  isSafeAttribute  (   ":all ",  el,  attr  )  ;	[BUGGY]  return  !tagName  .  equals  (   ":all "  )  ||  isSafeAttribute  (   ":all "  ,  el  ,  attr  )  ;  [FE]  AssertionFailedError    expected:<Hello  <b[]>there</b>!>  but  was:<Hello  <b[  id  =   "bar "]>there</b>!>  assertEquals( "Hello  <b>there</b>! "  ,  TextUtil.stripNewlines(cleanHtml))  ;  [CONTEXT]  boolean  isSafeAttribute  (  String  tagName  ,  Element  el  ,  Attribute  attr  )  {  TagName  tag  =  TagName  .  valueOf  (  tagName  )  ;  AttributeKey  key  =  AttributeKey  .  valueOf  (  attr  .  getKey  (  )  )  ;    if  (  attributes  .  containsKey  (  tag  )  )  {  if  (  attributes  .  get  (  tag  )  .  contains  (  key  )  )  {  if  (  protocols  .  containsKey  (  tag  )  )  {  Map<AttributeKey  ,  Set<Protocol>>  attrProts  =  protocols  .  get  (  tag  )  ;    return  !attrProts  .  containsKey  (  key  )  ||  testValidProtocol  (  el  ,  attr  ,  attrProts  .  get  (  key  )  )  ;  }  else  {  //  attribute  found  ,  no  protocols  defined  ,  so  OK  return  true  ;  }  }  }  else  {  //  no  attributes  defined  for  tag  ,  try  :all  tag  [ATTENTION]  return  !tagName  .  equals  (   ":all "  )  ||  isSafeAttribute  (   ":all "  ,  el  ,  attr  )    ;  }  return  false  ;  }    [METHOD]  isSafeAttribute  [TYPE]  boolean  [PARAMETER]  String  tagName  Element  el  Attribute  attr  [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [TYPE]  AttributeKey  key  [TYPE]  Set  attributeSet  currentSet  protSet  tagNames  [TYPE]  boolean  false  true  [TYPE]  TagName  tag  [TYPE]  Attribute  attr  [TYPE]  Element  el  [TYPE]  String  key  protocol  tag  tagName  value  [TYPE]  Map  attrMap  attrProts  attributes  enforcedAttributes  protocols  
[REPLACE]  if  (  attributes  .  get  (  tag  )    .  contains  (  key  )  )  {	[BUGGY]  if  (  attributes  .  get  (  tag  )  .  addAll  (  key  )  )  {[CE]  no  suitable  method  found  for  addAll(AttributeKey)  [CONTEXT]  boolean  isSafeAttribute  (  String  tagName  ,  Element  el  ,  Attribute  attr  )  {  TagName  tag  =  TagName  .  valueOf  (  tagName  )  ;  AttributeKey  key  =  AttributeKey  .  valueOf  (  attr  .  getKey  (  )  )  ;    if  (  attributes  .  containsKey  (  tag  )  )  {  [ATTENTION]  if  (  attributes  .  get  (  tag  )    .  addAll  (  key  )  )  {  if  (  protocols  .  containsKey  (  tag  )  )  {  Map<AttributeKey  ,  Set<Protocol>>  attrProts  =  protocols  .  get  (  tag  )  ;    return  !attrProts  .  containsKey  (  key  )  ||  testValidProtocol  (  el  ,  attr  ,  attrProts  .  get  (  key  )  )  ;  }  else  {  //  attribute  found  ,  no  protocols  defined  ,  so  OK  return  true  ;  }  }  }  else  {  //  no  attributes  defined  for  tag  ,  try  :all  tag  return  !tagName  .  equals  (   ":all "  )  &&  isSafeAttribute  (   ":all "  ,  el  ,  attr  )  ;  }  return  false  ;  }    [METHOD]  isSafeAttribute  [TYPE]  boolean  [PARAMETER]  String  tagName  Element  el  Attribute  attr  [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [TYPE]  AttributeKey  key  [TYPE]  Set  attributeSet  currentSet  protSet  tagNames  [TYPE]  boolean  false  true  [TYPE]  TagName  tag  [TYPE]  Attribute  attr  [TYPE]  Element  el  [TYPE]  String  key  protocol  tag  tagName  value  [TYPE]  Map  attrMap  attrProts  attributes  enforcedAttributes  protocols  
[REPLACE]  if  (  protocols  .  containsKey  (  tag  )  )  {	[BUGGY]  if  (  attributes  .  containsKey  (  tag  )  )  {[NO-ERROR]  [CONTEXT]  boolean  isSafeAttribute  (  String  tagName  ,  Element  el  ,  Attribute  attr  )  {  TagName  tag  =  TagName  .  valueOf  (  tagName  )  ;  AttributeKey  key  =  AttributeKey  .  valueOf  (  attr  .  getKey  (  )  )  ;    if  (  attributes  .  containsKey  (  tag  )  )  {  if  (  attributes  .  get  (  tag  )  .  contains  (  key  )  )  {  [ATTENTION]  if  (  attributes  .  containsKey  (  tag  )  )  {  Map<AttributeKey  ,  Set<Protocol>>  attrProts  =  protocols  .  get  (  tag  )  ;    return  !attrProts  .  containsKey  (  key  )  ||  testValidProtocol  (  el  ,  attr  ,  attrProts  .  get  (  key  )  )  ;  }  else  {  //  attribute  found  ,  no  protocols  defined  ,  so  OK  return  true  ;  }  }  }  else  {  //  no  attributes  defined  for  tag  ,  try  :all  tag  return  !tagName  .  equals  (   ":all "  )  &&  isSafeAttribute  (   ":all "  ,  el  ,  attr  )  ;  }  return  false  ;  }    [METHOD]  isSafeAttribute  [TYPE]  boolean  [PARAMETER]  String  tagName  Element  el  Attribute  attr  [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [TYPE]  AttributeKey  key  [TYPE]  Set  attributeSet  currentSet  protSet  tagNames  [TYPE]  boolean  false  true  [TYPE]  TagName  tag  [TYPE]  Attribute  attr  [TYPE]  Element  el  [TYPE]  String  key  protocol  tag  tagName  value  [TYPE]  Map  attrMap  attrProts  attributes  enforcedAttributes  protocols  
[REPLACE]  return  true;	[BUGGY]  return  false  ;  [NO-ERROR]  [CONTEXT]  boolean  isSafeAttribute  (  String  tagName  ,  Element  el  ,  Attribute  attr  )  {  TagName  tag  =  TagName  .  valueOf  (  tagName  )  ;  AttributeKey  key  =  AttributeKey  .  valueOf  (  attr  .  getKey  (  )  )  ;    if  (  attributes  .  containsKey  (  tag  )  )  {  if  (  attributes  .  get  (  tag  )  .  contains  (  key  )  )  {  if  (  protocols  .  containsKey  (  tag  )  )  {  Map<AttributeKey  ,  Set<Protocol>>  attrProts  =  protocols  .  get  (  tag  )  ;    return  !attrProts  .  containsKey  (  key  )  ||  testValidProtocol  (  el  ,  attr  ,  attrProts  .  get  (  key  )  )  ;  }  else  {  //  attribute  found  ,  no  protocols  defined  ,  so  OK  [ATTENTION]  return  false  ;  }  }  }  else  {  //  no  attributes  defined  for  tag  ,  try  :all  tag  return  !tagName  .  equals  (   ":all "  )  &&  isSafeAttribute  (   ":all "  ,  el  ,  attr  )  ;  }  return  false  ;  }    [METHOD]  isSafeAttribute  [TYPE]  boolean  [PARAMETER]  String  tagName  Element  el  Attribute  attr  [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [TYPE]  AttributeKey  key  [TYPE]  Set  attributeSet  currentSet  protSet  tagNames  [TYPE]  boolean  false  true  [TYPE]  TagName  tag  [TYPE]  Attribute  attr  [TYPE]  Element  el  [TYPE]  String  key  protocol  tag  tagName  value  [TYPE]  Map  attrMap  attrProts  attributes  enforcedAttributes  protocols  
[REPLACE]  return  !attrProts  .  containsKey  (  key  )  ||  testValidProtocol  (  el,  attr,  attrProts  .  get  (  key  )  )  ;	[BUGGY]  return  !attrProts  .  containsKey  (  key  )    ;  [FE]  AssertionFailedError    expected:<...ollow ">Dodgy</a>  <a  [href  =   "http://nice.com "  ]rel  =   "nofollow ">Nice<...>  but  was:<...ollow ">Dodgy</a>  <a  []rel  =   "nofollow ">Nice<...>  assertEquals( "<p><a  rel  =  \ "nofollow\ ">Dodgy</a>  <a  href  =  \ "http://nice.com\ "  rel  =  \ "nofollow\ ">Nice</a></p><blockquote>Hello</blockquote> "  ,  [CONTEXT]  boolean  isSafeAttribute  (  String  tagName  ,  Element  el  ,  Attribute  attr  )  {  TagName  tag  =  TagName  .  valueOf  (  tagName  )  ;  AttributeKey  key  =  AttributeKey  .  valueOf  (  attr  .  getKey  (  )  )  ;    if  (  attributes  .  containsKey  (  tag  )  )  {  if  (  attributes  .  get  (  tag  )  .  contains  (  key  )  )  {  if  (  protocols  .  containsKey  (  tag  )  )  {  Map<AttributeKey  ,  Set<Protocol>>  attrProts  =  protocols  .  get  (  tag  )  ;    [ATTENTION]  return  !attrProts  .  containsKey  (  key  )  ;  }  else  {  //  attribute  found  ,  no  protocols  defined  ,  so  OK  return  true  ;  }  }  }  else  {  //  no  attributes  defined  for  tag  ,  try  :all  tag  return  !tagName  .  equals  (   ":all "  )  &&  isSafeAttribute  (   ":all "  ,  el  ,  attr  )  ;  }  return  false  ;  }    [METHOD]  isSafeAttribute  [TYPE]  boolean  [PARAMETER]  String  tagName  Element  el  Attribute  attr  [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [TYPE]  AttributeKey  key  [TYPE]  Set  attributeSet  currentSet  protSet  tagNames  [TYPE]  boolean  false  true  [TYPE]  TagName  tag  [TYPE]  Attribute  attr  [TYPE]  Element  el  [TYPE]  String  key  protocol  tag  tagName  value  [TYPE]  Map  attrMap  attrProts  attributes  enforcedAttributes  protocols  
[REPLACE]  Map<AttributeKey,  Set<Protocol>>  attrProts  =  protocols  .  get  (  tag  )  ;	[BUGGY]  Map<AttributeKey  ,  Set<Protocol>>  attrProts  =  protocols  .  containsKey  (  tag  )  ;  [CE]  incompatible  types  [CONTEXT]  boolean  isSafeAttribute  (  String  tagName  ,  Element  el  ,  Attribute  attr  )  {  TagName  tag  =  TagName  .  valueOf  (  tagName  )  ;  AttributeKey  key  =  AttributeKey  .  valueOf  (  attr  .  getKey  (  )  )  ;    if  (  attributes  .  containsKey  (  tag  )  )  {  if  (  attributes  .  get  (  tag  )  .  contains  (  key  )  )  {  if  (  protocols  .  containsKey  (  tag  )  )  {  [ATTENTION]  Map<AttributeKey  ,  Set<Protocol>>  attrProts  =  protocols  .  containsKey  (  tag  )    ;    return  !attrProts  .  containsKey  (  key  )  ||  testValidProtocol  (  el  ,  attr  ,  attrProts  .  get  (  key  )  )  ;  }  else  {  //  attribute  found  ,  no  protocols  defined  ,  so  OK  return  true  ;  }  }  }  else  {  //  no  attributes  defined  for  tag  ,  try  :all  tag  return  !tagName  .  equals  (   ":all "  )  &&  isSafeAttribute  (   ":all "  ,  el  ,  attr  )  ;  }  return  false  ;  }    [METHOD]  isSafeAttribute  [TYPE]  boolean  [PARAMETER]  String  tagName  Element  el  Attribute  attr  [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [TYPE]  AttributeKey  key  [TYPE]  Set  attributeSet  currentSet  protSet  tagNames  [TYPE]  boolean  false  true  [TYPE]  TagName  tag  [TYPE]  Attribute  attr  [TYPE]  Element  el  [TYPE]  String  key  protocol  tag  tagName  value  [TYPE]  Map  attrMap  attrProts  attributes  enforcedAttributes  protocols  
[ADD]  Map<AttributeKey,  Set<Protocol>>  attrProts  =  protocols  .  get  (  tag  )  ;	[BUGGY]  [CE]  cannot  find  symbol  attrProts  [CONTEXT]  boolean  isSafeAttribute  (  String  tagName  ,  Element  el  ,  Attribute  attr  )  {  TagName  tag  =  TagName  .  valueOf  (  tagName  )  ;  AttributeKey  key  =  AttributeKey  .  valueOf  (  attr  .  getKey  (  )  )  ;    if  (  attributes  .  containsKey  (  tag  )  )  {  if  (  attributes  .  get  (  tag  )  .  contains  (  key  )  )  {  if  (  protocols  .  containsKey  (  tag  )  )  {  [ATTENTION]    return  !attrProts  .  containsKey  (  key  )  ||  testValidProtocol  (  el  ,  attr  ,  attrProts  .  get  (  key  )  )  ;  }  else  {  //  attribute  found  ,  no  protocols  defined  ,  so  OK  return  true  ;  }  }  }  else  {  //  no  attributes  defined  for  tag  ,  try  :all  tag  return  !tagName  .  equals  (   ":all "  )  &&  isSafeAttribute  (   ":all "  ,  el  ,  attr  )  ;  }  return  false  ;  }    [METHOD]  isSafeAttribute  [TYPE]  boolean  [PARAMETER]  String  tagName  Element  el  Attribute  attr  [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [TYPE]  AttributeKey  key  [TYPE]  Set  attributeSet  currentSet  protSet  tagNames  [TYPE]  boolean  false  true  [TYPE]  TagName  tag  [TYPE]  Attribute  attr  [TYPE]  Element  el  [TYPE]  String  key  protocol  tag  tagName  value  [TYPE]  Map  attrMap  attrProts  attributes  enforcedAttributes  protocols  
[REPLACE]  return  !attrProts  .  containsKey  (  key  )  ||  testValidProtocol  (  el,  attr,  attrProts  .  get  (  key  )  )  ;	[BUGGY]  return  !attrProts  .  get  (  key  )  &&  testValidProtocol  (  el  ,  attr  ,  attrProts  .  get  (  key  )  )  ;  [CE]  bad  operand  type  Set<Protocol>  for  unary  operator  '!'  [CONTEXT]  boolean  isSafeAttribute  (  String  tagName  ,  Element  el  ,  Attribute  attr  )  {  TagName  tag  =  TagName  .  valueOf  (  tagName  )  ;  AttributeKey  key  =  AttributeKey  .  valueOf  (  attr  .  getKey  (  )  )  ;    if  (  attributes  .  containsKey  (  tag  )  )  {  if  (  attributes  .  get  (  tag  )  .  contains  (  key  )  )  {  if  (  protocols  .  containsKey  (  tag  )  )  {  Map<AttributeKey  ,  Set<Protocol>>  attrProts  =  protocols  .  get  (  tag  )  ;    [ATTENTION]  return  !attrProts  .  get  (  key  )  &&  testValidProtocol  (  el  ,  attr  ,  attrProts  .  get  (  key  )  )    ;  }  else  {  //  attribute  found  ,  no  protocols  defined  ,  so  OK  return  true  ;  }  }  }  else  {  //  no  attributes  defined  for  tag  ,  try  :all  tag  return  !tagName  .  equals  (   ":all "  )  &&  isSafeAttribute  (   ":all "  ,  el  ,  attr  )  ;  }  return  false  ;  }    [METHOD]  isSafeAttribute  [TYPE]  boolean  [PARAMETER]  String  tagName  Element  el  Attribute  attr  [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [TYPE]  AttributeKey  key  [TYPE]  Set  attributeSet  currentSet  protSet  tagNames  [TYPE]  boolean  false  true  [TYPE]  TagName  tag  [TYPE]  Attribute  attr  [TYPE]  Element  el  [TYPE]  String  key  protocol  tag  tagName  value  [TYPE]  Map  attrMap  attrProts  attributes  enforcedAttributes  protocols  
[REPLACE]  Map<AttributeKey,  Set<Protocol>>  attrProts  =  protocols  .  get  (  tag  )  ;	[BUGGY]  Map<AttributeKey  ,  Set<Protocol>>  attrProts  =  protocols  .  put  (  null  ,  1  )    ;  [CE]  method  put  in  interface  Map<K  ,  V>  cannot  be  applied  to  given  types  ;  [CONTEXT]  boolean  isSafeAttribute  (  String  tagName  ,  Element  el  ,  Attribute  attr  )  {  TagName  tag  =  TagName  .  valueOf  (  tagName  )  ;  AttributeKey  key  =  AttributeKey  .  valueOf  (  attr  .  getKey  (  )  )  ;    if  (  attributes  .  containsKey  (  tag  )  )  {  if  (  attributes  .  get  (  tag  )  .  contains  (  key  )  )  {  if  (  protocols  .  containsKey  (  tag  )  )  {  [ATTENTION]  Map<AttributeKey  ,  Set<Protocol>>  attrProts  =  protocols  .  put  (  null  ,  1  )  ;    return  !attrProts  .  containsKey  (  key  )  ||  testValidProtocol  (  el  ,  attr  ,  attrProts  .  get  (  key  )  )  ;  }  else  {  //  attribute  found  ,  no  protocols  defined  ,  so  OK  return  true  ;  }  }  }  else  {  //  no  attributes  defined  for  tag  ,  try  :all  tag  return  !tagName  .  equals  (   ":all "  )  &&  isSafeAttribute  (   ":all "  ,  el  ,  attr  )  ;  }  return  false  ;  }    [METHOD]  isSafeAttribute  [TYPE]  boolean  [PARAMETER]  String  tagName  Element  el  Attribute  attr  [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [TYPE]  AttributeKey  key  [TYPE]  Set  attributeSet  currentSet  protSet  tagNames  [TYPE]  boolean  false  true  [TYPE]  TagName  tag  [TYPE]  Attribute  attr  [TYPE]  Element  el  [TYPE]  String  key  protocol  tag  tagName  value  [TYPE]  Map  attrMap  attrProts  attributes  enforcedAttributes  protocols  
[REPLACE]  return  !attrProts  .  containsKey  (  key  )  ||  testValidProtocol  (  el,  attr,  attrProts  .  get  (  key  )  )  ;	[BUGGY]  return  !attrProts  .  get  (  key  )  ||  testValidProtocol  (  el  ,  attr  ,  attrProts  .  get  (  key  )  )  ;  [CE]  bad  operand  type  Set<Protocol>  for  unary  operator  '!'  [CONTEXT]  boolean  isSafeAttribute  (  String  tagName  ,  Element  el  ,  Attribute  attr  )  {  TagName  tag  =  TagName  .  valueOf  (  tagName  )  ;  AttributeKey  key  =  AttributeKey  .  valueOf  (  attr  .  getKey  (  )  )  ;    if  (  attributes  .  containsKey  (  tag  )  )  {  if  (  attributes  .  get  (  tag  )  .  contains  (  key  )  )  {  if  (  protocols  .  containsKey  (  tag  )  )  {  Map<AttributeKey  ,  Set<Protocol>>  attrProts  =  protocols  .  get  (  tag  )  ;    [ATTENTION]  return  !attrProts  .  get  (  key  )  ||  testValidProtocol  (  el  ,  attr  ,  attrProts  .  get  (  key  )  )    ;  }  else  {  //  attribute  found  ,  no  protocols  defined  ,  so  OK  return  true  ;  }  }  }  else  {  //  no  attributes  defined  for  tag  ,  try  :all  tag  return  !tagName  .  equals  (   ":all "  )  &&  isSafeAttribute  (   ":all "  ,  el  ,  attr  )  ;  }  return  false  ;  }    [METHOD]  isSafeAttribute  [TYPE]  boolean  [PARAMETER]  String  tagName  Element  el  Attribute  attr  [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [TYPE]  AttributeKey  key  [TYPE]  Set  attributeSet  currentSet  protSet  tagNames  [TYPE]  boolean  false  true  [TYPE]  TagName  tag  [TYPE]  Attribute  attr  [TYPE]  Element  el  [TYPE]  String  key  protocol  tag  tagName  value  [TYPE]  Map  attrMap  attrProts  attributes  enforcedAttributes  protocols  
[REPLACE]  return  !attrProts  .  containsKey  (  key  )  ||  testValidProtocol  (  el,  attr,  attrProts  .  get  (  key  )  )  ;	[BUGGY]  return  !attrProts  .  entrySet  (  )    ||  testValidProtocol  (  el  ,  attr  ,  attrProts  .  get  (  key  )  )  ;  [CE]  bad  operand  type  Set<Entry<AttributeKey  ,  Set<Protocol>>>  for  unary  operator  '!'  [CONTEXT]  boolean  isSafeAttribute  (  String  tagName  ,  Element  el  ,  Attribute  attr  )  {  TagName  tag  =  TagName  .  valueOf  (  tagName  )  ;  AttributeKey  key  =  AttributeKey  .  valueOf  (  attr  .  getKey  (  )  )  ;    if  (  attributes  .  containsKey  (  tag  )  )  {  if  (  attributes  .  get  (  tag  )  .  contains  (  key  )  )  {  if  (  protocols  .  containsKey  (  tag  )  )  {  Map<AttributeKey  ,  Set<Protocol>>  attrProts  =  protocols  .  get  (  tag  )  ;    [ATTENTION]  return  !attrProts  .  entrySet  (  )  ||  testValidProtocol  (  el  ,  attr  ,  attrProts  .  get  (  key  )  )    ;  }  else  {  //  attribute  found  ,  no  protocols  defined  ,  so  OK  return  true  ;  }  }  }  else  {  //  no  attributes  defined  for  tag  ,  try  :all  tag  return  !tagName  .  equals  (   ":all "  )  &&  isSafeAttribute  (   ":all "  ,  el  ,  attr  )  ;  }  return  false  ;  }    [METHOD]  isSafeAttribute  [TYPE]  boolean  [PARAMETER]  String  tagName  Element  el  Attribute  attr  [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [TYPE]  AttributeKey  key  [TYPE]  Set  attributeSet  currentSet  protSet  tagNames  [TYPE]  boolean  false  true  [TYPE]  TagName  tag  [TYPE]  Attribute  attr  [TYPE]  Element  el  [TYPE]  String  key  protocol  tag  tagName  value  [TYPE]  Map  attrMap  attrProts  attributes  enforcedAttributes  protocols  
[REPLACE]  if  (  attributes  .  get  (  tag  )    .  contains  (  key  )  )  {	[BUGGY]  if  (  value  .  toString  (  )  .  toLowerCase  (  )  .  startsWith  (  prot  )  )  {[CE]  cannot  find  symbol  prot  [CONTEXT]  boolean  isSafeAttribute  (  String  tagName  ,  Element  el  ,  Attribute  attr  )  {  TagName  tag  =  TagName  .  valueOf  (  tagName  )  ;  AttributeKey  key  =  AttributeKey  .  valueOf  (  attr  .  getKey  (  )  )  ;    if  (  attributes  .  containsKey  (  tag  )  )  {  [ATTENTION]  if  (  value  .  toString  (  )    .  toLowerCase  (  )    .  startsWith  (  prot  )  )  {  if  (  protocols  .  containsKey  (  tag  )  )  {  Map<AttributeKey  ,  Set<Protocol>>  attrProts  =  protocols  .  get  (  tag  )  ;    return  !attrProts  .  containsKey  (  key  )  ||  testValidProtocol  (  el  ,  attr  ,  attrProts  .  get  (  key  )  )  ;  }  else  {  //  attribute  found  ,  no  protocols  defined  ,  so  OK  return  true  ;  }  }  }  else  {  //  no  attributes  defined  for  tag  ,  try  :all  tag  return  !tagName  .  equals  (   ":all "  )  &&  isSafeAttribute  (   ":all "  ,  el  ,  attr  )  ;  }  return  false  ;  }    [METHOD]  isSafeAttribute  [TYPE]  boolean  [PARAMETER]  String  tagName  Element  el  Attribute  attr  [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [TYPE]  AttributeKey  key  [TYPE]  Set  attributeSet  currentSet  protSet  tagNames  [TYPE]  boolean  false  true  [TYPE]  TagName  tag  [TYPE]  Attribute  attr  [TYPE]  Element  el  [TYPE]  String  key  protocol  tag  tagName  value  [TYPE]  Map  attrMap  attrProts  attributes  enforcedAttributes  protocols  
[ADD]  if  (  protocols  .  containsKey  (  tag  )  )  {  Map<AttributeKey,  Set<Protocol>>  attrProts  =  protocols  .  get  (  tag  )  ;  return  !attrProts  .  containsKey  (  key  )  ||  testValidProtocol  (  el,  attr,  attrProts  .  get  (  key  )  )  ;	[BUGGY]  [CE]  illegal  start  of  type  [CONTEXT]  boolean  isSafeAttribute  (  String  tagName  ,  Element  el  ,  Attribute  attr  )  {  TagName  tag  =  TagName  .  valueOf  (  tagName  )  ;  AttributeKey  key  =  AttributeKey  .  valueOf  (  attr  .  getKey  (  )  )  ;    if  (  attributes  .  containsKey  (  tag  )  )  {  if  (  attributes  .  get  (  tag  )  .  contains  (  key  )  )  {  [ATTENTION]      }  else  {  //  attribute  found  ,  no  protocols  defined  ,  so  OK  return  true  ;  }  }  }  else  {  //  no  attributes  defined  for  tag  ,  try  :all  tag  return  !tagName  .  equals  (   ":all "  )  &&  isSafeAttribute  (   ":all "  ,  el  ,  attr  )  ;  }  return  false  ;  }    [METHOD]  isSafeAttribute  [TYPE]  boolean  [PARAMETER]  String  tagName  Element  el  Attribute  attr  [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [TYPE]  AttributeKey  key  [TYPE]  Set  attributeSet  currentSet  protSet  tagNames  [TYPE]  boolean  false  true  [TYPE]  TagName  tag  [TYPE]  Attribute  attr  [TYPE]  Element  el  [TYPE]  String  key  protocol  tag  tagName  value  [TYPE]  Map  attrMap  attrProts  attributes  enforcedAttributes  protocols  
[REPLACE]  return  !attrProts  .  containsKey  (  key  )  ||  testValidProtocol  (  el,  attr,  attrProts  .  get  (  key  )  )  ;	[BUGGY]  return    testValidProtocol  (  el  ,  attr  ,  attrProts  .  get  (  key  )  )  ;  [FE]  null  assertEquals( "<img  alt  =  \ "\ "  /> "  ,  cleanHtml)  ;  [CONTEXT]  boolean  isSafeAttribute  (  String  tagName  ,  Element  el  ,  Attribute  attr  )  {  TagName  tag  =  TagName  .  valueOf  (  tagName  )  ;  AttributeKey  key  =  AttributeKey  .  valueOf  (  attr  .  getKey  (  )  )  ;    if  (  attributes  .  containsKey  (  tag  )  )  {  if  (  attributes  .  get  (  tag  )  .  contains  (  key  )  )  {  if  (  protocols  .  containsKey  (  tag  )  )  {  Map<AttributeKey  ,  Set<Protocol>>  attrProts  =  protocols  .  get  (  tag  )  ;    [ATTENTION]  return  testValidProtocol  (  el  ,  attr  ,  attrProts  .  get  (  key  )  )    ;  }  else  {  //  attribute  found  ,  no  protocols  defined  ,  so  OK  return  true  ;  }  }  }  else  {  //  no  attributes  defined  for  tag  ,  try  :all  tag  return  !tagName  .  equals  (   ":all "  )  &&  isSafeAttribute  (   ":all "  ,  el  ,  attr  )  ;  }  return  false  ;  }    [METHOD]  isSafeAttribute  [TYPE]  boolean  [PARAMETER]  String  tagName  Element  el  Attribute  attr  [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [TYPE]  AttributeKey  key  [TYPE]  Set  attributeSet  currentSet  protSet  tagNames  [TYPE]  boolean  false  true  [TYPE]  TagName  tag  [TYPE]  Attribute  attr  [TYPE]  Element  el  [TYPE]  String  key  protocol  tag  tagName  value  [TYPE]  Map  attrMap  attrProts  attributes  enforcedAttributes  protocols  
[REPLACE]  return  !attrProts  .  containsKey  (  key  )  ||  testValidProtocol  (  el,  attr,  attrProts  .  get  (  key  )  )  ;	[BUGGY]  return  attrProts  .  containsKey  (  key  )    ;  [FE]  AssertionFailedError    expected:<<img  [alt  =   "] "  />>  but  was:<<img  [src  =   "unknown  =  assertEquals( "<img  alt  =  \ "\ "  /> "  ,  cleanHtml)  ;  [CONTEXT]  boolean  isSafeAttribute  (  String  tagName  ,  Element  el  ,  Attribute  attr  )  {  TagName  tag  =  TagName  .  valueOf  (  tagName  )  ;  AttributeKey  key  =  AttributeKey  .  valueOf  (  attr  .  getKey  (  )  )  ;    if  (  attributes  .  containsKey  (  tag  )  )  {  if  (  attributes  .  get  (  tag  )  .  contains  (  key  )  )  {  if  (  protocols  .  containsKey  (  tag  )  )  {  Map<AttributeKey  ,  Set<Protocol>>  attrProts  =  protocols  .  get  (  tag  )  ;    [ATTENTION]  return  attrProts  .  containsKey  (  key  )  ;  }  else  {  //  attribute  found  ,  no  protocols  defined  ,  so  OK  return  true  ;  }  }  }  else  {  //  no  attributes  defined  for  tag  ,  try  :all  tag  return  !tagName  .  equals  (   ":all "  )  &&  isSafeAttribute  (   ":all "  ,  el  ,  attr  )  ;  }  return  false  ;  }    [METHOD]  isSafeAttribute  [TYPE]  boolean  [PARAMETER]  String  tagName  Element  el  Attribute  attr  [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [TYPE]  AttributeKey  key  [TYPE]  Set  attributeSet  currentSet  protSet  tagNames  [TYPE]  boolean  false  true  [TYPE]  TagName  tag  [TYPE]  Attribute  attr  [TYPE]  Element  el  [TYPE]  String  key  protocol  tag  tagName  value  [TYPE]  Map  attrMap  attrProts  attributes  enforcedAttributes  protocols  
[ADD]  if  (  protocols  .  containsKey  (  tag  )  )  {  Map<AttributeKey,  Set<Protocol>>  attrProts  =  protocols  .  get  (  tag  )  ;  return  !attrProts  .  containsKey  (  key  )  ||  testValidProtocol  (  el,  attr,  attrProts  .  get  (  key  )  )  ;	[BUGGY]  Map<AttributeKey  ,  Set<Protocol>>  attrProts  =  protocols  .  get  (  tag  )  ;  return  !attrProts  .  containsKey  (  key  )  ||  testValidProtocol  (  el  ,  attr  ,  attrProts  .  get  (  key  )  )  ;  [CE]  illegal  start  of  type  [CONTEXT]  boolean  isSafeAttribute  (  String  tagName  ,  Element  el  ,  Attribute  attr  )  {  TagName  tag  =  TagName  .  valueOf  (  tagName  )  ;  AttributeKey  key  =  AttributeKey  .  valueOf  (  attr  .  getKey  (  )  )  ;    if  (  attributes  .  containsKey  (  tag  )  )  {  if  (  attributes  .  get  (  tag  )  .  contains  (  key  )  )  {  [ATTENTION]  Map<AttributeKey  ,  Set<Protocol>>  attrProts  =  protocols  .  get  (  tag  )    ;  return  !attrProts  .  containsKey  (  key  )  ||  testValidProtocol  (  el  ,  attr  ,  attrProts  .  get  (  key  )  )    ;      }  else  {  //  attribute  found  ,  no  protocols  defined  ,  so  OK  return  true  ;  }  }  }  else  {  //  no  attributes  defined  for  tag  ,  try  :all  tag  return  !tagName  .  equals  (   ":all "  )  &&  isSafeAttribute  (   ":all "  ,  el  ,  attr  )  ;  }  return  false  ;  }    [METHOD]  isSafeAttribute  [TYPE]  boolean  [PARAMETER]  String  tagName  Element  el  Attribute  attr  [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [TYPE]  AttributeKey  key  [TYPE]  Set  attributeSet  currentSet  protSet  tagNames  [TYPE]  boolean  false  true  [TYPE]  TagName  tag  [TYPE]  Attribute  attr  [TYPE]  Element  el  [TYPE]  String  key  protocol  tag  tagName  value  [TYPE]  Map  attrMap  attrProts  attributes  enforcedAttributes  protocols  
[REPLACE]  return  !tagName  .  equals  (   ":all "  )  &&  isSafeAttribute  (   ":all ",  el,  attr  )  ;	[BUGGY]  return  !tagName  .  toLowerCase  (  )    &&  isSafeAttribute  (   ":all "  ,  el  ,  attr  )  ;  [CE]  bad  operand  type  String  for  unary  operator  [CONTEXT]  boolean  isSafeAttribute  (  String  tagName  ,  Element  el  ,  Attribute  attr  )  {  TagName  tag  =  TagName  .  valueOf  (  tagName  )  ;  AttributeKey  key  =  AttributeKey  .  valueOf  (  attr  .  getKey  (  )  )  ;    if  (  attributes  .  containsKey  (  tag  )  )  {  if  (  attributes  .  get  (  tag  )  .  contains  (  key  )  )  {  if  (  protocols  .  containsKey  (  tag  )  )  {  Map<AttributeKey  ,  Set<Protocol>>  attrProts  =  protocols  .  get  (  tag  )  ;    return  !attrProts  .  containsKey  (  key  )  ||  testValidProtocol  (  el  ,  attr  ,  attrProts  .  get  (  key  )  )  ;  }  else  {  //  attribute  found  ,  no  protocols  defined  ,  so  OK  return  true  ;  }  }  }  else  {  //  no  attributes  defined  for  tag  ,  try  :all  tag  [ATTENTION]  return  !tagName  .  toLowerCase  (  )  &&  isSafeAttribute  (   ":all "  ,  el  ,  attr  )    ;  }  return  false  ;  }    [METHOD]  isSafeAttribute  [TYPE]  boolean  [PARAMETER]  String  tagName  Element  el  Attribute  attr  [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [TYPE]  AttributeKey  key  [TYPE]  Set  attributeSet  currentSet  protSet  tagNames  [TYPE]  boolean  false  true  [TYPE]  TagName  tag  [TYPE]  Attribute  attr  [TYPE]  Element  el  [TYPE]  String  key  protocol  tag  tagName  value  [TYPE]  Map  attrMap  attrProts  attributes  enforcedAttributes  protocols  
[REPLACE]  return  false;	[BUGGY]  return  true  ;  [NO-ERROR]  [CONTEXT]  boolean  isSafeAttribute  (  String  tagName  ,  Element  el  ,  Attribute  attr  )  {  TagName  tag  =  TagName  .  valueOf  (  tagName  )  ;  AttributeKey  key  =  AttributeKey  .  valueOf  (  attr  .  getKey  (  )  )  ;    if  (  attributes  .  containsKey  (  tag  )  )  {  if  (  attributes  .  get  (  tag  )  .  contains  (  key  )  )  {  if  (  protocols  .  containsKey  (  tag  )  )  {  Map<AttributeKey  ,  Set<Protocol>>  attrProts  =  protocols  .  get  (  tag  )  ;    return  !attrProts  .  containsKey  (  key  )  ||  testValidProtocol  (  el  ,  attr  ,  attrProts  .  get  (  key  )  )  ;  }  else  {  //  attribute  found  ,  no  protocols  defined  ,  so  OK  return  true  ;  }  }  }  else  {  //  no  attributes  defined  for  tag  ,  try  :all  tag  return  !tagName  .  equals  (   ":all "  )  &&  isSafeAttribute  (   ":all "  ,  el  ,  attr  )  ;  }  [ATTENTION]  return  true  ;  }    [METHOD]  isSafeAttribute  [TYPE]  boolean  [PARAMETER]  String  tagName  Element  el  Attribute  attr  [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [TYPE]  AttributeKey  key  [TYPE]  Set  attributeSet  currentSet  protSet  tagNames  [TYPE]  boolean  false  true  [TYPE]  TagName  tag  [TYPE]  Attribute  attr  [TYPE]  Element  el  [TYPE]  String  key  protocol  tag  tagName  value  [TYPE]  Map  attrMap  attrProts  attributes  enforcedAttributes  protocols  
[REPLACE]  String  value  =  el  .  absUrl  (  attr  .  getKey  (  )  )  ;	[BUGGY]  String  value  =  el  .  absUrl  (  attr  .  setValue  (  protocol  )    )  ;  [CE]  cannot  find  symbol  protocol  [CONTEXT]  private  boolean  testValidProtocol  (  Element  el  ,  Attribute  attr  ,  Set<Protocol>  protocols  )  {      [ATTENTION]  String  value  =  el  .  absUrl  (  attr  .  setValue  (  protocol  )    )    ;  attr  .  setValue  (  value  )  ;    for  (  Protocol  protocol  :  protocols  )  {  String  prot  =  protocol  .  toString  (  )  +   ": "  ;  if  (  value  .  toString  (  )  .  toLowerCase  (  )  .  startsWith  (  prot  )  )  {  return  true  ;  }  }  return  false  ;  }    [METHOD]  testValidProtocol  [TYPE]  boolean  [PARAMETER]  Element  el  Attribute  attr  Protocol>  protocols  [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [TYPE]  Set  attributeSet  currentSet  protSet  protocols  tagNames  [TYPE]  boolean  false  true  [TYPE]  Attribute  attr  [TYPE]  Element  el  [TYPE]  String  key  prot  protocol  tag  tagName  value  [TYPE]  Protocol  protocol  [TYPE]  Map  attrMap  attrProts  attributes  enforcedAttributes  protocols  
[ADD]  String  value  =  el  .  absUrl  (  attr  .  getKey  (  )  )  ;  attr  .  setValue  (  value  )  ;	[BUGGY]  [CE]  cannot  find  symbol  value  [CONTEXT]  private  boolean  testValidProtocol  (  Element  el  ,  Attribute  attr  ,  Set<Protocol>  protocols  )  {      [ATTENTION]    for  (  Protocol  protocol  :  protocols  )  {  String  prot  =  protocol  .  toString  (  )  +   ": "  ;  if  (  value  .  toString  (  )  .  toLowerCase  (  )  .  startsWith  (  prot  )  )  {  return  true  ;  }  }  return  false  ;  }    [METHOD]  testValidProtocol  [TYPE]  boolean  [PARAMETER]  Element  el  Attribute  attr  Protocol>  protocols  [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [TYPE]  Set  attributeSet  currentSet  protSet  protocols  tagNames  [TYPE]  boolean  false  true  [TYPE]  Attribute  attr  [TYPE]  Element  el  [TYPE]  String  key  prot  protocol  tag  tagName  value  [TYPE]  Protocol  protocol  [TYPE]  Map  attrMap  attrProts  attributes  enforcedAttributes  protocols  
[REPLACE]  attr  .  setValue  (  value  )  ;	[BUGGY]  attr  .  getKey  (  )    ;  [FE]  AssertionFailedError    expected:<...>Dodgy</a>  <a  href  =   "[http]://nice.com "  rel  =   "no...>  but  was:<...>Dodgy</a>  <a  href  =   "[HTTP]://nice.com "  rel  =   "no...>  assertEquals( "<p><a  rel  =  \ "nofollow\ ">Dodgy</a>  <a  href  =  \ "http://nice.com\ "  rel  =  \ "nofollow\ ">Nice</a></p><blockquote>Hello</blockquote> "  ,  [CONTEXT]  private  boolean  testValidProtocol  (  Element  el  ,  Attribute  attr  ,  Set<Protocol>  protocols  )  {      String  value  =  el  .  absUrl  (  attr  .  getKey  (  )  )  ;  [ATTENTION]  attr  .  getKey  (  )  ;    for  (  Protocol  protocol  :  protocols  )  {  String  prot  =  protocol  .  toString  (  )  +   ": "  ;  if  (  value  .  toString  (  )  .  toLowerCase  (  )  .  startsWith  (  prot  )  )  {  return  true  ;  }  }  return  false  ;  }    [METHOD]  testValidProtocol  [TYPE]  boolean  [PARAMETER]  Element  el  Attribute  attr  Protocol>  protocols  [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [TYPE]  Set  attributeSet  currentSet  protSet  protocols  tagNames  [TYPE]  boolean  false  true  [TYPE]  Attribute  attr  [TYPE]  Element  el  [TYPE]  String  key  prot  protocol  tag  tagName  value  [TYPE]  Protocol  protocol  [TYPE]  Map  attrMap  attrProts  attributes  enforcedAttributes  protocols  
[REPLACE]  if  (  value  .  toString  (  )    .  toLowerCase  (  )    .  startsWith  (  prot  )  )  {	[BUGGY]  if  (  value  .  TypedValue  (  key  )    .  toLowerCase  (  )  .  startsWith  (  protocol  )  )  {[CE]  cannot  find  symbol  key  [CONTEXT]  private  boolean  testValidProtocol  (  Element  el  ,  Attribute  attr  ,  Set<Protocol>  protocols  )  {      String  value  =  el  .  absUrl  (  attr  .  getKey  (  )  )  ;  attr  .  setValue  (  value  )  ;    for  (  Protocol  protocol  :  protocols  )  {  String  prot  =  protocol  .  toString  (  )  +   ": "  ;  [ATTENTION]  if  (  value  .  TypedValue  (  key  )  .  toLowerCase  (  )    .  startsWith  (  protocol  )  )  {  return  true  ;  }  }  return  false  ;  }    [METHOD]  testValidProtocol  [TYPE]  boolean  [PARAMETER]  Element  el  Attribute  attr  Protocol>  protocols  [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [TYPE]  Set  attributeSet  currentSet  protSet  protocols  tagNames  [TYPE]  boolean  false  true  [TYPE]  Attribute  attr  [TYPE]  Element  el  [TYPE]  String  key  prot  protocol  tag  tagName  value  [TYPE]  Protocol  protocol  [TYPE]  Map  attrMap  attrProts  attributes  enforcedAttributes  protocols  
[REPLACE]  return  true;	[BUGGY]  return  false  ;  [FE]  AssertionFailedError    expected:<...ollow ">Dodgy</a>  <a  [href  =   "http://nice.com "  ]rel  =   "nofollow ">Nice<...>  but  was:<...ollow ">Dodgy</a>  <a  []rel  =   "nofollow ">Nice<...>  assertEquals( "<p><a  rel  =  \ "nofollow\ ">Dodgy</a>  <a  href  =  \ "http://nice.com\ "  rel  =  \ "nofollow\ ">Nice</a></p><blockquote>Hello</blockquote> "  ,  [CONTEXT]  private  boolean  testValidProtocol  (  Element  el  ,  Attribute  attr  ,  Set<Protocol>  protocols  )  {      String  value  =  el  .  absUrl  (  attr  .  getKey  (  )  )  ;  attr  .  setValue  (  value  )  ;    for  (  Protocol  protocol  :  protocols  )  {  String  prot  =  protocol  .  toString  (  )  +   ": "  ;  if  (  value  .  toString  (  )  .  toLowerCase  (  )  .  startsWith  (  prot  )  )  {  [ATTENTION]  return  false  ;  }  }  return  false  ;  }    [METHOD]  testValidProtocol  [TYPE]  boolean  [PARAMETER]  Element  el  Attribute  attr  Protocol>  protocols  [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [TYPE]  Set  attributeSet  currentSet  protSet  protocols  tagNames  [TYPE]  boolean  false  true  [TYPE]  Attribute  attr  [TYPE]  Element  el  [TYPE]  String  key  prot  protocol  tag  tagName  value  [TYPE]  Protocol  protocol  [TYPE]  Map  attrMap  attrProts  attributes  enforcedAttributes  protocols  
[REPLACE]  for  (  Protocol  protocol  :  protocols  )  {	[BUGGY]  for  (  Protocol  protocol  :  protocols  )  {  String  prot  =  protocol  .  toString  (  )  +   ": "  ;  [CE]  variable  prot  is  already  defined  in  method  testValidProtocol(Element  ,  Attribute  ,  Set<Protocol>)  [CONTEXT]  private  boolean  testValidProtocol  (  Element  el  ,  Attribute  attr  ,  Set<Protocol>  protocols  )  {      String  value  =  el  .  absUrl  (  attr  .  getKey  (  )  )  ;  attr  .  setValue  (  value  )  ;    [ATTENTION]  for  (  Protocol  protocol  :  protocols  )  {  String  prot  =  protocol  .  toString  (  )  +   ": "  ;  String  prot  =  protocol  .  toString  (  )  +   ": "  ;  if  (  value  .  toString  (  )  .  toLowerCase  (  )  .  startsWith  (  prot  )  )  {  return  true  ;  }  }  return  false  ;  }    [METHOD]  testValidProtocol  [TYPE]  boolean  [PARAMETER]  Element  el  Attribute  attr  Protocol>  protocols  [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [TYPE]  Set  attributeSet  currentSet  protSet  protocols  tagNames  [TYPE]  boolean  false  true  [TYPE]  Attribute  attr  [TYPE]  Element  el  [TYPE]  String  key  prot  protocol  tag  tagName  value  [TYPE]  Protocol  protocol  [TYPE]  Map  attrMap  attrProts  attributes  enforcedAttributes  protocols  
[REPLACE]  String  prot  =  protocol  .  toString  (  )  +   ": ";	[BUGGY]  String  prot  =  value  (  )  +   ": "  ;  [CE]  cannot  find  symbol  [CONTEXT]  private  boolean  testValidProtocol  (  Element  el  ,  Attribute  attr  ,  Set<Protocol>  protocols  )  {      String  value  =  el  .  absUrl  (  attr  .  getKey  (  )  )  ;  attr  .  setValue  (  value  )  ;    for  (  Protocol  protocol  :  protocols  )  {  [ATTENTION]  String  prot  =  value  (  )  +   ": "  ;  if  (  value  .  toString  (  )  .  toLowerCase  (  )  .  startsWith  (  prot  )  )  {  return  true  ;  }  }  return  false  ;  }    [METHOD]  testValidProtocol  [TYPE]  boolean  [PARAMETER]  Element  el  Attribute  attr  Protocol>  protocols  [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [TYPE]  Set  attributeSet  currentSet  protSet  protocols  tagNames  [TYPE]  boolean  false  true  [TYPE]  Attribute  attr  [TYPE]  Element  el  [TYPE]  String  key  prot  protocol  tag  tagName  value  [TYPE]  Protocol  protocol  [TYPE]  Map  attrMap  attrProts  attributes  enforcedAttributes  protocols  
[REPLACE]  return  false;	[BUGGY]  return  true  ;  [FE]  AssertionFailedError    expected:<<img  alt  =   " "  []/>>  but  was:<<img  alt  =   " "  [src  =   " "  ]/>>  assertEquals( "<img  alt  =  \ "\ "  /> "  ,  cleanHtml)  ;  [CONTEXT]  private  boolean  testValidProtocol  (  Element  el  ,  Attribute  attr  ,  Set<Protocol>  protocols  )  {      String  value  =  el  .  absUrl  (  attr  .  getKey  (  )  )  ;  attr  .  setValue  (  value  )  ;    for  (  Protocol  protocol  :  protocols  )  {  String  prot  =  protocol  .  toString  (  )  +   ": "  ;  if  (  value  .  toString  (  )  .  toLowerCase  (  )  .  startsWith  (  prot  )  )  {  return  true  ;  }  }  [ATTENTION]  return  true  ;  }    [METHOD]  testValidProtocol  [TYPE]  boolean  [PARAMETER]  Element  el  Attribute  attr  Protocol>  protocols  [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [TYPE]  Set  attributeSet  currentSet  protSet  protocols  tagNames  [TYPE]  boolean  false  true  [TYPE]  Attribute  attr  [TYPE]  Element  el  [TYPE]  String  key  prot  protocol  tag  tagName  value  [TYPE]  Protocol  protocol  [TYPE]  Map  attrMap  attrProts  attributes  enforcedAttributes  protocols  
[REPLACE]  Attributes  attrs  =  new  Attributes  (  )  ;	[BUGGY]  AttributeKey  attrKey  =  AttributeKey  .  valueOf  (  key  )  ;  [CE]  cannot  find  symbol  key  [CONTEXT]  Attributes  getEnforcedAttributes  (  String  tagName  )  {  [ATTENTION]  AttributeKey  attrKey  =  AttributeKey  .  valueOf  (  key  )    ;  TagName  tag  =  TagName  .  valueOf  (  tagName  )  ;  if  (  enforcedAttributes  .  containsKey  (  tag  )  )  {  Map<AttributeKey  ,  AttributeValue>  keyVals  =  enforcedAttributes  .  get  (  tag  )  ;  for  (  Map  .  Entry<AttributeKey  ,  AttributeValue>  entry  :  keyVals  .  entrySet  (  )  )  {  attrs  .  put  (  entry  .  getKey  (  )  .  toString  (  )  ,  entry  .  getValue  (  )  .  toString  (  )  )  ;  }  }  return  attrs  ;  }    [METHOD]  getEnforcedAttributes  [TYPE]  Attributes  [PARAMETER]  String  tagName  [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [TYPE]  Entry  entry  [TYPE]  Set  attributeSet  currentSet  protSet  protocols  tagNames  [TYPE]  boolean  false  true  [TYPE]  TagName  tag  [TYPE]  Attributes  attrs  [TYPE]  String  key  prot  protocol  tag  tagName  value  [TYPE]  Map  attrMap  attrProts  attributes  enforcedAttributes  keyVals  protocols  
[REPLACE]  TagName  tag  =  TagName  .  valueOf  (  tagName  )  ;	[BUGGY]  TagName  tag  =  TagName  .  valueOf  (  value  )  ;  [CE]  cannot  find  symbol  value  [CONTEXT]  Attributes  getEnforcedAttributes  (  String  tagName  )  {  Attributes  attrs  =  new  Attributes  (  )  ;  [ATTENTION]  TagName  tag  =  TagName  .  valueOf  (  value  )    ;  if  (  enforcedAttributes  .  containsKey  (  tag  )  )  {  Map<AttributeKey  ,  AttributeValue>  keyVals  =  enforcedAttributes  .  get  (  tag  )  ;  for  (  Map  .  Entry<AttributeKey  ,  AttributeValue>  entry  :  keyVals  .  entrySet  (  )  )  {  attrs  .  put  (  entry  .  getKey  (  )  .  toString  (  )  ,  entry  .  getValue  (  )  .  toString  (  )  )  ;  }  }  return  attrs  ;  }    [METHOD]  getEnforcedAttributes  [TYPE]  Attributes  [PARAMETER]  String  tagName  [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [TYPE]  Entry  entry  [TYPE]  Set  attributeSet  currentSet  protSet  protocols  tagNames  [TYPE]  boolean  false  true  [TYPE]  TagName  tag  [TYPE]  Attributes  attrs  [TYPE]  String  key  prot  protocol  tag  tagName  value  [TYPE]  Map  attrMap  attrProts  attributes  enforcedAttributes  keyVals  protocols  
[ADD]  TagName  tag  =  TagName  .  valueOf  (  tagName  )  ;	[BUGGY]  [CE]  cannot  find  symbol  tag  [CONTEXT]  Attributes  getEnforcedAttributes  (  String  tagName  )  {  Attributes  attrs  =  new  Attributes  (  )  ;  [ATTENTION]  if  (  enforcedAttributes  .  containsKey  (  tag  )  )  {  Map<AttributeKey  ,  AttributeValue>  keyVals  =  enforcedAttributes  .  get  (  tag  )  ;  for  (  Map  .  Entry<AttributeKey  ,  AttributeValue>  entry  :  keyVals  .  entrySet  (  )  )  {  attrs  .  put  (  entry  .  getKey  (  )  .  toString  (  )  ,  entry  .  getValue  (  )  .  toString  (  )  )  ;  }  }  return  attrs  ;  }    [METHOD]  getEnforcedAttributes  [TYPE]  Attributes  [PARAMETER]  String  tagName  [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [TYPE]  Entry  entry  [TYPE]  Set  attributeSet  currentSet  protSet  protocols  tagNames  [TYPE]  boolean  false  true  [TYPE]  TagName  tag  [TYPE]  Attributes  attrs  [TYPE]  String  key  prot  protocol  tag  tagName  value  [TYPE]  Map  attrMap  attrProts  attributes  enforcedAttributes  keyVals  protocols  
[REPLACE]  if  (  enforcedAttributes  .  containsKey  (  tag  )  )  {	[BUGGY]  if  (  enforcedAttributes  .  containsKey  (  tagName  )  )  {[FE]  AssertionFailedError    expected:<<p><a[  rel  =   "nofollow ">Dodgy</a>  <a  href  =   "http://nice.com "  rel  =   "nofollow] ">Nice</a></p><block...>  but  was:<<p><a[>Dodgy</a>  <a  href  =   "http://nice.com] ">Nice</a></p><block...>  assertEquals( "<p><a  rel  =  \ "nofollow\ ">Dodgy</a>  <a  href  =  \ "http://nice.com\ "  rel  =  \ "nofollow\ ">Nice</a></p><blockquote>Hello</blockquote> "  ,  [CONTEXT]  Attributes  getEnforcedAttributes  (  String  tagName  )  {  Attributes  attrs  =  new  Attributes  (  )  ;  TagName  tag  =  TagName  .  valueOf  (  tagName  )  ;  [ATTENTION]  if  (  enforcedAttributes  .  containsKey  (  tagName  )  )  {  Map<AttributeKey  ,  AttributeValue>  keyVals  =  enforcedAttributes  .  get  (  tag  )  ;  for  (  Map  .  Entry<AttributeKey  ,  AttributeValue>  entry  :  keyVals  .  entrySet  (  )  )  {  attrs  .  put  (  entry  .  getKey  (  )  .  toString  (  )  ,  entry  .  getValue  (  )  .  toString  (  )  )  ;  }  }  return  attrs  ;  }    [METHOD]  getEnforcedAttributes  [TYPE]  Attributes  [PARAMETER]  String  tagName  [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [TYPE]  Entry  entry  [TYPE]  Set  attributeSet  currentSet  protSet  protocols  tagNames  [TYPE]  boolean  false  true  [TYPE]  TagName  tag  [TYPE]  Attributes  attrs  [TYPE]  String  key  prot  protocol  tag  tagName  value  [TYPE]  Map  attrMap  attrProts  attributes  enforcedAttributes  keyVals  protocols  
[REPLACE]  Map<AttributeKey,  AttributeValue>  keyVals  =  enforcedAttributes  .  get  (  tag  )  ;	[BUGGY]  Map<AttributeKey  ,  AttributeValue>  keyVals  =  enforcedAttributes  .  containsKey  (  tag  )  ;  [CE]  incompatible  types  [CONTEXT]  Attributes  getEnforcedAttributes  (  String  tagName  )  {  Attributes  attrs  =  new  Attributes  (  )  ;  TagName  tag  =  TagName  .  valueOf  (  tagName  )  ;  if  (  enforcedAttributes  .  containsKey  (  tag  )  )  {  [ATTENTION]  Map<AttributeKey  ,  AttributeValue>  keyVals  =  enforcedAttributes  .  containsKey  (  tag  )    ;  for  (  Map  .  Entry<AttributeKey  ,  AttributeValue>  entry  :  keyVals  .  entrySet  (  )  )  {  attrs  .  put  (  entry  .  getKey  (  )  .  toString  (  )  ,  entry  .  getValue  (  )  .  toString  (  )  )  ;  }  }  return  attrs  ;  }    [METHOD]  getEnforcedAttributes  [TYPE]  Attributes  [PARAMETER]  String  tagName  [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [TYPE]  Entry  entry  [TYPE]  Set  attributeSet  currentSet  protSet  protocols  tagNames  [TYPE]  boolean  false  true  [TYPE]  TagName  tag  [TYPE]  Attributes  attrs  [TYPE]  String  key  prot  protocol  tag  tagName  value  [TYPE]  Map  attrMap  attrProts  attributes  enforcedAttributes  keyVals  protocols  
[REPLACE]  for  (  Map  .  Entry<AttributeKey,  AttributeValue>  entry  :  keyVals  .  entrySet  (  )  )  {	[BUGGY]  AttributeKey  attrKey  =  AttributeKey  .  valueOf  (  key  )  ;  [CE]  illegal  start  of  type  [CONTEXT]  Attributes  getEnforcedAttributes  (  String  tagName  )  {  Attributes  attrs  =  new  Attributes  (  )  ;  TagName  tag  =  TagName  .  valueOf  (  tagName  )  ;  if  (  enforcedAttributes  .  containsKey  (  tag  )  )  {  Map<AttributeKey  ,  AttributeValue>  keyVals  =  enforcedAttributes  .  get  (  tag  )  ;  [ATTENTION]  AttributeKey  attrKey  =  AttributeKey  .  valueOf  (  key  )    ;  attrs  .  put  (  entry  .  getKey  (  )  .  toString  (  )  ,  entry  .  getValue  (  )  .  toString  (  )  )  ;  }  }  return  attrs  ;  }    [METHOD]  getEnforcedAttributes  [TYPE]  Attributes  [PARAMETER]  String  tagName  [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [TYPE]  Entry  entry  [TYPE]  Set  attributeSet  currentSet  protSet  protocols  tagNames  [TYPE]  boolean  false  true  [TYPE]  TagName  tag  [TYPE]  Attributes  attrs  [TYPE]  String  key  prot  protocol  tag  tagName  value  [TYPE]  Map  attrMap  attrProts  attributes  enforcedAttributes  keyVals  protocols  
[REPLACE]  Map<AttributeKey,  AttributeValue>  keyVals  =  enforcedAttributes  .  get  (  tag  )  ;	[BUGGY]  Map<AttributeKey  ,  AttributeValue>  keyVals  =  enforcedAttributes  .  put  (  null  ,  false  )    ;  [CE]  method  put  in  interface  Map<K  ,  V>  cannot  be  applied  to  given  types  ;  [CONTEXT]  Attributes  getEnforcedAttributes  (  String  tagName  )  {  Attributes  attrs  =  new  Attributes  (  )  ;  TagName  tag  =  TagName  .  valueOf  (  tagName  )  ;  if  (  enforcedAttributes  .  containsKey  (  tag  )  )  {  [ATTENTION]  Map<AttributeKey  ,  AttributeValue>  keyVals  =  enforcedAttributes  .  put  (  null  ,  false  )  ;  for  (  Map  .  Entry<AttributeKey  ,  AttributeValue>  entry  :  keyVals  .  entrySet  (  )  )  {  attrs  .  put  (  entry  .  getKey  (  )  .  toString  (  )  ,  entry  .  getValue  (  )  .  toString  (  )  )  ;  }  }  return  attrs  ;  }    [METHOD]  getEnforcedAttributes  [TYPE]  Attributes  [PARAMETER]  String  tagName  [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [TYPE]  Entry  entry  [TYPE]  Set  attributeSet  currentSet  protSet  protocols  tagNames  [TYPE]  boolean  false  true  [TYPE]  TagName  tag  [TYPE]  Attributes  attrs  [TYPE]  String  key  prot  protocol  tag  tagName  value  [TYPE]  Map  attrMap  attrProts  attributes  enforcedAttributes  keyVals  protocols  
[REPLACE]  return  attrs;	[BUGGY]  return  new  AttributeValue  (  value  )  ;  [CE]  cannot  find  symbol  value  [CONTEXT]  Attributes  getEnforcedAttributes  (  String  tagName  )  {  Attributes  attrs  =  new  Attributes  (  )  ;  TagName  tag  =  TagName  .  valueOf  (  tagName  )  ;  if  (  enforcedAttributes  .  containsKey  (  tag  )  )  {  Map<AttributeKey  ,  AttributeValue>  keyVals  =  enforcedAttributes  .  get  (  tag  )  ;  for  (  Map  .  Entry<AttributeKey  ,  AttributeValue>  entry  :  keyVals  .  entrySet  (  )  )  {  attrs  .  put  (  entry  .  getKey  (  )  .  toString  (  )  ,  entry  .  getValue  (  )  .  toString  (  )  )  ;  }  }  [ATTENTION]  return  new  AttributeValue  (  value  )    ;  }    [METHOD]  getEnforcedAttributes  [TYPE]  Attributes  [PARAMETER]  String  tagName  [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [TYPE]  Entry  entry  [TYPE]  Set  attributeSet  currentSet  protSet  protocols  tagNames  [TYPE]  boolean  false  true  [TYPE]  TagName  tag  [TYPE]  Attributes  attrs  [TYPE]  String  key  prot  protocol  tag  tagName  value  [TYPE]  Map  attrMap  attrProts  attributes  enforcedAttributes  keyVals  protocols  
[REPLACE]  return  new  TagName  (  value  )  ;	[BUGGY]  return  new  AttributeKey  (  tagName  )    ;  [CE]  cannot  find  symbol  tagName  [CONTEXT]  static  TagName  valueOf  (  String  value  )  {  [ATTENTION]  returnnew  AttributeKey  (  tagName  )  ;  }    [METHOD]  valueOf  [TYPE]  Whitelist$TagName  [PARAMETER]  String  value  [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [TYPE]  Set  attributeSet  currentSet  protSet  protocols  tagNames  [TYPE]  String  key  prot  protocol  tag  tagName  value  [TYPE]  boolean  false  true  [TYPE]  Map  attrMap  attrProts  attributes  enforcedAttributes  keyVals  protocols  
[REPLACE]  return  new  AttributeKey  (  value  )  ;	[BUGGY]  return  new  TagName  (  value  )    ;  [CE]  incompatible  types  [CONTEXT]  static  AttributeKey  valueOf  (  String  value  )  {  [ATTENTION]  returnnew  TagName  (  value  )  ;  }    [METHOD]  valueOf  [TYPE]  Whitelist$AttributeKey  [PARAMETER]  String  value  [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [TYPE]  Set  attributeSet  currentSet  protSet  protocols  tagNames  [TYPE]  String  key  prot  protocol  tag  tagName  value  [TYPE]  boolean  false  true  [TYPE]  Map  attrMap  attrProts  attributes  enforcedAttributes  keyVals  protocols  
[REPLACE]  return  new  AttributeValue  (  value  )  ;	[BUGGY]  return  new  AttributeKey  (  value  )  ;  [CE]  incompatible  types  [CONTEXT]  static  AttributeValue  valueOf  (  String  value  )  {  [ATTENTION]  return  new  AttributeKey  (  value  )    ;  }    [METHOD]  valueOf  [TYPE]  Whitelist$AttributeValue  [PARAMETER]  String  value  [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [TYPE]  Set  attributeSet  currentSet  protSet  protocols  tagNames  [TYPE]  String  key  prot  protocol  tag  tagName  value  [TYPE]  boolean  false  true  [TYPE]  Map  attrMap  attrProts  attributes  enforcedAttributes  keyVals  protocols  
[REPLACE]  return  new  Protocol  (  value  )  ;	[BUGGY]  return  new  TagName  (  value  )    ;  [CE]  incompatible  types  [CONTEXT]  static  Protocol  valueOf  (  String  value  )  {  [ATTENTION]  returnnew  TagName  (  value  )  ;  }    [METHOD]  valueOf  [TYPE]  Whitelist$Protocol  [PARAMETER]  String  value  [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [TYPE]  Set  attributeSet  currentSet  protSet  protocols  tagNames  [TYPE]  String  key  prot  protocol  tag  tagName  value  [TYPE]  boolean  false  true  [TYPE]  Map  attrMap  attrProts  attributes  enforcedAttributes  keyVals  protocols  
[REPLACE]  final  int  prime  =  31;	[BUGGY]  final  int  prime  =  30  ;  [NO-ERROR]  [CONTEXT]  public  int  hashCode  (  )  {  [ATTENTION]  final  int  prime  =  30  ;  int  result  =  1  ;  result  =  prime  *  result  +  (  (  value  =  =  null  )  ?  0  :  value  .  hashCode  (  )  )  ;  return  result  ;  }    [METHOD]  hashCode  [TYPE]  int  [PARAMETER]  [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [TYPE]  Set  attributeSet  currentSet  protSet  protocols  tagNames  [TYPE]  String  key  prot  protocol  tag  tagName  value  [TYPE]  boolean  false  true  [TYPE]  Map  attrMap  attrProts  attributes  enforcedAttributes  keyVals  protocols  [TYPE]  int  prime  result  
[REPLACE]  int  result  =  1;	[BUGGY]  int  result  =  3  ;  [NO-ERROR]  [CONTEXT]  public  int  hashCode  (  )  {  final  int  prime  =  31  ;  [ATTENTION]  int  result  =  3  ;  result  =  prime  *  result  +  (  (  value  =  =  null  )  ?  0  :  value  .  hashCode  (  )  )  ;  return  result  ;  }    [METHOD]  hashCode  [TYPE]  int  [PARAMETER]  [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [TYPE]  Set  attributeSet  currentSet  protSet  protocols  tagNames  [TYPE]  String  key  prot  protocol  tag  tagName  value  [TYPE]  boolean  false  true  [TYPE]  Map  attrMap  attrProts  attributes  enforcedAttributes  keyVals  protocols  [TYPE]  int  prime  result  
[REPLACE]  result  =  prime  *  result  +  (  (  value  ==  null  )  ?  0  :  value  .  hashCode  (  )  )  ;	[BUGGY]  result    =    0  ;  [NO-ERROR]  [CONTEXT]  public  int  hashCode  (  )  {  final  int  prime  =  31  ;  int  result  =  1  ;  [ATTENTION]  result  =  0  ;  return  result  ;  }    [METHOD]  hashCode  [TYPE]  int  [PARAMETER]  [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [TYPE]  Set  attributeSet  currentSet  protSet  protocols  tagNames  [TYPE]  String  key  prot  protocol  tag  tagName  value  [TYPE]  boolean  false  true  [TYPE]  Map  attrMap  attrProts  attributes  enforcedAttributes  keyVals  protocols  [TYPE]  int  prime  result  
[REPLACE]  return  result;	[BUGGY]  return  new  Protocol  (  value  )  ;  [CE]  incompatible  types  [CONTEXT]  public  int  hashCode  (  )  {  final  int  prime  =  31  ;  int  result  =  1  ;  result  =  prime  *  result  +  (  (  value  =  =  null  )  ?  0  :  value  .  hashCode  (  )  )  ;  [ATTENTION]  return  new  Protocol  (  value  )    ;  }    [METHOD]  hashCode  [TYPE]  int  [PARAMETER]  [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [TYPE]  Set  attributeSet  currentSet  protSet  protocols  tagNames  [TYPE]  String  key  prot  protocol  tag  tagName  value  [TYPE]  boolean  false  true  [TYPE]  Map  attrMap  attrProts  attributes  enforcedAttributes  keyVals  protocols  [TYPE]  int  prime  result  
[REPLACE]  if  (  this  ==  obj  )  return  true;	[BUGGY]  if  (  this  &&  obj  )  return  false  ;  [CE]  bad  operand  types  for  binary  operator  '&&'  [CONTEXT]  public  boolean  equals  (  Object  obj  )  {  [ATTENTION]  if  (  this&&obj  )  return  false  ;  if  (  obj  =  =  null  )  return  false  ;  if  (  getClass  (  )  !  =  obj  .  getClass  (  )  )  return  false  ;  TypedValue  other  =    (  TypedValue  )  obj  ;  if  (  value  =  =  null  )  {  if  (  other  .  value  !  =  null  )  return  false  ;  }  else  if  (  !value  .  equals  (  other  .  value  )  )  return  false  ;  return  true  ;  }    [METHOD]  equals  [TYPE]  boolean  [PARAMETER]  Object  obj  [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [TYPE]  Object  obj  [TYPE]  Set  attributeSet  currentSet  protSet  protocols  tagNames  [TYPE]  String  key  prot  protocol  tag  tagName  value  [TYPE]  boolean  false  true  [TYPE]  Map  attrMap  attrProts  attributes  enforcedAttributes  keyVals  protocols  [TYPE]  TypedValue  other  
[REPLACE]  if  (  this  ==  obj  )  return  true;	[BUGGY]  if  (  this  =  =  obj  )  return  false  ;  [NO-ERROR]  [CONTEXT]  public  boolean  equals  (  Object  obj  )  {  [ATTENTION]  if  (  this  =  =  obj  )  return  false  ;  if  (  obj  =  =  null  )  return  false  ;  if  (  getClass  (  )  !  =  obj  .  getClass  (  )  )  return  false  ;  TypedValue  other  =    (  TypedValue  )  obj  ;  if  (  value  =  =  null  )  {  if  (  other  .  value  !  =  null  )  return  false  ;  }  else  if  (  !value  .  equals  (  other  .  value  )  )  return  false  ;  return  true  ;  }    [METHOD]  equals  [TYPE]  boolean  [PARAMETER]  Object  obj  [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [TYPE]  Object  obj  [TYPE]  Set  attributeSet  currentSet  protSet  protocols  tagNames  [TYPE]  String  key  prot  protocol  tag  tagName  value  [TYPE]  boolean  false  true  [TYPE]  Map  attrMap  attrProts  attributes  enforcedAttributes  keyVals  protocols  [TYPE]  TypedValue  other  
[REPLACE]  if  (  obj  ==  null  )  return  false;	[BUGGY]  if  (  obj  !  =  null  )  return  false  ;  [FE]  AssertionFailedError    expected:<[<img  alt  =   " "  />]>  but  was:<[]>  assertEquals( "<img  alt  =  \ "\ "  /> "  ,  cleanHtml)  ;  [CONTEXT]  public  boolean  equals  (  Object  obj  )  {  if  (  this  =  =  obj  )  return  true  ;  [ATTENTION]  if  (  obj  !  =  null  )  return  false  ;  if  (  getClass  (  )  !  =  obj  .  getClass  (  )  )  return  false  ;  TypedValue  other  =    (  TypedValue  )  obj  ;  if  (  value  =  =  null  )  {  if  (  other  .  value  !  =  null  )  return  false  ;  }  else  if  (  !value  .  equals  (  other  .  value  )  )  return  false  ;  return  true  ;  }    [METHOD]  equals  [TYPE]  boolean  [PARAMETER]  Object  obj  [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [TYPE]  Object  obj  [TYPE]  Set  attributeSet  currentSet  protSet  protocols  tagNames  [TYPE]  String  key  prot  protocol  tag  tagName  value  [TYPE]  boolean  false  true  [TYPE]  Map  attrMap  attrProts  attributes  enforcedAttributes  keyVals  protocols  [TYPE]  TypedValue  other  
[ADD]  if  (  obj  ==  null  )  return  false;  if  (  getClass  (  )  !=  obj  .  getClass  (  )  )  return  false;  TypedValue  other  =  (  TypedValue  )  obj;  if  (  value  ==  null  )  {  if  (  other  .  value  !=  null  )  return  false;	[BUGGY]  [CE]  illegal  start  of  type  [CONTEXT]  public  boolean  equals  (  Object  obj  )  {  if  (  this  =  =  obj  )  return  true  ;  [ATTENTION]      }  else  if  (  !value  .  equals  (  other  .  value  )  )  return  false  ;  return  true  ;  }    [METHOD]  equals  [TYPE]  boolean  [PARAMETER]  Object  obj  [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [TYPE]  Object  obj  [TYPE]  Set  attributeSet  currentSet  protSet  protocols  tagNames  [TYPE]  String  key  prot  protocol  tag  tagName  value  [TYPE]  boolean  false  true  [TYPE]  Map  attrMap  attrProts  attributes  enforcedAttributes  keyVals  protocols  [TYPE]  TypedValue  other  
[REPLACE]  if  (  obj  ==  null  )  return  false;	[BUGGY]  if  (  obj  =  =  null  )  return  true  ;  [NO-ERROR]  [CONTEXT]  public  boolean  equals  (  Object  obj  )  {  if  (  this  =  =  obj  )  return  true  ;  [ATTENTION]  if  (  obj  =  =  null  )  return  true  ;  if  (  getClass  (  )  !  =  obj  .  getClass  (  )  )  return  false  ;  TypedValue  other  =    (  TypedValue  )  obj  ;  if  (  value  =  =  null  )  {  if  (  other  .  value  !  =  null  )  return  false  ;  }  else  if  (  !value  .  equals  (  other  .  value  )  )  return  false  ;  return  true  ;  }    [METHOD]  equals  [TYPE]  boolean  [PARAMETER]  Object  obj  [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [TYPE]  Object  obj  [TYPE]  Set  attributeSet  currentSet  protSet  protocols  tagNames  [TYPE]  String  key  prot  protocol  tag  tagName  value  [TYPE]  boolean  false  true  [TYPE]  Map  attrMap  attrProts  attributes  enforcedAttributes  keyVals  protocols  [TYPE]  TypedValue  other  
[REPLACE]  if  (  getClass  (  )  !=  obj  .  getClass  (  )  )  return  false;	[BUGGY]  if  (  0  (  )    =  =    obj  .  getClass  (  )  )  return  false  ;  [CE]  ')'  expected  [CONTEXT]  public  boolean  equals  (  Object  obj  )  {  if  (  this  =  =  obj  )  return  true  ;  if  (  obj  =  =  null  )  return  false  ;  [ATTENTION]  if  (  0  (  )    =  =  obj  .  getClass  (  )  )  return  false  ;  TypedValue  other  =    (  TypedValue  )  obj  ;  if  (  value  =  =  null  )  {  if  (  other  .  value  !  =  null  )  return  false  ;  }  else  if  (  !value  .  equals  (  other  .  value  )  )  return  false  ;  return  true  ;  }    [METHOD]  equals  [TYPE]  boolean  [PARAMETER]  Object  obj  [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [TYPE]  Object  obj  [TYPE]  Set  attributeSet  currentSet  protSet  protocols  tagNames  [TYPE]  String  key  prot  protocol  tag  tagName  value  [TYPE]  boolean  false  true  [TYPE]  Map  attrMap  attrProts  attributes  enforcedAttributes  keyVals  protocols  [TYPE]  TypedValue  other  
[REPLACE]  if  (  getClass  (  )  !=  obj  .  getClass  (  )  )  return  false;	[BUGGY]  if  (  getClass  (  )  !  =  obj  .  getClass  (  )  )  return  true  ;  [NO-ERROR]  [CONTEXT]  public  boolean  equals  (  Object  obj  )  {  if  (  this  =  =  obj  )  return  true  ;  if  (  obj  =  =  null  )  return  false  ;  [ATTENTION]  if  (  getClass  (  )  !  =  obj  .  getClass  (  )  )  return  true  ;  TypedValue  other  =    (  TypedValue  )  obj  ;  if  (  value  =  =  null  )  {  if  (  other  .  value  !  =  null  )  return  false  ;  }  else  if  (  !value  .  equals  (  other  .  value  )  )  return  false  ;  return  true  ;  }    [METHOD]  equals  [TYPE]  boolean  [PARAMETER]  Object  obj  [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [TYPE]  Object  obj  [TYPE]  Set  attributeSet  currentSet  protSet  protocols  tagNames  [TYPE]  String  key  prot  protocol  tag  tagName  value  [TYPE]  boolean  false  true  [TYPE]  Map  attrMap  attrProts  attributes  enforcedAttributes  keyVals  protocols  [TYPE]  TypedValue  other  
[REPLACE]  TypedValue  other  =  (  TypedValue  )  obj;	[BUGGY]  AttributeValue  attrVal  =  AttributeValue  .  valueOf  (  value  )  ;  [CE]  cannot  find  symbol  other  [CONTEXT]  public  boolean  equals  (  Object  obj  )  {  if  (  this  =  =  obj  )  return  true  ;  if  (  obj  =  =  null  )  return  false  ;  if  (  getClass  (  )  !  =  obj  .  getClass  (  )  )  return  false  ;  [ATTENTION]  AttributeValue  attrVal  =  AttributeValue  .  valueOf  (  value  )    ;  if  (  value  =  =  null  )  {  if  (  other  .  value  !  =  null  )  return  false  ;  }  else  if  (  !value  .  equals  (  other  .  value  )  )  return  false  ;  return  true  ;  }    [METHOD]  equals  [TYPE]  boolean  [PARAMETER]  Object  obj  [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [TYPE]  Object  obj  [TYPE]  Set  attributeSet  currentSet  protSet  protocols  tagNames  [TYPE]  String  key  prot  protocol  tag  tagName  value  [TYPE]  boolean  false  true  [TYPE]  Map  attrMap  attrProts  attributes  enforcedAttributes  keyVals  protocols  [TYPE]  TypedValue  other  
[REPLACE]  if  (  value  ==  null  )  {	[BUGGY]  if  (tagName  !  =  null  )  {[CE]  cannot  find  symbol  tagName  [CONTEXT]  public  boolean  equals  (  Object  obj  )  {  if  (  this  =  =  obj  )  return  true  ;  if  (  obj  =  =  null  )  return  false  ;  if  (  getClass  (  )  !  =  obj  .  getClass  (  )  )  return  false  ;  TypedValue  other  =    (  TypedValue  )  obj  ;  [ATTENTION]  if  (  tagName  !  =  null  )  {  if  (  other  .  value  !  =  null  )  return  false  ;  }  else  if  (  !value  .  equals  (  other  .  value  )  )  return  false  ;  return  true  ;  }    [METHOD]  equals  [TYPE]  boolean  [PARAMETER]  Object  obj  [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [TYPE]  Object  obj  [TYPE]  Set  attributeSet  currentSet  protSet  protocols  tagNames  [TYPE]  String  key  prot  protocol  tag  tagName  value  [TYPE]  boolean  false  true  [TYPE]  Map  attrMap  attrProts  attributes  enforcedAttributes  keyVals  protocols  [TYPE]  TypedValue  other  
[REPLACE]  }  else  if  (  !value  .  equals  (  other  .  value  )  )  return  false;	[BUGGY]    if  (  !value  .  equals  (  other  .  value  )  )  return  true  ;  [NO-ERROR]  [CONTEXT]  public  boolean  equals  (  Object  obj  )  {  if  (  this  =  =  obj  )  return  true  ;  if  (  obj  =  =  null  )  return  false  ;  if  (  getClass  (  )  !  =  obj  .  getClass  (  )  )  return  false  ;  TypedValue  other  =    (  TypedValue  )  obj  ;  if  (  value  =  =  null  )  {  if  (  other  .  value  !  =  null  )  return  false  ;  [ATTENTION]  }if  (  !value  .  equals  (  other  .  value  )  )  return  true  ;  return  true  ;  }    [METHOD]  equals  [TYPE]  boolean  [PARAMETER]  Object  obj  [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [TYPE]  Object  obj  [TYPE]  Set  attributeSet  currentSet  protSet  protocols  tagNames  [TYPE]  String  key  prot  protocol  tag  tagName  value  [TYPE]  boolean  false  true  [TYPE]  Map  attrMap  attrProts  attributes  enforcedAttributes  keyVals  protocols  [TYPE]  TypedValue  other  
[REPLACE]  }  else  if  (  !value  .  equals  (  other  .  value  )  )  return  false;	[BUGGY]  else  if  (  !value  .  equals  (  other  .  value  )  )  return  true  ;  [NO-ERROR]  [CONTEXT]  public  boolean  equals  (  Object  obj  )  {  if  (  this  =  =  obj  )  return  true  ;  if  (  obj  =  =  null  )  return  false  ;  if  (  getClass  (  )  !  =  obj  .  getClass  (  )  )  return  false  ;  TypedValue  other  =    (  TypedValue  )  obj  ;  if  (  value  =  =  null  )  {  if  (  other  .  value  !  =  null  )  return  false  ;  [ATTENTION]  }  else  if  (  !value  .  equals  (  other  .  value  )  )  return  true  ;  return  true  ;  }    [METHOD]  equals  [TYPE]  boolean  [PARAMETER]  Object  obj  [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [TYPE]  Object  obj  [TYPE]  Set  attributeSet  currentSet  protSet  protocols  tagNames  [TYPE]  String  key  prot  protocol  tag  tagName  value  [TYPE]  boolean  false  true  [TYPE]  Map  attrMap  attrProts  attributes  enforcedAttributes  keyVals  protocols  [TYPE]  TypedValue  other  
[REPLACE]  if  (  other  .  value  !=  null  )  return  false;	[BUGGY]  if  (  other  .  value  =  =  value  )  return  false  ;  [NO-ERROR]  [CONTEXT]  public  boolean  equals  (  Object  obj  )  {  if  (  this  =  =  obj  )  return  true  ;  if  (  obj  =  =  null  )  return  false  ;  if  (  getClass  (  )  !  =  obj  .  getClass  (  )  )  return  false  ;  TypedValue  other  =    (  TypedValue  )  obj  ;  if  (  value  =  =  null  )  {  [ATTENTION]  if  (  other  .  value  =  =  value  )  return  false  ;  }  else  if  (  !value  .  equals  (  other  .  value  )  )  return  false  ;  return  true  ;  }    [METHOD]  equals  [TYPE]  boolean  [PARAMETER]  Object  obj  [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [TYPE]  Object  obj  [TYPE]  Set  attributeSet  currentSet  protSet  protocols  tagNames  [TYPE]  String  key  prot  protocol  tag  tagName  value  [TYPE]  boolean  false  true  [TYPE]  Map  attrMap  attrProts  attributes  enforcedAttributes  keyVals  protocols  [TYPE]  TypedValue  other  
[REPLACE]  if  (  other  .  value  !=  null  )  return  false;	[BUGGY]  if  (  other  .  value  !  =  null  )  return  true  ;  [NO-ERROR]  [CONTEXT]  public  boolean  equals  (  Object  obj  )  {  if  (  this  =  =  obj  )  return  true  ;  if  (  obj  =  =  null  )  return  false  ;  if  (  getClass  (  )  !  =  obj  .  getClass  (  )  )  return  false  ;  TypedValue  other  =    (  TypedValue  )  obj  ;  if  (  value  =  =  null  )  {  [ATTENTION]  if  (  other  .  value  !  =  null  )  return  true  ;  }  else  if  (  !value  .  equals  (  other  .  value  )  )  return  false  ;  return  true  ;  }    [METHOD]  equals  [TYPE]  boolean  [PARAMETER]  Object  obj  [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [TYPE]  Object  obj  [TYPE]  Set  attributeSet  currentSet  protSet  protocols  tagNames  [TYPE]  String  key  prot  protocol  tag  tagName  value  [TYPE]  boolean  false  true  [TYPE]  Map  attrMap  attrProts  attributes  enforcedAttributes  keyVals  protocols  [TYPE]  TypedValue  other  
[REPLACE]  if  (  other  .  value  !=  null  )  return  false;	[BUGGY]  if  (  other  .  value  =  =  tag  )  return  false  ;  [CE]  cannot  find  symbol  tag  [CONTEXT]  public  boolean  equals  (  Object  obj  )  {  if  (  this  =  =  obj  )  return  true  ;  if  (  obj  =  =  null  )  return  false  ;  if  (  getClass  (  )  !  =  obj  .  getClass  (  )  )  return  false  ;  TypedValue  other  =    (  TypedValue  )  obj  ;  if  (  value  =  =  null  )  {  [ATTENTION]  if  (  other  .  value  =  =  tag  )  return  false  ;  }  else  if  (  !value  .  equals  (  other  .  value  )  )  return  false  ;  return  true  ;  }    [METHOD]  equals  [TYPE]  boolean  [PARAMETER]  Object  obj  [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [TYPE]  Object  obj  [TYPE]  Set  attributeSet  currentSet  protSet  protocols  tagNames  [TYPE]  String  key  prot  protocol  tag  tagName  value  [TYPE]  boolean  false  true  [TYPE]  Map  attrMap  attrProts  attributes  enforcedAttributes  keyVals  protocols  [TYPE]  TypedValue  other  
[ADD]  if  (  other  .  value  !=  null  )  return  false;  }  else  if  (  !value  .  equals  (  other  .  value  )  )  return  false;  return  true;  }	[BUGGY]  [CE]  '  ;  '  expected  [CONTEXT]  public  boolean  equals  (  Object  obj  )  {  if  (  this  =  =  obj  )  return  true  ;  if  (  obj  =  =  null  )  return  false  ;  if  (  getClass  (  )  !  =  obj  .  getClass  (  )  )  return  false  ;  TypedValue  other  =    (  TypedValue  )  obj  ;  if  (  value  =  =  null  )  {  [ATTENTION]        [METHOD]  equals  [TYPE]  boolean  [PARAMETER]  Object  obj  [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [TYPE]  Object  obj  [TYPE]  Set  attributeSet  currentSet  protSet  protocols  tagNames  [TYPE]  String  key  prot  protocol  tag  tagName  value  [TYPE]  boolean  false  true  [TYPE]  Map  attrMap  attrProts  attributes  enforcedAttributes  keyVals  protocols  [TYPE]  TypedValue  other  
[REPLACE]  return  true;	[BUGGY]  return  false  ;  [FE]  AssertionFailedError    expected:<[<img  alt  =   " "  />]>  but  was:<[]>  assertEquals( "<img  alt  =  \ "\ "  /> "  ,  cleanHtml)  ;  [CONTEXT]  public  boolean  equals  (  Object  obj  )  {  if  (  this  =  =  obj  )  return  true  ;  if  (  obj  =  =  null  )  return  false  ;  if  (  getClass  (  )  !  =  obj  .  getClass  (  )  )  return  false  ;  TypedValue  other  =    (  TypedValue  )  obj  ;  if  (  value  =  =  null  )  {  if  (  other  .  value  !  =  null  )  return  false  ;  }  else  if  (  !value  .  equals  (  other  .  value  )  )  return  false  ;  [ATTENTION]  return  false  ;  }    [METHOD]  equals  [TYPE]  boolean  [PARAMETER]  Object  obj  [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [TYPE]  Object  obj  [TYPE]  Set  attributeSet  currentSet  protSet  protocols  tagNames  [TYPE]  String  key  prot  protocol  tag  tagName  value  [TYPE]  boolean  false  true  [TYPE]  Map  attrMap  attrProts  attributes  enforcedAttributes  keyVals  protocols  [TYPE]  TypedValue  other  
[REPLACE]  return  value;	[BUGGY]  return  false  ;  [CE]  incompatible  types  [CONTEXT]  public  String  toString  (  )  {  [ATTENTION]  return  false  ;  }    [METHOD]  toString  [TYPE]  String  [PARAMETER]  [CLASS]  Whitelist  TagName  AttributeKey  AttributeValue  Protocol  TypedValue    [TYPE]  Set  attributeSet  currentSet  protSet  protocols  tagNames  [TYPE]  String  key  prot  protocol  tag  tagName  value  [TYPE]  boolean  false  true  [TYPE]  Map  attrMap  attrProts  attributes  enforcedAttributes  keyVals  protocols  
[ADD]  super  (  value  )  ;	[BUGGY]  [CE]  constructor  TypedValue  in  class  TypedValue  cannot  be  applied  to  given  types  ;  [CONTEXT]  TagName  (  String  value  )  {  [ATTENTION]  }    [METHOD]  <init>  [TYPE]  String)  [PARAMETER]  String  value  [CLASS]  TagName    [TYPE]  boolean  false  true  [TYPE]  String  value  
[REPLACE]  Validate  .  notNull  (  value  )  ;	[BUGGY]  value    ;  [CE]  not  a  statement  [CONTEXT]  TypedValue  (  String  value  )  {  [ATTENTION]  value  ;  this  .  value  =  value  ;  }    [METHOD]  <init>  [TYPE]  String)  [PARAMETER]  String  value  [CLASS]  TypedValue    [TYPE]  String  value  [TYPE]  boolean  false  true  
[ADD]  Validate  .  notNull  (  value  )  ;	[BUGGY]  [NO-ERROR]  [CONTEXT]  TypedValue  (  String  value  )  {  [ATTENTION]  this  .  value  =  value  ;  }    [METHOD]  <init>  [TYPE]  String)  [PARAMETER]  String  value  [CLASS]  TypedValue    [TYPE]  String  value  [TYPE]  boolean  false  true  
[REPLACE]  this  .  value  =  value;	[BUGGY]  this  .  value  =    null  ;  [FE]  The  validated  string  is  empty  assertEquals( "<img  alt  =  \ "\ "  /> "  ,  cleanHtml)  ;  [CONTEXT]  TypedValue  (  String  value  )  {  Validate  .  notNull  (  value  )  ;  [ATTENTION]  this  .  value  =  null  ;  }    [METHOD]  <init>  [TYPE]  String)  [PARAMETER]  String  value  [CLASS]  TypedValue    [TYPE]  String  value  [TYPE]  boolean  false  true  
[ADD]  this  .  value  =  value;	[BUGGY]  [FE]  The  validated  string  is  empty  assertEquals( "<img  alt  =  \ "\ "  /> "  ,  cleanHtml)  ;  [CONTEXT]  TypedValue  (  String  value  )  {  Validate  .  notNull  (  value  )  ;  [ATTENTION]  }    [METHOD]  <init>  [TYPE]  String)  [PARAMETER]  String  value  [CLASS]  TypedValue    [TYPE]  String  value  [TYPE]  boolean  false  true  
[REPLACE]  final  int  prime  =  31;	[BUGGY]  final  int  prime  =  31  >>>  1  ;  [NO-ERROR]  [CONTEXT]  public  int  hashCode  (  )  {  [ATTENTION]  final  int  prime  =  31  >>>  1  ;  int  result  =  1  ;  result  =  prime  *  result  +  (  (  value  =  =  null  )  ?  0  :  value  .  hashCode  (  )  )  ;  return  result  ;  }    [METHOD]  hashCode  [TYPE]  int  [PARAMETER]  [CLASS]  TypedValue    [TYPE]  int  prime  result  [TYPE]  String  value  [TYPE]  boolean  false  true  
[REPLACE]  int  result  =  1;	[BUGGY]  int  result  =  1L  ;  [CE]  possible  loss  of  precision  [CONTEXT]  public  int  hashCode  (  )  {  final  int  prime  =  31  ;  [ATTENTION]  int  result  =  1L  ;  result  =  prime  *  result  +  (  (  value  =  =  null  )  ?  0  :  value  .  hashCode  (  )  )  ;  return  result  ;  }    [METHOD]  hashCode  [TYPE]  int  [PARAMETER]  [CLASS]  TypedValue    [TYPE]  int  prime  result  [TYPE]  String  value  [TYPE]  boolean  false  true  
[REPLACE]  result  =  prime  *  result  +  (  (  value  ==  null  )  ?  0  :  value  .  hashCode  (  )  )  ;	[BUGGY]  result  =  prime  *  result  +  (  (  value  !  =  this  )  ?  0  :  value  .  hashCode  (  )  )  ;  [CE]  incomparable  types:  String  and  TypedValue  [CONTEXT]  public  int  hashCode  (  )  {  final  int  prime  =  31  ;  int  result  =  1  ;  [ATTENTION]  result  =  prime  *  result  +  (  (  value  !  =  this  )  ?  0  :  value  .  hashCode  (  )  )    ;  return  result  ;  }    [METHOD]  hashCode  [TYPE]  int  [PARAMETER]  [CLASS]  TypedValue    [TYPE]  int  prime  result  [TYPE]  String  value  [TYPE]  boolean  false  true  
[REPLACE]  return  result;	[BUGGY]  return  value  ;  [CE]  incompatible  types  [CONTEXT]  public  int  hashCode  (  )  {  final  int  prime  =  31  ;  int  result  =  1  ;  result  =  prime  *  result  +  (  (  value  =  =  null  )  ?  0  :  value  .  hashCode  (  )  )  ;  [ATTENTION]  return  value  ;  }    [METHOD]  hashCode  [TYPE]  int  [PARAMETER]  [CLASS]  TypedValue    [TYPE]  int  prime  result  [TYPE]  String  value  [TYPE]  boolean  false  true  
[REPLACE]  if  (  this  ==  obj  )  return  true;	[BUGGY]  if  (  this  &&  obj  )  return  false  ;  [CE]  bad  operand  types  for  binary  operator  '&&'  [CONTEXT]  public  boolean  equals  (  Object  obj  )  {  [ATTENTION]  if  (  this&&obj  )  return  false  ;  if  (  obj  =  =  null  )  return  false  ;  if  (  getClass  (  )  !  =  obj  .  getClass  (  )  )  return  false  ;  TypedValue  other  =    (  TypedValue  )  obj  ;  if  (  value  =  =  null  )  {  if  (  other  .  value  !  =  null  )  return  false  ;  }  else  if  (  !value  .  equals  (  other  .  value  )  )  return  false  ;  return  true  ;  }    [METHOD]  equals  [TYPE]  boolean  [PARAMETER]  Object  obj  [CLASS]  TypedValue    [TYPE]  Object  obj  [TYPE]  String  value  [TYPE]  boolean  false  true  [TYPE]  TypedValue  other  
[ADD]  if  (  this  ==  obj  )  return  true;  if  (  obj  ==  null  )  return  false;  if  (  getClass  (  )  !=  obj  .  getClass  (  )  )  return  false;  TypedValue  other  =  (  TypedValue  )  obj;	[BUGGY]  [CE]  cannot  find  symbol  other  [CONTEXT]  public  boolean  equals  (  Object  obj  )  {  [ATTENTION]      if  (  value  =  =  null  )  {  if  (  other  .  value  !  =  null  )  return  false  ;  }  else  if  (  !value  .  equals  (  other  .  value  )  )  return  false  ;  return  true  ;  }    [METHOD]  equals  [TYPE]  boolean  [PARAMETER]  Object  obj  [CLASS]  TypedValue    [TYPE]  Object  obj  [TYPE]  String  value  [TYPE]  boolean  false  true  [TYPE]  TypedValue  other  
[REPLACE]  if  (  this  ==  obj  )  return  true;	[BUGGY]  if  (  this  =  =  obj  )  return  false  ;  [NO-ERROR]  [CONTEXT]  public  boolean  equals  (  Object  obj  )  {  [ATTENTION]  if  (  this  =  =  obj  )  return  false  ;  if  (  obj  =  =  null  )  return  false  ;  if  (  getClass  (  )  !  =  obj  .  getClass  (  )  )  return  false  ;  TypedValue  other  =    (  TypedValue  )  obj  ;  if  (  value  =  =  null  )  {  if  (  other  .  value  !  =  null  )  return  false  ;  }  else  if  (  !value  .  equals  (  other  .  value  )  )  return  false  ;  return  true  ;  }    [METHOD]  equals  [TYPE]  boolean  [PARAMETER]  Object  obj  [CLASS]  TypedValue    [TYPE]  Object  obj  [TYPE]  String  value  [TYPE]  boolean  false  true  [TYPE]  TypedValue  other  
[REPLACE]  if  (  obj  ==  null  )  return  false;	[BUGGY]  if  (  obj  !  =  null  )  return  false  ;  [FE]  AssertionFailedError    expected:<[<img  alt  =   " "  />]>  but  was:<[]>  assertEquals( "<img  alt  =  \ "\ "  /> "  ,  cleanHtml)  ;  [CONTEXT]  public  boolean  equals  (  Object  obj  )  {  if  (  this  =  =  obj  )  return  true  ;  [ATTENTION]  if  (  obj  !  =  null  )  return  false  ;  if  (  getClass  (  )  !  =  obj  .  getClass  (  )  )  return  false  ;  TypedValue  other  =    (  TypedValue  )  obj  ;  if  (  value  =  =  null  )  {  if  (  other  .  value  !  =  null  )  return  false  ;  }  else  if  (  !value  .  equals  (  other  .  value  )  )  return  false  ;  return  true  ;  }    [METHOD]  equals  [TYPE]  boolean  [PARAMETER]  Object  obj  [CLASS]  TypedValue    [TYPE]  Object  obj  [TYPE]  String  value  [TYPE]  boolean  false  true  [TYPE]  TypedValue  other  
[ADD]  if  (  obj  ==  null  )  return  false;  if  (  getClass  (  )  !=  obj  .  getClass  (  )  )  return  false;  TypedValue  other  =  (  TypedValue  )  obj;  if  (  value  ==  null  )  {  if  (  other  .  value  !=  null  )  return  false;	[BUGGY]  [CE]  illegal  start  of  type  [CONTEXT]  public  boolean  equals  (  Object  obj  )  {  if  (  this  =  =  obj  )  return  true  ;  [ATTENTION]      }  else  if  (  !value  .  equals  (  other  .  value  )  )  return  false  ;  return  true  ;  }    [METHOD]  equals  [TYPE]  boolean  [PARAMETER]  Object  obj  [CLASS]  TypedValue    [TYPE]  Object  obj  [TYPE]  String  value  [TYPE]  boolean  false  true  [TYPE]  TypedValue  other  
[REPLACE]  if  (  obj  ==  null  )  return  false;	[BUGGY]  if  (  obj  =  =  null  )  return  true  ;  [NO-ERROR]  [CONTEXT]  public  boolean  equals  (  Object  obj  )  {  if  (  this  =  =  obj  )  return  true  ;  [ATTENTION]  if  (  obj  =  =  null  )  return  true  ;  if  (  getClass  (  )  !  =  obj  .  getClass  (  )  )  return  false  ;  TypedValue  other  =    (  TypedValue  )  obj  ;  if  (  value  =  =  null  )  {  if  (  other  .  value  !  =  null  )  return  false  ;  }  else  if  (  !value  .  equals  (  other  .  value  )  )  return  false  ;  return  true  ;  }    [METHOD]  equals  [TYPE]  boolean  [PARAMETER]  Object  obj  [CLASS]  TypedValue    [TYPE]  Object  obj  [TYPE]  String  value  [TYPE]  boolean  false  true  [TYPE]  TypedValue  other  
[REPLACE]  if  (  getClass  (  )  !=  obj  .  getClass  (  )  )  return  false;	[BUGGY]  if  (  getClass  (  )    =  =    obj  .  getClass  (  )  )  return  true  ;  [NO-ERROR]  [CONTEXT]  public  boolean  equals  (  Object  obj  )  {  if  (  this  =  =  obj  )  return  true  ;  if  (  obj  =  =  null  )  return  false  ;  [ATTENTION]  if  (  getClass  (  )    =  =  obj  .  getClass  (  )  )  return  true  ;  TypedValue  other  =    (  TypedValue  )  obj  ;  if  (  value  =  =  null  )  {  if  (  other  .  value  !  =  null  )  return  false  ;  }  else  if  (  !value  .  equals  (  other  .  value  )  )  return  false  ;  return  true  ;  }    [METHOD]  equals  [TYPE]  boolean  [PARAMETER]  Object  obj  [CLASS]  TypedValue    [TYPE]  Object  obj  [TYPE]  String  value  [TYPE]  boolean  false  true  [TYPE]  TypedValue  other  
[REPLACE]  if  (  getClass  (  )  !=  obj  .  getClass  (  )  )  return  false;	[BUGGY]  if  (  getClass  (  )  !  =  obj  .  getClass  (  )  )  return  true  ;  [NO-ERROR]  [CONTEXT]  public  boolean  equals  (  Object  obj  )  {  if  (  this  =  =  obj  )  return  true  ;  if  (  obj  =  =  null  )  return  false  ;  [ATTENTION]  if  (  getClass  (  )  !  =  obj  .  getClass  (  )  )  return  true  ;  TypedValue  other  =    (  TypedValue  )  obj  ;  if  (  value  =  =  null  )  {  if  (  other  .  value  !  =  null  )  return  false  ;  }  else  if  (  !value  .  equals  (  other  .  value  )  )  return  false  ;  return  true  ;  }    [METHOD]  equals  [TYPE]  boolean  [PARAMETER]  Object  obj  [CLASS]  TypedValue    [TYPE]  Object  obj  [TYPE]  String  value  [TYPE]  boolean  false  true  [TYPE]  TypedValue  other  
[REPLACE]  TypedValue  other  =  (  TypedValue  )  obj;	[BUGGY]  int  result  =  1  ;  [CE]  cannot  find  symbol  other  [CONTEXT]  public  boolean  equals  (  Object  obj  )  {  if  (  this  =  =  obj  )  return  true  ;  if  (  obj  =  =  null  )  return  false  ;  if  (  getClass  (  )  !  =  obj  .  getClass  (  )  )  return  false  ;  [ATTENTION]  int  result  =  1  ;  if  (  value  =  =  null  )  {  if  (  other  .  value  !  =  null  )  return  false  ;  }  else  if  (  !value  .  equals  (  other  .  value  )  )  return  false  ;  return  true  ;  }    [METHOD]  equals  [TYPE]  boolean  [PARAMETER]  Object  obj  [CLASS]  TypedValue    [TYPE]  Object  obj  [TYPE]  String  value  [TYPE]  boolean  false  true  [TYPE]  TypedValue  other  
[ADD]  TypedValue  other  =  (  TypedValue  )  obj;	[BUGGY]  [CE]  cannot  find  symbol  other  [CONTEXT]  public  boolean  equals  (  Object  obj  )  {  if  (  this  =  =  obj  )  return  true  ;  if  (  obj  =  =  null  )  return  false  ;  if  (  getClass  (  )  !  =  obj  .  getClass  (  )  )  return  false  ;  [ATTENTION]  if  (  value  =  =  null  )  {  if  (  other  .  value  !  =  null  )  return  false  ;  }  else  if  (  !value  .  equals  (  other  .  value  )  )  return  false  ;  return  true  ;  }    [METHOD]  equals  [TYPE]  boolean  [PARAMETER]  Object  obj  [CLASS]  TypedValue    [TYPE]  Object  obj  [TYPE]  String  value  [TYPE]  boolean  false  true  [TYPE]  TypedValue  other  
[REPLACE]  if  (  value  ==  null  )  {	[BUGGY]  if  (  value  !  =  this  )  {[CE]  incomparable  types:  String  and  TypedValue  [CONTEXT]  public  boolean  equals  (  Object  obj  )  {  if  (  this  =  =  obj  )  return  true  ;  if  (  obj  =  =  null  )  return  false  ;  if  (  getClass  (  )  !  =  obj  .  getClass  (  )  )  return  false  ;  TypedValue  other  =    (  TypedValue  )  obj  ;  [ATTENTION]  if  (  value  !  =  this  )  {  if  (  other  .  value  !  =  null  )  return  false  ;  }  else  if  (  !value  .  equals  (  other  .  value  )  )  return  false  ;  return  true  ;  }    [METHOD]  equals  [TYPE]  boolean  [PARAMETER]  Object  obj  [CLASS]  TypedValue    [TYPE]  Object  obj  [TYPE]  String  value  [TYPE]  boolean  false  true  [TYPE]  TypedValue  other  
[REPLACE]  }  else  if  (  !value  .  equals  (  other  .  value  )  )  return  false;	[BUGGY]  else  if  (  !value  .  equals  (  other  .  value  )  )  return  true  ;  [NO-ERROR]  [CONTEXT]  public  boolean  equals  (  Object  obj  )  {  if  (  this  =  =  obj  )  return  true  ;  if  (  obj  =  =  null  )  return  false  ;  if  (  getClass  (  )  !  =  obj  .  getClass  (  )  )  return  false  ;  TypedValue  other  =    (  TypedValue  )  obj  ;  if  (  value  =  =  null  )  {  if  (  other  .  value  !  =  null  )  return  false  ;  [ATTENTION]  }  else  if  (  !value  .  equals  (  other  .  value  )  )  return  true  ;  return  true  ;  }    [METHOD]  equals  [TYPE]  boolean  [PARAMETER]  Object  obj  [CLASS]  TypedValue    [TYPE]  Object  obj  [TYPE]  String  value  [TYPE]  boolean  false  true  [TYPE]  TypedValue  other  
[ADD]  else  if  (  !value  .  equals  (  other  .  value  )  )  return  false;  return  true;  }	[BUGGY]  [CE]  '  ;  '  expected  [CONTEXT]  public  boolean  equals  (  Object  obj  )  {  if  (  this  =  =  obj  )  return  true  ;  if  (  obj  =  =  null  )  return  false  ;  if  (  getClass  (  )  !  =  obj  .  getClass  (  )  )  return  false  ;  TypedValue  other  =    (  TypedValue  )  obj  ;  if  (  value  =  =  null  )  {  if  (  other  .  value  !  =  null  )  return  false  ;  [ATTENTION]  }      [METHOD]  equals  [TYPE]  boolean  [PARAMETER]  Object  obj  [CLASS]  TypedValue    [TYPE]  Object  obj  [TYPE]  String  value  [TYPE]  boolean  false  true  [TYPE]  TypedValue  other  
[REPLACE]  if  (  other  .  value  !=  null  )  return  false;	[BUGGY]  if  (  other  .  value  =  =  null  )  return  false  ;  [NO-ERROR]  [CONTEXT]  public  boolean  equals  (  Object  obj  )  {  if  (  this  =  =  obj  )  return  true  ;  if  (  obj  =  =  null  )  return  false  ;  if  (  getClass  (  )  !  =  obj  .  getClass  (  )  )  return  false  ;  TypedValue  other  =    (  TypedValue  )  obj  ;  if  (  value  =  =  null  )  {  [ATTENTION]  if  (  other  .  value  =  =  null  )  return  false  ;  }  else  if  (  !value  .  equals  (  other  .  value  )  )  return  false  ;  return  true  ;  }    [METHOD]  equals  [TYPE]  boolean  [PARAMETER]  Object  obj  [CLASS]  TypedValue    [TYPE]  Object  obj  [TYPE]  String  value  [TYPE]  boolean  false  true  [TYPE]  TypedValue  other  
[REPLACE]  if  (  other  .  value  !=  null  )  return  false;	[BUGGY]  if  (  other  .  value  !  =  null  )  return  true  ;  [NO-ERROR]  [CONTEXT]  public  boolean  equals  (  Object  obj  )  {  if  (  this  =  =  obj  )  return  true  ;  if  (  obj  =  =  null  )  return  false  ;  if  (  getClass  (  )  !  =  obj  .  getClass  (  )  )  return  false  ;  TypedValue  other  =    (  TypedValue  )  obj  ;  if  (  value  =  =  null  )  {  [ATTENTION]  if  (  other  .  value  !  =  null  )  return  true  ;  }  else  if  (  !value  .  equals  (  other  .  value  )  )  return  false  ;  return  true  ;  }    [METHOD]  equals  [TYPE]  boolean  [PARAMETER]  Object  obj  [CLASS]  TypedValue    [TYPE]  Object  obj  [TYPE]  String  value  [TYPE]  boolean  false  true  [TYPE]  TypedValue  other  
[REMOVE]  	[BUGGY]  if  (  (  getClass  (  )  )  !  =    (  obj  .  getClass  (  )  )  )      return  false  ;  [NO-ERROR]  [CONTEXT]  public  boolean  equals  (  Object  obj  )  {  if  (  this  =  =  obj  )  return  true  ;  if  (  obj  =  =  null  )  return  false  ;  if  (  getClass  (  )  !  =  obj  .  getClass  (  )  )  return  false  ;  TypedValue  other  =    (  TypedValue  )  obj  ;  if  (  value  =  =  null  )  {  [ATTENTION]  if  (  other  .  value  !  =  null  )  return  false  ;    if  (  (  getClass  (  )  )  !  =  (  obj  .  getClass  (  )  )  )  return  false  ;  }  else  if  (  !value  .  equals  (  other  .  value  )  )  return  false  ;  return  true  ;      [METHOD]  equals  [TYPE]  boolean  [PARAMETER]  Object  obj  [CLASS]  TypedValue    [TYPE]  Object  obj  [TYPE]  String  value  [TYPE]  boolean  false  true  [TYPE]  TypedValue  other  
[REPLACE]  return  true;	[BUGGY]  return  false  ;  [FE]  AssertionFailedError    expected:<[<img  alt  =   " "  />]>  but  was:<[]>  assertEquals( "<img  alt  =  \ "\ "  /> "  ,  cleanHtml)  ;  [CONTEXT]  public  boolean  equals  (  Object  obj  )  {  if  (  this  =  =  obj  )  return  true  ;  if  (  obj  =  =  null  )  return  false  ;  if  (  getClass  (  )  !  =  obj  .  getClass  (  )  )  return  false  ;  TypedValue  other  =    (  TypedValue  )  obj  ;  if  (  value  =  =  null  )  {  if  (  other  .  value  !  =  null  )  return  false  ;  }  else  if  (  !value  .  equals  (  other  .  value  )  )  return  false  ;  [ATTENTION]  return  false  ;  }    [METHOD]  equals  [TYPE]  boolean  [PARAMETER]  Object  obj  [CLASS]  TypedValue    [TYPE]  Object  obj  [TYPE]  String  value  [TYPE]  boolean  false  true  [TYPE]  TypedValue  other  
[REPLACE]  return  value;	[BUGGY]  if  (  obj  =  =  null  )  return  false  ;  [CE]  cannot  find  symbol  obj  [CONTEXT]  public  String  toString  (  )  {  [ATTENTION]  if  (  obj  =  =  null  )  return  false  ;  }    [METHOD]  toString  [TYPE]  String  [PARAMETER]  [CLASS]  TypedValue    [TYPE]  String  value  [TYPE]  boolean  false  true  
[REPLACE]  Elements  elements  =  new  Elements  (  )  ;	[BUGGY]  for  (  Element  child:  element  .  children  (  )  )  accumulateMatches  (  eval  ,  elements  ,  child  )  ;  [CE]  cannot  find  symbol  element  [CONTEXT]  public  static  Elements  collect  (  Evaluator  eval  ,  Element  root  )  {  [ATTENTION]  for  (  Element  child:  element  .  children  (  )  )  accumulateMatches  (  eval  ,  elements  ,  child  )    ;  accumulateMatches  (  eval  ,  elements  ,  root  )  ;  return  elements  ;  }    [METHOD]  collect  [TYPE]  Elements  [PARAMETER]  Evaluator  eval  Element  root  [CLASS]  Collector    [TYPE]  boolean  false  true  [TYPE]  Element  root  [TYPE]  Evaluator  eval  [TYPE]  Elements  elements  
[ADD]  Elements  elements  =  new  Elements  (  )  ;  accumulateMatches  (  eval,  elements,  root  )  ;	[BUGGY]  [CE]  cannot  find  symbol  elements  [CONTEXT]  public  static  Elements  collect  (  Evaluator  eval  ,  Element  root  )  {  [ATTENTION]    return  elements  ;  }    [METHOD]  collect  [TYPE]  Elements  [PARAMETER]  Evaluator  eval  Element  root  [CLASS]  Collector    [TYPE]  boolean  false  true  [TYPE]  Element  root  [TYPE]  Evaluator  eval  [TYPE]  Elements  elements  
[REPLACE]  accumulateMatches  (  eval,  elements,  root  )  ;	[BUGGY]  accumulateMatches  (  eval  ,  elements  ,  child  )  ;  [CE]  cannot  find  symbol  child  [CONTEXT]  public  static  Elements  collect  (  Evaluator  eval  ,  Element  root  )  {  Elements  elements  =  new  Elements  (  )  ;  [ATTENTION]  accumulateMatches  (  eval  ,  elements  ,  child  )    ;  return  elements  ;  }    [METHOD]  collect  [TYPE]  Elements  [PARAMETER]  Evaluator  eval  Element  root  [CLASS]  Collector    [TYPE]  boolean  false  true  [TYPE]  Element  root  [TYPE]  Evaluator  eval  [TYPE]  Elements  elements  
[REPLACE]  elements  .  add  (  element  )  ;	[BUGGY]  accumulateMatches  (  eval  ,  elements  ,  root  )  ;  [CE]  cannot  find  symbol  root  [CONTEXT]  private  static  void  accumulateMatches  (  Evaluator  eval  ,  List<Element>  elements  ,  Element  element  )  {  if  (  eval  .  matches  (  element  )  )  [ATTENTION]  accumulateMatches  (  eval  ,  elements  ,  root  )    ;  for  (  Element  child:  element  .  children  (  )  )  accumulateMatches  (  eval  ,  elements  ,  child  )  ;  }    [METHOD]  accumulateMatches  [TYPE]  void  [PARAMETER]  Evaluator  eval  Element>  elements  Element  element  [CLASS]  Collector    [TYPE]  boolean  false  true  [TYPE]  Element  child  element  [TYPE]  List  elements  [TYPE]  Evaluator  eval  
[REMOVE]  	[BUGGY]  accumulateMatches  (  eval  ,  elements  ,  root  )  ;  [CE]  cannot  find  symbol  root  [CONTEXT]  private  static  void  accumulateMatches  (  Evaluator  eval  ,  List<Element>  elements  ,  Element  element  )  {  if  (  eval  .  matches  (  element  )  )  [ATTENTION]  elements  .  add  (  element  )  ;    accumulateMatches  (  eval  ,  elements  ,  root  )    ;  for  (  Element  child:  element  .  children  (  )  )  accumulateMatches  (  eval  ,  elements  ,  child  )  ;      [METHOD]  accumulateMatches  [TYPE]  void  [PARAMETER]  Evaluator  eval  Element>  elements  Element  element  [CLASS]  Collector    [TYPE]  boolean  false  true  [TYPE]  Element  child  element  [TYPE]  List  elements  [TYPE]  Evaluator  eval  
[REPLACE]  private  final  static  String[]  combinators  =  { ", ",   "> ",   "+ ",   "~ ",   "   "};	[BUGGY]  private  final  static  String[]  combinators  ;  [CE]  variable  combinators  might  not  have  been  initialized  [CONTEXT]      [CLASS]  Selector  SelectorParseException  
[REPLACE]  private  final  LinkedHashSet<Element>  elements;	[BUGGY]  private  LinkedHashSet<Element>  elements  ;  [NO-ERROR]  [CONTEXT]      [CLASS]  Selector  SelectorParseException  
[REPLACE]  private  final  TokenQueue  tq;	[BUGGY]  private  TokenQueue  tq  ;  [NO-ERROR]  [CONTEXT]      [CLASS]  Selector  SelectorParseException  
[REPLACE]  Validate  .  notNull  (  query  )  ;	[BUGGY]  Validate  .  notEmpty  (  query  )    ;  [NO-ERROR]  [CONTEXT]  private  Selector  (  String  query  ,  Element  root  )  {  [ATTENTION]  Validate  .  notEmpty  (  query  )  ;  query  =  query  .  trim  (  )  ;  Validate  .  notEmpty  (  query  )  ;  Validate  .  notNull  (  root  )  ;    this  .  elements  =  new  LinkedHashSet<Element>  (  )  ;  this  .  query  =  query  ;  this  .  root  =  root  ;  this  .  tq  =  new  TokenQueue  (  query  )  ;  }    [METHOD]  <init>  [TYPE]  Element)  [PARAMETER]  String  query  Element  root  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  String[]  combinators  [TYPE]  String  query  [TYPE]  boolean  false  true  [TYPE]  Element  root  
[REPLACE]  query  =  query  .  trim  (  )  ;	[BUGGY]  query  =    null  .  trim  (  )  ;  [CE]  <null>  cannot  be  dereferenced  [CONTEXT]  private  Selector  (  String  query  ,  Element  root  )  {  Validate  .  notNull  (  query  )  ;  [ATTENTION]  query  =  null  .  trim  (  )    ;  Validate  .  notEmpty  (  query  )  ;  Validate  .  notNull  (  root  )  ;    this  .  elements  =  new  LinkedHashSet<Element>  (  )  ;  this  .  query  =  query  ;  this  .  root  =  root  ;  this  .  tq  =  new  TokenQueue  (  query  )  ;  }    [METHOD]  <init>  [TYPE]  Element)  [PARAMETER]  String  query  Element  root  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  String[]  combinators  [TYPE]  String  query  [TYPE]  boolean  false  true  [TYPE]  Element  root  
[ADD]  query  =  query  .  trim  (  )  ;  Validate  .  notEmpty  (  query  )  ;	[BUGGY]  Validate  .  notEmpty  (  query  )  ;  [NO-ERROR]  [CONTEXT]  private  Selector  (  String  query  ,  Element  root  )  {  Validate  .  notNull  (  query  )  ;  [ATTENTION]  Validate  .  notEmpty  (  query  )    ;    Validate  .  notNull  (  root  )  ;    this  .  elements  =  new  LinkedHashSet<Element>  (  )  ;  this  .  query  =  query  ;  this  .  root  =  root  ;  this  .  tq  =  new  TokenQueue  (  query  )  ;  }    [METHOD]  <init>  [TYPE]  Element)  [PARAMETER]  String  query  Element  root  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  String[]  combinators  [TYPE]  String  query  [TYPE]  boolean  false  true  [TYPE]  Element  root  
[REPLACE]  Validate  .  notEmpty  (  query  )  ;	[BUGGY]  Validate  .  isTrue  (  query  )  ;  [CE]  no  suitable  method  found  for  isTrue(String)  [CONTEXT]  private  Selector  (  String  query  ,  Element  root  )  {  Validate  .  notNull  (  query  )  ;  query  =  query  .  trim  (  )  ;  [ATTENTION]  Validate  .  isTrue  (  query  )    ;  Validate  .  notNull  (  root  )  ;    this  .  elements  =  new  LinkedHashSet<Element>  (  )  ;  this  .  query  =  query  ;  this  .  root  =  root  ;  this  .  tq  =  new  TokenQueue  (  query  )  ;  }    [METHOD]  <init>  [TYPE]  Element)  [PARAMETER]  String  query  Element  root  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  String[]  combinators  [TYPE]  String  query  [TYPE]  boolean  false  true  [TYPE]  Element  root  
[REPLACE]  Validate  .  notNull  (  root  )  ;	[BUGGY]  Validate  .  notNull  (  roots  )  ;  [CE]  cannot  find  symbol  roots  [CONTEXT]  private  Selector  (  String  query  ,  Element  root  )  {  Validate  .  notNull  (  query  )  ;  query  =  query  .  trim  (  )  ;  Validate  .  notEmpty  (  query  )  ;  [ATTENTION]  Validate  .  notNull  (  roots  )    ;    this  .  elements  =  new  LinkedHashSet<Element>  (  )  ;  this  .  query  =  query  ;  this  .  root  =  root  ;  this  .  tq  =  new  TokenQueue  (  query  )  ;  }    [METHOD]  <init>  [TYPE]  Element)  [PARAMETER]  String  query  Element  root  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  String[]  combinators  [TYPE]  String  query  [TYPE]  boolean  false  true  [TYPE]  Element  root  
[ADD]  Validate  .  notNull  (  root  )  ;	[BUGGY]  [NO-ERROR]  [CONTEXT]  private  Selector  (  String  query  ,  Element  root  )  {  Validate  .  notNull  (  query  )  ;  query  =  query  .  trim  (  )  ;  Validate  .  notEmpty  (  query  )  ;  [ATTENTION]    this  .  elements  =  new  LinkedHashSet<Element>  (  )  ;  this  .  query  =  query  ;  this  .  root  =  root  ;  this  .  tq  =  new  TokenQueue  (  query  )  ;  }    [METHOD]  <init>  [TYPE]  Element)  [PARAMETER]  String  query  Element  root  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  String[]  combinators  [TYPE]  String  query  [TYPE]  boolean  false  true  [TYPE]  Element  root  
[REPLACE]  this  .  elements  =  new  LinkedHashSet<Element>  (  )  ;	[BUGGY]  this  .  elements    =  null  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  private  Selector  (  String  query  ,  Element  root  )  {  Validate  .  notNull  (  query  )  ;  query  =  query  .  trim  (  )  ;  Validate  .  notEmpty  (  query  )  ;  Validate  .  notNull  (  root  )  ;    [ATTENTION]  this  .  elements  =  null  ;  this  .  query  =  query  ;  this  .  root  =  root  ;  this  .  tq  =  new  TokenQueue  (  query  )  ;  }    [METHOD]  <init>  [TYPE]  Element)  [PARAMETER]  String  query  Element  root  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  String[]  combinators  [TYPE]  String  query  [TYPE]  boolean  false  true  [TYPE]  Element  root  
[REPLACE]  this  .  query  =  query;	[BUGGY]  this  .  query  =    null  ;  [NO-ERROR]  [CONTEXT]  private  Selector  (  String  query  ,  Element  root  )  {  Validate  .  notNull  (  query  )  ;  query  =  query  .  trim  (  )  ;  Validate  .  notEmpty  (  query  )  ;  Validate  .  notNull  (  root  )  ;    this  .  elements  =  new  LinkedHashSet<Element>  (  )  ;  [ATTENTION]  this  .  query  =  null  ;  this  .  root  =  root  ;  this  .  tq  =  new  TokenQueue  (  query  )  ;  }    [METHOD]  <init>  [TYPE]  Element)  [PARAMETER]  String  query  Element  root  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  String[]  combinators  [TYPE]  String  query  [TYPE]  boolean  false  true  [TYPE]  Element  root  
[REPLACE]  this  .  root  =  root;	[BUGGY]  this  .  root  =    null  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  private  Selector  (  String  query  ,  Element  root  )  {  Validate  .  notNull  (  query  )  ;  query  =  query  .  trim  (  )  ;  Validate  .  notEmpty  (  query  )  ;  Validate  .  notNull  (  root  )  ;    this  .  elements  =  new  LinkedHashSet<Element>  (  )  ;  this  .  query  =  query  ;  [ATTENTION]  this  .  root  =  null  ;  this  .  tq  =  new  TokenQueue  (  query  )  ;  }    [METHOD]  <init>  [TYPE]  Element)  [PARAMETER]  String  query  Element  root  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  String[]  combinators  [TYPE]  String  query  [TYPE]  boolean  false  true  [TYPE]  Element  root  
[REPLACE]  this  .  tq  =  new  TokenQueue  (  query  )  ;	[BUGGY]  this  .  tq  =    new  TokenQueue  (  null  )  ;  [FE]  The  validated  object  is  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  private  Selector  (  String  query  ,  Element  root  )  {  Validate  .  notNull  (  query  )  ;  query  =  query  .  trim  (  )  ;  Validate  .  notEmpty  (  query  )  ;  Validate  .  notNull  (  root  )  ;    this  .  elements  =  new  LinkedHashSet<Element>  (  )  ;  this  .  query  =  query  ;  this  .  root  =  root  ;  [ATTENTION]  this  .  tq  =  new  TokenQueue  (  null  )    ;  }    [METHOD]  <init>  [TYPE]  Element)  [PARAMETER]  String  query  Element  root  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  String[]  combinators  [TYPE]  String  query  [TYPE]  boolean  false  true  [TYPE]  Element  root  
[REPLACE]  super  (  s  )  ;	[BUGGY]  query  =  query  .  trim  (  )  ;  [CE]  non-static  variable  query  cannot  be  referenced  from  a  static  context  [CONTEXT]  public  SelectorParseException  (  String  s  )  {  [ATTENTION]  query  =  query  .  trim  (  )    ;  }    [METHOD]  <init>  [TYPE]  String)  [PARAMETER]  String  s  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  String[]  combinators  [TYPE]  String  query  s  [TYPE]  boolean  false  true  [TYPE]  Element  root  
[ADD]  super  (  s  )  ;	[BUGGY]  [NO-ERROR]  [CONTEXT]  public  SelectorParseException  (  String  s  )  {  [ATTENTION]  }    [METHOD]  <init>  [TYPE]  String)  [PARAMETER]  String  s  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  String[]  combinators  [TYPE]  String  query  s  [TYPE]  boolean  false  true  [TYPE]  Element  root  
[REPLACE]  return  new  Selector  (  query,  root  )    .  select  (  )  ;	[BUGGY]  return  byTag  (  )  ;  [CE]  non-static  method  byTag()  cannot  be  referenced  from  a  static  context  [CONTEXT]  public  static  Elements  select  (  String  query  ,  Element  root  )  {  [ATTENTION]  return  byTag  (  )    ;  }    [METHOD]  select  [TYPE]  Elements  [PARAMETER]  String  query  Element  root  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  String[]  combinators  [TYPE]  String  query  s  [TYPE]  boolean  false  true  [TYPE]  Element  root  
[REPLACE]  Validate  .  notEmpty  (  query  )  ;	[BUGGY]  query    ;  [CE]  not  a  statement  [CONTEXT]  public  static  Elements  select  (  String  query  ,  Iterable<Element>  roots  )  {  [ATTENTION]  query  ;  Validate  .  notNull  (  roots  )  ;  LinkedHashSet<Element>  elements  =  new  LinkedHashSet<Element>  (  )  ;    for  (  Element  root  :  roots  )  {  elements  .  addAll  (  select  (  query  ,  root  )  )  ;  }  return  new  Elements  (  elements  )  ;  }    [METHOD]  select  [TYPE]  Elements  [PARAMETER]  String  query  Element>  roots  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  Iterable  roots  [TYPE]  Element  root  [TYPE]  String[]  combinators  [TYPE]  String  query  s  
[REPLACE]  Validate  .  notNull  (  roots  )  ;	[BUGGY]  Validate  .  notEmpty  (  this  )  ;  [CE]  non-static  variable  this  cannot  be  referenced  from  a  static  context  [CONTEXT]  public  static  Elements  select  (  String  query  ,  Iterable<Element>  roots  )  {  Validate  .  notEmpty  (  query  )  ;  [ATTENTION]  Validate  .  notEmpty  (  this  )    ;  LinkedHashSet<Element>  elements  =  new  LinkedHashSet<Element>  (  )  ;    for  (  Element  root  :  roots  )  {  elements  .  addAll  (  select  (  query  ,  root  )  )  ;  }  return  new  Elements  (  elements  )  ;  }    [METHOD]  select  [TYPE]  Elements  [PARAMETER]  String  query  Element>  roots  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  Iterable  roots  [TYPE]  Element  root  [TYPE]  String[]  combinators  [TYPE]  String  query  s  
[REPLACE]  LinkedHashSet<Element>  elements  =  new  LinkedHashSet<Element>  (  )  ;	[BUGGY]  Elements  candidates  =  findElements  (  )  ;  [CE]  non-static  method  findElements()  cannot  be  referenced  from  a  static  context  [CONTEXT]  public  static  Elements  select  (  String  query  ,  Iterable<Element>  roots  )  {  Validate  .  notEmpty  (  query  )  ;  Validate  .  notNull  (  roots  )  ;  [ATTENTION]  Elements  candidates  =  findElements  (  )    ;    for  (  Element  root  :  roots  )  {  elements  .  addAll  (  select  (  query  ,  root  )  )  ;  }  return  new  Elements  (  elements  )  ;  }    [METHOD]  select  [TYPE]  Elements  [PARAMETER]  String  query  Element>  roots  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  Iterable  roots  [TYPE]  Element  root  [TYPE]  String[]  combinators  [TYPE]  String  query  s  
[REPLACE]  for  (  Element  root  :  roots  )  {	[BUGGY]  for  (  Element  root  :  roots  )  {  elements  .  addAll  (  select  (  query  ,  root  )  )  ;  [NO-ERROR]  [CONTEXT]  public  static  Elements  select  (  String  query  ,  Iterable<Element>  roots  )  {  Validate  .  notEmpty  (  query  )  ;  Validate  .  notNull  (  roots  )  ;  LinkedHashSet<Element>  elements  =  new  LinkedHashSet<Element>  (  )  ;    [ATTENTION]  for  (  Element  root  :  roots  )  {  elements  .  addAll  (  select  (  query  ,  root  )  )    ;  elements  .  addAll  (  select  (  query  ,  root  )  )  ;  }  return  new  Elements  (  elements  )  ;  }    [METHOD]  select  [TYPE]  Elements  [PARAMETER]  String  query  Element>  roots  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  Iterable  roots  [TYPE]  Element  root  [TYPE]  String[]  combinators  [TYPE]  String  query  s  
[ADD]  for  (  Element  root  :  roots  )  {  elements  .  addAll  (  select  (  query,  root  )  )  ;  }	[BUGGY]  [FE]  AssertionFailedError    expected:<12>  but  was:<0>  assertEquals( "ipod  -  Google  Search "  ,  doc.title())  ;  assertEquals(12  ,  results.size())  ;  assertEquals( "http://news.google.com/news?hl  =  en&q  =  ipod&um  =  1&ie  =  UTF-8&ei  =  uYlKS4SbBoGg6gPf-5XXCw&sa  =  X&oi  =  news_group&ct  =  title&resnum  =  1&ved  =  0CCIQsQQwAA "  ,  assertEquals( "http://www.apple.com/itunes/ "  ,  [CONTEXT]  public  static  Elements  select  (  String  query  ,  Iterable<Element>  roots  )  {  Validate  .  notEmpty  (  query  )  ;  Validate  .  notNull  (  roots  )  ;  LinkedHashSet<Element>  elements  =  new  LinkedHashSet<Element>  (  )  ;    [ATTENTION]    return  new  Elements  (  elements  )  ;  }    [METHOD]  select  [TYPE]  Elements  [PARAMETER]  String  query  Element>  roots  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  Iterable  roots  [TYPE]  Element  root  [TYPE]  String[]  combinators  [TYPE]  String  query  s  
[REPLACE]  return  new  Elements  (  elements  )  ;	[BUGGY]  return  new  Elements  (  true  )  ;  [CE]  no  suitable  constructor  found  for  Elements(boolean)  [CONTEXT]  public  static  Elements  select  (  String  query  ,  Iterable<Element>  roots  )  {  Validate  .  notEmpty  (  query  )  ;  Validate  .  notNull  (  roots  )  ;  LinkedHashSet<Element>  elements  =  new  LinkedHashSet<Element>  (  )  ;    for  (  Element  root  :  roots  )  {  elements  .  addAll  (  select  (  query  ,  root  )  )  ;  }  [ATTENTION]  return  new  Elements  (  true  )    ;  }    [METHOD]  select  [TYPE]  Elements  [PARAMETER]  String  query  Element>  roots  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  Iterable  roots  [TYPE]  Element  root  [TYPE]  String[]  combinators  [TYPE]  String  query  s  
[REPLACE]  tq  .  consumeWhitespace  (  )  ;	[BUGGY]  tq  .  consumeWord  (  )  ;  [FE]  Could  not  parse  query  html  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  private  Elements  select  (  )  {  [ATTENTION]  tq  .  consumeWord  (  )    ;    if  (  tq  .  matchesAny  (  combinators  )  )  {  //  if  starts  with  a  combinator  ,  use  root  as  elements  elements  .  add  (  root  )  ;  combinator  (  tq  .  consume  (  )  .  toString  (  )  )  ;  }  else  {  addElements  (  findElements  (  )  )  ;  //  chomp  first  element  matcher  off  queue  }  while  (  !tq  .  isEmpty  (  )  )  {    boolean  seenWhite  =  tq  .  consumeWhitespace  (  )  ;    if  (  tq  .  matchChomp  (   "  ,   "  )  )  {  //  group  or  while  (  !tq  .  isEmpty  (  )  )  {  String  subQuery  =  tq  .  chompTo  (   "  ,   "  )  ;  elements  .  addAll  (  select  (  subQuery  ,  root  )  )  ;  }  }  else  if  (  tq  .  matchesAny  (  combinators  )  )  {  combinator  (  tq  .  consume  (  )  .  toString  (  )  )  ;  }  else  if  (  seenWhite  )  {  combinator  (   "   "  )  ;  }  else  {  //  E  .  class  ,  E#id  ,  E[attr]  etc  .  AND  Elements  candidates  =  findElements  (  )  ;  //  take  next  el  ,  #  .  etc  off  queue  intersectElements  (  filterForSelf  (  elements  ,  candidates  )  )  ;  }  }  return  new  Elements  (  elements  )  ;  }    [METHOD]  select  [TYPE]  Elements  [PARAMETER]  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  seenWhite  true  [TYPE]  Element  root  [TYPE]  String[]  combinators  [TYPE]  String  query  s  subQuery  [TYPE]  Elements  candidates  
[REPLACE]  if  (  tq  .  matchesAny  (  combinators  )  )  {	[BUGGY]  else  if  (  tq  .  matchesAny  (  combinators  )  )  {[CE]  illegal  start  of  type  [CONTEXT]  private  Elements  select  (  )  {  tq  .  consumeWhitespace  (  )  ;    [ATTENTION]  }  else  if  (  tq  .  matchesAny  (  combinators  )  )  {  elements  .  add  (  root  )  ;  combinator  (  tq  .  consume  (  )  .  toString  (  )  )  ;  }  else  {  addElements  (  findElements  (  )  )  ;  //  chomp  first  element  matcher  off  queue  }  while  (  !tq  .  isEmpty  (  )  )  {    boolean  seenWhite  =  tq  .  consumeWhitespace  (  )  ;    if  (  tq  .  matchChomp  (   "  ,   "  )  )  {  //  group  or  while  (  !tq  .  isEmpty  (  )  )  {  String  subQuery  =  tq  .  chompTo  (   "  ,   "  )  ;  elements  .  addAll  (  select  (  subQuery  ,  root  )  )  ;  }  }  else  if  (  tq  .  matchesAny  (  combinators  )  )  {  combinator  (  tq  .  consume  (  )  .  toString  (  )  )  ;  }  else  if  (  seenWhite  )  {  combinator  (   "   "  )  ;  }  else  {  //  E  .  class  ,  E#id  ,  E[attr]  etc  .  AND  Elements  candidates  =  findElements  (  )  ;  //  take  next  el  ,  #  .  etc  off  queue  intersectElements  (  filterForSelf  (  elements  ,  candidates  )  )  ;  }  }  return  new  Elements  (  elements  )  ;  }    [METHOD]  select  [TYPE]  Elements  [PARAMETER]  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  seenWhite  true  [TYPE]  Element  root  [TYPE]  String[]  combinators  [TYPE]  String  query  s  subQuery  [TYPE]  Elements  candidates  
[REPLACE]  addElements  (  findElements  (  )  )  ;	[BUGGY]  Elements  candidates  =  findElements  (  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  if  (  tq  .  matchesAny  (  combinators  )  )  {  //  if  starts  with  a  combinator  ,  use  root  as  elements  elements  .  add  (  root  )  ;  combinator  (  tq  .  consume  (  )  .  toString  (  )  )  ;  }  else  {  [ATTENTION]  Elements  candidates  =  findElements  (  )    ;  }    [METHOD]  select  [TYPE]  Elements  [PARAMETER]  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  seenWhite  true  [TYPE]  Element  root  [TYPE]  String[]  combinators  [TYPE]  String  query  s  subQuery  [TYPE]  Elements  candidates  
[ADD]  addElements  (  findElements  (  )  )  ;	[BUGGY]  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  if  (  tq  .  matchesAny  (  combinators  )  )  {  //  if  starts  with  a  combinator  ,  use  root  as  elements  elements  .  add  (  root  )  ;  combinator  (  tq  .  consume  (  )  .  toString  (  )  )  ;  }  else  {  [ATTENTION]  }    [METHOD]  select  [TYPE]  Elements  [PARAMETER]  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  seenWhite  true  [TYPE]  Element  root  [TYPE]  String[]  combinators  [TYPE]  String  query  s  subQuery  [TYPE]  Elements  candidates  
[REPLACE]  elements  .  add  (  root  )  ;	[BUGGY]  elements  .  addAll  (  root  )  ;  [CE]  method  addAll  in  class  AbstractCollection<E>  cannot  be  applied  to  given  types  ;  [CONTEXT]  private  Elements  select  (  )  {  tq  .  consumeWhitespace  (  )  ;    if  (  tq  .  matchesAny  (  combinators  )  )  {  //  if  starts  with  a  combinator  ,  use  root  as  elements  [ATTENTION]  elements  .  addAll  (  root  )    ;  combinator  (  tq  .  consume  (  )  .  toString  (  )  )  ;  }  else  {  addElements  (  findElements  (  )  )  ;  //  chomp  first  element  matcher  off  queue  }  while  (  !tq  .  isEmpty  (  )  )  {    boolean  seenWhite  =  tq  .  consumeWhitespace  (  )  ;    if  (  tq  .  matchChomp  (   "  ,   "  )  )  {  //  group  or  while  (  !tq  .  isEmpty  (  )  )  {  String  subQuery  =  tq  .  chompTo  (   "  ,   "  )  ;  elements  .  addAll  (  select  (  subQuery  ,  root  )  )  ;  }  }  else  if  (  tq  .  matchesAny  (  combinators  )  )  {  combinator  (  tq  .  consume  (  )  .  toString  (  )  )  ;  }  else  if  (  seenWhite  )  {  combinator  (   "   "  )  ;  }  else  {  //  E  .  class  ,  E#id  ,  E[attr]  etc  .  AND  Elements  candidates  =  findElements  (  )  ;  //  take  next  el  ,  #  .  etc  off  queue  intersectElements  (  filterForSelf  (  elements  ,  candidates  )  )  ;  }  }  return  new  Elements  (  elements  )  ;  }    [METHOD]  select  [TYPE]  Elements  [PARAMETER]  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  seenWhite  true  [TYPE]  Element  root  [TYPE]  String[]  combinators  [TYPE]  String  query  s  subQuery  [TYPE]  Elements  candidates  
[REPLACE]  combinator  (  tq  .  consume  (  )    .  toString  (  )  )  ;	[BUGGY]  combinator  (  tq  .  consume  (  )  .  equals  (  )  )  ;  [CE]  no  suitable  method  found  for  equals()  [CONTEXT]  private  Elements  select  (  )  {  tq  .  consumeWhitespace  (  )  ;    if  (  tq  .  matchesAny  (  combinators  )  )  {  //  if  starts  with  a  combinator  ,  use  root  as  elements  elements  .  add  (  root  )  ;  [ATTENTION]  combinator  (  tq  .  consume  (  )    .  equals  (  )  )    ;  }  else  {  addElements  (  findElements  (  )  )  ;  //  chomp  first  element  matcher  off  queue  }  while  (  !tq  .  isEmpty  (  )  )  {    boolean  seenWhite  =  tq  .  consumeWhitespace  (  )  ;    if  (  tq  .  matchChomp  (   "  ,   "  )  )  {  //  group  or  while  (  !tq  .  isEmpty  (  )  )  {  String  subQuery  =  tq  .  chompTo  (   "  ,   "  )  ;  elements  .  addAll  (  select  (  subQuery  ,  root  )  )  ;  }  }  else  if  (  tq  .  matchesAny  (  combinators  )  )  {  combinator  (  tq  .  consume  (  )  .  toString  (  )  )  ;  }  else  if  (  seenWhite  )  {  combinator  (   "   "  )  ;  }  else  {  //  E  .  class  ,  E#id  ,  E[attr]  etc  .  AND  Elements  candidates  =  findElements  (  )  ;  //  take  next  el  ,  #  .  etc  off  queue  intersectElements  (  filterForSelf  (  elements  ,  candidates  )  )  ;  }  }  return  new  Elements  (  elements  )  ;  }    [METHOD]  select  [TYPE]  Elements  [PARAMETER]  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  seenWhite  true  [TYPE]  Element  root  [TYPE]  String[]  combinators  [TYPE]  String  query  s  subQuery  [TYPE]  Elements  candidates  
[REPLACE]  combinator  (  tq  .  consume  (  )    .  toString  (  )  )  ;	[BUGGY]  combinator  (  tq  .  consumeWord  (  )  .  toString  (  )  )  ;  [FE]  Unknown  combinator:  assertEquals(2  ,  spans.size())  ;  assertEquals( "One "  ,  spans.first().text())  ;  assertEquals( "2 "  ,  div.id())  ;  [CONTEXT]  private  Elements  select  (  )  {  tq  .  consumeWhitespace  (  )  ;    if  (  tq  .  matchesAny  (  combinators  )  )  {  //  if  starts  with  a  combinator  ,  use  root  as  elements  elements  .  add  (  root  )  ;  [ATTENTION]  combinator  (  tq  .  consumeWord  (  )    .  toString  (  )  )    ;  }  else  {  addElements  (  findElements  (  )  )  ;  //  chomp  first  element  matcher  off  queue  }  while  (  !tq  .  isEmpty  (  )  )  {    boolean  seenWhite  =  tq  .  consumeWhitespace  (  )  ;    if  (  tq  .  matchChomp  (   "  ,   "  )  )  {  //  group  or  while  (  !tq  .  isEmpty  (  )  )  {  String  subQuery  =  tq  .  chompTo  (   "  ,   "  )  ;  elements  .  addAll  (  select  (  subQuery  ,  root  )  )  ;  }  }  else  if  (  tq  .  matchesAny  (  combinators  )  )  {  combinator  (  tq  .  consume  (  )  .  toString  (  )  )  ;  }  else  if  (  seenWhite  )  {  combinator  (   "   "  )  ;  }  else  {  //  E  .  class  ,  E#id  ,  E[attr]  etc  .  AND  Elements  candidates  =  findElements  (  )  ;  //  take  next  el  ,  #  .  etc  off  queue  intersectElements  (  filterForSelf  (  elements  ,  candidates  )  )  ;  }  }  return  new  Elements  (  elements  )  ;  }    [METHOD]  select  [TYPE]  Elements  [PARAMETER]  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  seenWhite  true  [TYPE]  Element  root  [TYPE]  String[]  combinators  [TYPE]  String  query  s  subQuery  [TYPE]  Elements  candidates  
[REPLACE]  while  (  !tq  .  isEmpty  (  )  )  {	[BUGGY]  while  (  !tq  .  chompTo  (  s  )    )  {[CE]  cannot  find  symbol  s  [CONTEXT]  private  Elements  select  (  )  {  tq  .  consumeWhitespace  (  )  ;    if  (  tq  .  matchesAny  (  combinators  )  )  {  //  if  starts  with  a  combinator  ,  use  root  as  elements  elements  .  add  (  root  )  ;  combinator  (  tq  .  consume  (  )  .  toString  (  )  )  ;  }  else  {  addElements  (  findElements  (  )  )  ;  //  chomp  first  element  matcher  off  queue  }  [ATTENTION]  while  (  !tq  .  chompTo  (  s  )    )  {    boolean  seenWhite  =  tq  .  consumeWhitespace  (  )  ;    if  (  tq  .  matchChomp  (   "  ,   "  )  )  {  //  group  or  while  (  !tq  .  isEmpty  (  )  )  {  String  subQuery  =  tq  .  chompTo  (   "  ,   "  )  ;  elements  .  addAll  (  select  (  subQuery  ,  root  )  )  ;  }  }  else  if  (  tq  .  matchesAny  (  combinators  )  )  {  combinator  (  tq  .  consume  (  )  .  toString  (  )  )  ;  }  else  if  (  seenWhite  )  {  combinator  (   "   "  )  ;  }  else  {  //  E  .  class  ,  E#id  ,  E[attr]  etc  .  AND  Elements  candidates  =  findElements  (  )  ;  //  take  next  el  ,  #  .  etc  off  queue  intersectElements  (  filterForSelf  (  elements  ,  candidates  )  )  ;  }  }  return  new  Elements  (  elements  )  ;  }    [METHOD]  select  [TYPE]  Elements  [PARAMETER]  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  seenWhite  true  [TYPE]  Element  root  [TYPE]  String[]  combinators  [TYPE]  String  query  s  subQuery  [TYPE]  Elements  candidates  
[REPLACE]  while  (  !tq  .  isEmpty  (  )  )  {	[BUGGY]  while  (  !tq  .  chompTo  (  )  )  {[CE]  method  chompTo  in  class  TokenQueue  cannot  be  applied  to  given  types  ;  [CONTEXT]  private  Elements  select  (  )  {  tq  .  consumeWhitespace  (  )  ;    if  (  tq  .  matchesAny  (  combinators  )  )  {  //  if  starts  with  a  combinator  ,  use  root  as  elements  elements  .  add  (  root  )  ;  combinator  (  tq  .  consume  (  )  .  toString  (  )  )  ;  }  else  {  addElements  (  findElements  (  )  )  ;  //  chomp  first  element  matcher  off  queue  }  while  (  !tq  .  isEmpty  (  )  )  {    boolean  seenWhite  =  tq  .  consumeWhitespace  (  )  ;    if  (  tq  .  matchChomp  (   "  ,   "  )  )  {  //  group  or  [ATTENTION]  while  (  !tq  .  chompTo  (  )  )  {  String  subQuery  =  tq  .  chompTo  (   "  ,   "  )  ;  elements  .  addAll  (  select  (  subQuery  ,  root  )  )  ;  }  }  else  if  (  tq  .  matchesAny  (  combinators  )  )  {  combinator  (  tq  .  consume  (  )  .  toString  (  )  )  ;  }  else  if  (  seenWhite  )  {  combinator  (   "   "  )  ;  }  else  {  //  E  .  class  ,  E#id  ,  E[attr]  etc  .  AND  Elements  candidates  =  findElements  (  )  ;  //  take  next  el  ,  #  .  etc  off  queue  intersectElements  (  filterForSelf  (  elements  ,  candidates  )  )  ;  }  }  return  new  Elements  (  elements  )  ;  }    [METHOD]  select  [TYPE]  Elements  [PARAMETER]  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  seenWhite  true  [TYPE]  Element  root  [TYPE]  String[]  combinators  [TYPE]  String  query  s  subQuery  [TYPE]  Elements  candidates  
[REPLACE]  String  subQuery  =  tq  .  chompTo  (   ", "  )  ;	[BUGGY]  String  subQuery  =  tq  .  consumeToAny  (  combinators  )  ;  [FE]  The  validated  string  is  empty  assertEquals(5  ,  els.size())  ;  assertEquals( "p "  ,  els.get(0).tagName())  ;  assertEquals( "div "  ,  els.get(1).tagName())  ;  assertEquals( "foo "  ,  els.get(1).attr( "title "))  ;  assertEquals( "div "  ,  els.get(2).tagName())  ;  assertEquals( "bar "  ,  els.get(2).attr( "title "))  ;  assertEquals( "div "  ,  els.get(3).tagName())  ;  assertTrue(els.get(3).attr( "title ").length()  =  =  0)  ;  //  missing  attributes  come  back  as  empty  stringassertFalse(els.get(3).hasAttr( "title "))  ;  assertEquals( "span "  ,  els.get(4).tagName())  ;  assertEquals(3  ,  els.size())  ;  assertEquals( "1 "  ,  els.get(0).id())  ;  assertEquals( "2 "  ,  els.get(1).id())  ;  assertEquals( "foo "  ,  els.get(2).attr( "title "))  ;  [CONTEXT]  private  Elements  select  (  )  {  tq  .  consumeWhitespace  (  )  ;    if  (  tq  .  matchesAny  (  combinators  )  )  {  //  if  starts  with  a  combinator  ,  use  root  as  elements  elements  .  add  (  root  )  ;  combinator  (  tq  .  consume  (  )  .  toString  (  )  )  ;  }  else  {  addElements  (  findElements  (  )  )  ;  //  chomp  first  element  matcher  off  queue  }  while  (  !tq  .  isEmpty  (  )  )  {    boolean  seenWhite  =  tq  .  consumeWhitespace  (  )  ;    if  (  tq  .  matchChomp  (   "  ,   "  )  )  {  //  group  or  while  (  !tq  .  isEmpty  (  )  )  {  [ATTENTION]  String  subQuery  =  tq  .  consumeToAny  (  combinators  )    ;  elements  .  addAll  (  select  (  subQuery  ,  root  )  )  ;  }  }  else  if  (  tq  .  matchesAny  (  combinators  )  )  {  combinator  (  tq  .  consume  (  )  .  toString  (  )  )  ;  }  else  if  (  seenWhite  )  {  combinator  (   "   "  )  ;  }  else  {  //  E  .  class  ,  E#id  ,  E[attr]  etc  .  AND  Elements  candidates  =  findElements  (  )  ;  //  take  next  el  ,  #  .  etc  off  queue  intersectElements  (  filterForSelf  (  elements  ,  candidates  )  )  ;  }  }  return  new  Elements  (  elements  )  ;  }    [METHOD]  select  [TYPE]  Elements  [PARAMETER]  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  seenWhite  true  [TYPE]  Element  root  [TYPE]  String[]  combinators  [TYPE]  String  query  s  subQuery  [TYPE]  Elements  candidates  
[REPLACE]  if  (  tq  .  matchChomp  (   ", "  )  )  {	[BUGGY]  else  if  (  tq  .  matchChomp  (   "  .   "  )  )  {[CE]  [CONTEXT]  private  Elements  select  (  )  {  tq  .  consumeWhitespace  (  )  ;    if  (  tq  .  matchesAny  (  combinators  )  )  {  //  if  starts  with  a  combinator  ,  use  root  as  elements  elements  .  add  (  root  )  ;  combinator  (  tq  .  consume  (  )  .  toString  (  )  )  ;  }  else  {  addElements  (  findElements  (  )  )  ;  //  chomp  first  element  matcher  off  queue  }  while  (  !tq  .  isEmpty  (  )  )  {    boolean  seenWhite  =  tq  .  consumeWhitespace  (  )  ;    [ATTENTION]  }  else  if  (  tq  .  matchChomp  (   "  .   "  )  )  {  while  (  !tq  .  isEmpty  (  )  )  {  String  subQuery  =  tq  .  chompTo  (   "  ,   "  )  ;  elements  .  addAll  (  select  (  subQuery  ,  root  )  )  ;  }  }  else  if  (  tq  .  matchesAny  (  combinators  )  )  {  combinator  (  tq  .  consume  (  )  .  toString  (  )  )  ;  }  else  if  (  seenWhite  )  {  combinator  (   "   "  )  ;  }  else  {  //  E  .  class  ,  E#id  ,  E[attr]  etc  .  AND  Elements  candidates  =  findElements  (  )  ;  //  take  next  el  ,  #  .  etc  off  queue  intersectElements  (  filterForSelf  (  elements  ,  candidates  )  )  ;  }  }  return  new  Elements  (  elements  )  ;  }    [METHOD]  select  [TYPE]  Elements  [PARAMETER]  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  seenWhite  true  [TYPE]  Element  root  [TYPE]  String[]  combinators  [TYPE]  String  query  s  subQuery  [TYPE]  Elements  candidates  
[REPLACE]  }  else  if  (  tq  .  matchesAny  (  combinators  )  )  {	[BUGGY]    else  {[CE]  'else'  without  'if'  [CONTEXT]  private  Elements  select  (  )  {  tq  .  consumeWhitespace  (  )  ;    if  (  tq  .  matchesAny  (  combinators  )  )  {  //  if  starts  with  a  combinator  ,  use  root  as  elements  elements  .  add  (  root  )  ;  combinator  (  tq  .  consume  (  )  .  toString  (  )  )  ;  }  else  {  addElements  (  findElements  (  )  )  ;  //  chomp  first  element  matcher  off  queue  }  while  (  !tq  .  isEmpty  (  )  )  {    boolean  seenWhite  =  tq  .  consumeWhitespace  (  )  ;    if  (  tq  .  matchChomp  (   "  ,   "  )  )  {  //  group  or  while  (  !tq  .  isEmpty  (  )  )  {  String  subQuery  =  tq  .  chompTo  (   "  ,   "  )  ;  elements  .  addAll  (  select  (  subQuery  ,  root  )  )  ;  }  [ATTENTION]  }else  {  combinator  (  tq  .  consume  (  )  .  toString  (  )  )  ;  }  else  if  (  seenWhite  )  {  combinator  (   "   "  )  ;  }  else  {  //  E  .  class  ,  E#id  ,  E[attr]  etc  .  AND  Elements  candidates  =  findElements  (  )  ;  //  take  next  el  ,  #  .  etc  off  queue  intersectElements  (  filterForSelf  (  elements  ,  candidates  )  )  ;  }  }  return  new  Elements  (  elements  )  ;  }    [METHOD]  select  [TYPE]  Elements  [PARAMETER]  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  seenWhite  true  [TYPE]  Element  root  [TYPE]  String[]  combinators  [TYPE]  String  query  s  subQuery  [TYPE]  Elements  candidates  
[ADD]  else  if  (  tq  .  matchesAny  (  combinators  )  )  {  combinator  (  tq  .  consume  (  )    .  toString  (  )  )  ;  }  else  if  (  seenWhite  )  {  combinator  (   "   "  )  ;	[BUGGY]    combinator  (   "   "  )  ;  [CE]  [CONTEXT]  private  Elements  select  (  )  {  tq  .  consumeWhitespace  (  )  ;    if  (  tq  .  matchesAny  (  combinators  )  )  {  //  if  starts  with  a  combinator  ,  use  root  as  elements  elements  .  add  (  root  )  ;  combinator  (  tq  .  consume  (  )  .  toString  (  )  )  ;  }  else  {  addElements  (  findElements  (  )  )  ;  //  chomp  first  element  matcher  off  queue  }  while  (  !tq  .  isEmpty  (  )  )  {    boolean  seenWhite  =  tq  .  consumeWhitespace  (  )  ;    if  (  tq  .  matchChomp  (   "  ,   "  )  )  {  //  group  or  while  (  !tq  .  isEmpty  (  )  )  {  String  subQuery  =  tq  .  chompTo  (   "  ,   "  )  ;  elements  .  addAll  (  select  (  subQuery  ,  root  )  )  ;  }  [ATTENTION]  }  combinator  (   "   "  )    ;      }  else  {  //  E  .  class  ,  E#id  ,  E[attr]  etc  .  AND  Elements  candidates  =  findElements  (  )  ;  //  take  next  el  ,  #  .  etc  off  queue  intersectElements  (  filterForSelf  (  elements  ,  candidates  )  )  ;  }  }  return  new  Elements  (  elements  )  ;  }    [METHOD]  select  [TYPE]  Elements  [PARAMETER]  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  seenWhite  true  [TYPE]  Element  root  [TYPE]  String[]  combinators  [TYPE]  String  query  s  subQuery  [TYPE]  Elements  candidates  
[REPLACE]  }  else  if  (  seenWhite  )  {	[BUGGY]  else  if  (  true  )  {[FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  private  Elements  select  (  )  {  tq  .  consumeWhitespace  (  )  ;    if  (  tq  .  matchesAny  (  combinators  )  )  {  //  if  starts  with  a  combinator  ,  use  root  as  elements  elements  .  add  (  root  )  ;  combinator  (  tq  .  consume  (  )  .  toString  (  )  )  ;  }  else  {  addElements  (  findElements  (  )  )  ;  //  chomp  first  element  matcher  off  queue  }  while  (  !tq  .  isEmpty  (  )  )  {    boolean  seenWhite  =  tq  .  consumeWhitespace  (  )  ;    if  (  tq  .  matchChomp  (   "  ,   "  )  )  {  //  group  or  while  (  !tq  .  isEmpty  (  )  )  {  String  subQuery  =  tq  .  chompTo  (   "  ,   "  )  ;  elements  .  addAll  (  select  (  subQuery  ,  root  )  )  ;  }  }  else  if  (  tq  .  matchesAny  (  combinators  )  )  {  combinator  (  tq  .  consume  (  )  .  toString  (  )  )  ;  [ATTENTION]  }  else  if  (  true  )  {  combinator  (   "   "  )  ;  }  else  {  //  E  .  class  ,  E#id  ,  E[attr]  etc  .  AND  Elements  candidates  =  findElements  (  )  ;  //  take  next  el  ,  #  .  etc  off  queue  intersectElements  (  filterForSelf  (  elements  ,  candidates  )  )  ;  }  }  return  new  Elements  (  elements  )  ;  }    [METHOD]  select  [TYPE]  Elements  [PARAMETER]  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  seenWhite  true  [TYPE]  Element  root  [TYPE]  String[]  combinators  [TYPE]  String  query  s  subQuery  [TYPE]  Elements  candidates  
[ADD]  else  if  (  seenWhite  )  {  combinator  (   "   "  )  ;  }  else  {  Elements  candidates  =  findElements  (  )  ;  intersectElements  (  filterForSelf  (  elements,  candidates  )  )  ;	[BUGGY]    combinator  (   "   "  )  ;  Elements  candidates  =  findElements  (  )  ;  intersectElements  (  filterForSelf  (  elements  ,  candidates  )  )  ;  [CE]  illegal  start  of  type  [CONTEXT]  private  Elements  select  (  )  {  tq  .  consumeWhitespace  (  )  ;    if  (  tq  .  matchesAny  (  combinators  )  )  {  //  if  starts  with  a  combinator  ,  use  root  as  elements  elements  .  add  (  root  )  ;  combinator  (  tq  .  consume  (  )  .  toString  (  )  )  ;  }  else  {  addElements  (  findElements  (  )  )  ;  //  chomp  first  element  matcher  off  queue  }  while  (  !tq  .  isEmpty  (  )  )  {    boolean  seenWhite  =  tq  .  consumeWhitespace  (  )  ;    if  (  tq  .  matchChomp  (   "  ,   "  )  )  {  //  group  or  while  (  !tq  .  isEmpty  (  )  )  {  String  subQuery  =  tq  .  chompTo  (   "  ,   "  )  ;  elements  .  addAll  (  select  (  subQuery  ,  root  )  )  ;  }  }  else  if  (  tq  .  matchesAny  (  combinators  )  )  {  combinator  (  tq  .  consume  (  )  .  toString  (  )  )  ;  [ATTENTION]  }  combinator  (   "   "  )    ;  Elements  candidates  =  findElements  (  )    ;  intersectElements  (  filterForSelf  (  elements  ,  candidates  )  )    ;      }  }  return  new  Elements  (  elements  )  ;  }    [METHOD]  select  [TYPE]  Elements  [PARAMETER]  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  seenWhite  true  [TYPE]  Element  root  [TYPE]  String[]  combinators  [TYPE]  String  query  s  subQuery  [TYPE]  Elements  candidates  
[REPLACE]  Elements  candidates  =  findElements  (  )  ;	[BUGGY]  Elements  output  =  new  Elements  (  )  ;  [CE]  cannot  find  symbol  candidates  [CONTEXT]  }  else  if  (  seenWhite  )  {  combinator  (   "   "  )  ;  }  else  {  //  E  .  class  ,  E#id  ,  E[attr]  etc  .  AND  [ATTENTION]  Elements  output  =  new  Elements  (  )    ;  intersectElements  (  filterForSelf  (  elements  ,  candidates  )  )  ;  }    [METHOD]  select  [TYPE]  Elements  [PARAMETER]  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  seenWhite  true  [TYPE]  Element  root  [TYPE]  String[]  combinators  [TYPE]  String  query  s  subQuery  [TYPE]  Elements  candidates  
[REPLACE]  combinator  (   "   "  )  ;	[BUGGY]  Validate  .  notNull  (  root  )  ;  [FE]  AssertionFailedError    expected:<[Brace  yourself  for  Metro  meltdown]>  but  was:<[]>  assertEquals( "News.com.au  |  News  from  Australia  and  around  the  world  online  |  NewsComAu "  ,  doc.title())  ;  assertEquals( "Brace  yourself  for  Metro  meltdown "  ,  doc.select( ".id1225817868581  h4 ").text().trim())  ;  assertEquals( "/entertainment/horoscopes "  ,  a.attr( "href "))  ;  assertEquals( "http://www.news.com.au/entertainment/horoscopes "  ,  a.attr( "abs:href "))  ;  assertEquals( "http://www.heraldsun.com.au/news/naughty-corners-are-a-bad-idea-for-kids/story-e6frf7jo-1225817899003 "  ,  hs.attr( "href "))  ;  assertEquals(hs.attr( "href ")  ,  hs.attr( "abs:href "))  ;  [CONTEXT]  private  Elements  select  (  )  {  tq  .  consumeWhitespace  (  )  ;    if  (  tq  .  matchesAny  (  combinators  )  )  {  //  if  starts  with  a  combinator  ,  use  root  as  elements  elements  .  add  (  root  )  ;  combinator  (  tq  .  consume  (  )  .  toString  (  )  )  ;  }  else  {  addElements  (  findElements  (  )  )  ;  //  chomp  first  element  matcher  off  queue  }  while  (  !tq  .  isEmpty  (  )  )  {    boolean  seenWhite  =  tq  .  consumeWhitespace  (  )  ;    if  (  tq  .  matchChomp  (   "  ,   "  )  )  {  //  group  or  while  (  !tq  .  isEmpty  (  )  )  {  String  subQuery  =  tq  .  chompTo  (   "  ,   "  )  ;  elements  .  addAll  (  select  (  subQuery  ,  root  )  )  ;  }  }  else  if  (  tq  .  matchesAny  (  combinators  )  )  {  combinator  (  tq  .  consume  (  )  .  toString  (  )  )  ;  }  else  if  (  seenWhite  )  {  [ATTENTION]  Validate  .  notNull  (  root  )    ;  }  else  {  //  E  .  class  ,  E#id  ,  E[attr]  etc  .  AND  Elements  candidates  =  findElements  (  )  ;  //  take  next  el  ,  #  .  etc  off  queue  intersectElements  (  filterForSelf  (  elements  ,  candidates  )  )  ;  }  }  return  new  Elements  (  elements  )  ;  }    [METHOD]  select  [TYPE]  Elements  [PARAMETER]  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  seenWhite  true  [TYPE]  Element  root  [TYPE]  String[]  combinators  [TYPE]  String  query  s  subQuery  [TYPE]  Elements  candidates  
[REPLACE]  Elements  candidates  =  findElements  (  )  ;	[BUGGY]  Elements  output  =  new  Elements  (  )  ;  [CE]  cannot  find  symbol  candidates  [CONTEXT]  private  Elements  select  (  )  {  tq  .  consumeWhitespace  (  )  ;    if  (  tq  .  matchesAny  (  combinators  )  )  {  //  if  starts  with  a  combinator  ,  use  root  as  elements  elements  .  add  (  root  )  ;  combinator  (  tq  .  consume  (  )  .  toString  (  )  )  ;  }  else  {  addElements  (  findElements  (  )  )  ;  //  chomp  first  element  matcher  off  queue  }  while  (  !tq  .  isEmpty  (  )  )  {    boolean  seenWhite  =  tq  .  consumeWhitespace  (  )  ;    if  (  tq  .  matchChomp  (   "  ,   "  )  )  {  //  group  or  while  (  !tq  .  isEmpty  (  )  )  {  String  subQuery  =  tq  .  chompTo  (   "  ,   "  )  ;  elements  .  addAll  (  select  (  subQuery  ,  root  )  )  ;  }  }  else  if  (  tq  .  matchesAny  (  combinators  )  )  {  combinator  (  tq  .  consume  (  )  .  toString  (  )  )  ;  }  else  if  (  seenWhite  )  {  combinator  (   "   "  )  ;  }  else  {  //  E  .  class  ,  E#id  ,  E[attr]  etc  .  AND  [ATTENTION]  Elements  output  =  new  Elements  (  )    ;  intersectElements  (  filterForSelf  (  elements  ,  candidates  )  )  ;  }  }  return  new  Elements  (  elements  )  ;  }    [METHOD]  select  [TYPE]  Elements  [PARAMETER]  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  seenWhite  true  [TYPE]  Element  root  [TYPE]  String[]  combinators  [TYPE]  String  query  s  subQuery  [TYPE]  Elements  candidates  
[REPLACE]  combinator  (  tq  .  consume  (  )    .  toString  (  )  )  ;	[BUGGY]  combinator  (  tq  .  consumeWord  (  )    .  toString  (  )  )  ;  [FE]  Unknown  combinator:  assertEquals( "ipod  -  Google  Search "  ,  doc.title())  ;  assertEquals(12  ,  results.size())  ;  assertEquals( "http://news.google.com/news?hl  =  en&q  =  ipod&um  =  1&ie  =  UTF-8&ei  =  uYlKS4SbBoGg6gPf-5XXCw&sa  =  X&oi  =  news_group&ct  =  title&resnum  =  1&ved  =  0CCIQsQQwAA "  ,  assertEquals( "http://www.apple.com/itunes/ "  ,  [CONTEXT]  private  Elements  select  (  )  {  tq  .  consumeWhitespace  (  )  ;    if  (  tq  .  matchesAny  (  combinators  )  )  {  //  if  starts  with  a  combinator  ,  use  root  as  elements  elements  .  add  (  root  )  ;  combinator  (  tq  .  consume  (  )  .  toString  (  )  )  ;  }  else  {  addElements  (  findElements  (  )  )  ;  //  chomp  first  element  matcher  off  queue  }  while  (  !tq  .  isEmpty  (  )  )  {    boolean  seenWhite  =  tq  .  consumeWhitespace  (  )  ;    if  (  tq  .  matchChomp  (   "  ,   "  )  )  {  //  group  or  while  (  !tq  .  isEmpty  (  )  )  {  String  subQuery  =  tq  .  chompTo  (   "  ,   "  )  ;  elements  .  addAll  (  select  (  subQuery  ,  root  )  )  ;  }  }  else  if  (  tq  .  matchesAny  (  combinators  )  )  {  [ATTENTION]  combinator  (  tq  .  consumeWord  (  )  .  toString  (  )  )    ;  }  else  if  (  seenWhite  )  {  combinator  (   "   "  )  ;  }  else  {  //  E  .  class  ,  E#id  ,  E[attr]  etc  .  AND  Elements  candidates  =  findElements  (  )  ;  //  take  next  el  ,  #  .  etc  off  queue  intersectElements  (  filterForSelf  (  elements  ,  candidates  )  )  ;  }  }  return  new  Elements  (  elements  )  ;  }    [METHOD]  select  [TYPE]  Elements  [PARAMETER]  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  seenWhite  true  [TYPE]  Element  root  [TYPE]  String[]  combinators  [TYPE]  String  query  s  subQuery  [TYPE]  Elements  candidates  
[REPLACE]  combinator  (  tq  .  consume  (  )    .  toString  (  )  )  ;	[BUGGY]  combinator  (  tq  .  consume  (  )  .  equals  (  )  )  ;  [CE]  no  suitable  method  found  for  equals()  [CONTEXT]  private  Elements  select  (  )  {  tq  .  consumeWhitespace  (  )  ;    if  (  tq  .  matchesAny  (  combinators  )  )  {  //  if  starts  with  a  combinator  ,  use  root  as  elements  elements  .  add  (  root  )  ;  combinator  (  tq  .  consume  (  )  .  toString  (  )  )  ;  }  else  {  addElements  (  findElements  (  )  )  ;  //  chomp  first  element  matcher  off  queue  }  while  (  !tq  .  isEmpty  (  )  )  {    boolean  seenWhite  =  tq  .  consumeWhitespace  (  )  ;    if  (  tq  .  matchChomp  (   "  ,   "  )  )  {  //  group  or  while  (  !tq  .  isEmpty  (  )  )  {  String  subQuery  =  tq  .  chompTo  (   "  ,   "  )  ;  elements  .  addAll  (  select  (  subQuery  ,  root  )  )  ;  }  }  else  if  (  tq  .  matchesAny  (  combinators  )  )  {  [ATTENTION]  combinator  (  tq  .  consume  (  )    .  equals  (  )  )    ;  }  else  if  (  seenWhite  )  {  combinator  (   "   "  )  ;  }  else  {  //  E  .  class  ,  E#id  ,  E[attr]  etc  .  AND  Elements  candidates  =  findElements  (  )  ;  //  take  next  el  ,  #  .  etc  off  queue  intersectElements  (  filterForSelf  (  elements  ,  candidates  )  )  ;  }  }  return  new  Elements  (  elements  )  ;  }    [METHOD]  select  [TYPE]  Elements  [PARAMETER]  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  seenWhite  true  [TYPE]  Element  root  [TYPE]  String[]  combinators  [TYPE]  String  query  s  subQuery  [TYPE]  Elements  candidates  
[REPLACE]  }  else  if  (  seenWhite  )  {	[BUGGY]    if  (  seenWhite  )  {[FE]  The  validated  string  is  empty  assertEquals( "ipod  -  Google  Search "  ,  doc.title())  ;  assertEquals(12  ,  results.size())  ;  assertEquals( "http://news.google.com/news?hl  =  en&q  =  ipod&um  =  1&ie  =  UTF-8&ei  =  uYlKS4SbBoGg6gPf-5XXCw&sa  =  X&oi  =  news_group&ct  =  title&resnum  =  1&ved  =  0CCIQsQQwAA "  ,  assertEquals( "http://www.apple.com/itunes/ "  ,  [CONTEXT]  private  Elements  select  (  )  {  tq  .  consumeWhitespace  (  )  ;    if  (  tq  .  matchesAny  (  combinators  )  )  {  //  if  starts  with  a  combinator  ,  use  root  as  elements  elements  .  add  (  root  )  ;  combinator  (  tq  .  consume  (  )  .  toString  (  )  )  ;  }  else  {  addElements  (  findElements  (  )  )  ;  //  chomp  first  element  matcher  off  queue  }  while  (  !tq  .  isEmpty  (  )  )  {    boolean  seenWhite  =  tq  .  consumeWhitespace  (  )  ;    if  (  tq  .  matchChomp  (   "  ,   "  )  )  {  //  group  or  while  (  !tq  .  isEmpty  (  )  )  {  String  subQuery  =  tq  .  chompTo  (   "  ,   "  )  ;  elements  .  addAll  (  select  (  subQuery  ,  root  )  )  ;  }  }  else  if  (  tq  .  matchesAny  (  combinators  )  )  {  combinator  (  tq  .  consume  (  )  .  toString  (  )  )  ;  [ATTENTION]  }if  (  seenWhite  )  {  combinator  (   "   "  )  ;  }  else  {  //  E  .  class  ,  E#id  ,  E[attr]  etc  .  AND  Elements  candidates  =  findElements  (  )  ;  //  take  next  el  ,  #  .  etc  off  queue  intersectElements  (  filterForSelf  (  elements  ,  candidates  )  )  ;  }  }  return  new  Elements  (  elements  )  ;  }    [METHOD]  select  [TYPE]  Elements  [PARAMETER]  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  seenWhite  true  [TYPE]  Element  root  [TYPE]  String[]  combinators  [TYPE]  String  query  s  subQuery  [TYPE]  Elements  candidates  
[ADD]  Elements  candidates  =  findElements  (  )  ;  intersectElements  (  filterForSelf  (  elements,  candidates  )  )  ;	[BUGGY]  [FE]  [CONTEXT]  }  else  if  (  seenWhite  )  {  combinator  (   "   "  )  ;  }  else  {  //  E  .  class  ,  E#id  ,  E[attr]  etc  .  AND  [ATTENTION]    }    [METHOD]  select  [TYPE]  Elements  [PARAMETER]  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  seenWhite  true  [TYPE]  Element  root  [TYPE]  String[]  combinators  [TYPE]  String  query  s  subQuery  [TYPE]  Elements  candidates  
[REPLACE]  while  (  !tq  .  isEmpty  (  )  )  {	[BUGGY]  while  (  !tq  .  chompTo  (  s  )    )  {[CE]  cannot  find  symbol  s  [CONTEXT]  private  Elements  select  (  )  {  tq  .  consumeWhitespace  (  )  ;    if  (  tq  .  matchesAny  (  combinators  )  )  {  //  if  starts  with  a  combinator  ,  use  root  as  elements  elements  .  add  (  root  )  ;  combinator  (  tq  .  consume  (  )  .  toString  (  )  )  ;  }  else  {  addElements  (  findElements  (  )  )  ;  //  chomp  first  element  matcher  off  queue  }  while  (  !tq  .  isEmpty  (  )  )  {    boolean  seenWhite  =  tq  .  consumeWhitespace  (  )  ;    if  (  tq  .  matchChomp  (   "  ,   "  )  )  {  //  group  or  [ATTENTION]  while  (  !tq  .  chompTo  (  s  )    )  {  String  subQuery  =  tq  .  chompTo  (   "  ,   "  )  ;  elements  .  addAll  (  select  (  subQuery  ,  root  )  )  ;  }  }  else  if  (  tq  .  matchesAny  (  combinators  )  )  {  combinator  (  tq  .  consume  (  )  .  toString  (  )  )  ;  }  else  if  (  seenWhite  )  {  combinator  (   "   "  )  ;  }  else  {  //  E  .  class  ,  E#id  ,  E[attr]  etc  .  AND  Elements  candidates  =  findElements  (  )  ;  //  take  next  el  ,  #  .  etc  off  queue  intersectElements  (  filterForSelf  (  elements  ,  candidates  )  )  ;  }  }  return  new  Elements  (  elements  )  ;  }    [METHOD]  select  [TYPE]  Elements  [PARAMETER]  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  seenWhite  true  [TYPE]  Element  root  [TYPE]  String[]  combinators  [TYPE]  String  query  s  subQuery  [TYPE]  Elements  candidates  
[REPLACE]  String  subQuery  =  tq  .  chompTo  (   ", "  )  ;	[BUGGY]  String  subQuery  =  tq  .  isEmpty  (  )    ;  [CE]  incompatible  types  [CONTEXT]  private  Elements  select  (  )  {  tq  .  consumeWhitespace  (  )  ;    if  (  tq  .  matchesAny  (  combinators  )  )  {  //  if  starts  with  a  combinator  ,  use  root  as  elements  elements  .  add  (  root  )  ;  combinator  (  tq  .  consume  (  )  .  toString  (  )  )  ;  }  else  {  addElements  (  findElements  (  )  )  ;  //  chomp  first  element  matcher  off  queue  }  while  (  !tq  .  isEmpty  (  )  )  {    boolean  seenWhite  =  tq  .  consumeWhitespace  (  )  ;    if  (  tq  .  matchChomp  (   "  ,   "  )  )  {  //  group  or  while  (  !tq  .  isEmpty  (  )  )  {  [ATTENTION]  String  subQuery  =  tq  .  isEmpty  (  )  ;  elements  .  addAll  (  select  (  subQuery  ,  root  )  )  ;  }  }  else  if  (  tq  .  matchesAny  (  combinators  )  )  {  combinator  (  tq  .  consume  (  )  .  toString  (  )  )  ;  }  else  if  (  seenWhite  )  {  combinator  (   "   "  )  ;  }  else  {  //  E  .  class  ,  E#id  ,  E[attr]  etc  .  AND  Elements  candidates  =  findElements  (  )  ;  //  take  next  el  ,  #  .  etc  off  queue  intersectElements  (  filterForSelf  (  elements  ,  candidates  )  )  ;  }  }  return  new  Elements  (  elements  )  ;  }    [METHOD]  select  [TYPE]  Elements  [PARAMETER]  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  seenWhite  true  [TYPE]  Element  root  [TYPE]  String[]  combinators  [TYPE]  String  query  s  subQuery  [TYPE]  Elements  candidates  
[ADD]  String  subQuery  =  tq  .  chompTo  (   ", "  )  ;  elements  .  addAll  (  select  (  subQuery,  root  )  )  ;	[BUGGY]  [FE]  [CONTEXT]  private  Elements  select  (  )  {  tq  .  consumeWhitespace  (  )  ;    if  (  tq  .  matchesAny  (  combinators  )  )  {  //  if  starts  with  a  combinator  ,  use  root  as  elements  elements  .  add  (  root  )  ;  combinator  (  tq  .  consume  (  )  .  toString  (  )  )  ;  }  else  {  addElements  (  findElements  (  )  )  ;  //  chomp  first  element  matcher  off  queue  }  while  (  !tq  .  isEmpty  (  )  )  {    boolean  seenWhite  =  tq  .  consumeWhitespace  (  )  ;    if  (  tq  .  matchChomp  (   "  ,   "  )  )  {  //  group  or  while  (  !tq  .  isEmpty  (  )  )  {  [ATTENTION]    }  }  else  if  (  tq  .  matchesAny  (  combinators  )  )  {  combinator  (  tq  .  consume  (  )  .  toString  (  )  )  ;  }  else  if  (  seenWhite  )  {  combinator  (   "   "  )  ;  }  else  {  //  E  .  class  ,  E#id  ,  E[attr]  etc  .  AND  Elements  candidates  =  findElements  (  )  ;  //  take  next  el  ,  #  .  etc  off  queue  intersectElements  (  filterForSelf  (  elements  ,  candidates  )  )  ;  }  }  return  new  Elements  (  elements  )  ;  }    [METHOD]  select  [TYPE]  Elements  [PARAMETER]  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  seenWhite  true  [TYPE]  Element  root  [TYPE]  String[]  combinators  [TYPE]  String  query  s  subQuery  [TYPE]  Elements  candidates  
[REPLACE]  }  else  if  (  tq  .  matchesAny  (  combinators  )  )  {	[BUGGY]    if  (  tq  .  matchesAny  (  combinators  )  )  {[FE]  Could  not  parse  query  p  ,  div  ,  [title]  assertEquals(5  ,  els.size())  ;  assertEquals( "p "  ,  els.get(0).tagName())  ;  assertEquals( "div "  ,  els.get(1).tagName())  ;  assertEquals( "foo "  ,  els.get(1).attr( "title "))  ;  assertEquals( "div "  ,  els.get(2).tagName())  ;  assertEquals( "bar "  ,  els.get(2).attr( "title "))  ;  assertEquals( "div "  ,  els.get(3).tagName())  ;  assertTrue(els.get(3).attr( "title ").length()  =  =  0)  ;  //  missing  attributes  come  back  as  empty  stringassertFalse(els.get(3).hasAttr( "title "))  ;  assertEquals( "span "  ,  els.get(4).tagName())  ;  assertEquals(3  ,  els.size())  ;  assertEquals( "1 "  ,  els.get(0).id())  ;  assertEquals( "2 "  ,  els.get(1).id())  ;  assertEquals( "foo "  ,  els.get(2).attr( "title "))  ;  [CONTEXT]  private  Elements  select  (  )  {  tq  .  consumeWhitespace  (  )  ;    if  (  tq  .  matchesAny  (  combinators  )  )  {  //  if  starts  with  a  combinator  ,  use  root  as  elements  elements  .  add  (  root  )  ;  combinator  (  tq  .  consume  (  )  .  toString  (  )  )  ;  }  else  {  addElements  (  findElements  (  )  )  ;  //  chomp  first  element  matcher  off  queue  }  while  (  !tq  .  isEmpty  (  )  )  {    boolean  seenWhite  =  tq  .  consumeWhitespace  (  )  ;    if  (  tq  .  matchChomp  (   "  ,   "  )  )  {  //  group  or  while  (  !tq  .  isEmpty  (  )  )  {  String  subQuery  =  tq  .  chompTo  (   "  ,   "  )  ;  elements  .  addAll  (  select  (  subQuery  ,  root  )  )  ;  }  [ATTENTION]  }if  (  tq  .  matchesAny  (  combinators  )  )  {  combinator  (  tq  .  consume  (  )  .  toString  (  )  )  ;  }  else  if  (  seenWhite  )  {  combinator  (   "   "  )  ;  }  else  {  //  E  .  class  ,  E#id  ,  E[attr]  etc  .  AND  Elements  candidates  =  findElements  (  )  ;  //  take  next  el  ,  #  .  etc  off  queue  intersectElements  (  filterForSelf  (  elements  ,  candidates  )  )  ;  }  }  return  new  Elements  (  elements  )  ;  }    [METHOD]  select  [TYPE]  Elements  [PARAMETER]  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  seenWhite  true  [TYPE]  Element  root  [TYPE]  String[]  combinators  [TYPE]  String  query  s  subQuery  [TYPE]  Elements  candidates  
[ADD]  else  if  (  tq  .  matchesAny  (  combinators  )  )  {  combinator  (  tq  .  consume  (  )    .  toString  (  )  )  ;  }  else  if  (  seenWhite  )  {  combinator  (   "   "  )  ;	[BUGGY]    combinator  (  tq  .  consume  (  )  .  toString  (  )  )  ;  combinator  (   "   "  )  ;  [CE]  [CONTEXT]  private  Elements  select  (  )  {  tq  .  consumeWhitespace  (  )  ;    if  (  tq  .  matchesAny  (  combinators  )  )  {  //  if  starts  with  a  combinator  ,  use  root  as  elements  elements  .  add  (  root  )  ;  combinator  (  tq  .  consume  (  )  .  toString  (  )  )  ;  }  else  {  addElements  (  findElements  (  )  )  ;  //  chomp  first  element  matcher  off  queue  }  while  (  !tq  .  isEmpty  (  )  )  {    boolean  seenWhite  =  tq  .  consumeWhitespace  (  )  ;    if  (  tq  .  matchChomp  (   "  ,   "  )  )  {  //  group  or  while  (  !tq  .  isEmpty  (  )  )  {  String  subQuery  =  tq  .  chompTo  (   "  ,   "  )  ;  elements  .  addAll  (  select  (  subQuery  ,  root  )  )  ;  }  [ATTENTION]  }  combinator  (  tq  .  consume  (  )    .  toString  (  )  )    ;  combinator  (   "   "  )    ;      }  else  {  //  E  .  class  ,  E#id  ,  E[attr]  etc  .  AND  Elements  candidates  =  findElements  (  )  ;  //  take  next  el  ,  #  .  etc  off  queue  intersectElements  (  filterForSelf  (  elements  ,  candidates  )  )  ;  }  }  return  new  Elements  (  elements  )  ;  }    [METHOD]  select  [TYPE]  Elements  [PARAMETER]  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  seenWhite  true  [TYPE]  Element  root  [TYPE]  String[]  combinators  [TYPE]  String  query  s  subQuery  [TYPE]  Elements  candidates  
[ADD]  Elements  candidates  =  findElements  (  )  ;  intersectElements  (  filterForSelf  (  elements,  candidates  )  )  ;	[BUGGY]  [FE]  [CONTEXT]  private  Elements  select  (  )  {  tq  .  consumeWhitespace  (  )  ;    if  (  tq  .  matchesAny  (  combinators  )  )  {  //  if  starts  with  a  combinator  ,  use  root  as  elements  elements  .  add  (  root  )  ;  combinator  (  tq  .  consume  (  )  .  toString  (  )  )  ;  }  else  {  addElements  (  findElements  (  )  )  ;  //  chomp  first  element  matcher  off  queue  }  while  (  !tq  .  isEmpty  (  )  )  {    boolean  seenWhite  =  tq  .  consumeWhitespace  (  )  ;    if  (  tq  .  matchChomp  (   "  ,   "  )  )  {  //  group  or  while  (  !tq  .  isEmpty  (  )  )  {  String  subQuery  =  tq  .  chompTo  (   "  ,   "  )  ;  elements  .  addAll  (  select  (  subQuery  ,  root  )  )  ;  }  }  else  if  (  tq  .  matchesAny  (  combinators  )  )  {  combinator  (  tq  .  consume  (  )  .  toString  (  )  )  ;  }  else  if  (  seenWhite  )  {  combinator  (   "   "  )  ;  }  else  {  //  E  .  class  ,  E#id  ,  E[attr]  etc  .  AND  [ATTENTION]    }  }  return  new  Elements  (  elements  )  ;  }    [METHOD]  select  [TYPE]  Elements  [PARAMETER]  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  seenWhite  true  [TYPE]  Element  root  [TYPE]  String[]  combinators  [TYPE]  String  query  s  subQuery  [TYPE]  Elements  candidates  
[REPLACE]  combinator  (  tq  .  consume  (  )    .  toString  (  )  )  ;	[BUGGY]  combinator  (  tq  .  consumeWord  (  )  .  toString  (  )  )  ;  [FE]  Unknown  combinator:  assertEquals( "ipod  -  Google  Search "  ,  doc.title())  ;  assertEquals(12  ,  results.size())  ;  assertEquals( "http://news.google.com/news?hl  =  en&q  =  ipod&um  =  1&ie  =  UTF-8&ei  =  uYlKS4SbBoGg6gPf-5XXCw&sa  =  X&oi  =  news_group&ct  =  title&resnum  =  1&ved  =  0CCIQsQQwAA "  ,  assertEquals( "http://www.apple.com/itunes/ "  ,  [CONTEXT]  private  Elements  select  (  )  {  tq  .  consumeWhitespace  (  )  ;    if  (  tq  .  matchesAny  (  combinators  )  )  {  //  if  starts  with  a  combinator  ,  use  root  as  elements  elements  .  add  (  root  )  ;  combinator  (  tq  .  consume  (  )  .  toString  (  )  )  ;  }  else  {  addElements  (  findElements  (  )  )  ;  //  chomp  first  element  matcher  off  queue  }  while  (  !tq  .  isEmpty  (  )  )  {    boolean  seenWhite  =  tq  .  consumeWhitespace  (  )  ;    if  (  tq  .  matchChomp  (   "  ,   "  )  )  {  //  group  or  while  (  !tq  .  isEmpty  (  )  )  {  String  subQuery  =  tq  .  chompTo  (   "  ,   "  )  ;  elements  .  addAll  (  select  (  subQuery  ,  root  )  )  ;  }  }  else  if  (  tq  .  matchesAny  (  combinators  )  )  {  [ATTENTION]  combinator  (  tq  .  consumeWord  (  )    .  toString  (  )  )    ;  }  else  if  (  seenWhite  )  {  combinator  (   "   "  )  ;  }  else  {  //  E  .  class  ,  E#id  ,  E[attr]  etc  .  AND  Elements  candidates  =  findElements  (  )  ;  //  take  next  el  ,  #  .  etc  off  queue  intersectElements  (  filterForSelf  (  elements  ,  candidates  )  )  ;  }  }  return  new  Elements  (  elements  )  ;  }    [METHOD]  select  [TYPE]  Elements  [PARAMETER]  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  seenWhite  true  [TYPE]  Element  root  [TYPE]  String[]  combinators  [TYPE]  String  query  s  subQuery  [TYPE]  Elements  candidates  
[REPLACE]  }  else  if  (  seenWhite  )  {	[BUGGY]    if  (  true  )  {[FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  private  Elements  select  (  )  {  tq  .  consumeWhitespace  (  )  ;    if  (  tq  .  matchesAny  (  combinators  )  )  {  //  if  starts  with  a  combinator  ,  use  root  as  elements  elements  .  add  (  root  )  ;  combinator  (  tq  .  consume  (  )  .  toString  (  )  )  ;  }  else  {  addElements  (  findElements  (  )  )  ;  //  chomp  first  element  matcher  off  queue  }  while  (  !tq  .  isEmpty  (  )  )  {    boolean  seenWhite  =  tq  .  consumeWhitespace  (  )  ;    if  (  tq  .  matchChomp  (   "  ,   "  )  )  {  //  group  or  while  (  !tq  .  isEmpty  (  )  )  {  String  subQuery  =  tq  .  chompTo  (   "  ,   "  )  ;  elements  .  addAll  (  select  (  subQuery  ,  root  )  )  ;  }  }  else  if  (  tq  .  matchesAny  (  combinators  )  )  {  combinator  (  tq  .  consume  (  )  .  toString  (  )  )  ;  [ATTENTION]  }if  (  true  )  {  combinator  (   "   "  )  ;  }  else  {  //  E  .  class  ,  E#id  ,  E[attr]  etc  .  AND  Elements  candidates  =  findElements  (  )  ;  //  take  next  el  ,  #  .  etc  off  queue  intersectElements  (  filterForSelf  (  elements  ,  candidates  )  )  ;  }  }  return  new  Elements  (  elements  )  ;  }    [METHOD]  select  [TYPE]  Elements  [PARAMETER]  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  seenWhite  true  [TYPE]  Element  root  [TYPE]  String[]  combinators  [TYPE]  String  query  s  subQuery  [TYPE]  Elements  candidates  
[REPLACE]  boolean  seenWhite  =  tq  .  consumeWhitespace  (  )  ;	[BUGGY]  boolean  seenWhite  =  tq  .  consumeWord  (  )  ;  [CE]  incompatible  types  [CONTEXT]  private  Elements  select  (  )  {  tq  .  consumeWhitespace  (  )  ;    if  (  tq  .  matchesAny  (  combinators  )  )  {  //  if  starts  with  a  combinator  ,  use  root  as  elements  elements  .  add  (  root  )  ;  combinator  (  tq  .  consume  (  )  .  toString  (  )  )  ;  }  else  {  addElements  (  findElements  (  )  )  ;  //  chomp  first  element  matcher  off  queue  }  while  (  !tq  .  isEmpty  (  )  )  {    [ATTENTION]  boolean  seenWhite  =  tq  .  consumeWord  (  )    ;    if  (  tq  .  matchChomp  (   "  ,   "  )  )  {  //  group  or  while  (  !tq  .  isEmpty  (  )  )  {  String  subQuery  =  tq  .  chompTo  (   "  ,   "  )  ;  elements  .  addAll  (  select  (  subQuery  ,  root  )  )  ;  }  }  else  if  (  tq  .  matchesAny  (  combinators  )  )  {  combinator  (  tq  .  consume  (  )  .  toString  (  )  )  ;  }  else  if  (  seenWhite  )  {  combinator  (   "   "  )  ;  }  else  {  //  E  .  class  ,  E#id  ,  E[attr]  etc  .  AND  Elements  candidates  =  findElements  (  )  ;  //  take  next  el  ,  #  .  etc  off  queue  intersectElements  (  filterForSelf  (  elements  ,  candidates  )  )  ;  }  }  return  new  Elements  (  elements  )  ;  }    [METHOD]  select  [TYPE]  Elements  [PARAMETER]  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  seenWhite  true  [TYPE]  Element  root  [TYPE]  String[]  combinators  [TYPE]  String  query  s  subQuery  [TYPE]  Elements  candidates  
[ADD]  boolean  seenWhite  =  tq  .  consumeWhitespace  (  )  ;	[BUGGY]  [CE]  cannot  find  symbol  seenWhite  [CONTEXT]  private  Elements  select  (  )  {  tq  .  consumeWhitespace  (  )  ;    if  (  tq  .  matchesAny  (  combinators  )  )  {  //  if  starts  with  a  combinator  ,  use  root  as  elements  elements  .  add  (  root  )  ;  combinator  (  tq  .  consume  (  )  .  toString  (  )  )  ;  }  else  {  addElements  (  findElements  (  )  )  ;  //  chomp  first  element  matcher  off  queue  }  while  (  !tq  .  isEmpty  (  )  )  {    [ATTENTION]    if  (  tq  .  matchChomp  (   "  ,   "  )  )  {  //  group  or  while  (  !tq  .  isEmpty  (  )  )  {  String  subQuery  =  tq  .  chompTo  (   "  ,   "  )  ;  elements  .  addAll  (  select  (  subQuery  ,  root  )  )  ;  }  }  else  if  (  tq  .  matchesAny  (  combinators  )  )  {  combinator  (  tq  .  consume  (  )  .  toString  (  )  )  ;  }  else  if  (  seenWhite  )  {  combinator  (   "   "  )  ;  }  else  {  //  E  .  class  ,  E#id  ,  E[attr]  etc  .  AND  Elements  candidates  =  findElements  (  )  ;  //  take  next  el  ,  #  .  etc  off  queue  intersectElements  (  filterForSelf  (  elements  ,  candidates  )  )  ;  }  }  return  new  Elements  (  elements  )  ;  }    [METHOD]  select  [TYPE]  Elements  [PARAMETER]  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  seenWhite  true  [TYPE]  Element  root  [TYPE]  String[]  combinators  [TYPE]  String  query  s  subQuery  [TYPE]  Elements  candidates  
[REPLACE]  }  else  if  (  seenWhite  )  {	[BUGGY]    else  {[CE]  'else'  without  'if'  [CONTEXT]  private  Elements  select  (  )  {  tq  .  consumeWhitespace  (  )  ;    if  (  tq  .  matchesAny  (  combinators  )  )  {  //  if  starts  with  a  combinator  ,  use  root  as  elements  elements  .  add  (  root  )  ;  combinator  (  tq  .  consume  (  )  .  toString  (  )  )  ;  }  else  {  addElements  (  findElements  (  )  )  ;  //  chomp  first  element  matcher  off  queue  }  while  (  !tq  .  isEmpty  (  )  )  {    boolean  seenWhite  =  tq  .  consumeWhitespace  (  )  ;    if  (  tq  .  matchChomp  (   "  ,   "  )  )  {  //  group  or  while  (  !tq  .  isEmpty  (  )  )  {  String  subQuery  =  tq  .  chompTo  (   "  ,   "  )  ;  elements  .  addAll  (  select  (  subQuery  ,  root  )  )  ;  }  }  else  if  (  tq  .  matchesAny  (  combinators  )  )  {  combinator  (  tq  .  consume  (  )  .  toString  (  )  )  ;  [ATTENTION]  }else  {  combinator  (   "   "  )  ;  }  else  {  //  E  .  class  ,  E#id  ,  E[attr]  etc  .  AND  Elements  candidates  =  findElements  (  )  ;  //  take  next  el  ,  #  .  etc  off  queue  intersectElements  (  filterForSelf  (  elements  ,  candidates  )  )  ;  }  }  return  new  Elements  (  elements  )  ;  }    [METHOD]  select  [TYPE]  Elements  [PARAMETER]  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  seenWhite  true  [TYPE]  Element  root  [TYPE]  String[]  combinators  [TYPE]  String  query  s  subQuery  [TYPE]  Elements  candidates  
[ADD]  else  if  (  seenWhite  )  {  combinator  (   "   "  )  ;  }  else  {  Elements  candidates  =  findElements  (  )  ;  intersectElements  (  filterForSelf  (  elements,  candidates  )  )  ;	[BUGGY]    Elements  candidates  =  findElements  (  )  ;  intersectElements  (  filterForSelf  (  elements  ,  candidates  )  )  ;  [CE]  illegal  start  of  type  [CONTEXT]  private  Elements  select  (  )  {  tq  .  consumeWhitespace  (  )  ;    if  (  tq  .  matchesAny  (  combinators  )  )  {  //  if  starts  with  a  combinator  ,  use  root  as  elements  elements  .  add  (  root  )  ;  combinator  (  tq  .  consume  (  )  .  toString  (  )  )  ;  }  else  {  addElements  (  findElements  (  )  )  ;  //  chomp  first  element  matcher  off  queue  }  while  (  !tq  .  isEmpty  (  )  )  {    boolean  seenWhite  =  tq  .  consumeWhitespace  (  )  ;    if  (  tq  .  matchChomp  (   "  ,   "  )  )  {  //  group  or  while  (  !tq  .  isEmpty  (  )  )  {  String  subQuery  =  tq  .  chompTo  (   "  ,   "  )  ;  elements  .  addAll  (  select  (  subQuery  ,  root  )  )  ;  }  }  else  if  (  tq  .  matchesAny  (  combinators  )  )  {  combinator  (  tq  .  consume  (  )  .  toString  (  )  )  ;  [ATTENTION]  }  Elements  candidates  =  findElements  (  )    ;  intersectElements  (  filterForSelf  (  elements  ,  candidates  )  )    ;      }  }  return  new  Elements  (  elements  )  ;  }    [METHOD]  select  [TYPE]  Elements  [PARAMETER]  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  seenWhite  true  [TYPE]  Element  root  [TYPE]  String[]  combinators  [TYPE]  String  query  s  subQuery  [TYPE]  Elements  candidates  
[ADD]  Elements  candidates  =  findElements  (  )  ;  intersectElements  (  filterForSelf  (  elements,  candidates  )  )  ;	[BUGGY]  intersectElements  (  filterForSelf  (  elements  ,  candidates  )  )  ;  [CE]  cannot  find  symbol  candidates  [CONTEXT]  }  else  if  (  seenWhite  )  {  combinator  (   "   "  )  ;  }  else  {  //  E  .  class  ,  E#id  ,  E[attr]  etc  .  AND  [ATTENTION]  intersectElements  (  filterForSelf  (  elements  ,  candidates  )  )    ;    }    [METHOD]  select  [TYPE]  Elements  [PARAMETER]  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  seenWhite  true  [TYPE]  Element  root  [TYPE]  String[]  combinators  [TYPE]  String  query  s  subQuery  [TYPE]  Elements  candidates  
[REMOVE]  	[BUGGY]  Validate  .  notNull  (  root  )  ;  [NO-ERROR]  [CONTEXT]  private  Elements  select  (  )  {  tq  .  consumeWhitespace  (  )  ;    if  (  tq  .  matchesAny  (  combinators  )  )  {  //  if  starts  with  a  combinator  ,  use  root  as  elements  elements  .  add  (  root  )  ;  combinator  (  tq  .  consume  (  )  .  toString  (  )  )  ;  }  else  {  addElements  (  findElements  (  )  )  ;  //  chomp  first  element  matcher  off  queue  }  while  (  !tq  .  isEmpty  (  )  )  {    boolean  seenWhite  =  tq  .  consumeWhitespace  (  )  ;    if  (  tq  .  matchChomp  (   "  ,   "  )  )  {  //  group  or  while  (  !tq  .  isEmpty  (  )  )  {  String  subQuery  =  tq  .  chompTo  (   "  ,   "  )  ;  elements  .  addAll  (  select  (  subQuery  ,  root  )  )  ;  }  }  else  if  (  tq  .  matchesAny  (  combinators  )  )  {  combinator  (  tq  .  consume  (  )  .  toString  (  )  )  ;  }  else  if  (  seenWhite  )  {  [ATTENTION]  combinator  (   "   "  )  ;    Validate  .  notNull  (  root  )    ;  }  else  {  //  E  .  class  ,  E#id  ,  E[attr]  etc  .  AND  Elements  candidates  =  findElements  (  )  ;  //  take  next  el  ,  #  .  etc  off  queue  intersectElements  (  filterForSelf  (  elements  ,  candidates  )  )  ;  }  }  return  new  Elements  (  elements  )  ;      [METHOD]  select  [TYPE]  Elements  [PARAMETER]  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  seenWhite  true  [TYPE]  Element  root  [TYPE]  String[]  combinators  [TYPE]  String  query  s  subQuery  [TYPE]  Elements  candidates  
[ADD]  combinator  (   "   "  )  ;	[BUGGY]  [FE]  AssertionFailedError    expected:<[Brace  yourself  for  Metro  meltdown]>  but  was:<[]>  assertEquals( "News.com.au  |  News  from  Australia  and  around  the  world  online  |  NewsComAu "  ,  doc.title())  ;  assertEquals( "Brace  yourself  for  Metro  meltdown "  ,  doc.select( ".id1225817868581  h4 ").text().trim())  ;  assertEquals( "/entertainment/horoscopes "  ,  a.attr( "href "))  ;  assertEquals( "http://www.news.com.au/entertainment/horoscopes "  ,  a.attr( "abs:href "))  ;  assertEquals( "http://www.heraldsun.com.au/news/naughty-corners-are-a-bad-idea-for-kids/story-e6frf7jo-1225817899003 "  ,  hs.attr( "href "))  ;  assertEquals(hs.attr( "href ")  ,  hs.attr( "abs:href "))  ;  [CONTEXT]  private  Elements  select  (  )  {  tq  .  consumeWhitespace  (  )  ;    if  (  tq  .  matchesAny  (  combinators  )  )  {  //  if  starts  with  a  combinator  ,  use  root  as  elements  elements  .  add  (  root  )  ;  combinator  (  tq  .  consume  (  )  .  toString  (  )  )  ;  }  else  {  addElements  (  findElements  (  )  )  ;  //  chomp  first  element  matcher  off  queue  }  while  (  !tq  .  isEmpty  (  )  )  {    boolean  seenWhite  =  tq  .  consumeWhitespace  (  )  ;    if  (  tq  .  matchChomp  (   "  ,   "  )  )  {  //  group  or  while  (  !tq  .  isEmpty  (  )  )  {  String  subQuery  =  tq  .  chompTo  (   "  ,   "  )  ;  elements  .  addAll  (  select  (  subQuery  ,  root  )  )  ;  }  }  else  if  (  tq  .  matchesAny  (  combinators  )  )  {  combinator  (  tq  .  consume  (  )  .  toString  (  )  )  ;  }  else  if  (  seenWhite  )  {  [ATTENTION]  }  else  {  //  E  .  class  ,  E#id  ,  E[attr]  etc  .  AND  Elements  candidates  =  findElements  (  )  ;  //  take  next  el  ,  #  .  etc  off  queue  intersectElements  (  filterForSelf  (  elements  ,  candidates  )  )  ;  }  }  return  new  Elements  (  elements  )  ;  }    [METHOD]  select  [TYPE]  Elements  [PARAMETER]  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  seenWhite  true  [TYPE]  Element  root  [TYPE]  String[]  combinators  [TYPE]  String  query  s  subQuery  [TYPE]  Elements  candidates  
[REPLACE]  boolean  seenWhite  =  tq  .  consumeWhitespace  (  )  ;	[BUGGY]  boolean  seenWhite  =  tq  .  consumeToAny  (  combinators  )    ;  [CE]  incompatible  types  [CONTEXT]  private  Elements  select  (  )  {  tq  .  consumeWhitespace  (  )  ;    if  (  tq  .  matchesAny  (  combinators  )  )  {  //  if  starts  with  a  combinator  ,  use  root  as  elements  elements  .  add  (  root  )  ;  combinator  (  tq  .  consume  (  )  .  toString  (  )  )  ;  }  else  {  addElements  (  findElements  (  )  )  ;  //  chomp  first  element  matcher  off  queue  }  while  (  !tq  .  isEmpty  (  )  )  {    [ATTENTION]  boolean  seenWhite  =  tq  .  consumeToAny  (  combinators  )  ;    if  (  tq  .  matchChomp  (   "  ,   "  )  )  {  //  group  or  while  (  !tq  .  isEmpty  (  )  )  {  String  subQuery  =  tq  .  chompTo  (   "  ,   "  )  ;  elements  .  addAll  (  select  (  subQuery  ,  root  )  )  ;  }  }  else  if  (  tq  .  matchesAny  (  combinators  )  )  {  combinator  (  tq  .  consume  (  )  .  toString  (  )  )  ;  }  else  if  (  seenWhite  )  {  combinator  (   "   "  )  ;  }  else  {  //  E  .  class  ,  E#id  ,  E[attr]  etc  .  AND  Elements  candidates  =  findElements  (  )  ;  //  take  next  el  ,  #  .  etc  off  queue  intersectElements  (  filterForSelf  (  elements  ,  candidates  )  )  ;  }  }  return  new  Elements  (  elements  )  ;  }    [METHOD]  select  [TYPE]  Elements  [PARAMETER]  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  seenWhite  true  [TYPE]  Element  root  [TYPE]  String[]  combinators  [TYPE]  String  query  s  subQuery  [TYPE]  Elements  candidates  
[REPLACE]  return  new  Elements  (  elements  )  ;	[BUGGY]  return  byTag  (  )  ;  [FE]  The  validated  string  is  empty  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  private  Elements  select  (  )  {  tq  .  consumeWhitespace  (  )  ;    if  (  tq  .  matchesAny  (  combinators  )  )  {  //  if  starts  with  a  combinator  ,  use  root  as  elements  elements  .  add  (  root  )  ;  combinator  (  tq  .  consume  (  )  .  toString  (  )  )  ;  }  else  {  addElements  (  findElements  (  )  )  ;  //  chomp  first  element  matcher  off  queue  }  while  (  !tq  .  isEmpty  (  )  )  {    boolean  seenWhite  =  tq  .  consumeWhitespace  (  )  ;    if  (  tq  .  matchChomp  (   "  ,   "  )  )  {  //  group  or  while  (  !tq  .  isEmpty  (  )  )  {  String  subQuery  =  tq  .  chompTo  (   "  ,   "  )  ;  elements  .  addAll  (  select  (  subQuery  ,  root  )  )  ;  }  }  else  if  (  tq  .  matchesAny  (  combinators  )  )  {  combinator  (  tq  .  consume  (  )  .  toString  (  )  )  ;  }  else  if  (  seenWhite  )  {  combinator  (   "   "  )  ;  }  else  {  //  E  .  class  ,  E#id  ,  E[attr]  etc  .  AND  Elements  candidates  =  findElements  (  )  ;  //  take  next  el  ,  #  .  etc  off  queue  intersectElements  (  filterForSelf  (  elements  ,  candidates  )  )  ;  }  }  [ATTENTION]  return  byTag  (  )    ;  }    [METHOD]  select  [TYPE]  Elements  [PARAMETER]  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  seenWhite  true  [TYPE]  Element  root  [TYPE]  String[]  combinators  [TYPE]  String  query  s  subQuery  [TYPE]  Elements  candidates  
[REPLACE]  tq  .  consumeWhitespace  (  )  ;	[BUGGY]  tq  .  consumeWord  (  )  ;  [FE]  The  validated  string  is  empty  assertEquals( "ipod  -  Google  Search "  ,  doc.title())  ;  assertEquals(12  ,  results.size())  ;  assertEquals( "http://news.google.com/news?hl  =  en&q  =  ipod&um  =  1&ie  =  UTF-8&ei  =  uYlKS4SbBoGg6gPf-5XXCw&sa  =  X&oi  =  news_group&ct  =  title&resnum  =  1&ved  =  0CCIQsQQwAA "  ,  assertEquals( "http://www.apple.com/itunes/ "  ,  [CONTEXT]  private  void  combinator  (  String  combinator  )  {  [ATTENTION]  tq  .  consumeWord  (  )    ;  String  subQuery  =  tq  .  consumeToAny  (  combinators  )  ;  //  support  multi  >  childs  Elements  output  ;  if  (  combinator  .  equals  (   "> "  )  )  output  =  filterForChildren  (  elements  ,  select  (  subQuery  ,  elements  )  )  ;  else  if  (  combinator  .  equals  (   "   "  )  )  output  =  filterForDescendants  (  elements  ,  select  (  subQuery  ,  elements  )  )  ;  else  if  (  combinator  .  equals  (   "+ "  )  )  output  =  filterForAdjacentSiblings  (  elements  ,  select  (  subQuery  ,  root  )  )  ;  else  if  (  combinator  .  equals  (   "~ "  )  )  output  =  filterForGeneralSiblings  (  elements  ,  select  (  subQuery  ,  root  )  )  ;  else  throw  new  IllegalStateException  (   "Unknown  combinator:   "  +  combinator  )  ;    elements  .  clear  (  )  ;  elements  .  addAll  (  output  )  ;  }    [METHOD]  combinator  [TYPE]  void  [PARAMETER]  String  combinator  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  Element  root  [TYPE]  String[]  combinators  [TYPE]  String  combinator  query  s  subQuery  [TYPE]  Elements  output  
[REPLACE]  String  subQuery  =  tq  .  consumeToAny  (  combinators  )  ;	[BUGGY]  String  subQuery  =  tq  .  matchesAny  (  combinators  )  ;  [CE]  incompatible  types  [CONTEXT]  private  void  combinator  (  String  combinator  )  {  tq  .  consumeWhitespace  (  )  ;  [ATTENTION]  String  subQuery  =  tq  .  matchesAny  (  combinators  )    ;    Elements  output  ;  if  (  combinator  .  equals  (   "> "  )  )  output  =  filterForChildren  (  elements  ,  select  (  subQuery  ,  elements  )  )  ;  else  if  (  combinator  .  equals  (   "   "  )  )  output  =  filterForDescendants  (  elements  ,  select  (  subQuery  ,  elements  )  )  ;  else  if  (  combinator  .  equals  (   "+ "  )  )  output  =  filterForAdjacentSiblings  (  elements  ,  select  (  subQuery  ,  root  )  )  ;  else  if  (  combinator  .  equals  (   "~ "  )  )  output  =  filterForGeneralSiblings  (  elements  ,  select  (  subQuery  ,  root  )  )  ;  else  throw  new  IllegalStateException  (   "Unknown  combinator:   "  +  combinator  )  ;    elements  .  clear  (  )  ;  elements  .  addAll  (  output  )  ;  }    [METHOD]  combinator  [TYPE]  void  [PARAMETER]  String  combinator  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  Element  root  [TYPE]  String[]  combinators  [TYPE]  String  combinator  query  s  subQuery  [TYPE]  Elements  output  
[ADD]  String  subQuery  =  tq  .  consumeToAny  (  combinators  )  ;	[BUGGY]  [CE]  cannot  find  symbol  subQuery  [CONTEXT]  private  void  combinator  (  String  combinator  )  {  tq  .  consumeWhitespace  (  )  ;  [ATTENTION]    Elements  output  ;  if  (  combinator  .  equals  (   "> "  )  )  output  =  filterForChildren  (  elements  ,  select  (  subQuery  ,  elements  )  )  ;  else  if  (  combinator  .  equals  (   "   "  )  )  output  =  filterForDescendants  (  elements  ,  select  (  subQuery  ,  elements  )  )  ;  else  if  (  combinator  .  equals  (   "+ "  )  )  output  =  filterForAdjacentSiblings  (  elements  ,  select  (  subQuery  ,  root  )  )  ;  else  if  (  combinator  .  equals  (   "~ "  )  )  output  =  filterForGeneralSiblings  (  elements  ,  select  (  subQuery  ,  root  )  )  ;  else  throw  new  IllegalStateException  (   "Unknown  combinator:   "  +  combinator  )  ;    elements  .  clear  (  )  ;  elements  .  addAll  (  output  )  ;  }    [METHOD]  combinator  [TYPE]  void  [PARAMETER]  String  combinator  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  Element  root  [TYPE]  String[]  combinators  [TYPE]  String  combinator  query  s  subQuery  [TYPE]  Elements  output  
[REPLACE]  Elements  output;	[BUGGY]  Elements  output  =  new  Elements  (  )  ;  [NO-ERROR]  [CONTEXT]  private  void  combinator  (  String  combinator  )  {  tq  .  consumeWhitespace  (  )  ;  String  subQuery  =  tq  .  consumeToAny  (  combinators  )  ;  //  support  multi  >  childs  [ATTENTION]  Elements  output  =  new  Elements  (  )    ;  if  (  combinator  .  equals  (   "> "  )  )  output  =  filterForChildren  (  elements  ,  select  (  subQuery  ,  elements  )  )  ;  else  if  (  combinator  .  equals  (   "   "  )  )  output  =  filterForDescendants  (  elements  ,  select  (  subQuery  ,  elements  )  )  ;  else  if  (  combinator  .  equals  (   "+ "  )  )  output  =  filterForAdjacentSiblings  (  elements  ,  select  (  subQuery  ,  root  )  )  ;  else  if  (  combinator  .  equals  (   "~ "  )  )  output  =  filterForGeneralSiblings  (  elements  ,  select  (  subQuery  ,  root  )  )  ;  else  throw  new  IllegalStateException  (   "Unknown  combinator:   "  +  combinator  )  ;    elements  .  clear  (  )  ;  elements  .  addAll  (  output  )  ;  }    [METHOD]  combinator  [TYPE]  void  [PARAMETER]  String  combinator  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  Element  root  [TYPE]  String[]  combinators  [TYPE]  String  combinator  query  s  subQuery  [TYPE]  Elements  output  
[REPLACE]  if  (  combinator  .  equals  (   "> "  )  )  output  =  filterForChildren  (  elements,  select  (  subQuery,  elements  )  )  ;	[BUGGY]  else  if  (  combinator  .  equals  (   "+ "  )  )  output  =  filterForAdjacentSiblings  (  elements  ,  select  (  subQuery  ,  root  )  )  ;  [CE]  [CONTEXT]  private  void  combinator  (  String  combinator  )  {  tq  .  consumeWhitespace  (  )  ;  String  subQuery  =  tq  .  consumeToAny  (  combinators  )  ;  //  support  multi  >  childs  Elements  output  ;  [ATTENTION]  else  if  (  combinator  .  equals  (   "+ "  )  )  output  =  filterForAdjacentSiblings  (  elements  ,  select  (  subQuery  ,  root  )  )    ;    else  if  (  combinator  .  equals  (   "   "  )  )  output  =  filterForDescendants  (  elements  ,  select  (  subQuery  ,  elements  )  )  ;  else  if  (  combinator  .  equals  (   "+ "  )  )  output  =  filterForAdjacentSiblings  (  elements  ,  select  (  subQuery  ,  root  )  )  ;  else  if  (  combinator  .  equals  (   "~ "  )  )  output  =  filterForGeneralSiblings  (  elements  ,  select  (  subQuery  ,  root  )  )  ;  else  throw  new  IllegalStateException  (   "Unknown  combinator:   "  +  combinator  )  ;    elements  .  clear  (  )  ;  elements  .  addAll  (  output  )  ;  }    [METHOD]  combinator  [TYPE]  void  [PARAMETER]  String  combinator  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  Element  root  [TYPE]  String[]  combinators  [TYPE]  String  combinator  query  s  subQuery  [TYPE]  Elements  output  
[REPLACE]  else  if  (  combinator  .  equals  (   "   "  )  )  output  =  filterForDescendants  (  elements,  select  (  subQuery,  elements  )  )  ;	[BUGGY]  if  (  combinator  .  equals  (   "   "  )  )  output  =  filterForDescendants  (  elements  ,  select  (  subQuery  ,  elements  )  )  ;  [FE]  Unknown  combinator:  >  assertEquals( "ipod  -  Google  Search "  ,  doc.title())  ;  assertEquals(12  ,  results.size())  ;  assertEquals( "http://news.google.com/news?hl  =  en&q  =  ipod&um  =  1&ie  =  UTF-8&ei  =  uYlKS4SbBoGg6gPf-5XXCw&sa  =  X&oi  =  news_group&ct  =  title&resnum  =  1&ved  =  0CCIQsQQwAA "  ,  assertEquals( "http://www.apple.com/itunes/ "  ,  [CONTEXT]  private  void  combinator  (  String  combinator  )  {  tq  .  consumeWhitespace  (  )  ;  String  subQuery  =  tq  .  consumeToAny  (  combinators  )  ;  //  support  multi  >  childs  Elements  output  ;  if  (  combinator  .  equals  (   "> "  )  )  output  =  filterForChildren  (  elements  ,  select  (  subQuery  ,  elements  )  )  ;  [ATTENTION]  if  (  combinator  .  equals  (   "   "  )  )  output  =  filterForDescendants  (  elements  ,  select  (  subQuery  ,  elements  )  )    ;    else  if  (  combinator  .  equals  (   "+ "  )  )  output  =  filterForAdjacentSiblings  (  elements  ,  select  (  subQuery  ,  root  )  )  ;  else  if  (  combinator  .  equals  (   "~ "  )  )  output  =  filterForGeneralSiblings  (  elements  ,  select  (  subQuery  ,  root  )  )  ;  else  throw  new  IllegalStateException  (   "Unknown  combinator:   "  +  combinator  )  ;    elements  .  clear  (  )  ;  elements  .  addAll  (  output  )  ;  }    [METHOD]  combinator  [TYPE]  void  [PARAMETER]  String  combinator  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  Element  root  [TYPE]  String[]  combinators  [TYPE]  String  combinator  query  s  subQuery  [TYPE]  Elements  output  
[ADD]  else  if  (  combinator  .  equals  (   "   "  )  )  output  =  filterForDescendants  (  elements,  select  (  subQuery,  elements  )  )  ;  else  if  (  combinator  .  equals  (   "+ "  )  )  output  =  filterForAdjacentSiblings  (  elements,  select  (  subQuery,  root  )  )  ;  else  if  (  combinator  .  equals  (   "~ "  )  )	[BUGGY]  output  =  filterForDescendants  (  elements  ,  select  (  subQuery  ,  elements  )  )  ;  output  =  filterForAdjacentSiblings  (  elements  ,  select  (  subQuery  ,  root  )  )  ;  [CE]  'else'  without  'if'  [CONTEXT]  private  void  combinator  (  String  combinator  )  {  tq  .  consumeWhitespace  (  )  ;  String  subQuery  =  tq  .  consumeToAny  (  combinators  )  ;  //  support  multi  >  childs  Elements  output  ;  if  (  combinator  .  equals  (   "> "  )  )  output  =  filterForChildren  (  elements  ,  select  (  subQuery  ,  elements  )  )  ;  [ATTENTION]  output  =  filterForDescendants  (  elements  ,  select  (  subQuery  ,  elements  )  )    ;  output  =  filterForAdjacentSiblings  (  elements  ,  select  (  subQuery  ,  root  )  )    ;      output  =  filterForGeneralSiblings  (  elements  ,  select  (  subQuery  ,  root  )  )  ;  else  throw  new  IllegalStateException  (   "Unknown  combinator:   "  +  combinator  )  ;    elements  .  clear  (  )  ;  elements  .  addAll  (  output  )  ;  }    [METHOD]  combinator  [TYPE]  void  [PARAMETER]  String  combinator  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  Element  root  [TYPE]  String[]  combinators  [TYPE]  String  combinator  query  s  subQuery  [TYPE]  Elements  output  
[REPLACE]  else  if  (  combinator  .  equals  (   "~ "  )  )  output  =  filterForGeneralSiblings  (  elements,  select  (  subQuery,  root  )  )  ;	[BUGGY]  if  (  combinator  .  equals  (   "~ "  )  )  output  =  filterForGeneralSiblings  (  elements  ,  select  (  subQuery  ,  root  )  )  ;  [FE]  Unknown  combinator:  >  assertEquals( "ipod  -  Google  Search "  ,  doc.title())  ;  assertEquals(12  ,  results.size())  ;  assertEquals( "http://news.google.com/news?hl  =  en&q  =  ipod&um  =  1&ie  =  UTF-8&ei  =  uYlKS4SbBoGg6gPf-5XXCw&sa  =  X&oi  =  news_group&ct  =  title&resnum  =  1&ved  =  0CCIQsQQwAA "  ,  assertEquals( "http://www.apple.com/itunes/ "  ,  [CONTEXT]  private  void  combinator  (  String  combinator  )  {  tq  .  consumeWhitespace  (  )  ;  String  subQuery  =  tq  .  consumeToAny  (  combinators  )  ;  //  support  multi  >  childs  Elements  output  ;  if  (  combinator  .  equals  (   "> "  )  )  output  =  filterForChildren  (  elements  ,  select  (  subQuery  ,  elements  )  )  ;  else  if  (  combinator  .  equals  (   "   "  )  )  output  =  filterForDescendants  (  elements  ,  select  (  subQuery  ,  elements  )  )  ;  else  if  (  combinator  .  equals  (   "+ "  )  )  output  =  filterForAdjacentSiblings  (  elements  ,  select  (  subQuery  ,  root  )  )  ;  [ATTENTION]  if  (  combinator  .  equals  (   "~ "  )  )  output  =  filterForGeneralSiblings  (  elements  ,  select  (  subQuery  ,  root  )  )    ;    else  throw  new  IllegalStateException  (   "Unknown  combinator:   "  +  combinator  )  ;    elements  .  clear  (  )  ;  elements  .  addAll  (  output  )  ;  }    [METHOD]  combinator  [TYPE]  void  [PARAMETER]  String  combinator  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  Element  root  [TYPE]  String[]  combinators  [TYPE]  String  combinator  query  s  subQuery  [TYPE]  Elements  output  
[REPLACE]  throw  new  IllegalStateException  ( "   ")  ;	[BUGGY]  return  ;  [NO-ERROR]  [CONTEXT]  private  void  combinator  (  String  combinator  )  {  tq  .  consumeWhitespace  (  )  ;  String  subQuery  =  tq  .  consumeToAny  (  combinators  )  ;  //  support  multi  >  childs  Elements  output  ;  if  (  combinator  .  equals  (   "> "  )  )  output  =  filterForChildren  (  elements  ,  select  (  subQuery  ,  elements  )  )  ;  else  if  (  combinator  .  equals  (   "   "  )  )  output  =  filterForDescendants  (  elements  ,  select  (  subQuery  ,  elements  )  )  ;  else  if  (  combinator  .  equals  (   "+ "  )  )  output  =  filterForAdjacentSiblings  (  elements  ,  select  (  subQuery  ,  root  )  )  ;  else  if  (  combinator  .  equals  (   "~ "  )  )  output  =  filterForGeneralSiblings  (  elements  ,  select  (  subQuery  ,  root  )  )  ;  else  [ATTENTION]  return  ;    elements  .  clear  (  )  ;  elements  .  addAll  (  output  )  ;  }    [METHOD]  combinator  [TYPE]  void  [PARAMETER]  String  combinator  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  Element  root  [TYPE]  String[]  combinators  [TYPE]  String  combinator  query  s  subQuery  [TYPE]  Elements  output  
[REPLACE]  output  =  filterForGeneralSiblings  (  elements,  select  (  subQuery,  root  )  )  ;	[BUGGY]  output  =  filterForDescendants  (  elements  ,  select  (  subQuery  ,  elements  )  )  ;    ;  [CE]  'else'  without  'if'  [CONTEXT]  private  void  combinator  (  String  combinator  )  {  tq  .  consumeWhitespace  (  )  ;  String  subQuery  =  tq  .  consumeToAny  (  combinators  )  ;  //  support  multi  >  childs  Elements  output  ;  if  (  combinator  .  equals  (   "> "  )  )  output  =  filterForChildren  (  elements  ,  select  (  subQuery  ,  elements  )  )  ;  else  if  (  combinator  .  equals  (   "   "  )  )  output  =  filterForDescendants  (  elements  ,  select  (  subQuery  ,  elements  )  )  ;  else  if  (  combinator  .  equals  (   "+ "  )  )  output  =  filterForAdjacentSiblings  (  elements  ,  select  (  subQuery  ,  root  )  )  ;  else  if  (  combinator  .  equals  (   "~ "  )  )  [ATTENTION]  output  =  filterForDescendants  (  elements  ,  select  (  subQuery  ,  elements  )  )    ;    ;  else  throw  new  IllegalStateException  (   "Unknown  combinator:   "  +  combinator  )  ;    elements  .  clear  (  )  ;  elements  .  addAll  (  output  )  ;  }    [METHOD]  combinator  [TYPE]  void  [PARAMETER]  String  combinator  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  Element  root  [TYPE]  String[]  combinators  [TYPE]  String  combinator  query  s  subQuery  [TYPE]  Elements  output  
[ADD]  output  =  filterForGeneralSiblings  (  elements,  select  (  subQuery,  root  )  )  ;	[BUGGY]  [CE]  'else'  without  'if'  [CONTEXT]  private  void  combinator  (  String  combinator  )  {  tq  .  consumeWhitespace  (  )  ;  String  subQuery  =  tq  .  consumeToAny  (  combinators  )  ;  //  support  multi  >  childs  Elements  output  ;  if  (  combinator  .  equals  (   "> "  )  )  output  =  filterForChildren  (  elements  ,  select  (  subQuery  ,  elements  )  )  ;  else  if  (  combinator  .  equals  (   "   "  )  )  output  =  filterForDescendants  (  elements  ,  select  (  subQuery  ,  elements  )  )  ;  else  if  (  combinator  .  equals  (   "+ "  )  )  output  =  filterForAdjacentSiblings  (  elements  ,  select  (  subQuery  ,  root  )  )  ;  else  if  (  combinator  .  equals  (   "~ "  )  )  [ATTENTION]  else  throw  new  IllegalStateException  (   "Unknown  combinator:   "  +  combinator  )  ;    elements  .  clear  (  )  ;  elements  .  addAll  (  output  )  ;  }    [METHOD]  combinator  [TYPE]  void  [PARAMETER]  String  combinator  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  Element  root  [TYPE]  String[]  combinators  [TYPE]  String  combinator  query  s  subQuery  [TYPE]  Elements  output  
[REPLACE]  throw  new  IllegalStateException  ( "   ")  ;	[BUGGY]  throw  new  SelectorParseException  ( "   ")    ;    ;  [NO-ERROR]  [CONTEXT]  private  void  combinator  (  String  combinator  )  {  tq  .  consumeWhitespace  (  )  ;  String  subQuery  =  tq  .  consumeToAny  (  combinators  )  ;  //  support  multi  >  childs  Elements  output  ;  if  (  combinator  .  equals  (   "> "  )  )  output  =  filterForChildren  (  elements  ,  select  (  subQuery  ,  elements  )  )  ;  else  if  (  combinator  .  equals  (   "   "  )  )  output  =  filterForDescendants  (  elements  ,  select  (  subQuery  ,  elements  )  )  ;  else  if  (  combinator  .  equals  (   "+ "  )  )  output  =  filterForAdjacentSiblings  (  elements  ,  select  (  subQuery  ,  root  )  )  ;  else  if  (  combinator  .  equals  (   "~ "  )  )  output  =  filterForGeneralSiblings  (  elements  ,  select  (  subQuery  ,  root  )  )  ;  else  [ATTENTION]  throw  new  SelectorParseException  (   "   "  )  ;    ;    elements  .  clear  (  )  ;  elements  .  addAll  (  output  )  ;  }    [METHOD]  combinator  [TYPE]  void  [PARAMETER]  String  combinator  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  Element  root  [TYPE]  String[]  combinators  [TYPE]  String  combinator  query  s  subQuery  [TYPE]  Elements  output  
[ADD]  throw  new  IllegalStateException  ( "   ")  ;	[BUGGY]  [CE]  variable  output  might  not  have  been  initialized  [CONTEXT]  private  void  combinator  (  String  combinator  )  {  tq  .  consumeWhitespace  (  )  ;  String  subQuery  =  tq  .  consumeToAny  (  combinators  )  ;  //  support  multi  >  childs  Elements  output  ;  if  (  combinator  .  equals  (   "> "  )  )  output  =  filterForChildren  (  elements  ,  select  (  subQuery  ,  elements  )  )  ;  else  if  (  combinator  .  equals  (   "   "  )  )  output  =  filterForDescendants  (  elements  ,  select  (  subQuery  ,  elements  )  )  ;  else  if  (  combinator  .  equals  (   "+ "  )  )  output  =  filterForAdjacentSiblings  (  elements  ,  select  (  subQuery  ,  root  )  )  ;  else  if  (  combinator  .  equals  (   "~ "  )  )  output  =  filterForGeneralSiblings  (  elements  ,  select  (  subQuery  ,  root  )  )  ;  else  [ATTENTION]    elements  .  clear  (  )  ;  elements  .  addAll  (  output  )  ;  }    [METHOD]  combinator  [TYPE]  void  [PARAMETER]  String  combinator  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  Element  root  [TYPE]  String[]  combinators  [TYPE]  String  combinator  query  s  subQuery  [TYPE]  Elements  output  
[REPLACE]  output  =  filterForAdjacentSiblings  (  elements,  select  (  subQuery,  root  )  )  ;	[BUGGY]  output  =  filterForGeneralSiblings  (  elements  ,  select  (  subQuery  ,  root  )  )  ;    ;  [CE]  [CONTEXT]  private  void  combinator  (  String  combinator  )  {  tq  .  consumeWhitespace  (  )  ;  String  subQuery  =  tq  .  consumeToAny  (  combinators  )  ;  //  support  multi  >  childs  Elements  output  ;  if  (  combinator  .  equals  (   "> "  )  )  output  =  filterForChildren  (  elements  ,  select  (  subQuery  ,  elements  )  )  ;  else  if  (  combinator  .  equals  (   "   "  )  )  output  =  filterForDescendants  (  elements  ,  select  (  subQuery  ,  elements  )  )  ;  else  if  (  combinator  .  equals  (   "+ "  )  )  [ATTENTION]  output  =  filterForGeneralSiblings  (  elements  ,  select  (  subQuery  ,  root  )  )    ;    ;  else  if  (  combinator  .  equals  (   "~ "  )  )  output  =  filterForGeneralSiblings  (  elements  ,  select  (  subQuery  ,  root  )  )  ;  else  throw  new  IllegalStateException  (   "Unknown  combinator:   "  +  combinator  )  ;    elements  .  clear  (  )  ;  elements  .  addAll  (  output  )  ;  }    [METHOD]  combinator  [TYPE]  void  [PARAMETER]  String  combinator  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  Element  root  [TYPE]  String[]  combinators  [TYPE]  String  combinator  query  s  subQuery  [TYPE]  Elements  output  
[ADD]  output  =  filterForAdjacentSiblings  (  elements,  select  (  subQuery,  root  )  )  ;	[BUGGY]  [CE]  [CONTEXT]  private  void  combinator  (  String  combinator  )  {  tq  .  consumeWhitespace  (  )  ;  String  subQuery  =  tq  .  consumeToAny  (  combinators  )  ;  //  support  multi  >  childs  Elements  output  ;  if  (  combinator  .  equals  (   "> "  )  )  output  =  filterForChildren  (  elements  ,  select  (  subQuery  ,  elements  )  )  ;  else  if  (  combinator  .  equals  (   "   "  )  )  output  =  filterForDescendants  (  elements  ,  select  (  subQuery  ,  elements  )  )  ;  else  if  (  combinator  .  equals  (   "+ "  )  )  [ATTENTION]  else  if  (  combinator  .  equals  (   "~ "  )  )  output  =  filterForGeneralSiblings  (  elements  ,  select  (  subQuery  ,  root  )  )  ;  else  throw  new  IllegalStateException  (   "Unknown  combinator:   "  +  combinator  )  ;    elements  .  clear  (  )  ;  elements  .  addAll  (  output  )  ;  }    [METHOD]  combinator  [TYPE]  void  [PARAMETER]  String  combinator  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  Element  root  [TYPE]  String[]  combinators  [TYPE]  String  combinator  query  s  subQuery  [TYPE]  Elements  output  
[REPLACE]  else  if  (  combinator  .  equals  (   "~ "  )  )  output  =  filterForGeneralSiblings  (  elements,  select  (  subQuery,  root  )  )  ;	[BUGGY]  if  (  combinator  .  equals  (   "~ "  )  )  output  =  filterForGeneralSiblings  (  elements  ,  select  (  s  ,  root  )  )  ;  [CE]  cannot  find  symbol  s  [CONTEXT]  private  void  combinator  (  String  combinator  )  {  tq  .  consumeWhitespace  (  )  ;  String  subQuery  =  tq  .  consumeToAny  (  combinators  )  ;  //  support  multi  >  childs  Elements  output  ;  if  (  combinator  .  equals  (   "> "  )  )  output  =  filterForChildren  (  elements  ,  select  (  subQuery  ,  elements  )  )  ;  else  if  (  combinator  .  equals  (   "   "  )  )  output  =  filterForDescendants  (  elements  ,  select  (  subQuery  ,  elements  )  )  ;  else  if  (  combinator  .  equals  (   "+ "  )  )  output  =  filterForAdjacentSiblings  (  elements  ,  select  (  subQuery  ,  root  )  )  ;  [ATTENTION]  if  (  combinator  .  equals  (   "~ "  )  )  output  =  filterForGeneralSiblings  (  elements  ,  select  (  s  ,  root  )  )    ;    else  throw  new  IllegalStateException  (   "Unknown  combinator:   "  +  combinator  )  ;    elements  .  clear  (  )  ;  elements  .  addAll  (  output  )  ;  }    [METHOD]  combinator  [TYPE]  void  [PARAMETER]  String  combinator  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  Element  root  [TYPE]  String[]  combinators  [TYPE]  String  combinator  query  s  subQuery  [TYPE]  Elements  output  
[REPLACE]  output  =  filterForDescendants  (  elements,  select  (  subQuery,  elements  )  )  ;	[BUGGY]  output  =  filterForGeneralSiblings  (  elements  ,  select  (  subQuery  ,  root  )  )  ;    ;  [CE]  [CONTEXT]  private  void  combinator  (  String  combinator  )  {  tq  .  consumeWhitespace  (  )  ;  String  subQuery  =  tq  .  consumeToAny  (  combinators  )  ;  //  support  multi  >  childs  Elements  output  ;  if  (  combinator  .  equals  (   "> "  )  )  output  =  filterForChildren  (  elements  ,  select  (  subQuery  ,  elements  )  )  ;  else  if  (  combinator  .  equals  (   "   "  )  )  [ATTENTION]  output  =  filterForGeneralSiblings  (  elements  ,  select  (  subQuery  ,  root  )  )    ;    ;  else  if  (  combinator  .  equals  (   "+ "  )  )  output  =  filterForAdjacentSiblings  (  elements  ,  select  (  subQuery  ,  root  )  )  ;  else  if  (  combinator  .  equals  (   "~ "  )  )  output  =  filterForGeneralSiblings  (  elements  ,  select  (  subQuery  ,  root  )  )  ;  else  throw  new  IllegalStateException  (   "Unknown  combinator:   "  +  combinator  )  ;    elements  .  clear  (  )  ;  elements  .  addAll  (  output  )  ;  }    [METHOD]  combinator  [TYPE]  void  [PARAMETER]  String  combinator  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  Element  root  [TYPE]  String[]  combinators  [TYPE]  String  combinator  query  s  subQuery  [TYPE]  Elements  output  
[REPLACE]  else  if  (  combinator  .  equals  (   "~ "  )  )  output  =  filterForGeneralSiblings  (  elements,  select  (  subQuery,  root  )  )  ;	[BUGGY]  if  (subQuery  .  equals  (   "~ "  )  )  output  =  filterForGeneralSiblings  (  elements  ,  select  (  subQuery  ,  root  )  )  ;  [FE]  Unknown  combinator:  >  assertEquals( "ipod  -  Google  Search "  ,  doc.title())  ;  assertEquals(12  ,  results.size())  ;  assertEquals( "http://news.google.com/news?hl  =  en&q  =  ipod&um  =  1&ie  =  UTF-8&ei  =  uYlKS4SbBoGg6gPf-5XXCw&sa  =  X&oi  =  news_group&ct  =  title&resnum  =  1&ved  =  0CCIQsQQwAA "  ,  assertEquals( "http://www.apple.com/itunes/ "  ,  [CONTEXT]  private  void  combinator  (  String  combinator  )  {  tq  .  consumeWhitespace  (  )  ;  String  subQuery  =  tq  .  consumeToAny  (  combinators  )  ;  //  support  multi  >  childs  Elements  output  ;  if  (  combinator  .  equals  (   "> "  )  )  output  =  filterForChildren  (  elements  ,  select  (  subQuery  ,  elements  )  )  ;  else  if  (  combinator  .  equals  (   "   "  )  )  output  =  filterForDescendants  (  elements  ,  select  (  subQuery  ,  elements  )  )  ;  else  if  (  combinator  .  equals  (   "+ "  )  )  output  =  filterForAdjacentSiblings  (  elements  ,  select  (  subQuery  ,  root  )  )  ;  [ATTENTION]  if  (  subQuery  .  equals  (   "~ "  )  )  output  =  filterForGeneralSiblings  (  elements  ,  select  (  subQuery  ,  root  )  )    ;    else  throw  new  IllegalStateException  (   "Unknown  combinator:   "  +  combinator  )  ;    elements  .  clear  (  )  ;  elements  .  addAll  (  output  )  ;  }    [METHOD]  combinator  [TYPE]  void  [PARAMETER]  String  combinator  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  Element  root  [TYPE]  String[]  combinators  [TYPE]  String  combinator  query  s  subQuery  [TYPE]  Elements  output  
[REPLACE]  output  =  filterForChildren  (  elements,  select  (  subQuery,  elements  )  )  ;	[BUGGY]  output  =  filterForGeneralSiblings  (  elements  ,  select  (  subQuery  ,  root  )  )  ;    ;  [CE]  [CONTEXT]  private  void  combinator  (  String  combinator  )  {  tq  .  consumeWhitespace  (  )  ;  String  subQuery  =  tq  .  consumeToAny  (  combinators  )  ;  //  support  multi  >  childs  Elements  output  ;  if  (  combinator  .  equals  (   "> "  )  )  [ATTENTION]  output  =  filterForGeneralSiblings  (  elements  ,  select  (  subQuery  ,  root  )  )    ;    ;  else  if  (  combinator  .  equals  (   "   "  )  )  output  =  filterForDescendants  (  elements  ,  select  (  subQuery  ,  elements  )  )  ;  else  if  (  combinator  .  equals  (   "+ "  )  )  output  =  filterForAdjacentSiblings  (  elements  ,  select  (  subQuery  ,  root  )  )  ;  else  if  (  combinator  .  equals  (   "~ "  )  )  output  =  filterForGeneralSiblings  (  elements  ,  select  (  subQuery  ,  root  )  )  ;  else  throw  new  IllegalStateException  (   "Unknown  combinator:   "  +  combinator  )  ;    elements  .  clear  (  )  ;  elements  .  addAll  (  output  )  ;  }    [METHOD]  combinator  [TYPE]  void  [PARAMETER]  String  combinator  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  Element  root  [TYPE]  String[]  combinators  [TYPE]  String  combinator  query  s  subQuery  [TYPE]  Elements  output  
[ADD]  output  =  filterForChildren  (  elements,  select  (  subQuery,  elements  )  )  ;	[BUGGY]  [CE]  [CONTEXT]  private  void  combinator  (  String  combinator  )  {  tq  .  consumeWhitespace  (  )  ;  String  subQuery  =  tq  .  consumeToAny  (  combinators  )  ;  //  support  multi  >  childs  Elements  output  ;  if  (  combinator  .  equals  (   "> "  )  )  [ATTENTION]  else  if  (  combinator  .  equals  (   "   "  )  )  output  =  filterForDescendants  (  elements  ,  select  (  subQuery  ,  elements  )  )  ;  else  if  (  combinator  .  equals  (   "+ "  )  )  output  =  filterForAdjacentSiblings  (  elements  ,  select  (  subQuery  ,  root  )  )  ;  else  if  (  combinator  .  equals  (   "~ "  )  )  output  =  filterForGeneralSiblings  (  elements  ,  select  (  subQuery  ,  root  )  )  ;  else  throw  new  IllegalStateException  (   "Unknown  combinator:   "  +  combinator  )  ;    elements  .  clear  (  )  ;  elements  .  addAll  (  output  )  ;  }    [METHOD]  combinator  [TYPE]  void  [PARAMETER]  String  combinator  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  Element  root  [TYPE]  String[]  combinators  [TYPE]  String  combinator  query  s  subQuery  [TYPE]  Elements  output  
[ADD]  else  if  (  combinator  .  equals  (   "~ "  )  )  output  =  filterForGeneralSiblings  (  elements,  select  (  subQuery,  root  )  )  ;  else  throw  new  IllegalStateException  ( "   ")  ;	[BUGGY]  output  =  filterForGeneralSiblings  (  elements  ,  select  (  subQuery  ,  root  )  )  ;  [FE]  AssertionFailedError    expected:<12>  but  was:<0>  assertEquals( "ipod  -  Google  Search "  ,  doc.title())  ;  assertEquals(12  ,  results.size())  ;  assertEquals( "http://news.google.com/news?hl  =  en&q  =  ipod&um  =  1&ie  =  UTF-8&ei  =  uYlKS4SbBoGg6gPf-5XXCw&sa  =  X&oi  =  news_group&ct  =  title&resnum  =  1&ved  =  0CCIQsQQwAA "  ,  assertEquals( "http://www.apple.com/itunes/ "  ,  [CONTEXT]  private  void  combinator  (  String  combinator  )  {  tq  .  consumeWhitespace  (  )  ;  String  subQuery  =  tq  .  consumeToAny  (  combinators  )  ;  //  support  multi  >  childs  Elements  output  ;  if  (  combinator  .  equals  (   "> "  )  )  output  =  filterForChildren  (  elements  ,  select  (  subQuery  ,  elements  )  )  ;  else  if  (  combinator  .  equals  (   "   "  )  )  output  =  filterForDescendants  (  elements  ,  select  (  subQuery  ,  elements  )  )  ;  else  if  (  combinator  .  equals  (   "+ "  )  )  output  =  filterForAdjacentSiblings  (  elements  ,  select  (  subQuery  ,  root  )  )  ;  [ATTENTION]  output  =  filterForGeneralSiblings  (  elements  ,  select  (  subQuery  ,  root  )  )    ;      elements  .  clear  (  )  ;  elements  .  addAll  (  output  )  ;  }    [METHOD]  combinator  [TYPE]  void  [PARAMETER]  String  combinator  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  Element  root  [TYPE]  String[]  combinators  [TYPE]  String  combinator  query  s  subQuery  [TYPE]  Elements  output  
[ADD]  else  if  (  combinator  .  equals  (   "~ "  )  )  output  =  filterForGeneralSiblings  (  elements,  select  (  subQuery,  root  )  )  ;  else  throw  new  IllegalStateException  ( "   ")  ;	[BUGGY]  [CE]  variable  output  might  not  have  been  initialized  [CONTEXT]  private  void  combinator  (  String  combinator  )  {  tq  .  consumeWhitespace  (  )  ;  String  subQuery  =  tq  .  consumeToAny  (  combinators  )  ;  //  support  multi  >  childs  Elements  output  ;  if  (  combinator  .  equals  (   "> "  )  )  output  =  filterForChildren  (  elements  ,  select  (  subQuery  ,  elements  )  )  ;  else  if  (  combinator  .  equals  (   "   "  )  )  output  =  filterForDescendants  (  elements  ,  select  (  subQuery  ,  elements  )  )  ;  else  if  (  combinator  .  equals  (   "+ "  )  )  output  =  filterForAdjacentSiblings  (  elements  ,  select  (  subQuery  ,  root  )  )  ;  [ATTENTION]      elements  .  clear  (  )  ;  elements  .  addAll  (  output  )  ;  }    [METHOD]  combinator  [TYPE]  void  [PARAMETER]  String  combinator  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  Element  root  [TYPE]  String[]  combinators  [TYPE]  String  combinator  query  s  subQuery  [TYPE]  Elements  output  
[REPLACE]  elements  .  clear  (  )  ;  elements  .  addAll  (  output  )  ;	[BUGGY]  elements  .  addAll  (  )    ;  elements  .  addAll  (  output  )  ;  [CE]  method  addAll  in  class  AbstractCollection<E>  cannot  be  applied  to  given  types  ;  [CONTEXT]  private  void  combinator  (  String  combinator  )  {  tq  .  consumeWhitespace  (  )  ;  String  subQuery  =  tq  .  consumeToAny  (  combinators  )  ;  //  support  multi  >  childs  Elements  output  ;  if  (  combinator  .  equals  (   "> "  )  )  output  =  filterForChildren  (  elements  ,  select  (  subQuery  ,  elements  )  )  ;  else  if  (  combinator  .  equals  (   "   "  )  )  output  =  filterForDescendants  (  elements  ,  select  (  subQuery  ,  elements  )  )  ;  else  if  (  combinator  .  equals  (   "+ "  )  )  output  =  filterForAdjacentSiblings  (  elements  ,  select  (  subQuery  ,  root  )  )  ;  else  if  (  combinator  .  equals  (   "~ "  )  )  output  =  filterForGeneralSiblings  (  elements  ,  select  (  subQuery  ,  root  )  )  ;  else  throw  new  IllegalStateException  (   "Unknown  combinator:   "  +  combinator  )  ;    [ATTENTION]  elements  .  addAll  (  )  ;  elements  .  addAll  (  output  )    ;  }    [METHOD]  combinator  [TYPE]  void  [PARAMETER]  String  combinator  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  Element  root  [TYPE]  String[]  combinators  [TYPE]  String  combinator  query  s  subQuery  [TYPE]  Elements  output  
[ADD]  elements  .  clear  (  )  ;  elements  .  addAll  (  output  )  ;	[BUGGY]  [FE]  AssertionFailedError    expected:<[http://news.google.com/news?hl  =  en&q  =  ipod&um  =  1&ie  =  UTF-8&ei  =  uYlKS4SbBoGg6gPf-5XXCw&sa  =  X&oi  =  news_group&ct  =  title&resnum  =  1&ved  =  0CCIQsQQwAA]>  but  was:<[]>  assertEquals( "ipod  -  Google  Search "  ,  doc.title())  ;  assertEquals(12  ,  results.size())  ;  assertEquals( "http://news.google.com/news?hl  =  en&q  =  ipod&um  =  1&ie  =  UTF-8&ei  =  uYlKS4SbBoGg6gPf-5XXCw&sa  =  X&oi  =  news_group&ct  =  title&resnum  =  1&ved  =  0CCIQsQQwAA "  ,  assertEquals( "http://www.apple.com/itunes/ "  ,  [CONTEXT]  private  void  combinator  (  String  combinator  )  {  tq  .  consumeWhitespace  (  )  ;  String  subQuery  =  tq  .  consumeToAny  (  combinators  )  ;  //  support  multi  >  childs  Elements  output  ;  if  (  combinator  .  equals  (   "> "  )  )  output  =  filterForChildren  (  elements  ,  select  (  subQuery  ,  elements  )  )  ;  else  if  (  combinator  .  equals  (   "   "  )  )  output  =  filterForDescendants  (  elements  ,  select  (  subQuery  ,  elements  )  )  ;  else  if  (  combinator  .  equals  (   "+ "  )  )  output  =  filterForAdjacentSiblings  (  elements  ,  select  (  subQuery  ,  root  )  )  ;  else  if  (  combinator  .  equals  (   "~ "  )  )  output  =  filterForGeneralSiblings  (  elements  ,  select  (  subQuery  ,  root  )  )  ;  else  throw  new  IllegalStateException  (   "Unknown  combinator:   "  +  combinator  )  ;    [ATTENTION]  }    [METHOD]  combinator  [TYPE]  void  [PARAMETER]  String  combinator  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  Element  root  [TYPE]  String[]  combinators  [TYPE]  String  combinator  query  s  subQuery  [TYPE]  Elements  output  
[REPLACE]  elements  .  clear  (  )  ;  elements  .  addAll  (  output  )  ;	[BUGGY]  elements  .  clear  (  )  ;  elements  .  add  (  output  )  ;  [CE]  no  suitable  method  found  for  add(Elements)  [CONTEXT]  private  void  combinator  (  String  combinator  )  {  tq  .  consumeWhitespace  (  )  ;  String  subQuery  =  tq  .  consumeToAny  (  combinators  )  ;  //  support  multi  >  childs  Elements  output  ;  if  (  combinator  .  equals  (   "> "  )  )  output  =  filterForChildren  (  elements  ,  select  (  subQuery  ,  elements  )  )  ;  else  if  (  combinator  .  equals  (   "   "  )  )  output  =  filterForDescendants  (  elements  ,  select  (  subQuery  ,  elements  )  )  ;  else  if  (  combinator  .  equals  (   "+ "  )  )  output  =  filterForAdjacentSiblings  (  elements  ,  select  (  subQuery  ,  root  )  )  ;  else  if  (  combinator  .  equals  (   "~ "  )  )  output  =  filterForGeneralSiblings  (  elements  ,  select  (  subQuery  ,  root  )  )  ;  else  throw  new  IllegalStateException  (   "Unknown  combinator:   "  +  combinator  )  ;    [ATTENTION]  elements  .  clear  (  )    ;  elements  .  add  (  output  )    ;  }    [METHOD]  combinator  [TYPE]  void  [PARAMETER]  String  combinator  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  Element  root  [TYPE]  String[]  combinators  [TYPE]  String  combinator  query  s  subQuery  [TYPE]  Elements  output  
[REPLACE]  if  (  tq  .  matchChomp  (   "# "  )  )  {	[BUGGY]  if  (  tq  .  matchChomp  (   "  ,   "  )  )  {[FE]  Could  not  parse  query  #foo  assertEquals(1  ,  els.size())  ;  assertEquals( "Hello "  ,  els.get(0).text())  ;  assertEquals(0  ,  none.size())  ;  [CONTEXT]  private  Elements  findElements  (  )  {  [ATTENTION]  if  (  tq  .  matchChomp  (   "  ,   "  )  )  {  return  byId  (  )  ;  }  else  if  (  tq  .  matchChomp  (   "  .   "  )  )  {  return  byClass  (  )  ;  }  else  if  (  tq  .  matchesWord  (  )  )  {  return  byTag  (  )  ;  }  else  if  (  tq  .  matchChomp  (   "[ "  )  )  {  return  byAttribute  (  )  ;  }  else  if  (  tq  .  matchChomp  (   "* "  )  )  {  return  allElements  (  )  ;  }  else  if  (  tq  .  matchChomp  (   ":lt  (   "  )  )  {  return  indexLessThan  (  )  ;  }  else  if  (  tq  .  matchChomp  (   ":gt  (   "  )  )  {  return  indexGreaterThan  (  )  ;  }  else  if  (  tq  .  matchChomp  (   ":eq  (   "  )  )  {  return  indexEquals  (  )  ;  }  else  {  //  unhandled  throw  new  SelectorParseException  (   "Could  not  parse  query   "  +  query  )  ;  }  }    [METHOD]  findElements  [TYPE]  Elements  [PARAMETER]  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  String[]  combinators  [TYPE]  String  combinator  query  s  subQuery  [TYPE]  boolean  false  true  [TYPE]  Element  root  
[REPLACE]  }  else  if  (  tq  .  matchChomp  (   "  .   "  )  )  {	[BUGGY]  else  if  (  tq  .  matchesWord  (  )  )  {[FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  private  Elements  findElements  (  )  {  if  (  tq  .  matchChomp  (   "# "  )  )  {  return  byId  (  )  ;  [ATTENTION]  }  else  if  (  tq  .  matchesWord  (  )  )  {  return  byClass  (  )  ;  }  else  if  (  tq  .  matchesWord  (  )  )  {  return  byTag  (  )  ;  }  else  if  (  tq  .  matchChomp  (   "[ "  )  )  {  return  byAttribute  (  )  ;  }  else  if  (  tq  .  matchChomp  (   "* "  )  )  {  return  allElements  (  )  ;  }  else  if  (  tq  .  matchChomp  (   ":lt  (   "  )  )  {  return  indexLessThan  (  )  ;  }  else  if  (  tq  .  matchChomp  (   ":gt  (   "  )  )  {  return  indexGreaterThan  (  )  ;  }  else  if  (  tq  .  matchChomp  (   ":eq  (   "  )  )  {  return  indexEquals  (  )  ;  }  else  {  //  unhandled  throw  new  SelectorParseException  (   "Could  not  parse  query   "  +  query  )  ;  }  }    [METHOD]  findElements  [TYPE]  Elements  [PARAMETER]  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  String[]  combinators  [TYPE]  String  combinator  query  s  subQuery  [TYPE]  boolean  false  true  [TYPE]  Element  root  
[REPLACE]  }  else  if  (  tq  .  matchesWord  (  )  )  {	[BUGGY]    else  {[CE]  [CONTEXT]  private  Elements  findElements  (  )  {  if  (  tq  .  matchChomp  (   "# "  )  )  {  return  byId  (  )  ;  }  else  if  (  tq  .  matchChomp  (   "  .   "  )  )  {  return  byClass  (  )  ;  [ATTENTION]  }else  {  return  byTag  (  )  ;  }  else  if  (  tq  .  matchChomp  (   "[ "  )  )  {  return  byAttribute  (  )  ;  }  else  if  (  tq  .  matchChomp  (   "* "  )  )  {  return  allElements  (  )  ;  }  else  if  (  tq  .  matchChomp  (   ":lt  (   "  )  )  {  return  indexLessThan  (  )  ;  }  else  if  (  tq  .  matchChomp  (   ":gt  (   "  )  )  {  return  indexGreaterThan  (  )  ;  }  else  if  (  tq  .  matchChomp  (   ":eq  (   "  )  )  {  return  indexEquals  (  )  ;  }  else  {  //  unhandled  throw  new  SelectorParseException  (   "Could  not  parse  query   "  +  query  )  ;  }  }    [METHOD]  findElements  [TYPE]  Elements  [PARAMETER]  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  String[]  combinators  [TYPE]  String  combinator  query  s  subQuery  [TYPE]  boolean  false  true  [TYPE]  Element  root  
[ADD]  else  if  (  tq  .  matchesWord  (  )  )  {  return  byTag  (  )  ;  }  else  if  (  tq  .  matchChomp  (   "[ "  )  )  {  return  byAttribute  (  )  ;	[BUGGY]    return  byAttribute  (  )  ;  [CE]  illegal  start  of  type  [CONTEXT]  private  Elements  findElements  (  )  {  if  (  tq  .  matchChomp  (   "# "  )  )  {  return  byId  (  )  ;  }  else  if  (  tq  .  matchChomp  (   "  .   "  )  )  {  return  byClass  (  )  ;  [ATTENTION]  }  return  byAttribute  (  )    ;      }  else  if  (  tq  .  matchChomp  (   "* "  )  )  {  return  allElements  (  )  ;  }  else  if  (  tq  .  matchChomp  (   ":lt  (   "  )  )  {  return  indexLessThan  (  )  ;  }  else  if  (  tq  .  matchChomp  (   ":gt  (   "  )  )  {  return  indexGreaterThan  (  )  ;  }  else  if  (  tq  .  matchChomp  (   ":eq  (   "  )  )  {  return  indexEquals  (  )  ;  }  else  {  //  unhandled  throw  new  SelectorParseException  (   "Could  not  parse  query   "  +  query  )  ;  }  }    [METHOD]  findElements  [TYPE]  Elements  [PARAMETER]  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  String[]  combinators  [TYPE]  String  combinator  query  s  subQuery  [TYPE]  boolean  false  true  [TYPE]  Element  root  
[REPLACE]  }  else  if  (  tq  .  matchChomp  (   "[ "  )  )  {	[BUGGY]  else  if  (  tq  .  matchesWord  (  )  )  {[FE]  Could  not  parse  query  a[href  =  t/2322m2]  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  private  Elements  findElements  (  )  {  if  (  tq  .  matchChomp  (   "# "  )  )  {  return  byId  (  )  ;  }  else  if  (  tq  .  matchChomp  (   "  .   "  )  )  {  return  byClass  (  )  ;  }  else  if  (  tq  .  matchesWord  (  )  )  {  return  byTag  (  )  ;  [ATTENTION]  }  else  if  (  tq  .  matchesWord  (  )  )  {  return  byAttribute  (  )  ;  }  else  if  (  tq  .  matchChomp  (   "* "  )  )  {  return  allElements  (  )  ;  }  else  if  (  tq  .  matchChomp  (   ":lt  (   "  )  )  {  return  indexLessThan  (  )  ;  }  else  if  (  tq  .  matchChomp  (   ":gt  (   "  )  )  {  return  indexGreaterThan  (  )  ;  }  else  if  (  tq  .  matchChomp  (   ":eq  (   "  )  )  {  return  indexEquals  (  )  ;  }  else  {  //  unhandled  throw  new  SelectorParseException  (   "Could  not  parse  query   "  +  query  )  ;  }  }    [METHOD]  findElements  [TYPE]  Elements  [PARAMETER]  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  String[]  combinators  [TYPE]  String  combinator  query  s  subQuery  [TYPE]  boolean  false  true  [TYPE]  Element  root  
[ADD]  else  if  (  tq  .  matchChomp  (   "[ "  )  )  {  return  byAttribute  (  )  ;  }  else  if  (  tq  .  matchChomp  (   "* "  )  )  {  return  allElements  (  )  ;	[BUGGY]    return  allElements  (  )  ;  [CE]  illegal  start  of  type  [CONTEXT]  private  Elements  findElements  (  )  {  if  (  tq  .  matchChomp  (   "# "  )  )  {  return  byId  (  )  ;  }  else  if  (  tq  .  matchChomp  (   "  .   "  )  )  {  return  byClass  (  )  ;  }  else  if  (  tq  .  matchesWord  (  )  )  {  return  byTag  (  )  ;  [ATTENTION]  }  return  allElements  (  )    ;      }  else  if  (  tq  .  matchChomp  (   ":lt  (   "  )  )  {  return  indexLessThan  (  )  ;  }  else  if  (  tq  .  matchChomp  (   ":gt  (   "  )  )  {  return  indexGreaterThan  (  )  ;  }  else  if  (  tq  .  matchChomp  (   ":eq  (   "  )  )  {  return  indexEquals  (  )  ;  }  else  {  //  unhandled  throw  new  SelectorParseException  (   "Could  not  parse  query   "  +  query  )  ;  }  }    [METHOD]  findElements  [TYPE]  Elements  [PARAMETER]  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  String[]  combinators  [TYPE]  String  combinator  query  s  subQuery  [TYPE]  boolean  false  true  [TYPE]  Element  root  
[REPLACE]  }  else  if  (  tq  .  matchChomp  (   "* "  )  )  {	[BUGGY]    if  (  tq  .  matchChomp  (   "* "  )  )  {[NO-ERROR]  [CONTEXT]  private  Elements  findElements  (  )  {  if  (  tq  .  matchChomp  (   "# "  )  )  {  return  byId  (  )  ;  }  else  if  (  tq  .  matchChomp  (   "  .   "  )  )  {  return  byClass  (  )  ;  }  else  if  (  tq  .  matchesWord  (  )  )  {  return  byTag  (  )  ;  }  else  if  (  tq  .  matchChomp  (   "[ "  )  )  {  return  byAttribute  (  )  ;  [ATTENTION]  }if  (  tq  .  matchChomp  (   "* "  )  )  {  return  allElements  (  )  ;  }  else  if  (  tq  .  matchChomp  (   ":lt  (   "  )  )  {  return  indexLessThan  (  )  ;  }  else  if  (  tq  .  matchChomp  (   ":gt  (   "  )  )  {  return  indexGreaterThan  (  )  ;  }  else  if  (  tq  .  matchChomp  (   ":eq  (   "  )  )  {  return  indexEquals  (  )  ;  }  else  {  //  unhandled  throw  new  SelectorParseException  (   "Could  not  parse  query   "  +  query  )  ;  }  }    [METHOD]  findElements  [TYPE]  Elements  [PARAMETER]  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  String[]  combinators  [TYPE]  String  combinator  query  s  subQuery  [TYPE]  boolean  false  true  [TYPE]  Element  root  
[REPLACE]  }  else  if  (  tq  .  matchChomp  (   ":lt  (   "  )  )  {	[BUGGY]  else  if  (  tq  .  matchChomp  (   "  .   "  )  )  {[FE]  Could  not  parse  query  p:gt(0  assertEquals(1  ,  ps.size())  ;  assertEquals( "Two "  ,  ps.get(0).text())  ;  [CONTEXT]  private  Elements  findElements  (  )  {  if  (  tq  .  matchChomp  (   "# "  )  )  {  return  byId  (  )  ;  }  else  if  (  tq  .  matchChomp  (   "  .   "  )  )  {  return  byClass  (  )  ;  }  else  if  (  tq  .  matchesWord  (  )  )  {  return  byTag  (  )  ;  }  else  if  (  tq  .  matchChomp  (   "[ "  )  )  {  return  byAttribute  (  )  ;  }  else  if  (  tq  .  matchChomp  (   "* "  )  )  {  return  allElements  (  )  ;  [ATTENTION]  }  else  if  (  tq  .  matchChomp  (   "  .   "  )  )  {  return  indexLessThan  (  )  ;  }  else  if  (  tq  .  matchChomp  (   ":gt  (   "  )  )  {  return  indexGreaterThan  (  )  ;  }  else  if  (  tq  .  matchChomp  (   ":eq  (   "  )  )  {  return  indexEquals  (  )  ;  }  else  {  //  unhandled  throw  new  SelectorParseException  (   "Could  not  parse  query   "  +  query  )  ;  }  }    [METHOD]  findElements  [TYPE]  Elements  [PARAMETER]  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  String[]  combinators  [TYPE]  String  combinator  query  s  subQuery  [TYPE]  boolean  false  true  [TYPE]  Element  root  
[REPLACE]  }  else  if  (  tq  .  matchChomp  (   ":gt  (   "  )  )  {	[BUGGY]    else  {[CE]  [CONTEXT]  private  Elements  findElements  (  )  {  if  (  tq  .  matchChomp  (   "# "  )  )  {  return  byId  (  )  ;  }  else  if  (  tq  .  matchChomp  (   "  .   "  )  )  {  return  byClass  (  )  ;  }  else  if  (  tq  .  matchesWord  (  )  )  {  return  byTag  (  )  ;  }  else  if  (  tq  .  matchChomp  (   "[ "  )  )  {  return  byAttribute  (  )  ;  }  else  if  (  tq  .  matchChomp  (   "* "  )  )  {  return  allElements  (  )  ;  }  else  if  (  tq  .  matchChomp  (   ":lt  (   "  )  )  {  return  indexLessThan  (  )  ;  [ATTENTION]  }else  {  return  indexGreaterThan  (  )  ;  }  else  if  (  tq  .  matchChomp  (   ":eq  (   "  )  )  {  return  indexEquals  (  )  ;  }  else  {  //  unhandled  throw  new  SelectorParseException  (   "Could  not  parse  query   "  +  query  )  ;  }  }    [METHOD]  findElements  [TYPE]  Elements  [PARAMETER]  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  String[]  combinators  [TYPE]  String  combinator  query  s  subQuery  [TYPE]  boolean  false  true  [TYPE]  Element  root  
[ADD]  else  if  (  tq  .  matchChomp  (   ":gt  (   "  )  )  {  return  indexGreaterThan  (  )  ;  }  else  if  (  tq  .  matchChomp  (   ":eq  (   "  )  )  {  return  indexEquals  (  )  ;	[BUGGY]    return  indexEquals  (  )  ;  [CE]  illegal  start  of  type  [CONTEXT]  private  Elements  findElements  (  )  {  if  (  tq  .  matchChomp  (   "# "  )  )  {  return  byId  (  )  ;  }  else  if  (  tq  .  matchChomp  (   "  .   "  )  )  {  return  byClass  (  )  ;  }  else  if  (  tq  .  matchesWord  (  )  )  {  return  byTag  (  )  ;  }  else  if  (  tq  .  matchChomp  (   "[ "  )  )  {  return  byAttribute  (  )  ;  }  else  if  (  tq  .  matchChomp  (   "* "  )  )  {  return  allElements  (  )  ;  }  else  if  (  tq  .  matchChomp  (   ":lt  (   "  )  )  {  return  indexLessThan  (  )  ;  [ATTENTION]  }  return  indexEquals  (  )    ;      }  else  {  //  unhandled  throw  new  SelectorParseException  (   "Could  not  parse  query   "  +  query  )  ;  }  }    [METHOD]  findElements  [TYPE]  Elements  [PARAMETER]  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  String[]  combinators  [TYPE]  String  combinator  query  s  subQuery  [TYPE]  boolean  false  true  [TYPE]  Element  root  
[REPLACE]  }  else  if  (  tq  .  matchChomp  (   ":eq  (   "  )  )  {	[BUGGY]    else  {[CE]  'else'  without  'if'  [CONTEXT]  private  Elements  findElements  (  )  {  if  (  tq  .  matchChomp  (   "# "  )  )  {  return  byId  (  )  ;  }  else  if  (  tq  .  matchChomp  (   "  .   "  )  )  {  return  byClass  (  )  ;  }  else  if  (  tq  .  matchesWord  (  )  )  {  return  byTag  (  )  ;  }  else  if  (  tq  .  matchChomp  (   "[ "  )  )  {  return  byAttribute  (  )  ;  }  else  if  (  tq  .  matchChomp  (   "* "  )  )  {  return  allElements  (  )  ;  }  else  if  (  tq  .  matchChomp  (   ":lt  (   "  )  )  {  return  indexLessThan  (  )  ;  }  else  if  (  tq  .  matchChomp  (   ":gt  (   "  )  )  {  return  indexGreaterThan  (  )  ;  [ATTENTION]  }else  {  return  indexEquals  (  )  ;  }  else  {  //  unhandled  throw  new  SelectorParseException  (   "Could  not  parse  query   "  +  query  )  ;  }  }    [METHOD]  findElements  [TYPE]  Elements  [PARAMETER]  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  String[]  combinators  [TYPE]  String  combinator  query  s  subQuery  [TYPE]  boolean  false  true  [TYPE]  Element  root  
[REPLACE]  throw  new  SelectorParseException  ( "   ")  ;	[BUGGY]  return  ;  [CE]  missing  return  value  [CONTEXT]  private  Elements  findElements  (  )  {  if  (  tq  .  matchChomp  (   "# "  )  )  {  return  byId  (  )  ;  }  else  if  (  tq  .  matchChomp  (   "  .   "  )  )  {  return  byClass  (  )  ;  }  else  if  (  tq  .  matchesWord  (  )  )  {  return  byTag  (  )  ;  }  else  if  (  tq  .  matchChomp  (   "[ "  )  )  {  return  byAttribute  (  )  ;  }  else  if  (  tq  .  matchChomp  (   "* "  )  )  {  return  allElements  (  )  ;  }  else  if  (  tq  .  matchChomp  (   ":lt  (   "  )  )  {  return  indexLessThan  (  )  ;  }  else  if  (  tq  .  matchChomp  (   ":gt  (   "  )  )  {  return  indexGreaterThan  (  )  ;  }  else  if  (  tq  .  matchChomp  (   ":eq  (   "  )  )  {  return  indexEquals  (  )  ;  }  else  {  //  unhandled  [ATTENTION]  return  ;  }  }    [METHOD]  findElements  [TYPE]  Elements  [PARAMETER]  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  String[]  combinators  [TYPE]  String  combinator  query  s  subQuery  [TYPE]  boolean  false  true  [TYPE]  Element  root  
[REPLACE]  return  indexEquals  (  )  ;	[BUGGY]  return  byTag  (  )  ;  [FE]  Could  not  parse  query  p:eq(0)  assertEquals(2  ,  ps.size())  ;  assertEquals( "One "  ,  ps.get(0).text())  ;  assertEquals( "Four "  ,  ps.get(1).text())  ;  assertEquals(1  ,  ps2.size())  ;  assertEquals( "One "  ,  ps2.get(0).text())  ;  assertEquals( "p "  ,  ps2.get(0).tagName())  ;  [CONTEXT]  private  Elements  findElements  (  )  {  if  (  tq  .  matchChomp  (   "# "  )  )  {  return  byId  (  )  ;  }  else  if  (  tq  .  matchChomp  (   "  .   "  )  )  {  return  byClass  (  )  ;  }  else  if  (  tq  .  matchesWord  (  )  )  {  return  byTag  (  )  ;  }  else  if  (  tq  .  matchChomp  (   "[ "  )  )  {  return  byAttribute  (  )  ;  }  else  if  (  tq  .  matchChomp  (   "* "  )  )  {  return  allElements  (  )  ;  }  else  if  (  tq  .  matchChomp  (   ":lt  (   "  )  )  {  return  indexLessThan  (  )  ;  }  else  if  (  tq  .  matchChomp  (   ":gt  (   "  )  )  {  return  indexGreaterThan  (  )  ;  }  else  if  (  tq  .  matchChomp  (   ":eq  (   "  )  )  {  [ATTENTION]  return  byTag  (  )    ;  }  else  {  //  unhandled  throw  new  SelectorParseException  (   "Could  not  parse  query   "  +  query  )  ;  }  }    [METHOD]  findElements  [TYPE]  Elements  [PARAMETER]  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  String[]  combinators  [TYPE]  String  combinator  query  s  subQuery  [TYPE]  boolean  false  true  [TYPE]  Element  root  
[REPLACE]  throw  new  SelectorParseException  ( "   ")  ;	[BUGGY]  throw  new  IllegalStateException  ( "   ")    ;    ;  [CE]  unreachable  statement  [CONTEXT]  private  Elements  findElements  (  )  {  if  (  tq  .  matchChomp  (   "# "  )  )  {  return  byId  (  )  ;  }  else  if  (  tq  .  matchChomp  (   "  .   "  )  )  {  return  byClass  (  )  ;  }  else  if  (  tq  .  matchesWord  (  )  )  {  return  byTag  (  )  ;  }  else  if  (  tq  .  matchChomp  (   "[ "  )  )  {  return  byAttribute  (  )  ;  }  else  if  (  tq  .  matchChomp  (   "* "  )  )  {  return  allElements  (  )  ;  }  else  if  (  tq  .  matchChomp  (   ":lt  (   "  )  )  {  return  indexLessThan  (  )  ;  }  else  if  (  tq  .  matchChomp  (   ":gt  (   "  )  )  {  return  indexGreaterThan  (  )  ;  }  else  if  (  tq  .  matchChomp  (   ":eq  (   "  )  )  {  return  indexEquals  (  )  ;  }  else  {  //  unhandled  [ATTENTION]  throw  new  IllegalStateException  (   "   "  )  ;    ;  }  }    [METHOD]  findElements  [TYPE]  Elements  [PARAMETER]  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  String[]  combinators  [TYPE]  String  combinator  query  s  subQuery  [TYPE]  boolean  false  true  [TYPE]  Element  root  
[REPLACE]  return  indexGreaterThan  (  )  ;	[BUGGY]  return  byTag  (  )  ;  [FE]  Could  not  parse  query  p:gt(0)  assertEquals(2  ,  ps.size())  ;  assertEquals( "Two "  ,  ps.get(0).text())  ;  assertEquals( "Three "  ,  ps.get(1).text())  ;  [CONTEXT]  private  Elements  findElements  (  )  {  if  (  tq  .  matchChomp  (   "# "  )  )  {  return  byId  (  )  ;  }  else  if  (  tq  .  matchChomp  (   "  .   "  )  )  {  return  byClass  (  )  ;  }  else  if  (  tq  .  matchesWord  (  )  )  {  return  byTag  (  )  ;  }  else  if  (  tq  .  matchChomp  (   "[ "  )  )  {  return  byAttribute  (  )  ;  }  else  if  (  tq  .  matchChomp  (   "* "  )  )  {  return  allElements  (  )  ;  }  else  if  (  tq  .  matchChomp  (   ":lt  (   "  )  )  {  return  indexLessThan  (  )  ;  }  else  if  (  tq  .  matchChomp  (   ":gt  (   "  )  )  {  [ATTENTION]  return  byTag  (  )    ;  }  else  if  (  tq  .  matchChomp  (   ":eq  (   "  )  )  {  return  indexEquals  (  )  ;  }  else  {  //  unhandled  throw  new  SelectorParseException  (   "Could  not  parse  query   "  +  query  )  ;  }  }    [METHOD]  findElements  [TYPE]  Elements  [PARAMETER]  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  String[]  combinators  [TYPE]  String  combinator  query  s  subQuery  [TYPE]  boolean  false  true  [TYPE]  Element  root  
[REPLACE]  }  else  if  (  tq  .  matchChomp  (   ":eq  (   "  )  )  {	[BUGGY]    if  (  tq  .  matchChomp  (   ":eq  (   "  )  )  {[FE]  Could  not  parse  query  p:eq(0)  assertEquals(2  ,  ps.size())  ;  assertEquals( "One "  ,  ps.get(0).text())  ;  assertEquals( "Four "  ,  ps.get(1).text())  ;  assertEquals(1  ,  ps2.size())  ;  assertEquals( "One "  ,  ps2.get(0).text())  ;  assertEquals( "p "  ,  ps2.get(0).tagName())  ;  [CONTEXT]  private  Elements  findElements  (  )  {  if  (  tq  .  matchChomp  (   "# "  )  )  {  return  byId  (  )  ;  }  else  if  (  tq  .  matchChomp  (   "  .   "  )  )  {  return  byClass  (  )  ;  }  else  if  (  tq  .  matchesWord  (  )  )  {  return  byTag  (  )  ;  }  else  if  (  tq  .  matchChomp  (   "[ "  )  )  {  return  byAttribute  (  )  ;  }  else  if  (  tq  .  matchChomp  (   "* "  )  )  {  return  allElements  (  )  ;  }  else  if  (  tq  .  matchChomp  (   ":lt  (   "  )  )  {  return  indexLessThan  (  )  ;  }  else  if  (  tq  .  matchChomp  (   ":gt  (   "  )  )  {  return  indexGreaterThan  (  )  ;  [ATTENTION]  }if  (  tq  .  matchChomp  (   ":eq  (   "  )  )  {  return  indexEquals  (  )  ;  }  else  {  //  unhandled  throw  new  SelectorParseException  (   "Could  not  parse  query   "  +  query  )  ;  }  }    [METHOD]  findElements  [TYPE]  Elements  [PARAMETER]  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  String[]  combinators  [TYPE]  String  combinator  query  s  subQuery  [TYPE]  boolean  false  true  [TYPE]  Element  root  
[REMOVE]  	[BUGGY]  if  (  tq  .  matchChomp  (   "*  =   "  )  )      return  root  .  getElementsByAttributeValueContaining  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;  else      throw  new  SelectorParseException  (  (   "Could  not  parse  attribute  query   "  +  (  query  )  )  )  ;  [CE]  cannot  find  symbol  key  [CONTEXT]  private  Elements  findElements  (  )  {  if  (  tq  .  matchChomp  (   "# "  )  )  {  return  byId  (  )  ;  }  else  if  (  tq  .  matchChomp  (   "  .   "  )  )  {  return  byClass  (  )  ;  }  else  if  (  tq  .  matchesWord  (  )  )  {  return  byTag  (  )  ;  }  else  if  (  tq  .  matchChomp  (   "[ "  )  )  {  return  byAttribute  (  )  ;  }  else  if  (  tq  .  matchChomp  (   "* "  )  )  {  return  allElements  (  )  ;  }  else  if  (  tq  .  matchChomp  (   ":lt  (   "  )  )  {  return  indexLessThan  (  )  ;  }  else  if  (  tq  .  matchChomp  (   ":gt  (   "  )  )  {  return  indexGreaterThan  (  )  ;  [ATTENTION]  }  else  if  (  tq  .  matchChomp  (   ":eq  (   "  )  )  {  if  (  tq  .  matchChomp  (   "*  =   "  )  )  return  root  .  getElementsByAttributeValueContaining  (  key  ,  tq  .  chompTo  (   "] "  )  )    ;  else  throw  new  SelectorParseException  (  (   "Could  not  parse  attribute  query   "  +  (  query  )  )  )    ;  return  indexEquals  (  )  ;  }  else  {  //  unhandled  throw  new  SelectorParseException  (   "Could  not  parse  query   "  +  query  )  ;  }    [METHOD]  findElements  [TYPE]  Elements  [PARAMETER]  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  String[]  combinators  [TYPE]  String  combinator  query  s  subQuery  [TYPE]  boolean  false  true  [TYPE]  Element  root  
[REPLACE]  return  indexLessThan  (  )  ;	[BUGGY]  return  byTag  (  )  ;  [FE]  Could  not  parse  query  p:gt(0  assertEquals(1  ,  ps.size())  ;  assertEquals( "Two "  ,  ps.get(0).text())  ;  [CONTEXT]  private  Elements  findElements  (  )  {  if  (  tq  .  matchChomp  (   "# "  )  )  {  return  byId  (  )  ;  }  else  if  (  tq  .  matchChomp  (   "  .   "  )  )  {  return  byClass  (  )  ;  }  else  if  (  tq  .  matchesWord  (  )  )  {  return  byTag  (  )  ;  }  else  if  (  tq  .  matchChomp  (   "[ "  )  )  {  return  byAttribute  (  )  ;  }  else  if  (  tq  .  matchChomp  (   "* "  )  )  {  return  allElements  (  )  ;  }  else  if  (  tq  .  matchChomp  (   ":lt  (   "  )  )  {  [ATTENTION]  return  byTag  (  )    ;  }  else  if  (  tq  .  matchChomp  (   ":gt  (   "  )  )  {  return  indexGreaterThan  (  )  ;  }  else  if  (  tq  .  matchChomp  (   ":eq  (   "  )  )  {  return  indexEquals  (  )  ;  }  else  {  //  unhandled  throw  new  SelectorParseException  (   "Could  not  parse  query   "  +  query  )  ;  }  }    [METHOD]  findElements  [TYPE]  Elements  [PARAMETER]  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  String[]  combinators  [TYPE]  String  combinator  query  s  subQuery  [TYPE]  boolean  false  true  [TYPE]  Element  root  
[REPLACE]  }  else  if  (  tq  .  matchChomp  (   ":gt  (   "  )  )  {	[BUGGY]  else  if  (  tq  .  matchChomp  (   "  .   "  )  )  {[FE]  Could  not  parse  query  p:gt(0)  assertEquals(2  ,  ps.size())  ;  assertEquals( "Two "  ,  ps.get(0).text())  ;  assertEquals( "Three "  ,  ps.get(1).text())  ;  [CONTEXT]  private  Elements  findElements  (  )  {  if  (  tq  .  matchChomp  (   "# "  )  )  {  return  byId  (  )  ;  }  else  if  (  tq  .  matchChomp  (   "  .   "  )  )  {  return  byClass  (  )  ;  }  else  if  (  tq  .  matchesWord  (  )  )  {  return  byTag  (  )  ;  }  else  if  (  tq  .  matchChomp  (   "[ "  )  )  {  return  byAttribute  (  )  ;  }  else  if  (  tq  .  matchChomp  (   "* "  )  )  {  return  allElements  (  )  ;  }  else  if  (  tq  .  matchChomp  (   ":lt  (   "  )  )  {  return  indexLessThan  (  )  ;  [ATTENTION]  }  else  if  (  tq  .  matchChomp  (   "  .   "  )  )  {  return  indexGreaterThan  (  )  ;  }  else  if  (  tq  .  matchChomp  (   ":eq  (   "  )  )  {  return  indexEquals  (  )  ;  }  else  {  //  unhandled  throw  new  SelectorParseException  (   "Could  not  parse  query   "  +  query  )  ;  }  }    [METHOD]  findElements  [TYPE]  Elements  [PARAMETER]  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  String[]  combinators  [TYPE]  String  combinator  query  s  subQuery  [TYPE]  boolean  false  true  [TYPE]  Element  root  
[ADD]  else  if  (  tq  .  matchChomp  (   ":eq  (   "  )  )  {  return  indexEquals  (  )  ;  }  else  {  throw  new  SelectorParseException  ( "   ")  ;  }	[BUGGY]    return  indexEquals  (  )  ;  [FE]  Index  must  be  numeric  assertEquals(2  ,  ps.size())  ;  assertEquals( "One "  ,  ps.get(0).text())  ;  assertEquals( "Four "  ,  ps.get(1).text())  ;  assertEquals(1  ,  ps2.size())  ;  assertEquals( "One "  ,  ps2.get(0).text())  ;  assertEquals( "p "  ,  ps2.get(0).tagName())  ;  [CONTEXT]  private  Elements  findElements  (  )  {  if  (  tq  .  matchChomp  (   "# "  )  )  {  return  byId  (  )  ;  }  else  if  (  tq  .  matchChomp  (   "  .   "  )  )  {  return  byClass  (  )  ;  }  else  if  (  tq  .  matchesWord  (  )  )  {  return  byTag  (  )  ;  }  else  if  (  tq  .  matchChomp  (   "[ "  )  )  {  return  byAttribute  (  )  ;  }  else  if  (  tq  .  matchChomp  (   "* "  )  )  {  return  allElements  (  )  ;  }  else  if  (  tq  .  matchChomp  (   ":lt  (   "  )  )  {  return  indexLessThan  (  )  ;  }  else  if  (  tq  .  matchChomp  (   ":gt  (   "  )  )  {  return  indexGreaterThan  (  )  ;  [ATTENTION]  }  return  indexEquals  (  )    ;      }    [METHOD]  findElements  [TYPE]  Elements  [PARAMETER]  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  String[]  combinators  [TYPE]  String  combinator  query  s  subQuery  [TYPE]  boolean  false  true  [TYPE]  Element  root  
[ADD]  throw  new  SelectorParseException  ( "   ")  ;	[BUGGY]  [CE]  missing  return  statement  [CONTEXT]  private  Elements  findElements  (  )  {  if  (  tq  .  matchChomp  (   "# "  )  )  {  return  byId  (  )  ;  }  else  if  (  tq  .  matchChomp  (   "  .   "  )  )  {  return  byClass  (  )  ;  }  else  if  (  tq  .  matchesWord  (  )  )  {  return  byTag  (  )  ;  }  else  if  (  tq  .  matchChomp  (   "[ "  )  )  {  return  byAttribute  (  )  ;  }  else  if  (  tq  .  matchChomp  (   "* "  )  )  {  return  allElements  (  )  ;  }  else  if  (  tq  .  matchChomp  (   ":lt  (   "  )  )  {  return  indexLessThan  (  )  ;  }  else  if  (  tq  .  matchChomp  (   ":gt  (   "  )  )  {  return  indexGreaterThan  (  )  ;  }  else  if  (  tq  .  matchChomp  (   ":eq  (   "  )  )  {  return  indexEquals  (  )  ;  }  else  {  //  unhandled  [ATTENTION]  }  }    [METHOD]  findElements  [TYPE]  Elements  [PARAMETER]  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  String[]  combinators  [TYPE]  String  combinator  query  s  subQuery  [TYPE]  boolean  false  true  [TYPE]  Element  root  
[REPLACE]  return  allElements  (  )  ;	[BUGGY]  return  byTag  (  )  ;  [FE]  The  validated  string  is  empty  assertEquals( "The  boards  next  fear:  the  female  quota "  ,  doc.title())  ;  //  note  that  the  apos  in  the  source  is  a  literal    (8217)  ,  not  escaped  or  'assertEquals( "en "  ,  doc.select( "html ").attr( "xml:lang "))  ;  assertEquals(17  ,  articleBody.size())  ;  [CONTEXT]  private  Elements  findElements  (  )  {  if  (  tq  .  matchChomp  (   "# "  )  )  {  return  byId  (  )  ;  }  else  if  (  tq  .  matchChomp  (   "  .   "  )  )  {  return  byClass  (  )  ;  }  else  if  (  tq  .  matchesWord  (  )  )  {  return  byTag  (  )  ;  }  else  if  (  tq  .  matchChomp  (   "[ "  )  )  {  return  byAttribute  (  )  ;  }  else  if  (  tq  .  matchChomp  (   "* "  )  )  {  [ATTENTION]  return  byTag  (  )    ;  }  else  if  (  tq  .  matchChomp  (   ":lt  (   "  )  )  {  return  indexLessThan  (  )  ;  }  else  if  (  tq  .  matchChomp  (   ":gt  (   "  )  )  {  return  indexGreaterThan  (  )  ;  }  else  if  (  tq  .  matchChomp  (   ":eq  (   "  )  )  {  return  indexEquals  (  )  ;  }  else  {  //  unhandled  throw  new  SelectorParseException  (   "Could  not  parse  query   "  +  query  )  ;  }  }    [METHOD]  findElements  [TYPE]  Elements  [PARAMETER]  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  String[]  combinators  [TYPE]  String  combinator  query  s  subQuery  [TYPE]  boolean  false  true  [TYPE]  Element  root  
[REPLACE]  }  else  if  (  tq  .  matchChomp  (   ":lt  (   "  )  )  {	[BUGGY]    if  (  tq  .  matchChomp  (   ":lt  (   "  )  )  {[FE]  Could  not  parse  query  p:gt(0  assertEquals(1  ,  ps.size())  ;  assertEquals( "Two "  ,  ps.get(0).text())  ;  [CONTEXT]  private  Elements  findElements  (  )  {  if  (  tq  .  matchChomp  (   "# "  )  )  {  return  byId  (  )  ;  }  else  if  (  tq  .  matchChomp  (   "  .   "  )  )  {  return  byClass  (  )  ;  }  else  if  (  tq  .  matchesWord  (  )  )  {  return  byTag  (  )  ;  }  else  if  (  tq  .  matchChomp  (   "[ "  )  )  {  return  byAttribute  (  )  ;  }  else  if  (  tq  .  matchChomp  (   "* "  )  )  {  return  allElements  (  )  ;  [ATTENTION]  }if  (  tq  .  matchChomp  (   ":lt  (   "  )  )  {  return  indexLessThan  (  )  ;  }  else  if  (  tq  .  matchChomp  (   ":gt  (   "  )  )  {  return  indexGreaterThan  (  )  ;  }  else  if  (  tq  .  matchChomp  (   ":eq  (   "  )  )  {  return  indexEquals  (  )  ;  }  else  {  //  unhandled  throw  new  SelectorParseException  (   "Could  not  parse  query   "  +  query  )  ;  }  }    [METHOD]  findElements  [TYPE]  Elements  [PARAMETER]  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  String[]  combinators  [TYPE]  String  combinator  query  s  subQuery  [TYPE]  boolean  false  true  [TYPE]  Element  root  
[ADD]  else  if  (  tq  .  matchChomp  (   ":lt  (   "  )  )  {  return  indexLessThan  (  )  ;  }  else  if  (  tq  .  matchChomp  (   ":gt  (   "  )  )  {  return  indexGreaterThan  (  )  ;	[BUGGY]    return  indexLessThan  (  )  ;  return  indexGreaterThan  (  )  ;  [CE]  illegal  start  of  type  [CONTEXT]  private  Elements  findElements  (  )  {  if  (  tq  .  matchChomp  (   "# "  )  )  {  return  byId  (  )  ;  }  else  if  (  tq  .  matchChomp  (   "  .   "  )  )  {  return  byClass  (  )  ;  }  else  if  (  tq  .  matchesWord  (  )  )  {  return  byTag  (  )  ;  }  else  if  (  tq  .  matchChomp  (   "[ "  )  )  {  return  byAttribute  (  )  ;  }  else  if  (  tq  .  matchChomp  (   "* "  )  )  {  return  allElements  (  )  ;  [ATTENTION]  }  return  indexLessThan  (  )    ;  return  indexGreaterThan  (  )    ;      }  else  if  (  tq  .  matchChomp  (   ":eq  (   "  )  )  {  return  indexEquals  (  )  ;  }  else  {  //  unhandled  throw  new  SelectorParseException  (   "Could  not  parse  query   "  +  query  )  ;  }  }    [METHOD]  findElements  [TYPE]  Elements  [PARAMETER]  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  String[]  combinators  [TYPE]  String  combinator  query  s  subQuery  [TYPE]  boolean  false  true  [TYPE]  Element  root  
[REPLACE]  }  else  if  (  tq  .  matchChomp  (   ":eq  (   "  )  )  {	[BUGGY]    if  (  tq  .  matchesAny  (   ":eq  (   "  )  )  {[FE]  Could  not  parse  query  p:eq(0)  assertEquals(2  ,  ps.size())  ;  assertEquals( "One "  ,  ps.get(0).text())  ;  assertEquals( "Four "  ,  ps.get(1).text())  ;  assertEquals(1  ,  ps2.size())  ;  assertEquals( "One "  ,  ps2.get(0).text())  ;  assertEquals( "p "  ,  ps2.get(0).tagName())  ;  [CONTEXT]  private  Elements  findElements  (  )  {  if  (  tq  .  matchChomp  (   "# "  )  )  {  return  byId  (  )  ;  }  else  if  (  tq  .  matchChomp  (   "  .   "  )  )  {  return  byClass  (  )  ;  }  else  if  (  tq  .  matchesWord  (  )  )  {  return  byTag  (  )  ;  }  else  if  (  tq  .  matchChomp  (   "[ "  )  )  {  return  byAttribute  (  )  ;  }  else  if  (  tq  .  matchChomp  (   "* "  )  )  {  return  allElements  (  )  ;  }  else  if  (  tq  .  matchChomp  (   ":lt  (   "  )  )  {  return  indexLessThan  (  )  ;  }  else  if  (  tq  .  matchChomp  (   ":gt  (   "  )  )  {  return  indexGreaterThan  (  )  ;  [ATTENTION]  }if  (  tq  .  matchesAny  (   ":eq  (   "  )  )  {  return  indexEquals  (  )  ;  }  else  {  //  unhandled  throw  new  SelectorParseException  (   "Could  not  parse  query   "  +  query  )  ;  }  }    [METHOD]  findElements  [TYPE]  Elements  [PARAMETER]  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  String[]  combinators  [TYPE]  String  combinator  query  s  subQuery  [TYPE]  boolean  false  true  [TYPE]  Element  root  
[ADD]  else  if  (  tq  .  matchChomp  (   ":gt  (   "  )  )  {  return  indexGreaterThan  (  )  ;  }  else  if  (  tq  .  matchChomp  (   ":eq  (   "  )  )  {  return  indexEquals  (  )  ;	[BUGGY]    return  indexGreaterThan  (  )  ;  return  indexEquals  (  )  ;  [CE]  illegal  start  of  type  [CONTEXT]  private  Elements  findElements  (  )  {  if  (  tq  .  matchChomp  (   "# "  )  )  {  return  byId  (  )  ;  }  else  if  (  tq  .  matchChomp  (   "  .   "  )  )  {  return  byClass  (  )  ;  }  else  if  (  tq  .  matchesWord  (  )  )  {  return  byTag  (  )  ;  }  else  if  (  tq  .  matchChomp  (   "[ "  )  )  {  return  byAttribute  (  )  ;  }  else  if  (  tq  .  matchChomp  (   "* "  )  )  {  return  allElements  (  )  ;  }  else  if  (  tq  .  matchChomp  (   ":lt  (   "  )  )  {  return  indexLessThan  (  )  ;  [ATTENTION]  }  return  indexGreaterThan  (  )    ;  return  indexEquals  (  )    ;      }  else  {  //  unhandled  throw  new  SelectorParseException  (   "Could  not  parse  query   "  +  query  )  ;  }  }    [METHOD]  findElements  [TYPE]  Elements  [PARAMETER]  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  String[]  combinators  [TYPE]  String  combinator  query  s  subQuery  [TYPE]  boolean  false  true  [TYPE]  Element  root  
[ADD]  else  if  (  tq  .  matchChomp  (   ":eq  (   "  )  )  {  return  indexEquals  (  )  ;  }  else  {  throw  new  SelectorParseException  ( "   ")  ;  }	[BUGGY]  [CE]  missing  return  statement  [CONTEXT]  private  Elements  findElements  (  )  {  if  (  tq  .  matchChomp  (   "# "  )  )  {  return  byId  (  )  ;  }  else  if  (  tq  .  matchChomp  (   "  .   "  )  )  {  return  byClass  (  )  ;  }  else  if  (  tq  .  matchesWord  (  )  )  {  return  byTag  (  )  ;  }  else  if  (  tq  .  matchChomp  (   "[ "  )  )  {  return  byAttribute  (  )  ;  }  else  if  (  tq  .  matchChomp  (   "* "  )  )  {  return  allElements  (  )  ;  }  else  if  (  tq  .  matchChomp  (   ":lt  (   "  )  )  {  return  indexLessThan  (  )  ;  }  else  if  (  tq  .  matchChomp  (   ":gt  (   "  )  )  {  return  indexGreaterThan  (  )  ;  [ATTENTION]  }      }    [METHOD]  findElements  [TYPE]  Elements  [PARAMETER]  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  String[]  combinators  [TYPE]  String  combinator  query  s  subQuery  [TYPE]  boolean  false  true  [TYPE]  Element  root  
[REPLACE]  return  byAttribute  (  )  ;	[BUGGY]  return  byTag  (  )  ;  [FE]  Could  not  parse  query  a[href  =  t/2322m2]  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  private  Elements  findElements  (  )  {  if  (  tq  .  matchChomp  (   "# "  )  )  {  return  byId  (  )  ;  }  else  if  (  tq  .  matchChomp  (   "  .   "  )  )  {  return  byClass  (  )  ;  }  else  if  (  tq  .  matchesWord  (  )  )  {  return  byTag  (  )  ;  }  else  if  (  tq  .  matchChomp  (   "[ "  )  )  {  [ATTENTION]  return  byTag  (  )    ;  }  else  if  (  tq  .  matchChomp  (   "* "  )  )  {  return  allElements  (  )  ;  }  else  if  (  tq  .  matchChomp  (   ":lt  (   "  )  )  {  return  indexLessThan  (  )  ;  }  else  if  (  tq  .  matchChomp  (   ":gt  (   "  )  )  {  return  indexGreaterThan  (  )  ;  }  else  if  (  tq  .  matchChomp  (   ":eq  (   "  )  )  {  return  indexEquals  (  )  ;  }  else  {  //  unhandled  throw  new  SelectorParseException  (   "Could  not  parse  query   "  +  query  )  ;  }  }    [METHOD]  findElements  [TYPE]  Elements  [PARAMETER]  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  String[]  combinators  [TYPE]  String  combinator  query  s  subQuery  [TYPE]  boolean  false  true  [TYPE]  Element  root  
[REPLACE]  }  else  if  (  tq  .  matchChomp  (   "* "  )  )  {	[BUGGY]    else  {[CE]  [CONTEXT]  private  Elements  findElements  (  )  {  if  (  tq  .  matchChomp  (   "# "  )  )  {  return  byId  (  )  ;  }  else  if  (  tq  .  matchChomp  (   "  .   "  )  )  {  return  byClass  (  )  ;  }  else  if  (  tq  .  matchesWord  (  )  )  {  return  byTag  (  )  ;  }  else  if  (  tq  .  matchChomp  (   "[ "  )  )  {  return  byAttribute  (  )  ;  [ATTENTION]  }else  {  return  allElements  (  )  ;  }  else  if  (  tq  .  matchChomp  (   ":lt  (   "  )  )  {  return  indexLessThan  (  )  ;  }  else  if  (  tq  .  matchChomp  (   ":gt  (   "  )  )  {  return  indexGreaterThan  (  )  ;  }  else  if  (  tq  .  matchChomp  (   ":eq  (   "  )  )  {  return  indexEquals  (  )  ;  }  else  {  //  unhandled  throw  new  SelectorParseException  (   "Could  not  parse  query   "  +  query  )  ;  }  }    [METHOD]  findElements  [TYPE]  Elements  [PARAMETER]  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  String[]  combinators  [TYPE]  String  combinator  query  s  subQuery  [TYPE]  boolean  false  true  [TYPE]  Element  root  
[REPLACE]  }  else  if  (  tq  .  matchChomp  (   ":eq  (   "  )  )  {	[BUGGY]  else  if  (  tq  .  matchesAny  (   ":eq  (   "  )  )  {[FE]  Could  not  parse  query  p:eq(0)  assertEquals(2  ,  ps.size())  ;  assertEquals( "One "  ,  ps.get(0).text())  ;  assertEquals( "Four "  ,  ps.get(1).text())  ;  assertEquals(1  ,  ps2.size())  ;  assertEquals( "One "  ,  ps2.get(0).text())  ;  assertEquals( "p "  ,  ps2.get(0).tagName())  ;  [CONTEXT]  private  Elements  findElements  (  )  {  if  (  tq  .  matchChomp  (   "# "  )  )  {  return  byId  (  )  ;  }  else  if  (  tq  .  matchChomp  (   "  .   "  )  )  {  return  byClass  (  )  ;  }  else  if  (  tq  .  matchesWord  (  )  )  {  return  byTag  (  )  ;  }  else  if  (  tq  .  matchChomp  (   "[ "  )  )  {  return  byAttribute  (  )  ;  }  else  if  (  tq  .  matchChomp  (   "* "  )  )  {  return  allElements  (  )  ;  }  else  if  (  tq  .  matchChomp  (   ":lt  (   "  )  )  {  return  indexLessThan  (  )  ;  }  else  if  (  tq  .  matchChomp  (   ":gt  (   "  )  )  {  return  indexGreaterThan  (  )  ;  [ATTENTION]  }  else  if  (  tq  .  matchesAny  (   ":eq  (   "  )  )  {  return  indexEquals  (  )  ;  }  else  {  //  unhandled  throw  new  SelectorParseException  (   "Could  not  parse  query   "  +  query  )  ;  }  }    [METHOD]  findElements  [TYPE]  Elements  [PARAMETER]  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  String[]  combinators  [TYPE]  String  combinator  query  s  subQuery  [TYPE]  boolean  false  true  [TYPE]  Element  root  
[REPLACE]  }  else  if  (  tq  .  matchChomp  (   ":gt  (   "  )  )  {	[BUGGY]    if  (  tq  .  matchChomp  (   ":gt  (   "  )  )  {[FE]  Could  not  parse  query  p:gt(0)  assertEquals(2  ,  ps.size())  ;  assertEquals( "Two "  ,  ps.get(0).text())  ;  assertEquals( "Three "  ,  ps.get(1).text())  ;  [CONTEXT]  private  Elements  findElements  (  )  {  if  (  tq  .  matchChomp  (   "# "  )  )  {  return  byId  (  )  ;  }  else  if  (  tq  .  matchChomp  (   "  .   "  )  )  {  return  byClass  (  )  ;  }  else  if  (  tq  .  matchesWord  (  )  )  {  return  byTag  (  )  ;  }  else  if  (  tq  .  matchChomp  (   "[ "  )  )  {  return  byAttribute  (  )  ;  }  else  if  (  tq  .  matchChomp  (   "* "  )  )  {  return  allElements  (  )  ;  }  else  if  (  tq  .  matchChomp  (   ":lt  (   "  )  )  {  return  indexLessThan  (  )  ;  [ATTENTION]  }if  (  tq  .  matchChomp  (   ":gt  (   "  )  )  {  return  indexGreaterThan  (  )  ;  }  else  if  (  tq  .  matchChomp  (   ":eq  (   "  )  )  {  return  indexEquals  (  )  ;  }  else  {  //  unhandled  throw  new  SelectorParseException  (   "Could  not  parse  query   "  +  query  )  ;  }  }    [METHOD]  findElements  [TYPE]  Elements  [PARAMETER]  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  String[]  combinators  [TYPE]  String  combinator  query  s  subQuery  [TYPE]  boolean  false  true  [TYPE]  Element  root  
[REPLACE]  }  else  if  (  tq  .  matchChomp  (   ":lt  (   "  )  )  {	[BUGGY]    else  {[CE]  [CONTEXT]  private  Elements  findElements  (  )  {  if  (  tq  .  matchChomp  (   "# "  )  )  {  return  byId  (  )  ;  }  else  if  (  tq  .  matchChomp  (   "  .   "  )  )  {  return  byClass  (  )  ;  }  else  if  (  tq  .  matchesWord  (  )  )  {  return  byTag  (  )  ;  }  else  if  (  tq  .  matchChomp  (   "[ "  )  )  {  return  byAttribute  (  )  ;  }  else  if  (  tq  .  matchChomp  (   "* "  )  )  {  return  allElements  (  )  ;  [ATTENTION]  }else  {  return  indexLessThan  (  )  ;  }  else  if  (  tq  .  matchChomp  (   ":gt  (   "  )  )  {  return  indexGreaterThan  (  )  ;  }  else  if  (  tq  .  matchChomp  (   ":eq  (   "  )  )  {  return  indexEquals  (  )  ;  }  else  {  //  unhandled  throw  new  SelectorParseException  (   "Could  not  parse  query   "  +  query  )  ;  }  }    [METHOD]  findElements  [TYPE]  Elements  [PARAMETER]  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  String[]  combinators  [TYPE]  String  combinator  query  s  subQuery  [TYPE]  boolean  false  true  [TYPE]  Element  root  
[REPLACE]  }  else  if  (  tq  .  matchChomp  (   ":eq  (   "  )  )  {	[BUGGY]  else  if  (  tq  .  matchChomp  (   "  .   "  )  )  {[FE]  Could  not  parse  query  p:eq(0)  assertEquals(2  ,  ps.size())  ;  assertEquals( "One "  ,  ps.get(0).text())  ;  assertEquals( "Four "  ,  ps.get(1).text())  ;  assertEquals(1  ,  ps2.size())  ;  assertEquals( "One "  ,  ps2.get(0).text())  ;  assertEquals( "p "  ,  ps2.get(0).tagName())  ;  [CONTEXT]  private  Elements  findElements  (  )  {  if  (  tq  .  matchChomp  (   "# "  )  )  {  return  byId  (  )  ;  }  else  if  (  tq  .  matchChomp  (   "  .   "  )  )  {  return  byClass  (  )  ;  }  else  if  (  tq  .  matchesWord  (  )  )  {  return  byTag  (  )  ;  }  else  if  (  tq  .  matchChomp  (   "[ "  )  )  {  return  byAttribute  (  )  ;  }  else  if  (  tq  .  matchChomp  (   "* "  )  )  {  return  allElements  (  )  ;  }  else  if  (  tq  .  matchChomp  (   ":lt  (   "  )  )  {  return  indexLessThan  (  )  ;  }  else  if  (  tq  .  matchChomp  (   ":gt  (   "  )  )  {  return  indexGreaterThan  (  )  ;  [ATTENTION]  }  else  if  (  tq  .  matchChomp  (   "  .   "  )  )  {  return  indexEquals  (  )  ;  }  else  {  //  unhandled  throw  new  SelectorParseException  (   "Could  not  parse  query   "  +  query  )  ;  }  }    [METHOD]  findElements  [TYPE]  Elements  [PARAMETER]  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  String[]  combinators  [TYPE]  String  combinator  query  s  subQuery  [TYPE]  boolean  false  true  [TYPE]  Element  root  
[REPLACE]  return  byTag  (  )  ;	[BUGGY]  return  byId  (  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  private  Elements  findElements  (  )  {  if  (  tq  .  matchChomp  (   "# "  )  )  {  return  byId  (  )  ;  }  else  if  (  tq  .  matchChomp  (   "  .   "  )  )  {  return  byClass  (  )  ;  }  else  if  (  tq  .  matchesWord  (  )  )  {  [ATTENTION]  return  byId  (  )    ;  }  else  if  (  tq  .  matchChomp  (   "[ "  )  )  {  return  byAttribute  (  )  ;  }  else  if  (  tq  .  matchChomp  (   "* "  )  )  {  return  allElements  (  )  ;  }  else  if  (  tq  .  matchChomp  (   ":lt  (   "  )  )  {  return  indexLessThan  (  )  ;  }  else  if  (  tq  .  matchChomp  (   ":gt  (   "  )  )  {  return  indexGreaterThan  (  )  ;  }  else  if  (  tq  .  matchChomp  (   ":eq  (   "  )  )  {  return  indexEquals  (  )  ;  }  else  {  //  unhandled  throw  new  SelectorParseException  (   "Could  not  parse  query   "  +  query  )  ;  }  }    [METHOD]  findElements  [TYPE]  Elements  [PARAMETER]  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  String[]  combinators  [TYPE]  String  combinator  query  s  subQuery  [TYPE]  boolean  false  true  [TYPE]  Element  root  
[REPLACE]  }  else  if  (  tq  .  matchChomp  (   "[ "  )  )  {	[BUGGY]    if  (  tq  .  matchChomp  (   "[ "  )  )  {[NO-ERROR]  [CONTEXT]  private  Elements  findElements  (  )  {  if  (  tq  .  matchChomp  (   "# "  )  )  {  return  byId  (  )  ;  }  else  if  (  tq  .  matchChomp  (   "  .   "  )  )  {  return  byClass  (  )  ;  }  else  if  (  tq  .  matchesWord  (  )  )  {  return  byTag  (  )  ;  [ATTENTION]  }if  (  tq  .  matchChomp  (   "[ "  )  )  {  return  byAttribute  (  )  ;  }  else  if  (  tq  .  matchChomp  (   "* "  )  )  {  return  allElements  (  )  ;  }  else  if  (  tq  .  matchChomp  (   ":lt  (   "  )  )  {  return  indexLessThan  (  )  ;  }  else  if  (  tq  .  matchChomp  (   ":gt  (   "  )  )  {  return  indexGreaterThan  (  )  ;  }  else  if  (  tq  .  matchChomp  (   ":eq  (   "  )  )  {  return  indexEquals  (  )  ;  }  else  {  //  unhandled  throw  new  SelectorParseException  (   "Could  not  parse  query   "  +  query  )  ;  }  }    [METHOD]  findElements  [TYPE]  Elements  [PARAMETER]  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  String[]  combinators  [TYPE]  String  combinator  query  s  subQuery  [TYPE]  boolean  false  true  [TYPE]  Element  root  
[REPLACE]  }  else  if  (  tq  .  matchChomp  (   "* "  )  )  {	[BUGGY]    if  (  tq  .  matchesAny  (   "* "  )  )  {[FE]  [CONTEXT]  private  Elements  findElements  (  )  {  if  (  tq  .  matchChomp  (   "# "  )  )  {  return  byId  (  )  ;  }  else  if  (  tq  .  matchChomp  (   "  .   "  )  )  {  return  byClass  (  )  ;  }  else  if  (  tq  .  matchesWord  (  )  )  {  return  byTag  (  )  ;  }  else  if  (  tq  .  matchChomp  (   "[ "  )  )  {  return  byAttribute  (  )  ;  [ATTENTION]  }if  (  tq  .  matchesAny  (   "* "  )  )  {  return  allElements  (  )  ;  }  else  if  (  tq  .  matchChomp  (   ":lt  (   "  )  )  {  return  indexLessThan  (  )  ;  }  else  if  (  tq  .  matchChomp  (   ":gt  (   "  )  )  {  return  indexGreaterThan  (  )  ;  }  else  if  (  tq  .  matchChomp  (   ":eq  (   "  )  )  {  return  indexEquals  (  )  ;  }  else  {  //  unhandled  throw  new  SelectorParseException  (   "Could  not  parse  query   "  +  query  )  ;  }  }    [METHOD]  findElements  [TYPE]  Elements  [PARAMETER]  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  String[]  combinators  [TYPE]  String  combinator  query  s  subQuery  [TYPE]  boolean  false  true  [TYPE]  Element  root  
[REMOVE]  	[BUGGY]  if  (  tq  .  matchChomp  (   "*  =   "  )  )      return  root  .  getElementsByAttributeValueContaining  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;  else      throw  new  SelectorParseException  (  (   "Could  not  parse  attribute  query   "  +  (  query  )  )  )  ;  [CE]  cannot  find  symbol  key  [CONTEXT]  private  Elements  findElements  (  )  {  if  (  tq  .  matchChomp  (   "# "  )  )  {  return  byId  (  )  ;  }  else  if  (  tq  .  matchChomp  (   "  .   "  )  )  {  return  byClass  (  )  ;  }  else  if  (  tq  .  matchesWord  (  )  )  {  return  byTag  (  )  ;  }  else  if  (  tq  .  matchChomp  (   "[ "  )  )  {  return  byAttribute  (  )  ;  }  else  if  (  tq  .  matchChomp  (   "* "  )  )  {  return  allElements  (  )  ;  }  else  if  (  tq  .  matchChomp  (   ":lt  (   "  )  )  {  return  indexLessThan  (  )  ;  [ATTENTION]  }  else  if  (  tq  .  matchChomp  (   ":gt  (   "  )  )  {  if  (  tq  .  matchChomp  (   "*  =   "  )  )  return  root  .  getElementsByAttributeValueContaining  (  key  ,  tq  .  chompTo  (   "] "  )  )    ;  else  throw  new  SelectorParseException  (  (   "Could  not  parse  attribute  query   "  +  (  query  )  )  )    ;  return  indexGreaterThan  (  )  ;  }  else  if  (  tq  .  matchChomp  (   ":eq  (   "  )  )  {  return  indexEquals  (  )  ;  }  else  {  //  unhandled  throw  new  SelectorParseException  (   "Could  not  parse  query   "  +  query  )  ;  }    [METHOD]  findElements  [TYPE]  Elements  [PARAMETER]  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  String[]  combinators  [TYPE]  String  combinator  query  s  subQuery  [TYPE]  boolean  false  true  [TYPE]  Element  root  
[REPLACE]  }  else  if  (  tq  .  matchChomp  (   ":eq  (   "  )  )  {	[BUGGY]    if  (  tq  .  matchesWord  (  )    {[CE]  ')'  expected  [CONTEXT]  private  Elements  findElements  (  )  {  if  (  tq  .  matchChomp  (   "# "  )  )  {  return  byId  (  )  ;  }  else  if  (  tq  .  matchChomp  (   "  .   "  )  )  {  return  byClass  (  )  ;  }  else  if  (  tq  .  matchesWord  (  )  )  {  return  byTag  (  )  ;  }  else  if  (  tq  .  matchChomp  (   "[ "  )  )  {  return  byAttribute  (  )  ;  }  else  if  (  tq  .  matchChomp  (   "* "  )  )  {  return  allElements  (  )  ;  }  else  if  (  tq  .  matchChomp  (   ":lt  (   "  )  )  {  return  indexLessThan  (  )  ;  }  else  if  (  tq  .  matchChomp  (   ":gt  (   "  )  )  {  return  indexGreaterThan  (  )  ;  [ATTENTION]  }if  (  tq  .  matchesWord  (  )  {  return  indexEquals  (  )  ;  }  else  {  //  unhandled  throw  new  SelectorParseException  (   "Could  not  parse  query   "  +  query  )  ;  }  }    [METHOD]  findElements  [TYPE]  Elements  [PARAMETER]  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  String[]  combinators  [TYPE]  String  combinator  query  s  subQuery  [TYPE]  boolean  false  true  [TYPE]  Element  root  
[REPLACE]  return  byClass  (  )  ;	[BUGGY]  return  byTag  (  )  ;  [FE]  AssertionFailedError    expected:<12>  but  was:<0>  assertEquals( "ipod  -  Google  Search "  ,  doc.title())  ;  assertEquals(12  ,  results.size())  ;  assertEquals( "http://news.google.com/news?hl  =  en&q  =  ipod&um  =  1&ie  =  UTF-8&ei  =  uYlKS4SbBoGg6gPf-5XXCw&sa  =  X&oi  =  news_group&ct  =  title&resnum  =  1&ved  =  0CCIQsQQwAA "  ,  assertEquals( "http://www.apple.com/itunes/ "  ,  [CONTEXT]  private  Elements  findElements  (  )  {  if  (  tq  .  matchChomp  (   "# "  )  )  {  return  byId  (  )  ;  }  else  if  (  tq  .  matchChomp  (   "  .   "  )  )  {  [ATTENTION]  return  byTag  (  )    ;  }  else  if  (  tq  .  matchesWord  (  )  )  {  return  byTag  (  )  ;  }  else  if  (  tq  .  matchChomp  (   "[ "  )  )  {  return  byAttribute  (  )  ;  }  else  if  (  tq  .  matchChomp  (   "* "  )  )  {  return  allElements  (  )  ;  }  else  if  (  tq  .  matchChomp  (   ":lt  (   "  )  )  {  return  indexLessThan  (  )  ;  }  else  if  (  tq  .  matchChomp  (   ":gt  (   "  )  )  {  return  indexGreaterThan  (  )  ;  }  else  if  (  tq  .  matchChomp  (   ":eq  (   "  )  )  {  return  indexEquals  (  )  ;  }  else  {  //  unhandled  throw  new  SelectorParseException  (   "Could  not  parse  query   "  +  query  )  ;  }  }    [METHOD]  findElements  [TYPE]  Elements  [PARAMETER]  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  String[]  combinators  [TYPE]  String  combinator  query  s  subQuery  [TYPE]  boolean  false  true  [TYPE]  Element  root  
[ADD]  else  if  (  tq  .  matchesWord  (  )  )  {  return  byTag  (  )  ;  }  else  if  (  tq  .  matchChomp  (   "[ "  )  )  {  return  byAttribute  (  )  ;	[BUGGY]    return  byTag  (  )  ;  return  byAttribute  (  )  ;  [CE]  illegal  start  of  type  [CONTEXT]  private  Elements  findElements  (  )  {  if  (  tq  .  matchChomp  (   "# "  )  )  {  return  byId  (  )  ;  }  else  if  (  tq  .  matchChomp  (   "  .   "  )  )  {  return  byClass  (  )  ;  [ATTENTION]  }  return  byTag  (  )    ;  return  byAttribute  (  )    ;      }  else  if  (  tq  .  matchChomp  (   "* "  )  )  {  return  allElements  (  )  ;  }  else  if  (  tq  .  matchChomp  (   ":lt  (   "  )  )  {  return  indexLessThan  (  )  ;  }  else  if  (  tq  .  matchChomp  (   ":gt  (   "  )  )  {  return  indexGreaterThan  (  )  ;  }  else  if  (  tq  .  matchChomp  (   ":eq  (   "  )  )  {  return  indexEquals  (  )  ;  }  else  {  //  unhandled  throw  new  SelectorParseException  (   "Could  not  parse  query   "  +  query  )  ;  }  }    [METHOD]  findElements  [TYPE]  Elements  [PARAMETER]  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  String[]  combinators  [TYPE]  String  combinator  query  s  subQuery  [TYPE]  boolean  false  true  [TYPE]  Element  root  
[REPLACE]  }  else  if  (  tq  .  matchChomp  (   ":gt  (   "  )  )  {	[BUGGY]    if  (  tq  .  matchesAny  (   ":gt  (   "  )  )  {[FE]  Could  not  parse  query  p:gt(0)  assertEquals(2  ,  ps.size())  ;  assertEquals( "Two "  ,  ps.get(0).text())  ;  assertEquals( "Three "  ,  ps.get(1).text())  ;  [CONTEXT]  private  Elements  findElements  (  )  {  if  (  tq  .  matchChomp  (   "# "  )  )  {  return  byId  (  )  ;  }  else  if  (  tq  .  matchChomp  (   "  .   "  )  )  {  return  byClass  (  )  ;  }  else  if  (  tq  .  matchesWord  (  )  )  {  return  byTag  (  )  ;  }  else  if  (  tq  .  matchChomp  (   "[ "  )  )  {  return  byAttribute  (  )  ;  }  else  if  (  tq  .  matchChomp  (   "* "  )  )  {  return  allElements  (  )  ;  }  else  if  (  tq  .  matchChomp  (   ":lt  (   "  )  )  {  return  indexLessThan  (  )  ;  [ATTENTION]  }if  (  tq  .  matchesAny  (   ":gt  (   "  )  )  {  return  indexGreaterThan  (  )  ;  }  else  if  (  tq  .  matchChomp  (   ":eq  (   "  )  )  {  return  indexEquals  (  )  ;  }  else  {  //  unhandled  throw  new  SelectorParseException  (   "Could  not  parse  query   "  +  query  )  ;  }  }    [METHOD]  findElements  [TYPE]  Elements  [PARAMETER]  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  String[]  combinators  [TYPE]  String  combinator  query  s  subQuery  [TYPE]  boolean  false  true  [TYPE]  Element  root  
[REPLACE]  }  else  if  (  tq  .  matchChomp  (   "[ "  )  )  {	[BUGGY]    else  {[CE]  [CONTEXT]  private  Elements  findElements  (  )  {  if  (  tq  .  matchChomp  (   "# "  )  )  {  return  byId  (  )  ;  }  else  if  (  tq  .  matchChomp  (   "  .   "  )  )  {  return  byClass  (  )  ;  }  else  if  (  tq  .  matchesWord  (  )  )  {  return  byTag  (  )  ;  [ATTENTION]  }else  {  return  byAttribute  (  )  ;  }  else  if  (  tq  .  matchChomp  (   "* "  )  )  {  return  allElements  (  )  ;  }  else  if  (  tq  .  matchChomp  (   ":lt  (   "  )  )  {  return  indexLessThan  (  )  ;  }  else  if  (  tq  .  matchChomp  (   ":gt  (   "  )  )  {  return  indexGreaterThan  (  )  ;  }  else  if  (  tq  .  matchChomp  (   ":eq  (   "  )  )  {  return  indexEquals  (  )  ;  }  else  {  //  unhandled  throw  new  SelectorParseException  (   "Could  not  parse  query   "  +  query  )  ;  }  }    [METHOD]  findElements  [TYPE]  Elements  [PARAMETER]  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  String[]  combinators  [TYPE]  String  combinator  query  s  subQuery  [TYPE]  boolean  false  true  [TYPE]  Element  root  
[REPLACE]  }  else  if  (  tq  .  matchChomp  (   "* "  )  )  {	[BUGGY]  else  if  (  tq  .  matchesWord  (  )  )  {[FE]  Could  not  parse  query  *  assertEquals( "The  boards  next  fear:  the  female  quota "  ,  doc.title())  ;  //  note  that  the  apos  in  the  source  is  a  literal    (8217)  ,  not  escaped  or  'assertEquals( "en "  ,  doc.select( "html ").attr( "xml:lang "))  ;  assertEquals(17  ,  articleBody.size())  ;  [CONTEXT]  private  Elements  findElements  (  )  {  if  (  tq  .  matchChomp  (   "# "  )  )  {  return  byId  (  )  ;  }  else  if  (  tq  .  matchChomp  (   "  .   "  )  )  {  return  byClass  (  )  ;  }  else  if  (  tq  .  matchesWord  (  )  )  {  return  byTag  (  )  ;  }  else  if  (  tq  .  matchChomp  (   "[ "  )  )  {  return  byAttribute  (  )  ;  [ATTENTION]  }  else  if  (  tq  .  matchesWord  (  )  )  {  return  allElements  (  )  ;  }  else  if  (  tq  .  matchChomp  (   ":lt  (   "  )  )  {  return  indexLessThan  (  )  ;  }  else  if  (  tq  .  matchChomp  (   ":gt  (   "  )  )  {  return  indexGreaterThan  (  )  ;  }  else  if  (  tq  .  matchChomp  (   ":eq  (   "  )  )  {  return  indexEquals  (  )  ;  }  else  {  //  unhandled  throw  new  SelectorParseException  (   "Could  not  parse  query   "  +  query  )  ;  }  }    [METHOD]  findElements  [TYPE]  Elements  [PARAMETER]  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  String[]  combinators  [TYPE]  String  combinator  query  s  subQuery  [TYPE]  boolean  false  true  [TYPE]  Element  root  
[REPLACE]  return  byId  (  )  ;	[BUGGY]  return  byTag  (  )  ;  [FE]  AssertionFailedError    expected:<1>  but  was:<0>  assertEquals(1  ,  els.size())  ;  assertEquals( "Hello "  ,  els.get(0).text())  ;  assertEquals(0  ,  none.size())  ;  [CONTEXT]  private  Elements  findElements  (  )  {  if  (  tq  .  matchChomp  (   "# "  )  )  {  [ATTENTION]  return  byTag  (  )    ;  }  else  if  (  tq  .  matchChomp  (   "  .   "  )  )  {  return  byClass  (  )  ;  }  else  if  (  tq  .  matchesWord  (  )  )  {  return  byTag  (  )  ;  }  else  if  (  tq  .  matchChomp  (   "[ "  )  )  {  return  byAttribute  (  )  ;  }  else  if  (  tq  .  matchChomp  (   "* "  )  )  {  return  allElements  (  )  ;  }  else  if  (  tq  .  matchChomp  (   ":lt  (   "  )  )  {  return  indexLessThan  (  )  ;  }  else  if  (  tq  .  matchChomp  (   ":gt  (   "  )  )  {  return  indexGreaterThan  (  )  ;  }  else  if  (  tq  .  matchChomp  (   ":eq  (   "  )  )  {  return  indexEquals  (  )  ;  }  else  {  //  unhandled  throw  new  SelectorParseException  (   "Could  not  parse  query   "  +  query  )  ;  }  }    [METHOD]  findElements  [TYPE]  Elements  [PARAMETER]  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  String[]  combinators  [TYPE]  String  combinator  query  s  subQuery  [TYPE]  boolean  false  true  [TYPE]  Element  root  
[REPLACE]  }  else  if  (  tq  .  matchChomp  (   "  .   "  )  )  {	[BUGGY]    if  (  tq  .  matchChomp  (   "  .   "  )  )  {[NO-ERROR]  [CONTEXT]  private  Elements  findElements  (  )  {  if  (  tq  .  matchChomp  (   "# "  )  )  {  return  byId  (  )  ;  [ATTENTION]  }if  (  tq  .  matchChomp  (   "  .   "  )  )  {  return  byClass  (  )  ;  }  else  if  (  tq  .  matchesWord  (  )  )  {  return  byTag  (  )  ;  }  else  if  (  tq  .  matchChomp  (   "[ "  )  )  {  return  byAttribute  (  )  ;  }  else  if  (  tq  .  matchChomp  (   "* "  )  )  {  return  allElements  (  )  ;  }  else  if  (  tq  .  matchChomp  (   ":lt  (   "  )  )  {  return  indexLessThan  (  )  ;  }  else  if  (  tq  .  matchChomp  (   ":gt  (   "  )  )  {  return  indexGreaterThan  (  )  ;  }  else  if  (  tq  .  matchChomp  (   ":eq  (   "  )  )  {  return  indexEquals  (  )  ;  }  else  {  //  unhandled  throw  new  SelectorParseException  (   "Could  not  parse  query   "  +  query  )  ;  }  }    [METHOD]  findElements  [TYPE]  Elements  [PARAMETER]  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  String[]  combinators  [TYPE]  String  combinator  query  s  subQuery  [TYPE]  boolean  false  true  [TYPE]  Element  root  
[REPLACE]  }  else  if  (  tq  .  matchChomp  (   "* "  )  )  {	[BUGGY]    if  (  tq  .  matchesWord  (  )    )  {[FE]  Could  not  parse  query  *  assertEquals( "The  boards  next  fear:  the  female  quota "  ,  doc.title())  ;  //  note  that  the  apos  in  the  source  is  a  literal    (8217)  ,  not  escaped  or  'assertEquals( "en "  ,  doc.select( "html ").attr( "xml:lang "))  ;  assertEquals(17  ,  articleBody.size())  ;  [CONTEXT]  private  Elements  findElements  (  )  {  if  (  tq  .  matchChomp  (   "# "  )  )  {  return  byId  (  )  ;  }  else  if  (  tq  .  matchChomp  (   "  .   "  )  )  {  return  byClass  (  )  ;  }  else  if  (  tq  .  matchesWord  (  )  )  {  return  byTag  (  )  ;  }  else  if  (  tq  .  matchChomp  (   "[ "  )  )  {  return  byAttribute  (  )  ;  [ATTENTION]  }if  (  tq  .  matchesWord  (  )    )  {  return  allElements  (  )  ;  }  else  if  (  tq  .  matchChomp  (   ":lt  (   "  )  )  {  return  indexLessThan  (  )  ;  }  else  if  (  tq  .  matchChomp  (   ":gt  (   "  )  )  {  return  indexGreaterThan  (  )  ;  }  else  if  (  tq  .  matchChomp  (   ":eq  (   "  )  )  {  return  indexEquals  (  )  ;  }  else  {  //  unhandled  throw  new  SelectorParseException  (   "Could  not  parse  query   "  +  query  )  ;  }  }    [METHOD]  findElements  [TYPE]  Elements  [PARAMETER]  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  String[]  combinators  [TYPE]  String  combinator  query  s  subQuery  [TYPE]  boolean  false  true  [TYPE]  Element  root  
[REPLACE]  }  else  if  (  tq  .  matchChomp  (   ":gt  (   "  )  )  {	[BUGGY]  else  if  (  tq  .  matchesWord  (  )    {[CE]  ')'  expected  [CONTEXT]  private  Elements  findElements  (  )  {  if  (  tq  .  matchChomp  (   "# "  )  )  {  return  byId  (  )  ;  }  else  if  (  tq  .  matchChomp  (   "  .   "  )  )  {  return  byClass  (  )  ;  }  else  if  (  tq  .  matchesWord  (  )  )  {  return  byTag  (  )  ;  }  else  if  (  tq  .  matchChomp  (   "[ "  )  )  {  return  byAttribute  (  )  ;  }  else  if  (  tq  .  matchChomp  (   "* "  )  )  {  return  allElements  (  )  ;  }  else  if  (  tq  .  matchChomp  (   ":lt  (   "  )  )  {  return  indexLessThan  (  )  ;  [ATTENTION]  }  else  if  (  tq  .  matchesWord  (  )  {  return  indexGreaterThan  (  )  ;  }  else  if  (  tq  .  matchChomp  (   ":eq  (   "  )  )  {  return  indexEquals  (  )  ;  }  else  {  //  unhandled  throw  new  SelectorParseException  (   "Could  not  parse  query   "  +  query  )  ;  }  }    [METHOD]  findElements  [TYPE]  Elements  [PARAMETER]  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  String[]  combinators  [TYPE]  String  combinator  query  s  subQuery  [TYPE]  boolean  false  true  [TYPE]  Element  root  
[REMOVE]  	[BUGGY]  if  (  tq  .  matchChomp  (   "*  =   "  )  )      return  root  .  getElementsByAttributeValueContaining  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;  else      throw  new  SelectorParseException  (  (   "Could  not  parse  attribute  query   "  +  (  query  )  )  )  ;  [CE]  cannot  find  symbol  key  [CONTEXT]  private  Elements  findElements  (  )  {  if  (  tq  .  matchChomp  (   "# "  )  )  {  return  byId  (  )  ;  }  else  if  (  tq  .  matchChomp  (   "  .   "  )  )  {  return  byClass  (  )  ;  }  else  if  (  tq  .  matchesWord  (  )  )  {  return  byTag  (  )  ;  }  else  if  (  tq  .  matchChomp  (   "[ "  )  )  {  return  byAttribute  (  )  ;  }  else  if  (  tq  .  matchChomp  (   "* "  )  )  {  return  allElements  (  )  ;  [ATTENTION]  }  else  if  (  tq  .  matchChomp  (   ":lt  (   "  )  )  {  if  (  tq  .  matchChomp  (   "*  =   "  )  )  return  root  .  getElementsByAttributeValueContaining  (  key  ,  tq  .  chompTo  (   "] "  )  )    ;  else  throw  new  SelectorParseException  (  (   "Could  not  parse  attribute  query   "  +  (  query  )  )  )    ;  return  indexLessThan  (  )  ;  }  else  if  (  tq  .  matchChomp  (   ":gt  (   "  )  )  {  return  indexGreaterThan  (  )  ;  }  else  if  (  tq  .  matchChomp  (   ":eq  (   "  )  )  {  return  indexEquals  (  )  ;  }  else  {  //  unhandled  throw  new  SelectorParseException  (   "Could  not  parse  query   "  +  query  )  ;  }    [METHOD]  findElements  [TYPE]  Elements  [PARAMETER]  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  String[]  combinators  [TYPE]  String  combinator  query  s  subQuery  [TYPE]  boolean  false  true  [TYPE]  Element  root  
[REPLACE]  }  else  if  (  tq  .  matchChomp  (   ":gt  (   "  )  )  {	[BUGGY]    if  (  tq  .  matchesWord  (  )    {[CE]  ')'  expected  [CONTEXT]  private  Elements  findElements  (  )  {  if  (  tq  .  matchChomp  (   "# "  )  )  {  return  byId  (  )  ;  }  else  if  (  tq  .  matchChomp  (   "  .   "  )  )  {  return  byClass  (  )  ;  }  else  if  (  tq  .  matchesWord  (  )  )  {  return  byTag  (  )  ;  }  else  if  (  tq  .  matchChomp  (   "[ "  )  )  {  return  byAttribute  (  )  ;  }  else  if  (  tq  .  matchChomp  (   "* "  )  )  {  return  allElements  (  )  ;  }  else  if  (  tq  .  matchChomp  (   ":lt  (   "  )  )  {  return  indexLessThan  (  )  ;  [ATTENTION]  }if  (  tq  .  matchesWord  (  )  {  return  indexGreaterThan  (  )  ;  }  else  if  (  tq  .  matchChomp  (   ":eq  (   "  )  )  {  return  indexEquals  (  )  ;  }  else  {  //  unhandled  throw  new  SelectorParseException  (   "Could  not  parse  query   "  +  query  )  ;  }  }    [METHOD]  findElements  [TYPE]  Elements  [PARAMETER]  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  String[]  combinators  [TYPE]  String  combinator  query  s  subQuery  [TYPE]  boolean  false  true  [TYPE]  Element  root  
[REPLACE]  }  else  if  (  tq  .  matchesWord  (  )  )  {	[BUGGY]  else  if  (  tq  .  matchChomp  (   "  .   "  )  )  {[FE]  Could  not  parse  query  html  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  private  Elements  findElements  (  )  {  if  (  tq  .  matchChomp  (   "# "  )  )  {  return  byId  (  )  ;  }  else  if  (  tq  .  matchChomp  (   "  .   "  )  )  {  return  byClass  (  )  ;  [ATTENTION]  }  else  if  (  tq  .  matchChomp  (   "  .   "  )  )  {  return  byTag  (  )  ;  }  else  if  (  tq  .  matchChomp  (   "[ "  )  )  {  return  byAttribute  (  )  ;  }  else  if  (  tq  .  matchChomp  (   "* "  )  )  {  return  allElements  (  )  ;  }  else  if  (  tq  .  matchChomp  (   ":lt  (   "  )  )  {  return  indexLessThan  (  )  ;  }  else  if  (  tq  .  matchChomp  (   ":gt  (   "  )  )  {  return  indexGreaterThan  (  )  ;  }  else  if  (  tq  .  matchChomp  (   ":eq  (   "  )  )  {  return  indexEquals  (  )  ;  }  else  {  //  unhandled  throw  new  SelectorParseException  (   "Could  not  parse  query   "  +  query  )  ;  }  }    [METHOD]  findElements  [TYPE]  Elements  [PARAMETER]  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  String[]  combinators  [TYPE]  String  combinator  query  s  subQuery  [TYPE]  boolean  false  true  [TYPE]  Element  root  
[REPLACE]  }  else  if  (  tq  .  matchChomp  (   ":lt  (   "  )  )  {	[BUGGY]    if  (  tq  .  matchesAny  (   ":lt  (   "  )  )  {[FE]  Could  not  parse  query  p:gt(0  assertEquals(1  ,  ps.size())  ;  assertEquals( "Two "  ,  ps.get(0).text())  ;  [CONTEXT]  private  Elements  findElements  (  )  {  if  (  tq  .  matchChomp  (   "# "  )  )  {  return  byId  (  )  ;  }  else  if  (  tq  .  matchChomp  (   "  .   "  )  )  {  return  byClass  (  )  ;  }  else  if  (  tq  .  matchesWord  (  )  )  {  return  byTag  (  )  ;  }  else  if  (  tq  .  matchChomp  (   "[ "  )  )  {  return  byAttribute  (  )  ;  }  else  if  (  tq  .  matchChomp  (   "* "  )  )  {  return  allElements  (  )  ;  [ATTENTION]  }if  (  tq  .  matchesAny  (   ":lt  (   "  )  )  {  return  indexLessThan  (  )  ;  }  else  if  (  tq  .  matchChomp  (   ":gt  (   "  )  )  {  return  indexGreaterThan  (  )  ;  }  else  if  (  tq  .  matchChomp  (   ":eq  (   "  )  )  {  return  indexEquals  (  )  ;  }  else  {  //  unhandled  throw  new  SelectorParseException  (   "Could  not  parse  query   "  +  query  )  ;  }  }    [METHOD]  findElements  [TYPE]  Elements  [PARAMETER]  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  String[]  combinators  [TYPE]  String  combinator  query  s  subQuery  [TYPE]  boolean  false  true  [TYPE]  Element  root  
[ADD]  else  if  (  tq  .  matchChomp  (   "[ "  )  )  {  return  byAttribute  (  )  ;  }  else  if  (  tq  .  matchChomp  (   "* "  )  )  {  return  allElements  (  )  ;	[BUGGY]    return  byAttribute  (  )  ;  return  allElements  (  )  ;  [CE]  illegal  start  of  type  [CONTEXT]  private  Elements  findElements  (  )  {  if  (  tq  .  matchChomp  (   "# "  )  )  {  return  byId  (  )  ;  }  else  if  (  tq  .  matchChomp  (   "  .   "  )  )  {  return  byClass  (  )  ;  }  else  if  (  tq  .  matchesWord  (  )  )  {  return  byTag  (  )  ;  [ATTENTION]  }  return  byAttribute  (  )    ;  return  allElements  (  )    ;      }  else  if  (  tq  .  matchChomp  (   ":lt  (   "  )  )  {  return  indexLessThan  (  )  ;  }  else  if  (  tq  .  matchChomp  (   ":gt  (   "  )  )  {  return  indexGreaterThan  (  )  ;  }  else  if  (  tq  .  matchChomp  (   ":eq  (   "  )  )  {  return  indexEquals  (  )  ;  }  else  {  //  unhandled  throw  new  SelectorParseException  (   "Could  not  parse  query   "  +  query  )  ;  }  }    [METHOD]  findElements  [TYPE]  Elements  [PARAMETER]  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  String[]  combinators  [TYPE]  String  combinator  query  s  subQuery  [TYPE]  boolean  false  true  [TYPE]  Element  root  
[REPLACE]  elements  .  addAll  (  add  )  ;	[BUGGY]  elements  .  addAll  (  true  )  ;  [CE]  method  addAll  in  class  AbstractCollection<E>  cannot  be  applied  to  given  types  ;  [CONTEXT]  private  void  addElements  (  Collection<Element>  add  )  {  [ATTENTION]  elements  .  addAll  (  true  )    ;  }    [METHOD]  addElements  [TYPE]  void  [PARAMETER]  Element>  add  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  Element  root  [TYPE]  Collection  add  [TYPE]  String[]  combinators  [TYPE]  String  combinator  query  s  subQuery  
[REPLACE]  elements  .  retainAll  (  intersect  )  ;	[BUGGY]  elements  .  addAll  (  )    ;  [CE]  method  addAll  in  class  AbstractCollection<E>  cannot  be  applied  to  given  types  ;  [CONTEXT]  private  void  intersectElements  (  Collection<Element>  intersect  )  {  [ATTENTION]  elements  .  addAll  (  )  ;  }    [METHOD]  intersectElements  [TYPE]  void  [PARAMETER]  Element>  intersect  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  Element  root  [TYPE]  Collection  intersect  [TYPE]  String[]  combinators  [TYPE]  String  combinator  query  s  subQuery  
[REPLACE]  String  id  =  tq  .  consumeCssIdentifier  (  )  ;	[BUGGY]  String  id  =  tq  .  consumeWhitespace  (  )    ;  [CE]  incompatible  types  [CONTEXT]  private  Elements  byId  (  )  {  [ATTENTION]  String  id  =  tq  .  consumeWhitespace  (  )  ;  Validate  .  notEmpty  (  id  )  ;    Element  found  =  root  .  getElementById  (  id  )  ;  Elements  byId  =  new  Elements  (  )  ;  if  (  found  !  =  null  )  byId  .  add  (  found  )  ;  return  byId  ;  }    [METHOD]  byId  [TYPE]  Elements  [PARAMETER]  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  Element  found  root  [TYPE]  String[]  combinators  [TYPE]  String  combinator  id  query  s  subQuery  [TYPE]  Elements  byId  
[REPLACE]  Validate  .  notEmpty  (  id  )  ;	[BUGGY]  Validate  .  notEmpty  (  combinator  )  ;  [CE]  cannot  find  symbol  combinator  [CONTEXT]  private  Elements  byId  (  )  {  String  id  =  tq  .  consumeCssIdentifier  (  )  ;  [ATTENTION]  Validate  .  notEmpty  (  combinator  )    ;    Element  found  =  root  .  getElementById  (  id  )  ;  Elements  byId  =  new  Elements  (  )  ;  if  (  found  !  =  null  )  byId  .  add  (  found  )  ;  return  byId  ;  }    [METHOD]  byId  [TYPE]  Elements  [PARAMETER]  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  Element  found  root  [TYPE]  String[]  combinators  [TYPE]  String  combinator  id  query  s  subQuery  [TYPE]  Elements  byId  
[REPLACE]  Element  found  =  root  .  getElementById  (  id  )  ;	[BUGGY]  Element  found  =  root  .  getElementById  (  combinator  )  ;  [CE]  cannot  find  symbol  combinator  [CONTEXT]  private  Elements  byId  (  )  {  String  id  =  tq  .  consumeCssIdentifier  (  )  ;  Validate  .  notEmpty  (  id  )  ;    [ATTENTION]  Element  found  =  root  .  getElementById  (  combinator  )    ;  Elements  byId  =  new  Elements  (  )  ;  if  (  found  !  =  null  )  byId  .  add  (  found  )  ;  return  byId  ;  }    [METHOD]  byId  [TYPE]  Elements  [PARAMETER]  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  Element  found  root  [TYPE]  String[]  combinators  [TYPE]  String  combinator  id  query  s  subQuery  [TYPE]  Elements  byId  
[REPLACE]  Elements  byId  =  new  Elements  (  )  ;	[BUGGY]  Elements  candidates  =  findElements  (  )  ;  [CE]  cannot  find  symbol  byId  [CONTEXT]  private  Elements  byId  (  )  {  String  id  =  tq  .  consumeCssIdentifier  (  )  ;  Validate  .  notEmpty  (  id  )  ;    Element  found  =  root  .  getElementById  (  id  )  ;  [ATTENTION]  Elements  candidates  =  findElements  (  )    ;  if  (  found  !  =  null  )  byId  .  add  (  found  )  ;  return  byId  ;  }    [METHOD]  byId  [TYPE]  Elements  [PARAMETER]  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  Element  found  root  [TYPE]  String[]  combinators  [TYPE]  String  combinator  id  query  s  subQuery  [TYPE]  Elements  byId  
[REPLACE]  if  (  found  !=  null  )  byId  .  add  (  found  )  ;	[BUGGY]  if  (  found  =  =  null  )  byId  .  add  (  found  )  ;  [FE]  AssertionFailedError    expected:<1>  but  was:<0>  assertEquals(1  ,  els.size())  ;  assertEquals( "Hello "  ,  els.get(0).text())  ;  assertEquals(0  ,  none.size())  ;  [CONTEXT]  private  Elements  byId  (  )  {  String  id  =  tq  .  consumeCssIdentifier  (  )  ;  Validate  .  notEmpty  (  id  )  ;    Element  found  =  root  .  getElementById  (  id  )  ;  Elements  byId  =  new  Elements  (  )  ;  [ATTENTION]  if  (  found  =  =  null  )  byId  .  add  (  found  )    ;    return  byId  ;  }    [METHOD]  byId  [TYPE]  Elements  [PARAMETER]  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  Element  found  root  [TYPE]  String[]  combinators  [TYPE]  String  combinator  id  query  s  subQuery  [TYPE]  Elements  byId  
[REPLACE]  byId  .  add  (  found  )  ;	[BUGGY]  byId  .  addAll  (  )    ;  [CE]  no  suitable  method  found  for  addAll()  [CONTEXT]  private  Elements  byId  (  )  {  String  id  =  tq  .  consumeCssIdentifier  (  )  ;  Validate  .  notEmpty  (  id  )  ;    Element  found  =  root  .  getElementById  (  id  )  ;  Elements  byId  =  new  Elements  (  )  ;  if  (  found  !  =  null  )  [ATTENTION]  byId  .  addAll  (  )  ;  return  byId  ;  }    [METHOD]  byId  [TYPE]  Elements  [PARAMETER]  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  Element  found  root  [TYPE]  String[]  combinators  [TYPE]  String  combinator  id  query  s  subQuery  [TYPE]  Elements  byId  
[REMOVE]  	[BUGGY]  Validate  .  notNull  (  root  )  ;  [NO-ERROR]  [CONTEXT]  private  Elements  byId  (  )  {  String  id  =  tq  .  consumeCssIdentifier  (  )  ;  Validate  .  notEmpty  (  id  )  ;    Element  found  =  root  .  getElementById  (  id  )  ;  Elements  byId  =  new  Elements  (  )  ;  if  (  found  !  =  null  )  [ATTENTION]  byId  .  add  (  found  )  ;    Validate  .  notNull  (  root  )    ;  return  byId  ;      [METHOD]  byId  [TYPE]  Elements  [PARAMETER]  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  Element  found  root  [TYPE]  String[]  combinators  [TYPE]  String  combinator  id  query  s  subQuery  [TYPE]  Elements  byId  
[REPLACE]  return  byId;	[BUGGY]  return  byTag  (  )  ;  [FE]  The  validated  string  is  empty  assertEquals(1  ,  els.size())  ;  assertEquals( "Hello "  ,  els.get(0).text())  ;  assertEquals(0  ,  none.size())  ;  [CONTEXT]  private  Elements  byId  (  )  {  String  id  =  tq  .  consumeCssIdentifier  (  )  ;  Validate  .  notEmpty  (  id  )  ;    Element  found  =  root  .  getElementById  (  id  )  ;  Elements  byId  =  new  Elements  (  )  ;  if  (  found  !  =  null  )  byId  .  add  (  found  )  ;  [ATTENTION]  return  byTag  (  )    ;  }    [METHOD]  byId  [TYPE]  Elements  [PARAMETER]  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  Element  found  root  [TYPE]  String[]  combinators  [TYPE]  String  combinator  id  query  s  subQuery  [TYPE]  Elements  byId  
[REPLACE]  String  className  =  tq  .  consumeCssIdentifier  (  )  ;	[BUGGY]  String  className  =  tq  .  consumeWhitespace  (  )    ;  [CE]  incompatible  types  [CONTEXT]  private  Elements  byClass  (  )  {  [ATTENTION]  String  className  =  tq  .  consumeWhitespace  (  )  ;  Validate  .  notEmpty  (  className  )  ;    return  root  .  getElementsByClass  (  className  )  ;  }    [METHOD]  byClass  [TYPE]  Elements  [PARAMETER]  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  String[]  combinators  [TYPE]  String  className  combinator  id  query  s  subQuery  [TYPE]  boolean  false  true  [TYPE]  Element  found  root  
[REPLACE]  Validate  .  notEmpty  (  className  )  ;	[BUGGY]  Validate  .  notEmpty  (  s  )  ;  [CE]  cannot  find  symbol  s  [CONTEXT]  private  Elements  byClass  (  )  {  String  className  =  tq  .  consumeCssIdentifier  (  )  ;  [ATTENTION]  Validate  .  notEmpty  (  s  )    ;    return  root  .  getElementsByClass  (  className  )  ;  }    [METHOD]  byClass  [TYPE]  Elements  [PARAMETER]  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  String[]  combinators  [TYPE]  String  className  combinator  id  query  s  subQuery  [TYPE]  boolean  false  true  [TYPE]  Element  found  root  
[ADD]  Validate  .  notEmpty  (  className  )  ;	[BUGGY]  [NO-ERROR]  [CONTEXT]  private  Elements  byClass  (  )  {  String  className  =  tq  .  consumeCssIdentifier  (  )  ;  [ATTENTION]    return  root  .  getElementsByClass  (  className  )  ;  }    [METHOD]  byClass  [TYPE]  Elements  [PARAMETER]  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  String[]  combinators  [TYPE]  String  className  combinator  id  query  s  subQuery  [TYPE]  boolean  false  true  [TYPE]  Element  found  root  
[REPLACE]  return  root  .  getElementsByClass  (  className  )  ;	[BUGGY]  return  root  .  getElementsByTag  (  s  )    ;  [CE]  cannot  find  symbol  s  [CONTEXT]  private  Elements  byClass  (  )  {  String  className  =  tq  .  consumeCssIdentifier  (  )  ;  Validate  .  notEmpty  (  className  )  ;    [ATTENTION]  return  root  .  getElementsByTag  (  s  )  ;  }    [METHOD]  byClass  [TYPE]  Elements  [PARAMETER]  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  String[]  combinators  [TYPE]  String  className  combinator  id  query  s  subQuery  [TYPE]  boolean  false  true  [TYPE]  Element  found  root  
[REPLACE]  String  tagName  =  tq  .  consumeWord  (  )  ;	[BUGGY]  String  tagName  =  tq  .  consume  (  )  ;  [CE]  incompatible  types  [CONTEXT]  private  Elements  byTag  (  )  {  [ATTENTION]  String  tagName  =  tq  .  consume  (  )    ;  Validate  .  notEmpty  (  tagName  )  ;    return  root  .  getElementsByTag  (  tagName  )  ;  }    [METHOD]  byTag  [TYPE]  Elements  [PARAMETER]  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  String[]  combinators  [TYPE]  String  className  combinator  id  query  s  subQuery  tagName  [TYPE]  boolean  false  true  [TYPE]  Element  found  root  
[REPLACE]  Validate  .  notEmpty  (  tagName  )  ;	[BUGGY]  Validate  .  isTrue  (  combinator  )  ;  [CE]  cannot  find  symbol  combinator  [CONTEXT]  private  Elements  byTag  (  )  {  String  tagName  =  tq  .  consumeWord  (  )  ;  [ATTENTION]  Validate  .  isTrue  (  combinator  )    ;    return  root  .  getElementsByTag  (  tagName  )  ;  }    [METHOD]  byTag  [TYPE]  Elements  [PARAMETER]  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  String[]  combinators  [TYPE]  String  className  combinator  id  query  s  subQuery  tagName  [TYPE]  boolean  false  true  [TYPE]  Element  found  root  
[REPLACE]  return  root  .  getElementsByTag  (  tagName  )  ;	[BUGGY]  return  root  .  getElementsByClass  (  className  )  ;  [CE]  cannot  find  symbol  className  [CONTEXT]  private  Elements  byTag  (  )  {  String  tagName  =  tq  .  consumeWord  (  )  ;  Validate  .  notEmpty  (  tagName  )  ;    [ATTENTION]  return  root  .  getElementsByClass  (  className  )    ;  }    [METHOD]  byTag  [TYPE]  Elements  [PARAMETER]  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  String[]  combinators  [TYPE]  String  className  combinator  id  query  s  subQuery  tagName  [TYPE]  boolean  false  true  [TYPE]  Element  found  root  
[REPLACE]  Validate  .  notEmpty  (  key  )  ;	[BUGGY]  Validate  .  notEmpty  (  subQuery  )  ;  [CE]  cannot  find  symbol  subQuery  [CONTEXT]  private  Elements  byAttribute  (  )  {  String  key  =  tq  .  consumeToAny  (   "  =   "  ,   "!  =   "  ,   "^  =   "  ,   "$  =   "  ,   "*  =   "  ,   "] "  )  ;  //  eq  ,  not  ,  start  ,  end  ,  contain  ,    (  no  val  )  [ATTENTION]  Validate  .  notEmpty  (  subQuery  )    ;    if  (  tq  .  matchChomp  (   "] "  )  )  {  return  root  .  getElementsByAttribute  (  key  )  ;  }  else  {  if  (  tq  .  matchChomp  (   "  =   "  )  )  return  root  .  getElementsByAttributeValue  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "!  =   "  )  )  return  root  .  getElementsByAttributeValueNot  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "^  =   "  )  )  return  root  .  getElementsByAttributeValueStarting  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "$  =   "  )  )  return  root  .  getElementsByAttributeValueEnding  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "*  =   "  )  )  return  root  .  getElementsByAttributeValueContaining  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  throw  new  SelectorParseException  (   "Could  not  parse  attribute  query   "  +  query  )  ;  }  }    [METHOD]  byAttribute  [TYPE]  Elements  [PARAMETER]  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  String[]  combinators  [TYPE]  String  className  combinator  id  key  query  s  subQuery  tagName  [TYPE]  boolean  false  true  [TYPE]  Element  found  root  
[REPLACE]  if  (  tq  .  matchChomp  (   "] "  )  )  {	[BUGGY]  if  (  tq  .  matchChomp  (   "  ,   "  )  )  {[FE]  Could  not  parse  attribute  query  p[title]  assertEquals(2  ,  withTitle.size())  ;  assertTrue(withTitle.hasAttr( "title "))  ;  assertFalse(withTitle.hasAttr( "class "))  ;  assertEquals( "foo "  ,  withTitle.attr( "title "))  ;  assertEquals(2  ,  withTitle.size())  ;  //  existing  Elements  are  not  reevaluatedassertEquals(0  ,  doc.select( "p[title] ").size())  ;  assertEquals(4  ,  ps.size())  ;  assertEquals( "classy "  ,  ps.last().attr( "style "))  ;  assertEquals( "bar "  ,  ps.last().attr( "class "))  ;  [CONTEXT]  private  Elements  byAttribute  (  )  {  String  key  =  tq  .  consumeToAny  (   "  =   "  ,   "!  =   "  ,   "^  =   "  ,   "$  =   "  ,   "*  =   "  ,   "] "  )  ;  //  eq  ,  not  ,  start  ,  end  ,  contain  ,    (  no  val  )  Validate  .  notEmpty  (  key  )  ;    [ATTENTION]  if  (  tq  .  matchChomp  (   "  ,   "  )  )  {  return  root  .  getElementsByAttribute  (  key  )  ;  }  else  {  if  (  tq  .  matchChomp  (   "  =   "  )  )  return  root  .  getElementsByAttributeValue  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "!  =   "  )  )  return  root  .  getElementsByAttributeValueNot  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "^  =   "  )  )  return  root  .  getElementsByAttributeValueStarting  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "$  =   "  )  )  return  root  .  getElementsByAttributeValueEnding  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "*  =   "  )  )  return  root  .  getElementsByAttributeValueContaining  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  throw  new  SelectorParseException  (   "Could  not  parse  attribute  query   "  +  query  )  ;  }  }    [METHOD]  byAttribute  [TYPE]  Elements  [PARAMETER]  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  String[]  combinators  [TYPE]  String  className  combinator  id  key  query  s  subQuery  tagName  [TYPE]  boolean  false  true  [TYPE]  Element  found  root  
[ADD]  if  (  tq  .  matchChomp  (   "] "  )  )  {  return  root  .  getElementsByAttribute  (  key  )  ;  }  else  {  if  (  tq  .  matchChomp  (   "= "  )  )  return  root  .  getElementsByAttributeValue  (  key,  tq  .  chompTo  (   "] "  )  )  ;	[BUGGY]  return  root  .  getElementsByAttribute  (  key  )  ;  return  root  .  getElementsByAttributeValue  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;  [CE]  [CONTEXT]  private  Elements  byAttribute  (  )  {  String  key  =  tq  .  consumeToAny  (   "  =   "  ,   "!  =   "  ,   "^  =   "  ,   "$  =   "  ,   "*  =   "  ,   "] "  )  ;  //  eq  ,  not  ,  start  ,  end  ,  contain  ,    (  no  val  )  Validate  .  notEmpty  (  key  )  ;    [ATTENTION]  return  root  .  getElementsByAttribute  (  key  )    ;  return  root  .  getElementsByAttributeValue  (  key  ,  tq  .  chompTo  (   "] "  )  )    ;        else  if  (  tq  .  matchChomp  (   "!  =   "  )  )  return  root  .  getElementsByAttributeValueNot  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "^  =   "  )  )  return  root  .  getElementsByAttributeValueStarting  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "$  =   "  )  )  return  root  .  getElementsByAttributeValueEnding  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "*  =   "  )  )  return  root  .  getElementsByAttributeValueContaining  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  throw  new  SelectorParseException  (   "Could  not  parse  attribute  query   "  +  query  )  ;  }  }    [METHOD]  byAttribute  [TYPE]  Elements  [PARAMETER]  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  String[]  combinators  [TYPE]  String  className  combinator  id  key  query  s  subQuery  tagName  [TYPE]  boolean  false  true  [TYPE]  Element  found  root  
[REPLACE]  if  (  tq  .  matchChomp  (   "= "  )  )  return  root  .  getElementsByAttributeValue  (  key,  tq  .  chompTo  (   "] "  )  )  ;	[BUGGY]  else  if  (  tq  .  matchChomp  (   "$  =   "  )  )  return  root  .  getElementsByAttributeValueEnding  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;  [CE]  [CONTEXT]  private  Elements  byAttribute  (  )  {  String  key  =  tq  .  consumeToAny  (   "  =   "  ,   "!  =   "  ,   "^  =   "  ,   "$  =   "  ,   "*  =   "  ,   "] "  )  ;  //  eq  ,  not  ,  start  ,  end  ,  contain  ,    (  no  val  )  Validate  .  notEmpty  (  key  )  ;    if  (  tq  .  matchChomp  (   "] "  )  )  {  return  root  .  getElementsByAttribute  (  key  )  ;  }  else  {  [ATTENTION]  else  if  (  tq  .  matchChomp  (   "$  =   "  )  )  return  root  .  getElementsByAttributeValueEnding  (  key  ,  tq  .  chompTo  (   "] "  )  )    ;    else  if  (  tq  .  matchChomp  (   "!  =   "  )  )  return  root  .  getElementsByAttributeValueNot  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "^  =   "  )  )  return  root  .  getElementsByAttributeValueStarting  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "$  =   "  )  )  return  root  .  getElementsByAttributeValueEnding  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "*  =   "  )  )  return  root  .  getElementsByAttributeValueContaining  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  throw  new  SelectorParseException  (   "Could  not  parse  attribute  query   "  +  query  )  ;  }  }    [METHOD]  byAttribute  [TYPE]  Elements  [PARAMETER]  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  String[]  combinators  [TYPE]  String  className  combinator  id  key  query  s  subQuery  tagName  [TYPE]  boolean  false  true  [TYPE]  Element  found  root  
[REPLACE]  else  if  (  tq  .  matchChomp  (   "!= "  )  )  return  root  .  getElementsByAttributeValueNot  (  key,  tq  .  chompTo  (   "] "  )  )  ;	[BUGGY]  if  (  tq  .  matchChomp  (   "!  =   "  )  )  return  root  .  getElementsByAttributeValueNot  (  subQuery  ,  tq  .  chompTo  (   "] "  )  )  ;  [CE]  cannot  find  symbol  subQuery  [CONTEXT]  private  Elements  byAttribute  (  )  {  String  key  =  tq  .  consumeToAny  (   "  =   "  ,   "!  =   "  ,   "^  =   "  ,   "$  =   "  ,   "*  =   "  ,   "] "  )  ;  //  eq  ,  not  ,  start  ,  end  ,  contain  ,    (  no  val  )  Validate  .  notEmpty  (  key  )  ;    if  (  tq  .  matchChomp  (   "] "  )  )  {  return  root  .  getElementsByAttribute  (  key  )  ;  }  else  {  if  (  tq  .  matchChomp  (   "  =   "  )  )  return  root  .  getElementsByAttributeValue  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    [ATTENTION]  if  (  tq  .  matchChomp  (   "!  =   "  )  )  return  root  .  getElementsByAttributeValueNot  (  subQuery  ,  tq  .  chompTo  (   "] "  )  )    ;    else  if  (  tq  .  matchChomp  (   "^  =   "  )  )  return  root  .  getElementsByAttributeValueStarting  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "$  =   "  )  )  return  root  .  getElementsByAttributeValueEnding  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "*  =   "  )  )  return  root  .  getElementsByAttributeValueContaining  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  throw  new  SelectorParseException  (   "Could  not  parse  attribute  query   "  +  query  )  ;  }  }    [METHOD]  byAttribute  [TYPE]  Elements  [PARAMETER]  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  String[]  combinators  [TYPE]  String  className  combinator  id  key  query  s  subQuery  tagName  [TYPE]  boolean  false  true  [TYPE]  Element  found  root  
[REPLACE]  else  if  (  tq  .  matchChomp  (   "*= "  )  )  return  root  .  getElementsByAttributeValueContaining  (  key,  tq  .  chompTo  (   "] "  )  )  ;	[BUGGY]  else  if  (  tq  .  matchesAny  (   "*  =   "  )  )  return  root  .  getElementsByAttributeValueContaining  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;  [FE]  null  assertEquals( "News.com.au  |  News  from  Australia  and  around  the  world  online  |  NewsComAu "  ,  doc.title())  ;  assertEquals( "Brace  yourself  for  Metro  meltdown "  ,  doc.select( ".id1225817868581  h4 ").text().trim())  ;  assertEquals( "/entertainment/horoscopes "  ,  a.attr( "href "))  ;  assertEquals( "http://www.news.com.au/entertainment/horoscopes "  ,  a.attr( "abs:href "))  ;  assertEquals( "http://www.heraldsun.com.au/news/naughty-corners-are-a-bad-idea-for-kids/story-e6frf7jo-1225817899003 "  ,  hs.attr( "href "))  ;  assertEquals(hs.attr( "href ")  ,  hs.attr( "abs:href "))  ;  [CONTEXT]  private  Elements  byAttribute  (  )  {  String  key  =  tq  .  consumeToAny  (   "  =   "  ,   "!  =   "  ,   "^  =   "  ,   "$  =   "  ,   "*  =   "  ,   "] "  )  ;  //  eq  ,  not  ,  start  ,  end  ,  contain  ,    (  no  val  )  Validate  .  notEmpty  (  key  )  ;    if  (  tq  .  matchChomp  (   "] "  )  )  {  return  root  .  getElementsByAttribute  (  key  )  ;  }  else  {  if  (  tq  .  matchChomp  (   "  =   "  )  )  return  root  .  getElementsByAttributeValue  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "!  =   "  )  )  return  root  .  getElementsByAttributeValueNot  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "^  =   "  )  )  return  root  .  getElementsByAttributeValueStarting  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "$  =   "  )  )  return  root  .  getElementsByAttributeValueEnding  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    [ATTENTION]  else  if  (  tq  .  matchesAny  (   "*  =   "  )  )  return  root  .  getElementsByAttributeValueContaining  (  key  ,  tq  .  chompTo  (   "] "  )  )    ;    else  throw  new  SelectorParseException  (   "Could  not  parse  attribute  query   "  +  query  )  ;  }  }    [METHOD]  byAttribute  [TYPE]  Elements  [PARAMETER]  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  String[]  combinators  [TYPE]  String  className  combinator  id  key  query  s  subQuery  tagName  [TYPE]  boolean  false  true  [TYPE]  Element  found  root  
[REPLACE]  throw  new  SelectorParseException  ( "   ")  ;	[BUGGY]  throw  new  IllegalStateException  ( "   ")    ;    ;  [CE]  unreachable  statement  [CONTEXT]  private  Elements  byAttribute  (  )  {  String  key  =  tq  .  consumeToAny  (   "  =   "  ,   "!  =   "  ,   "^  =   "  ,   "$  =   "  ,   "*  =   "  ,   "] "  )  ;  //  eq  ,  not  ,  start  ,  end  ,  contain  ,    (  no  val  )  Validate  .  notEmpty  (  key  )  ;    if  (  tq  .  matchChomp  (   "] "  )  )  {  return  root  .  getElementsByAttribute  (  key  )  ;  }  else  {  if  (  tq  .  matchChomp  (   "  =   "  )  )  return  root  .  getElementsByAttributeValue  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "!  =   "  )  )  return  root  .  getElementsByAttributeValueNot  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "^  =   "  )  )  return  root  .  getElementsByAttributeValueStarting  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "$  =   "  )  )  return  root  .  getElementsByAttributeValueEnding  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "*  =   "  )  )  return  root  .  getElementsByAttributeValueContaining  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  [ATTENTION]  throw  new  IllegalStateException  (   "   "  )  ;    ;  }  }    [METHOD]  byAttribute  [TYPE]  Elements  [PARAMETER]  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  String[]  combinators  [TYPE]  String  className  combinator  id  key  query  s  subQuery  tagName  [TYPE]  boolean  false  true  [TYPE]  Element  found  root  
[REPLACE]  return  root  .  getElementsByAttributeValueContaining  (  key,  tq  .  chompTo  (   "] "  )  )  ;	[BUGGY]  return  root  .  getElementsByAttributeValueContaining  (  subQuery  ,  tq  .  matchChomp  (   "] "  )  )  ;  [CE]  cannot  find  symbol  subQuery  [CONTEXT]  private  Elements  byAttribute  (  )  {  String  key  =  tq  .  consumeToAny  (   "  =   "  ,   "!  =   "  ,   "^  =   "  ,   "$  =   "  ,   "*  =   "  ,   "] "  )  ;  //  eq  ,  not  ,  start  ,  end  ,  contain  ,    (  no  val  )  Validate  .  notEmpty  (  key  )  ;    if  (  tq  .  matchChomp  (   "] "  )  )  {  return  root  .  getElementsByAttribute  (  key  )  ;  }  else  {  if  (  tq  .  matchChomp  (   "  =   "  )  )  return  root  .  getElementsByAttributeValue  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "!  =   "  )  )  return  root  .  getElementsByAttributeValueNot  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "^  =   "  )  )  return  root  .  getElementsByAttributeValueStarting  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "$  =   "  )  )  return  root  .  getElementsByAttributeValueEnding  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "*  =   "  )  )  [ATTENTION]  return  root  .  getElementsByAttributeValueContaining  (  subQuery  ,  tq  .  matchChomp  (   "] "  )  )    ;    else  throw  new  SelectorParseException  (   "Could  not  parse  attribute  query   "  +  query  )  ;  }  }    [METHOD]  byAttribute  [TYPE]  Elements  [PARAMETER]  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  String[]  combinators  [TYPE]  String  className  combinator  id  key  query  s  subQuery  tagName  [TYPE]  boolean  false  true  [TYPE]  Element  found  root  
[REPLACE]  return  root  .  getElementsByAttributeValueContaining  (  key,  tq  .  chompTo  (   "] "  )  )  ;	[BUGGY]  return  root  .  getElementsByAttributeValueContaining  (  key  ,  tq  .  matchChomp  (   "] "  )  )  ;  [CE]  method  getElementsByAttributeValueContaining  in  class  Element  cannot  be  applied  to  given  types  ;  [CONTEXT]  private  Elements  byAttribute  (  )  {  String  key  =  tq  .  consumeToAny  (   "  =   "  ,   "!  =   "  ,   "^  =   "  ,   "$  =   "  ,   "*  =   "  ,   "] "  )  ;  //  eq  ,  not  ,  start  ,  end  ,  contain  ,    (  no  val  )  Validate  .  notEmpty  (  key  )  ;    if  (  tq  .  matchChomp  (   "] "  )  )  {  return  root  .  getElementsByAttribute  (  key  )  ;  }  else  {  if  (  tq  .  matchChomp  (   "  =   "  )  )  return  root  .  getElementsByAttributeValue  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "!  =   "  )  )  return  root  .  getElementsByAttributeValueNot  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "^  =   "  )  )  return  root  .  getElementsByAttributeValueStarting  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "$  =   "  )  )  return  root  .  getElementsByAttributeValueEnding  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "*  =   "  )  )  [ATTENTION]  return  root  .  getElementsByAttributeValueContaining  (  key  ,  tq  .  matchChomp  (   "] "  )  )    ;    else  throw  new  SelectorParseException  (   "Could  not  parse  attribute  query   "  +  query  )  ;  }  }    [METHOD]  byAttribute  [TYPE]  Elements  [PARAMETER]  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  String[]  combinators  [TYPE]  String  className  combinator  id  key  query  s  subQuery  tagName  [TYPE]  boolean  false  true  [TYPE]  Element  found  root  
[REPLACE]  throw  new  SelectorParseException  ( "   ")  ;	[BUGGY]  return  ;  [CE]  missing  return  value  [CONTEXT]  private  Elements  byAttribute  (  )  {  String  key  =  tq  .  consumeToAny  (   "  =   "  ,   "!  =   "  ,   "^  =   "  ,   "$  =   "  ,   "*  =   "  ,   "] "  )  ;  //  eq  ,  not  ,  start  ,  end  ,  contain  ,    (  no  val  )  Validate  .  notEmpty  (  key  )  ;    if  (  tq  .  matchChomp  (   "] "  )  )  {  return  root  .  getElementsByAttribute  (  key  )  ;  }  else  {  if  (  tq  .  matchChomp  (   "  =   "  )  )  return  root  .  getElementsByAttributeValue  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "!  =   "  )  )  return  root  .  getElementsByAttributeValueNot  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "^  =   "  )  )  return  root  .  getElementsByAttributeValueStarting  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "$  =   "  )  )  return  root  .  getElementsByAttributeValueEnding  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "*  =   "  )  )  return  root  .  getElementsByAttributeValueContaining  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  [ATTENTION]  return  ;  }  }    [METHOD]  byAttribute  [TYPE]  Elements  [PARAMETER]  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  String[]  combinators  [TYPE]  String  className  combinator  id  key  query  s  subQuery  tagName  [TYPE]  boolean  false  true  [TYPE]  Element  found  root  
[ADD]  throw  new  SelectorParseException  ( "   ")  ;	[BUGGY]  [CE]  illegal  start  of  expression  [CONTEXT]  private  Elements  byAttribute  (  )  {  String  key  =  tq  .  consumeToAny  (   "  =   "  ,   "!  =   "  ,   "^  =   "  ,   "$  =   "  ,   "*  =   "  ,   "] "  )  ;  //  eq  ,  not  ,  start  ,  end  ,  contain  ,    (  no  val  )  Validate  .  notEmpty  (  key  )  ;    if  (  tq  .  matchChomp  (   "] "  )  )  {  return  root  .  getElementsByAttribute  (  key  )  ;  }  else  {  if  (  tq  .  matchChomp  (   "  =   "  )  )  return  root  .  getElementsByAttributeValue  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "!  =   "  )  )  return  root  .  getElementsByAttributeValueNot  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "^  =   "  )  )  return  root  .  getElementsByAttributeValueStarting  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "$  =   "  )  )  return  root  .  getElementsByAttributeValueEnding  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "*  =   "  )  )  return  root  .  getElementsByAttributeValueContaining  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  [ATTENTION]  }  }    [METHOD]  byAttribute  [TYPE]  Elements  [PARAMETER]  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  String[]  combinators  [TYPE]  String  className  combinator  id  key  query  s  subQuery  tagName  [TYPE]  boolean  false  true  [TYPE]  Element  found  root  
[REPLACE]  return  root  .  getElementsByAttributeValueEnding  (  key,  tq  .  chompTo  (   "] "  )  )  ;	[BUGGY]  return  root  .  getElementsByAttributeValueEnding  (  key  ,  tq  .  isEmpty  (  )    )  ;  [CE]  method  getElementsByAttributeValueEnding  in  class  Element  cannot  be  applied  to  given  types  ;  [CONTEXT]  private  Elements  byAttribute  (  )  {  String  key  =  tq  .  consumeToAny  (   "  =   "  ,   "!  =   "  ,   "^  =   "  ,   "$  =   "  ,   "*  =   "  ,   "] "  )  ;  //  eq  ,  not  ,  start  ,  end  ,  contain  ,    (  no  val  )  Validate  .  notEmpty  (  key  )  ;    if  (  tq  .  matchChomp  (   "] "  )  )  {  return  root  .  getElementsByAttribute  (  key  )  ;  }  else  {  if  (  tq  .  matchChomp  (   "  =   "  )  )  return  root  .  getElementsByAttributeValue  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "!  =   "  )  )  return  root  .  getElementsByAttributeValueNot  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "^  =   "  )  )  return  root  .  getElementsByAttributeValueStarting  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "$  =   "  )  )  [ATTENTION]  return  root  .  getElementsByAttributeValueEnding  (  key  ,  tq  .  isEmpty  (  )    )    ;    else  if  (  tq  .  matchChomp  (   "*  =   "  )  )  return  root  .  getElementsByAttributeValueContaining  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  throw  new  SelectorParseException  (   "Could  not  parse  attribute  query   "  +  query  )  ;  }  }    [METHOD]  byAttribute  [TYPE]  Elements  [PARAMETER]  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  String[]  combinators  [TYPE]  String  className  combinator  id  key  query  s  subQuery  tagName  [TYPE]  boolean  false  true  [TYPE]  Element  found  root  
[REPLACE]  return  root  .  getElementsByAttributeValueContaining  (  key,  tq  .  chompTo  (   "] "  )  )  ;	[BUGGY]  return  root  .  getElementsByAttributeValueStarting  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;  [FE]  null  assertEquals( "News.com.au  |  News  from  Australia  and  around  the  world  online  |  NewsComAu "  ,  doc.title())  ;  assertEquals( "Brace  yourself  for  Metro  meltdown "  ,  doc.select( ".id1225817868581  h4 ").text().trim())  ;  assertEquals( "/entertainment/horoscopes "  ,  a.attr( "href "))  ;  assertEquals( "http://www.news.com.au/entertainment/horoscopes "  ,  a.attr( "abs:href "))  ;  assertEquals( "http://www.heraldsun.com.au/news/naughty-corners-are-a-bad-idea-for-kids/story-e6frf7jo-1225817899003 "  ,  hs.attr( "href "))  ;  assertEquals(hs.attr( "href ")  ,  hs.attr( "abs:href "))  ;  [CONTEXT]  private  Elements  byAttribute  (  )  {  String  key  =  tq  .  consumeToAny  (   "  =   "  ,   "!  =   "  ,   "^  =   "  ,   "$  =   "  ,   "*  =   "  ,   "] "  )  ;  //  eq  ,  not  ,  start  ,  end  ,  contain  ,    (  no  val  )  Validate  .  notEmpty  (  key  )  ;    if  (  tq  .  matchChomp  (   "] "  )  )  {  return  root  .  getElementsByAttribute  (  key  )  ;  }  else  {  if  (  tq  .  matchChomp  (   "  =   "  )  )  return  root  .  getElementsByAttributeValue  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "!  =   "  )  )  return  root  .  getElementsByAttributeValueNot  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "^  =   "  )  )  return  root  .  getElementsByAttributeValueStarting  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "$  =   "  )  )  return  root  .  getElementsByAttributeValueEnding  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "*  =   "  )  )  [ATTENTION]  return  root  .  getElementsByAttributeValueStarting  (  key  ,  tq  .  chompTo  (   "] "  )  )    ;    else  throw  new  SelectorParseException  (   "Could  not  parse  attribute  query   "  +  query  )  ;  }  }    [METHOD]  byAttribute  [TYPE]  Elements  [PARAMETER]  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  String[]  combinators  [TYPE]  String  className  combinator  id  key  query  s  subQuery  tagName  [TYPE]  boolean  false  true  [TYPE]  Element  found  root  
[REPLACE]  return  root  .  getElementsByAttributeValueEnding  (  key,  tq  .  chompTo  (   "] "  )  )  ;	[BUGGY]  return  root  .  getElementsByAttributeValueEnding  (  key  ,  tq  .  matchChomp  (   "] "  )  )  ;  [CE]  method  getElementsByAttributeValueEnding  in  class  Element  cannot  be  applied  to  given  types  ;  [CONTEXT]  private  Elements  byAttribute  (  )  {  String  key  =  tq  .  consumeToAny  (   "  =   "  ,   "!  =   "  ,   "^  =   "  ,   "$  =   "  ,   "*  =   "  ,   "] "  )  ;  //  eq  ,  not  ,  start  ,  end  ,  contain  ,    (  no  val  )  Validate  .  notEmpty  (  key  )  ;    if  (  tq  .  matchChomp  (   "] "  )  )  {  return  root  .  getElementsByAttribute  (  key  )  ;  }  else  {  if  (  tq  .  matchChomp  (   "  =   "  )  )  return  root  .  getElementsByAttributeValue  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "!  =   "  )  )  return  root  .  getElementsByAttributeValueNot  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "^  =   "  )  )  return  root  .  getElementsByAttributeValueStarting  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "$  =   "  )  )  [ATTENTION]  return  root  .  getElementsByAttributeValueEnding  (  key  ,  tq  .  matchChomp  (   "] "  )  )    ;    else  if  (  tq  .  matchChomp  (   "*  =   "  )  )  return  root  .  getElementsByAttributeValueContaining  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  throw  new  SelectorParseException  (   "Could  not  parse  attribute  query   "  +  query  )  ;  }  }    [METHOD]  byAttribute  [TYPE]  Elements  [PARAMETER]  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  String[]  combinators  [TYPE]  String  className  combinator  id  key  query  s  subQuery  tagName  [TYPE]  boolean  false  true  [TYPE]  Element  found  root  
[REPLACE]  return  root  .  getElementsByAttributeValueContaining  (  key,  tq  .  chompTo  (   "] "  )  )  ;	[BUGGY]  return  root  .  getElementsByAttributeValueStarting  (  tagName  )    ;  [CE]  cannot  find  symbol  tagName  [CONTEXT]  private  Elements  byAttribute  (  )  {  String  key  =  tq  .  consumeToAny  (   "  =   "  ,   "!  =   "  ,   "^  =   "  ,   "$  =   "  ,   "*  =   "  ,   "] "  )  ;  //  eq  ,  not  ,  start  ,  end  ,  contain  ,    (  no  val  )  Validate  .  notEmpty  (  key  )  ;    if  (  tq  .  matchChomp  (   "] "  )  )  {  return  root  .  getElementsByAttribute  (  key  )  ;  }  else  {  if  (  tq  .  matchChomp  (   "  =   "  )  )  return  root  .  getElementsByAttributeValue  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "!  =   "  )  )  return  root  .  getElementsByAttributeValueNot  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "^  =   "  )  )  return  root  .  getElementsByAttributeValueStarting  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "$  =   "  )  )  return  root  .  getElementsByAttributeValueEnding  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "*  =   "  )  )  [ATTENTION]  return  root  .  getElementsByAttributeValueStarting  (  tagName  )  ;    else  throw  new  SelectorParseException  (   "Could  not  parse  attribute  query   "  +  query  )  ;  }  }    [METHOD]  byAttribute  [TYPE]  Elements  [PARAMETER]  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  String[]  combinators  [TYPE]  String  className  combinator  id  key  query  s  subQuery  tagName  [TYPE]  boolean  false  true  [TYPE]  Element  found  root  
[REPLACE]  return  root  .  getElementsByAttributeValueStarting  (  key,  tq  .  chompTo  (   "] "  )  )  ;	[BUGGY]  return  root  .  getElementsByAttributeValueStarting  (  subQuery  ,  tq  .  chompTo  (   "] "  )  )  ;  [CE]  cannot  find  symbol  subQuery  [CONTEXT]  private  Elements  byAttribute  (  )  {  String  key  =  tq  .  consumeToAny  (   "  =   "  ,   "!  =   "  ,   "^  =   "  ,   "$  =   "  ,   "*  =   "  ,   "] "  )  ;  //  eq  ,  not  ,  start  ,  end  ,  contain  ,    (  no  val  )  Validate  .  notEmpty  (  key  )  ;    if  (  tq  .  matchChomp  (   "] "  )  )  {  return  root  .  getElementsByAttribute  (  key  )  ;  }  else  {  if  (  tq  .  matchChomp  (   "  =   "  )  )  return  root  .  getElementsByAttributeValue  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "!  =   "  )  )  return  root  .  getElementsByAttributeValueNot  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "^  =   "  )  )  [ATTENTION]  return  root  .  getElementsByAttributeValueStarting  (  subQuery  ,  tq  .  chompTo  (   "] "  )  )    ;    else  if  (  tq  .  matchChomp  (   "$  =   "  )  )  return  root  .  getElementsByAttributeValueEnding  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "*  =   "  )  )  return  root  .  getElementsByAttributeValueContaining  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  throw  new  SelectorParseException  (   "Could  not  parse  attribute  query   "  +  query  )  ;  }  }    [METHOD]  byAttribute  [TYPE]  Elements  [PARAMETER]  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  String[]  combinators  [TYPE]  String  className  combinator  id  key  query  s  subQuery  tagName  [TYPE]  boolean  false  true  [TYPE]  Element  found  root  
[REPLACE]  return  root  .  getElementsByAttributeValueContaining  (  key,  tq  .  chompTo  (   "] "  )  )  ;	[BUGGY]  return  root  .  getElementsByAttributeValueContaining  (  subQuery  ,  tq  .  chompTo  (   "] "  )  )  ;  [CE]  cannot  find  symbol  subQuery  [CONTEXT]  private  Elements  byAttribute  (  )  {  String  key  =  tq  .  consumeToAny  (   "  =   "  ,   "!  =   "  ,   "^  =   "  ,   "$  =   "  ,   "*  =   "  ,   "] "  )  ;  //  eq  ,  not  ,  start  ,  end  ,  contain  ,    (  no  val  )  Validate  .  notEmpty  (  key  )  ;    if  (  tq  .  matchChomp  (   "] "  )  )  {  return  root  .  getElementsByAttribute  (  key  )  ;  }  else  {  if  (  tq  .  matchChomp  (   "  =   "  )  )  return  root  .  getElementsByAttributeValue  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "!  =   "  )  )  return  root  .  getElementsByAttributeValueNot  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "^  =   "  )  )  return  root  .  getElementsByAttributeValueStarting  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "$  =   "  )  )  return  root  .  getElementsByAttributeValueEnding  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "*  =   "  )  )  [ATTENTION]  return  root  .  getElementsByAttributeValueContaining  (  subQuery  ,  tq  .  chompTo  (   "] "  )  )    ;    else  throw  new  SelectorParseException  (   "Could  not  parse  attribute  query   "  +  query  )  ;  }  }    [METHOD]  byAttribute  [TYPE]  Elements  [PARAMETER]  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  String[]  combinators  [TYPE]  String  className  combinator  id  key  query  s  subQuery  tagName  [TYPE]  boolean  false  true  [TYPE]  Element  found  root  
[REPLACE]  else  if  (  tq  .  matchChomp  (   "*= "  )  )  return  root  .  getElementsByAttributeValueContaining  (  key,  tq  .  chompTo  (   "] "  )  )  ;	[BUGGY]  if  (  tq  .  matchChomp  (   "*  =   "  )  )  return  root  .  getElementsByAttributeValueContaining  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;  [NO-ERROR]  [CONTEXT]  private  Elements  byAttribute  (  )  {  String  key  =  tq  .  consumeToAny  (   "  =   "  ,   "!  =   "  ,   "^  =   "  ,   "$  =   "  ,   "*  =   "  ,   "] "  )  ;  //  eq  ,  not  ,  start  ,  end  ,  contain  ,    (  no  val  )  Validate  .  notEmpty  (  key  )  ;    if  (  tq  .  matchChomp  (   "] "  )  )  {  return  root  .  getElementsByAttribute  (  key  )  ;  }  else  {  if  (  tq  .  matchChomp  (   "  =   "  )  )  return  root  .  getElementsByAttributeValue  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "!  =   "  )  )  return  root  .  getElementsByAttributeValueNot  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "^  =   "  )  )  return  root  .  getElementsByAttributeValueStarting  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "$  =   "  )  )  return  root  .  getElementsByAttributeValueEnding  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    [ATTENTION]  if  (  tq  .  matchChomp  (   "*  =   "  )  )  return  root  .  getElementsByAttributeValueContaining  (  key  ,  tq  .  chompTo  (   "] "  )  )    ;    else  throw  new  SelectorParseException  (   "Could  not  parse  attribute  query   "  +  query  )  ;  }  }    [METHOD]  byAttribute  [TYPE]  Elements  [PARAMETER]  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  String[]  combinators  [TYPE]  String  className  combinator  id  key  query  s  subQuery  tagName  [TYPE]  boolean  false  true  [TYPE]  Element  found  root  
[ADD]  else  if  (  tq  .  matchChomp  (   "*= "  )  )  return  root  .  getElementsByAttributeValueContaining  (  key,  tq  .  chompTo  (   "] "  )  )  ;  else  throw  new  SelectorParseException  ( "   ")  ;	[BUGGY]  [CE]  missing  return  statement  [CONTEXT]  private  Elements  byAttribute  (  )  {  String  key  =  tq  .  consumeToAny  (   "  =   "  ,   "!  =   "  ,   "^  =   "  ,   "$  =   "  ,   "*  =   "  ,   "] "  )  ;  //  eq  ,  not  ,  start  ,  end  ,  contain  ,    (  no  val  )  Validate  .  notEmpty  (  key  )  ;    if  (  tq  .  matchChomp  (   "] "  )  )  {  return  root  .  getElementsByAttribute  (  key  )  ;  }  else  {  if  (  tq  .  matchChomp  (   "  =   "  )  )  return  root  .  getElementsByAttributeValue  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "!  =   "  )  )  return  root  .  getElementsByAttributeValueNot  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "^  =   "  )  )  return  root  .  getElementsByAttributeValueStarting  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "$  =   "  )  )  return  root  .  getElementsByAttributeValueEnding  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    [ATTENTION]      }  }    [METHOD]  byAttribute  [TYPE]  Elements  [PARAMETER]  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  String[]  combinators  [TYPE]  String  className  combinator  id  key  query  s  subQuery  tagName  [TYPE]  boolean  false  true  [TYPE]  Element  found  root  
[REPLACE]  return  root  .  getElementsByAttributeValueStarting  (  key,  tq  .  chompTo  (   "] "  )  )  ;	[BUGGY]  return  root  .  getElementsByAttributeValueContaining  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;  [NO-ERROR]  [CONTEXT]  private  Elements  byAttribute  (  )  {  String  key  =  tq  .  consumeToAny  (   "  =   "  ,   "!  =   "  ,   "^  =   "  ,   "$  =   "  ,   "*  =   "  ,   "] "  )  ;  //  eq  ,  not  ,  start  ,  end  ,  contain  ,    (  no  val  )  Validate  .  notEmpty  (  key  )  ;    if  (  tq  .  matchChomp  (   "] "  )  )  {  return  root  .  getElementsByAttribute  (  key  )  ;  }  else  {  if  (  tq  .  matchChomp  (   "  =   "  )  )  return  root  .  getElementsByAttributeValue  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "!  =   "  )  )  return  root  .  getElementsByAttributeValueNot  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "^  =   "  )  )  [ATTENTION]  return  root  .  getElementsByAttributeValueContaining  (  key  ,  tq  .  chompTo  (   "] "  )  )    ;    else  if  (  tq  .  matchChomp  (   "$  =   "  )  )  return  root  .  getElementsByAttributeValueEnding  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "*  =   "  )  )  return  root  .  getElementsByAttributeValueContaining  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  throw  new  SelectorParseException  (   "Could  not  parse  attribute  query   "  +  query  )  ;  }  }    [METHOD]  byAttribute  [TYPE]  Elements  [PARAMETER]  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  String[]  combinators  [TYPE]  String  className  combinator  id  key  query  s  subQuery  tagName  [TYPE]  boolean  false  true  [TYPE]  Element  found  root  
[REPLACE]  return  root  .  getElementsByAttributeValueEnding  (  key,  tq  .  chompTo  (   "] "  )  )  ;	[BUGGY]  return  root  .  getElementsByAttributeValueStarting  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;  [FE]  AssertionFailedError    expected:<2>  but  was:<0>  assertEquals(4  ,  withTitle.size())  ;  assertEquals(1  ,  foo.size())  ;  assertEquals(5  ,  not.size())  ;  assertEquals( "Foo "  ,  not.first().attr( "title "))  ;  assertEquals(2  ,  starts.size())  ;  assertEquals( "Bar "  ,  starts.first().attr( "title "))  ;  assertEquals( "Bam "  ,  starts.last().attr( "title "))  ;  assertEquals(2  ,  ends.size())  ;  assertEquals( "Bam "  ,  ends.first().attr( "title "))  ;  assertEquals( "SLAM "  ,  ends.last().attr( "title "))  ;  assertEquals(3  ,  contains.size())  ;  assertEquals( "Bar "  ,  contains.first().attr( "title "))  ;  assertEquals( "SLAM "  ,  contains.last().attr( "title "))  ;  [CONTEXT]  private  Elements  byAttribute  (  )  {  String  key  =  tq  .  consumeToAny  (   "  =   "  ,   "!  =   "  ,   "^  =   "  ,   "$  =   "  ,   "*  =   "  ,   "] "  )  ;  //  eq  ,  not  ,  start  ,  end  ,  contain  ,    (  no  val  )  Validate  .  notEmpty  (  key  )  ;    if  (  tq  .  matchChomp  (   "] "  )  )  {  return  root  .  getElementsByAttribute  (  key  )  ;  }  else  {  if  (  tq  .  matchChomp  (   "  =   "  )  )  return  root  .  getElementsByAttributeValue  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "!  =   "  )  )  return  root  .  getElementsByAttributeValueNot  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "^  =   "  )  )  return  root  .  getElementsByAttributeValueStarting  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "$  =   "  )  )  [ATTENTION]  return  root  .  getElementsByAttributeValueStarting  (  key  ,  tq  .  chompTo  (   "] "  )  )    ;    else  if  (  tq  .  matchChomp  (   "*  =   "  )  )  return  root  .  getElementsByAttributeValueContaining  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  throw  new  SelectorParseException  (   "Could  not  parse  attribute  query   "  +  query  )  ;  }  }    [METHOD]  byAttribute  [TYPE]  Elements  [PARAMETER]  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  String[]  combinators  [TYPE]  String  className  combinator  id  key  query  s  subQuery  tagName  [TYPE]  boolean  false  true  [TYPE]  Element  found  root  
[REPLACE]  return  root  .  getElementsByAttributeValueNot  (  key,  tq  .  chompTo  (   "] "  )  )  ;	[BUGGY]  return  root  .  getElementsByAttributeValueNot  (  subQuery  ,  tq  .  chompTo  (   "] "  )  )  ;  [CE]  cannot  find  symbol  subQuery  [CONTEXT]  private  Elements  byAttribute  (  )  {  String  key  =  tq  .  consumeToAny  (   "  =   "  ,   "!  =   "  ,   "^  =   "  ,   "$  =   "  ,   "*  =   "  ,   "] "  )  ;  //  eq  ,  not  ,  start  ,  end  ,  contain  ,    (  no  val  )  Validate  .  notEmpty  (  key  )  ;    if  (  tq  .  matchChomp  (   "] "  )  )  {  return  root  .  getElementsByAttribute  (  key  )  ;  }  else  {  if  (  tq  .  matchChomp  (   "  =   "  )  )  return  root  .  getElementsByAttributeValue  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "!  =   "  )  )  [ATTENTION]  return  root  .  getElementsByAttributeValueNot  (  subQuery  ,  tq  .  chompTo  (   "] "  )  )    ;    else  if  (  tq  .  matchChomp  (   "^  =   "  )  )  return  root  .  getElementsByAttributeValueStarting  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "$  =   "  )  )  return  root  .  getElementsByAttributeValueEnding  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "*  =   "  )  )  return  root  .  getElementsByAttributeValueContaining  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  throw  new  SelectorParseException  (   "Could  not  parse  attribute  query   "  +  query  )  ;  }  }    [METHOD]  byAttribute  [TYPE]  Elements  [PARAMETER]  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  String[]  combinators  [TYPE]  String  className  combinator  id  key  query  s  subQuery  tagName  [TYPE]  boolean  false  true  [TYPE]  Element  found  root  
[REPLACE]  else  if  (  tq  .  matchChomp  (   "$= "  )  )  return  root  .  getElementsByAttributeValueEnding  (  key,  tq  .  chompTo  (   "] "  )  )  ;	[BUGGY]  if  (  tq  .  matchChomp  (   "  =   "  )  )  return  root  .  getElementsByAttributeValue  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;  [FE]  Could  not  parse  attribute  query  [title$  =  am]  assertEquals(4  ,  withTitle.size())  ;  assertEquals(1  ,  foo.size())  ;  assertEquals(5  ,  not.size())  ;  assertEquals( "Foo "  ,  not.first().attr( "title "))  ;  assertEquals(2  ,  starts.size())  ;  assertEquals( "Bar "  ,  starts.first().attr( "title "))  ;  assertEquals( "Bam "  ,  starts.last().attr( "title "))  ;  assertEquals(2  ,  ends.size())  ;  assertEquals( "Bam "  ,  ends.first().attr( "title "))  ;  assertEquals( "SLAM "  ,  ends.last().attr( "title "))  ;  assertEquals(3  ,  contains.size())  ;  assertEquals( "Bar "  ,  contains.first().attr( "title "))  ;  assertEquals( "SLAM "  ,  contains.last().attr( "title "))  ;  [CONTEXT]  private  Elements  byAttribute  (  )  {  String  key  =  tq  .  consumeToAny  (   "  =   "  ,   "!  =   "  ,   "^  =   "  ,   "$  =   "  ,   "*  =   "  ,   "] "  )  ;  //  eq  ,  not  ,  start  ,  end  ,  contain  ,    (  no  val  )  Validate  .  notEmpty  (  key  )  ;    if  (  tq  .  matchChomp  (   "] "  )  )  {  return  root  .  getElementsByAttribute  (  key  )  ;  }  else  {  if  (  tq  .  matchChomp  (   "  =   "  )  )  return  root  .  getElementsByAttributeValue  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "!  =   "  )  )  return  root  .  getElementsByAttributeValueNot  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "^  =   "  )  )  return  root  .  getElementsByAttributeValueStarting  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    [ATTENTION]  if  (  tq  .  matchChomp  (   "  =   "  )  )  return  root  .  getElementsByAttributeValue  (  key  ,  tq  .  chompTo  (   "] "  )  )    ;    else  if  (  tq  .  matchChomp  (   "*  =   "  )  )  return  root  .  getElementsByAttributeValueContaining  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  throw  new  SelectorParseException  (   "Could  not  parse  attribute  query   "  +  query  )  ;  }  }    [METHOD]  byAttribute  [TYPE]  Elements  [PARAMETER]  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  String[]  combinators  [TYPE]  String  className  combinator  id  key  query  s  subQuery  tagName  [TYPE]  boolean  false  true  [TYPE]  Element  found  root  
[ADD]  else  if  (  tq  .  matchChomp  (   "$= "  )  )  return  root  .  getElementsByAttributeValueEnding  (  key,  tq  .  chompTo  (   "] "  )  )  ;  else  if  (  tq  .  matchChomp  (   "*= "  )  )  return  root  .  getElementsByAttributeValueContaining  (  key,  tq  .  chompTo  (   "] "  )  )  ;	[BUGGY]  [FE]  Could  not  parse  attribute  query  a[href*  =  naughty-corners-are-a-bad-idea]  assertEquals( "News.com.au  |  News  from  Australia  and  around  the  world  online  |  NewsComAu "  ,  doc.title())  ;  assertEquals( "Brace  yourself  for  Metro  meltdown "  ,  doc.select( ".id1225817868581  h4 ").text().trim())  ;  assertEquals( "/entertainment/horoscopes "  ,  a.attr( "href "))  ;  assertEquals( "http://www.news.com.au/entertainment/horoscopes "  ,  a.attr( "abs:href "))  ;  assertEquals( "http://www.heraldsun.com.au/news/naughty-corners-are-a-bad-idea-for-kids/story-e6frf7jo-1225817899003 "  ,  hs.attr( "href "))  ;  assertEquals(hs.attr( "href ")  ,  hs.attr( "abs:href "))  ;  [CONTEXT]  private  Elements  byAttribute  (  )  {  String  key  =  tq  .  consumeToAny  (   "  =   "  ,   "!  =   "  ,   "^  =   "  ,   "$  =   "  ,   "*  =   "  ,   "] "  )  ;  //  eq  ,  not  ,  start  ,  end  ,  contain  ,    (  no  val  )  Validate  .  notEmpty  (  key  )  ;    if  (  tq  .  matchChomp  (   "] "  )  )  {  return  root  .  getElementsByAttribute  (  key  )  ;  }  else  {  if  (  tq  .  matchChomp  (   "  =   "  )  )  return  root  .  getElementsByAttributeValue  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "!  =   "  )  )  return  root  .  getElementsByAttributeValueNot  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "^  =   "  )  )  return  root  .  getElementsByAttributeValueStarting  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    [ATTENTION]        else  throw  new  SelectorParseException  (   "Could  not  parse  attribute  query   "  +  query  )  ;  }  }    [METHOD]  byAttribute  [TYPE]  Elements  [PARAMETER]  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  String[]  combinators  [TYPE]  String  className  combinator  id  key  query  s  subQuery  tagName  [TYPE]  boolean  false  true  [TYPE]  Element  found  root  
[REPLACE]  return  root  .  getElementsByAttributeValueContaining  (  key,  tq  .  chompTo  (   "] "  )  )  ;	[BUGGY]  return  root  .  getElementsByAttributeValueContaining  (  key  ,  tq  .  isEmpty  (  )    )  ;  [CE]  method  getElementsByAttributeValueContaining  in  class  Element  cannot  be  applied  to  given  types  ;  [CONTEXT]  private  Elements  byAttribute  (  )  {  String  key  =  tq  .  consumeToAny  (   "  =   "  ,   "!  =   "  ,   "^  =   "  ,   "$  =   "  ,   "*  =   "  ,   "] "  )  ;  //  eq  ,  not  ,  start  ,  end  ,  contain  ,    (  no  val  )  Validate  .  notEmpty  (  key  )  ;    if  (  tq  .  matchChomp  (   "] "  )  )  {  return  root  .  getElementsByAttribute  (  key  )  ;  }  else  {  if  (  tq  .  matchChomp  (   "  =   "  )  )  return  root  .  getElementsByAttributeValue  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "!  =   "  )  )  return  root  .  getElementsByAttributeValueNot  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "^  =   "  )  )  return  root  .  getElementsByAttributeValueStarting  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "$  =   "  )  )  return  root  .  getElementsByAttributeValueEnding  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "*  =   "  )  )  [ATTENTION]  return  root  .  getElementsByAttributeValueContaining  (  key  ,  tq  .  isEmpty  (  )    )    ;    else  throw  new  SelectorParseException  (   "Could  not  parse  attribute  query   "  +  query  )  ;  }  }    [METHOD]  byAttribute  [TYPE]  Elements  [PARAMETER]  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  String[]  combinators  [TYPE]  String  className  combinator  id  key  query  s  subQuery  tagName  [TYPE]  boolean  false  true  [TYPE]  Element  found  root  
[ADD]  else  if  (  tq  .  matchChomp  (   "*= "  )  )  return  root  .  getElementsByAttributeValueContaining  (  key,  tq  .  chompTo  (   "] "  )  )  ;  else  throw  new  SelectorParseException  ( "   ")  ;	[BUGGY]  return  root  .  getElementsByAttributeValueContaining  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;  [FE]  null  assertEquals( "News.com.au  |  News  from  Australia  and  around  the  world  online  |  NewsComAu "  ,  doc.title())  ;  assertEquals( "Brace  yourself  for  Metro  meltdown "  ,  doc.select( ".id1225817868581  h4 ").text().trim())  ;  assertEquals( "/entertainment/horoscopes "  ,  a.attr( "href "))  ;  assertEquals( "http://www.news.com.au/entertainment/horoscopes "  ,  a.attr( "abs:href "))  ;  assertEquals( "http://www.heraldsun.com.au/news/naughty-corners-are-a-bad-idea-for-kids/story-e6frf7jo-1225817899003 "  ,  hs.attr( "href "))  ;  assertEquals(hs.attr( "href ")  ,  hs.attr( "abs:href "))  ;  [CONTEXT]  private  Elements  byAttribute  (  )  {  String  key  =  tq  .  consumeToAny  (   "  =   "  ,   "!  =   "  ,   "^  =   "  ,   "$  =   "  ,   "*  =   "  ,   "] "  )  ;  //  eq  ,  not  ,  start  ,  end  ,  contain  ,    (  no  val  )  Validate  .  notEmpty  (  key  )  ;    if  (  tq  .  matchChomp  (   "] "  )  )  {  return  root  .  getElementsByAttribute  (  key  )  ;  }  else  {  if  (  tq  .  matchChomp  (   "  =   "  )  )  return  root  .  getElementsByAttributeValue  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "!  =   "  )  )  return  root  .  getElementsByAttributeValueNot  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "^  =   "  )  )  return  root  .  getElementsByAttributeValueStarting  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "$  =   "  )  )  return  root  .  getElementsByAttributeValueEnding  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    [ATTENTION]  return  root  .  getElementsByAttributeValueContaining  (  key  ,  tq  .  chompTo  (   "] "  )  )    ;      }  }    [METHOD]  byAttribute  [TYPE]  Elements  [PARAMETER]  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  String[]  combinators  [TYPE]  String  className  combinator  id  key  query  s  subQuery  tagName  [TYPE]  boolean  false  true  [TYPE]  Element  found  root  
[REPLACE]  return  root  .  getElementsByAttributeValueEnding  (  key,  tq  .  chompTo  (   "] "  )  )  ;	[BUGGY]  return  root  .  getElementsByAttributeValueEnding  (  subQuery  ,  tq  .  chompTo  (   "] "  )  )  ;  [CE]  cannot  find  symbol  subQuery  [CONTEXT]  private  Elements  byAttribute  (  )  {  String  key  =  tq  .  consumeToAny  (   "  =   "  ,   "!  =   "  ,   "^  =   "  ,   "$  =   "  ,   "*  =   "  ,   "] "  )  ;  //  eq  ,  not  ,  start  ,  end  ,  contain  ,    (  no  val  )  Validate  .  notEmpty  (  key  )  ;    if  (  tq  .  matchChomp  (   "] "  )  )  {  return  root  .  getElementsByAttribute  (  key  )  ;  }  else  {  if  (  tq  .  matchChomp  (   "  =   "  )  )  return  root  .  getElementsByAttributeValue  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "!  =   "  )  )  return  root  .  getElementsByAttributeValueNot  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "^  =   "  )  )  return  root  .  getElementsByAttributeValueStarting  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "$  =   "  )  )  [ATTENTION]  return  root  .  getElementsByAttributeValueEnding  (  subQuery  ,  tq  .  chompTo  (   "] "  )  )    ;    else  if  (  tq  .  matchChomp  (   "*  =   "  )  )  return  root  .  getElementsByAttributeValueContaining  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  throw  new  SelectorParseException  (   "Could  not  parse  attribute  query   "  +  query  )  ;  }  }    [METHOD]  byAttribute  [TYPE]  Elements  [PARAMETER]  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  String[]  combinators  [TYPE]  String  className  combinator  id  key  query  s  subQuery  tagName  [TYPE]  boolean  false  true  [TYPE]  Element  found  root  
[REPLACE]  else  if  (  tq  .  matchChomp  (   "$= "  )  )  return  root  .  getElementsByAttributeValueEnding  (  key,  tq  .  chompTo  (   "] "  )  )  ;	[BUGGY]  else  if  (  tq  .  matchChomp  (   "$  =   "  )  )  return  root  .  getElementsByAttributeValueEnding  (  subQuery  ,  tq  .  chompTo  (   "] "  )  )  ;  [CE]  cannot  find  symbol  subQuery  [CONTEXT]  private  Elements  byAttribute  (  )  {  String  key  =  tq  .  consumeToAny  (   "  =   "  ,   "!  =   "  ,   "^  =   "  ,   "$  =   "  ,   "*  =   "  ,   "] "  )  ;  //  eq  ,  not  ,  start  ,  end  ,  contain  ,    (  no  val  )  Validate  .  notEmpty  (  key  )  ;    if  (  tq  .  matchChomp  (   "] "  )  )  {  return  root  .  getElementsByAttribute  (  key  )  ;  }  else  {  if  (  tq  .  matchChomp  (   "  =   "  )  )  return  root  .  getElementsByAttributeValue  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "!  =   "  )  )  return  root  .  getElementsByAttributeValueNot  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "^  =   "  )  )  return  root  .  getElementsByAttributeValueStarting  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    [ATTENTION]  else  if  (  tq  .  matchChomp  (   "$  =   "  )  )  return  root  .  getElementsByAttributeValueEnding  (  subQuery  ,  tq  .  chompTo  (   "] "  )  )    ;    else  if  (  tq  .  matchChomp  (   "*  =   "  )  )  return  root  .  getElementsByAttributeValueContaining  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  throw  new  SelectorParseException  (   "Could  not  parse  attribute  query   "  +  query  )  ;  }  }    [METHOD]  byAttribute  [TYPE]  Elements  [PARAMETER]  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  String[]  combinators  [TYPE]  String  className  combinator  id  key  query  s  subQuery  tagName  [TYPE]  boolean  false  true  [TYPE]  Element  found  root  
[REPLACE]  return  root  .  getElementsByAttributeValueStarting  (  key,  tq  .  chompTo  (   "] "  )  )  ;	[BUGGY]  return  root  .  getElementsByAttributeValueStarting  (  key  ,  tq  .  matchChomp  (   "] "  )  )  ;  [CE]  method  getElementsByAttributeValueStarting  in  class  Element  cannot  be  applied  to  given  types  ;  [CONTEXT]  private  Elements  byAttribute  (  )  {  String  key  =  tq  .  consumeToAny  (   "  =   "  ,   "!  =   "  ,   "^  =   "  ,   "$  =   "  ,   "*  =   "  ,   "] "  )  ;  //  eq  ,  not  ,  start  ,  end  ,  contain  ,    (  no  val  )  Validate  .  notEmpty  (  key  )  ;    if  (  tq  .  matchChomp  (   "] "  )  )  {  return  root  .  getElementsByAttribute  (  key  )  ;  }  else  {  if  (  tq  .  matchChomp  (   "  =   "  )  )  return  root  .  getElementsByAttributeValue  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "!  =   "  )  )  return  root  .  getElementsByAttributeValueNot  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "^  =   "  )  )  [ATTENTION]  return  root  .  getElementsByAttributeValueStarting  (  key  ,  tq  .  matchChomp  (   "] "  )  )    ;    else  if  (  tq  .  matchChomp  (   "$  =   "  )  )  return  root  .  getElementsByAttributeValueEnding  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "*  =   "  )  )  return  root  .  getElementsByAttributeValueContaining  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  throw  new  SelectorParseException  (   "Could  not  parse  attribute  query   "  +  query  )  ;  }  }    [METHOD]  byAttribute  [TYPE]  Elements  [PARAMETER]  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  String[]  combinators  [TYPE]  String  className  combinator  id  key  query  s  subQuery  tagName  [TYPE]  boolean  false  true  [TYPE]  Element  found  root  
[REPLACE]  return  root  .  getElementsByAttributeValue  (  key,  tq  .  chompTo  (   "] "  )  )  ;	[BUGGY]  return  root  .  getElementsByAttributeValueNot  (  key  )    ;  [CE]  method  getElementsByAttributeValueNot  in  class  Element  cannot  be  applied  to  given  types  ;  [CONTEXT]  private  Elements  byAttribute  (  )  {  String  key  =  tq  .  consumeToAny  (   "  =   "  ,   "!  =   "  ,   "^  =   "  ,   "$  =   "  ,   "*  =   "  ,   "] "  )  ;  //  eq  ,  not  ,  start  ,  end  ,  contain  ,    (  no  val  )  Validate  .  notEmpty  (  key  )  ;    if  (  tq  .  matchChomp  (   "] "  )  )  {  return  root  .  getElementsByAttribute  (  key  )  ;  }  else  {  if  (  tq  .  matchChomp  (   "  =   "  )  )  [ATTENTION]  return  root  .  getElementsByAttributeValueNot  (  key  )  ;    else  if  (  tq  .  matchChomp  (   "!  =   "  )  )  return  root  .  getElementsByAttributeValueNot  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "^  =   "  )  )  return  root  .  getElementsByAttributeValueStarting  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "$  =   "  )  )  return  root  .  getElementsByAttributeValueEnding  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "*  =   "  )  )  return  root  .  getElementsByAttributeValueContaining  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  throw  new  SelectorParseException  (   "Could  not  parse  attribute  query   "  +  query  )  ;  }  }    [METHOD]  byAttribute  [TYPE]  Elements  [PARAMETER]  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  String[]  combinators  [TYPE]  String  className  combinator  id  key  query  s  subQuery  tagName  [TYPE]  boolean  false  true  [TYPE]  Element  found  root  
[REPLACE]  else  if  (  tq  .  matchChomp  (   "!= "  )  )  return  root  .  getElementsByAttributeValueNot  (  key,  tq  .  chompTo  (   "] "  )  )  ;	[BUGGY]  if  (  tq  .  matchesAny  (   "!  =   "  )  )  return  root  .  getElementsByAttributeValueNot  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;  [FE]  AssertionFailedError    expected:<5>  but  was:<6>  assertEquals(4  ,  withTitle.size())  ;  assertEquals(1  ,  foo.size())  ;  assertEquals(5  ,  not.size())  ;  assertEquals( "Foo "  ,  not.first().attr( "title "))  ;  assertEquals(2  ,  starts.size())  ;  assertEquals( "Bar "  ,  starts.first().attr( "title "))  ;  assertEquals( "Bam "  ,  starts.last().attr( "title "))  ;  assertEquals(2  ,  ends.size())  ;  assertEquals( "Bam "  ,  ends.first().attr( "title "))  ;  assertEquals( "SLAM "  ,  ends.last().attr( "title "))  ;  assertEquals(3  ,  contains.size())  ;  assertEquals( "Bar "  ,  contains.first().attr( "title "))  ;  assertEquals( "SLAM "  ,  contains.last().attr( "title "))  ;  [CONTEXT]  private  Elements  byAttribute  (  )  {  String  key  =  tq  .  consumeToAny  (   "  =   "  ,   "!  =   "  ,   "^  =   "  ,   "$  =   "  ,   "*  =   "  ,   "] "  )  ;  //  eq  ,  not  ,  start  ,  end  ,  contain  ,    (  no  val  )  Validate  .  notEmpty  (  key  )  ;    if  (  tq  .  matchChomp  (   "] "  )  )  {  return  root  .  getElementsByAttribute  (  key  )  ;  }  else  {  if  (  tq  .  matchChomp  (   "  =   "  )  )  return  root  .  getElementsByAttributeValue  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    [ATTENTION]  if  (  tq  .  matchesAny  (   "!  =   "  )  )  return  root  .  getElementsByAttributeValueNot  (  key  ,  tq  .  chompTo  (   "] "  )  )    ;    else  if  (  tq  .  matchChomp  (   "^  =   "  )  )  return  root  .  getElementsByAttributeValueStarting  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "$  =   "  )  )  return  root  .  getElementsByAttributeValueEnding  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "*  =   "  )  )  return  root  .  getElementsByAttributeValueContaining  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  throw  new  SelectorParseException  (   "Could  not  parse  attribute  query   "  +  query  )  ;  }  }    [METHOD]  byAttribute  [TYPE]  Elements  [PARAMETER]  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  String[]  combinators  [TYPE]  String  className  combinator  id  key  query  s  subQuery  tagName  [TYPE]  boolean  false  true  [TYPE]  Element  found  root  
[REPLACE]  else  if  (  tq  .  matchChomp  (   "$= "  )  )  return  root  .  getElementsByAttributeValueEnding  (  key,  tq  .  chompTo  (   "] "  )  )  ;	[BUGGY]  if  (  tq  .  matchChomp  (   "$  =   "  )  )  return  root  .  getElementsByAttributeValueEnding  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;  [NO-ERROR]  [CONTEXT]  private  Elements  byAttribute  (  )  {  String  key  =  tq  .  consumeToAny  (   "  =   "  ,   "!  =   "  ,   "^  =   "  ,   "$  =   "  ,   "*  =   "  ,   "] "  )  ;  //  eq  ,  not  ,  start  ,  end  ,  contain  ,    (  no  val  )  Validate  .  notEmpty  (  key  )  ;    if  (  tq  .  matchChomp  (   "] "  )  )  {  return  root  .  getElementsByAttribute  (  key  )  ;  }  else  {  if  (  tq  .  matchChomp  (   "  =   "  )  )  return  root  .  getElementsByAttributeValue  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "!  =   "  )  )  return  root  .  getElementsByAttributeValueNot  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "^  =   "  )  )  return  root  .  getElementsByAttributeValueStarting  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    [ATTENTION]  if  (  tq  .  matchChomp  (   "$  =   "  )  )  return  root  .  getElementsByAttributeValueEnding  (  key  ,  tq  .  chompTo  (   "] "  )  )    ;    else  if  (  tq  .  matchChomp  (   "*  =   "  )  )  return  root  .  getElementsByAttributeValueContaining  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  throw  new  SelectorParseException  (   "Could  not  parse  attribute  query   "  +  query  )  ;  }  }    [METHOD]  byAttribute  [TYPE]  Elements  [PARAMETER]  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  String[]  combinators  [TYPE]  String  className  combinator  id  key  query  s  subQuery  tagName  [TYPE]  boolean  false  true  [TYPE]  Element  found  root  
[REPLACE]  else  if  (  tq  .  matchChomp  (   "*= "  )  )  return  root  .  getElementsByAttributeValueContaining  (  key,  tq  .  chompTo  (   "] "  )  )  ;	[BUGGY]  if  (  tq  .  matchChomp  (   "*  =   "  )  )  return  root  .  getElementsByAttributeValueContaining  (  subQuery  ,  tq  .  chompTo  (   "] "  )  )  ;  [CE]  cannot  find  symbol  subQuery  [CONTEXT]  private  Elements  byAttribute  (  )  {  String  key  =  tq  .  consumeToAny  (   "  =   "  ,   "!  =   "  ,   "^  =   "  ,   "$  =   "  ,   "*  =   "  ,   "] "  )  ;  //  eq  ,  not  ,  start  ,  end  ,  contain  ,    (  no  val  )  Validate  .  notEmpty  (  key  )  ;    if  (  tq  .  matchChomp  (   "] "  )  )  {  return  root  .  getElementsByAttribute  (  key  )  ;  }  else  {  if  (  tq  .  matchChomp  (   "  =   "  )  )  return  root  .  getElementsByAttributeValue  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "!  =   "  )  )  return  root  .  getElementsByAttributeValueNot  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "^  =   "  )  )  return  root  .  getElementsByAttributeValueStarting  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "$  =   "  )  )  return  root  .  getElementsByAttributeValueEnding  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    [ATTENTION]  if  (  tq  .  matchChomp  (   "*  =   "  )  )  return  root  .  getElementsByAttributeValueContaining  (  subQuery  ,  tq  .  chompTo  (   "] "  )  )    ;    else  throw  new  SelectorParseException  (   "Could  not  parse  attribute  query   "  +  query  )  ;  }  }    [METHOD]  byAttribute  [TYPE]  Elements  [PARAMETER]  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  String[]  combinators  [TYPE]  String  className  combinator  id  key  query  s  subQuery  tagName  [TYPE]  boolean  false  true  [TYPE]  Element  found  root  
[REPLACE]  return  root  .  getElementsByAttributeValueContaining  (  key,  tq  .  chompTo  (   "] "  )  )  ;	[BUGGY]  return  root  .  getElementsByAttributeValueStarting  (  combinator  )    ;  [CE]  cannot  find  symbol  combinator  [CONTEXT]  private  Elements  byAttribute  (  )  {  String  key  =  tq  .  consumeToAny  (   "  =   "  ,   "!  =   "  ,   "^  =   "  ,   "$  =   "  ,   "*  =   "  ,   "] "  )  ;  //  eq  ,  not  ,  start  ,  end  ,  contain  ,    (  no  val  )  Validate  .  notEmpty  (  key  )  ;    if  (  tq  .  matchChomp  (   "] "  )  )  {  return  root  .  getElementsByAttribute  (  key  )  ;  }  else  {  if  (  tq  .  matchChomp  (   "  =   "  )  )  return  root  .  getElementsByAttributeValue  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "!  =   "  )  )  return  root  .  getElementsByAttributeValueNot  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "^  =   "  )  )  return  root  .  getElementsByAttributeValueStarting  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "$  =   "  )  )  return  root  .  getElementsByAttributeValueEnding  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "*  =   "  )  )  [ATTENTION]  return  root  .  getElementsByAttributeValueStarting  (  combinator  )  ;    else  throw  new  SelectorParseException  (   "Could  not  parse  attribute  query   "  +  query  )  ;  }  }    [METHOD]  byAttribute  [TYPE]  Elements  [PARAMETER]  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  String[]  combinators  [TYPE]  String  className  combinator  id  key  query  s  subQuery  tagName  [TYPE]  boolean  false  true  [TYPE]  Element  found  root  
[REPLACE]  else  if  (  tq  .  matchChomp  (   "*= "  )  )  return  root  .  getElementsByAttributeValueContaining  (  key,  tq  .  chompTo  (   "] "  )  )  ;	[BUGGY]  else  if  (  tq  .  matchesWord  (  )    )  return  root  .  getElementsByAttributeValueContaining  (  subQuery  ,  tq  .  chompTo  (   "] "  )  )  ;  [CE]  cannot  find  symbol  subQuery  [CONTEXT]  private  Elements  byAttribute  (  )  {  String  key  =  tq  .  consumeToAny  (   "  =   "  ,   "!  =   "  ,   "^  =   "  ,   "$  =   "  ,   "*  =   "  ,   "] "  )  ;  //  eq  ,  not  ,  start  ,  end  ,  contain  ,    (  no  val  )  Validate  .  notEmpty  (  key  )  ;    if  (  tq  .  matchChomp  (   "] "  )  )  {  return  root  .  getElementsByAttribute  (  key  )  ;  }  else  {  if  (  tq  .  matchChomp  (   "  =   "  )  )  return  root  .  getElementsByAttributeValue  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "!  =   "  )  )  return  root  .  getElementsByAttributeValueNot  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "^  =   "  )  )  return  root  .  getElementsByAttributeValueStarting  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "$  =   "  )  )  return  root  .  getElementsByAttributeValueEnding  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    [ATTENTION]  else  if  (  tq  .  matchesWord  (  )    )  return  root  .  getElementsByAttributeValueContaining  (  subQuery  ,  tq  .  chompTo  (   "] "  )  )    ;    else  throw  new  SelectorParseException  (   "Could  not  parse  attribute  query   "  +  query  )  ;  }  }    [METHOD]  byAttribute  [TYPE]  Elements  [PARAMETER]  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  String[]  combinators  [TYPE]  String  className  combinator  id  key  query  s  subQuery  tagName  [TYPE]  boolean  false  true  [TYPE]  Element  found  root  
[REPLACE]  return  root  .  getElementsByAttributeValue  (  key,  tq  .  chompTo  (   "] "  )  )  ;	[BUGGY]  return  root  .  getElementsByAttributeValueStarting  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;  [NO-ERROR]  [CONTEXT]  private  Elements  byAttribute  (  )  {  String  key  =  tq  .  consumeToAny  (   "  =   "  ,   "!  =   "  ,   "^  =   "  ,   "$  =   "  ,   "*  =   "  ,   "] "  )  ;  //  eq  ,  not  ,  start  ,  end  ,  contain  ,    (  no  val  )  Validate  .  notEmpty  (  key  )  ;    if  (  tq  .  matchChomp  (   "] "  )  )  {  return  root  .  getElementsByAttribute  (  key  )  ;  }  else  {  if  (  tq  .  matchChomp  (   "  =   "  )  )  [ATTENTION]  return  root  .  getElementsByAttributeValueStarting  (  key  ,  tq  .  chompTo  (   "] "  )  )    ;    else  if  (  tq  .  matchChomp  (   "!  =   "  )  )  return  root  .  getElementsByAttributeValueNot  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "^  =   "  )  )  return  root  .  getElementsByAttributeValueStarting  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "$  =   "  )  )  return  root  .  getElementsByAttributeValueEnding  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "*  =   "  )  )  return  root  .  getElementsByAttributeValueContaining  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  throw  new  SelectorParseException  (   "Could  not  parse  attribute  query   "  +  query  )  ;  }  }    [METHOD]  byAttribute  [TYPE]  Elements  [PARAMETER]  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  String[]  combinators  [TYPE]  String  className  combinator  id  key  query  s  subQuery  tagName  [TYPE]  boolean  false  true  [TYPE]  Element  found  root  
[REPLACE]  return  root  .  getElementsByAttributeValueNot  (  key,  tq  .  chompTo  (   "] "  )  )  ;	[BUGGY]  return  root  .  getElementsByAttributeValueNot  (  key  ,  tq  .  matchChomp  (   "] "  )  )  ;  [CE]  method  getElementsByAttributeValueNot  in  class  Element  cannot  be  applied  to  given  types  ;  [CONTEXT]  private  Elements  byAttribute  (  )  {  String  key  =  tq  .  consumeToAny  (   "  =   "  ,   "!  =   "  ,   "^  =   "  ,   "$  =   "  ,   "*  =   "  ,   "] "  )  ;  //  eq  ,  not  ,  start  ,  end  ,  contain  ,    (  no  val  )  Validate  .  notEmpty  (  key  )  ;    if  (  tq  .  matchChomp  (   "] "  )  )  {  return  root  .  getElementsByAttribute  (  key  )  ;  }  else  {  if  (  tq  .  matchChomp  (   "  =   "  )  )  return  root  .  getElementsByAttributeValue  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "!  =   "  )  )  [ATTENTION]  return  root  .  getElementsByAttributeValueNot  (  key  ,  tq  .  matchChomp  (   "] "  )  )    ;    else  if  (  tq  .  matchChomp  (   "^  =   "  )  )  return  root  .  getElementsByAttributeValueStarting  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "$  =   "  )  )  return  root  .  getElementsByAttributeValueEnding  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "*  =   "  )  )  return  root  .  getElementsByAttributeValueContaining  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  throw  new  SelectorParseException  (   "Could  not  parse  attribute  query   "  +  query  )  ;  }  }    [METHOD]  byAttribute  [TYPE]  Elements  [PARAMETER]  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  String[]  combinators  [TYPE]  String  className  combinator  id  key  query  s  subQuery  tagName  [TYPE]  boolean  false  true  [TYPE]  Element  found  root  
[REPLACE]  return  root  .  getElementsByAttributeValueEnding  (  key,  tq  .  chompTo  (   "] "  )  )  ;	[BUGGY]  return  root  .  getElementsByAttributeValueStarting  (  id  )    ;  [CE]  cannot  find  symbol  id  [CONTEXT]  private  Elements  byAttribute  (  )  {  String  key  =  tq  .  consumeToAny  (   "  =   "  ,   "!  =   "  ,   "^  =   "  ,   "$  =   "  ,   "*  =   "  ,   "] "  )  ;  //  eq  ,  not  ,  start  ,  end  ,  contain  ,    (  no  val  )  Validate  .  notEmpty  (  key  )  ;    if  (  tq  .  matchChomp  (   "] "  )  )  {  return  root  .  getElementsByAttribute  (  key  )  ;  }  else  {  if  (  tq  .  matchChomp  (   "  =   "  )  )  return  root  .  getElementsByAttributeValue  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "!  =   "  )  )  return  root  .  getElementsByAttributeValueNot  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "^  =   "  )  )  return  root  .  getElementsByAttributeValueStarting  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "$  =   "  )  )  [ATTENTION]  return  root  .  getElementsByAttributeValueStarting  (  id  )  ;    else  if  (  tq  .  matchChomp  (   "*  =   "  )  )  return  root  .  getElementsByAttributeValueContaining  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  throw  new  SelectorParseException  (   "Could  not  parse  attribute  query   "  +  query  )  ;  }  }    [METHOD]  byAttribute  [TYPE]  Elements  [PARAMETER]  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  String[]  combinators  [TYPE]  String  className  combinator  id  key  query  s  subQuery  tagName  [TYPE]  boolean  false  true  [TYPE]  Element  found  root  
[REPLACE]  return  root  .  getElementsByAttribute  (  key  )  ;	[BUGGY]  return  root  .  getElementsByAttributeValue  (  key  )  ;  [CE]  method  getElementsByAttributeValue  in  class  Element  cannot  be  applied  to  given  types  ;  [CONTEXT]  private  Elements  byAttribute  (  )  {  String  key  =  tq  .  consumeToAny  (   "  =   "  ,   "!  =   "  ,   "^  =   "  ,   "$  =   "  ,   "*  =   "  ,   "] "  )  ;  //  eq  ,  not  ,  start  ,  end  ,  contain  ,    (  no  val  )  Validate  .  notEmpty  (  key  )  ;    if  (  tq  .  matchChomp  (   "] "  )  )  {  [ATTENTION]  return  root  .  getElementsByAttributeValue  (  key  )    ;  }  else  {  if  (  tq  .  matchChomp  (   "  =   "  )  )  return  root  .  getElementsByAttributeValue  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "!  =   "  )  )  return  root  .  getElementsByAttributeValueNot  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "^  =   "  )  )  return  root  .  getElementsByAttributeValueStarting  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "$  =   "  )  )  return  root  .  getElementsByAttributeValueEnding  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "*  =   "  )  )  return  root  .  getElementsByAttributeValueContaining  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  throw  new  SelectorParseException  (   "Could  not  parse  attribute  query   "  +  query  )  ;  }  }    [METHOD]  byAttribute  [TYPE]  Elements  [PARAMETER]  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  String[]  combinators  [TYPE]  String  className  combinator  id  key  query  s  subQuery  tagName  [TYPE]  boolean  false  true  [TYPE]  Element  found  root  
[ADD]  if  (  tq  .  matchChomp  (   "= "  )  )  return  root  .  getElementsByAttributeValue  (  key,  tq  .  chompTo  (   "] "  )  )  ;  else  if  (  tq  .  matchChomp  (   "!= "  )  )  return  root  .  getElementsByAttributeValueNot  (  key,  tq  .  chompTo  (   "] "  )  )  ;	[BUGGY]  return  root  .  getElementsByAttributeValue  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;  return  root  .  getElementsByAttributeValueNot  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;  [CE]  [CONTEXT]  private  Elements  byAttribute  (  )  {  String  key  =  tq  .  consumeToAny  (   "  =   "  ,   "!  =   "  ,   "^  =   "  ,   "$  =   "  ,   "*  =   "  ,   "] "  )  ;  //  eq  ,  not  ,  start  ,  end  ,  contain  ,    (  no  val  )  Validate  .  notEmpty  (  key  )  ;    if  (  tq  .  matchChomp  (   "] "  )  )  {  return  root  .  getElementsByAttribute  (  key  )  ;  }  else  {  [ATTENTION]  return  root  .  getElementsByAttributeValue  (  key  ,  tq  .  chompTo  (   "] "  )  )    ;  return  root  .  getElementsByAttributeValueNot  (  key  ,  tq  .  chompTo  (   "] "  )  )    ;        else  if  (  tq  .  matchChomp  (   "^  =   "  )  )  return  root  .  getElementsByAttributeValueStarting  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "$  =   "  )  )  return  root  .  getElementsByAttributeValueEnding  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "*  =   "  )  )  return  root  .  getElementsByAttributeValueContaining  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  throw  new  SelectorParseException  (   "Could  not  parse  attribute  query   "  +  query  )  ;  }  }    [METHOD]  byAttribute  [TYPE]  Elements  [PARAMETER]  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  String[]  combinators  [TYPE]  String  className  combinator  id  key  query  s  subQuery  tagName  [TYPE]  boolean  false  true  [TYPE]  Element  found  root  
[REMOVE]  	[BUGGY]  if  (  tq  .  matchChomp  (   "*  =   "  )  )      return  root  .  getElementsByAttributeValueContaining  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;  else      throw  new  SelectorParseException  (  (   "Could  not  parse  attribute  query   "  +  (  query  )  )  )  ;  [CE]  [CONTEXT]  private  Elements  byAttribute  (  )  {  String  key  =  tq  .  consumeToAny  (   "  =   "  ,   "!  =   "  ,   "^  =   "  ,   "$  =   "  ,   "*  =   "  ,   "] "  )  ;  //  eq  ,  not  ,  start  ,  end  ,  contain  ,    (  no  val  )  Validate  .  notEmpty  (  key  )  ;    if  (  tq  .  matchChomp  (   "] "  )  )  {  return  root  .  getElementsByAttribute  (  key  )  ;  }  else  {  if  (  tq  .  matchChomp  (   "  =   "  )  )  return  root  .  getElementsByAttributeValue  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "!  =   "  )  )  return  root  .  getElementsByAttributeValueNot  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    [ATTENTION]  else  if  (  tq  .  matchChomp  (   "^  =   "  )  )    if  (  tq  .  matchChomp  (   "*  =   "  )  )  return  root  .  getElementsByAttributeValueContaining  (  key  ,  tq  .  chompTo  (   "] "  )  )    ;  else  throw  new  SelectorParseException  (  (   "Could  not  parse  attribute  query   "  +  (  query  )  )  )    ;  return  root  .  getElementsByAttributeValueStarting  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "$  =   "  )  )  return  root  .  getElementsByAttributeValueEnding  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "*  =   "  )  )  return  root  .  getElementsByAttributeValueContaining  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  throw  new  SelectorParseException  (   "Could  not  parse  attribute  query   "  +  query  )  ;  }    [METHOD]  byAttribute  [TYPE]  Elements  [PARAMETER]  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  String[]  combinators  [TYPE]  String  className  combinator  id  key  query  s  subQuery  tagName  [TYPE]  boolean  false  true  [TYPE]  Element  found  root  
[REPLACE]  else  if  (  tq  .  matchChomp  (   "$= "  )  )  return  root  .  getElementsByAttributeValueEnding  (  key,  tq  .  chompTo  (   "] "  )  )  ;	[BUGGY]  if  (  tq  .  matchesAny  (   "$  =   "  )  )  return  root  .  getElementsByAttributeValueEnding  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;  [FE]  AssertionFailedError    expected:<2>  but  was:<0>  assertEquals(4  ,  withTitle.size())  ;  assertEquals(1  ,  foo.size())  ;  assertEquals(5  ,  not.size())  ;  assertEquals( "Foo "  ,  not.first().attr( "title "))  ;  assertEquals(2  ,  starts.size())  ;  assertEquals( "Bar "  ,  starts.first().attr( "title "))  ;  assertEquals( "Bam "  ,  starts.last().attr( "title "))  ;  assertEquals(2  ,  ends.size())  ;  assertEquals( "Bam "  ,  ends.first().attr( "title "))  ;  assertEquals( "SLAM "  ,  ends.last().attr( "title "))  ;  assertEquals(3  ,  contains.size())  ;  assertEquals( "Bar "  ,  contains.first().attr( "title "))  ;  assertEquals( "SLAM "  ,  contains.last().attr( "title "))  ;  [CONTEXT]  private  Elements  byAttribute  (  )  {  String  key  =  tq  .  consumeToAny  (   "  =   "  ,   "!  =   "  ,   "^  =   "  ,   "$  =   "  ,   "*  =   "  ,   "] "  )  ;  //  eq  ,  not  ,  start  ,  end  ,  contain  ,    (  no  val  )  Validate  .  notEmpty  (  key  )  ;    if  (  tq  .  matchChomp  (   "] "  )  )  {  return  root  .  getElementsByAttribute  (  key  )  ;  }  else  {  if  (  tq  .  matchChomp  (   "  =   "  )  )  return  root  .  getElementsByAttributeValue  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "!  =   "  )  )  return  root  .  getElementsByAttributeValueNot  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "^  =   "  )  )  return  root  .  getElementsByAttributeValueStarting  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    [ATTENTION]  if  (  tq  .  matchesAny  (   "$  =   "  )  )  return  root  .  getElementsByAttributeValueEnding  (  key  ,  tq  .  chompTo  (   "] "  )  )    ;    else  if  (  tq  .  matchChomp  (   "*  =   "  )  )  return  root  .  getElementsByAttributeValueContaining  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  throw  new  SelectorParseException  (   "Could  not  parse  attribute  query   "  +  query  )  ;  }  }    [METHOD]  byAttribute  [TYPE]  Elements  [PARAMETER]  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  String[]  combinators  [TYPE]  String  className  combinator  id  key  query  s  subQuery  tagName  [TYPE]  boolean  false  true  [TYPE]  Element  found  root  
[REPLACE]  else  if  (  tq  .  matchChomp  (   "*= "  )  )  return  root  .  getElementsByAttributeValueContaining  (  key,  tq  .  chompTo  (   "] "  )  )  ;	[BUGGY]  else  if  (  tq  .  matchChomp  (   "*  =   "  )  )  return  root  .  getElementsByAttributeValueContaining  (  subQuery  ,  tq  .  chompTo  (   "] "  )  )  ;  [CE]  cannot  find  symbol  subQuery  [CONTEXT]  private  Elements  byAttribute  (  )  {  String  key  =  tq  .  consumeToAny  (   "  =   "  ,   "!  =   "  ,   "^  =   "  ,   "$  =   "  ,   "*  =   "  ,   "] "  )  ;  //  eq  ,  not  ,  start  ,  end  ,  contain  ,    (  no  val  )  Validate  .  notEmpty  (  key  )  ;    if  (  tq  .  matchChomp  (   "] "  )  )  {  return  root  .  getElementsByAttribute  (  key  )  ;  }  else  {  if  (  tq  .  matchChomp  (   "  =   "  )  )  return  root  .  getElementsByAttributeValue  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "!  =   "  )  )  return  root  .  getElementsByAttributeValueNot  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "^  =   "  )  )  return  root  .  getElementsByAttributeValueStarting  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "$  =   "  )  )  return  root  .  getElementsByAttributeValueEnding  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    [ATTENTION]  else  if  (  tq  .  matchChomp  (   "*  =   "  )  )  return  root  .  getElementsByAttributeValueContaining  (  subQuery  ,  tq  .  chompTo  (   "] "  )  )    ;    else  throw  new  SelectorParseException  (   "Could  not  parse  attribute  query   "  +  query  )  ;  }  }    [METHOD]  byAttribute  [TYPE]  Elements  [PARAMETER]  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  String[]  combinators  [TYPE]  String  className  combinator  id  key  query  s  subQuery  tagName  [TYPE]  boolean  false  true  [TYPE]  Element  found  root  
[REPLACE]  return  root  .  getElementsByAttributeValueEnding  (  key,  tq  .  chompTo  (   "] "  )  )  ;	[BUGGY]  return  root  .  getElementsByAttributeValueStarting  (  className  )    ;  [CE]  cannot  find  symbol  className  [CONTEXT]  private  Elements  byAttribute  (  )  {  String  key  =  tq  .  consumeToAny  (   "  =   "  ,   "!  =   "  ,   "^  =   "  ,   "$  =   "  ,   "*  =   "  ,   "] "  )  ;  //  eq  ,  not  ,  start  ,  end  ,  contain  ,    (  no  val  )  Validate  .  notEmpty  (  key  )  ;    if  (  tq  .  matchChomp  (   "] "  )  )  {  return  root  .  getElementsByAttribute  (  key  )  ;  }  else  {  if  (  tq  .  matchChomp  (   "  =   "  )  )  return  root  .  getElementsByAttributeValue  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "!  =   "  )  )  return  root  .  getElementsByAttributeValueNot  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "^  =   "  )  )  return  root  .  getElementsByAttributeValueStarting  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "$  =   "  )  )  [ATTENTION]  return  root  .  getElementsByAttributeValueStarting  (  className  )  ;    else  if  (  tq  .  matchChomp  (   "*  =   "  )  )  return  root  .  getElementsByAttributeValueContaining  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  throw  new  SelectorParseException  (   "Could  not  parse  attribute  query   "  +  query  )  ;  }  }    [METHOD]  byAttribute  [TYPE]  Elements  [PARAMETER]  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  String[]  combinators  [TYPE]  String  className  combinator  id  key  query  s  subQuery  tagName  [TYPE]  boolean  false  true  [TYPE]  Element  found  root  
[ADD]  else  if  (  tq  .  matchChomp  (   "$= "  )  )  return  root  .  getElementsByAttributeValueEnding  (  key,  tq  .  chompTo  (   "] "  )  )  ;  else  if  (  tq  .  matchChomp  (   "*= "  )  )  return  root  .  getElementsByAttributeValueContaining  (  key,  tq  .  chompTo  (   "] "  )  )  ;	[BUGGY]  return  root  .  getElementsByAttributeValueEnding  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;  return  root  .  getElementsByAttributeValueContaining  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;  [CE]  'else'  without  'if'  [CONTEXT]  private  Elements  byAttribute  (  )  {  String  key  =  tq  .  consumeToAny  (   "  =   "  ,   "!  =   "  ,   "^  =   "  ,   "$  =   "  ,   "*  =   "  ,   "] "  )  ;  //  eq  ,  not  ,  start  ,  end  ,  contain  ,    (  no  val  )  Validate  .  notEmpty  (  key  )  ;    if  (  tq  .  matchChomp  (   "] "  )  )  {  return  root  .  getElementsByAttribute  (  key  )  ;  }  else  {  if  (  tq  .  matchChomp  (   "  =   "  )  )  return  root  .  getElementsByAttributeValue  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "!  =   "  )  )  return  root  .  getElementsByAttributeValueNot  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "^  =   "  )  )  return  root  .  getElementsByAttributeValueStarting  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    [ATTENTION]  return  root  .  getElementsByAttributeValueEnding  (  key  ,  tq  .  chompTo  (   "] "  )  )    ;  return  root  .  getElementsByAttributeValueContaining  (  key  ,  tq  .  chompTo  (   "] "  )  )    ;        else  throw  new  SelectorParseException  (   "Could  not  parse  attribute  query   "  +  query  )  ;  }  }    [METHOD]  byAttribute  [TYPE]  Elements  [PARAMETER]  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  String[]  combinators  [TYPE]  String  className  combinator  id  key  query  s  subQuery  tagName  [TYPE]  boolean  false  true  [TYPE]  Element  found  root  
[REPLACE]  return  root  .  getElementsByAttributeValueEnding  (  key,  tq  .  chompTo  (   "] "  )  )  ;	[BUGGY]  return  root  .  getElementsByAttributeValueStarting  (  subQuery  )    ;  [CE]  cannot  find  symbol  subQuery  [CONTEXT]  private  Elements  byAttribute  (  )  {  String  key  =  tq  .  consumeToAny  (   "  =   "  ,   "!  =   "  ,   "^  =   "  ,   "$  =   "  ,   "*  =   "  ,   "] "  )  ;  //  eq  ,  not  ,  start  ,  end  ,  contain  ,    (  no  val  )  Validate  .  notEmpty  (  key  )  ;    if  (  tq  .  matchChomp  (   "] "  )  )  {  return  root  .  getElementsByAttribute  (  key  )  ;  }  else  {  if  (  tq  .  matchChomp  (   "  =   "  )  )  return  root  .  getElementsByAttributeValue  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "!  =   "  )  )  return  root  .  getElementsByAttributeValueNot  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "^  =   "  )  )  return  root  .  getElementsByAttributeValueStarting  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "$  =   "  )  )  [ATTENTION]  return  root  .  getElementsByAttributeValueStarting  (  subQuery  )  ;    else  if  (  tq  .  matchChomp  (   "*  =   "  )  )  return  root  .  getElementsByAttributeValueContaining  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  throw  new  SelectorParseException  (   "Could  not  parse  attribute  query   "  +  query  )  ;  }  }    [METHOD]  byAttribute  [TYPE]  Elements  [PARAMETER]  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  String[]  combinators  [TYPE]  String  className  combinator  id  key  query  s  subQuery  tagName  [TYPE]  boolean  false  true  [TYPE]  Element  found  root  
[REPLACE]  else  if  (  tq  .  matchChomp  (   "*= "  )  )  return  root  .  getElementsByAttributeValueContaining  (  key,  tq  .  chompTo  (   "] "  )  )  ;	[BUGGY]  else  if  (  tq  .  matchChomp  (   "$  =   "  )  )  return  root  .  getElementsByAttributeValueEnding  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;  [FE]  Could  not  parse  attribute  query  a[href*  =  naughty-corners-are-a-bad-idea]  assertEquals( "News.com.au  |  News  from  Australia  and  around  the  world  online  |  NewsComAu "  ,  doc.title())  ;  assertEquals( "Brace  yourself  for  Metro  meltdown "  ,  doc.select( ".id1225817868581  h4 ").text().trim())  ;  assertEquals( "/entertainment/horoscopes "  ,  a.attr( "href "))  ;  assertEquals( "http://www.news.com.au/entertainment/horoscopes "  ,  a.attr( "abs:href "))  ;  assertEquals( "http://www.heraldsun.com.au/news/naughty-corners-are-a-bad-idea-for-kids/story-e6frf7jo-1225817899003 "  ,  hs.attr( "href "))  ;  assertEquals(hs.attr( "href ")  ,  hs.attr( "abs:href "))  ;  [CONTEXT]  private  Elements  byAttribute  (  )  {  String  key  =  tq  .  consumeToAny  (   "  =   "  ,   "!  =   "  ,   "^  =   "  ,   "$  =   "  ,   "*  =   "  ,   "] "  )  ;  //  eq  ,  not  ,  start  ,  end  ,  contain  ,    (  no  val  )  Validate  .  notEmpty  (  key  )  ;    if  (  tq  .  matchChomp  (   "] "  )  )  {  return  root  .  getElementsByAttribute  (  key  )  ;  }  else  {  if  (  tq  .  matchChomp  (   "  =   "  )  )  return  root  .  getElementsByAttributeValue  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "!  =   "  )  )  return  root  .  getElementsByAttributeValueNot  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "^  =   "  )  )  return  root  .  getElementsByAttributeValueStarting  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "$  =   "  )  )  return  root  .  getElementsByAttributeValueEnding  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    [ATTENTION]  else  if  (  tq  .  matchChomp  (   "$  =   "  )  )  return  root  .  getElementsByAttributeValueEnding  (  key  ,  tq  .  chompTo  (   "] "  )  )    ;    else  throw  new  SelectorParseException  (   "Could  not  parse  attribute  query   "  +  query  )  ;  }  }    [METHOD]  byAttribute  [TYPE]  Elements  [PARAMETER]  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  String[]  combinators  [TYPE]  String  className  combinator  id  key  query  s  subQuery  tagName  [TYPE]  boolean  false  true  [TYPE]  Element  found  root  
[REPLACE]  else  if  (  tq  .  matchChomp  (   "*= "  )  )  return  root  .  getElementsByAttributeValueContaining  (  key,  tq  .  chompTo  (   "] "  )  )  ;	[BUGGY]  else  if  (  tq  .  matchesWord  (  )    )  return  root  .  getElementsByAttributeValueContaining  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;  [FE]  Could  not  parse  attribute  query  a[href*  =  naughty-corners-are-a-bad-idea]  assertEquals( "News.com.au  |  News  from  Australia  and  around  the  world  online  |  NewsComAu "  ,  doc.title())  ;  assertEquals( "Brace  yourself  for  Metro  meltdown "  ,  doc.select( ".id1225817868581  h4 ").text().trim())  ;  assertEquals( "/entertainment/horoscopes "  ,  a.attr( "href "))  ;  assertEquals( "http://www.news.com.au/entertainment/horoscopes "  ,  a.attr( "abs:href "))  ;  assertEquals( "http://www.heraldsun.com.au/news/naughty-corners-are-a-bad-idea-for-kids/story-e6frf7jo-1225817899003 "  ,  hs.attr( "href "))  ;  assertEquals(hs.attr( "href ")  ,  hs.attr( "abs:href "))  ;  [CONTEXT]  private  Elements  byAttribute  (  )  {  String  key  =  tq  .  consumeToAny  (   "  =   "  ,   "!  =   "  ,   "^  =   "  ,   "$  =   "  ,   "*  =   "  ,   "] "  )  ;  //  eq  ,  not  ,  start  ,  end  ,  contain  ,    (  no  val  )  Validate  .  notEmpty  (  key  )  ;    if  (  tq  .  matchChomp  (   "] "  )  )  {  return  root  .  getElementsByAttribute  (  key  )  ;  }  else  {  if  (  tq  .  matchChomp  (   "  =   "  )  )  return  root  .  getElementsByAttributeValue  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "!  =   "  )  )  return  root  .  getElementsByAttributeValueNot  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "^  =   "  )  )  return  root  .  getElementsByAttributeValueStarting  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "$  =   "  )  )  return  root  .  getElementsByAttributeValueEnding  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    [ATTENTION]  else  if  (  tq  .  matchesWord  (  )    )  return  root  .  getElementsByAttributeValueContaining  (  key  ,  tq  .  chompTo  (   "] "  )  )    ;    else  throw  new  SelectorParseException  (   "Could  not  parse  attribute  query   "  +  query  )  ;  }  }    [METHOD]  byAttribute  [TYPE]  Elements  [PARAMETER]  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  String[]  combinators  [TYPE]  String  className  combinator  id  key  query  s  subQuery  tagName  [TYPE]  boolean  false  true  [TYPE]  Element  found  root  
[REPLACE]  return  root  .  getElementsByAttributeValueEnding  (  key,  tq  .  chompTo  (   "] "  )  )  ;	[BUGGY]  return  root  .  getElementsByAttributeValueStarting  (  tagName  )    ;  [CE]  cannot  find  symbol  tagName  [CONTEXT]  private  Elements  byAttribute  (  )  {  String  key  =  tq  .  consumeToAny  (   "  =   "  ,   "!  =   "  ,   "^  =   "  ,   "$  =   "  ,   "*  =   "  ,   "] "  )  ;  //  eq  ,  not  ,  start  ,  end  ,  contain  ,    (  no  val  )  Validate  .  notEmpty  (  key  )  ;    if  (  tq  .  matchChomp  (   "] "  )  )  {  return  root  .  getElementsByAttribute  (  key  )  ;  }  else  {  if  (  tq  .  matchChomp  (   "  =   "  )  )  return  root  .  getElementsByAttributeValue  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "!  =   "  )  )  return  root  .  getElementsByAttributeValueNot  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "^  =   "  )  )  return  root  .  getElementsByAttributeValueStarting  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "$  =   "  )  )  [ATTENTION]  return  root  .  getElementsByAttributeValueStarting  (  tagName  )  ;    else  if  (  tq  .  matchChomp  (   "*  =   "  )  )  return  root  .  getElementsByAttributeValueContaining  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  throw  new  SelectorParseException  (   "Could  not  parse  attribute  query   "  +  query  )  ;  }  }    [METHOD]  byAttribute  [TYPE]  Elements  [PARAMETER]  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  String[]  combinators  [TYPE]  String  className  combinator  id  key  query  s  subQuery  tagName  [TYPE]  boolean  false  true  [TYPE]  Element  found  root  
[REPLACE]  return  root  .  getElementsByAttributeValueEnding  (  key,  tq  .  chompTo  (   "] "  )  )  ;	[BUGGY]  return  root  .  getElementsByAttributeValueStarting  (  s  )    ;  [CE]  cannot  find  symbol  s  [CONTEXT]  private  Elements  byAttribute  (  )  {  String  key  =  tq  .  consumeToAny  (   "  =   "  ,   "!  =   "  ,   "^  =   "  ,   "$  =   "  ,   "*  =   "  ,   "] "  )  ;  //  eq  ,  not  ,  start  ,  end  ,  contain  ,    (  no  val  )  Validate  .  notEmpty  (  key  )  ;    if  (  tq  .  matchChomp  (   "] "  )  )  {  return  root  .  getElementsByAttribute  (  key  )  ;  }  else  {  if  (  tq  .  matchChomp  (   "  =   "  )  )  return  root  .  getElementsByAttributeValue  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "!  =   "  )  )  return  root  .  getElementsByAttributeValueNot  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "^  =   "  )  )  return  root  .  getElementsByAttributeValueStarting  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "$  =   "  )  )  [ATTENTION]  return  root  .  getElementsByAttributeValueStarting  (  s  )  ;    else  if  (  tq  .  matchChomp  (   "*  =   "  )  )  return  root  .  getElementsByAttributeValueContaining  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  throw  new  SelectorParseException  (   "Could  not  parse  attribute  query   "  +  query  )  ;  }  }    [METHOD]  byAttribute  [TYPE]  Elements  [PARAMETER]  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  String[]  combinators  [TYPE]  String  className  combinator  id  key  query  s  subQuery  tagName  [TYPE]  boolean  false  true  [TYPE]  Element  found  root  
[REPLACE]  return  root  .  getElementsByAttributeValueNot  (  key,  tq  .  chompTo  (   "] "  )  )  ;	[BUGGY]  return  root  .  getElementsByAttributeValue  (  query  )    ;  [CE]  method  getElementsByAttributeValue  in  class  Element  cannot  be  applied  to  given  types  ;  [CONTEXT]  private  Elements  byAttribute  (  )  {  String  key  =  tq  .  consumeToAny  (   "  =   "  ,   "!  =   "  ,   "^  =   "  ,   "$  =   "  ,   "*  =   "  ,   "] "  )  ;  //  eq  ,  not  ,  start  ,  end  ,  contain  ,    (  no  val  )  Validate  .  notEmpty  (  key  )  ;    if  (  tq  .  matchChomp  (   "] "  )  )  {  return  root  .  getElementsByAttribute  (  key  )  ;  }  else  {  if  (  tq  .  matchChomp  (   "  =   "  )  )  return  root  .  getElementsByAttributeValue  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "!  =   "  )  )  [ATTENTION]  return  root  .  getElementsByAttributeValue  (  query  )  ;    else  if  (  tq  .  matchChomp  (   "^  =   "  )  )  return  root  .  getElementsByAttributeValueStarting  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "$  =   "  )  )  return  root  .  getElementsByAttributeValueEnding  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "*  =   "  )  )  return  root  .  getElementsByAttributeValueContaining  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  throw  new  SelectorParseException  (   "Could  not  parse  attribute  query   "  +  query  )  ;  }  }    [METHOD]  byAttribute  [TYPE]  Elements  [PARAMETER]  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  String[]  combinators  [TYPE]  String  className  combinator  id  key  query  s  subQuery  tagName  [TYPE]  boolean  false  true  [TYPE]  Element  found  root  
[REPLACE]  return  root  .  getElementsByAttributeValueStarting  (  key,  tq  .  chompTo  (   "] "  )  )  ;	[BUGGY]  return  root  .  getElementsByAttributeValueStarting  (  subQuery  ,  tq  .  matchChomp  (   "] "  )  )  ;  [CE]  cannot  find  symbol  subQuery  [CONTEXT]  private  Elements  byAttribute  (  )  {  String  key  =  tq  .  consumeToAny  (   "  =   "  ,   "!  =   "  ,   "^  =   "  ,   "$  =   "  ,   "*  =   "  ,   "] "  )  ;  //  eq  ,  not  ,  start  ,  end  ,  contain  ,    (  no  val  )  Validate  .  notEmpty  (  key  )  ;    if  (  tq  .  matchChomp  (   "] "  )  )  {  return  root  .  getElementsByAttribute  (  key  )  ;  }  else  {  if  (  tq  .  matchChomp  (   "  =   "  )  )  return  root  .  getElementsByAttributeValue  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "!  =   "  )  )  return  root  .  getElementsByAttributeValueNot  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "^  =   "  )  )  [ATTENTION]  return  root  .  getElementsByAttributeValueStarting  (  subQuery  ,  tq  .  matchChomp  (   "] "  )  )    ;    else  if  (  tq  .  matchChomp  (   "$  =   "  )  )  return  root  .  getElementsByAttributeValueEnding  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "*  =   "  )  )  return  root  .  getElementsByAttributeValueContaining  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  throw  new  SelectorParseException  (   "Could  not  parse  attribute  query   "  +  query  )  ;  }  }    [METHOD]  byAttribute  [TYPE]  Elements  [PARAMETER]  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  String[]  combinators  [TYPE]  String  className  combinator  id  key  query  s  subQuery  tagName  [TYPE]  boolean  false  true  [TYPE]  Element  found  root  
[REPLACE]  return  root  .  getElementsByAttributeValue  (  key,  tq  .  chompTo  (   "] "  )  )  ;	[BUGGY]  return  root  .  getElementsByAttributeValue  (  subQuery  ,  tq  .  chompTo  (   "] "  )  )  ;  [CE]  cannot  find  symbol  subQuery  [CONTEXT]  private  Elements  byAttribute  (  )  {  String  key  =  tq  .  consumeToAny  (   "  =   "  ,   "!  =   "  ,   "^  =   "  ,   "$  =   "  ,   "*  =   "  ,   "] "  )  ;  //  eq  ,  not  ,  start  ,  end  ,  contain  ,    (  no  val  )  Validate  .  notEmpty  (  key  )  ;    if  (  tq  .  matchChomp  (   "] "  )  )  {  return  root  .  getElementsByAttribute  (  key  )  ;  }  else  {  if  (  tq  .  matchChomp  (   "  =   "  )  )  [ATTENTION]  return  root  .  getElementsByAttributeValue  (  subQuery  ,  tq  .  chompTo  (   "] "  )  )    ;    else  if  (  tq  .  matchChomp  (   "!  =   "  )  )  return  root  .  getElementsByAttributeValueNot  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "^  =   "  )  )  return  root  .  getElementsByAttributeValueStarting  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "$  =   "  )  )  return  root  .  getElementsByAttributeValueEnding  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "*  =   "  )  )  return  root  .  getElementsByAttributeValueContaining  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  throw  new  SelectorParseException  (   "Could  not  parse  attribute  query   "  +  query  )  ;  }  }    [METHOD]  byAttribute  [TYPE]  Elements  [PARAMETER]  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  String[]  combinators  [TYPE]  String  className  combinator  id  key  query  s  subQuery  tagName  [TYPE]  boolean  false  true  [TYPE]  Element  found  root  
[REPLACE]  return  root  .  getElementsByAttributeValueEnding  (  key,  tq  .  chompTo  (   "] "  )  )  ;	[BUGGY]  return  root  .  getElementsByAttributeValueStarting  (  query  )    ;  [CE]  method  getElementsByAttributeValueStarting  in  class  Element  cannot  be  applied  to  given  types  ;  [CONTEXT]  private  Elements  byAttribute  (  )  {  String  key  =  tq  .  consumeToAny  (   "  =   "  ,   "!  =   "  ,   "^  =   "  ,   "$  =   "  ,   "*  =   "  ,   "] "  )  ;  //  eq  ,  not  ,  start  ,  end  ,  contain  ,    (  no  val  )  Validate  .  notEmpty  (  key  )  ;    if  (  tq  .  matchChomp  (   "] "  )  )  {  return  root  .  getElementsByAttribute  (  key  )  ;  }  else  {  if  (  tq  .  matchChomp  (   "  =   "  )  )  return  root  .  getElementsByAttributeValue  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "!  =   "  )  )  return  root  .  getElementsByAttributeValueNot  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "^  =   "  )  )  return  root  .  getElementsByAttributeValueStarting  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "$  =   "  )  )  [ATTENTION]  return  root  .  getElementsByAttributeValueStarting  (  query  )  ;    else  if  (  tq  .  matchChomp  (   "*  =   "  )  )  return  root  .  getElementsByAttributeValueContaining  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  throw  new  SelectorParseException  (   "Could  not  parse  attribute  query   "  +  query  )  ;  }  }    [METHOD]  byAttribute  [TYPE]  Elements  [PARAMETER]  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  String[]  combinators  [TYPE]  String  className  combinator  id  key  query  s  subQuery  tagName  [TYPE]  boolean  false  true  [TYPE]  Element  found  root  
[REPLACE]  return  root  .  getElementsByAttributeValueEnding  (  key,  tq  .  chompTo  (   "] "  )  )  ;	[BUGGY]  return  root  .  getElementsByAttributeValueEnding  (  subQuery  ,  tq  .  matchChomp  (   "] "  )  )  ;  [CE]  cannot  find  symbol  subQuery  [CONTEXT]  private  Elements  byAttribute  (  )  {  String  key  =  tq  .  consumeToAny  (   "  =   "  ,   "!  =   "  ,   "^  =   "  ,   "$  =   "  ,   "*  =   "  ,   "] "  )  ;  //  eq  ,  not  ,  start  ,  end  ,  contain  ,    (  no  val  )  Validate  .  notEmpty  (  key  )  ;    if  (  tq  .  matchChomp  (   "] "  )  )  {  return  root  .  getElementsByAttribute  (  key  )  ;  }  else  {  if  (  tq  .  matchChomp  (   "  =   "  )  )  return  root  .  getElementsByAttributeValue  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "!  =   "  )  )  return  root  .  getElementsByAttributeValueNot  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "^  =   "  )  )  return  root  .  getElementsByAttributeValueStarting  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "$  =   "  )  )  [ATTENTION]  return  root  .  getElementsByAttributeValueEnding  (  subQuery  ,  tq  .  matchChomp  (   "] "  )  )    ;    else  if  (  tq  .  matchChomp  (   "*  =   "  )  )  return  root  .  getElementsByAttributeValueContaining  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  throw  new  SelectorParseException  (   "Could  not  parse  attribute  query   "  +  query  )  ;  }  }    [METHOD]  byAttribute  [TYPE]  Elements  [PARAMETER]  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  String[]  combinators  [TYPE]  String  className  combinator  id  key  query  s  subQuery  tagName  [TYPE]  boolean  false  true  [TYPE]  Element  found  root  
[REPLACE]  return  root  .  getElementsByAttributeValueNot  (  key,  tq  .  chompTo  (   "] "  )  )  ;	[BUGGY]  return  root  .  getElementsByAttributeValueNot  (  subQuery  ,  tq  .  matchChomp  (   "] "  )  )  ;  [CE]  cannot  find  symbol  subQuery  [CONTEXT]  private  Elements  byAttribute  (  )  {  String  key  =  tq  .  consumeToAny  (   "  =   "  ,   "!  =   "  ,   "^  =   "  ,   "$  =   "  ,   "*  =   "  ,   "] "  )  ;  //  eq  ,  not  ,  start  ,  end  ,  contain  ,    (  no  val  )  Validate  .  notEmpty  (  key  )  ;    if  (  tq  .  matchChomp  (   "] "  )  )  {  return  root  .  getElementsByAttribute  (  key  )  ;  }  else  {  if  (  tq  .  matchChomp  (   "  =   "  )  )  return  root  .  getElementsByAttributeValue  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "!  =   "  )  )  [ATTENTION]  return  root  .  getElementsByAttributeValueNot  (  subQuery  ,  tq  .  matchChomp  (   "] "  )  )    ;    else  if  (  tq  .  matchChomp  (   "^  =   "  )  )  return  root  .  getElementsByAttributeValueStarting  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "$  =   "  )  )  return  root  .  getElementsByAttributeValueEnding  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "*  =   "  )  )  return  root  .  getElementsByAttributeValueContaining  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  throw  new  SelectorParseException  (   "Could  not  parse  attribute  query   "  +  query  )  ;  }  }    [METHOD]  byAttribute  [TYPE]  Elements  [PARAMETER]  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  String[]  combinators  [TYPE]  String  className  combinator  id  key  query  s  subQuery  tagName  [TYPE]  boolean  false  true  [TYPE]  Element  found  root  
[REPLACE]  return  root  .  getElementsByAttributeValueContaining  (  key,  tq  .  chompTo  (   "] "  )  )  ;	[BUGGY]  return  root  .  getElementsByAttributeValueStarting  (  subQuery  )    ;  [CE]  cannot  find  symbol  subQuery  [CONTEXT]  private  Elements  byAttribute  (  )  {  String  key  =  tq  .  consumeToAny  (   "  =   "  ,   "!  =   "  ,   "^  =   "  ,   "$  =   "  ,   "*  =   "  ,   "] "  )  ;  //  eq  ,  not  ,  start  ,  end  ,  contain  ,    (  no  val  )  Validate  .  notEmpty  (  key  )  ;    if  (  tq  .  matchChomp  (   "] "  )  )  {  return  root  .  getElementsByAttribute  (  key  )  ;  }  else  {  if  (  tq  .  matchChomp  (   "  =   "  )  )  return  root  .  getElementsByAttributeValue  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "!  =   "  )  )  return  root  .  getElementsByAttributeValueNot  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "^  =   "  )  )  return  root  .  getElementsByAttributeValueStarting  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "$  =   "  )  )  return  root  .  getElementsByAttributeValueEnding  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "*  =   "  )  )  [ATTENTION]  return  root  .  getElementsByAttributeValueStarting  (  subQuery  )  ;    else  throw  new  SelectorParseException  (   "Could  not  parse  attribute  query   "  +  query  )  ;  }  }    [METHOD]  byAttribute  [TYPE]  Elements  [PARAMETER]  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  String[]  combinators  [TYPE]  String  className  combinator  id  key  query  s  subQuery  tagName  [TYPE]  boolean  false  true  [TYPE]  Element  found  root  
[REPLACE]  return  root  .  getElementsByAttributeValueContaining  (  key,  tq  .  chompTo  (   "] "  )  )  ;	[BUGGY]  return  root  .  getElementsByAttributeValueContaining  (  subQuery  ,  tq  .  isEmpty  (  )    )  ;  [CE]  cannot  find  symbol  subQuery  [CONTEXT]  private  Elements  byAttribute  (  )  {  String  key  =  tq  .  consumeToAny  (   "  =   "  ,   "!  =   "  ,   "^  =   "  ,   "$  =   "  ,   "*  =   "  ,   "] "  )  ;  //  eq  ,  not  ,  start  ,  end  ,  contain  ,    (  no  val  )  Validate  .  notEmpty  (  key  )  ;    if  (  tq  .  matchChomp  (   "] "  )  )  {  return  root  .  getElementsByAttribute  (  key  )  ;  }  else  {  if  (  tq  .  matchChomp  (   "  =   "  )  )  return  root  .  getElementsByAttributeValue  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "!  =   "  )  )  return  root  .  getElementsByAttributeValueNot  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "^  =   "  )  )  return  root  .  getElementsByAttributeValueStarting  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "$  =   "  )  )  return  root  .  getElementsByAttributeValueEnding  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "*  =   "  )  )  [ATTENTION]  return  root  .  getElementsByAttributeValueContaining  (  subQuery  ,  tq  .  isEmpty  (  )    )    ;    else  throw  new  SelectorParseException  (   "Could  not  parse  attribute  query   "  +  query  )  ;  }  }    [METHOD]  byAttribute  [TYPE]  Elements  [PARAMETER]  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  String[]  combinators  [TYPE]  String  className  combinator  id  key  query  s  subQuery  tagName  [TYPE]  boolean  false  true  [TYPE]  Element  found  root  
[REPLACE]  else  if  (  tq  .  matchChomp  (   "$= "  )  )  return  root  .  getElementsByAttributeValueEnding  (  key,  tq  .  chompTo  (   "] "  )  )  ;	[BUGGY]  else  if  (  tq  .  matchesAny  (   "$  =   "  )  )  return  root  .  getElementsByAttributeValueEnding  (  subQuery  ,  tq  .  chompTo  (   "] "  )  )  ;  [CE]  cannot  find  symbol  subQuery  [CONTEXT]  private  Elements  byAttribute  (  )  {  String  key  =  tq  .  consumeToAny  (   "  =   "  ,   "!  =   "  ,   "^  =   "  ,   "$  =   "  ,   "*  =   "  ,   "] "  )  ;  //  eq  ,  not  ,  start  ,  end  ,  contain  ,    (  no  val  )  Validate  .  notEmpty  (  key  )  ;    if  (  tq  .  matchChomp  (   "] "  )  )  {  return  root  .  getElementsByAttribute  (  key  )  ;  }  else  {  if  (  tq  .  matchChomp  (   "  =   "  )  )  return  root  .  getElementsByAttributeValue  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "!  =   "  )  )  return  root  .  getElementsByAttributeValueNot  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "^  =   "  )  )  return  root  .  getElementsByAttributeValueStarting  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    [ATTENTION]  else  if  (  tq  .  matchesAny  (   "$  =   "  )  )  return  root  .  getElementsByAttributeValueEnding  (  subQuery  ,  tq  .  chompTo  (   "] "  )  )    ;    else  if  (  tq  .  matchChomp  (   "*  =   "  )  )  return  root  .  getElementsByAttributeValueContaining  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  throw  new  SelectorParseException  (   "Could  not  parse  attribute  query   "  +  query  )  ;  }  }    [METHOD]  byAttribute  [TYPE]  Elements  [PARAMETER]  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  String[]  combinators  [TYPE]  String  className  combinator  id  key  query  s  subQuery  tagName  [TYPE]  boolean  false  true  [TYPE]  Element  found  root  
[REPLACE]  return  root  .  getElementsByAttributeValue  (  key,  tq  .  chompTo  (   "] "  )  )  ;	[BUGGY]  return  root  .  getElementsByAttributeValue  (  key  ,  tq  .  matchChomp  (   "] "  )  )  ;  [CE]  method  getElementsByAttributeValue  in  class  Element  cannot  be  applied  to  given  types  ;  [CONTEXT]  private  Elements  byAttribute  (  )  {  String  key  =  tq  .  consumeToAny  (   "  =   "  ,   "!  =   "  ,   "^  =   "  ,   "$  =   "  ,   "*  =   "  ,   "] "  )  ;  //  eq  ,  not  ,  start  ,  end  ,  contain  ,    (  no  val  )  Validate  .  notEmpty  (  key  )  ;    if  (  tq  .  matchChomp  (   "] "  )  )  {  return  root  .  getElementsByAttribute  (  key  )  ;  }  else  {  if  (  tq  .  matchChomp  (   "  =   "  )  )  [ATTENTION]  return  root  .  getElementsByAttributeValue  (  key  ,  tq  .  matchChomp  (   "] "  )  )    ;    else  if  (  tq  .  matchChomp  (   "!  =   "  )  )  return  root  .  getElementsByAttributeValueNot  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "^  =   "  )  )  return  root  .  getElementsByAttributeValueStarting  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "$  =   "  )  )  return  root  .  getElementsByAttributeValueEnding  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "*  =   "  )  )  return  root  .  getElementsByAttributeValueContaining  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  throw  new  SelectorParseException  (   "Could  not  parse  attribute  query   "  +  query  )  ;  }  }    [METHOD]  byAttribute  [TYPE]  Elements  [PARAMETER]  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  String[]  combinators  [TYPE]  String  className  combinator  id  key  query  s  subQuery  tagName  [TYPE]  boolean  false  true  [TYPE]  Element  found  root  
[REPLACE]  return  root  .  getElementsByAttributeValueNot  (  key,  tq  .  chompTo  (   "] "  )  )  ;	[BUGGY]  return  root  .  getElementsByAttributeValueStarting  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;  [FE]  AssertionFailedError    expected:<5>  but  was:<1>  assertEquals(4  ,  withTitle.size())  ;  assertEquals(1  ,  foo.size())  ;  assertEquals(5  ,  not.size())  ;  assertEquals( "Foo "  ,  not.first().attr( "title "))  ;  assertEquals(2  ,  starts.size())  ;  assertEquals( "Bar "  ,  starts.first().attr( "title "))  ;  assertEquals( "Bam "  ,  starts.last().attr( "title "))  ;  assertEquals(2  ,  ends.size())  ;  assertEquals( "Bam "  ,  ends.first().attr( "title "))  ;  assertEquals( "SLAM "  ,  ends.last().attr( "title "))  ;  assertEquals(3  ,  contains.size())  ;  assertEquals( "Bar "  ,  contains.first().attr( "title "))  ;  assertEquals( "SLAM "  ,  contains.last().attr( "title "))  ;  [CONTEXT]  private  Elements  byAttribute  (  )  {  String  key  =  tq  .  consumeToAny  (   "  =   "  ,   "!  =   "  ,   "^  =   "  ,   "$  =   "  ,   "*  =   "  ,   "] "  )  ;  //  eq  ,  not  ,  start  ,  end  ,  contain  ,    (  no  val  )  Validate  .  notEmpty  (  key  )  ;    if  (  tq  .  matchChomp  (   "] "  )  )  {  return  root  .  getElementsByAttribute  (  key  )  ;  }  else  {  if  (  tq  .  matchChomp  (   "  =   "  )  )  return  root  .  getElementsByAttributeValue  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "!  =   "  )  )  [ATTENTION]  return  root  .  getElementsByAttributeValueStarting  (  key  ,  tq  .  chompTo  (   "] "  )  )    ;    else  if  (  tq  .  matchChomp  (   "^  =   "  )  )  return  root  .  getElementsByAttributeValueStarting  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "$  =   "  )  )  return  root  .  getElementsByAttributeValueEnding  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  if  (  tq  .  matchChomp  (   "*  =   "  )  )  return  root  .  getElementsByAttributeValueContaining  (  key  ,  tq  .  chompTo  (   "] "  )  )  ;    else  throw  new  SelectorParseException  (   "Could  not  parse  attribute  query   "  +  query  )  ;  }  }    [METHOD]  byAttribute  [TYPE]  Elements  [PARAMETER]  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  String[]  combinators  [TYPE]  String  className  combinator  id  key  query  s  subQuery  tagName  [TYPE]  boolean  false  true  [TYPE]  Element  found  root  
[REPLACE]  return  root  .  getAllElements  (  )  ;	[BUGGY]  return  root  .  getElementById  (  subQuery  )    ;  [CE]  cannot  find  symbol  subQuery  [CONTEXT]  private  Elements  allElements  (  )  {  [ATTENTION]  return  root  .  getElementById  (  subQuery  )  ;  }    [METHOD]  allElements  [TYPE]  Elements  [PARAMETER]  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  String[]  combinators  [TYPE]  String  className  combinator  id  key  query  s  subQuery  tagName  [TYPE]  boolean  false  true  [TYPE]  Element  found  root  
[REPLACE]  return  root  .  getElementsByIndexLessThan  (  consumeIndex  (  )  )  ;	[BUGGY]  return  root  .  getElementsByIndexGreaterThan  (  consumeIndex  (  )  )  ;  [FE]  AssertionFailedError    expected:<1>  but  was:<0>  assertEquals(1  ,  ps.size())  ;  assertEquals( "Two "  ,  ps.get(0).text())  ;  [CONTEXT]  private  Elements  indexLessThan  (  )  {  [ATTENTION]  return  root  .  getElementsByIndexGreaterThan  (  consumeIndex  (  )  )    ;  }    [METHOD]  indexLessThan  [TYPE]  Elements  [PARAMETER]  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  String[]  combinators  [TYPE]  String  className  combinator  id  key  query  s  subQuery  tagName  [TYPE]  boolean  false  true  [TYPE]  Element  found  root  
[REPLACE]  return  root  .  getElementsByIndexGreaterThan  (  consumeIndex  (  )  )  ;	[BUGGY]  return  root  .  getElementsByIndexEquals  (  consumeIndex  (  )  )  ;  [FE]  AssertionFailedError    expected:<[Two]>  but  was:<[One]>  assertEquals(2  ,  ps.size())  ;  assertEquals( "Two "  ,  ps.get(0).text())  ;  assertEquals( "Three "  ,  ps.get(1).text())  ;  [CONTEXT]  private  Elements  indexGreaterThan  (  )  {  [ATTENTION]  return  root  .  getElementsByIndexEquals  (  consumeIndex  (  )  )    ;  }    [METHOD]  indexGreaterThan  [TYPE]  Elements  [PARAMETER]  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  String[]  combinators  [TYPE]  String  className  combinator  id  key  query  s  subQuery  tagName  [TYPE]  boolean  false  true  [TYPE]  Element  found  root  
[REPLACE]  return  root  .  getElementsByIndexEquals  (  consumeIndex  (  )  )  ;	[BUGGY]  return  root  .  getElementsByIndexGreaterThan  (  consumeIndex  (  )  )  ;  [FE]  AssertionFailedError    expected:<[One]>  but  was:<[Two]>  assertEquals(2  ,  ps.size())  ;  assertEquals( "One "  ,  ps.get(0).text())  ;  assertEquals( "Four "  ,  ps.get(1).text())  ;  assertEquals(1  ,  ps2.size())  ;  assertEquals( "One "  ,  ps2.get(0).text())  ;  assertEquals( "p "  ,  ps2.get(0).tagName())  ;  [CONTEXT]  private  Elements  indexEquals  (  )  {  [ATTENTION]  return  root  .  getElementsByIndexGreaterThan  (  consumeIndex  (  )  )    ;  }    [METHOD]  indexEquals  [TYPE]  Elements  [PARAMETER]  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  String[]  combinators  [TYPE]  String  className  combinator  id  key  query  s  subQuery  tagName  [TYPE]  boolean  false  true  [TYPE]  Element  found  root  
[REPLACE]  String  indexS  =  tq  .  chompTo  (   "  )   "  )    .  trim  (  )  ;	[BUGGY]  String  indexS  =  tq  .  matchChomp  (   "  )   "  )  .  trim  (  )  ;  [CE]  boolean  cannot  be  dereferenced  [CONTEXT]  private  int  consumeIndex  (  )  {  [ATTENTION]  String  indexS  =  tq  .  matchChomp  (   "  )   "  )    .  trim  (  )    ;  Validate  .  isTrue  (  StringUtils  .  isNumeric  (  indexS  )  ,   "Index  must  be  numeric "  )  ;  int  index  =  Integer  .  parseInt  (  indexS  )  ;    return  index  ;  }    [METHOD]  consumeIndex  [TYPE]  int  [PARAMETER]  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  Element  found  root  [TYPE]  String[]  combinators  [TYPE]  String  className  combinator  id  indexS  key  query  s  subQuery  tagName  [TYPE]  int  index  
[ADD]  String  indexS  =  tq  .  chompTo  (   "  )   "  )    .  trim  (  )  ;  Validate  .  isTrue  (  StringUtils  .  isNumeric  (  indexS  )  ,   "Index  must  be  numeric "  )  ;	[BUGGY]  [CE]  cannot  find  symbol  indexS  [CONTEXT]  private  int  consumeIndex  (  )  {  [ATTENTION]    int  index  =  Integer  .  parseInt  (  indexS  )  ;    return  index  ;  }    [METHOD]  consumeIndex  [TYPE]  int  [PARAMETER]  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  Element  found  root  [TYPE]  String[]  combinators  [TYPE]  String  className  combinator  id  indexS  key  query  s  subQuery  tagName  [TYPE]  int  index  
[REPLACE]  Validate  .  isTrue  (  StringUtils  .  isNumeric  (  indexS  )  ,   "Index  must  be  numeric "  )  ;	[BUGGY]  Validate  .  isTrue  (  StringUtils  .  isNumeric  (  subQuery  )  ,   "Index  must  be  numeric "  )  ;  [CE]  cannot  find  symbol  subQuery  [CONTEXT]  private  int  consumeIndex  (  )  {  String  indexS  =  tq  .  chompTo  (   "  )   "  )  .  trim  (  )  ;  [ATTENTION]  Validate  .  isTrue  (  StringUtils  .  isNumeric  (  subQuery  )    ,   "Index  must  be  numeric "  )    ;  int  index  =  Integer  .  parseInt  (  indexS  )  ;    return  index  ;  }    [METHOD]  consumeIndex  [TYPE]  int  [PARAMETER]  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  Element  found  root  [TYPE]  String[]  combinators  [TYPE]  String  className  combinator  id  indexS  key  query  s  subQuery  tagName  [TYPE]  int  index  
[ADD]  Validate  .  isTrue  (  StringUtils  .  isNumeric  (  indexS  )  ,   "Index  must  be  numeric "  )  ;  int  index  =  Integer  .  parseInt  (  indexS  )  ;	[BUGGY]  [CE]  cannot  find  symbol  index  [CONTEXT]  private  int  consumeIndex  (  )  {  String  indexS  =  tq  .  chompTo  (   "  )   "  )  .  trim  (  )  ;  [ATTENTION]    return  index  ;  }    [METHOD]  consumeIndex  [TYPE]  int  [PARAMETER]  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  Element  found  root  [TYPE]  String[]  combinators  [TYPE]  String  className  combinator  id  indexS  key  query  s  subQuery  tagName  [TYPE]  int  index  
[ADD]  Validate  .  isTrue  (  StringUtils  .  isNumeric  (  indexS  )  ,   "Index  must  be  numeric "  )  ;  int  index  =  Integer  .  parseInt  (  indexS  )  ;	[BUGGY]  int  index  =  Integer  .  parseInt  (  indexS  )  ;  [NO-ERROR]  [CONTEXT]  private  int  consumeIndex  (  )  {  String  indexS  =  tq  .  chompTo  (   "  )   "  )  .  trim  (  )  ;  [ATTENTION]  int  index  =  Integer  .  parseInt  (  indexS  )    ;    return  index  ;  }    [METHOD]  consumeIndex  [TYPE]  int  [PARAMETER]  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  Element  found  root  [TYPE]  String[]  combinators  [TYPE]  String  className  combinator  id  indexS  key  query  s  subQuery  tagName  [TYPE]  int  index  
[REPLACE]  int  index  =  Integer  .  parseInt  (  indexS  )  ;	[BUGGY]  int  index  =  Integer  .  parseInt  (  subQuery  )  ;  [CE]  cannot  find  symbol  subQuery  [CONTEXT]  private  int  consumeIndex  (  )  {  String  indexS  =  tq  .  chompTo  (   "  )   "  )  .  trim  (  )  ;  Validate  .  isTrue  (  StringUtils  .  isNumeric  (  indexS  )  ,   "Index  must  be  numeric "  )  ;  [ATTENTION]  int  index  =  Integer  .  parseInt  (  subQuery  )    ;    return  index  ;  }    [METHOD]  consumeIndex  [TYPE]  int  [PARAMETER]  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  Element  found  root  [TYPE]  String[]  combinators  [TYPE]  String  className  combinator  id  indexS  key  query  s  subQuery  tagName  [TYPE]  int  index  
[REPLACE]  return  index;	[BUGGY]  return  byTag  (  )  ;  [CE]  incompatible  types  [CONTEXT]  private  int  consumeIndex  (  )  {  String  indexS  =  tq  .  chompTo  (   "  )   "  )  .  trim  (  )  ;  Validate  .  isTrue  (  StringUtils  .  isNumeric  (  indexS  )  ,   "Index  must  be  numeric "  )  ;  int  index  =  Integer  .  parseInt  (  indexS  )  ;    [ATTENTION]  return  byTag  (  )    ;  }    [METHOD]  consumeIndex  [TYPE]  int  [PARAMETER]  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  Element  found  root  [TYPE]  String[]  combinators  [TYPE]  String  className  combinator  id  indexS  key  query  s  subQuery  tagName  [TYPE]  int  index  
[REPLACE]  Elements  children  =  new  Elements  (  )  ;	[BUGGY]  Elements  candidates  =  findElements  (  )  ;  [CE]  variable  candidates  is  already  defined  in  method  filterForChildren(Collection<Element>  ,  Collection<Element>)  [CONTEXT]  private  static  Elements  filterForChildren  (  Collection<Element>  parents  ,  Collection<Element>  candidates  )  {  [ATTENTION]  Elements  candidates  =  findElements  (  )    ;  CHILD:  for  (  Element  c  :  candidates  )  {  for  (  Element  p  :  parents  )  {  if  (  c  .  parent  (  )  !  =  null  &&  c  .  parent  (  )  .  equals  (  p  )  )  {  children  .  add  (  c  )  ;  continue  CHILD  ;  }  }  }  return  children  ;  }    [METHOD]  filterForChildren  [TYPE]  Elements  [PARAMETER]  Element>  parents  Element>  candidates  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  Element  c  found  p  root  [TYPE]  Collection  candidates  parents  [TYPE]  String[]  combinators  [TYPE]  String  className  combinator  id  indexS  key  query  s  subQuery  tagName  [TYPE]  Elements  children  
[REPLACE]  if  (  c  .  parent  (  )  !=  null  &&  c  .  parent  (  )    .  equals  (  p  )  )  {	[BUGGY]  if  (  c  .  getAllElements  (  )    =  =  this  )  {[CE]  non-static  variable  this  cannot  be  referenced  from  a  static  context  [CONTEXT]  private  static  Elements  filterForChildren  (  Collection<Element>  parents  ,  Collection<Element>  candidates  )  {  Elements  children  =  new  Elements  (  )  ;  CHILD:  for  (  Element  c  :  candidates  )  {  for  (  Element  p  :  parents  )  {  [ATTENTION]  if  (  c  .  getAllElements  (  )  =  =  this  )  {  children  .  add  (  c  )  ;  continue  CHILD  ;  }  }  }  return  children  ;  }    [METHOD]  filterForChildren  [TYPE]  Elements  [PARAMETER]  Element>  parents  Element>  candidates  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  Element  c  found  p  root  [TYPE]  Collection  candidates  parents  [TYPE]  String[]  combinators  [TYPE]  String  className  combinator  id  indexS  key  query  s  subQuery  tagName  [TYPE]  Elements  children  
[REPLACE]  children  .  add  (  c  )  ;	[BUGGY]  children  .  addAll  (  )    ;  [CE]  no  suitable  method  found  for  addAll()  [CONTEXT]  private  static  Elements  filterForChildren  (  Collection<Element>  parents  ,  Collection<Element>  candidates  )  {  Elements  children  =  new  Elements  (  )  ;  CHILD:  for  (  Element  c  :  candidates  )  {  for  (  Element  p  :  parents  )  {  if  (  c  .  parent  (  )  !  =  null  &&  c  .  parent  (  )  .  equals  (  p  )  )  {  [ATTENTION]  children  .  addAll  (  )  ;  continue  CHILD  ;  }  }  }  return  children  ;  }    [METHOD]  filterForChildren  [TYPE]  Elements  [PARAMETER]  Element>  parents  Element>  candidates  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  Element  c  found  p  root  [TYPE]  Collection  candidates  parents  [TYPE]  String[]  combinators  [TYPE]  String  className  combinator  id  indexS  key  query  s  subQuery  tagName  [TYPE]  Elements  children  
[REPLACE]  CHILD:  for  (  Element  c  :  candidates  )  {	[BUGGY]  CHILD:  for  (  Element  c  :  candidates  )  {  boolean  found  =  false  ;  [NO-ERROR]  [CONTEXT]  private  static  Elements  filterForChildren  (  Collection<Element>  parents  ,  Collection<Element>  candidates  )  {  Elements  children  =  new  Elements  (  )  ;  [ATTENTION]  CHILD:  for  (  Element  c  :  candidates  )  {  boolean  found  =  false  ;  for  (  Element  p  :  parents  )  {  if  (  c  .  parent  (  )  !  =  null  &&  c  .  parent  (  )  .  equals  (  p  )  )  {  children  .  add  (  c  )  ;  continue  CHILD  ;  }  }  }  return  children  ;  }    [METHOD]  filterForChildren  [TYPE]  Elements  [PARAMETER]  Element>  parents  Element>  candidates  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  Element  c  found  p  root  [TYPE]  Collection  candidates  parents  [TYPE]  String[]  combinators  [TYPE]  String  className  combinator  id  indexS  key  query  s  subQuery  tagName  [TYPE]  Elements  children  
[REPLACE]  for  (  Element  p  :  parents  )  {	[BUGGY]  CHILD:  for  (  Element  c  :  candidates  )  {  boolean  found  =  false  ;  [CE]  label  CHILD  already  in  use  [CONTEXT]  private  static  Elements  filterForChildren  (  Collection<Element>  parents  ,  Collection<Element>  candidates  )  {  Elements  children  =  new  Elements  (  )  ;  CHILD:  for  (  Element  c  :  candidates  )  {  [ATTENTION]  CHILD:  for  (  Element  c  :  candidates  )  {  boolean  found  =  false  ;  if  (  c  .  parent  (  )  !  =  null  &&  c  .  parent  (  )  .  equals  (  p  )  )  {  children  .  add  (  c  )  ;  continue  CHILD  ;  }  }  }  return  children  ;  }    [METHOD]  filterForChildren  [TYPE]  Elements  [PARAMETER]  Element>  parents  Element>  candidates  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  Element  c  found  p  root  [TYPE]  Collection  candidates  parents  [TYPE]  String[]  combinators  [TYPE]  String  className  combinator  id  indexS  key  query  s  subQuery  tagName  [TYPE]  Elements  children  
[REPLACE]  return  children;	[BUGGY]  return  byTag  (  )  ;  [CE]  non-static  method  byTag()  cannot  be  referenced  from  a  static  context  [CONTEXT]  private  static  Elements  filterForChildren  (  Collection<Element>  parents  ,  Collection<Element>  candidates  )  {  Elements  children  =  new  Elements  (  )  ;  CHILD:  for  (  Element  c  :  candidates  )  {  for  (  Element  p  :  parents  )  {  if  (  c  .  parent  (  )  !  =  null  &&  c  .  parent  (  )  .  equals  (  p  )  )  {  children  .  add  (  c  )  ;  continue  CHILD  ;  }  }  }  [ATTENTION]  return  byTag  (  )    ;  }    [METHOD]  filterForChildren  [TYPE]  Elements  [PARAMETER]  Element>  parents  Element>  candidates  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  Element  c  found  p  root  [TYPE]  Collection  candidates  parents  [TYPE]  String[]  combinators  [TYPE]  String  className  combinator  id  indexS  key  query  s  subQuery  tagName  [TYPE]  Elements  children  
[REPLACE]  Elements  children  =  new  Elements  (  )  ;	[BUGGY]  Elements  candidates  =  findElements  (  )  ;  [CE]  variable  candidates  is  already  defined  in  method  filterForDescendants(Collection<Element>  ,  Collection<Element>)  [CONTEXT]  private  static  Elements  filterForDescendants  (  Collection<Element>  parents  ,  Collection<Element>  candidates  )  {  [ATTENTION]  Elements  candidates  =  findElements  (  )    ;  CHILD:  for  (  Element  c  :  candidates  )  {  boolean  found  =  false  ;  for  (  Element  p  :  parents  )  {  if  (  c  .  equals  (  p  )  )  {  found  =  true  ;  continue  CHILD  ;  }  }  if  (  !found  )  children  .  add  (  c  )  ;  }  return  children  ;  }    [METHOD]  filterForDescendants  [TYPE]  Elements  [PARAMETER]  Element>  parents  Element>  candidates  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  found  true  [TYPE]  Element  c  found  p  root  [TYPE]  Collection  candidates  parents  [TYPE]  String[]  combinators  [TYPE]  String  className  combinator  id  indexS  key  query  s  subQuery  tagName  [TYPE]  Elements  children  
[ADD]  Elements  children  =  new  Elements  (  )  ;	[BUGGY]  [CE]  cannot  find  symbol  children  [CONTEXT]  private  static  Elements  filterForDescendants  (  Collection<Element>  parents  ,  Collection<Element>  candidates  )  {  [ATTENTION]  CHILD:  for  (  Element  c  :  candidates  )  {  boolean  found  =  false  ;  for  (  Element  p  :  parents  )  {  if  (  c  .  equals  (  p  )  )  {  found  =  true  ;  continue  CHILD  ;  }  }  if  (  !found  )  children  .  add  (  c  )  ;  }  return  children  ;  }    [METHOD]  filterForDescendants  [TYPE]  Elements  [PARAMETER]  Element>  parents  Element>  candidates  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  found  true  [TYPE]  Element  c  found  p  root  [TYPE]  Collection  candidates  parents  [TYPE]  String[]  combinators  [TYPE]  String  className  combinator  id  indexS  key  query  s  subQuery  tagName  [TYPE]  Elements  children  
[REPLACE]  if  (  c  .  equals  (  p  )  )  {	[BUGGY]  if  (  c  .  getElementsByIndexEquals  (  p  )  )  {[CE]  method  getElementsByIndexEquals  in  class  Element  cannot  be  applied  to  given  types  ;  [CONTEXT]  private  static  Elements  filterForDescendants  (  Collection<Element>  parents  ,  Collection<Element>  candidates  )  {  Elements  children  =  new  Elements  (  )  ;  CHILD:  for  (  Element  c  :  candidates  )  {  boolean  found  =  false  ;  for  (  Element  p  :  parents  )  {  [ATTENTION]  if  (  c  .  getElementsByIndexEquals  (  p  )  )  {  found  =  true  ;  continue  CHILD  ;  }  }  if  (  !found  )  children  .  add  (  c  )  ;  }  return  children  ;  }    [METHOD]  filterForDescendants  [TYPE]  Elements  [PARAMETER]  Element>  parents  Element>  candidates  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  found  true  [TYPE]  Element  c  found  p  root  [TYPE]  Collection  candidates  parents  [TYPE]  String[]  combinators  [TYPE]  String  className  combinator  id  indexS  key  query  s  subQuery  tagName  [TYPE]  Elements  children  
[REPLACE]  found  =  true;	[BUGGY]  found  =  false  ;  [NO-ERROR]  [CONTEXT]  private  static  Elements  filterForDescendants  (  Collection<Element>  parents  ,  Collection<Element>  candidates  )  {  Elements  children  =  new  Elements  (  )  ;  CHILD:  for  (  Element  c  :  candidates  )  {  boolean  found  =  false  ;  for  (  Element  p  :  parents  )  {  if  (  c  .  equals  (  p  )  )  {  [ATTENTION]  found  =  false  ;  continue  CHILD  ;  }  }  if  (  !found  )  children  .  add  (  c  )  ;  }  return  children  ;  }    [METHOD]  filterForDescendants  [TYPE]  Elements  [PARAMETER]  Element>  parents  Element>  candidates  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  found  true  [TYPE]  Element  c  found  p  root  [TYPE]  Collection  candidates  parents  [TYPE]  String[]  combinators  [TYPE]  String  className  combinator  id  indexS  key  query  s  subQuery  tagName  [TYPE]  Elements  children  
[REPLACE]  if  (  !found  )  children  .  add  (  c  )  ;	[BUGGY]  if  (  found  )  children  .  add  (  c  )  ;  [FE]  AssertionFailedError    expected:<[Brace  yourself  for  Metro  meltdown]>  but  was:<[]>  assertEquals( "News.com.au  |  News  from  Australia  and  around  the  world  online  |  NewsComAu "  ,  doc.title())  ;  assertEquals( "Brace  yourself  for  Metro  meltdown "  ,  doc.select( ".id1225817868581  h4 ").text().trim())  ;  assertEquals( "/entertainment/horoscopes "  ,  a.attr( "href "))  ;  assertEquals( "http://www.news.com.au/entertainment/horoscopes "  ,  a.attr( "abs:href "))  ;  assertEquals( "http://www.heraldsun.com.au/news/naughty-corners-are-a-bad-idea-for-kids/story-e6frf7jo-1225817899003 "  ,  hs.attr( "href "))  ;  assertEquals(hs.attr( "href ")  ,  hs.attr( "abs:href "))  ;  [CONTEXT]  private  static  Elements  filterForDescendants  (  Collection<Element>  parents  ,  Collection<Element>  candidates  )  {  Elements  children  =  new  Elements  (  )  ;  CHILD:  for  (  Element  c  :  candidates  )  {  boolean  found  =  false  ;  for  (  Element  p  :  parents  )  {  if  (  c  .  equals  (  p  )  )  {  found  =  true  ;  continue  CHILD  ;  }  }  [ATTENTION]  if  (  found  )  children  .  add  (  c  )    ;    }  return  children  ;  }    [METHOD]  filterForDescendants  [TYPE]  Elements  [PARAMETER]  Element>  parents  Element>  candidates  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  found  true  [TYPE]  Element  c  found  p  root  [TYPE]  Collection  candidates  parents  [TYPE]  String[]  combinators  [TYPE]  String  className  combinator  id  indexS  key  query  s  subQuery  tagName  [TYPE]  Elements  children  
[REPLACE]  children  .  add  (  c  )  ;	[BUGGY]  Validate  .  notNull  (  root  )  ;  [CE]  non-static  variable  root  cannot  be  referenced  from  a  static  context  [CONTEXT]  private  static  Elements  filterForDescendants  (  Collection<Element>  parents  ,  Collection<Element>  candidates  )  {  Elements  children  =  new  Elements  (  )  ;  CHILD:  for  (  Element  c  :  candidates  )  {  boolean  found  =  false  ;  for  (  Element  p  :  parents  )  {  if  (  c  .  equals  (  p  )  )  {  found  =  true  ;  continue  CHILD  ;  }  }  if  (  !found  )  [ATTENTION]  Validate  .  notNull  (  root  )    ;  }  return  children  ;  }    [METHOD]  filterForDescendants  [TYPE]  Elements  [PARAMETER]  Element>  parents  Element>  candidates  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  found  true  [TYPE]  Element  c  found  p  root  [TYPE]  Collection  candidates  parents  [TYPE]  String[]  combinators  [TYPE]  String  className  combinator  id  indexS  key  query  s  subQuery  tagName  [TYPE]  Elements  children  
[ADD]  found  =  true;	[BUGGY]  [NO-ERROR]  [CONTEXT]  private  static  Elements  filterForDescendants  (  Collection<Element>  parents  ,  Collection<Element>  candidates  )  {  Elements  children  =  new  Elements  (  )  ;  CHILD:  for  (  Element  c  :  candidates  )  {  boolean  found  =  false  ;  for  (  Element  p  :  parents  )  {  if  (  c  .  equals  (  p  )  )  {  [ATTENTION]  continue  CHILD  ;  }  }  if  (  !found  )  children  .  add  (  c  )  ;  }  return  children  ;  }    [METHOD]  filterForDescendants  [TYPE]  Elements  [PARAMETER]  Element>  parents  Element>  candidates  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  found  true  [TYPE]  Element  c  found  p  root  [TYPE]  Collection  candidates  parents  [TYPE]  String[]  combinators  [TYPE]  String  className  combinator  id  indexS  key  query  s  subQuery  tagName  [TYPE]  Elements  children  
[REPLACE]  CHILD:  for  (  Element  c  :  candidates  )  {	[BUGGY]  CHILD:  for  (  Element  c  :  candidates  )  {  boolean  found  =  false  ;  [CE]  variable  found  is  already  defined  in  method  filterForDescendants(Collection<Element>  ,  Collection<Element>)  [CONTEXT]  private  static  Elements  filterForDescendants  (  Collection<Element>  parents  ,  Collection<Element>  candidates  )  {  Elements  children  =  new  Elements  (  )  ;  [ATTENTION]  CHILD:  for  (  Element  c  :  candidates  )  {  boolean  found  =  false  ;  boolean  found  =  false  ;  for  (  Element  p  :  parents  )  {  if  (  c  .  equals  (  p  )  )  {  found  =  true  ;  continue  CHILD  ;  }  }  if  (  !found  )  children  .  add  (  c  )  ;  }  return  children  ;  }    [METHOD]  filterForDescendants  [TYPE]  Elements  [PARAMETER]  Element>  parents  Element>  candidates  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  found  true  [TYPE]  Element  c  found  p  root  [TYPE]  Collection  candidates  parents  [TYPE]  String[]  combinators  [TYPE]  String  className  combinator  id  indexS  key  query  s  subQuery  tagName  [TYPE]  Elements  children  
[ADD]  CHILD:  for  (  Element  c  :  candidates  )  {  boolean  found  =  false;  for  (  Element  p  :  parents  )  {  if  (  c  .  equals  (  p  )  )  {  found  =  true;	[BUGGY]  [CE]  class  ,  interface  ,  or  enum  expected  [CONTEXT]  private  static  Elements  filterForDescendants  (  Collection<Element>  parents  ,  Collection<Element>  candidates  )  {  Elements  children  =  new  Elements  (  )  ;  [ATTENTION]      continue  CHILD  ;  }  }  if  (  !found  )  children  .  add  (  c  )  ;  }  return  children  ;  }    [METHOD]  filterForDescendants  [TYPE]  Elements  [PARAMETER]  Element>  parents  Element>  candidates  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  found  true  [TYPE]  Element  c  found  p  root  [TYPE]  Collection  candidates  parents  [TYPE]  String[]  combinators  [TYPE]  String  className  combinator  id  indexS  key  query  s  subQuery  tagName  [TYPE]  Elements  children  
[REPLACE]  boolean  found  =  false;	[BUGGY]  boolean  found  =  true  ;  [FE]  AssertionFailedError    expected:<[Brace  yourself  for  Metro  meltdown]>  but  was:<[]>  assertEquals( "News.com.au  |  News  from  Australia  and  around  the  world  online  |  NewsComAu "  ,  doc.title())  ;  assertEquals( "Brace  yourself  for  Metro  meltdown "  ,  doc.select( ".id1225817868581  h4 ").text().trim())  ;  assertEquals( "/entertainment/horoscopes "  ,  a.attr( "href "))  ;  assertEquals( "http://www.news.com.au/entertainment/horoscopes "  ,  a.attr( "abs:href "))  ;  assertEquals( "http://www.heraldsun.com.au/news/naughty-corners-are-a-bad-idea-for-kids/story-e6frf7jo-1225817899003 "  ,  hs.attr( "href "))  ;  assertEquals(hs.attr( "href ")  ,  hs.attr( "abs:href "))  ;  [CONTEXT]  private  static  Elements  filterForDescendants  (  Collection<Element>  parents  ,  Collection<Element>  candidates  )  {  Elements  children  =  new  Elements  (  )  ;  CHILD:  for  (  Element  c  :  candidates  )  {  [ATTENTION]  boolean  found  =  true  ;  for  (  Element  p  :  parents  )  {  if  (  c  .  equals  (  p  )  )  {  found  =  true  ;  continue  CHILD  ;  }  }  if  (  !found  )  children  .  add  (  c  )  ;  }  return  children  ;  }    [METHOD]  filterForDescendants  [TYPE]  Elements  [PARAMETER]  Element>  parents  Element>  candidates  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  found  true  [TYPE]  Element  c  found  p  root  [TYPE]  Collection  candidates  parents  [TYPE]  String[]  combinators  [TYPE]  String  className  combinator  id  indexS  key  query  s  subQuery  tagName  [TYPE]  Elements  children  
[ADD]  boolean  found  =  false;	[BUGGY]  [CE]  cannot  find  symbol  found  [CONTEXT]  private  static  Elements  filterForDescendants  (  Collection<Element>  parents  ,  Collection<Element>  candidates  )  {  Elements  children  =  new  Elements  (  )  ;  CHILD:  for  (  Element  c  :  candidates  )  {  [ATTENTION]  for  (  Element  p  :  parents  )  {  if  (  c  .  equals  (  p  )  )  {  found  =  true  ;  continue  CHILD  ;  }  }  if  (  !found  )  children  .  add  (  c  )  ;  }  return  children  ;  }    [METHOD]  filterForDescendants  [TYPE]  Elements  [PARAMETER]  Element>  parents  Element>  candidates  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  found  true  [TYPE]  Element  c  found  p  root  [TYPE]  Collection  candidates  parents  [TYPE]  String[]  combinators  [TYPE]  String  className  combinator  id  indexS  key  query  s  subQuery  tagName  [TYPE]  Elements  children  
[REPLACE]  for  (  Element  p  :  parents  )  {	[BUGGY]  CHILD:  for  (  Element  c  :  candidates  )  {  boolean  found  =  false  ;  [CE]  label  CHILD  already  in  use  [CONTEXT]  private  static  Elements  filterForDescendants  (  Collection<Element>  parents  ,  Collection<Element>  candidates  )  {  Elements  children  =  new  Elements  (  )  ;  CHILD:  for  (  Element  c  :  candidates  )  {  boolean  found  =  false  ;  [ATTENTION]  CHILD:  for  (  Element  c  :  candidates  )  {  boolean  found  =  false  ;  if  (  c  .  equals  (  p  )  )  {  found  =  true  ;  continue  CHILD  ;  }  }  if  (  !found  )  children  .  add  (  c  )  ;  }  return  children  ;  }    [METHOD]  filterForDescendants  [TYPE]  Elements  [PARAMETER]  Element>  parents  Element>  candidates  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  found  true  [TYPE]  Element  c  found  p  root  [TYPE]  Collection  candidates  parents  [TYPE]  String[]  combinators  [TYPE]  String  className  combinator  id  indexS  key  query  s  subQuery  tagName  [TYPE]  Elements  children  
[ADD]  for  (  Element  p  :  parents  )  {  if  (  c  .  equals  (  p  )  )  {  found  =  true;  continue  CHILD;  }	[BUGGY]  [CE]  illegal  start  of  type  [CONTEXT]  private  static  Elements  filterForDescendants  (  Collection<Element>  parents  ,  Collection<Element>  candidates  )  {  Elements  children  =  new  Elements  (  )  ;  CHILD:  for  (  Element  c  :  candidates  )  {  boolean  found  =  false  ;  [ATTENTION]      }  if  (  !found  )  children  .  add  (  c  )  ;  }  return  children  ;  }    [METHOD]  filterForDescendants  [TYPE]  Elements  [PARAMETER]  Element>  parents  Element>  candidates  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  found  true  [TYPE]  Element  c  found  p  root  [TYPE]  Collection  candidates  parents  [TYPE]  String[]  combinators  [TYPE]  String  className  combinator  id  indexS  key  query  s  subQuery  tagName  [TYPE]  Elements  children  
[REPLACE]  return  children;	[BUGGY]  return  byTag  (  )  ;  [CE]  non-static  method  byTag()  cannot  be  referenced  from  a  static  context  [CONTEXT]  private  static  Elements  filterForDescendants  (  Collection<Element>  parents  ,  Collection<Element>  candidates  )  {  Elements  children  =  new  Elements  (  )  ;  CHILD:  for  (  Element  c  :  candidates  )  {  boolean  found  =  false  ;  for  (  Element  p  :  parents  )  {  if  (  c  .  equals  (  p  )  )  {  found  =  true  ;  continue  CHILD  ;  }  }  if  (  !found  )  children  .  add  (  c  )  ;  }  [ATTENTION]  return  byTag  (  )    ;  }    [METHOD]  filterForDescendants  [TYPE]  Elements  [PARAMETER]  Element>  parents  Element>  candidates  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  found  true  [TYPE]  Element  c  found  p  root  [TYPE]  Collection  candidates  parents  [TYPE]  String[]  combinators  [TYPE]  String  className  combinator  id  indexS  key  query  s  subQuery  tagName  [TYPE]  Elements  children  
[REPLACE]  Elements  siblings  =  new  Elements  (  )  ;	[BUGGY]  Elements  candidates  =  findElements  (  )  ;  [CE]  variable  candidates  is  already  defined  in  method  filterForAdjacentSiblings(Collection<Element>  ,  Collection<Element>)  [CONTEXT]  private  static  Elements  filterForAdjacentSiblings  (  Collection<Element>  elements  ,  Collection<Element>  candidates  )  {  [ATTENTION]  Elements  candidates  =  findElements  (  )    ;  SIBLING:  for  (  Element  c:  candidates  )  {  for  (  Element  e:  elements  )  {  if  (  !e  .  parent  (  )  .  equals  (  c  .  parent  (  )  )  )  continue  ;  Element  previousSib  =  c  .  previousElementSibling  (  )  ;  if  (  previousSib  !  =  null  &&  previousSib  .  equals  (  e  )  )  {  siblings  .  add  (  c  )  ;  continue  SIBLING  ;  }  }  }  return  siblings  ;  }    [METHOD]  filterForAdjacentSiblings  [TYPE]  Elements  [PARAMETER]  Element>  elements  Element>  candidates  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  Element  c  e  found  p  previousSib  root  [TYPE]  Collection  candidates  elements  [TYPE]  String[]  combinators  [TYPE]  String  className  combinator  id  indexS  key  query  s  subQuery  tagName  [TYPE]  Elements  siblings  
[REPLACE]  if  (  !e  .  parent  (  )    .  equals  (  c  .  parent  (  )  )  )  continue;	[BUGGY]  if  (  !e  .  getAllElements  (  )    .  equals  (  c[CE]  ')'  expected  [CONTEXT]  private  static  Elements  filterForAdjacentSiblings  (  Collection<Element>  elements  ,  Collection<Element>  candidates  )  {  Elements  siblings  =  new  Elements  (  )  ;  SIBLING:  for  (  Element  c:  candidates  )  {  for  (  Element  e:  elements  )  {  [ATTENTION]  if  (  !e  .  getAllElements  (  )  .  equals  (  c  Element  previousSib  =  c  .  previousElementSibling  (  )  ;  if  (  previousSib  !  =  null  &&  previousSib  .  equals  (  e  )  )  {  siblings  .  add  (  c  )  ;  continue  SIBLING  ;  }  }  }  return  siblings  ;  }    [METHOD]  filterForAdjacentSiblings  [TYPE]  Elements  [PARAMETER]  Element>  elements  Element>  candidates  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  Element  c  e  found  p  previousSib  root  [TYPE]  Collection  candidates  elements  [TYPE]  String[]  combinators  [TYPE]  String  className  combinator  id  indexS  key  query  s  subQuery  tagName  [TYPE]  Elements  siblings  
[REPLACE]  if  (  previousSib  !=  null  &&  previousSib  .  equals  (  e  )  )  {	[BUGGY]  if  (  previousSib  =  =  null  )  {[FE]  null  assertTrue(divs.hasText())  ;  assertFalse(doc.select( "div  +  div ").hasText())  ;  [CONTEXT]  private  static  Elements  filterForAdjacentSiblings  (  Collection<Element>  elements  ,  Collection<Element>  candidates  )  {  Elements  siblings  =  new  Elements  (  )  ;  SIBLING:  for  (  Element  c:  candidates  )  {  for  (  Element  e:  elements  )  {  if  (  !e  .  parent  (  )  .  equals  (  c  .  parent  (  )  )  )  continue  ;  Element  previousSib  =  c  .  previousElementSibling  (  )  ;  [ATTENTION]  if  (  previousSib  =  =  null  )  {  siblings  .  add  (  c  )  ;  continue  SIBLING  ;  }  }  }  return  siblings  ;  }    [METHOD]  filterForAdjacentSiblings  [TYPE]  Elements  [PARAMETER]  Element>  elements  Element>  candidates  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  Element  c  e  found  p  previousSib  root  [TYPE]  Collection  candidates  elements  [TYPE]  String[]  combinators  [TYPE]  String  className  combinator  id  indexS  key  query  s  subQuery  tagName  [TYPE]  Elements  siblings  
[ADD]  if  (  previousSib  !=  null  &&  previousSib  .  equals  (  e  )  )  {  siblings  .  add  (  c  )  ;  continue  SIBLING;  }	[BUGGY]  siblings  .  add  (  c  )  ;  continue  SIBLING  ;  [FE]  null  assertTrue(divs.hasText())  ;  assertFalse(doc.select( "div  +  div ").hasText())  ;  [CONTEXT]  private  static  Elements  filterForAdjacentSiblings  (  Collection<Element>  elements  ,  Collection<Element>  candidates  )  {  Elements  siblings  =  new  Elements  (  )  ;  SIBLING:  for  (  Element  c:  candidates  )  {  for  (  Element  e:  elements  )  {  if  (  !e  .  parent  (  )  .  equals  (  c  .  parent  (  )  )  )  continue  ;  Element  previousSib  =  c  .  previousElementSibling  (  )  ;  [ATTENTION]  siblings  .  add  (  c  )    ;  continue  SIBLING  ;      }  }  return  siblings  ;  }    [METHOD]  filterForAdjacentSiblings  [TYPE]  Elements  [PARAMETER]  Element>  elements  Element>  candidates  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  Element  c  e  found  p  previousSib  root  [TYPE]  Collection  candidates  elements  [TYPE]  String[]  combinators  [TYPE]  String  className  combinator  id  indexS  key  query  s  subQuery  tagName  [TYPE]  Elements  siblings  
[REPLACE]  siblings  .  add  (  c  )  ;	[BUGGY]  siblings  .  addAll  (  )    ;  [CE]  no  suitable  method  found  for  addAll()  [CONTEXT]  private  static  Elements  filterForAdjacentSiblings  (  Collection<Element>  elements  ,  Collection<Element>  candidates  )  {  Elements  siblings  =  new  Elements  (  )  ;  SIBLING:  for  (  Element  c:  candidates  )  {  for  (  Element  e:  elements  )  {  if  (  !e  .  parent  (  )  .  equals  (  c  .  parent  (  )  )  )  continue  ;  Element  previousSib  =  c  .  previousElementSibling  (  )  ;  if  (  previousSib  !  =  null  &&  previousSib  .  equals  (  e  )  )  {  [ATTENTION]  siblings  .  addAll  (  )  ;  continue  SIBLING  ;  }  }  }  return  siblings  ;  }    [METHOD]  filterForAdjacentSiblings  [TYPE]  Elements  [PARAMETER]  Element>  elements  Element>  candidates  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  Element  c  e  found  p  previousSib  root  [TYPE]  Collection  candidates  elements  [TYPE]  String[]  combinators  [TYPE]  String  className  combinator  id  indexS  key  query  s  subQuery  tagName  [TYPE]  Elements  siblings  
[REPLACE]  SIBLING:  for  (  Element  c:  candidates  )  {	[BUGGY]  CHILD:  for  (  Element  c  :  candidates  )  {  boolean  found  =  false  ;  [CE]  undefined  label:  SIBLING  [CONTEXT]  private  static  Elements  filterForAdjacentSiblings  (  Collection<Element>  elements  ,  Collection<Element>  candidates  )  {  Elements  siblings  =  new  Elements  (  )  ;  [ATTENTION]  CHILD:  for  (  Element  c  :  candidates  )  {  boolean  found  =  false  ;  for  (  Element  e:  elements  )  {  if  (  !e  .  parent  (  )  .  equals  (  c  .  parent  (  )  )  )  continue  ;  Element  previousSib  =  c  .  previousElementSibling  (  )  ;  if  (  previousSib  !  =  null  &&  previousSib  .  equals  (  e  )  )  {  siblings  .  add  (  c  )  ;  continue  SIBLING  ;  }  }  }  return  siblings  ;  }    [METHOD]  filterForAdjacentSiblings  [TYPE]  Elements  [PARAMETER]  Element>  elements  Element>  candidates  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  Element  c  e  found  p  previousSib  root  [TYPE]  Collection  candidates  elements  [TYPE]  String[]  combinators  [TYPE]  String  className  combinator  id  indexS  key  query  s  subQuery  tagName  [TYPE]  Elements  siblings  
[REPLACE]  for  (  Element  e:  elements  )  {	[BUGGY]  for  (  Element  e:  elements  )  {  if  (  !e  .  parent  (  )  .  equals  (  c  .  parent  (  )  )  )[NO-ERROR]  [CONTEXT]  private  static  Elements  filterForAdjacentSiblings  (  Collection<Element>  elements  ,  Collection<Element>  candidates  )  {  Elements  siblings  =  new  Elements  (  )  ;  SIBLING:  for  (  Element  c:  candidates  )  {  [ATTENTION]  for  (  Element  e:  elements  )  {  if  (  !e  .  parent  (  )    .  equals  (  c  .  parent  (  )  )  )  if  (  !e  .  parent  (  )  .  equals  (  c  .  parent  (  )  )  )  continue  ;  Element  previousSib  =  c  .  previousElementSibling  (  )  ;  if  (  previousSib  !  =  null  &&  previousSib  .  equals  (  e  )  )  {  siblings  .  add  (  c  )  ;  continue  SIBLING  ;  }  }  }  return  siblings  ;  }    [METHOD]  filterForAdjacentSiblings  [TYPE]  Elements  [PARAMETER]  Element>  elements  Element>  candidates  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  Element  c  e  found  p  previousSib  root  [TYPE]  Collection  candidates  elements  [TYPE]  String[]  combinators  [TYPE]  String  className  combinator  id  indexS  key  query  s  subQuery  tagName  [TYPE]  Elements  siblings  
[REPLACE]  Element  previousSib  =  c  .  previousElementSibling  (  )  ;	[BUGGY]  Element  previousSib  =  c  .  getAllElements  (  )  ;  [CE]  incompatible  types  [CONTEXT]  private  static  Elements  filterForAdjacentSiblings  (  Collection<Element>  elements  ,  Collection<Element>  candidates  )  {  Elements  siblings  =  new  Elements  (  )  ;  SIBLING:  for  (  Element  c:  candidates  )  {  for  (  Element  e:  elements  )  {  if  (  !e  .  parent  (  )  .  equals  (  c  .  parent  (  )  )  )  continue  ;  [ATTENTION]  Element  previousSib  =  c  .  getAllElements  (  )    ;  if  (  previousSib  !  =  null  &&  previousSib  .  equals  (  e  )  )  {  siblings  .  add  (  c  )  ;  continue  SIBLING  ;  }  }  }  return  siblings  ;  }    [METHOD]  filterForAdjacentSiblings  [TYPE]  Elements  [PARAMETER]  Element>  elements  Element>  candidates  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  Element  c  e  found  p  previousSib  root  [TYPE]  Collection  candidates  elements  [TYPE]  String[]  combinators  [TYPE]  String  className  combinator  id  indexS  key  query  s  subQuery  tagName  [TYPE]  Elements  siblings  
[REPLACE]  return  siblings;	[BUGGY]  return  byTag  (  )  ;  [CE]  non-static  method  byTag()  cannot  be  referenced  from  a  static  context  [CONTEXT]  private  static  Elements  filterForAdjacentSiblings  (  Collection<Element>  elements  ,  Collection<Element>  candidates  )  {  Elements  siblings  =  new  Elements  (  )  ;  SIBLING:  for  (  Element  c:  candidates  )  {  for  (  Element  e:  elements  )  {  if  (  !e  .  parent  (  )  .  equals  (  c  .  parent  (  )  )  )  continue  ;  Element  previousSib  =  c  .  previousElementSibling  (  )  ;  if  (  previousSib  !  =  null  &&  previousSib  .  equals  (  e  )  )  {  siblings  .  add  (  c  )  ;  continue  SIBLING  ;  }  }  }  [ATTENTION]  return  byTag  (  )    ;  }    [METHOD]  filterForAdjacentSiblings  [TYPE]  Elements  [PARAMETER]  Element>  elements  Element>  candidates  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  Element  c  e  found  p  previousSib  root  [TYPE]  Collection  candidates  elements  [TYPE]  String[]  combinators  [TYPE]  String  className  combinator  id  indexS  key  query  s  subQuery  tagName  [TYPE]  Elements  siblings  
[REPLACE]  Elements  output  =  new  Elements  (  )  ;	[BUGGY]  Elements  candidates  =  findElements  (  )  ;  [CE]  variable  candidates  is  already  defined  in  method  filterForGeneralSiblings(Collection<Element>  ,  Collection<Element>)  [CONTEXT]  private  static  Elements  filterForGeneralSiblings  (  Collection<Element>  elements  ,  Collection<Element>  candidates  )  {  [ATTENTION]  Elements  candidates  =  findElements  (  )    ;  SIBLING:  for  (  Element  c:  candidates  )  {  for  (  Element  e:  elements  )  {  if  (  !e  .  parent  (  )  .  equals  (  c  .  parent  (  )  )  )  continue  ;  int  ePos  =  e  .  elementSiblingIndex  (  )  ;  int  cPos  =  c  .  elementSiblingIndex  (  )  ;  if  (  cPos  >  ePos  )  {  output  .  add  (  c  )  ;  continue  SIBLING  ;  }  }  }  return  output  ;  }    [METHOD]  filterForGeneralSiblings  [TYPE]  Elements  [PARAMETER]  Element>  elements  Element>  candidates  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  Element  c  e  found  p  previousSib  root  [TYPE]  Collection  candidates  elements  [TYPE]  String[]  combinators  [TYPE]  String  className  combinator  id  indexS  key  query  s  subQuery  tagName  [TYPE]  Elements  output  [TYPE]  int  cPos  ePos  
[REPLACE]  if  (  !e  .  parent  (  )    .  equals  (  c  .  parent  (  )  )  )  continue;	[BUGGY]  if  (  !e  .  getAllElements  (  )  .  equals  (  c  .  parent  (  )  )  )  continue  ;  [FE]  AssertionFailedError    expected:<1>  but  was:<0>  assertEquals(1  ,  els.size())  ;  assertEquals( "Three "  ,  els.first().text())  ;  [CONTEXT]  private  static  Elements  filterForGeneralSiblings  (  Collection<Element>  elements  ,  Collection<Element>  candidates  )  {  Elements  output  =  new  Elements  (  )  ;  SIBLING:  for  (  Element  c:  candidates  )  {  for  (  Element  e:  elements  )  {  [ATTENTION]  if  (  !e  .  getAllElements  (  )    .  equals  (  c  .  parent  (  )  )  )  continue  ;    int  ePos  =  e  .  elementSiblingIndex  (  )  ;  int  cPos  =  c  .  elementSiblingIndex  (  )  ;  if  (  cPos  >  ePos  )  {  output  .  add  (  c  )  ;  continue  SIBLING  ;  }  }  }  return  output  ;  }    [METHOD]  filterForGeneralSiblings  [TYPE]  Elements  [PARAMETER]  Element>  elements  Element>  candidates  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  Element  c  e  found  p  previousSib  root  [TYPE]  Collection  candidates  elements  [TYPE]  String[]  combinators  [TYPE]  String  className  combinator  id  indexS  key  query  s  subQuery  tagName  [TYPE]  Elements  output  [TYPE]  int  cPos  ePos  
[ADD]  if  (  !e  .  parent  (  )    .  equals  (  c  .  parent  (  )  )  )  continue;  int  ePos  =  e  .  elementSiblingIndex  (  )  ;  int  cPos  =  c  .  elementSiblingIndex  (  )  ;	[BUGGY]  [CE]  cannot  find  symbol  cPos  [CONTEXT]  private  static  Elements  filterForGeneralSiblings  (  Collection<Element>  elements  ,  Collection<Element>  candidates  )  {  Elements  output  =  new  Elements  (  )  ;  SIBLING:  for  (  Element  c:  candidates  )  {  for  (  Element  e:  elements  )  {  [ATTENTION]      if  (  cPos  >  ePos  )  {  output  .  add  (  c  )  ;  continue  SIBLING  ;  }  }  }  return  output  ;  }    [METHOD]  filterForGeneralSiblings  [TYPE]  Elements  [PARAMETER]  Element>  elements  Element>  candidates  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  Element  c  e  found  p  previousSib  root  [TYPE]  Collection  candidates  elements  [TYPE]  String[]  combinators  [TYPE]  String  className  combinator  id  indexS  key  query  s  subQuery  tagName  [TYPE]  Elements  output  [TYPE]  int  cPos  ePos  
[REPLACE]  if  (  cPos  >  ePos  )  {	[BUGGY]  if  (  cPos  <  ePos  )  {[FE]  AssertionFailedError    expected:<1>  but  was:<0>  assertEquals(1  ,  els.size())  ;  assertEquals( "Three "  ,  els.first().text())  ;  [CONTEXT]  private  static  Elements  filterForGeneralSiblings  (  Collection<Element>  elements  ,  Collection<Element>  candidates  )  {  Elements  output  =  new  Elements  (  )  ;  SIBLING:  for  (  Element  c:  candidates  )  {  for  (  Element  e:  elements  )  {  if  (  !e  .  parent  (  )  .  equals  (  c  .  parent  (  )  )  )  continue  ;  int  ePos  =  e  .  elementSiblingIndex  (  )  ;  int  cPos  =  c  .  elementSiblingIndex  (  )  ;  [ATTENTION]  if  (  cPos<ePos  )  {  output  .  add  (  c  )  ;  continue  SIBLING  ;  }  }  }  return  output  ;  }    [METHOD]  filterForGeneralSiblings  [TYPE]  Elements  [PARAMETER]  Element>  elements  Element>  candidates  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  Element  c  e  found  p  previousSib  root  [TYPE]  Collection  candidates  elements  [TYPE]  String[]  combinators  [TYPE]  String  className  combinator  id  indexS  key  query  s  subQuery  tagName  [TYPE]  Elements  output  [TYPE]  int  cPos  ePos  
[REPLACE]  output  .  add  (  c  )  ;	[BUGGY]  query  =  query  .  trim  (  )  ;  [CE]  non-static  variable  query  cannot  be  referenced  from  a  static  context  [CONTEXT]  private  static  Elements  filterForGeneralSiblings  (  Collection<Element>  elements  ,  Collection<Element>  candidates  )  {  Elements  output  =  new  Elements  (  )  ;  SIBLING:  for  (  Element  c:  candidates  )  {  for  (  Element  e:  elements  )  {  if  (  !e  .  parent  (  )  .  equals  (  c  .  parent  (  )  )  )  continue  ;  int  ePos  =  e  .  elementSiblingIndex  (  )  ;  int  cPos  =  c  .  elementSiblingIndex  (  )  ;  if  (  cPos  >  ePos  )  {  [ATTENTION]  query  =  query  .  trim  (  )    ;  continue  SIBLING  ;  }  }  }  return  output  ;  }    [METHOD]  filterForGeneralSiblings  [TYPE]  Elements  [PARAMETER]  Element>  elements  Element>  candidates  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  Element  c  e  found  p  previousSib  root  [TYPE]  Collection  candidates  elements  [TYPE]  String[]  combinators  [TYPE]  String  className  combinator  id  indexS  key  query  s  subQuery  tagName  [TYPE]  Elements  output  [TYPE]  int  cPos  ePos  
[REPLACE]  SIBLING:  for  (  Element  c:  candidates  )  {	[BUGGY]  CHILD:  for  (  Element  c  :  candidates  )  {  boolean  found  =  false  ;  [CE]  undefined  label:  SIBLING  [CONTEXT]  private  static  Elements  filterForGeneralSiblings  (  Collection<Element>  elements  ,  Collection<Element>  candidates  )  {  Elements  output  =  new  Elements  (  )  ;  [ATTENTION]  CHILD:  for  (  Element  c  :  candidates  )  {  boolean  found  =  false  ;  for  (  Element  e:  elements  )  {  if  (  !e  .  parent  (  )  .  equals  (  c  .  parent  (  )  )  )  continue  ;  int  ePos  =  e  .  elementSiblingIndex  (  )  ;  int  cPos  =  c  .  elementSiblingIndex  (  )  ;  if  (  cPos  >  ePos  )  {  output  .  add  (  c  )  ;  continue  SIBLING  ;  }  }  }  return  output  ;  }    [METHOD]  filterForGeneralSiblings  [TYPE]  Elements  [PARAMETER]  Element>  elements  Element>  candidates  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  Element  c  e  found  p  previousSib  root  [TYPE]  Collection  candidates  elements  [TYPE]  String[]  combinators  [TYPE]  String  className  combinator  id  indexS  key  query  s  subQuery  tagName  [TYPE]  Elements  output  [TYPE]  int  cPos  ePos  
[REPLACE]  for  (  Element  e:  elements  )  {	[BUGGY]  for  (  Element  e:  elements  )  {  if  (  !e  .  parent  (  )  .  equals  (  c  .  parent  (  )  )  )[NO-ERROR]  [CONTEXT]  private  static  Elements  filterForGeneralSiblings  (  Collection<Element>  elements  ,  Collection<Element>  candidates  )  {  Elements  output  =  new  Elements  (  )  ;  SIBLING:  for  (  Element  c:  candidates  )  {  [ATTENTION]  for  (  Element  e:  elements  )  {  if  (  !e  .  parent  (  )    .  equals  (  c  .  parent  (  )  )  )  if  (  !e  .  parent  (  )  .  equals  (  c  .  parent  (  )  )  )  continue  ;  int  ePos  =  e  .  elementSiblingIndex  (  )  ;  int  cPos  =  c  .  elementSiblingIndex  (  )  ;  if  (  cPos  >  ePos  )  {  output  .  add  (  c  )  ;  continue  SIBLING  ;  }  }  }  return  output  ;  }    [METHOD]  filterForGeneralSiblings  [TYPE]  Elements  [PARAMETER]  Element>  elements  Element>  candidates  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  Element  c  e  found  p  previousSib  root  [TYPE]  Collection  candidates  elements  [TYPE]  String[]  combinators  [TYPE]  String  className  combinator  id  indexS  key  query  s  subQuery  tagName  [TYPE]  Elements  output  [TYPE]  int  cPos  ePos  
[REPLACE]  int  ePos  =  e  .  elementSiblingIndex  (  )  ;	[BUGGY]  int  previousSibPos  =  e  .  elementSiblingIndex  (  )  ;  [CE]  cannot  find  symbol  ePos  [CONTEXT]  private  static  Elements  filterForGeneralSiblings  (  Collection<Element>  elements  ,  Collection<Element>  candidates  )  {  Elements  output  =  new  Elements  (  )  ;  SIBLING:  for  (  Element  c:  candidates  )  {  for  (  Element  e:  elements  )  {  if  (  !e  .  parent  (  )  .  equals  (  c  .  parent  (  )  )  )  continue  ;  [ATTENTION]  int  previousSibPos  =  e  .  elementSiblingIndex  (  )    ;  int  cPos  =  c  .  elementSiblingIndex  (  )  ;  if  (  cPos  >  ePos  )  {  output  .  add  (  c  )  ;  continue  SIBLING  ;  }  }  }  return  output  ;  }    [METHOD]  filterForGeneralSiblings  [TYPE]  Elements  [PARAMETER]  Element>  elements  Element>  candidates  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  Element  c  e  found  p  previousSib  root  [TYPE]  Collection  candidates  elements  [TYPE]  String[]  combinators  [TYPE]  String  className  combinator  id  indexS  key  query  s  subQuery  tagName  [TYPE]  Elements  output  [TYPE]  int  cPos  ePos  
[REPLACE]  int  cPos  =  c  .  elementSiblingIndex  (  )  ;	[BUGGY]  int  cPos  =  c  .  getElementsByIndexLessThan  (  cPos  )    ;  [CE]  incompatible  types  [CONTEXT]  private  static  Elements  filterForGeneralSiblings  (  Collection<Element>  elements  ,  Collection<Element>  candidates  )  {  Elements  output  =  new  Elements  (  )  ;  SIBLING:  for  (  Element  c:  candidates  )  {  for  (  Element  e:  elements  )  {  if  (  !e  .  parent  (  )  .  equals  (  c  .  parent  (  )  )  )  continue  ;  int  ePos  =  e  .  elementSiblingIndex  (  )  ;  [ATTENTION]  int  cPos  =  c  .  getElementsByIndexLessThan  (  cPos  )  ;  if  (  cPos  >  ePos  )  {  output  .  add  (  c  )  ;  continue  SIBLING  ;  }  }  }  return  output  ;  }    [METHOD]  filterForGeneralSiblings  [TYPE]  Elements  [PARAMETER]  Element>  elements  Element>  candidates  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  Element  c  e  found  p  previousSib  root  [TYPE]  Collection  candidates  elements  [TYPE]  String[]  combinators  [TYPE]  String  className  combinator  id  indexS  key  query  s  subQuery  tagName  [TYPE]  Elements  output  [TYPE]  int  cPos  ePos  
[ADD]  int  cPos  =  c  .  elementSiblingIndex  (  )  ;	[BUGGY]  [CE]  cannot  find  symbol  cPos  [CONTEXT]  private  static  Elements  filterForGeneralSiblings  (  Collection<Element>  elements  ,  Collection<Element>  candidates  )  {  Elements  output  =  new  Elements  (  )  ;  SIBLING:  for  (  Element  c:  candidates  )  {  for  (  Element  e:  elements  )  {  if  (  !e  .  parent  (  )  .  equals  (  c  .  parent  (  )  )  )  continue  ;  int  ePos  =  e  .  elementSiblingIndex  (  )  ;  [ATTENTION]  if  (  cPos  >  ePos  )  {  output  .  add  (  c  )  ;  continue  SIBLING  ;  }  }  }  return  output  ;  }    [METHOD]  filterForGeneralSiblings  [TYPE]  Elements  [PARAMETER]  Element>  elements  Element>  candidates  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  Element  c  e  found  p  previousSib  root  [TYPE]  Collection  candidates  elements  [TYPE]  String[]  combinators  [TYPE]  String  className  combinator  id  indexS  key  query  s  subQuery  tagName  [TYPE]  Elements  output  [TYPE]  int  cPos  ePos  
[REPLACE]  return  output;	[BUGGY]  return  byTag  (  )  ;  [CE]  non-static  method  byTag()  cannot  be  referenced  from  a  static  context  [CONTEXT]  private  static  Elements  filterForGeneralSiblings  (  Collection<Element>  elements  ,  Collection<Element>  candidates  )  {  Elements  output  =  new  Elements  (  )  ;  SIBLING:  for  (  Element  c:  candidates  )  {  for  (  Element  e:  elements  )  {  if  (  !e  .  parent  (  )  .  equals  (  c  .  parent  (  )  )  )  continue  ;  int  ePos  =  e  .  elementSiblingIndex  (  )  ;  int  cPos  =  c  .  elementSiblingIndex  (  )  ;  if  (  cPos  >  ePos  )  {  output  .  add  (  c  )  ;  continue  SIBLING  ;  }  }  }  [ATTENTION]  return  byTag  (  )    ;  }    [METHOD]  filterForGeneralSiblings  [TYPE]  Elements  [PARAMETER]  Element>  elements  Element>  candidates  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  Element  c  e  found  p  previousSib  root  [TYPE]  Collection  candidates  elements  [TYPE]  String[]  combinators  [TYPE]  String  className  combinator  id  indexS  key  query  s  subQuery  tagName  [TYPE]  Elements  output  [TYPE]  int  cPos  ePos  
[REPLACE]  Elements  children  =  new  Elements  (  )  ;	[BUGGY]  Elements  candidates  =  findElements  (  )  ;  [CE]  variable  candidates  is  already  defined  in  method  filterForSelf(Collection<Element>  ,  Collection<Element>)  [CONTEXT]  private  static  Elements  filterForSelf  (  Collection<Element>  parents  ,  Collection<Element>  candidates  )  {  [ATTENTION]  Elements  candidates  =  findElements  (  )    ;  CHILD:  for  (  Element  c  :  candidates  )  {  for  (  Element  p  :  parents  )  {  if  (  c  .  equals  (  p  )  )  {  children  .  add  (  c  )  ;  continue  CHILD  ;  }  }  }  return  children  ;  }    [METHOD]  filterForSelf  [TYPE]  Elements  [PARAMETER]  Element>  parents  Element>  candidates  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  Element  c  e  found  p  previousSib  root  [TYPE]  Collection  candidates  parents  [TYPE]  String[]  combinators  [TYPE]  String  className  combinator  id  indexS  key  query  s  subQuery  tagName  [TYPE]  Elements  children  
[REPLACE]  if  (  c  .  equals  (  p  )  )  {	[BUGGY]  else  if  (  combinator  .  equals  (   "+ "  )  )[CE]  [CONTEXT]  private  static  Elements  filterForSelf  (  Collection<Element>  parents  ,  Collection<Element>  candidates  )  {  Elements  children  =  new  Elements  (  )  ;  CHILD:  for  (  Element  c  :  candidates  )  {  for  (  Element  p  :  parents  )  {  [ATTENTION]  else  if  (  combinator  .  equals  (   "+ "  )  )  children  .  add  (  c  )  ;  continue  CHILD  ;  }  }  }  return  children  ;  }    [METHOD]  filterForSelf  [TYPE]  Elements  [PARAMETER]  Element>  parents  Element>  candidates  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  Element  c  e  found  p  previousSib  root  [TYPE]  Collection  candidates  parents  [TYPE]  String[]  combinators  [TYPE]  String  className  combinator  id  indexS  key  query  s  subQuery  tagName  [TYPE]  Elements  children  
[ADD]  if  (  c  .  equals  (  p  )  )  {  children  .  add  (  c  )  ;  continue  CHILD;  }	[BUGGY]  children  .  add  (  c  )  ;  continue  CHILD  ;  [NO-ERROR]  [CONTEXT]  private  static  Elements  filterForSelf  (  Collection<Element>  parents  ,  Collection<Element>  candidates  )  {  Elements  children  =  new  Elements  (  )  ;  CHILD:  for  (  Element  c  :  candidates  )  {  for  (  Element  p  :  parents  )  {  [ATTENTION]  children  .  add  (  c  )    ;  continue  CHILD  ;      }  }  return  children  ;  }    [METHOD]  filterForSelf  [TYPE]  Elements  [PARAMETER]  Element>  parents  Element>  candidates  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  Element  c  e  found  p  previousSib  root  [TYPE]  Collection  candidates  parents  [TYPE]  String[]  combinators  [TYPE]  String  className  combinator  id  indexS  key  query  s  subQuery  tagName  [TYPE]  Elements  children  
[REPLACE]  children  .  add  (  c  )  ;	[BUGGY]  children  .  addAll  (  )    ;  [CE]  no  suitable  method  found  for  addAll()  [CONTEXT]  private  static  Elements  filterForSelf  (  Collection<Element>  parents  ,  Collection<Element>  candidates  )  {  Elements  children  =  new  Elements  (  )  ;  CHILD:  for  (  Element  c  :  candidates  )  {  for  (  Element  p  :  parents  )  {  if  (  c  .  equals  (  p  )  )  {  [ATTENTION]  children  .  addAll  (  )  ;  continue  CHILD  ;  }  }  }  return  children  ;  }    [METHOD]  filterForSelf  [TYPE]  Elements  [PARAMETER]  Element>  parents  Element>  candidates  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  Element  c  e  found  p  previousSib  root  [TYPE]  Collection  candidates  parents  [TYPE]  String[]  combinators  [TYPE]  String  className  combinator  id  indexS  key  query  s  subQuery  tagName  [TYPE]  Elements  children  
[REPLACE]  CHILD:  for  (  Element  c  :  candidates  )  {	[BUGGY]  CHILD:  for  (  Element  c  :  candidates  )  {  boolean  found  =  false  ;  [NO-ERROR]  [CONTEXT]  private  static  Elements  filterForSelf  (  Collection<Element>  parents  ,  Collection<Element>  candidates  )  {  Elements  children  =  new  Elements  (  )  ;  [ATTENTION]  CHILD:  for  (  Element  c  :  candidates  )  {  boolean  found  =  false  ;  for  (  Element  p  :  parents  )  {  if  (  c  .  equals  (  p  )  )  {  children  .  add  (  c  )  ;  continue  CHILD  ;  }  }  }  return  children  ;  }    [METHOD]  filterForSelf  [TYPE]  Elements  [PARAMETER]  Element>  parents  Element>  candidates  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  Element  c  e  found  p  previousSib  root  [TYPE]  Collection  candidates  parents  [TYPE]  String[]  combinators  [TYPE]  String  className  combinator  id  indexS  key  query  s  subQuery  tagName  [TYPE]  Elements  children  
[REPLACE]  for  (  Element  p  :  parents  )  {	[BUGGY]  CHILD:  for  (  Element  c  :  candidates  )  {  boolean  found  =  false  ;  [CE]  label  CHILD  already  in  use  [CONTEXT]  private  static  Elements  filterForSelf  (  Collection<Element>  parents  ,  Collection<Element>  candidates  )  {  Elements  children  =  new  Elements  (  )  ;  CHILD:  for  (  Element  c  :  candidates  )  {  [ATTENTION]  CHILD:  for  (  Element  c  :  candidates  )  {  boolean  found  =  false  ;  if  (  c  .  equals  (  p  )  )  {  children  .  add  (  c  )  ;  continue  CHILD  ;  }  }  }  return  children  ;  }    [METHOD]  filterForSelf  [TYPE]  Elements  [PARAMETER]  Element>  parents  Element>  candidates  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  Element  c  e  found  p  previousSib  root  [TYPE]  Collection  candidates  parents  [TYPE]  String[]  combinators  [TYPE]  String  className  combinator  id  indexS  key  query  s  subQuery  tagName  [TYPE]  Elements  children  
[REPLACE]  return  children;	[BUGGY]  return  byTag  (  )  ;  [CE]  non-static  method  byTag()  cannot  be  referenced  from  a  static  context  [CONTEXT]  private  static  Elements  filterForSelf  (  Collection<Element>  parents  ,  Collection<Element>  candidates  )  {  Elements  children  =  new  Elements  (  )  ;  CHILD:  for  (  Element  c  :  candidates  )  {  for  (  Element  p  :  parents  )  {  if  (  c  .  equals  (  p  )  )  {  children  .  add  (  c  )  ;  continue  CHILD  ;  }  }  }  [ATTENTION]  return  byTag  (  )    ;  }    [METHOD]  filterForSelf  [TYPE]  Elements  [PARAMETER]  Element>  parents  Element>  candidates  [CLASS]  Selector  SelectorParseException    [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  Element  c  e  found  p  previousSib  root  [TYPE]  Collection  candidates  parents  [TYPE]  String[]  combinators  [TYPE]  String  className  combinator  id  indexS  key  query  s  subQuery  tagName  [TYPE]  Elements  children  
[ADD]  super  (  s  )  ;	[BUGGY]  [NO-ERROR]  [CONTEXT]  public  SelectorParseException  (  String  s  )  {  [ATTENTION]  }    [METHOD]  <init>  [TYPE]  String)  [PARAMETER]  String  s  [CLASS]  SelectorParseException    [TYPE]  boolean  false  true  [TYPE]  String  s  
[REPLACE]  contents  =  new  ArrayList<Element>  (  )  ;	[BUGGY]  contents  =  new  ArrayList<Element>  (  elements  )  ;    ;  [CE]  cannot  find  symbol  elements  [CONTEXT]  public  Elements  (  )  {  [ATTENTION]  contents  =  new  ArrayList<Element>  (  elements  )    ;    ;  }    [METHOD]  <init>  [TYPE]  Elements()  [PARAMETER]  [CLASS]  Elements    [TYPE]  List  contents  [TYPE]  boolean  false  true  
[REPLACE]  contents  =  new  ArrayList<Element>  (  elements  )  ;	[BUGGY]  contents  =    new  Element>  (  )    ;    ;  [CE]  '('  or  '['  expected  [CONTEXT]  public  Elements  (  Collection<Element>  elements  )  {  [ATTENTION]  contents  =  new  Element>  (  )  ;    ;  }    [METHOD]  <init>  [TYPE]  Collection)  [PARAMETER]  Element>  elements  [CLASS]  Elements    [TYPE]  Collection  elements  [TYPE]  List  contents  [TYPE]  boolean  false  true  
[REPLACE]  contents  =  elements;	[BUGGY]  contents  =    null  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  Elements  (  List<Element>  elements  )  {  [ATTENTION]  contents  =  null  ;  }    [METHOD]  <init>  [TYPE]  List)  [PARAMETER]  Element>  elements  [CLASS]  Elements    [TYPE]  List  contents  elements  [TYPE]  boolean  false  true  
[REPLACE]  this  (  Arrays  .  asList  (  elements  )  )  ;	[BUGGY]  this  (    elements    )  ;  [CE]  recursive  constructor  invocation  [CONTEXT]  public  Elements  (  Element  .  .  .  elements  )  {  [ATTENTION]  this  (  elements  )    ;  }    [METHOD]  <init>  [TYPE]  Element[])  [PARAMETER]  elements  [CLASS]  Elements    [TYPE]  List  contents  elements  [TYPE]  Element[]  elements  [TYPE]  boolean  false  true  
[REPLACE]  if  (  element  .  hasAttr  (  attributeKey  )  )  return  element  .  attr  (  attributeKey  )  ;	[BUGGY]  if  (  element  .  hasAttr  (  .  hasAttributeKey  )  )  return  element  .  attr  (  attributeKey  )  ;  [CE]  illegal  start  of  expression  [CONTEXT]  public  String  attr  (  String  attributeKey  )  {  for  (  Element  element  :  contents  )  {  [ATTENTION]  if  (  element  .  hasAttr  (  .  hasAttributeKey  )  )  return  element  .  attr  (  attributeKey  )    ;    }  return   " "  ;  }    [METHOD]  attr  [TYPE]  String  [PARAMETER]  String  attributeKey  [CLASS]  Elements    [TYPE]  List  contents  elements  [TYPE]  String  attributeKey  [TYPE]  boolean  false  true  [TYPE]  Element  element  
[REPLACE]  return  element  .  attr  (  attributeKey  )  ;	[BUGGY]  return  element  .  hasAttr  (  attributeKey  )  ;  [CE]  incompatible  types  [CONTEXT]  public  String  attr  (  String  attributeKey  )  {  for  (  Element  element  :  contents  )  {  if  (  element  .  hasAttr  (  attributeKey  )  )  [ATTENTION]  return  element  .  hasAttr  (  attributeKey  )    ;  }  return   " "  ;  }    [METHOD]  attr  [TYPE]  String  [PARAMETER]  String  attributeKey  [CLASS]  Elements    [TYPE]  List  contents  elements  [TYPE]  String  attributeKey  [TYPE]  boolean  false  true  [TYPE]  Element  element  
[REPLACE]  for  (  Element  element  :  contents  )  {	[BUGGY]  for  (  Element  element  :  contents  )  {  element  .  addClass  (  className  )  ;  [CE]  cannot  find  symbol  className  [CONTEXT]  public  String  attr  (  String  attributeKey  )  {  [ATTENTION]  for  (  Element  element  :  contents  )  {  element  .  addClass  (  className  )    ;  if  (  element  .  hasAttr  (  attributeKey  )  )  return  element  .  attr  (  attributeKey  )  ;  }  return   " "  ;  }    [METHOD]  attr  [TYPE]  String  [PARAMETER]  String  attributeKey  [CLASS]  Elements    [TYPE]  List  contents  elements  [TYPE]  String  attributeKey  [TYPE]  boolean  false  true  [TYPE]  Element  element  
[REPLACE]  return   " ";	[BUGGY]  return  new  Elements  (  )  ;  [CE]  incompatible  types  [CONTEXT]  public  String  attr  (  String  attributeKey  )  {  for  (  Element  element  :  contents  )  {  if  (  element  .  hasAttr  (  attributeKey  )  )  return  element  .  attr  (  attributeKey  )  ;  }  [ATTENTION]  return  new  Elements  (  )    ;  }    [METHOD]  attr  [TYPE]  String  [PARAMETER]  String  attributeKey  [CLASS]  Elements    [TYPE]  List  contents  elements  [TYPE]  String  attributeKey  [TYPE]  boolean  false  true  [TYPE]  Element  element  
[REPLACE]  if  (  element  .  hasAttr  (  attributeKey  )  )  return  true;	[BUGGY]  if  (  element  .  attr  (  attributeKey  )  )  return  false  ;  [CE]  incompatible  types  [CONTEXT]  public  boolean  hasAttr  (  String  attributeKey  )  {  for  (  Element  element  :  contents  )  {  [ATTENTION]  if  (  element  .  attr  (  attributeKey  )  )  return  false  ;    }  return  false  ;  }    [METHOD]  hasAttr  [TYPE]  boolean  [PARAMETER]  String  attributeKey  [CLASS]  Elements    [TYPE]  List  contents  elements  [TYPE]  String  attributeKey  [TYPE]  boolean  false  true  [TYPE]  Element  element  
[REPLACE]  return  true;	[BUGGY]  return  false  ;  [FE]  null  assertEquals(2  ,  withTitle.size())  ;  assertTrue(withTitle.hasAttr( "title "))  ;  assertFalse(withTitle.hasAttr( "class "))  ;  assertEquals( "foo "  ,  withTitle.attr( "title "))  ;  assertEquals(2  ,  withTitle.size())  ;  //  existing  Elements  are  not  reevaluatedassertEquals(0  ,  doc.select( "p[title] ").size())  ;  assertEquals(4  ,  ps.size())  ;  assertEquals( "classy "  ,  ps.last().attr( "style "))  ;  assertEquals( "bar "  ,  ps.last().attr( "class "))  ;  [CONTEXT]  public  boolean  hasAttr  (  String  attributeKey  )  {  for  (  Element  element  :  contents  )  {  if  (  element  .  hasAttr  (  attributeKey  )  )  [ATTENTION]  return  false  ;  }  return  false  ;  }    [METHOD]  hasAttr  [TYPE]  boolean  [PARAMETER]  String  attributeKey  [CLASS]  Elements    [TYPE]  List  contents  elements  [TYPE]  String  attributeKey  [TYPE]  boolean  false  true  [TYPE]  Element  element  
[REPLACE]  for  (  Element  element  :  contents  )  {	[BUGGY]  for  (  Element  element  :  contents  )  {  element  .  addClass  (  className  )  ;  [CE]  cannot  find  symbol  className  [CONTEXT]  public  boolean  hasAttr  (  String  attributeKey  )  {  [ATTENTION]  for  (  Element  element  :  contents  )  {  element  .  addClass  (  className  )    ;  if  (  element  .  hasAttr  (  attributeKey  )  )  return  true  ;  }  return  false  ;  }    [METHOD]  hasAttr  [TYPE]  boolean  [PARAMETER]  String  attributeKey  [CLASS]  Elements    [TYPE]  List  contents  elements  [TYPE]  String  attributeKey  [TYPE]  boolean  false  true  [TYPE]  Element  element  
[REPLACE]  return  false;	[BUGGY]  return  true  ;  [FE]  null  assertEquals(2  ,  withTitle.size())  ;  assertTrue(withTitle.hasAttr( "title "))  ;  assertFalse(withTitle.hasAttr( "class "))  ;  assertEquals( "foo "  ,  withTitle.attr( "title "))  ;  assertEquals(2  ,  withTitle.size())  ;  //  existing  Elements  are  not  reevaluatedassertEquals(0  ,  doc.select( "p[title] ").size())  ;  assertEquals(4  ,  ps.size())  ;  assertEquals( "classy "  ,  ps.last().attr( "style "))  ;  assertEquals( "bar "  ,  ps.last().attr( "class "))  ;  [CONTEXT]  public  boolean  hasAttr  (  String  attributeKey  )  {  for  (  Element  element  :  contents  )  {  if  (  element  .  hasAttr  (  attributeKey  )  )  return  true  ;  }  [ATTENTION]  return  true  ;  }    [METHOD]  hasAttr  [TYPE]  boolean  [PARAMETER]  String  attributeKey  [CLASS]  Elements    [TYPE]  List  contents  elements  [TYPE]  String  attributeKey  [TYPE]  boolean  false  true  [TYPE]  Element  element  
[REPLACE]  for  (  Element  element  :  contents  )  {	[BUGGY]  for  (  Element  element  :  contents  )  {  element  .  addClass  (  className  )  ;  [CE]  cannot  find  symbol  className  [CONTEXT]  public  Elements  attr  (  String  attributeKey  ,  String  attributeValue  )  {  [ATTENTION]  for  (  Element  element  :  contents  )  {  element  .  addClass  (  className  )    ;  element  .  attr  (  attributeKey  ,  attributeValue  )  ;  }  return  this  ;  }    [METHOD]  attr  [TYPE]  Elements  [PARAMETER]  String  attributeKey  String  attributeValue  [CLASS]  Elements    [TYPE]  List  contents  elements  [TYPE]  String  attributeKey  attributeValue  [TYPE]  boolean  false  true  [TYPE]  Element  element  
[REPLACE]  return  this;	[BUGGY]  return  null  ;  [FE]  null  assertEquals(2  ,  withTitle.size())  ;  assertTrue(withTitle.hasAttr( "title "))  ;  assertFalse(withTitle.hasAttr( "class "))  ;  assertEquals( "foo "  ,  withTitle.attr( "title "))  ;  assertEquals(2  ,  withTitle.size())  ;  //  existing  Elements  are  not  reevaluatedassertEquals(0  ,  doc.select( "p[title] ").size())  ;  assertEquals(4  ,  ps.size())  ;  assertEquals( "classy "  ,  ps.last().attr( "style "))  ;  assertEquals( "bar "  ,  ps.last().attr( "class "))  ;  [CONTEXT]  public  Elements  attr  (  String  attributeKey  ,  String  attributeValue  )  {  for  (  Element  element  :  contents  )  {  element  .  attr  (  attributeKey  ,  attributeValue  )  ;  }  [ATTENTION]  return  null  ;  }    [METHOD]  attr  [TYPE]  Elements  [PARAMETER]  String  attributeKey  String  attributeValue  [CLASS]  Elements    [TYPE]  List  contents  elements  [TYPE]  String  attributeKey  attributeValue  [TYPE]  boolean  false  true  [TYPE]  Element  element  
[REPLACE]  for  (  Element  element  :  contents  )  {	[BUGGY]  for  (  Element  element  :  contents  )  {  element  .  addClass  (  className  )  ;  [CE]  cannot  find  symbol  className  [CONTEXT]  public  Elements  removeAttr  (  String  attributeKey  )  {  [ATTENTION]  for  (  Element  element  :  contents  )  {  element  .  addClass  (  className  )    ;  element  .  removeAttr  (  attributeKey  )  ;  }  return  this  ;  }    [METHOD]  removeAttr  [TYPE]  Elements  [PARAMETER]  String  attributeKey  [CLASS]  Elements    [TYPE]  List  contents  elements  [TYPE]  String  attributeKey  [TYPE]  boolean  false  true  [TYPE]  Element  element  
[ADD]  for  (  Element  element  :  contents  )  {  element  .  removeAttr  (  attributeKey  )  ;  }	[BUGGY]  [FE]  AssertionFailedError    expected:<0>  but  was:<2>  assertEquals(2  ,  withTitle.size())  ;  assertTrue(withTitle.hasAttr( "title "))  ;  assertFalse(withTitle.hasAttr( "class "))  ;  assertEquals( "foo "  ,  withTitle.attr( "title "))  ;  assertEquals(2  ,  withTitle.size())  ;  //  existing  Elements  are  not  reevaluatedassertEquals(0  ,  doc.select( "p[title] ").size())  ;  assertEquals(4  ,  ps.size())  ;  assertEquals( "classy "  ,  ps.last().attr( "style "))  ;  assertEquals( "bar "  ,  ps.last().attr( "class "))  ;  [CONTEXT]  public  Elements  removeAttr  (  String  attributeKey  )  {  [ATTENTION]    return  this  ;  }    [METHOD]  removeAttr  [TYPE]  Elements  [PARAMETER]  String  attributeKey  [CLASS]  Elements    [TYPE]  List  contents  elements  [TYPE]  String  attributeKey  [TYPE]  boolean  false  true  [TYPE]  Element  element  
[REPLACE]  return  this;	[BUGGY]  return  null  ;  [NO-ERROR]  [CONTEXT]  public  Elements  removeAttr  (  String  attributeKey  )  {  for  (  Element  element  :  contents  )  {  element  .  removeAttr  (  attributeKey  )  ;  }  [ATTENTION]  return  null  ;  }    [METHOD]  removeAttr  [TYPE]  Elements  [PARAMETER]  String  attributeKey  [CLASS]  Elements    [TYPE]  List  contents  elements  [TYPE]  String  attributeKey  [TYPE]  boolean  false  true  [TYPE]  Element  element  
[REPLACE]  for  (  Element  element  :  contents  )  {	[BUGGY]  for  (  Element  element  :  contents  )  {  element  .  addClass  (  className  )  ;  [NO-ERROR]  [CONTEXT]  public  Elements  addClass  (  String  className  )  {  [ATTENTION]  for  (  Element  element  :  contents  )  {  element  .  addClass  (  className  )    ;  element  .  addClass  (  className  )  ;  }  return  this  ;  }    [METHOD]  addClass  [TYPE]  Elements  [PARAMETER]  String  className  [CLASS]  Elements    [TYPE]  List  contents  elements  [TYPE]  String  className  [TYPE]  boolean  false  true  [TYPE]  Element  element  
[REPLACE]  return  this;	[BUGGY]  return  null  ;  [NO-ERROR]  [CONTEXT]  public  Elements  addClass  (  String  className  )  {  for  (  Element  element  :  contents  )  {  element  .  addClass  (  className  )  ;  }  [ATTENTION]  return  null  ;  }    [METHOD]  addClass  [TYPE]  Elements  [PARAMETER]  String  className  [CLASS]  Elements    [TYPE]  List  contents  elements  [TYPE]  String  className  [TYPE]  boolean  false  true  [TYPE]  Element  element  
[REPLACE]  for  (  Element  element  :  contents  )  {	[BUGGY]  for  (  Element  element  :  contents  )  {  element  .  addClass  (  className  )  ;  [NO-ERROR]  [CONTEXT]  public  Elements  removeClass  (  String  className  )  {  [ATTENTION]  for  (  Element  element  :  contents  )  {  element  .  addClass  (  className  )    ;  element  .  removeClass  (  className  )  ;  }  return  this  ;  }    [METHOD]  removeClass  [TYPE]  Elements  [PARAMETER]  String  className  [CLASS]  Elements    [TYPE]  List  contents  elements  [TYPE]  String  className  [TYPE]  boolean  false  true  [TYPE]  Element  element  
[REPLACE]  return  this;	[BUGGY]  return  null  ;  [NO-ERROR]  [CONTEXT]  public  Elements  removeClass  (  String  className  )  {  for  (  Element  element  :  contents  )  {  element  .  removeClass  (  className  )  ;  }  [ATTENTION]  return  null  ;  }    [METHOD]  removeClass  [TYPE]  Elements  [PARAMETER]  String  className  [CLASS]  Elements    [TYPE]  List  contents  elements  [TYPE]  String  className  [TYPE]  boolean  false  true  [TYPE]  Element  element  
[REPLACE]  for  (  Element  element  :  contents  )  {	[BUGGY]  for  (  Element  element  :  contents  )  {  element  .  addClass  (  className  )  ;  [FE]  AssertionFailedError    expected:<red  green  blue[  mellow]>  but  was:<red  green  blue[]>  assertTrue(els.hasClass( "red "))  ;  assertFalse(els.hasClass( "blue "))  ;  assertEquals( "blue "  ,  els.get(0).className())  ;  assertEquals( "red  green  blue  mellow "  ,  els.get(1).className())  ;  [CONTEXT]  public  Elements  toggleClass  (  String  className  )  {  [ATTENTION]  for  (  Element  element  :  contents  )  {  element  .  addClass  (  className  )    ;  element  .  toggleClass  (  className  )  ;  }  return  this  ;  }    [METHOD]  toggleClass  [TYPE]  Elements  [PARAMETER]  String  className  [CLASS]  Elements    [TYPE]  List  contents  elements  [TYPE]  String  className  [TYPE]  boolean  false  true  [TYPE]  Element  element  
[REPLACE]  return  this;	[BUGGY]  return  null  ;  [NO-ERROR]  [CONTEXT]  public  Elements  toggleClass  (  String  className  )  {  for  (  Element  element  :  contents  )  {  element  .  toggleClass  (  className  )  ;  }  [ATTENTION]  return  null  ;  }    [METHOD]  toggleClass  [TYPE]  Elements  [PARAMETER]  String  className  [CLASS]  Elements    [TYPE]  List  contents  elements  [TYPE]  String  className  [TYPE]  boolean  false  true  [TYPE]  Element  element  
[REPLACE]  if  (  element  .  hasClass  (  className  )  )  return  true;	[BUGGY]  if  (  element  .  addClass  (  className  )  )  return  false  ;  [CE]  incompatible  types  [CONTEXT]  public  boolean  hasClass  (  String  className  )  {  for  (  Element  element  :  contents  )  {  [ATTENTION]  if  (  element  .  addClass  (  className  )  )  return  false  ;    }  return  false  ;  }    [METHOD]  hasClass  [TYPE]  boolean  [PARAMETER]  String  className  [CLASS]  Elements    [TYPE]  List  contents  elements  [TYPE]  String  className  [TYPE]  boolean  false  true  [TYPE]  Element  element  
[REPLACE]  return  true;	[BUGGY]  return  false  ;  [FE]  null  assertTrue(els.hasClass( "red "))  ;  assertFalse(els.hasClass( "blue "))  ;  assertEquals( "blue "  ,  els.get(0).className())  ;  assertEquals( "red  green  blue  mellow "  ,  els.get(1).className())  ;  [CONTEXT]  public  boolean  hasClass  (  String  className  )  {  for  (  Element  element  :  contents  )  {  if  (  element  .  hasClass  (  className  )  )  [ATTENTION]  return  false  ;  }  return  false  ;  }    [METHOD]  hasClass  [TYPE]  boolean  [PARAMETER]  String  className  [CLASS]  Elements    [TYPE]  List  contents  elements  [TYPE]  String  className  [TYPE]  boolean  false  true  [TYPE]  Element  element  
[REPLACE]  for  (  Element  element  :  contents  )  {	[BUGGY]  for  (  Element  element  :  contents  )  {  element  .  addClass  (  className  )  ;  [FE]  null  assertTrue(els.hasClass( "red "))  ;  assertFalse(els.hasClass( "blue "))  ;  assertEquals( "blue "  ,  els.get(0).className())  ;  assertEquals( "red  green  blue  mellow "  ,  els.get(1).className())  ;  [CONTEXT]  public  boolean  hasClass  (  String  className  )  {  [ATTENTION]  for  (  Element  element  :  contents  )  {  element  .  addClass  (  className  )    ;  if  (  element  .  hasClass  (  className  )  )  return  true  ;  }  return  false  ;  }    [METHOD]  hasClass  [TYPE]  boolean  [PARAMETER]  String  className  [CLASS]  Elements    [TYPE]  List  contents  elements  [TYPE]  String  className  [TYPE]  boolean  false  true  [TYPE]  Element  element  
[REPLACE]  return  false;	[BUGGY]  return  true  ;  [FE]  null  assertTrue(els.hasClass( "red "))  ;  assertFalse(els.hasClass( "blue "))  ;  assertEquals( "blue "  ,  els.get(0).className())  ;  assertEquals( "red  green  blue  mellow "  ,  els.get(1).className())  ;  [CONTEXT]  public  boolean  hasClass  (  String  className  )  {  for  (  Element  element  :  contents  )  {  if  (  element  .  hasClass  (  className  )  )  return  true  ;  }  [ATTENTION]  return  true  ;  }    [METHOD]  hasClass  [TYPE]  boolean  [PARAMETER]  String  className  [CLASS]  Elements    [TYPE]  List  contents  elements  [TYPE]  String  className  [TYPE]  boolean  false  true  [TYPE]  Element  element  
[REPLACE]  if  (  size  (  )  >  0  )  return  first  (  )    .  val  (  )  ;	[BUGGY]  if  (  size  (  )  -  4  >  0  )  return  first  (  )  .  val  (  )  ;  [FE]  AssertionFailedError    expected:<[Hello]>  but  was:<[]>  assertEquals( "Hello "  ,  els.text())  ;  assertEquals( "Hello "  ,  els.val())  ;  [CONTEXT]  public  String  val  (  )  {  [ATTENTION]  if  (  size  (  )  -  4  >  0  )  return  first  (  )    .  val  (  )    ;    else  return   " "  ;  }    [METHOD]  val  [TYPE]  String  [PARAMETER]  [CLASS]  Elements    [TYPE]  List  contents  elements  [TYPE]  boolean  false  true  
[REPLACE]  return   " ";	[BUGGY]  return  new  Elements  (  )  ;  [CE]  incompatible  types  [CONTEXT]  public  String  val  (  )  {  if  (  size  (  )  >  0  )  return  first  (  )  .  val  (  )  ;  else  [ATTENTION]  return  new  Elements  (  )    ;  }    [METHOD]  val  [TYPE]  String  [PARAMETER]  [CLASS]  Elements    [TYPE]  List  contents  elements  [TYPE]  boolean  false  true  
[REPLACE]  return  first  (  )    .  val  (  )  ;	[BUGGY]  public  int  size  (  )  {return  contents  .  size  (  )  ;  }[CE]  illegal  start  of  expression  [CONTEXT]  public  String  val  (  )  {  if  (  size  (  )  >  0  )  [ATTENTION]  public  int  size  (  )  {return  contents  .  size  (  )    ;  }  else  return   " "  ;  }    [METHOD]  val  [TYPE]  String  [PARAMETER]  [CLASS]  Elements    [TYPE]  List  contents  elements  [TYPE]  boolean  false  true  
[ADD]  for  (  Element  element  :  contents  )  element  .  val  (  value  )  ;  return  this;  }	[BUGGY]  [CE]  illegal  start  of  expression  [CONTEXT]  public  Elements  val  (  String  value  )  {  [ATTENTION]        [METHOD]  val  [TYPE]  Elements  [PARAMETER]  String  value  [CLASS]  Elements    [TYPE]  List  contents  elements  [TYPE]  String  value  [TYPE]  boolean  false  true  [TYPE]  Element  element  
[REPLACE]  return  this;	[BUGGY]  return  null  ;  [NO-ERROR]  [CONTEXT]  public  Elements  val  (  String  value  )  {  for  (  Element  element  :  contents  )  element  .  val  (  value  )  ;  [ATTENTION]  return  null  ;  }    [METHOD]  val  [TYPE]  Elements  [PARAMETER]  String  value  [CLASS]  Elements    [TYPE]  List  contents  elements  [TYPE]  String  value  [TYPE]  boolean  false  true  [TYPE]  Element  element  
[REPLACE]  StringBuilder  sb  =  new  StringBuilder  (  )  ;	[BUGGY]  for  (  Element  element  :  contents  )  {  element  .  addClass  (  className  )  ;  [CE]  illegal  start  of  expression  [CONTEXT]  public  String  text  (  )  {  [ATTENTION]  for  (  Element  element  :  contents  )  {  element  .  addClass  (  className  )    ;  for  (  Element  element  :  contents  )  {  if  (  sb  .  length  (  )  !  =  0  )  sb  .  append  (   "   "  )  ;  sb  .  append  (  element  .  text  (  )  )  ;  }  return  sb  .  toString  (  )  ;  }    [METHOD]  text  [TYPE]  String  [PARAMETER]  [CLASS]  Elements    [TYPE]  List  contents  elements  [TYPE]  boolean  false  true  [TYPE]  StringBuilder  sb  [TYPE]  Element  element  
[REPLACE]  if  (  sb  .  length  (  )  !=  0  )  sb  .  append  (   "   "  )  ;	[BUGGY]  if  (  sb  .  length  (  )  -  1  !  =  0  )  sb  .  append  (   "   "  )  ;  [FE]  AssertionFailedError    expected:<[]Hello>  but  was:<[  ]Hello>  assertEquals( "Hello "  ,  els.text())  ;  assertEquals( "Hello "  ,  els.val())  ;  [CONTEXT]  public  String  text  (  )  {  StringBuilder  sb  =  new  StringBuilder  (  )  ;  for  (  Element  element  :  contents  )  {  [ATTENTION]  if  (  sb  .  length  (  )  -  1  !  =  0  )  sb  .  append  (   "   "  )    ;    sb  .  append  (  element  .  text  (  )  )  ;  }  return  sb  .  toString  (  )  ;  }    [METHOD]  text  [TYPE]  String  [PARAMETER]  [CLASS]  Elements    [TYPE]  List  contents  elements  [TYPE]  boolean  false  true  [TYPE]  StringBuilder  sb  [TYPE]  Element  element  
[REPLACE]  sb  .  append  (   "   "  )  ;	[BUGGY]  sb  .  append  (   "\n "  )  ;  [FE]  AssertionFailedError    expected:<Hello[  there  ]world>  but  was:<Hello[  assertEquals( "Hello  there  world "  ,  doc.select( "div  >  * ").text())  ;  [CONTEXT]  public  String  text  (  )  {  StringBuilder  sb  =  new  StringBuilder  (  )  ;  for  (  Element  element  :  contents  )  {  if  (  sb  .  length  (  )  !  =  0  )  [ATTENTION]  sb  .  append  (   "\n "  )    ;  sb  .  append  (  element  .  text  (  )  )  ;  }  return  sb  .  toString  (  )  ;  }    [METHOD]  text  [TYPE]  String  [PARAMETER]  [CLASS]  Elements    [TYPE]  List  contents  elements  [TYPE]  boolean  false  true  [TYPE]  StringBuilder  sb  [TYPE]  Element  element  
[REPLACE]  for  (  Element  element  :  contents  )  {	[BUGGY]  for  (  Element  element  :  contents  )  {  element  .  addClass  (  className  )  ;  [CE]  cannot  find  symbol  className  [CONTEXT]  public  String  text  (  )  {  StringBuilder  sb  =  new  StringBuilder  (  )  ;  [ATTENTION]  for  (  Element  element  :  contents  )  {  element  .  addClass  (  className  )    ;  if  (  sb  .  length  (  )  !  =  0  )  sb  .  append  (   "   "  )  ;  sb  .  append  (  element  .  text  (  )  )  ;  }  return  sb  .  toString  (  )  ;  }    [METHOD]  text  [TYPE]  String  [PARAMETER]  [CLASS]  Elements    [TYPE]  List  contents  elements  [TYPE]  boolean  false  true  [TYPE]  StringBuilder  sb  [TYPE]  Element  element  
[ADD]  for  (  Element  element  :  contents  )  {  if  (  sb  .  length  (  )  !=  0  )  sb  .  append  (   "   "  )  ;  sb  .  append  (  element  .  text  (  )  )  ;  }	[BUGGY]  [FE]  AssertionFailedError    expected:<[Brace  yourself  for  Metro  meltdown]>  but  was:<[]>  assertEquals( "News.com.au  |  News  from  Australia  and  around  the  world  online  |  NewsComAu "  ,  doc.title())  ;  assertEquals( "Brace  yourself  for  Metro  meltdown "  ,  doc.select( ".id1225817868581  h4 ").text().trim())  ;  assertEquals( "/entertainment/horoscopes "  ,  a.attr( "href "))  ;  assertEquals( "http://www.news.com.au/entertainment/horoscopes "  ,  a.attr( "abs:href "))  ;  assertEquals( "http://www.heraldsun.com.au/news/naughty-corners-are-a-bad-idea-for-kids/story-e6frf7jo-1225817899003 "  ,  hs.attr( "href "))  ;  assertEquals(hs.attr( "href ")  ,  hs.attr( "abs:href "))  ;  [CONTEXT]  public  String  text  (  )  {  StringBuilder  sb  =  new  StringBuilder  (  )  ;  [ATTENTION]      return  sb  .  toString  (  )  ;  }    [METHOD]  text  [TYPE]  String  [PARAMETER]  [CLASS]  Elements    [TYPE]  List  contents  elements  [TYPE]  boolean  false  true  [TYPE]  StringBuilder  sb  [TYPE]  Element  element  
[REPLACE]  return  sb  .  toString  (  )  ;	[BUGGY]  return  sb  .  StringBuilder  (  )  ;  [CE]  cannot  find  symbol  [CONTEXT]  public  String  text  (  )  {  StringBuilder  sb  =  new  StringBuilder  (  )  ;  for  (  Element  element  :  contents  )  {  if  (  sb  .  length  (  )  !  =  0  )  sb  .  append  (   "   "  )  ;  sb  .  append  (  element  .  text  (  )  )  ;  }  [ATTENTION]  return  sb  .  StringBuilder  (  )    ;  }    [METHOD]  text  [TYPE]  String  [PARAMETER]  [CLASS]  Elements    [TYPE]  List  contents  elements  [TYPE]  boolean  false  true  [TYPE]  StringBuilder  sb  [TYPE]  Element  element  
[REPLACE]  if  (  element  .  hasText  (  )  )  return  true;	[BUGGY]  if  (  element  .  hasText  (  )  )  return  false  ;  [FE]  null  assertTrue(divs.hasText())  ;  assertFalse(doc.select( "div  +  div ").hasText())  ;  [CONTEXT]  public  boolean  hasText  (  )  {  for  (  Element  element:  contents  )  {  [ATTENTION]  if  (  element  .  hasText  (  )  )  return  false  ;    }  return  false  ;  }    [METHOD]  hasText  [TYPE]  boolean  [PARAMETER]  [CLASS]  Elements    [TYPE]  List  contents  elements  [TYPE]  Element  element  [TYPE]  boolean  false  true  
[REPLACE]  return  true;	[BUGGY]  return  false  ;  [FE]  null  assertTrue(divs.hasText())  ;  assertFalse(doc.select( "div  +  div ").hasText())  ;  [CONTEXT]  public  boolean  hasText  (  )  {  for  (  Element  element:  contents  )  {  if  (  element  .  hasText  (  )  )  [ATTENTION]  return  false  ;  }  return  false  ;  }    [METHOD]  hasText  [TYPE]  boolean  [PARAMETER]  [CLASS]  Elements    [TYPE]  List  contents  elements  [TYPE]  Element  element  [TYPE]  boolean  false  true  
[REPLACE]  for  (  Element  element:  contents  )  {	[BUGGY]  for  (  Element  element  :  contents  )  {  element  .  addClass  (  className  )  ;  [CE]  cannot  find  symbol  className  [CONTEXT]  public  boolean  hasText  (  )  {  [ATTENTION]  for  (  Element  element  :  contents  )  {  element  .  addClass  (  className  )    ;  if  (  element  .  hasText  (  )  )  return  true  ;  }  return  false  ;  }    [METHOD]  hasText  [TYPE]  boolean  [PARAMETER]  [CLASS]  Elements    [TYPE]  List  contents  elements  [TYPE]  Element  element  [TYPE]  boolean  false  true  
[REPLACE]  return  false;	[BUGGY]  return  true  ;  [FE]  null  assertTrue(divs.hasText())  ;  assertFalse(doc.select( "div  +  div ").hasText())  ;  [CONTEXT]  public  boolean  hasText  (  )  {  for  (  Element  element:  contents  )  {  if  (  element  .  hasText  (  )  )  return  true  ;  }  [ATTENTION]  return  true  ;  }    [METHOD]  hasText  [TYPE]  boolean  [PARAMETER]  [CLASS]  Elements    [TYPE]  List  contents  elements  [TYPE]  Element  element  [TYPE]  boolean  false  true  
[REPLACE]  StringBuilder  sb  =  new  StringBuilder  (  )  ;	[BUGGY]  for  (  Element  element  :  contents  )  {  element  .  addClass  (  className  )  ;  [CE]  illegal  start  of  expression  [CONTEXT]  public  String  html  (  )  {  [ATTENTION]  for  (  Element  element  :  contents  )  {  element  .  addClass  (  className  )    ;  for  (  Element  element  :  contents  )  {  if  (  sb  .  length  (  )  !  =  0  )  sb  .  append  (   "\n "  )  ;  sb  .  append  (  element  .  html  (  )  )  ;  }  return  sb  .  toString  (  )  ;  }    [METHOD]  html  [TYPE]  String  [PARAMETER]  [CLASS]  Elements    [TYPE]  List  contents  elements  [TYPE]  boolean  false  true  [TYPE]  StringBuilder  sb  [TYPE]  Element  element  
[REPLACE]  if  (  sb  .  length  (  )  !=  0  )  sb  .  append  (   "\n "  )  ;	[BUGGY]  if  (  sb  .  length  (  )  *  2  !  =  0  )  sb  .  append  (   "\n "  )  ;  [NO-ERROR]  [CONTEXT]  public  String  html  (  )  {  StringBuilder  sb  =  new  StringBuilder  (  )  ;  for  (  Element  element  :  contents  )  {  [ATTENTION]  if  (  sb  .  length  (  )  *2  !  =  0  )  sb  .  append  (   "\n "  )    ;    sb  .  append  (  element  .  html  (  )  )  ;  }  return  sb  .  toString  (  )  ;  }    [METHOD]  html  [TYPE]  String  [PARAMETER]  [CLASS]  Elements    [TYPE]  List  contents  elements  [TYPE]  boolean  false  true  [TYPE]  StringBuilder  sb  [TYPE]  Element  element  
[REPLACE]  sb  .  append  (   "\n "  )  ;	[BUGGY]  sb  .  StringBuilder  (  )    ;  [CE]  cannot  find  symbol  [CONTEXT]  public  String  html  (  )  {  StringBuilder  sb  =  new  StringBuilder  (  )  ;  for  (  Element  element  :  contents  )  {  if  (  sb  .  length  (  )  !  =  0  )  [ATTENTION]  sb  .  StringBuilder  (  )  ;  sb  .  append  (  element  .  html  (  )  )  ;  }  return  sb  .  toString  (  )  ;  }    [METHOD]  html  [TYPE]  String  [PARAMETER]  [CLASS]  Elements    [TYPE]  List  contents  elements  [TYPE]  boolean  false  true  [TYPE]  StringBuilder  sb  [TYPE]  Element  element  
[REPLACE]  for  (  Element  element  :  contents  )  {	[BUGGY]  for  (  Element  element  :  contents  )  {  element  .  addClass  (  className  )  ;  [CE]  cannot  find  symbol  className  [CONTEXT]  public  String  html  (  )  {  StringBuilder  sb  =  new  StringBuilder  (  )  ;  [ATTENTION]  for  (  Element  element  :  contents  )  {  element  .  addClass  (  className  )    ;  if  (  sb  .  length  (  )  !  =  0  )  sb  .  append  (   "\n "  )  ;  sb  .  append  (  element  .  html  (  )  )  ;  }  return  sb  .  toString  (  )  ;  }    [METHOD]  html  [TYPE]  String  [PARAMETER]  [CLASS]  Elements    [TYPE]  List  contents  elements  [TYPE]  boolean  false  true  [TYPE]  StringBuilder  sb  [TYPE]  Element  element  
[REPLACE]  return  sb  .  toString  (  )  ;	[BUGGY]  return  sb  .  StringBuilder  (  )  ;  [CE]  cannot  find  symbol  [CONTEXT]  public  String  html  (  )  {  StringBuilder  sb  =  new  StringBuilder  (  )  ;  for  (  Element  element  :  contents  )  {  if  (  sb  .  length  (  )  !  =  0  )  sb  .  append  (   "\n "  )  ;  sb  .  append  (  element  .  html  (  )  )  ;  }  [ATTENTION]  return  sb  .  StringBuilder  (  )    ;  }    [METHOD]  html  [TYPE]  String  [PARAMETER]  [CLASS]  Elements    [TYPE]  List  contents  elements  [TYPE]  boolean  false  true  [TYPE]  StringBuilder  sb  [TYPE]  Element  element  
[REPLACE]  StringBuilder  sb  =  new  StringBuilder  (  )  ;	[BUGGY]  for  (  Element  element  :  contents  )  {  element  .  addClass  (  className  )  ;  [CE]  illegal  start  of  expression  [CONTEXT]  public  String  outerHtml  (  )  {  [ATTENTION]  for  (  Element  element  :  contents  )  {  element  .  addClass  (  className  )    ;  for  (  Element  element  :  contents  )  {  if  (  sb  .  length  (  )  !  =  0  )  sb  .  append  (   "\n "  )  ;  sb  .  append  (  element  .  outerHtml  (  )  )  ;  }  return  sb  .  toString  (  )  ;  }    [METHOD]  outerHtml  [TYPE]  String  [PARAMETER]  [CLASS]  Elements    [TYPE]  List  contents  elements  [TYPE]  boolean  false  true  [TYPE]  StringBuilder  sb  [TYPE]  Element  element  
[REPLACE]  if  (  sb  .  length  (  )  !=  0  )  sb  .  append  (   "\n "  )  ;	[BUGGY]  if  (  sb  .  length  (  )  %  2  !  =  0  )  sb  .  append  (   "\n "  )  ;  [NO-ERROR]  [CONTEXT]  public  String  outerHtml  (  )  {  StringBuilder  sb  =  new  StringBuilder  (  )  ;  for  (  Element  element  :  contents  )  {  [ATTENTION]  if  (  sb  .  length  (  )  %2  !  =  0  )  sb  .  append  (   "\n "  )    ;    sb  .  append  (  element  .  outerHtml  (  )  )  ;  }  return  sb  .  toString  (  )  ;  }    [METHOD]  outerHtml  [TYPE]  String  [PARAMETER]  [CLASS]  Elements    [TYPE]  List  contents  elements  [TYPE]  boolean  false  true  [TYPE]  StringBuilder  sb  [TYPE]  Element  element  
[ADD]  if  (  sb  .  length  (  )  !=  0  )  sb  .  append  (   "\n "  )  ;  sb  .  append  (  element  .  outerHtml  (  )  )  ;  }	[BUGGY]  sb  .  append  (   "\n "  )  ;  sb  .  append  (  element  .  outerHtml  (  )  )  ;  [CE]  illegal  start  of  expression  [CONTEXT]  public  String  outerHtml  (  )  {  StringBuilder  sb  =  new  StringBuilder  (  )  ;  for  (  Element  element  :  contents  )  {  [ATTENTION]  sb  .  append  (   "\n "  )    ;  sb  .  append  (  element  .  outerHtml  (  )  )    ;      return  sb  .  toString  (  )  ;  }    [METHOD]  outerHtml  [TYPE]  String  [PARAMETER]  [CLASS]  Elements    [TYPE]  List  contents  elements  [TYPE]  boolean  false  true  [TYPE]  StringBuilder  sb  [TYPE]  Element  element  
[REPLACE]  sb  .  append  (   "\n "  )  ;	[BUGGY]  sb  .  StringBuilder  (  )    ;  [CE]  cannot  find  symbol  [CONTEXT]  public  String  outerHtml  (  )  {  StringBuilder  sb  =  new  StringBuilder  (  )  ;  for  (  Element  element  :  contents  )  {  if  (  sb  .  length  (  )  !  =  0  )  [ATTENTION]  sb  .  StringBuilder  (  )  ;  sb  .  append  (  element  .  outerHtml  (  )  )  ;  }  return  sb  .  toString  (  )  ;  }    [METHOD]  outerHtml  [TYPE]  String  [PARAMETER]  [CLASS]  Elements    [TYPE]  List  contents  elements  [TYPE]  boolean  false  true  [TYPE]  StringBuilder  sb  [TYPE]  Element  element  
[REPLACE]  for  (  Element  element  :  contents  )  {	[BUGGY]  for  (  Element  element  :  contents  )  {  element  .  addClass  (  className  )  ;  [CE]  cannot  find  symbol  className  [CONTEXT]  public  String  outerHtml  (  )  {  StringBuilder  sb  =  new  StringBuilder  (  )  ;  [ATTENTION]  for  (  Element  element  :  contents  )  {  element  .  addClass  (  className  )    ;  if  (  sb  .  length  (  )  !  =  0  )  sb  .  append  (   "\n "  )  ;  sb  .  append  (  element  .  outerHtml  (  )  )  ;  }  return  sb  .  toString  (  )  ;  }    [METHOD]  outerHtml  [TYPE]  String  [PARAMETER]  [CLASS]  Elements    [TYPE]  List  contents  elements  [TYPE]  boolean  false  true  [TYPE]  StringBuilder  sb  [TYPE]  Element  element  
[REPLACE]  return  sb  .  toString  (  )  ;	[BUGGY]  return  sb  .  StringBuilder  (  )  ;  [CE]  cannot  find  symbol  [CONTEXT]  public  String  outerHtml  (  )  {  StringBuilder  sb  =  new  StringBuilder  (  )  ;  for  (  Element  element  :  contents  )  {  if  (  sb  .  length  (  )  !  =  0  )  sb  .  append  (   "\n "  )  ;  sb  .  append  (  element  .  outerHtml  (  )  )  ;  }  [ATTENTION]  return  sb  .  StringBuilder  (  )    ;  }    [METHOD]  outerHtml  [TYPE]  String  [PARAMETER]  [CLASS]  Elements    [TYPE]  List  contents  elements  [TYPE]  boolean  false  true  [TYPE]  StringBuilder  sb  [TYPE]  Element  element  
[REPLACE]  for  (  Element  element  :  contents  )  {	[BUGGY]  for  (  Element  element  :  contents  )  {  element  .  addClass  (  className  )  ;  [CE]  cannot  find  symbol  className  [CONTEXT]  public  Elements  html  (  String  html  )  {  [ATTENTION]  for  (  Element  element  :  contents  )  {  element  .  addClass  (  className  )    ;  element  .  html  (  html  )  ;  }  return  this  ;  }    [METHOD]  html  [TYPE]  Elements  [PARAMETER]  String  html  [CLASS]  Elements    [TYPE]  List  contents  elements  [TYPE]  String  html  [TYPE]  boolean  false  true  [TYPE]  Element  element  
[REPLACE]  return  this;	[BUGGY]  return  null  ;  [NO-ERROR]  [CONTEXT]  public  Elements  html  (  String  html  )  {  for  (  Element  element  :  contents  )  {  element  .  html  (  html  )  ;  }  [ATTENTION]  return  null  ;  }    [METHOD]  html  [TYPE]  Elements  [PARAMETER]  String  html  [CLASS]  Elements    [TYPE]  List  contents  elements  [TYPE]  String  html  [TYPE]  boolean  false  true  [TYPE]  Element  element  
[REPLACE]  for  (  Element  element  :  contents  )  {	[BUGGY]  for  (  Element  element  :  contents  )  {  element  .  addClass  (  className  )  ;  [CE]  cannot  find  symbol  className  [CONTEXT]  public  Elements  prepend  (  String  html  )  {  [ATTENTION]  for  (  Element  element  :  contents  )  {  element  .  addClass  (  className  )    ;  element  .  prepend  (  html  )  ;  }  return  this  ;  }    [METHOD]  prepend  [TYPE]  Elements  [PARAMETER]  String  html  [CLASS]  Elements    [TYPE]  List  contents  elements  [TYPE]  String  html  [TYPE]  boolean  false  true  [TYPE]  Element  element  
[REPLACE]  return  this;	[BUGGY]  return  null  ;  [FE]  null  assertEquals( "<p><b>Bold</b>Two<i>Ital</i></p> "  ,  TextUtil.stripNewlines(ps.get(1).outerHtml()))  ;  assertEquals( "<p><span>Gone</span></p> "  ,  TextUtil.stripNewlines(ps.get(1).outerHtml()))  ;  [CONTEXT]  public  Elements  prepend  (  String  html  )  {  for  (  Element  element  :  contents  )  {  element  .  prepend  (  html  )  ;  }  [ATTENTION]  return  null  ;  }    [METHOD]  prepend  [TYPE]  Elements  [PARAMETER]  String  html  [CLASS]  Elements    [TYPE]  List  contents  elements  [TYPE]  String  html  [TYPE]  boolean  false  true  [TYPE]  Element  element  
[REPLACE]  for  (  Element  element  :  contents  )  {	[BUGGY]  for  (  Element  element  :  contents  )  {  element  .  addClass  (  className  )  ;  [CE]  cannot  find  symbol  className  [CONTEXT]  public  Elements  append  (  String  html  )  {  [ATTENTION]  for  (  Element  element  :  contents  )  {  element  .  addClass  (  className  )    ;  element  .  append  (  html  )  ;  }  return  this  ;  }    [METHOD]  append  [TYPE]  Elements  [PARAMETER]  String  html  [CLASS]  Elements    [TYPE]  List  contents  elements  [TYPE]  String  html  [TYPE]  boolean  false  true  [TYPE]  Element  element  
[ADD]  for  (  Element  element  :  contents  )  {  element  .  append  (  html  )  ;  }	[BUGGY]  [FE]  AssertionFailedError    expected:<<p><b>Bold</b>Two<[i>Ital</i><]/p>>  but  was:<<p><b>Bold</b>Two<[]/p>>  assertEquals( "<p><b>Bold</b>Two<i>Ital</i></p> "  ,  TextUtil.stripNewlines(ps.get(1).outerHtml()))  ;  assertEquals( "<p><span>Gone</span></p> "  ,  TextUtil.stripNewlines(ps.get(1).outerHtml()))  ;  [CONTEXT]  public  Elements  append  (  String  html  )  {  [ATTENTION]    return  this  ;  }    [METHOD]  append  [TYPE]  Elements  [PARAMETER]  String  html  [CLASS]  Elements    [TYPE]  List  contents  elements  [TYPE]  String  html  [TYPE]  boolean  false  true  [TYPE]  Element  element  
[REPLACE]  return  this;	[BUGGY]  return  null  ;  [NO-ERROR]  [CONTEXT]  public  Elements  append  (  String  html  )  {  for  (  Element  element  :  contents  )  {  element  .  append  (  html  )  ;  }  [ATTENTION]  return  null  ;  }    [METHOD]  append  [TYPE]  Elements  [PARAMETER]  String  html  [CLASS]  Elements    [TYPE]  List  contents  elements  [TYPE]  String  html  [TYPE]  boolean  false  true  [TYPE]  Element  element  
[REPLACE]  Validate  .  notEmpty  (  html  )  ;	[BUGGY]  html    ;  [CE]  not  a  statement  [CONTEXT]  public  Elements  wrap  (  String  html  )  {  [ATTENTION]  html  ;  for  (  Element  element  :  contents  )  {  element  .  wrap  (  html  )  ;  }  return  this  ;  }    [METHOD]  wrap  [TYPE]  Elements  [PARAMETER]  String  html  [CLASS]  Elements    [TYPE]  List  contents  elements  [TYPE]  String  html  [TYPE]  boolean  false  true  [TYPE]  Element  element  
[ADD]  Validate  .  notEmpty  (  html  )  ;	[BUGGY]  [NO-ERROR]  [CONTEXT]  public  Elements  wrap  (  String  html  )  {  [ATTENTION]  for  (  Element  element  :  contents  )  {  element  .  wrap  (  html  )  ;  }  return  this  ;  }    [METHOD]  wrap  [TYPE]  Elements  [PARAMETER]  String  html  [CLASS]  Elements    [TYPE]  List  contents  elements  [TYPE]  String  html  [TYPE]  boolean  false  true  [TYPE]  Element  element  
[REPLACE]  for  (  Element  element  :  contents  )  {	[BUGGY]  for  (  Element  element  :  contents  )  {  element  .  addClass  (  className  )  ;  [CE]  cannot  find  symbol  className  [CONTEXT]  public  Elements  wrap  (  String  html  )  {  Validate  .  notEmpty  (  html  )  ;  [ATTENTION]  for  (  Element  element  :  contents  )  {  element  .  addClass  (  className  )    ;  element  .  wrap  (  html  )  ;  }  return  this  ;  }    [METHOD]  wrap  [TYPE]  Elements  [PARAMETER]  String  html  [CLASS]  Elements    [TYPE]  List  contents  elements  [TYPE]  String  html  [TYPE]  boolean  false  true  [TYPE]  Element  element  
[REPLACE]  return  this;	[BUGGY]  return  null  ;  [NO-ERROR]  [CONTEXT]  public  Elements  wrap  (  String  html  )  {  Validate  .  notEmpty  (  html  )  ;  for  (  Element  element  :  contents  )  {  element  .  wrap  (  html  )  ;  }  [ATTENTION]  return  null  ;  }    [METHOD]  wrap  [TYPE]  Elements  [PARAMETER]  String  html  [CLASS]  Elements    [TYPE]  List  contents  elements  [TYPE]  String  html  [TYPE]  boolean  false  true  [TYPE]  Element  element  
[REPLACE]  return  Selector  .  select  (  query,  this  )  ;	[BUGGY]  return  Selector  .  select  (  query  )    ;  [CE]  no  suitable  method  found  for  select(String)  [CONTEXT]  public  Elements  select  (  String  query  )  {  [ATTENTION]  return  Selector  .  select  (  query  )  ;  }    [METHOD]  select  [TYPE]  Elements  [PARAMETER]  String  query  [CLASS]  Elements    [TYPE]  List  contents  elements  [TYPE]  String  query  [TYPE]  boolean  false  true  
[REPLACE]  if  (  contents  .  size  (  )  >  index  )  return  new  Elements  (  get  (  index  )  )  ;	[BUGGY]  if  (  contents  .  size  (  )  %  0  .  5  >  index  )  return  new  Elements  (  get  (  index  )  )  ;  [FE]  AssertionFailedError    expected:<[there]>  but  was:<[]>  assertEquals( "there "  ,  doc.select( "p ").eq(1).text())  ;  [CONTEXT]  public  Elements  eq  (  int  index  )  {  [ATTENTION]  if  (  contents  .  size  (  )  %0  .  5>  index  )  return  new  Elements  (  get  (  index  )  )    ;    else  return  new  Elements  (  )  ;  }    [METHOD]  eq  [TYPE]  Elements  [PARAMETER]  int  index  [CLASS]  Elements    [TYPE]  List  contents  elements  [TYPE]  int  index  [TYPE]  boolean  false  true  
[REPLACE]  return  new  Elements  (  )  ;	[BUGGY]  return  new  Elements  (  get  (  index  )  )    ;  [NO-ERROR]  [CONTEXT]  public  Elements  eq  (  int  index  )  {  if  (  contents  .  size  (  )  >  index  )  return  new  Elements  (  get  (  index  )  )  ;  else  [ATTENTION]  returnnew  Elements  (  get  (  index  )  )  ;  }    [METHOD]  eq  [TYPE]  Elements  [PARAMETER]  int  index  [CLASS]  Elements    [TYPE]  List  contents  elements  [TYPE]  int  index  [TYPE]  boolean  false  true  
[REPLACE]  return  new  Elements  (  get  (  index  )  )  ;	[BUGGY]  return  new  Elements  (  )    )  ;  [CE]  '  ;  '  expected  [CONTEXT]  public  Elements  eq  (  int  index  )  {  if  (  contents  .  size  (  )  >  index  )  [ATTENTION]  returnnew  Elements  (  )    )    ;  else  return  new  Elements  (  )  ;  }    [METHOD]  eq  [TYPE]  Elements  [PARAMETER]  int  index  [CLASS]  Elements    [TYPE]  List  contents  elements  [TYPE]  int  index  [TYPE]  boolean  false  true  
[REPLACE]  Elements  children  =  this  .  select  (  query  )  ;	[BUGGY]  Elements  children  =  this  .  select  (  query  ,  children  )    ;  [CE]  method  select  in  class  Elements  cannot  be  applied  to  given  types  ;  [CONTEXT]  public  boolean  is  (  String  query  )  {  [ATTENTION]  Elements  children  =  this  .  select  (  query  ,  children  )  ;  return  !children  .  isEmpty  (  )  ;  }    [METHOD]  is  [TYPE]  boolean  [PARAMETER]  String  query  [CLASS]  Elements    [TYPE]  List  contents  elements  [TYPE]  String  query  [TYPE]  boolean  false  true  [TYPE]  Elements  children  
[REPLACE]  return  !children  .  isEmpty  (  )  ;	[BUGGY]  return  !children  .  set  (  null  ,  null  )    ;  [CE]  method  set  in  class  Elements  cannot  be  applied  to  given  types  ;  [CONTEXT]  public  boolean  is  (  String  query  )  {  Elements  children  =  this  .  select  (  query  )  ;  [ATTENTION]  return  !children  .  set  (  null  ,  null  )  ;  }    [METHOD]  is  [TYPE]  boolean  [PARAMETER]  String  query  [CLASS]  Elements    [TYPE]  List  contents  elements  [TYPE]  String  query  [TYPE]  boolean  false  true  [TYPE]  Elements  children  
[REPLACE]  return  !contents  .  isEmpty  (  )  ?  contents  .  get  (  0  )  :  null;	[BUGGY]  return  !contents  .  isEmpty  (  )  ?  contents  .  get  (  2  )  :  null  ;  [FE]  IndexOutOfBoundsException  Index:  2  ,  Size:  1  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  Element  first  (  )  {  [ATTENTION]  return  !contents  .  isEmpty  (  )  ?  contents  .  get  (  2  )  :  null  ;  }    [METHOD]  first  [TYPE]  Element  [PARAMETER]  [CLASS]  Elements    [TYPE]  List  contents  elements  [TYPE]  boolean  false  true  
[REPLACE]  return  !contents  .  isEmpty  (  )  ?  contents  .  get  (  contents  .  size  (  )  -  1  )  :  null;	[BUGGY]  return  !contents  .  isEmpty  (  )  ?  contents  .  clear  (  contents  .  size  (  )  -  1  )  :  null  ;  [CE]  no  suitable  method  found  for  clear(int)  [CONTEXT]  public  Element  last  (  )  {  [ATTENTION]  return  !contents  .  isEmpty  (  )  ?  contents  .  clear  (  contents  .  size  (  )  -  1  )  :  null  ;  }    [METHOD]  last  [TYPE]  Element  [PARAMETER]  [CLASS]  Elements    [TYPE]  List  contents  elements  [TYPE]  boolean  false  true  
[REPLACE]  public  int  size  (  )  {return  contents  .  size  (  )  ;}	[BUGGY]  public  int  .  get  (  )  {return  contents  .  size  (  )  ;  }[CE]  <identifier>  expected  [CONTEXT]    [METHOD]  size  [TYPE]  int  [PARAMETER]  [CLASS]  Elements    [TYPE]  List  contents  elements  [TYPE]  boolean  false  true  
[REPLACE]  public  boolean  isEmpty  (  )  {return  contents  .  isEmpty  (  )  ;}	[BUGGY]  public  boolean  .  iterator  (  )  {return  contents  .  isEmpty  (  )  ;  }[CE]  <identifier>  expected  [CONTEXT]    [METHOD]  isEmpty  [TYPE]  boolean  [PARAMETER]  [CLASS]  Elements    [TYPE]  List  contents  elements  [TYPE]  boolean  false  true  
[REPLACE]  public  boolean  contains  (  Object  o  )  {return  contents  .  contains  (  o  )  ;}	[BUGGY]  public  boolean  .  equals  (  Object  o  )  {return  contents  .  contains  (  o  )  ;  }[CE]  <identifier>  expected  [CONTEXT]    [METHOD]  contains  [TYPE]  boolean  [PARAMETER]  Object  o  [CLASS]  Elements    [TYPE]  List  contents  elements  [TYPE]  Object  o  [TYPE]  boolean  false  true  
[REPLACE]  public  Iterator<Element>  iterator  (  )  {return  contents  .  iterator  (  )  ;}	[BUGGY]  public  Iterator<Element>  .  listIterator  (  )  {return  contents  .  iterator  (  )  ;  }[CE]  <identifier>  expected  [CONTEXT]    [METHOD]  iterator  [TYPE]  Iterator  [PARAMETER]  [CLASS]  Elements    [TYPE]  List  contents  elements  [TYPE]  boolean  false  true  
[REPLACE]  public  Object[]  toArray  (  )  {return  contents  .  toArray  (  )  ;}	[BUGGY]  public  Object[]  .  isEmpty  (  )  {return  contents  .  toArray  (  )  ;  }[CE]  <identifier>  expected  [CONTEXT]    [METHOD]  toArray  [TYPE]  Object[]  [PARAMETER]  [CLASS]  Elements    [TYPE]  List  contents  elements  [TYPE]  boolean  false  true  
[REPLACE]  public  <T>  T[]  toArray  (  T[]  a  )  {return  contents  .  toArray  (  a  )  ;}	[BUGGY]  public  Object[]  toArray  (  )  {return  contents  .  toArray  (  )  ;  }[CE]  method  toArray()  is  already  defined  in  class  Elements  [CONTEXT]    [METHOD]  toArray  [TYPE]  <T>  [PARAMETER]  T[]  a  [CLASS]  Elements    [TYPE]  List  contents  elements  [TYPE]  T[]  a  [TYPE]  boolean  false  true  
[REPLACE]  public  boolean  add  (  Element  element  )  {return  contents  .  add  (  element  )  ;}	[BUGGY]  public  boolean  .  remove  (  Element  element  )  {return  contents  .  add  (  element  )  ;  }[CE]  <identifier>  expected  [CONTEXT]    [METHOD]  add  [TYPE]  boolean  [PARAMETER]  Element  element  [CLASS]  Elements    [TYPE]  List  contents  elements  [TYPE]  Element  element  [TYPE]  boolean  false  true  
[REPLACE]  public  boolean  remove  (  Object  o  )  {return  contents  .  remove  (  o  )  ;}	[BUGGY]  public  boolean  .  indexOf  (  Object  o  )  {return  contents  .  remove  (  o  )  ;  }[CE]  <identifier>  expected  [CONTEXT]    [METHOD]  remove  [TYPE]  boolean  [PARAMETER]  Object  o  [CLASS]  Elements    [TYPE]  List  contents  elements  [TYPE]  Object  o  [TYPE]  boolean  false  true  
[REPLACE]  public  boolean  containsAll  (  Collection<?>  c  )  {return  contents  .  containsAll  (  c  )  ;}	[BUGGY]  public  boolean  containsAll  (  Collection<?>  c  )  {return  contents  .  contains  (  null  )    ;  }[NO-ERROR]  [CONTEXT]    [METHOD]  containsAll  [TYPE]  boolean  [PARAMETER]  Collection<?>  c  [CLASS]  Elements    [TYPE]  Collection  c  [TYPE]  List  contents  elements  [TYPE]  boolean  false  true  
[REPLACE]  public  boolean  addAll  (  Collection<?  extends  Element>  c  )  {return  contents  .  addAll  (  c  )  ;}	[BUGGY]  public  boolean  .  retainAll  (  Collection<?  extends  Element>  c  )  {return  contents  .  addAll  (  c  )  ;  }[CE]  <identifier>  expected  [CONTEXT]    [METHOD]  addAll  [TYPE]  boolean  [PARAMETER]  Element>  c  [CLASS]  Elements    [TYPE]  Collection  c  [TYPE]  List  contents  elements  [TYPE]  boolean  false  true  
[REPLACE]  public  boolean  addAll  (  int  index,  Collection<?  extends  Element>  c  )  {return  contents  .  addAll  (  index,  c  )  ;}	[BUGGY]  public  boolean  .  add  (  int  index  ,  Collection<?  extends  Element>  c  )  {return  contents  .  addAll  (  index  ,  c  )  ;  }[CE]  <identifier>  expected  [CONTEXT]    [METHOD]  addAll  [TYPE]  boolean  [PARAMETER]  int  index  Element>  c  [CLASS]  Elements    [TYPE]  Collection  c  [TYPE]  List  contents  elements  [TYPE]  boolean  false  true  [TYPE]  int  index  
[REPLACE]  public  boolean  removeAll  (  Collection<?>  c  )  {return  contents  .  removeAll  (  c  )  ;}	[BUGGY]  public  boolean  .  retainAll  (  Collection<?>  1  )  {return  contents  .  removeAll  (  c  )  ;  }[CE]  <identifier>  expected  [CONTEXT]    [METHOD]  removeAll  [TYPE]  boolean  [PARAMETER]  Collection<?>  c  [CLASS]  Elements    [TYPE]  Collection  c  [TYPE]  List  contents  elements  [TYPE]  boolean  false  true  
[REPLACE]  public  boolean  retainAll  (  Collection<?>  c  )  {return  contents  .  retainAll  (  c  )  ;}	[BUGGY]  public  boolean  containsAll  (  Collection<?>  c  )  {return  contents  .  containsAll  (  c  )  ;  }[CE]  method  containsAll(Collection<?>)  is  already  defined  in  class  Elements  [CONTEXT]    [METHOD]  retainAll  [TYPE]  boolean  [PARAMETER]  Collection<?>  c  [CLASS]  Elements    [TYPE]  Collection  c  [TYPE]  List  contents  elements  [TYPE]  boolean  false  true  
[REPLACE]  public  void  clear  (  )  {contents  .  clear  (  )  ;}	[BUGGY]  public  void  .  get  (  )  {contents  .  clear  (  )  ;  }[CE]  <identifier>  expected  [CONTEXT]    [METHOD]  clear  [TYPE]  void  [PARAMETER]  [CLASS]  Elements    [TYPE]  List  contents  elements  [TYPE]  boolean  false  true  
[REPLACE]  public  boolean  equals  (  Object  o  )  {return  contents  .  equals  (  o  )  ;}	[BUGGY]  public  boolean  .  contains  (  Object  o  )  {return  contents  .  equals  (  o  )  ;  }[CE]  <identifier>  expected  [CONTEXT]    [METHOD]  equals  [TYPE]  boolean  [PARAMETER]  Object  o  [CLASS]  Elements    [TYPE]  List  contents  elements  [TYPE]  Object  o  [TYPE]  boolean  false  true  
[REPLACE]  public  int  hashCode  (  )  {return  contents  .  hashCode  (  )  ;}	[BUGGY]  public  int  .  size  (  )  {return  contents  .  hashCode  (  )  ;  }[CE]  <identifier>  expected  [CONTEXT]    [METHOD]  hashCode  [TYPE]  int  [PARAMETER]  [CLASS]  Elements    [TYPE]  List  contents  elements  [TYPE]  boolean  false  true  
[REPLACE]  public  Element  get  (  int  index  )  {return  contents  .  get  (  index  )  ;}	[BUGGY]  public  Element  remove  (  int  index  )  {return  contents  .  remove  (  index  )  ;  }[CE]  method  remove(int)  is  already  defined  in  class  Elements  [CONTEXT]    [METHOD]  get  [TYPE]  Element  [PARAMETER]  int  index  [CLASS]  Elements    [TYPE]  List  contents  elements  [TYPE]  int  index  [TYPE]  boolean  false  true  
[REPLACE]  public  Element  set  (  int  index,  Element  element  )  {return  contents  .  set  (  index,  element  )  ;}	[BUGGY]  public  Element  .  add  (  int  index  ,  Element  element  )  {return  contents  .  set  (  index  ,  element  )  ;  }[CE]  <identifier>  expected  [CONTEXT]    [METHOD]  set  [TYPE]  Element  [PARAMETER]  int  index  Element  element  [CLASS]  Elements    [TYPE]  List  contents  elements  [TYPE]  boolean  false  true  [TYPE]  int  index  [TYPE]  Element  element  
[REPLACE]  public  void  add  (  int  index,  Element  element  )  {contents  .  add  (  index,  element  )  ;}	[BUGGY]  public  void  .  set  (  int  index  ,  Element  element  )  {contents  .  add  (  index  ,  element  )  ;  }[CE]  <identifier>  expected  [CONTEXT]    [METHOD]  add  [TYPE]  void  [PARAMETER]  int  index  Element  element  [CLASS]  Elements    [TYPE]  List  contents  elements  [TYPE]  boolean  false  true  [TYPE]  int  index  [TYPE]  Element  element  
[REPLACE]  public  Element  remove  (  int  index  )  {return  contents  .  remove  (  index  )  ;}	[BUGGY]  public  Element  remove  (  int  index  )  {return  contents  .  removeAll  (  null  )    ;  }[CE]  incompatible  types  [CONTEXT]    [METHOD]  remove  [TYPE]  Element  [PARAMETER]  int  index  [CLASS]  Elements    [TYPE]  List  contents  elements  [TYPE]  int  index  [TYPE]  boolean  false  true  
[REPLACE]  public  int  indexOf  (  Object  o  )  {return  contents  .  indexOf  (  o  )  ;}	[BUGGY]  public  int  .  lastIndexOf  (  Object  o  )  {return  contents  .  indexOf  (  o  )  ;  }[CE]  <identifier>  expected  [CONTEXT]    [METHOD]  indexOf  [TYPE]  int  [PARAMETER]  Object  o  [CLASS]  Elements    [TYPE]  List  contents  elements  [TYPE]  Object  o  [TYPE]  boolean  false  true  
[REPLACE]  public  int  lastIndexOf  (  Object  o  )  {return  contents  .  lastIndexOf  (  o  )  ;}	[BUGGY]  public  int  .  indexOf  (  Object  o  )  {return  contents  .  lastIndexOf  (  o  )  ;  }[CE]  <identifier>  expected  [CONTEXT]    [METHOD]  lastIndexOf  [TYPE]  int  [PARAMETER]  Object  o  [CLASS]  Elements    [TYPE]  List  contents  elements  [TYPE]  Object  o  [TYPE]  boolean  false  true  
[REPLACE]  public  ListIterator<Element>  listIterator  (  )  {return  contents  .  listIterator  (  )  ;}	[BUGGY]  public  ListIterator<Element>  .  iterator  (  )  {return  contents  .  listIterator  (  )  ;  }[CE]  <identifier>  expected  [CONTEXT]    [METHOD]  listIterator  [TYPE]  ListIterator  [PARAMETER]  [CLASS]  Elements    [TYPE]  List  contents  elements  [TYPE]  boolean  false  true  
[REPLACE]  public  ListIterator<Element>  listIterator  (  int  index  )  {return  contents  .  listIterator  (  index  )  ;}	[BUGGY]  public  ListIterator<Element>  listIterator  (  int  index  )  {return  contents  .  iterator  (  )    ;  }[CE]  incompatible  types  [CONTEXT]    [METHOD]  listIterator  [TYPE]  ListIterator  [PARAMETER]  int  index  [CLASS]  Elements    [TYPE]  List  contents  elements  [TYPE]  int  index  [TYPE]  boolean  false  true  
[REPLACE]  public  List<Element>  subList  (  int  fromIndex,  int  toIndex  )  {return  contents  .  subList  (  fromIndex,  toIndex  )  ;}	[BUGGY]  public  List<Element>  .  addAll  (  int  fromIndex  ,  int  toIndex  )  {return  contents  .  subList  (  fromIndex  ,  toIndex  )  ;  }[CE]  <identifier>  expected  [CONTEXT]    [METHOD]  subList  [TYPE]  List  [PARAMETER]  int  fromIndex  int  toIndex  [CLASS]  Elements    [TYPE]  List  contents  elements  [TYPE]  int  fromIndex  toIndex  [TYPE]  boolean  false  true  
[REPLACE]  private  static  final  Map<String,  Tag>  tags  =  new  HashMap<String,  Tag>  (  )  ;	[BUGGY]  private  static  final  Map<String  ,  Tag>  tags    =  null  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]      [CLASS]  Tag  
[REPLACE]  private  static  final  Tag  defaultAncestor;	[BUGGY]  private  static  Tag  defaultAncestor  ;  [NO-ERROR]  [CONTEXT]      [CLASS]  Tag  
[REPLACE]  private  String  tagName;	[BUGGY]  private  byte  tagName  ;  [CE]  method  put  in  interface  Map<K  ,  V>  cannot  be  applied  to  given  types  ;  [CONTEXT]      [CLASS]  Tag  
[REPLACE]  private  boolean  isBlock  =  true;	[BUGGY]  private  boolean  isBlock    =  null  ;  [CE]  incompatible  types  [CONTEXT]      [CLASS]  Tag  
[REPLACE]  private  boolean  canContainBlock  =  true;	[BUGGY]  private  boolean  canContainBlock    =  null  ;  [CE]  incompatible  types  [CONTEXT]      [CLASS]  Tag  
[REPLACE]  private  boolean  canContainInline  =  true;	[BUGGY]  private  boolean  canContainInline    =  null  ;  [CE]  incompatible  types  [CONTEXT]      [CLASS]  Tag  
[REPLACE]  private  boolean  optionalClosing  =  false;	[BUGGY]  private  boolean  optionalClosing  ;  [NO-ERROR]  [CONTEXT]      [CLASS]  Tag  
[REPLACE]  private  boolean  empty  =  false;	[BUGGY]  private  boolean  empty    =  null  ;  [CE]  incompatible  types  [CONTEXT]      [CLASS]  Tag  
[REPLACE]  private  boolean  preserveWhitespace  =  false;	[BUGGY]  private  boolean  preserveWhitespace  ;  [NO-ERROR]  [CONTEXT]      [CLASS]  Tag  
[REPLACE]  this  .  tagName  =  tagName  .  toLowerCase  (  )  ;	[BUGGY]  this  .  tagName  =    null  .  toLowerCase  (  )  ;  [CE]  <null>  cannot  be  dereferenced  [CONTEXT]  private  Tag  (  String  tagName  )  {  [ATTENTION]  this  .  tagName  =  null  .  toLowerCase  (  )    ;  }    [METHOD]  <init>  [TYPE]  String)  [PARAMETER]  String  tagName  [CLASS]  Tag    [TYPE]  List  ancestors  [TYPE]  boolean  canContainBlock  canContainInline  empty  false  isBlock  optionalClosing  preserveWhitespace  true  [TYPE]  Tag  defaultAncestor  [TYPE]  String  tagName  [TYPE]  Map  tags  
[REPLACE]  return  tagName;	[BUGGY]  return  tag  ;  [CE]  cannot  find  symbol  tag  [CONTEXT]  public  String  getName  (  )  {  [ATTENTION]  return  tag  ;  }    [METHOD]  getName  [TYPE]  String  [PARAMETER]  [CLASS]  Tag    [TYPE]  List  ancestors  [TYPE]  boolean  canContainBlock  canContainInline  empty  false  isBlock  optionalClosing  preserveWhitespace  true  [TYPE]  Tag  defaultAncestor  [TYPE]  String  tagName  [TYPE]  Map  tags  
[REPLACE]  Validate  .  notNull  (  tagName  )  ;	[BUGGY]  Validate  .  notEmpty  (  tagName  )    ;  [NO-ERROR]  [CONTEXT]  public  static  Tag  valueOf  (  String  tagName  )  {  [ATTENTION]  Validate  .  notEmpty  (  tagName  )  ;  tagName  =  tagName  .  trim  (  )  .  toLowerCase  (  )  ;  Validate  .  notEmpty  (  tagName  )  ;    synchronized  (  tags  )  {  Tag  tag  =  tags  .  get  (  tagName  )  ;  if  (  tag  =  =  null  )  {    tag  =  new  Tag  (  tagName  )  ;  tag  .  setAncestor  (  defaultAncestor  .  tagName  )  ;  tag  .  isBlock  =  false  ;  tag  .  canContainBlock  =  true  ;  }  return  tag  ;  }  }    [METHOD]  valueOf  [TYPE]  Tag  [PARAMETER]  String  tagName  [CLASS]  Tag    [TYPE]  List  ancestors  [TYPE]  boolean  canContainBlock  canContainInline  empty  false  isBlock  optionalClosing  preserveWhitespace  true  [TYPE]  Tag  defaultAncestor  tag  [TYPE]  String  tagName  [TYPE]  Map  tags  
[REPLACE]  tagName  =  tagName  .  trim  (  )    .  toLowerCase  (  )  ;	[BUGGY]  tagName  =    null  .  trim  (  )  .  toLowerCase  (  )  ;  [CE]  <null>  cannot  be  dereferenced  [CONTEXT]  public  static  Tag  valueOf  (  String  tagName  )  {  Validate  .  notNull  (  tagName  )  ;  [ATTENTION]  tagName  =  null  .  trim  (  )    .  toLowerCase  (  )    ;  Validate  .  notEmpty  (  tagName  )  ;    synchronized  (  tags  )  {  Tag  tag  =  tags  .  get  (  tagName  )  ;  if  (  tag  =  =  null  )  {    tag  =  new  Tag  (  tagName  )  ;  tag  .  setAncestor  (  defaultAncestor  .  tagName  )  ;  tag  .  isBlock  =  false  ;  tag  .  canContainBlock  =  true  ;  }  return  tag  ;  }  }    [METHOD]  valueOf  [TYPE]  Tag  [PARAMETER]  String  tagName  [CLASS]  Tag    [TYPE]  List  ancestors  [TYPE]  boolean  canContainBlock  canContainInline  empty  false  isBlock  optionalClosing  preserveWhitespace  true  [TYPE]  Tag  defaultAncestor  tag  [TYPE]  String  tagName  [TYPE]  Map  tags  
[REPLACE]  Validate  .  notEmpty  (  tagName  )  ;	[BUGGY]  Validate  .  notNull  (  tagName  )    ;  [FE]  Expected  exception:  java.lang.IllegalArgumentException  [CONTEXT]  public  static  Tag  valueOf  (  String  tagName  )  {  Validate  .  notNull  (  tagName  )  ;  tagName  =  tagName  .  trim  (  )  .  toLowerCase  (  )  ;  [ATTENTION]  Validate  .  notNull  (  tagName  )  ;    synchronized  (  tags  )  {  Tag  tag  =  tags  .  get  (  tagName  )  ;  if  (  tag  =  =  null  )  {    tag  =  new  Tag  (  tagName  )  ;  tag  .  setAncestor  (  defaultAncestor  .  tagName  )  ;  tag  .  isBlock  =  false  ;  tag  .  canContainBlock  =  true  ;  }  return  tag  ;  }  }    [METHOD]  valueOf  [TYPE]  Tag  [PARAMETER]  String  tagName  [CLASS]  Tag    [TYPE]  List  ancestors  [TYPE]  boolean  canContainBlock  canContainInline  empty  false  isBlock  optionalClosing  preserveWhitespace  true  [TYPE]  Tag  defaultAncestor  tag  [TYPE]  String  tagName  [TYPE]  Map  tags  
[ADD]  Validate  .  notEmpty  (  tagName  )  ;	[BUGGY]  [FE]  Expected  exception:  java.lang.IllegalArgumentException  [CONTEXT]  public  static  Tag  valueOf  (  String  tagName  )  {  Validate  .  notNull  (  tagName  )  ;  tagName  =  tagName  .  trim  (  )  .  toLowerCase  (  )  ;  [ATTENTION]    synchronized  (  tags  )  {  Tag  tag  =  tags  .  get  (  tagName  )  ;  if  (  tag  =  =  null  )  {    tag  =  new  Tag  (  tagName  )  ;  tag  .  setAncestor  (  defaultAncestor  .  tagName  )  ;  tag  .  isBlock  =  false  ;  tag  .  canContainBlock  =  true  ;  }  return  tag  ;  }  }    [METHOD]  valueOf  [TYPE]  Tag  [PARAMETER]  String  tagName  [CLASS]  Tag    [TYPE]  List  ancestors  [TYPE]  boolean  canContainBlock  canContainInline  empty  false  isBlock  optionalClosing  preserveWhitespace  true  [TYPE]  Tag  defaultAncestor  tag  [TYPE]  String  tagName  [TYPE]  Map  tags  
[REPLACE]  if  (  tag  ==  null  )  {	[BUGGY]  if  (  tag  !  =  null  )  {[FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  static  Tag  valueOf  (  String  tagName  )  {  Validate  .  notNull  (  tagName  )  ;  tagName  =  tagName  .  trim  (  )  .  toLowerCase  (  )  ;  Validate  .  notEmpty  (  tagName  )  ;    synchronized  (  tags  )  {  Tag  tag  =  tags  .  get  (  tagName  )  ;  [ATTENTION]  if  (  tag  !  =  null  )  {    tag  =  new  Tag  (  tagName  )  ;  tag  .  setAncestor  (  defaultAncestor  .  tagName  )  ;  tag  .  isBlock  =  false  ;  tag  .  canContainBlock  =  true  ;  }  return  tag  ;  }  }    [METHOD]  valueOf  [TYPE]  Tag  [PARAMETER]  String  tagName  [CLASS]  Tag    [TYPE]  List  ancestors  [TYPE]  boolean  canContainBlock  canContainInline  empty  false  isBlock  optionalClosing  preserveWhitespace  true  [TYPE]  Tag  defaultAncestor  tag  [TYPE]  String  tagName  [TYPE]  Map  tags  
[REPLACE]  tag  =  new  Tag  (  tagName  )  ;	[BUGGY]  tag  =    new  Tag  (  null  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  static  Tag  valueOf  (  String  tagName  )  {  Validate  .  notNull  (  tagName  )  ;  tagName  =  tagName  .  trim  (  )  .  toLowerCase  (  )  ;  Validate  .  notEmpty  (  tagName  )  ;    synchronized  (  tags  )  {  Tag  tag  =  tags  .  get  (  tagName  )  ;  if  (  tag  =  =  null  )  {    [ATTENTION]  tag  =  new  Tag  (  null  )    ;  tag  .  setAncestor  (  defaultAncestor  .  tagName  )  ;  tag  .  isBlock  =  false  ;  tag  .  canContainBlock  =  true  ;  }  return  tag  ;  }  }    [METHOD]  valueOf  [TYPE]  Tag  [PARAMETER]  String  tagName  [CLASS]  Tag    [TYPE]  List  ancestors  [TYPE]  boolean  canContainBlock  canContainInline  empty  false  isBlock  optionalClosing  preserveWhitespace  true  [TYPE]  Tag  defaultAncestor  tag  [TYPE]  String  tagName  [TYPE]  Map  tags  
[REPLACE]  tag  .  isBlock  =  false;	[BUGGY]  tag  .  isBlock  =  true  ;  [FE]  AssertionFailedError    expected:<<p><[cust>Test</cust></p><p><cust><cust>Test</cust></cust></p]>>  but  was:<<p><[/p><cust>Test</cust><p></p><cust><cust>Test</cust></cust]>>  assertEquals(h  ,  TextUtil.stripNewlines(out))  ;  [CONTEXT]  public  static  Tag  valueOf  (  String  tagName  )  {  Validate  .  notNull  (  tagName  )  ;  tagName  =  tagName  .  trim  (  )  .  toLowerCase  (  )  ;  Validate  .  notEmpty  (  tagName  )  ;    synchronized  (  tags  )  {  Tag  tag  =  tags  .  get  (  tagName  )  ;  if  (  tag  =  =  null  )  {    tag  =  new  Tag  (  tagName  )  ;  tag  .  setAncestor  (  defaultAncestor  .  tagName  )  ;  [ATTENTION]  tag  .  isBlock  =  true  ;  tag  .  canContainBlock  =  true  ;  }  return  tag  ;  }  }    [METHOD]  valueOf  [TYPE]  Tag  [PARAMETER]  String  tagName  [CLASS]  Tag    [TYPE]  List  ancestors  [TYPE]  boolean  canContainBlock  canContainInline  empty  false  isBlock  optionalClosing  preserveWhitespace  true  [TYPE]  Tag  defaultAncestor  tag  [TYPE]  String  tagName  [TYPE]  Map  tags  
[REPLACE]  tag  .  canContainBlock  =  true;	[BUGGY]  tag  .  canContainBlock  =  false  ;  [FE]  The  validated  object  is  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  static  Tag  valueOf  (  String  tagName  )  {  Validate  .  notNull  (  tagName  )  ;  tagName  =  tagName  .  trim  (  )  .  toLowerCase  (  )  ;  Validate  .  notEmpty  (  tagName  )  ;    synchronized  (  tags  )  {  Tag  tag  =  tags  .  get  (  tagName  )  ;  if  (  tag  =  =  null  )  {    tag  =  new  Tag  (  tagName  )  ;  tag  .  setAncestor  (  defaultAncestor  .  tagName  )  ;  tag  .  isBlock  =  false  ;  [ATTENTION]  tag  .  canContainBlock  =  false  ;  }  return  tag  ;  }  }    [METHOD]  valueOf  [TYPE]  Tag  [PARAMETER]  String  tagName  [CLASS]  Tag    [TYPE]  List  ancestors  [TYPE]  boolean  canContainBlock  canContainInline  empty  false  isBlock  optionalClosing  preserveWhitespace  true  [TYPE]  Tag  defaultAncestor  tag  [TYPE]  String  tagName  [TYPE]  Map  tags  
[ADD]  tag  =  new  Tag  (  tagName  )  ;	[BUGGY]  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  static  Tag  valueOf  (  String  tagName  )  {  Validate  .  notNull  (  tagName  )  ;  tagName  =  tagName  .  trim  (  )  .  toLowerCase  (  )  ;  Validate  .  notEmpty  (  tagName  )  ;    synchronized  (  tags  )  {  Tag  tag  =  tags  .  get  (  tagName  )  ;  if  (  tag  =  =  null  )  {    [ATTENTION]  tag  .  setAncestor  (  defaultAncestor  .  tagName  )  ;  tag  .  isBlock  =  false  ;  tag  .  canContainBlock  =  true  ;  }  return  tag  ;  }  }    [METHOD]  valueOf  [TYPE]  Tag  [PARAMETER]  String  tagName  [CLASS]  Tag    [TYPE]  List  ancestors  [TYPE]  boolean  canContainBlock  canContainInline  empty  false  isBlock  optionalClosing  preserveWhitespace  true  [TYPE]  Tag  defaultAncestor  tag  [TYPE]  String  tagName  [TYPE]  Map  tags  
[ADD]  tag  .  isBlock  =  false;	[BUGGY]  [FE]  AssertionFailedError    expected:<<p><[cust>Test</cust></p><p><cust><cust>Test</cust></cust></p]>>  but  was:<<p><[/p><cust>Test</cust><p></p><cust><cust>Test</cust></cust]>>  assertEquals(h  ,  TextUtil.stripNewlines(out))  ;  [CONTEXT]  public  static  Tag  valueOf  (  String  tagName  )  {  Validate  .  notNull  (  tagName  )  ;  tagName  =  tagName  .  trim  (  )  .  toLowerCase  (  )  ;  Validate  .  notEmpty  (  tagName  )  ;    synchronized  (  tags  )  {  Tag  tag  =  tags  .  get  (  tagName  )  ;  if  (  tag  =  =  null  )  {    tag  =  new  Tag  (  tagName  )  ;  tag  .  setAncestor  (  defaultAncestor  .  tagName  )  ;  [ATTENTION]  tag  .  canContainBlock  =  true  ;  }  return  tag  ;  }  }    [METHOD]  valueOf  [TYPE]  Tag  [PARAMETER]  String  tagName  [CLASS]  Tag    [TYPE]  List  ancestors  [TYPE]  boolean  canContainBlock  canContainInline  empty  false  isBlock  optionalClosing  preserveWhitespace  true  [TYPE]  Tag  defaultAncestor  tag  [TYPE]  String  tagName  [TYPE]  Map  tags  
[REPLACE]  return  tag;	[BUGGY]  return  defaultAncestor  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  static  Tag  valueOf  (  String  tagName  )  {  Validate  .  notNull  (  tagName  )  ;  tagName  =  tagName  .  trim  (  )  .  toLowerCase  (  )  ;  Validate  .  notEmpty  (  tagName  )  ;    synchronized  (  tags  )  {  Tag  tag  =  tags  .  get  (  tagName  )  ;  if  (  tag  =  =  null  )  {    tag  =  new  Tag  (  tagName  )  ;  tag  .  setAncestor  (  defaultAncestor  .  tagName  )  ;  tag  .  isBlock  =  false  ;  tag  .  canContainBlock  =  true  ;  }  [ATTENTION]  return  defaultAncestor  ;  }  }    [METHOD]  valueOf  [TYPE]  Tag  [PARAMETER]  String  tagName  [CLASS]  Tag    [TYPE]  List  ancestors  [TYPE]  boolean  canContainBlock  canContainInline  empty  false  isBlock  optionalClosing  preserveWhitespace  true  [TYPE]  Tag  defaultAncestor  tag  [TYPE]  String  tagName  [TYPE]  Map  tags  
[REPLACE]  Tag  tag  =  tags  .  get  (  tagName  )  ;	[BUGGY]  int  result  =  tagName  !  =  null  ?  tagName  .  hashCode  (  )  :  0  ;  [CE]  cannot  find  symbol  tag  [CONTEXT]  public  static  Tag  valueOf  (  String  tagName  )  {  Validate  .  notNull  (  tagName  )  ;  tagName  =  tagName  .  trim  (  )  .  toLowerCase  (  )  ;  Validate  .  notEmpty  (  tagName  )  ;    synchronized  (  tags  )  {  [ATTENTION]  int  result  =  tagName  !  =  null  ?  tagName  .  hashCode  (  )  :  0  ;  if  (  tag  =  =  null  )  {    tag  =  new  Tag  (  tagName  )  ;  tag  .  setAncestor  (  defaultAncestor  .  tagName  )  ;  tag  .  isBlock  =  false  ;  tag  .  canContainBlock  =  true  ;  }  return  tag  ;  }  }    [METHOD]  valueOf  [TYPE]  Tag  [PARAMETER]  String  tagName  [CLASS]  Tag    [TYPE]  List  ancestors  [TYPE]  boolean  canContainBlock  canContainInline  empty  false  isBlock  optionalClosing  preserveWhitespace  true  [TYPE]  Tag  defaultAncestor  tag  [TYPE]  String  tagName  [TYPE]  Map  tags  
[REPLACE]  Validate  .  notNull  (  child  )  ;	[BUGGY]  Validate  .  notNull  (  defaultAncestor  )  ;  [NO-ERROR]  [CONTEXT]  boolean  canContain  (  Tag  child  )  {  [ATTENTION]  Validate  .  notNull  (  defaultAncestor  )    ;    if  (  child  .  isBlock  &&  !this  .  canContainBlock  )  return  false  ;    if  (  !child  .  isBlock  &&  !this  .  canContainInline  )  //  not  block  =  =  inline  return  false  ;    if  (  this  .  optionalClosing  &&  this  .  equals  (  child  )  )  return  false  ;    if  (  this  .  empty  ||  this  .  isData  (  )  )  return  false  ;        if  (  this  .  tagName  .  equals  (   "head "  )  )  {  if  (  child  .  tagName  .  equals  (   "base "  )  ||  child  .  tagName  .  equals  (   "script "  )  ||  child  .  tagName  .  equals  (   "noscript "  )  ||  child  .  tagName  .  equals  (   "link "  )  ||  child  .  tagName  .  equals  (   "meta "  )  ||  child  .  tagName  .  equals  (   "title "  )  ||  child  .  tagName  .  equals  (   "style "  )  ||  child  .  tagName  .  equals  (   "object "  )  )  {  return  true  ;  }  return  false  ;  }    if  (  this  .  tagName  .  equals  (   "dt "  )  &&  child  .  tagName  .  equals  (   "dd "  )  )  return  false  ;  if  (  this  .  tagName  .  equals  (   "dd "  )  &&  child  .  tagName  .  equals  (   "dt "  )  )  return  false  ;    return  true  ;  }    [METHOD]  canContain  [TYPE]  boolean  [PARAMETER]  Tag  child  [CLASS]  Tag    [TYPE]  List  ancestors  [TYPE]  boolean  canContainBlock  canContainInline  empty  false  isBlock  optionalClosing  preserveWhitespace  true  [TYPE]  Tag  child  defaultAncestor  tag  [TYPE]  String  tagName  [TYPE]  Map  tags  
[ADD]  Validate  .  notNull  (  child  )  ;	[BUGGY]  [NO-ERROR]  [CONTEXT]  boolean  canContain  (  Tag  child  )  {  [ATTENTION]    if  (  child  .  isBlock  &&  !this  .  canContainBlock  )  return  false  ;    if  (  !child  .  isBlock  &&  !this  .  canContainInline  )  //  not  block  =  =  inline  return  false  ;    if  (  this  .  optionalClosing  &&  this  .  equals  (  child  )  )  return  false  ;    if  (  this  .  empty  ||  this  .  isData  (  )  )  return  false  ;        if  (  this  .  tagName  .  equals  (   "head "  )  )  {  if  (  child  .  tagName  .  equals  (   "base "  )  ||  child  .  tagName  .  equals  (   "script "  )  ||  child  .  tagName  .  equals  (   "noscript "  )  ||  child  .  tagName  .  equals  (   "link "  )  ||  child  .  tagName  .  equals  (   "meta "  )  ||  child  .  tagName  .  equals  (   "title "  )  ||  child  .  tagName  .  equals  (   "style "  )  ||  child  .  tagName  .  equals  (   "object "  )  )  {  return  true  ;  }  return  false  ;  }    if  (  this  .  tagName  .  equals  (   "dt "  )  &&  child  .  tagName  .  equals  (   "dd "  )  )  return  false  ;  if  (  this  .  tagName  .  equals  (   "dd "  )  &&  child  .  tagName  .  equals  (   "dt "  )  )  return  false  ;    return  true  ;  }    [METHOD]  canContain  [TYPE]  boolean  [PARAMETER]  Tag  child  [CLASS]  Tag    [TYPE]  List  ancestors  [TYPE]  boolean  canContainBlock  canContainInline  empty  false  isBlock  optionalClosing  preserveWhitespace  true  [TYPE]  Tag  child  defaultAncestor  tag  [TYPE]  String  tagName  [TYPE]  Map  tags  
[REPLACE]  if  (  child  .  isBlock  &&  !this  .  canContainBlock  )  return  false;	[BUGGY]  if  (  defaultAncestor  .  isBlock  &&  this  .  canContainBlock  )  return  true  ;  [FE]  AssertionFailedError    expected:<...--  comment  -->Hello<[/p><p>there]</p></div></body></h...>  but  was:<...--  comment  -->Hello<[p>there</p>]</p></div></body></h...>  assertEquals( "<html><head></head><body><div  title  =  \ "Tags  &amp  ;  c.\ "><img  src  =  \ "foo.png\ "  /><p><!--  comment  -->Hello</p><p>there</p></div></body></html> "  ,  [CONTEXT]  boolean  canContain  (  Tag  child  )  {  Validate  .  notNull  (  child  )  ;    [ATTENTION]  if  (  defaultAncestor  .  isBlock  &&  this  .  canContainBlock  )  return  true  ;    if  (  !child  .  isBlock  &&  !this  .  canContainInline  )  //  not  block  =  =  inline  return  false  ;    if  (  this  .  optionalClosing  &&  this  .  equals  (  child  )  )  return  false  ;    if  (  this  .  empty  ||  this  .  isData  (  )  )  return  false  ;        if  (  this  .  tagName  .  equals  (   "head "  )  )  {  if  (  child  .  tagName  .  equals  (   "base "  )  ||  child  .  tagName  .  equals  (   "script "  )  ||  child  .  tagName  .  equals  (   "noscript "  )  ||  child  .  tagName  .  equals  (   "link "  )  ||  child  .  tagName  .  equals  (   "meta "  )  ||  child  .  tagName  .  equals  (   "title "  )  ||  child  .  tagName  .  equals  (   "style "  )  ||  child  .  tagName  .  equals  (   "object "  )  )  {  return  true  ;  }  return  false  ;  }    if  (  this  .  tagName  .  equals  (   "dt "  )  &&  child  .  tagName  .  equals  (   "dd "  )  )  return  false  ;  if  (  this  .  tagName  .  equals  (   "dd "  )  &&  child  .  tagName  .  equals  (   "dt "  )  )  return  false  ;    return  true  ;  }    [METHOD]  canContain  [TYPE]  boolean  [PARAMETER]  Tag  child  [CLASS]  Tag    [TYPE]  List  ancestors  [TYPE]  boolean  canContainBlock  canContainInline  empty  false  isBlock  optionalClosing  preserveWhitespace  true  [TYPE]  Tag  child  defaultAncestor  tag  [TYPE]  String  tagName  [TYPE]  Map  tags  
[REMOVE]  	[BUGGY]  if  (  (  equals  (   "dt "  )  )  &&  (  equals  (   "dd "  )  )  )      return  false  ;  [CE]  unreachable  statement  [CONTEXT]  boolean  canContain  (  Tag  child  )  {  Validate  .  notNull  (  child  )  ;    [ATTENTION]  if  (  child  .  isBlock  &&  !this  .  canContainBlock  )    if  (  (  equals  (   "dt "  )  )  &&  (  equals  (   "dd "  )  )  )  return  false  ;  return  false  ;    if  (  !child  .  isBlock  &&  !this  .  canContainInline  )  //  not  block  =  =  inline  return  false  ;    if  (  this  .  optionalClosing  &&  this  .  equals  (  child  )  )  return  false  ;    if  (  this  .  empty  ||  this  .  isData  (  )  )  return  false  ;        if  (  this  .  tagName  .  equals  (   "head "  )  )  {  if  (  child  .  tagName  .  equals  (   "base "  )  ||  child  .  tagName  .  equals  (   "script "  )  ||  child  .  tagName  .  equals  (   "noscript "  )  ||  child  .  tagName  .  equals  (   "link "  )  ||  child  .  tagName  .  equals  (   "meta "  )  ||  child  .  tagName  .  equals  (   "title "  )  ||  child  .  tagName  .  equals  (   "style "  )  ||  child  .  tagName  .  equals  (   "object "  )  )  {  return  true  ;  }  return  false  ;  }    if  (  this  .  tagName  .  equals  (   "dt "  )  &&  child  .  tagName  .  equals  (   "dd "  )  )  return  false  ;  if  (  this  .  tagName  .  equals  (   "dd "  )  &&  child  .  tagName  .  equals  (   "dt "  )  )  return  false  ;    return  true  ;      [METHOD]  canContain  [TYPE]  boolean  [PARAMETER]  Tag  child  [CLASS]  Tag    [TYPE]  List  ancestors  [TYPE]  boolean  canContainBlock  canContainInline  empty  false  isBlock  optionalClosing  preserveWhitespace  true  [TYPE]  Tag  child  defaultAncestor  tag  [TYPE]  String  tagName  [TYPE]  Map  tags  
[REPLACE]  return  false;	[BUGGY]  return  true  ;  [FE]  AssertionFailedError    expected:<First[]>  but  was:<First[  Ignore  Hello]>  assertEquals( " "  ,  noTitle.title())  ;  assertEquals( "Hello "  ,  noTitle.title())  ;  assertEquals( "Hello "  ,  noTitle.select( "title ").first().text())  ;  assertEquals( "First "  ,  withTitle.title())  ;  assertEquals( "Hello "  ,  withTitle.title())  ;  assertEquals( "Hello "  ,  withTitle.select( "title ").first().text())  ;  [CONTEXT]  boolean  canContain  (  Tag  child  )  {  Validate  .  notNull  (  child  )  ;    if  (  child  .  isBlock  &&  !this  .  canContainBlock  )  [ATTENTION]  return  true  ;    if  (  !child  .  isBlock  &&  !this  .  canContainInline  )  //  not  block  =  =  inline  return  false  ;    if  (  this  .  optionalClosing  &&  this  .  equals  (  child  )  )  return  false  ;    if  (  this  .  empty  ||  this  .  isData  (  )  )  return  false  ;        if  (  this  .  tagName  .  equals  (   "head "  )  )  {  if  (  child  .  tagName  .  equals  (   "base "  )  ||  child  .  tagName  .  equals  (   "script "  )  ||  child  .  tagName  .  equals  (   "noscript "  )  ||  child  .  tagName  .  equals  (   "link "  )  ||  child  .  tagName  .  equals  (   "meta "  )  ||  child  .  tagName  .  equals  (   "title "  )  ||  child  .  tagName  .  equals  (   "style "  )  ||  child  .  tagName  .  equals  (   "object "  )  )  {  return  true  ;  }  return  false  ;  }    if  (  this  .  tagName  .  equals  (   "dt "  )  &&  child  .  tagName  .  equals  (   "dd "  )  )  return  false  ;  if  (  this  .  tagName  .  equals  (   "dd "  )  &&  child  .  tagName  .  equals  (   "dt "  )  )  return  false  ;    return  true  ;  }    [METHOD]  canContain  [TYPE]  boolean  [PARAMETER]  Tag  child  [CLASS]  Tag    [TYPE]  List  ancestors  [TYPE]  boolean  canContainBlock  canContainInline  empty  false  isBlock  optionalClosing  preserveWhitespace  true  [TYPE]  Tag  child  defaultAncestor  tag  [TYPE]  String  tagName  [TYPE]  Map  tags  
[REPLACE]  if  (  !child  .  isBlock  &&  !this  .  canContainInline  )  return  false;	[BUGGY]  if  (  child  .  isBlock  &&  !this  .  canContainInline  )  return  false  ;  [NO-ERROR]  [CONTEXT]  boolean  canContain  (  Tag  child  )  {  Validate  .  notNull  (  child  )  ;    if  (  child  .  isBlock  &&  !this  .  canContainBlock  )  return  false  ;    [ATTENTION]  if  (  child  .  isBlock  &&  !this  .  canContainInline  )  return  false  ;    if  (  this  .  optionalClosing  &&  this  .  equals  (  child  )  )  return  false  ;    if  (  this  .  empty  ||  this  .  isData  (  )  )  return  false  ;        if  (  this  .  tagName  .  equals  (   "head "  )  )  {  if  (  child  .  tagName  .  equals  (   "base "  )  ||  child  .  tagName  .  equals  (   "script "  )  ||  child  .  tagName  .  equals  (   "noscript "  )  ||  child  .  tagName  .  equals  (   "link "  )  ||  child  .  tagName  .  equals  (   "meta "  )  ||  child  .  tagName  .  equals  (   "title "  )  ||  child  .  tagName  .  equals  (   "style "  )  ||  child  .  tagName  .  equals  (   "object "  )  )  {  return  true  ;  }  return  false  ;  }    if  (  this  .  tagName  .  equals  (   "dt "  )  &&  child  .  tagName  .  equals  (   "dd "  )  )  return  false  ;  if  (  this  .  tagName  .  equals  (   "dd "  )  &&  child  .  tagName  .  equals  (   "dt "  )  )  return  false  ;    return  true  ;  }    [METHOD]  canContain  [TYPE]  boolean  [PARAMETER]  Tag  child  [CLASS]  Tag    [TYPE]  List  ancestors  [TYPE]  boolean  canContainBlock  canContainInline  empty  false  isBlock  optionalClosing  preserveWhitespace  true  [TYPE]  Tag  child  defaultAncestor  tag  [TYPE]  String  tagName  [TYPE]  Map  tags  
[REPLACE]  return  false;	[BUGGY]  return  true  ;  [FE]  null  assertFalse(img.canContain(img))  ;  assertFalse(img.canContain(p))  ;  [CONTEXT]  boolean  canContain  (  Tag  child  )  {  Validate  .  notNull  (  child  )  ;    if  (  child  .  isBlock  &&  !this  .  canContainBlock  )  return  false  ;    if  (  !child  .  isBlock  &&  !this  .  canContainInline  )  //  not  block  =  =  inline  [ATTENTION]  return  true  ;    if  (  this  .  optionalClosing  &&  this  .  equals  (  child  )  )  return  false  ;    if  (  this  .  empty  ||  this  .  isData  (  )  )  return  false  ;        if  (  this  .  tagName  .  equals  (   "head "  )  )  {  if  (  child  .  tagName  .  equals  (   "base "  )  ||  child  .  tagName  .  equals  (   "script "  )  ||  child  .  tagName  .  equals  (   "noscript "  )  ||  child  .  tagName  .  equals  (   "link "  )  ||  child  .  tagName  .  equals  (   "meta "  )  ||  child  .  tagName  .  equals  (   "title "  )  ||  child  .  tagName  .  equals  (   "style "  )  ||  child  .  tagName  .  equals  (   "object "  )  )  {  return  true  ;  }  return  false  ;  }    if  (  this  .  tagName  .  equals  (   "dt "  )  &&  child  .  tagName  .  equals  (   "dd "  )  )  return  false  ;  if  (  this  .  tagName  .  equals  (   "dd "  )  &&  child  .  tagName  .  equals  (   "dt "  )  )  return  false  ;    return  true  ;  }    [METHOD]  canContain  [TYPE]  boolean  [PARAMETER]  Tag  child  [CLASS]  Tag    [TYPE]  List  ancestors  [TYPE]  boolean  canContainBlock  canContainInline  empty  false  isBlock  optionalClosing  preserveWhitespace  true  [TYPE]  Tag  child  defaultAncestor  tag  [TYPE]  String  tagName  [TYPE]  Map  tags  
[REPLACE]  if  (  this  .  optionalClosing  &&  this  .  equals  (  child  )  )  return  false;	[BUGGY]  if  (  this  .  optionalClosing  ||  this  .  equals  (  defaultAncestor  )  )  return  false  ;  [FE]  The  validated  object  is  null  assertEquals( "<p>Hello</p><p>there</p><p>now</p> "  ,  TextUtil.stripNewlines(div.html()))  ;  [CONTEXT]  boolean  canContain  (  Tag  child  )  {  Validate  .  notNull  (  child  )  ;    if  (  child  .  isBlock  &&  !this  .  canContainBlock  )  return  false  ;    if  (  !child  .  isBlock  &&  !this  .  canContainInline  )  //  not  block  =  =  inline  return  false  ;    [ATTENTION]  if  (  this  .  optionalClosing  ||  this  .  equals  (  defaultAncestor  )  )  return  false  ;    if  (  this  .  empty  ||  this  .  isData  (  )  )  return  false  ;        if  (  this  .  tagName  .  equals  (   "head "  )  )  {  if  (  child  .  tagName  .  equals  (   "base "  )  ||  child  .  tagName  .  equals  (   "script "  )  ||  child  .  tagName  .  equals  (   "noscript "  )  ||  child  .  tagName  .  equals  (   "link "  )  ||  child  .  tagName  .  equals  (   "meta "  )  ||  child  .  tagName  .  equals  (   "title "  )  ||  child  .  tagName  .  equals  (   "style "  )  ||  child  .  tagName  .  equals  (   "object "  )  )  {  return  true  ;  }  return  false  ;  }    if  (  this  .  tagName  .  equals  (   "dt "  )  &&  child  .  tagName  .  equals  (   "dd "  )  )  return  false  ;  if  (  this  .  tagName  .  equals  (   "dd "  )  &&  child  .  tagName  .  equals  (   "dt "  )  )  return  false  ;    return  true  ;  }    [METHOD]  canContain  [TYPE]  boolean  [PARAMETER]  Tag  child  [CLASS]  Tag    [TYPE]  List  ancestors  [TYPE]  boolean  canContainBlock  canContainInline  empty  false  isBlock  optionalClosing  preserveWhitespace  true  [TYPE]  Tag  child  defaultAncestor  tag  [TYPE]  String  tagName  [TYPE]  Map  tags  
[REPLACE]  return  false;	[BUGGY]  return  true  ;  [FE]  AssertionFailedError    expected:<2>  but  was:<1>  assertEquals(1  ,  ol.size())  ;  assertEquals(2  ,  ol.get(0).children().size())  ;  assertEquals(0  ,  doc2.select( "ul ").size())  ;  assertEquals(1  ,  doc2.select( "ol ").size())  ;  assertEquals(2  ,  doc2.select( "ol  li ").size())  ;  assertEquals(2  ,  doc2.select( "ol  li  p ").size())  ;  assertEquals(1  ,  doc2.select( "ol  li ").get(0).children().size())  ;  //  one  p  in  first  li  [CONTEXT]  boolean  canContain  (  Tag  child  )  {  Validate  .  notNull  (  child  )  ;    if  (  child  .  isBlock  &&  !this  .  canContainBlock  )  return  false  ;    if  (  !child  .  isBlock  &&  !this  .  canContainInline  )  //  not  block  =  =  inline  return  false  ;    if  (  this  .  optionalClosing  &&  this  .  equals  (  child  )  )  [ATTENTION]  return  true  ;    if  (  this  .  empty  ||  this  .  isData  (  )  )  return  false  ;        if  (  this  .  tagName  .  equals  (   "head "  )  )  {  if  (  child  .  tagName  .  equals  (   "base "  )  ||  child  .  tagName  .  equals  (   "script "  )  ||  child  .  tagName  .  equals  (   "noscript "  )  ||  child  .  tagName  .  equals  (   "link "  )  ||  child  .  tagName  .  equals  (   "meta "  )  ||  child  .  tagName  .  equals  (   "title "  )  ||  child  .  tagName  .  equals  (   "style "  )  ||  child  .  tagName  .  equals  (   "object "  )  )  {  return  true  ;  }  return  false  ;  }    if  (  this  .  tagName  .  equals  (   "dt "  )  &&  child  .  tagName  .  equals  (   "dd "  )  )  return  false  ;  if  (  this  .  tagName  .  equals  (   "dd "  )  &&  child  .  tagName  .  equals  (   "dt "  )  )  return  false  ;    return  true  ;  }    [METHOD]  canContain  [TYPE]  boolean  [PARAMETER]  Tag  child  [CLASS]  Tag    [TYPE]  List  ancestors  [TYPE]  boolean  canContainBlock  canContainInline  empty  false  isBlock  optionalClosing  preserveWhitespace  true  [TYPE]  Tag  child  defaultAncestor  tag  [TYPE]  String  tagName  [TYPE]  Map  tags  
[REPLACE]  if  (  this  .  empty  ||  this  .  isData  (  )  )  return  false;	[BUGGY]  if  (  this  .  empty  &&isBlock  (  )  )  return  true  ;  [NO-ERROR]  [CONTEXT]  boolean  canContain  (  Tag  child  )  {  Validate  .  notNull  (  child  )  ;    if  (  child  .  isBlock  &&  !this  .  canContainBlock  )  return  false  ;    if  (  !child  .  isBlock  &&  !this  .  canContainInline  )  //  not  block  =  =  inline  return  false  ;    if  (  this  .  optionalClosing  &&  this  .  equals  (  child  )  )  return  false  ;    [ATTENTION]  if  (  this  .  empty  &&isBlock  (  )  )  return  true  ;        if  (  this  .  tagName  .  equals  (   "head "  )  )  {  if  (  child  .  tagName  .  equals  (   "base "  )  ||  child  .  tagName  .  equals  (   "script "  )  ||  child  .  tagName  .  equals  (   "noscript "  )  ||  child  .  tagName  .  equals  (   "link "  )  ||  child  .  tagName  .  equals  (   "meta "  )  ||  child  .  tagName  .  equals  (   "title "  )  ||  child  .  tagName  .  equals  (   "style "  )  ||  child  .  tagName  .  equals  (   "object "  )  )  {  return  true  ;  }  return  false  ;  }    if  (  this  .  tagName  .  equals  (   "dt "  )  &&  child  .  tagName  .  equals  (   "dd "  )  )  return  false  ;  if  (  this  .  tagName  .  equals  (   "dd "  )  &&  child  .  tagName  .  equals  (   "dt "  )  )  return  false  ;    return  true  ;  }    [METHOD]  canContain  [TYPE]  boolean  [PARAMETER]  Tag  child  [CLASS]  Tag    [TYPE]  List  ancestors  [TYPE]  boolean  canContainBlock  canContainInline  empty  false  isBlock  optionalClosing  preserveWhitespace  true  [TYPE]  Tag  child  defaultAncestor  tag  [TYPE]  String  tagName  [TYPE]  Map  tags  
[REMOVE]  	[BUGGY]  if  (  (  equals  (   "dt "  )  )  &&  (  equals  (   "dd "  )  )  )      return  false  ;  [CE]  unreachable  statement  [CONTEXT]  boolean  canContain  (  Tag  child  )  {  Validate  .  notNull  (  child  )  ;    if  (  child  .  isBlock  &&  !this  .  canContainBlock  )  return  false  ;    if  (  !child  .  isBlock  &&  !this  .  canContainInline  )  //  not  block  =  =  inline  return  false  ;    if  (  this  .  optionalClosing  &&  this  .  equals  (  child  )  )  return  false  ;    [ATTENTION]  if  (  this  .  empty  ||  this  .  isData  (  )  )    if  (  (  equals  (   "dt "  )  )  &&  (  equals  (   "dd "  )  )  )  return  false  ;  return  false  ;        if  (  this  .  tagName  .  equals  (   "head "  )  )  {  if  (  child  .  tagName  .  equals  (   "base "  )  ||  child  .  tagName  .  equals  (   "script "  )  ||  child  .  tagName  .  equals  (   "noscript "  )  ||  child  .  tagName  .  equals  (   "link "  )  ||  child  .  tagName  .  equals  (   "meta "  )  ||  child  .  tagName  .  equals  (   "title "  )  ||  child  .  tagName  .  equals  (   "style "  )  ||  child  .  tagName  .  equals  (   "object "  )  )  {  return  true  ;  }  return  false  ;  }    if  (  this  .  tagName  .  equals  (   "dt "  )  &&  child  .  tagName  .  equals  (   "dd "  )  )  return  false  ;  if  (  this  .  tagName  .  equals  (   "dd "  )  &&  child  .  tagName  .  equals  (   "dt "  )  )  return  false  ;    return  true  ;      [METHOD]  canContain  [TYPE]  boolean  [PARAMETER]  Tag  child  [CLASS]  Tag    [TYPE]  List  ancestors  [TYPE]  boolean  canContainBlock  canContainInline  empty  false  isBlock  optionalClosing  preserveWhitespace  true  [TYPE]  Tag  child  defaultAncestor  tag  [TYPE]  String  tagName  [TYPE]  Map  tags  
[REPLACE]  return  false;	[BUGGY]  return  true  ;  [NO-ERROR]  [CONTEXT]  boolean  canContain  (  Tag  child  )  {  Validate  .  notNull  (  child  )  ;    if  (  child  .  isBlock  &&  !this  .  canContainBlock  )  return  false  ;    if  (  !child  .  isBlock  &&  !this  .  canContainInline  )  //  not  block  =  =  inline  return  false  ;    if  (  this  .  optionalClosing  &&  this  .  equals  (  child  )  )  return  false  ;    if  (  this  .  empty  ||  this  .  isData  (  )  )  [ATTENTION]  return  true  ;        if  (  this  .  tagName  .  equals  (   "head "  )  )  {  if  (  child  .  tagName  .  equals  (   "base "  )  ||  child  .  tagName  .  equals  (   "script "  )  ||  child  .  tagName  .  equals  (   "noscript "  )  ||  child  .  tagName  .  equals  (   "link "  )  ||  child  .  tagName  .  equals  (   "meta "  )  ||  child  .  tagName  .  equals  (   "title "  )  ||  child  .  tagName  .  equals  (   "style "  )  ||  child  .  tagName  .  equals  (   "object "  )  )  {  return  true  ;  }  return  false  ;  }    if  (  this  .  tagName  .  equals  (   "dt "  )  &&  child  .  tagName  .  equals  (   "dd "  )  )  return  false  ;  if  (  this  .  tagName  .  equals  (   "dd "  )  &&  child  .  tagName  .  equals  (   "dt "  )  )  return  false  ;    return  true  ;  }    [METHOD]  canContain  [TYPE]  boolean  [PARAMETER]  Tag  child  [CLASS]  Tag    [TYPE]  List  ancestors  [TYPE]  boolean  canContainBlock  canContainInline  empty  false  isBlock  optionalClosing  preserveWhitespace  true  [TYPE]  Tag  child  defaultAncestor  tag  [TYPE]  String  tagName  [TYPE]  Map  tags  
[REPLACE]  if  (  this  .  tagName  .  equals  (   "head "  )  )  {	[BUGGY]  if  (  this  .  tagName  .  setOptionalClosing  (  )    )  {[CE]  cannot  find  symbol  [CONTEXT]  boolean  canContain  (  Tag  child  )  {  Validate  .  notNull  (  child  )  ;    if  (  child  .  isBlock  &&  !this  .  canContainBlock  )  return  false  ;    if  (  !child  .  isBlock  &&  !this  .  canContainInline  )  //  not  block  =  =  inline  return  false  ;    if  (  this  .  optionalClosing  &&  this  .  equals  (  child  )  )  return  false  ;    if  (  this  .  empty  ||  this  .  isData  (  )  )  return  false  ;        [ATTENTION]  if  (  this  .  tagName  .  setOptionalClosing  (  )    )  {  if  (  child  .  tagName  .  equals  (   "base "  )  ||  child  .  tagName  .  equals  (   "script "  )  ||  child  .  tagName  .  equals  (   "noscript "  )  ||  child  .  tagName  .  equals  (   "link "  )  ||  child  .  tagName  .  equals  (   "meta "  )  ||  child  .  tagName  .  equals  (   "title "  )  ||  child  .  tagName  .  equals  (   "style "  )  ||  child  .  tagName  .  equals  (   "object "  )  )  {  return  true  ;  }  return  false  ;  }    if  (  this  .  tagName  .  equals  (   "dt "  )  &&  child  .  tagName  .  equals  (   "dd "  )  )  return  false  ;  if  (  this  .  tagName  .  equals  (   "dd "  )  &&  child  .  tagName  .  equals  (   "dt "  )  )  return  false  ;    return  true  ;  }    [METHOD]  canContain  [TYPE]  boolean  [PARAMETER]  Tag  child  [CLASS]  Tag    [TYPE]  List  ancestors  [TYPE]  boolean  canContainBlock  canContainInline  empty  false  isBlock  optionalClosing  preserveWhitespace  true  [TYPE]  Tag  child  defaultAncestor  tag  [TYPE]  String  tagName  [TYPE]  Map  tags  
[ADD]  if  (  this  .  tagName  .  equals  (   "head "  )  )  {  if  (  child  .  tagName  .  equals  (   "base "  )  ||  child  .  tagName  .  equals  (   "script "  )  ||  child  .  tagName  .  equals  (   "noscript "  )  ||  child  .  tagName  .  equals  (   "link "  )  ||  child  .  tagName  .  equals  (   "meta "  )  ||  child  .  tagName  .  equals  (   "title "  )  ||  child  .  tagName  .  equals  (   "style "  )  ||  child  .  tagName  .  equals  (   "object "  )  )  {  return  true;  }	[BUGGY]  [CE]  illegal  start  of  type  [CONTEXT]  boolean  canContain  (  Tag  child  )  {  Validate  .  notNull  (  child  )  ;    if  (  child  .  isBlock  &&  !this  .  canContainBlock  )  return  false  ;    if  (  !child  .  isBlock  &&  !this  .  canContainInline  )  //  not  block  =  =  inline  return  false  ;    if  (  this  .  optionalClosing  &&  this  .  equals  (  child  )  )  return  false  ;    if  (  this  .  empty  ||  this  .  isData  (  )  )  return  false  ;        [ATTENTION]      return  false  ;  }    if  (  this  .  tagName  .  equals  (   "dt "  )  &&  child  .  tagName  .  equals  (   "dd "  )  )  return  false  ;  if  (  this  .  tagName  .  equals  (   "dd "  )  &&  child  .  tagName  .  equals  (   "dt "  )  )  return  false  ;    return  true  ;  }    [METHOD]  canContain  [TYPE]  boolean  [PARAMETER]  Tag  child  [CLASS]  Tag    [TYPE]  List  ancestors  [TYPE]  boolean  canContainBlock  canContainInline  empty  false  isBlock  optionalClosing  preserveWhitespace  true  [TYPE]  Tag  child  defaultAncestor  tag  [TYPE]  String  tagName  [TYPE]  Map  tags  
[REPLACE]  if  (  child  .  tagName  .  equals  (   "base "  )  ||  child  .  tagName  .  equals  (   "script "  )  ||  child  .  tagName  .  equals  (   "noscript "  )  ||  child  .  tagName  .  equals  (   "link "  )  ||  child  .  tagName  .  equals  (   "meta "  )  ||  child  .  tagName  .  equals  (   "title "  )  ||  child  .  tagName  .  equals  (   "style "  )  ||  child  .  tagName  .  equals  (   "object "  )  )  {	[BUGGY]  if  (  child  .  tagName  .  equals  (   "script "  )  &&  child  .  tagName  .  equals  (   "noscript "  )  &&  child  .  tagName  .  equals  (   "link "  )  &&  child  .  tagName  .  equals  (   "meta "  )  &&  child  .  tagName  .  equals  (   "title "  )  &&  child  .  tagName  .  equals  (   "style "  )  &&  child  .  tagName  .  equals  (   "object "  )  )  {[FE]  AssertionFailedError    expected:<2>  but  was:<4>  assertEquals(1  ,  doc.children().size())  ;  //  root  node:  contains  html  nodeassertEquals(2  ,  doc.child(0).children().size())  ;  //  html  node:  head  and  bodyassertEquals(3  ,  head.children().size())  ;  assertEquals(1  ,  body.children().size())  ;  assertEquals( "keywords "  ,  head.getElementsByTag( "meta ").get(0).attr( "name "))  ;  assertEquals(0  ,  body.getElementsByTag( "meta ").size())  ;  assertEquals( "jsoup "  ,  doc.title())  ;  assertEquals( "Hello  world "  ,  body.text())  ;  assertEquals( "Hello  world "  ,  body.children().get(0).text())  ;  [CONTEXT]  boolean  canContain  (  Tag  child  )  {  Validate  .  notNull  (  child  )  ;    if  (  child  .  isBlock  &&  !this  .  canContainBlock  )  return  false  ;    if  (  !child  .  isBlock  &&  !this  .  canContainInline  )  //  not  block  =  =  inline  return  false  ;    if  (  this  .  optionalClosing  &&  this  .  equals  (  child  )  )  return  false  ;    if  (  this  .  empty  ||  this  .  isData  (  )  )  return  false  ;        if  (  this  .  tagName  .  equals  (   "head "  )  )  {  [ATTENTION]  if  (  child  .  tagName  .  equals  (   "script "  )  &&  child  .  tagName  .  equals  (   "noscript "  )  &&  child  .  tagName  .  equals  (   "link "  )  &&  child  .  tagName  .  equals  (   "meta "  )  &&  child  .  tagName  .  equals  (   "title "  )  &&  child  .  tagName  .  equals  (   "style "  )  &&  child  .  tagName  .  equals  (   "object "  )  )  {  return  true  ;  }  return  false  ;  }    if  (  this  .  tagName  .  equals  (   "dt "  )  &&  child  .  tagName  .  equals  (   "dd "  )  )  return  false  ;  if  (  this  .  tagName  .  equals  (   "dd "  )  &&  child  .  tagName  .  equals  (   "dt "  )  )  return  false  ;    return  true  ;  }    [METHOD]  canContain  [TYPE]  boolean  [PARAMETER]  Tag  child  [CLASS]  Tag    [TYPE]  List  ancestors  [TYPE]  boolean  canContainBlock  canContainInline  empty  false  isBlock  optionalClosing  preserveWhitespace  true  [TYPE]  Tag  child  defaultAncestor  tag  [TYPE]  String  tagName  [TYPE]  Map  tags  
[REPLACE]  return  true;	[BUGGY]  return  false  ;  [FE]  AssertionFailedError    expected:<2>  but  was:<4>  assertEquals(1  ,  doc.children().size())  ;  //  root  node:  contains  html  nodeassertEquals(2  ,  doc.child(0).children().size())  ;  //  html  node:  head  and  bodyassertEquals(3  ,  head.children().size())  ;  assertEquals(1  ,  body.children().size())  ;  assertEquals( "keywords "  ,  head.getElementsByTag( "meta ").get(0).attr( "name "))  ;  assertEquals(0  ,  body.getElementsByTag( "meta ").size())  ;  assertEquals( "jsoup "  ,  doc.title())  ;  assertEquals( "Hello  world "  ,  body.text())  ;  assertEquals( "Hello  world "  ,  body.children().get(0).text())  ;  [CONTEXT]  if  (  child  .  tagName  .  equals  (   "base "  )  ||  child  .  tagName  .  equals  (   "script "  )  ||  child  .  tagName  .  equals  (   "noscript "  )  ||  child  .  tagName  .  equals  (   "link "  )  ||  child  .  tagName  .  equals  (   "meta "  )  ||  child  .  tagName  .  equals  (   "title "  )  ||  child  .  tagName  .  equals  (   "style "  )  ||  child  .  tagName  .  equals  (   "object "  )  )  {  [ATTENTION]  return  false  ;  }    [METHOD]  canContain  [TYPE]  boolean  [PARAMETER]  Tag  child  [CLASS]  Tag    [TYPE]  List  ancestors  [TYPE]  boolean  canContainBlock  canContainInline  empty  false  isBlock  optionalClosing  preserveWhitespace  true  [TYPE]  Tag  child  defaultAncestor  tag  [TYPE]  String  tagName  [TYPE]  Map  tags  
[REPLACE]  return  true;	[BUGGY]  return  false  ;  [FE]  AssertionFailedError    expected:<2>  but  was:<4>  assertEquals(1  ,  doc.children().size())  ;  //  root  node:  contains  html  nodeassertEquals(2  ,  doc.child(0).children().size())  ;  //  html  node:  head  and  bodyassertEquals(3  ,  head.children().size())  ;  assertEquals(1  ,  body.children().size())  ;  assertEquals( "keywords "  ,  head.getElementsByTag( "meta ").get(0).attr( "name "))  ;  assertEquals(0  ,  body.getElementsByTag( "meta ").size())  ;  assertEquals( "jsoup "  ,  doc.title())  ;  assertEquals( "Hello  world "  ,  body.text())  ;  assertEquals( "Hello  world "  ,  body.children().get(0).text())  ;  [CONTEXT]  boolean  canContain  (  Tag  child  )  {  Validate  .  notNull  (  child  )  ;    if  (  child  .  isBlock  &&  !this  .  canContainBlock  )  return  false  ;    if  (  !child  .  isBlock  &&  !this  .  canContainInline  )  //  not  block  =  =  inline  return  false  ;    if  (  this  .  optionalClosing  &&  this  .  equals  (  child  )  )  return  false  ;    if  (  this  .  empty  ||  this  .  isData  (  )  )  return  false  ;        if  (  this  .  tagName  .  equals  (   "head "  )  )  {  if  (  child  .  tagName  .  equals  (   "base "  )  ||  child  .  tagName  .  equals  (   "script "  )  ||  child  .  tagName  .  equals  (   "noscript "  )  ||  child  .  tagName  .  equals  (   "link "  )  ||  child  .  tagName  .  equals  (   "meta "  )  ||  child  .  tagName  .  equals  (   "title "  )  ||  child  .  tagName  .  equals  (   "style "  )  ||  child  .  tagName  .  equals  (   "object "  )  )  {  [ATTENTION]  return  false  ;  }  return  false  ;  }    if  (  this  .  tagName  .  equals  (   "dt "  )  &&  child  .  tagName  .  equals  (   "dd "  )  )  return  false  ;  if  (  this  .  tagName  .  equals  (   "dd "  )  &&  child  .  tagName  .  equals  (   "dt "  )  )  return  false  ;    return  true  ;  }    [METHOD]  canContain  [TYPE]  boolean  [PARAMETER]  Tag  child  [CLASS]  Tag    [TYPE]  List  ancestors  [TYPE]  boolean  canContainBlock  canContainInline  empty  false  isBlock  optionalClosing  preserveWhitespace  true  [TYPE]  Tag  child  defaultAncestor  tag  [TYPE]  String  tagName  [TYPE]  Map  tags  
[REPLACE]  return  false;	[BUGGY]  return  true  ;  [FE]  AssertionFailedError    expected:<2>  but  was:<1>  assertEquals(1  ,  doc.children().size())  ;  //  root  node:  contains  html  nodeassertEquals(2  ,  doc.child(0).children().size())  ;  //  html  node:  head  and  bodyassertEquals(3  ,  head.children().size())  ;  assertEquals(1  ,  body.children().size())  ;  assertEquals( "keywords "  ,  head.getElementsByTag( "meta ").get(0).attr( "name "))  ;  assertEquals(0  ,  body.getElementsByTag( "meta ").size())  ;  assertEquals( "jsoup "  ,  doc.title())  ;  assertEquals( "Hello  world "  ,  body.text())  ;  assertEquals( "Hello  world "  ,  body.children().get(0).text())  ;  [CONTEXT]  boolean  canContain  (  Tag  child  )  {  Validate  .  notNull  (  child  )  ;    if  (  child  .  isBlock  &&  !this  .  canContainBlock  )  return  false  ;    if  (  !child  .  isBlock  &&  !this  .  canContainInline  )  //  not  block  =  =  inline  return  false  ;    if  (  this  .  optionalClosing  &&  this  .  equals  (  child  )  )  return  false  ;    if  (  this  .  empty  ||  this  .  isData  (  )  )  return  false  ;        if  (  this  .  tagName  .  equals  (   "head "  )  )  {  if  (  child  .  tagName  .  equals  (   "base "  )  ||  child  .  tagName  .  equals  (   "script "  )  ||  child  .  tagName  .  equals  (   "noscript "  )  ||  child  .  tagName  .  equals  (   "link "  )  ||  child  .  tagName  .  equals  (   "meta "  )  ||  child  .  tagName  .  equals  (   "title "  )  ||  child  .  tagName  .  equals  (   "style "  )  ||  child  .  tagName  .  equals  (   "object "  )  )  {  return  true  ;  }  [ATTENTION]  return  true  ;  }    if  (  this  .  tagName  .  equals  (   "dt "  )  &&  child  .  tagName  .  equals  (   "dd "  )  )  return  false  ;  if  (  this  .  tagName  .  equals  (   "dd "  )  &&  child  .  tagName  .  equals  (   "dt "  )  )  return  false  ;    return  true  ;  }    [METHOD]  canContain  [TYPE]  boolean  [PARAMETER]  Tag  child  [CLASS]  Tag    [TYPE]  List  ancestors  [TYPE]  boolean  canContainBlock  canContainInline  empty  false  isBlock  optionalClosing  preserveWhitespace  true  [TYPE]  Tag  child  defaultAncestor  tag  [TYPE]  String  tagName  [TYPE]  Map  tags  
[REPLACE]  if  (  child  .  tagName  .  equals  (   "base "  )  ||  child  .  tagName  .  equals  (   "script "  )  ||  child  .  tagName  .  equals  (   "noscript "  )  ||  child  .  tagName  .  equals  (   "link "  )  ||  child  .  tagName  .  equals  (   "meta "  )  ||  child  .  tagName  .  equals  (   "title "  )  ||  child  .  tagName  .  equals  (   "style "  )  ||  child  .  tagName  .  equals  (   "object "  )  )  {	[BUGGY]  if  (  child  .  tagName  .  equals  (   "base "  )  &&  child  .  tagName  .  equals  (   "script "  )  &&  child  .  tagName  .  equals  (   "noscript "  )  &&  child  .  tagName  .  equals  (   "link "  )  &&  child  .  tagName  .  equals  (   "meta "  )  &&  child  .  tagName  .  equals  (   "title "  )  &&  child  .  tagName  .  equals  (   "style "  )  &&  child  .  tagName  .  equals  (   "object "  )  )  {[FE]  AssertionFailedError    expected:<2>  but  was:<4>  assertEquals(1  ,  doc.children().size())  ;  //  root  node:  contains  html  nodeassertEquals(2  ,  doc.child(0).children().size())  ;  //  html  node:  head  and  bodyassertEquals(3  ,  head.children().size())  ;  assertEquals(1  ,  body.children().size())  ;  assertEquals( "keywords "  ,  head.getElementsByTag( "meta ").get(0).attr( "name "))  ;  assertEquals(0  ,  body.getElementsByTag( "meta ").size())  ;  assertEquals( "jsoup "  ,  doc.title())  ;  assertEquals( "Hello  world "  ,  body.text())  ;  assertEquals( "Hello  world "  ,  body.children().get(0).text())  ;  [CONTEXT]  boolean  canContain  (  Tag  child  )  {  Validate  .  notNull  (  child  )  ;    if  (  child  .  isBlock  &&  !this  .  canContainBlock  )  return  false  ;    if  (  !child  .  isBlock  &&  !this  .  canContainInline  )  //  not  block  =  =  inline  return  false  ;    if  (  this  .  optionalClosing  &&  this  .  equals  (  child  )  )  return  false  ;    if  (  this  .  empty  ||  this  .  isData  (  )  )  return  false  ;        if  (  this  .  tagName  .  equals  (   "head "  )  )  {  [ATTENTION]  if  (  child  .  tagName  .  equals  (   "base "  )  &&  child  .  tagName  .  equals  (   "script "  )  &&  child  .  tagName  .  equals  (   "noscript "  )  &&  child  .  tagName  .  equals  (   "link "  )  &&  child  .  tagName  .  equals  (   "meta "  )  &&  child  .  tagName  .  equals  (   "title "  )  &&  child  .  tagName  .  equals  (   "style "  )  &&  child  .  tagName  .  equals  (   "object "  )  )  {  return  true  ;  }  return  false  ;  }    if  (  this  .  tagName  .  equals  (   "dt "  )  &&  child  .  tagName  .  equals  (   "dd "  )  )  return  false  ;  if  (  this  .  tagName  .  equals  (   "dd "  )  &&  child  .  tagName  .  equals  (   "dt "  )  )  return  false  ;    return  true  ;  }    [METHOD]  canContain  [TYPE]  boolean  [PARAMETER]  Tag  child  [CLASS]  Tag    [TYPE]  List  ancestors  [TYPE]  boolean  canContainBlock  canContainInline  empty  false  isBlock  optionalClosing  preserveWhitespace  true  [TYPE]  Tag  child  defaultAncestor  tag  [TYPE]  String  tagName  [TYPE]  Map  tags  
[REPLACE]  if  (  this  .  tagName  .  equals  (   "dt "  )  &&  child  .  tagName  .  equals  (   "dd "  )  )  return  false;	[BUGGY]  if  (  this  .  tagName  .  equals  (   "dt "  )  ||  defaultAncestor  .  tagName  .  equals  (   "dd "  )  )  return  false  ;  [NO-ERROR]  [CONTEXT]  boolean  canContain  (  Tag  child  )  {  Validate  .  notNull  (  child  )  ;    if  (  child  .  isBlock  &&  !this  .  canContainBlock  )  return  false  ;    if  (  !child  .  isBlock  &&  !this  .  canContainInline  )  //  not  block  =  =  inline  return  false  ;    if  (  this  .  optionalClosing  &&  this  .  equals  (  child  )  )  return  false  ;    if  (  this  .  empty  ||  this  .  isData  (  )  )  return  false  ;        if  (  this  .  tagName  .  equals  (   "head "  )  )  {  if  (  child  .  tagName  .  equals  (   "base "  )  ||  child  .  tagName  .  equals  (   "script "  )  ||  child  .  tagName  .  equals  (   "noscript "  )  ||  child  .  tagName  .  equals  (   "link "  )  ||  child  .  tagName  .  equals  (   "meta "  )  ||  child  .  tagName  .  equals  (   "title "  )  ||  child  .  tagName  .  equals  (   "style "  )  ||  child  .  tagName  .  equals  (   "object "  )  )  {  return  true  ;  }  return  false  ;  }    [ATTENTION]  if  (  this  .  tagName  .  equals  (   "dt "  )  ||  defaultAncestor  .  tagName  .  equals  (   "dd "  )  )  return  false  ;    if  (  this  .  tagName  .  equals  (   "dd "  )  &&  child  .  tagName  .  equals  (   "dt "  )  )  return  false  ;    return  true  ;  }    [METHOD]  canContain  [TYPE]  boolean  [PARAMETER]  Tag  child  [CLASS]  Tag    [TYPE]  List  ancestors  [TYPE]  boolean  canContainBlock  canContainInline  empty  false  isBlock  optionalClosing  preserveWhitespace  true  [TYPE]  Tag  child  defaultAncestor  tag  [TYPE]  String  tagName  [TYPE]  Map  tags  
[REPLACE]  return  false;	[BUGGY]  return  true  ;  [FE]  AssertionFailedError    expected:<4>  but  was:<2>  assertEquals(4  ,  doc.body().getElementsByTag( "dl ").first().children().size())  ;  assertEquals(2  ,  dts.size())  ;  assertEquals( "Zug "  ,  dts.get(1).nextElementSibling().text())  ;  [CONTEXT]  boolean  canContain  (  Tag  child  )  {  Validate  .  notNull  (  child  )  ;    if  (  child  .  isBlock  &&  !this  .  canContainBlock  )  return  false  ;    if  (  !child  .  isBlock  &&  !this  .  canContainInline  )  //  not  block  =  =  inline  return  false  ;    if  (  this  .  optionalClosing  &&  this  .  equals  (  child  )  )  return  false  ;    if  (  this  .  empty  ||  this  .  isData  (  )  )  return  false  ;        if  (  this  .  tagName  .  equals  (   "head "  )  )  {  if  (  child  .  tagName  .  equals  (   "base "  )  ||  child  .  tagName  .  equals  (   "script "  )  ||  child  .  tagName  .  equals  (   "noscript "  )  ||  child  .  tagName  .  equals  (   "link "  )  ||  child  .  tagName  .  equals  (   "meta "  )  ||  child  .  tagName  .  equals  (   "title "  )  ||  child  .  tagName  .  equals  (   "style "  )  ||  child  .  tagName  .  equals  (   "object "  )  )  {  return  true  ;  }  return  false  ;  }    if  (  this  .  tagName  .  equals  (   "dt "  )  &&  child  .  tagName  .  equals  (   "dd "  )  )  [ATTENTION]  return  true  ;  if  (  this  .  tagName  .  equals  (   "dd "  )  &&  child  .  tagName  .  equals  (   "dt "  )  )  return  false  ;    return  true  ;  }    [METHOD]  canContain  [TYPE]  boolean  [PARAMETER]  Tag  child  [CLASS]  Tag    [TYPE]  List  ancestors  [TYPE]  boolean  canContainBlock  canContainInline  empty  false  isBlock  optionalClosing  preserveWhitespace  true  [TYPE]  Tag  child  defaultAncestor  tag  [TYPE]  String  tagName  [TYPE]  Map  tags  
[REPLACE]  if  (  this  .  tagName  .  equals  (   "dd "  )  &&  child  .  tagName  .  equals  (   "dt "  )  )  return  false;	[BUGGY]  if  (  this  .  tagName  .  setOptionalClosing  (  )    ||  child  .  tagName[CE]  ')'  expected  [CONTEXT]  boolean  canContain  (  Tag  child  )  {  Validate  .  notNull  (  child  )  ;    if  (  child  .  isBlock  &&  !this  .  canContainBlock  )  return  false  ;    if  (  !child  .  isBlock  &&  !this  .  canContainInline  )  //  not  block  =  =  inline  return  false  ;    if  (  this  .  optionalClosing  &&  this  .  equals  (  child  )  )  return  false  ;    if  (  this  .  empty  ||  this  .  isData  (  )  )  return  false  ;        if  (  this  .  tagName  .  equals  (   "head "  )  )  {  if  (  child  .  tagName  .  equals  (   "base "  )  ||  child  .  tagName  .  equals  (   "script "  )  ||  child  .  tagName  .  equals  (   "noscript "  )  ||  child  .  tagName  .  equals  (   "link "  )  ||  child  .  tagName  .  equals  (   "meta "  )  ||  child  .  tagName  .  equals  (   "title "  )  ||  child  .  tagName  .  equals  (   "style "  )  ||  child  .  tagName  .  equals  (   "object "  )  )  {  return  true  ;  }  return  false  ;  }    if  (  this  .  tagName  .  equals  (   "dt "  )  &&  child  .  tagName  .  equals  (   "dd "  )  )  return  false  ;  [ATTENTION]  if  (  this  .  tagName  .  setOptionalClosing  (  )  ||  child  .  tagName    return  true  ;  }    [METHOD]  canContain  [TYPE]  boolean  [PARAMETER]  Tag  child  [CLASS]  Tag    [TYPE]  List  ancestors  [TYPE]  boolean  canContainBlock  canContainInline  empty  false  isBlock  optionalClosing  preserveWhitespace  true  [TYPE]  Tag  child  defaultAncestor  tag  [TYPE]  String  tagName  [TYPE]  Map  tags  
[REPLACE]  return  false;	[BUGGY]  return  true  ;  [FE]  AssertionFailedError    expected:<4>  but  was:<3>  assertEquals(4  ,  doc.body().getElementsByTag( "dl ").first().children().size())  ;  assertEquals(2  ,  dts.size())  ;  assertEquals( "Zug "  ,  dts.get(1).nextElementSibling().text())  ;  [CONTEXT]  boolean  canContain  (  Tag  child  )  {  Validate  .  notNull  (  child  )  ;    if  (  child  .  isBlock  &&  !this  .  canContainBlock  )  return  false  ;    if  (  !child  .  isBlock  &&  !this  .  canContainInline  )  //  not  block  =  =  inline  return  false  ;    if  (  this  .  optionalClosing  &&  this  .  equals  (  child  )  )  return  false  ;    if  (  this  .  empty  ||  this  .  isData  (  )  )  return  false  ;        if  (  this  .  tagName  .  equals  (   "head "  )  )  {  if  (  child  .  tagName  .  equals  (   "base "  )  ||  child  .  tagName  .  equals  (   "script "  )  ||  child  .  tagName  .  equals  (   "noscript "  )  ||  child  .  tagName  .  equals  (   "link "  )  ||  child  .  tagName  .  equals  (   "meta "  )  ||  child  .  tagName  .  equals  (   "title "  )  ||  child  .  tagName  .  equals  (   "style "  )  ||  child  .  tagName  .  equals  (   "object "  )  )  {  return  true  ;  }  return  false  ;  }    if  (  this  .  tagName  .  equals  (   "dt "  )  &&  child  .  tagName  .  equals  (   "dd "  )  )  return  false  ;  if  (  this  .  tagName  .  equals  (   "dd "  )  &&  child  .  tagName  .  equals  (   "dt "  )  )  [ATTENTION]  return  true  ;    return  true  ;  }    [METHOD]  canContain  [TYPE]  boolean  [PARAMETER]  Tag  child  [CLASS]  Tag    [TYPE]  List  ancestors  [TYPE]  boolean  canContainBlock  canContainInline  empty  false  isBlock  optionalClosing  preserveWhitespace  true  [TYPE]  Tag  child  defaultAncestor  tag  [TYPE]  String  tagName  [TYPE]  Map  tags  
[REPLACE]  return  true;	[BUGGY]  return  false  ;  [FE]  The  validated  object  is  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  boolean  canContain  (  Tag  child  )  {  Validate  .  notNull  (  child  )  ;    if  (  child  .  isBlock  &&  !this  .  canContainBlock  )  return  false  ;    if  (  !child  .  isBlock  &&  !this  .  canContainInline  )  //  not  block  =  =  inline  return  false  ;    if  (  this  .  optionalClosing  &&  this  .  equals  (  child  )  )  return  false  ;    if  (  this  .  empty  ||  this  .  isData  (  )  )  return  false  ;        if  (  this  .  tagName  .  equals  (   "head "  )  )  {  if  (  child  .  tagName  .  equals  (   "base "  )  ||  child  .  tagName  .  equals  (   "script "  )  ||  child  .  tagName  .  equals  (   "noscript "  )  ||  child  .  tagName  .  equals  (   "link "  )  ||  child  .  tagName  .  equals  (   "meta "  )  ||  child  .  tagName  .  equals  (   "title "  )  ||  child  .  tagName  .  equals  (   "style "  )  ||  child  .  tagName  .  equals  (   "object "  )  )  {  return  true  ;  }  return  false  ;  }    if  (  this  .  tagName  .  equals  (   "dt "  )  &&  child  .  tagName  .  equals  (   "dd "  )  )  return  false  ;  if  (  this  .  tagName  .  equals  (   "dd "  )  &&  child  .  tagName  .  equals  (   "dt "  )  )  return  false  ;    [ATTENTION]  return  false  ;  }    [METHOD]  canContain  [TYPE]  boolean  [PARAMETER]  Tag  child  [CLASS]  Tag    [TYPE]  List  ancestors  [TYPE]  boolean  canContainBlock  canContainInline  empty  false  isBlock  optionalClosing  preserveWhitespace  true  [TYPE]  Tag  child  defaultAncestor  tag  [TYPE]  String  tagName  [TYPE]  Map  tags  
[REPLACE]  return  isBlock;	[BUGGY]  return  !isBlock  ;  [FE]  expected:<<pre>[]<code>code  assertEquals( "code\n\ncode "  ,  doc.text())  ;  assertEquals( "<pre><code>code\n\ncode</code></pre> "  ,  doc.body().html())  ;  [CONTEXT]  public  boolean  isBlock  (  )  {  [ATTENTION]  return  !isBlock  ;  }    [METHOD]  isBlock  [TYPE]  boolean  [PARAMETER]  [CLASS]  Tag    [TYPE]  List  ancestors  [TYPE]  boolean  canContainBlock  canContainInline  empty  false  isBlock  optionalClosing  preserveWhitespace  true  [TYPE]  Tag  child  defaultAncestor  tag  [TYPE]  String  tagName  [TYPE]  Map  tags  
[REPLACE]  return  canContainBlock;	[BUGGY]  return  tag  ;  [CE]  cannot  find  symbol  tag  [CONTEXT]  public  boolean  canContainBlock  (  )  {  [ATTENTION]  return  tag  ;  }    [METHOD]  canContainBlock  [TYPE]  boolean  [PARAMETER]  [CLASS]  Tag    [TYPE]  List  ancestors  [TYPE]  boolean  canContainBlock  canContainInline  empty  false  isBlock  optionalClosing  preserveWhitespace  true  [TYPE]  Tag  child  defaultAncestor  tag  [TYPE]  String  tagName  [TYPE]  Map  tags  
[REPLACE]  return  !isBlock;	[BUGGY]  return  isBlock  ;  [NO-ERROR]  [CONTEXT]  public  boolean  isInline  (  )  {  [ATTENTION]  return  isBlock  ;  }    [METHOD]  isInline  [TYPE]  boolean  [PARAMETER]  [CLASS]  Tag    [TYPE]  List  ancestors  [TYPE]  boolean  canContainBlock  canContainInline  empty  false  isBlock  optionalClosing  preserveWhitespace  true  [TYPE]  Tag  child  defaultAncestor  tag  [TYPE]  String  tagName  [TYPE]  Map  tags  
[REPLACE]  return  !canContainInline  &&  !isEmpty  (  )  ;	[BUGGY]  return  canContainInline  ||  !isEmpty  (  )  ;  [FE]  The  validated  object  is  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  boolean  isData  (  )  {  [ATTENTION]  return  canContainInline  ||  !isEmpty  (  )    ;  }    [METHOD]  isData  [TYPE]  boolean  [PARAMETER]  [CLASS]  Tag    [TYPE]  List  ancestors  [TYPE]  boolean  canContainBlock  canContainInline  empty  false  isBlock  optionalClosing  preserveWhitespace  true  [TYPE]  Tag  child  defaultAncestor  tag  [TYPE]  String  tagName  [TYPE]  Map  tags  
[REPLACE]  return  empty;	[BUGGY]  return  tag  ;  [CE]  cannot  find  symbol  tag  [CONTEXT]  public  boolean  isEmpty  (  )  {  [ATTENTION]  return  tag  ;  }    [METHOD]  isEmpty  [TYPE]  boolean  [PARAMETER]  [CLASS]  Tag    [TYPE]  List  ancestors  [TYPE]  boolean  canContainBlock  canContainInline  empty  false  isBlock  optionalClosing  preserveWhitespace  true  [TYPE]  Tag  child  defaultAncestor  tag  [TYPE]  String  tagName  [TYPE]  Map  tags  
[REPLACE]  return  preserveWhitespace;	[BUGGY]  return  tag  ;  [CE]  cannot  find  symbol  tag  [CONTEXT]  public  boolean  preserveWhitespace  (  )  {  [ATTENTION]  return  tag  ;  }    [METHOD]  preserveWhitespace  [TYPE]  boolean  [PARAMETER]  [CLASS]  Tag    [TYPE]  List  ancestors  [TYPE]  boolean  canContainBlock  canContainInline  empty  false  isBlock  optionalClosing  preserveWhitespace  true  [TYPE]  Tag  child  defaultAncestor  tag  [TYPE]  String  tagName  [TYPE]  Map  tags  
[REPLACE]  return  (  !ancestors  .  isEmpty  (  )  )  ?  ancestors  .  get  (  0  )  :  null;	[BUGGY]  return  (  !ancestors  .  isEmpty  (  )  )  ?  ancestors  .  add  (  0  )  :  null  ;  [CE]  no  suitable  method  found  for  add(int)  [CONTEXT]  Tag  getImplicitParent  (  )  {  [ATTENTION]  return  (  !ancestors  .  isEmpty  (  )  )  ?  ancestors  .  add  (  0  )  :  null  ;  }    [METHOD]  getImplicitParent  [TYPE]  Tag  [PARAMETER]  [CLASS]  Tag    [TYPE]  List  ancestors  [TYPE]  boolean  canContainBlock  canContainInline  empty  false  isBlock  optionalClosing  preserveWhitespace  true  [TYPE]  Tag  child  defaultAncestor  tag  [TYPE]  String  tagName  [TYPE]  Map  tags  
[REPLACE]  if  (  child  .  ancestors  .  isEmpty  (  )  )  return  true;	[BUGGY]  if  (  child  .  ancestors  .  isEmpty  (  )  )  return  false  ;  [NO-ERROR]  [CONTEXT]  boolean  isValidParent  (  Tag  child  )  {  [ATTENTION]  if  (  child  .  ancestors  .  isEmpty  (  )  )  return  false  ;    for  (  Tag  tag  :  child  .  ancestors  )  {  if  (  this  .  equals  (  tag  )  )  return  true  ;  }  return  false  ;  }    [METHOD]  isValidParent  [TYPE]  boolean  [PARAMETER]  Tag  child  [CLASS]  Tag    [TYPE]  List  ancestors  [TYPE]  boolean  canContainBlock  canContainInline  empty  false  isBlock  optionalClosing  preserveWhitespace  true  [TYPE]  Tag  child  defaultAncestor  tag  [TYPE]  String  tagName  [TYPE]  Map  tags  
[REPLACE]  return  true;	[BUGGY]  return  false  ;  [NO-ERROR]  [CONTEXT]  boolean  isValidParent  (  Tag  child  )  {  if  (  child  .  ancestors  .  isEmpty  (  )  )  [ATTENTION]  return  false  ;    for  (  Tag  tag  :  child  .  ancestors  )  {  if  (  this  .  equals  (  tag  )  )  return  true  ;  }  return  false  ;  }    [METHOD]  isValidParent  [TYPE]  boolean  [PARAMETER]  Tag  child  [CLASS]  Tag    [TYPE]  List  ancestors  [TYPE]  boolean  canContainBlock  canContainInline  empty  false  isBlock  optionalClosing  preserveWhitespace  true  [TYPE]  Tag  child  defaultAncestor  tag  [TYPE]  String  tagName  [TYPE]  Map  tags  
[REPLACE]  if  (  this  .  equals  (  tag  )  )  return  true;	[BUGGY]  if  (  this  .  equals  (  tag  )  )  return  false  ;  [FE]  AssertionFailedError    expected:<12>  but  was:<0>  assertEquals( "ipod  -  Google  Search "  ,  doc.title())  ;  assertEquals(12  ,  results.size())  ;  assertEquals( "http://news.google.com/news?hl  =  en&q  =  ipod&um  =  1&ie  =  UTF-8&ei  =  uYlKS4SbBoGg6gPf-5XXCw&sa  =  X&oi  =  news_group&ct  =  title&resnum  =  1&ved  =  0CCIQsQQwAA "  ,  assertEquals( "http://www.apple.com/itunes/ "  ,  [CONTEXT]  boolean  isValidParent  (  Tag  child  )  {  if  (  child  .  ancestors  .  isEmpty  (  )  )  return  true  ;  //  HTML  tag  for  (  Tag  tag  :  child  .  ancestors  )  {  [ATTENTION]  if  (  this  .  equals  (  tag  )  )  return  false  ;    }  return  false  ;  }    [METHOD]  isValidParent  [TYPE]  boolean  [PARAMETER]  Tag  child  [CLASS]  Tag    [TYPE]  List  ancestors  [TYPE]  boolean  canContainBlock  canContainInline  empty  false  isBlock  optionalClosing  preserveWhitespace  true  [TYPE]  Tag  child  defaultAncestor  tag  [TYPE]  String  tagName  [TYPE]  Map  tags  
[REPLACE]  return  true;	[BUGGY]  return  false  ;  [FE]  AssertionFailedError    expected:<12>  but  was:<0>  assertEquals( "ipod  -  Google  Search "  ,  doc.title())  ;  assertEquals(12  ,  results.size())  ;  assertEquals( "http://news.google.com/news?hl  =  en&q  =  ipod&um  =  1&ie  =  UTF-8&ei  =  uYlKS4SbBoGg6gPf-5XXCw&sa  =  X&oi  =  news_group&ct  =  title&resnum  =  1&ved  =  0CCIQsQQwAA "  ,  assertEquals( "http://www.apple.com/itunes/ "  ,  [CONTEXT]  boolean  isValidParent  (  Tag  child  )  {  if  (  child  .  ancestors  .  isEmpty  (  )  )  return  true  ;  //  HTML  tag  for  (  Tag  tag  :  child  .  ancestors  )  {  if  (  this  .  equals  (  tag  )  )  [ATTENTION]  return  false  ;  }  return  false  ;  }    [METHOD]  isValidParent  [TYPE]  boolean  [PARAMETER]  Tag  child  [CLASS]  Tag    [TYPE]  List  ancestors  [TYPE]  boolean  canContainBlock  canContainInline  empty  false  isBlock  optionalClosing  preserveWhitespace  true  [TYPE]  Tag  child  defaultAncestor  tag  [TYPE]  String  tagName  [TYPE]  Map  tags  
[REPLACE]  for  (  Tag  tag  :  child  .  ancestors  )  {	[BUGGY]  for  (  String  name  :  tagNames  )  {  ancestors  .  add  (  Tag  .  valueOf  (  name  )  )  ;  [CE]  cannot  find  symbol  tagNames  [CONTEXT]  boolean  isValidParent  (  Tag  child  )  {  if  (  child  .  ancestors  .  isEmpty  (  )  )  return  true  ;  //  HTML  tag  [ATTENTION]  for  (  String  name  :  tagNames  )  {  ancestors  .  add  (  Tag  .  valueOf  (  name  )  )    ;  if  (  this  .  equals  (  tag  )  )  return  true  ;  }  return  false  ;  }    [METHOD]  isValidParent  [TYPE]  boolean  [PARAMETER]  Tag  child  [CLASS]  Tag    [TYPE]  List  ancestors  [TYPE]  boolean  canContainBlock  canContainInline  empty  false  isBlock  optionalClosing  preserveWhitespace  true  [TYPE]  Tag  child  defaultAncestor  tag  [TYPE]  String  tagName  [TYPE]  Map  tags  
[REPLACE]  return  false;	[BUGGY]  return  true  ;  [FE]  AssertionFailedError    expected:<[]Replaced>  but  was:<[Hello  ]Replaced>  assertEquals( "Replaced "  ,  doc.text())  ;  assertEquals( "Replaced "  ,  doc.body().text())  ;  assertEquals(1  ,  doc.select( "head ").size())  ;  [CONTEXT]  boolean  isValidParent  (  Tag  child  )  {  if  (  child  .  ancestors  .  isEmpty  (  )  )  return  true  ;  //  HTML  tag  for  (  Tag  tag  :  child  .  ancestors  )  {  if  (  this  .  equals  (  tag  )  )  return  true  ;  }  [ATTENTION]  return  true  ;  }    [METHOD]  isValidParent  [TYPE]  boolean  [PARAMETER]  Tag  child  [CLASS]  Tag    [TYPE]  List  ancestors  [TYPE]  boolean  canContainBlock  canContainInline  empty  false  isBlock  optionalClosing  preserveWhitespace  true  [TYPE]  Tag  child  defaultAncestor  tag  [TYPE]  String  tagName  [TYPE]  Map  tags  
[REPLACE]  if  (  this  ==  o  )  return  true;	[BUGGY]  if  (  tag  &&  o  )  return  true  ;  [CE]  cannot  find  symbol  tag  [CONTEXT]  public  boolean  equals  (  Object  o  )  {  [ATTENTION]  if  (  tag&&o  )  return  true  ;  if  (  o  =  =  null  ||  getClass  (  )  !  =  o  .  getClass  (  )  )  return  false  ;    Tag  tag  =    (  Tag  )  o  ;    if  (  canContainBlock  !  =  tag  .  canContainBlock  )  return  false  ;  if  (  canContainInline  !  =  tag  .  canContainInline  )  return  false  ;  if  (  empty  !  =  tag  .  empty  )  return  false  ;  if  (  isBlock  !  =  tag  .  isBlock  )  return  false  ;  if  (  optionalClosing  !  =  tag  .  optionalClosing  )  return  false  ;  if  (  tagName  !  =  null  ?  !tagName  .  equals  (  tag  .  tagName  )  :  tag  .  tagName  !  =  null  )  return  false  ;    return  true  ;  }    [METHOD]  equals  [TYPE]  boolean  [PARAMETER]  Object  o  [CLASS]  Tag    [TYPE]  List  ancestors  [TYPE]  Object  o  [TYPE]  boolean  canContainBlock  canContainInline  empty  false  isBlock  optionalClosing  preserveWhitespace  true  [TYPE]  Tag  child  defaultAncestor  tag  [TYPE]  String  tagName  [TYPE]  Map  tags  
[REPLACE]  if  (  this  ==  o  )  return  true;	[BUGGY]  if  (  this  =  =  o  )  return  false  ;  [FE]  AssertionFailedError    expected:<[Yahoo!  JAPAN]>  but  was:<[]>  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  boolean  equals  (  Object  o  )  {  [ATTENTION]  if  (  this  =  =  o  )  return  false  ;  if  (  o  =  =  null  ||  getClass  (  )  !  =  o  .  getClass  (  )  )  return  false  ;    Tag  tag  =    (  Tag  )  o  ;    if  (  canContainBlock  !  =  tag  .  canContainBlock  )  return  false  ;  if  (  canContainInline  !  =  tag  .  canContainInline  )  return  false  ;  if  (  empty  !  =  tag  .  empty  )  return  false  ;  if  (  isBlock  !  =  tag  .  isBlock  )  return  false  ;  if  (  optionalClosing  !  =  tag  .  optionalClosing  )  return  false  ;  if  (  tagName  !  =  null  ?  !tagName  .  equals  (  tag  .  tagName  )  :  tag  .  tagName  !  =  null  )  return  false  ;    return  true  ;  }    [METHOD]  equals  [TYPE]  boolean  [PARAMETER]  Object  o  [CLASS]  Tag    [TYPE]  List  ancestors  [TYPE]  Object  o  [TYPE]  boolean  canContainBlock  canContainInline  empty  false  isBlock  optionalClosing  preserveWhitespace  true  [TYPE]  Tag  child  defaultAncestor  tag  [TYPE]  String  tagName  [TYPE]  Map  tags  
[REPLACE]  if  (  o  ==  null  ||  getClass  (  )  !=  o  .  getClass  (  )  )  return  false;	[BUGGY]  if  (  o  !  =  true  ||  getClass  (  )  !  =  o  .  getClass  (  )  )  return  false  ;  [CE]  incomparable  types:  Object  and  boolean  [CONTEXT]  public  boolean  equals  (  Object  o  )  {  if  (  this  =  =  o  )  return  true  ;  [ATTENTION]  if  (  o  !  =  true  ||  getClass  (  )  !  =  o  .  getClass  (  )  )  return  false  ;    Tag  tag  =    (  Tag  )  o  ;    if  (  canContainBlock  !  =  tag  .  canContainBlock  )  return  false  ;  if  (  canContainInline  !  =  tag  .  canContainInline  )  return  false  ;  if  (  empty  !  =  tag  .  empty  )  return  false  ;  if  (  isBlock  !  =  tag  .  isBlock  )  return  false  ;  if  (  optionalClosing  !  =  tag  .  optionalClosing  )  return  false  ;  if  (  tagName  !  =  null  ?  !tagName  .  equals  (  tag  .  tagName  )  :  tag  .  tagName  !  =  null  )  return  false  ;    return  true  ;  }    [METHOD]  equals  [TYPE]  boolean  [PARAMETER]  Object  o  [CLASS]  Tag    [TYPE]  List  ancestors  [TYPE]  Object  o  [TYPE]  boolean  canContainBlock  canContainInline  empty  false  isBlock  optionalClosing  preserveWhitespace  true  [TYPE]  Tag  child  defaultAncestor  tag  [TYPE]  String  tagName  [TYPE]  Map  tags  
[REPLACE]  if  (  o  ==  null  ||  getClass  (  )  !=  o  .  getClass  (  )  )  return  false;	[BUGGY]  if  (  o  =  =  null  ||  getClass  (  )  !  =  o  .  getClass  (  )  )  return  true  ;  [NO-ERROR]  [CONTEXT]  public  boolean  equals  (  Object  o  )  {  if  (  this  =  =  o  )  return  true  ;  [ATTENTION]  if  (  o  =  =  null  ||  getClass  (  )  !  =  o  .  getClass  (  )  )  return  true  ;    Tag  tag  =    (  Tag  )  o  ;    if  (  canContainBlock  !  =  tag  .  canContainBlock  )  return  false  ;  if  (  canContainInline  !  =  tag  .  canContainInline  )  return  false  ;  if  (  empty  !  =  tag  .  empty  )  return  false  ;  if  (  isBlock  !  =  tag  .  isBlock  )  return  false  ;  if  (  optionalClosing  !  =  tag  .  optionalClosing  )  return  false  ;  if  (  tagName  !  =  null  ?  !tagName  .  equals  (  tag  .  tagName  )  :  tag  .  tagName  !  =  null  )  return  false  ;    return  true  ;  }    [METHOD]  equals  [TYPE]  boolean  [PARAMETER]  Object  o  [CLASS]  Tag    [TYPE]  List  ancestors  [TYPE]  Object  o  [TYPE]  boolean  canContainBlock  canContainInline  empty  false  isBlock  optionalClosing  preserveWhitespace  true  [TYPE]  Tag  child  defaultAncestor  tag  [TYPE]  String  tagName  [TYPE]  Map  tags  
[REPLACE]  Tag  tag  =  (  Tag  )  o;	[BUGGY]  Tag  tag  =  tags  .  get  (  tagName  )  ;  [FE]  null  assertEquals( "ipod  -  Google  Search "  ,  doc.title())  ;  assertEquals(12  ,  results.size())  ;  assertEquals( "http://news.google.com/news?hl  =  en&q  =  ipod&um  =  1&ie  =  UTF-8&ei  =  uYlKS4SbBoGg6gPf-5XXCw&sa  =  X&oi  =  news_group&ct  =  title&resnum  =  1&ved  =  0CCIQsQQwAA "  ,  assertEquals( "http://www.apple.com/itunes/ "  ,  [CONTEXT]  public  boolean  equals  (  Object  o  )  {  if  (  this  =  =  o  )  return  true  ;  if  (  o  =  =  null  ||  getClass  (  )  !  =  o  .  getClass  (  )  )  return  false  ;    [ATTENTION]  Tag  tag  =  tags  .  get  (  tagName  )    ;    if  (  canContainBlock  !  =  tag  .  canContainBlock  )  return  false  ;  if  (  canContainInline  !  =  tag  .  canContainInline  )  return  false  ;  if  (  empty  !  =  tag  .  empty  )  return  false  ;  if  (  isBlock  !  =  tag  .  isBlock  )  return  false  ;  if  (  optionalClosing  !  =  tag  .  optionalClosing  )  return  false  ;  if  (  tagName  !  =  null  ?  !tagName  .  equals  (  tag  .  tagName  )  :  tag  .  tagName  !  =  null  )  return  false  ;    return  true  ;  }    [METHOD]  equals  [TYPE]  boolean  [PARAMETER]  Object  o  [CLASS]  Tag    [TYPE]  List  ancestors  [TYPE]  Object  o  [TYPE]  boolean  canContainBlock  canContainInline  empty  false  isBlock  optionalClosing  preserveWhitespace  true  [TYPE]  Tag  child  defaultAncestor  tag  [TYPE]  String  tagName  [TYPE]  Map  tags  
[REPLACE]  if  (  canContainBlock  !=  tag  .  canContainBlock  )  return  false;	[BUGGY]  if  (  canContainBlock    =  =  true  )  return  false  ;  [FE]  AssertionFailedError    expected:  org.jsoup.parser.Tag<foo>  but  was:  org.jsoup.parser.Tag<foo>  assertEquals(foo  ,  foo2)  ;  assertTrue(foo.canContain(foo))  ;  assertTrue(foo.canContain(div))  ;  assertTrue(div.canContain(foo))  ;  [CONTEXT]  public  boolean  equals  (  Object  o  )  {  if  (  this  =  =  o  )  return  true  ;  if  (  o  =  =  null  ||  getClass  (  )  !  =  o  .  getClass  (  )  )  return  false  ;    Tag  tag  =    (  Tag  )  o  ;    [ATTENTION]  if  (  canContainBlock  =  =  true  )  return  false  ;  if  (  canContainInline  !  =  tag  .  canContainInline  )  return  false  ;  if  (  empty  !  =  tag  .  empty  )  return  false  ;  if  (  isBlock  !  =  tag  .  isBlock  )  return  false  ;  if  (  optionalClosing  !  =  tag  .  optionalClosing  )  return  false  ;  if  (  tagName  !  =  null  ?  !tagName  .  equals  (  tag  .  tagName  )  :  tag  .  tagName  !  =  null  )  return  false  ;    return  true  ;  }    [METHOD]  equals  [TYPE]  boolean  [PARAMETER]  Object  o  [CLASS]  Tag    [TYPE]  List  ancestors  [TYPE]  Object  o  [TYPE]  boolean  canContainBlock  canContainInline  empty  false  isBlock  optionalClosing  preserveWhitespace  true  [TYPE]  Tag  child  defaultAncestor  tag  [TYPE]  String  tagName  [TYPE]  Map  tags  
[REMOVE]  	[BUGGY]  if  (  (  equals  (   "dt "  )  )  &&  (  equals  (   "dd "  )  )  )      return  false  ;  [NO-ERROR]  [CONTEXT]  public  boolean  equals  (  Object  o  )  {  if  (  this  =  =  o  )  return  true  ;  if  (  o  =  =  null  ||  getClass  (  )  !  =  o  .  getClass  (  )  )  return  false  ;    Tag  tag  =    (  Tag  )  o  ;    [ATTENTION]  if  (  canContainBlock  !  =  tag  .  canContainBlock  )  return  false  ;    if  (  (  equals  (   "dt "  )  )  &&  (  equals  (   "dd "  )  )  )  return  false  ;  if  (  canContainInline  !  =  tag  .  canContainInline  )  return  false  ;  if  (  empty  !  =  tag  .  empty  )  return  false  ;  if  (  isBlock  !  =  tag  .  isBlock  )  return  false  ;  if  (  optionalClosing  !  =  tag  .  optionalClosing  )  return  false  ;  if  (  tagName  !  =  null  ?  !tagName  .  equals  (  tag  .  tagName  )  :  tag  .  tagName  !  =  null  )  return  false  ;    return  true  ;      [METHOD]  equals  [TYPE]  boolean  [PARAMETER]  Object  o  [CLASS]  Tag    [TYPE]  List  ancestors  [TYPE]  Object  o  [TYPE]  boolean  canContainBlock  canContainInline  empty  false  isBlock  optionalClosing  preserveWhitespace  true  [TYPE]  Tag  child  defaultAncestor  tag  [TYPE]  String  tagName  [TYPE]  Map  tags  
[REPLACE]  if  (  canContainBlock  !=  tag  .  canContainBlock  )  return  false;	[BUGGY]  if  (  canContainInline  !  =  tag  .  canContainInline  )  return  false  ;  [NO-ERROR]  [CONTEXT]  public  boolean  equals  (  Object  o  )  {  if  (  this  =  =  o  )  return  true  ;  if  (  o  =  =  null  ||  getClass  (  )  !  =  o  .  getClass  (  )  )  return  false  ;    Tag  tag  =    (  Tag  )  o  ;    [ATTENTION]  if  (  canContainInline  !  =  tag  .  canContainInline  )  return  false  ;  if  (  canContainInline  !  =  tag  .  canContainInline  )  return  false  ;  if  (  empty  !  =  tag  .  empty  )  return  false  ;  if  (  isBlock  !  =  tag  .  isBlock  )  return  false  ;  if  (  optionalClosing  !  =  tag  .  optionalClosing  )  return  false  ;  if  (  tagName  !  =  null  ?  !tagName  .  equals  (  tag  .  tagName  )  :  tag  .  tagName  !  =  null  )  return  false  ;    return  true  ;  }    [METHOD]  equals  [TYPE]  boolean  [PARAMETER]  Object  o  [CLASS]  Tag    [TYPE]  List  ancestors  [TYPE]  Object  o  [TYPE]  boolean  canContainBlock  canContainInline  empty  false  isBlock  optionalClosing  preserveWhitespace  true  [TYPE]  Tag  child  defaultAncestor  tag  [TYPE]  String  tagName  [TYPE]  Map  tags  
[REPLACE]  if  (  canContainBlock  !=  tag  .  canContainBlock  )  return  false;	[BUGGY]  if  (  canContainBlock  !  =  tag  .  canContainBlock  )  return  true  ;  [FE]  AssertionFailedError    expected:<17>  but  was:<19>  assertEquals( "The  boards  next  fear:  the  female  quota "  ,  doc.title())  ;  //  note  that  the  apos  in  the  source  is  a  literal    (8217)  ,  not  escaped  or  'assertEquals( "en "  ,  doc.select( "html ").attr( "xml:lang "))  ;  assertEquals(17  ,  articleBody.size())  ;  [CONTEXT]  public  boolean  equals  (  Object  o  )  {  if  (  this  =  =  o  )  return  true  ;  if  (  o  =  =  null  ||  getClass  (  )  !  =  o  .  getClass  (  )  )  return  false  ;    Tag  tag  =    (  Tag  )  o  ;    [ATTENTION]  if  (  canContainBlock  !  =  tag  .  canContainBlock  )  return  true  ;  if  (  canContainInline  !  =  tag  .  canContainInline  )  return  false  ;  if  (  empty  !  =  tag  .  empty  )  return  false  ;  if  (  isBlock  !  =  tag  .  isBlock  )  return  false  ;  if  (  optionalClosing  !  =  tag  .  optionalClosing  )  return  false  ;  if  (  tagName  !  =  null  ?  !tagName  .  equals  (  tag  .  tagName  )  :  tag  .  tagName  !  =  null  )  return  false  ;    return  true  ;  }    [METHOD]  equals  [TYPE]  boolean  [PARAMETER]  Object  o  [CLASS]  Tag    [TYPE]  List  ancestors  [TYPE]  Object  o  [TYPE]  boolean  canContainBlock  canContainInline  empty  false  isBlock  optionalClosing  preserveWhitespace  true  [TYPE]  Tag  child  defaultAncestor  tag  [TYPE]  String  tagName  [TYPE]  Map  tags  
[REPLACE]  if  (  canContainInline  !=  tag  .  canContainInline  )  return  false;	[BUGGY]  if  (  canContainInline    =  =  true  )  return  false  ;  [FE]  AssertionFailedError    expected:  org.jsoup.parser.Tag<foo>  but  was:  org.jsoup.parser.Tag<foo>  assertEquals(foo  ,  foo2)  ;  assertTrue(foo.canContain(foo))  ;  assertTrue(foo.canContain(div))  ;  assertTrue(div.canContain(foo))  ;  [CONTEXT]  public  boolean  equals  (  Object  o  )  {  if  (  this  =  =  o  )  return  true  ;  if  (  o  =  =  null  ||  getClass  (  )  !  =  o  .  getClass  (  )  )  return  false  ;    Tag  tag  =    (  Tag  )  o  ;    if  (  canContainBlock  !  =  tag  .  canContainBlock  )  return  false  ;  [ATTENTION]  if  (  canContainInline  =  =  true  )  return  false  ;  if  (  empty  !  =  tag  .  empty  )  return  false  ;  if  (  isBlock  !  =  tag  .  isBlock  )  return  false  ;  if  (  optionalClosing  !  =  tag  .  optionalClosing  )  return  false  ;  if  (  tagName  !  =  null  ?  !tagName  .  equals  (  tag  .  tagName  )  :  tag  .  tagName  !  =  null  )  return  false  ;    return  true  ;  }    [METHOD]  equals  [TYPE]  boolean  [PARAMETER]  Object  o  [CLASS]  Tag    [TYPE]  List  ancestors  [TYPE]  Object  o  [TYPE]  boolean  canContainBlock  canContainInline  empty  false  isBlock  optionalClosing  preserveWhitespace  true  [TYPE]  Tag  child  defaultAncestor  tag  [TYPE]  String  tagName  [TYPE]  Map  tags  
[ADD]  if  (  canContainInline  !=  tag  .  canContainInline  )  return  false;  if  (  empty  !=  tag  .  empty  )  return  false;  if  (  isBlock  !=  tag  .  isBlock  )  return  false;  if  (  optionalClosing  !=  tag  .  optionalClosing  )  return  false;  if  (  tagName  !=  null  ?  !tagName  .  equals  (  tag  .  tagName  )  :  tag  .  tagName  !=  null  )  return  false;	[BUGGY]  if  (  empty  !  =  tag  .  empty  )  return  false  ;  if  (  isBlock  !  =  tag  .  isBlock  )  return  false  ;  if  (  optionalClosing  !  =  tag  .  optionalClosing  )  return  false  ;  if  (  tagName  !  =  null  ?  !tagName  .  equals  (  tag  .  tagName  )  :  tag  .  tagName  !  =  null  )  return  false  ;  [NO-ERROR]  [CONTEXT]  public  boolean  equals  (  Object  o  )  {  if  (  this  =  =  o  )  return  true  ;  if  (  o  =  =  null  ||  getClass  (  )  !  =  o  .  getClass  (  )  )  return  false  ;    Tag  tag  =    (  Tag  )  o  ;    if  (  canContainBlock  !  =  tag  .  canContainBlock  )  return  false  ;  [ATTENTION]  if  (  empty  !  =  tag  .  empty  )  return  false  ;  if  (  isBlock  !  =  tag  .  isBlock  )  return  false  ;  if  (  optionalClosing  !  =  tag  .  optionalClosing  )  return  false  ;  if  (  tagName  !  =  null  ?  !tagName  .  equals  (  tag  .  tagName  )  :  tag  .  tagName  !  =  null  )  return  false  ;        return  true  ;  }    [METHOD]  equals  [TYPE]  boolean  [PARAMETER]  Object  o  [CLASS]  Tag    [TYPE]  List  ancestors  [TYPE]  Object  o  [TYPE]  boolean  canContainBlock  canContainInline  empty  false  isBlock  optionalClosing  preserveWhitespace  true  [TYPE]  Tag  child  defaultAncestor  tag  [TYPE]  String  tagName  [TYPE]  Map  tags  
[REPLACE]  if  (  canContainInline  !=  tag  .  canContainInline  )  return  false;	[BUGGY]  if  (  canContainInline  !  =  tag  .  canContainInline  )  return  true  ;  [NO-ERROR]  [CONTEXT]  public  boolean  equals  (  Object  o  )  {  if  (  this  =  =  o  )  return  true  ;  if  (  o  =  =  null  ||  getClass  (  )  !  =  o  .  getClass  (  )  )  return  false  ;    Tag  tag  =    (  Tag  )  o  ;    if  (  canContainBlock  !  =  tag  .  canContainBlock  )  return  false  ;  [ATTENTION]  if  (  canContainInline  !  =  tag  .  canContainInline  )  return  true  ;  if  (  empty  !  =  tag  .  empty  )  return  false  ;  if  (  isBlock  !  =  tag  .  isBlock  )  return  false  ;  if  (  optionalClosing  !  =  tag  .  optionalClosing  )  return  false  ;  if  (  tagName  !  =  null  ?  !tagName  .  equals  (  tag  .  tagName  )  :  tag  .  tagName  !  =  null  )  return  false  ;    return  true  ;  }    [METHOD]  equals  [TYPE]  boolean  [PARAMETER]  Object  o  [CLASS]  Tag    [TYPE]  List  ancestors  [TYPE]  Object  o  [TYPE]  boolean  canContainBlock  canContainInline  empty  false  isBlock  optionalClosing  preserveWhitespace  true  [TYPE]  Tag  child  defaultAncestor  tag  [TYPE]  String  tagName  [TYPE]  Map  tags  
[REPLACE]  if  (  empty  !=  tag  .  empty  )  return  false;	[BUGGY]  if  (  empty    =  =    defaultAncestor  .  empty  )  return  false  ;  [FE]  AssertionFailedError    expected:  org.jsoup.parser.Tag<foo>  but  was:  org.jsoup.parser.Tag<foo>  assertEquals(foo  ,  foo2)  ;  assertTrue(foo.canContain(foo))  ;  assertTrue(foo.canContain(div))  ;  assertTrue(div.canContain(foo))  ;  [CONTEXT]  public  boolean  equals  (  Object  o  )  {  if  (  this  =  =  o  )  return  true  ;  if  (  o  =  =  null  ||  getClass  (  )  !  =  o  .  getClass  (  )  )  return  false  ;    Tag  tag  =    (  Tag  )  o  ;    if  (  canContainBlock  !  =  tag  .  canContainBlock  )  return  false  ;  if  (  canContainInline  !  =  tag  .  canContainInline  )  return  false  ;  [ATTENTION]  if  (  empty  =  =  defaultAncestor  .  empty  )  return  false  ;  if  (  isBlock  !  =  tag  .  isBlock  )  return  false  ;  if  (  optionalClosing  !  =  tag  .  optionalClosing  )  return  false  ;  if  (  tagName  !  =  null  ?  !tagName  .  equals  (  tag  .  tagName  )  :  tag  .  tagName  !  =  null  )  return  false  ;    return  true  ;  }    [METHOD]  equals  [TYPE]  boolean  [PARAMETER]  Object  o  [CLASS]  Tag    [TYPE]  List  ancestors  [TYPE]  Object  o  [TYPE]  boolean  canContainBlock  canContainInline  empty  false  isBlock  optionalClosing  preserveWhitespace  true  [TYPE]  Tag  child  defaultAncestor  tag  [TYPE]  String  tagName  [TYPE]  Map  tags  
[REPLACE]  if  (  empty  !=  tag  .  empty  )  return  false;	[BUGGY]  if  (  empty  !  =  tag  .  empty  )  return  true  ;  [NO-ERROR]  [CONTEXT]  public  boolean  equals  (  Object  o  )  {  if  (  this  =  =  o  )  return  true  ;  if  (  o  =  =  null  ||  getClass  (  )  !  =  o  .  getClass  (  )  )  return  false  ;    Tag  tag  =    (  Tag  )  o  ;    if  (  canContainBlock  !  =  tag  .  canContainBlock  )  return  false  ;  if  (  canContainInline  !  =  tag  .  canContainInline  )  return  false  ;  [ATTENTION]  if  (  empty  !  =  tag  .  empty  )  return  true  ;  if  (  isBlock  !  =  tag  .  isBlock  )  return  false  ;  if  (  optionalClosing  !  =  tag  .  optionalClosing  )  return  false  ;  if  (  tagName  !  =  null  ?  !tagName  .  equals  (  tag  .  tagName  )  :  tag  .  tagName  !  =  null  )  return  false  ;    return  true  ;  }    [METHOD]  equals  [TYPE]  boolean  [PARAMETER]  Object  o  [CLASS]  Tag    [TYPE]  List  ancestors  [TYPE]  Object  o  [TYPE]  boolean  canContainBlock  canContainInline  empty  false  isBlock  optionalClosing  preserveWhitespace  true  [TYPE]  Tag  child  defaultAncestor  tag  [TYPE]  String  tagName  [TYPE]  Map  tags  
[REPLACE]  if  (  isBlock  !=  tag  .  isBlock  )  return  false;	[BUGGY]  if  (  isBlock    =  =  preserveWhitespace  )  return  false  ;  [FE]  AssertionFailedError    expected:  org.jsoup.parser.Tag<foo>  but  was:  org.jsoup.parser.Tag<foo>  assertEquals(foo  ,  foo2)  ;  assertTrue(foo.canContain(foo))  ;  assertTrue(foo.canContain(div))  ;  assertTrue(div.canContain(foo))  ;  [CONTEXT]  public  boolean  equals  (  Object  o  )  {  if  (  this  =  =  o  )  return  true  ;  if  (  o  =  =  null  ||  getClass  (  )  !  =  o  .  getClass  (  )  )  return  false  ;    Tag  tag  =    (  Tag  )  o  ;    if  (  canContainBlock  !  =  tag  .  canContainBlock  )  return  false  ;  if  (  canContainInline  !  =  tag  .  canContainInline  )  return  false  ;  if  (  empty  !  =  tag  .  empty  )  return  false  ;  [ATTENTION]  if  (  isBlock  =  =  preserveWhitespace  )  return  false  ;  if  (  optionalClosing  !  =  tag  .  optionalClosing  )  return  false  ;  if  (  tagName  !  =  null  ?  !tagName  .  equals  (  tag  .  tagName  )  :  tag  .  tagName  !  =  null  )  return  false  ;    return  true  ;  }    [METHOD]  equals  [TYPE]  boolean  [PARAMETER]  Object  o  [CLASS]  Tag    [TYPE]  List  ancestors  [TYPE]  Object  o  [TYPE]  boolean  canContainBlock  canContainInline  empty  false  isBlock  optionalClosing  preserveWhitespace  true  [TYPE]  Tag  child  defaultAncestor  tag  [TYPE]  String  tagName  [TYPE]  Map  tags  
[ADD]  if  (  isBlock  !=  tag  .  isBlock  )  return  false;  if  (  optionalClosing  !=  tag  .  optionalClosing  )  return  false;  if  (  tagName  !=  null  ?  !tagName  .  equals  (  tag  .  tagName  )  :  tag  .  tagName  !=  null  )  return  false;  return  true;	[BUGGY]  [CE]  missing  return  statement  [CONTEXT]  public  boolean  equals  (  Object  o  )  {  if  (  this  =  =  o  )  return  true  ;  if  (  o  =  =  null  ||  getClass  (  )  !  =  o  .  getClass  (  )  )  return  false  ;    Tag  tag  =    (  Tag  )  o  ;    if  (  canContainBlock  !  =  tag  .  canContainBlock  )  return  false  ;  if  (  canContainInline  !  =  tag  .  canContainInline  )  return  false  ;  if  (  empty  !  =  tag  .  empty  )  return  false  ;  [ATTENTION]      }    [METHOD]  equals  [TYPE]  boolean  [PARAMETER]  Object  o  [CLASS]  Tag    [TYPE]  List  ancestors  [TYPE]  Object  o  [TYPE]  boolean  canContainBlock  canContainInline  empty  false  isBlock  optionalClosing  preserveWhitespace  true  [TYPE]  Tag  child  defaultAncestor  tag  [TYPE]  String  tagName  [TYPE]  Map  tags  
[REPLACE]  if  (  isBlock  !=  tag  .  isBlock  )  return  false;	[BUGGY]  if  (  isBlock  !  =  tag  .  isBlock  )  return  true  ;  [FE]  AssertionFailedError    expected:<[]Replaced>  but  was:<[Hello  ]Replaced>  assertEquals( "Replaced "  ,  doc.text())  ;  assertEquals( "Replaced "  ,  doc.body().text())  ;  assertEquals(1  ,  doc.select( "head ").size())  ;  [CONTEXT]  public  boolean  equals  (  Object  o  )  {  if  (  this  =  =  o  )  return  true  ;  if  (  o  =  =  null  ||  getClass  (  )  !  =  o  .  getClass  (  )  )  return  false  ;    Tag  tag  =    (  Tag  )  o  ;    if  (  canContainBlock  !  =  tag  .  canContainBlock  )  return  false  ;  if  (  canContainInline  !  =  tag  .  canContainInline  )  return  false  ;  if  (  empty  !  =  tag  .  empty  )  return  false  ;  [ATTENTION]  if  (  isBlock  !  =  tag  .  isBlock  )  return  true  ;  if  (  optionalClosing  !  =  tag  .  optionalClosing  )  return  false  ;  if  (  tagName  !  =  null  ?  !tagName  .  equals  (  tag  .  tagName  )  :  tag  .  tagName  !  =  null  )  return  false  ;    return  true  ;  }    [METHOD]  equals  [TYPE]  boolean  [PARAMETER]  Object  o  [CLASS]  Tag    [TYPE]  List  ancestors  [TYPE]  Object  o  [TYPE]  boolean  canContainBlock  canContainInline  empty  false  isBlock  optionalClosing  preserveWhitespace  true  [TYPE]  Tag  child  defaultAncestor  tag  [TYPE]  String  tagName  [TYPE]  Map  tags  
[REPLACE]  if  (  optionalClosing  !=  tag  .  optionalClosing  )  return  false;	[BUGGY]  if  (  optionalClosing    =  =    defaultAncestor  .  optionalClosing  )  return  false  ;  [FE]  AssertionFailedError    expected:  org.jsoup.parser.Tag<foo>  but  was:  org.jsoup.parser.Tag<foo>  assertEquals(foo  ,  foo2)  ;  assertTrue(foo.canContain(foo))  ;  assertTrue(foo.canContain(div))  ;  assertTrue(div.canContain(foo))  ;  [CONTEXT]  public  boolean  equals  (  Object  o  )  {  if  (  this  =  =  o  )  return  true  ;  if  (  o  =  =  null  ||  getClass  (  )  !  =  o  .  getClass  (  )  )  return  false  ;    Tag  tag  =    (  Tag  )  o  ;    if  (  canContainBlock  !  =  tag  .  canContainBlock  )  return  false  ;  if  (  canContainInline  !  =  tag  .  canContainInline  )  return  false  ;  if  (  empty  !  =  tag  .  empty  )  return  false  ;  if  (  isBlock  !  =  tag  .  isBlock  )  return  false  ;  [ATTENTION]  if  (  optionalClosing  =  =  defaultAncestor  .  optionalClosing  )  return  false  ;  if  (  tagName  !  =  null  ?  !tagName  .  equals  (  tag  .  tagName  )  :  tag  .  tagName  !  =  null  )  return  false  ;    return  true  ;  }    [METHOD]  equals  [TYPE]  boolean  [PARAMETER]  Object  o  [CLASS]  Tag    [TYPE]  List  ancestors  [TYPE]  Object  o  [TYPE]  boolean  canContainBlock  canContainInline  empty  false  isBlock  optionalClosing  preserveWhitespace  true  [TYPE]  Tag  child  defaultAncestor  tag  [TYPE]  String  tagName  [TYPE]  Map  tags  
[ADD]  if  (  optionalClosing  !=  tag  .  optionalClosing  )  return  false;  if  (  tagName  !=  null  ?  !tagName  .  equals  (  tag  .  tagName  )  :  tag  .  tagName  !=  null  )  return  false;  return  true;  }	[BUGGY]  if  (  tagName  !  =  null  ?  !tagName  .  equals  (  tag  .  tagName  )  :  tag  .  tagName  !  =  null  )  return  false  ;  return  true  ;  [CE]  '  ;  '  expected  [CONTEXT]  public  boolean  equals  (  Object  o  )  {  if  (  this  =  =  o  )  return  true  ;  if  (  o  =  =  null  ||  getClass  (  )  !  =  o  .  getClass  (  )  )  return  false  ;    Tag  tag  =    (  Tag  )  o  ;    if  (  canContainBlock  !  =  tag  .  canContainBlock  )  return  false  ;  if  (  canContainInline  !  =  tag  .  canContainInline  )  return  false  ;  if  (  empty  !  =  tag  .  empty  )  return  false  ;  if  (  isBlock  !  =  tag  .  isBlock  )  return  false  ;  [ATTENTION]  if  (  tagName  !  =  null  ?  !tagName  .  equals  (  tag  .  tagName  )  :  tag  .  tagName  !  =  null  )  return  false  ;  return  true  ;          [METHOD]  equals  [TYPE]  boolean  [PARAMETER]  Object  o  [CLASS]  Tag    [TYPE]  List  ancestors  [TYPE]  Object  o  [TYPE]  boolean  canContainBlock  canContainInline  empty  false  isBlock  optionalClosing  preserveWhitespace  true  [TYPE]  Tag  child  defaultAncestor  tag  [TYPE]  String  tagName  [TYPE]  Map  tags  
[REPLACE]  if  (  optionalClosing  !=  tag  .  optionalClosing  )  return  false;	[BUGGY]  if  (  optionalClosing  !  =  tag  .  optionalClosing  )  return  true  ;  [FE]  AssertionFailedError    expected:<[Deprecated]>  but  was:<[]>  assertEquals( "Deprecated "  ,  a.text())  ;  assertEquals( "font "  ,  a.child(0).tagName())  ;  assertEquals( "b "  ,  a.child(0).child(0).tagName())  ;  [CONTEXT]  public  boolean  equals  (  Object  o  )  {  if  (  this  =  =  o  )  return  true  ;  if  (  o  =  =  null  ||  getClass  (  )  !  =  o  .  getClass  (  )  )  return  false  ;    Tag  tag  =    (  Tag  )  o  ;    if  (  canContainBlock  !  =  tag  .  canContainBlock  )  return  false  ;  if  (  canContainInline  !  =  tag  .  canContainInline  )  return  false  ;  if  (  empty  !  =  tag  .  empty  )  return  false  ;  if  (  isBlock  !  =  tag  .  isBlock  )  return  false  ;  [ATTENTION]  if  (  optionalClosing  !  =  tag  .  optionalClosing  )  return  true  ;  if  (  tagName  !  =  null  ?  !tagName  .  equals  (  tag  .  tagName  )  :  tag  .  tagName  !  =  null  )  return  false  ;    return  true  ;  }    [METHOD]  equals  [TYPE]  boolean  [PARAMETER]  Object  o  [CLASS]  Tag    [TYPE]  List  ancestors  [TYPE]  Object  o  [TYPE]  boolean  canContainBlock  canContainInline  empty  false  isBlock  optionalClosing  preserveWhitespace  true  [TYPE]  Tag  child  defaultAncestor  tag  [TYPE]  String  tagName  [TYPE]  Map  tags  
[REPLACE]  if  (  tagName  !=  null  ?  !tagName  .  equals  (  tag  .  tagName  )  :  tag  .  tagName  !=  null  )  return  false;	[BUGGY]  if  (  tagName  !  =    tag  .  tagName  !  =  null  )  return  false  ;  [CE]  ')'  expected  [CONTEXT]  public  boolean  equals  (  Object  o  )  {  if  (  this  =  =  o  )  return  true  ;  if  (  o  =  =  null  ||  getClass  (  )  !  =  o  .  getClass  (  )  )  return  false  ;    Tag  tag  =    (  Tag  )  o  ;    if  (  canContainBlock  !  =  tag  .  canContainBlock  )  return  false  ;  if  (  canContainInline  !  =  tag  .  canContainInline  )  return  false  ;  if  (  empty  !  =  tag  .  empty  )  return  false  ;  if  (  isBlock  !  =  tag  .  isBlock  )  return  false  ;  if  (  optionalClosing  !  =  tag  .  optionalClosing  )  return  false  ;  [ATTENTION]  if  (  tagName  !  =  tag  .  tagName  !  =  null  )  return  false  ;    return  true  ;  }    [METHOD]  equals  [TYPE]  boolean  [PARAMETER]  Object  o  [CLASS]  Tag    [TYPE]  List  ancestors  [TYPE]  Object  o  [TYPE]  boolean  canContainBlock  canContainInline  empty  false  isBlock  optionalClosing  preserveWhitespace  true  [TYPE]  Tag  child  defaultAncestor  tag  [TYPE]  String  tagName  [TYPE]  Map  tags  
[ADD]  if  (  tagName  !=  null  ?  !tagName  .  equals  (  tag  .  tagName  )  :  tag  .  tagName  !=  null  )  return  false;  return  true;  }	[BUGGY]  [CE]  '  ;  '  expected  [CONTEXT]  public  boolean  equals  (  Object  o  )  {  if  (  this  =  =  o  )  return  true  ;  if  (  o  =  =  null  ||  getClass  (  )  !  =  o  .  getClass  (  )  )  return  false  ;    Tag  tag  =    (  Tag  )  o  ;    if  (  canContainBlock  !  =  tag  .  canContainBlock  )  return  false  ;  if  (  canContainInline  !  =  tag  .  canContainInline  )  return  false  ;  if  (  empty  !  =  tag  .  empty  )  return  false  ;  if  (  isBlock  !  =  tag  .  isBlock  )  return  false  ;  if  (  optionalClosing  !  =  tag  .  optionalClosing  )  return  false  ;  [ATTENTION]        [METHOD]  equals  [TYPE]  boolean  [PARAMETER]  Object  o  [CLASS]  Tag    [TYPE]  List  ancestors  [TYPE]  Object  o  [TYPE]  boolean  canContainBlock  canContainInline  empty  false  isBlock  optionalClosing  preserveWhitespace  true  [TYPE]  Tag  child  defaultAncestor  tag  [TYPE]  String  tagName  [TYPE]  Map  tags  
[REPLACE]  if  (  tagName  !=  null  ?  !tagName  .  equals  (  tag  .  tagName  )  :  tag  .  tagName  !=  null  )  return  false;	[BUGGY]  if  (  tagName  !  =  null  ?  !tagName  .  equals  (  tag  .  tagName  )  :  tag  .  tagName  !  =  null  )  return  true  ;  [FE]  AssertionFailedError    expected:<17>  but  was:<18>  assertEquals( "The  boards  next  fear:  the  female  quota "  ,  doc.title())  ;  //  note  that  the  apos  in  the  source  is  a  literal    (8217)  ,  not  escaped  or  'assertEquals( "en "  ,  doc.select( "html ").attr( "xml:lang "))  ;  assertEquals(17  ,  articleBody.size())  ;  [CONTEXT]  public  boolean  equals  (  Object  o  )  {  if  (  this  =  =  o  )  return  true  ;  if  (  o  =  =  null  ||  getClass  (  )  !  =  o  .  getClass  (  )  )  return  false  ;    Tag  tag  =    (  Tag  )  o  ;    if  (  canContainBlock  !  =  tag  .  canContainBlock  )  return  false  ;  if  (  canContainInline  !  =  tag  .  canContainInline  )  return  false  ;  if  (  empty  !  =  tag  .  empty  )  return  false  ;  if  (  isBlock  !  =  tag  .  isBlock  )  return  false  ;  if  (  optionalClosing  !  =  tag  .  optionalClosing  )  return  false  ;  [ATTENTION]  if  (  tagName  !  =  null  ?  !tagName  .  equals  (  tag  .  tagName  )  :  tag  .  tagName  !  =  null  )  return  true  ;    return  true  ;  }    [METHOD]  equals  [TYPE]  boolean  [PARAMETER]  Object  o  [CLASS]  Tag    [TYPE]  List  ancestors  [TYPE]  Object  o  [TYPE]  boolean  canContainBlock  canContainInline  empty  false  isBlock  optionalClosing  preserveWhitespace  true  [TYPE]  Tag  child  defaultAncestor  tag  [TYPE]  String  tagName  [TYPE]  Map  tags  
[REPLACE]  return  true;	[BUGGY]  return  false  ;  [FE]  AssertionFailedError    expected:  org.jsoup.parser.Tag<foo>  but  was:  org.jsoup.parser.Tag<foo>  assertEquals(foo  ,  foo2)  ;  assertTrue(foo.canContain(foo))  ;  assertTrue(foo.canContain(div))  ;  assertTrue(div.canContain(foo))  ;  [CONTEXT]  public  boolean  equals  (  Object  o  )  {  if  (  this  =  =  o  )  return  true  ;  if  (  o  =  =  null  ||  getClass  (  )  !  =  o  .  getClass  (  )  )  return  false  ;    Tag  tag  =    (  Tag  )  o  ;    if  (  canContainBlock  !  =  tag  .  canContainBlock  )  return  false  ;  if  (  canContainInline  !  =  tag  .  canContainInline  )  return  false  ;  if  (  empty  !  =  tag  .  empty  )  return  false  ;  if  (  isBlock  !  =  tag  .  isBlock  )  return  false  ;  if  (  optionalClosing  !  =  tag  .  optionalClosing  )  return  false  ;  if  (  tagName  !  =  null  ?  !tagName  .  equals  (  tag  .  tagName  )  :  tag  .  tagName  !  =  null  )  return  false  ;    [ATTENTION]  return  false  ;  }    [METHOD]  equals  [TYPE]  boolean  [PARAMETER]  Object  o  [CLASS]  Tag    [TYPE]  List  ancestors  [TYPE]  Object  o  [TYPE]  boolean  canContainBlock  canContainInline  empty  false  isBlock  optionalClosing  preserveWhitespace  true  [TYPE]  Tag  child  defaultAncestor  tag  [TYPE]  String  tagName  [TYPE]  Map  tags  
[REPLACE]  int  result  =  tagName  !=  null  ?  tagName  .  hashCode  (  )  :  0;	[BUGGY]  int  result    =    tagName  .  hashCode  (  )    ;  [NO-ERROR]  [CONTEXT]  public  int  hashCode  (  )  {  [ATTENTION]  int  result  =  tagName  .  hashCode  (  )  ;  result  =  31  *  result  +  (  isBlock  ?  1  :  0  )  ;  result  =  31  *  result  +  (  canContainBlock  ?  1  :  0  )  ;  result  =  31  *  result  +  (  canContainInline  ?  1  :  0  )  ;  result  =  31  *  result  +  (  optionalClosing  ?  1  :  0  )  ;  result  =  31  *  result  +  (  empty  ?  1  :  0  )  ;  return  result  ;  }    [METHOD]  hashCode  [TYPE]  int  [PARAMETER]  [CLASS]  Tag    [TYPE]  List  ancestors  [TYPE]  boolean  canContainBlock  canContainInline  empty  false  isBlock  optionalClosing  preserveWhitespace  true  [TYPE]  Tag  child  defaultAncestor  tag  [TYPE]  String  tagName  [TYPE]  Map  tags  [TYPE]  int  result  
[REPLACE]  result  =  31  *  result  +  (  isBlock  ?  1  :  0  )  ;	[BUGGY]  result    =    0  )  ;  [CE]  '  ;  '  expected  [CONTEXT]  public  int  hashCode  (  )  {  int  result  =  tagName  !  =  null  ?  tagName  .  hashCode  (  )  :  0  ;  [ATTENTION]  result  =  0  )    ;  result  =  31  *  result  +  (  canContainBlock  ?  1  :  0  )  ;  result  =  31  *  result  +  (  canContainInline  ?  1  :  0  )  ;  result  =  31  *  result  +  (  optionalClosing  ?  1  :  0  )  ;  result  =  31  *  result  +  (  empty  ?  1  :  0  )  ;  return  result  ;  }    [METHOD]  hashCode  [TYPE]  int  [PARAMETER]  [CLASS]  Tag    [TYPE]  List  ancestors  [TYPE]  boolean  canContainBlock  canContainInline  empty  false  isBlock  optionalClosing  preserveWhitespace  true  [TYPE]  Tag  child  defaultAncestor  tag  [TYPE]  String  tagName  [TYPE]  Map  tags  [TYPE]  int  result  
[REPLACE]  result  =  31  *  result  +  (  canContainInline  ?  1  :  0  )  ;	[BUGGY]  result    =    0  )  ;  [CE]  '  ;  '  expected  [CONTEXT]  public  int  hashCode  (  )  {  int  result  =  tagName  !  =  null  ?  tagName  .  hashCode  (  )  :  0  ;  result  =  31  *  result  +  (  isBlock  ?  1  :  0  )  ;  result  =  31  *  result  +  (  canContainBlock  ?  1  :  0  )  ;  [ATTENTION]  result  =  0  )    ;  result  =  31  *  result  +  (  optionalClosing  ?  1  :  0  )  ;  result  =  31  *  result  +  (  empty  ?  1  :  0  )  ;  return  result  ;  }    [METHOD]  hashCode  [TYPE]  int  [PARAMETER]  [CLASS]  Tag    [TYPE]  List  ancestors  [TYPE]  boolean  canContainBlock  canContainInline  empty  false  isBlock  optionalClosing  preserveWhitespace  true  [TYPE]  Tag  child  defaultAncestor  tag  [TYPE]  String  tagName  [TYPE]  Map  tags  [TYPE]  int  result  
[REPLACE]  result  =  31  *  result  +  (  optionalClosing  ?  1  :  0  )  ;	[BUGGY]  result    =    1  ;  [NO-ERROR]  [CONTEXT]  public  int  hashCode  (  )  {  int  result  =  tagName  !  =  null  ?  tagName  .  hashCode  (  )  :  0  ;  result  =  31  *  result  +  (  isBlock  ?  1  :  0  )  ;  result  =  31  *  result  +  (  canContainBlock  ?  1  :  0  )  ;  result  =  31  *  result  +  (  canContainInline  ?  1  :  0  )  ;  [ATTENTION]  result  =  1  ;  result  =  31  *  result  +  (  empty  ?  1  :  0  )  ;  return  result  ;  }    [METHOD]  hashCode  [TYPE]  int  [PARAMETER]  [CLASS]  Tag    [TYPE]  List  ancestors  [TYPE]  boolean  canContainBlock  canContainInline  empty  false  isBlock  optionalClosing  preserveWhitespace  true  [TYPE]  Tag  child  defaultAncestor  tag  [TYPE]  String  tagName  [TYPE]  Map  tags  [TYPE]  int  result  
[REPLACE]  result  =  31  *  result  +  (  empty  ?  1  :  0  )  ;	[BUGGY]  result    =    0  )  ;  [CE]  '  ;  '  expected  [CONTEXT]  public  int  hashCode  (  )  {  int  result  =  tagName  !  =  null  ?  tagName  .  hashCode  (  )  :  0  ;  result  =  31  *  result  +  (  isBlock  ?  1  :  0  )  ;  result  =  31  *  result  +  (  canContainBlock  ?  1  :  0  )  ;  result  =  31  *  result  +  (  canContainInline  ?  1  :  0  )  ;  result  =  31  *  result  +  (  optionalClosing  ?  1  :  0  )  ;  [ATTENTION]  result  =  0  )    ;  return  result  ;  }    [METHOD]  hashCode  [TYPE]  int  [PARAMETER]  [CLASS]  Tag    [TYPE]  List  ancestors  [TYPE]  boolean  canContainBlock  canContainInline  empty  false  isBlock  optionalClosing  preserveWhitespace  true  [TYPE]  Tag  child  defaultAncestor  tag  [TYPE]  String  tagName  [TYPE]  Map  tags  [TYPE]  int  result  
[REPLACE]  return  result;	[BUGGY]  return  tag  ;  [CE]  cannot  find  symbol  tag  [CONTEXT]  public  int  hashCode  (  )  {  int  result  =  tagName  !  =  null  ?  tagName  .  hashCode  (  )  :  0  ;  result  =  31  *  result  +  (  isBlock  ?  1  :  0  )  ;  result  =  31  *  result  +  (  canContainBlock  ?  1  :  0  )  ;  result  =  31  *  result  +  (  canContainInline  ?  1  :  0  )  ;  result  =  31  *  result  +  (  optionalClosing  ?  1  :  0  )  ;  result  =  31  *  result  +  (  empty  ?  1  :  0  )  ;  [ATTENTION]  return  tag  ;  }    [METHOD]  hashCode  [TYPE]  int  [PARAMETER]  [CLASS]  Tag    [TYPE]  List  ancestors  [TYPE]  boolean  canContainBlock  canContainInline  empty  false  isBlock  optionalClosing  preserveWhitespace  true  [TYPE]  Tag  child  defaultAncestor  tag  [TYPE]  String  tagName  [TYPE]  Map  tags  [TYPE]  int  result  
[REPLACE]  return  tagName;	[BUGGY]  return  tag  ;  [CE]  cannot  find  symbol  tag  [CONTEXT]  public  String  toString  (  )  {  [ATTENTION]  return  tag  ;  }    [METHOD]  toString  [TYPE]  String  [PARAMETER]  [CLASS]  Tag    [TYPE]  List  ancestors  [TYPE]  boolean  canContainBlock  canContainInline  empty  false  isBlock  optionalClosing  preserveWhitespace  true  [TYPE]  Tag  child  defaultAncestor  tag  [TYPE]  String  tagName  [TYPE]  Map  tags  
[REPLACE]  return  register  (  new  Tag  (  tagName  )  )  ;	[BUGGY]  return  (  !ancestors  .  isEmpty  (  )  )  ?  ancestors  .  get  (  0  )  :  null  ;  [CE]  non-static  variable  ancestors  cannot  be  referenced  from  a  static  context  [CONTEXT]  private  static  Tag  createBlock  (  String  tagName  )  {  [ATTENTION]  return  (  !ancestors  .  isEmpty  (  )  )  ?  ancestors  .  get  (  0  )  :  null  ;  }    [METHOD]  createBlock  [TYPE]  Tag  [PARAMETER]  String  tagName  [CLASS]  Tag    [TYPE]  List  ancestors  [TYPE]  boolean  canContainBlock  canContainInline  empty  false  isBlock  optionalClosing  preserveWhitespace  true  [TYPE]  Tag  child  defaultAncestor  tag  [TYPE]  String  tagName  [TYPE]  Map  tags  
[REPLACE]  Tag  inline  =  new  Tag  (  tagName  )  ;	[BUGGY]  Tag  tag  =  tags  .  get  (  tagName  )  ;  [CE]  cannot  find  symbol  inline  [CONTEXT]  private  static  Tag  createInline  (  String  tagName  )  {  [ATTENTION]  Tag  tag  =  tags  .  get  (  tagName  )    ;  inline  .  isBlock  =  false  ;  inline  .  canContainBlock  =  false  ;  return  register  (  inline  )  ;  }    [METHOD]  createInline  [TYPE]  Tag  [PARAMETER]  String  tagName  [CLASS]  Tag    [TYPE]  List  ancestors  [TYPE]  boolean  canContainBlock  canContainInline  empty  false  isBlock  optionalClosing  preserveWhitespace  true  [TYPE]  Tag  child  defaultAncestor  inline  tag  [TYPE]  String  tagName  [TYPE]  Map  tags  
[REPLACE]  inline  .  isBlock  =  false;	[BUGGY]  inline  .  isBlock  =  true  ;  [FE]  AssertionFailedError    expected:<12>  but  was:<0>  assertEquals( "ipod  -  Google  Search "  ,  doc.title())  ;  assertEquals(12  ,  results.size())  ;  assertEquals( "http://news.google.com/news?hl  =  en&q  =  ipod&um  =  1&ie  =  UTF-8&ei  =  uYlKS4SbBoGg6gPf-5XXCw&sa  =  X&oi  =  news_group&ct  =  title&resnum  =  1&ved  =  0CCIQsQQwAA "  ,  assertEquals( "http://www.apple.com/itunes/ "  ,  [CONTEXT]  private  static  Tag  createInline  (  String  tagName  )  {  Tag  inline  =  new  Tag  (  tagName  )  ;  [ATTENTION]  inline  .  isBlock  =  true  ;  inline  .  canContainBlock  =  false  ;  return  register  (  inline  )  ;  }    [METHOD]  createInline  [TYPE]  Tag  [PARAMETER]  String  tagName  [CLASS]  Tag    [TYPE]  List  ancestors  [TYPE]  boolean  canContainBlock  canContainInline  empty  false  isBlock  optionalClosing  preserveWhitespace  true  [TYPE]  Tag  child  defaultAncestor  inline  tag  [TYPE]  String  tagName  [TYPE]  Map  tags  
[REPLACE]  inline  .  canContainBlock  =  false;	[BUGGY]  inline  .  canContainBlock  =  true  ;  [FE]  expected:<<pre><code>[code  assertEquals( "code\n\ncode "  ,  doc.text())  ;  assertEquals( "<pre><code>code\n\ncode</code></pre> "  ,  doc.body().html())  ;  [CONTEXT]  private  static  Tag  createInline  (  String  tagName  )  {  Tag  inline  =  new  Tag  (  tagName  )  ;  inline  .  isBlock  =  false  ;  [ATTENTION]  inline  .  canContainBlock  =  true  ;  return  register  (  inline  )  ;  }    [METHOD]  createInline  [TYPE]  Tag  [PARAMETER]  String  tagName  [CLASS]  Tag    [TYPE]  List  ancestors  [TYPE]  boolean  canContainBlock  canContainInline  empty  false  isBlock  optionalClosing  preserveWhitespace  true  [TYPE]  Tag  child  defaultAncestor  inline  tag  [TYPE]  String  tagName  [TYPE]  Map  tags  
[ADD]  inline  .  canContainBlock  =  false;	[BUGGY]  [FE]  expected:<<pre><code>[code  assertEquals( "code\n\ncode "  ,  doc.text())  ;  assertEquals( "<pre><code>code\n\ncode</code></pre> "  ,  doc.body().html())  ;  [CONTEXT]  private  static  Tag  createInline  (  String  tagName  )  {  Tag  inline  =  new  Tag  (  tagName  )  ;  inline  .  isBlock  =  false  ;  [ATTENTION]  return  register  (  inline  )  ;  }    [METHOD]  createInline  [TYPE]  Tag  [PARAMETER]  String  tagName  [CLASS]  Tag    [TYPE]  List  ancestors  [TYPE]  boolean  canContainBlock  canContainInline  empty  false  isBlock  optionalClosing  preserveWhitespace  true  [TYPE]  Tag  child  defaultAncestor  inline  tag  [TYPE]  String  tagName  [TYPE]  Map  tags  
[REPLACE]  return  register  (  inline  )  ;	[BUGGY]  return  register  (  defaultAncestor  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  private  static  Tag  createInline  (  String  tagName  )  {  Tag  inline  =  new  Tag  (  tagName  )  ;  inline  .  isBlock  =  false  ;  inline  .  canContainBlock  =  false  ;  [ATTENTION]  return  register  (  defaultAncestor  )    ;  }    [METHOD]  createInline  [TYPE]  Tag  [PARAMETER]  String  tagName  [CLASS]  Tag    [TYPE]  List  ancestors  [TYPE]  boolean  canContainBlock  canContainInline  empty  false  isBlock  optionalClosing  preserveWhitespace  true  [TYPE]  Tag  child  defaultAncestor  inline  tag  [TYPE]  String  tagName  [TYPE]  Map  tags  
[REPLACE]  tag  .  setAncestor  (  defaultAncestor  .  tagName  )  ;	[BUGGY]  tag  .  valueOf  (  defaultAncestor  .  tagName  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  private  static  Tag  register  (  Tag  tag  )  {  [ATTENTION]  tag  .  valueOf  (  defaultAncestor  .  tagName  )    ;  synchronized  (  tags  )  {  tags  .  put  (  tag  .  tagName  ,  tag  )  ;  }  return  tag  ;  }    [METHOD]  register  [TYPE]  Tag  [PARAMETER]  Tag  tag  [CLASS]  Tag    [TYPE]  List  ancestors  [TYPE]  boolean  canContainBlock  canContainInline  empty  false  isBlock  optionalClosing  preserveWhitespace  true  [TYPE]  Tag  child  defaultAncestor  inline  tag  [TYPE]  String  tagName  [TYPE]  Map  tags  
[REMOVE]  	[BUGGY]  ancestors  .  add  (  Tag  .  valueOf  (  name  )  )  ;  [CE]  cannot  find  symbol  name  [CONTEXT]  private  static  Tag  register  (  Tag  tag  )  {  [ATTENTION]  tag  .  setAncestor  (  defaultAncestor  .  tagName  )  ;    ancestors  .  add  (  Tag  .  valueOf  (  name  )  )    ;  synchronized  (  tags  )  {  tags  .  put  (  tag  .  tagName  ,  tag  )  ;  }  return  tag  ;      [METHOD]  register  [TYPE]  Tag  [PARAMETER]  Tag  tag  [CLASS]  Tag    [TYPE]  List  ancestors  [TYPE]  boolean  canContainBlock  canContainInline  empty  false  isBlock  optionalClosing  preserveWhitespace  true  [TYPE]  Tag  child  defaultAncestor  inline  tag  [TYPE]  String  tagName  [TYPE]  Map  tags  
[REPLACE]  tags  .  put  (  tag  .  tagName,  tag  )  ;	[BUGGY]  tags  .  put  (  defaultAncestor  .  tagName  ,  tag  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  private  static  Tag  register  (  Tag  tag  )  {  tag  .  setAncestor  (  defaultAncestor  .  tagName  )  ;  synchronized  (  tags  )  {  [ATTENTION]  tags  .  put  (  defaultAncestor  .  tagName  ,  tag  )    ;  }  return  tag  ;  }    [METHOD]  register  [TYPE]  Tag  [PARAMETER]  Tag  tag  [CLASS]  Tag    [TYPE]  List  ancestors  [TYPE]  boolean  canContainBlock  canContainInline  empty  false  isBlock  optionalClosing  preserveWhitespace  true  [TYPE]  Tag  child  defaultAncestor  inline  tag  [TYPE]  String  tagName  [TYPE]  Map  tags  
[ADD]  tags  .  put  (  tag  .  tagName,  tag  )  ;	[BUGGY]  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  private  static  Tag  register  (  Tag  tag  )  {  tag  .  setAncestor  (  defaultAncestor  .  tagName  )  ;  synchronized  (  tags  )  {  [ATTENTION]  }  return  tag  ;  }    [METHOD]  register  [TYPE]  Tag  [PARAMETER]  Tag  tag  [CLASS]  Tag    [TYPE]  List  ancestors  [TYPE]  boolean  canContainBlock  canContainInline  empty  false  isBlock  optionalClosing  preserveWhitespace  true  [TYPE]  Tag  child  defaultAncestor  inline  tag  [TYPE]  String  tagName  [TYPE]  Map  tags  
[REPLACE]  return  tag;	[BUGGY]  return  defaultAncestor  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  private  static  Tag  register  (  Tag  tag  )  {  tag  .  setAncestor  (  defaultAncestor  .  tagName  )  ;  synchronized  (  tags  )  {  tags  .  put  (  tag  .  tagName  ,  tag  )  ;  }  [ATTENTION]  return  defaultAncestor  ;  }    [METHOD]  register  [TYPE]  Tag  [PARAMETER]  Tag  tag  [CLASS]  Tag    [TYPE]  List  ancestors  [TYPE]  boolean  canContainBlock  canContainInline  empty  false  isBlock  optionalClosing  preserveWhitespace  true  [TYPE]  Tag  child  defaultAncestor  inline  tag  [TYPE]  String  tagName  [TYPE]  Map  tags  
[REPLACE]  canContainBlock  =  false;	[BUGGY]  canContainBlock  =  true  ;  [FE]  AssertionFailedError    expected:<...--  comment  -->Hello<[/p><p>there]</p></div></body></h...>  but  was:<...--  comment  -->Hello<[p>there</p>]</p></div></body></h...>  assertEquals( "<html><head></head><body><div  title  =  \ "Tags  &amp  ;  c.\ "><img  src  =  \ "foo.png\ "  /><p><!--  comment  -->Hello</p><p>there</p></div></body></html> "  ,  [CONTEXT]  private  Tag  setContainInlineOnly  (  )  {  [ATTENTION]  canContainBlock  =  true  ;  canContainInline  =  true  ;  return  this  ;  }    [METHOD]  setContainInlineOnly  [TYPE]  Tag  [PARAMETER]  [CLASS]  Tag    [TYPE]  List  ancestors  [TYPE]  boolean  canContainBlock  canContainInline  empty  false  isBlock  optionalClosing  preserveWhitespace  true  [TYPE]  Tag  child  defaultAncestor  inline  tag  [TYPE]  String  tagName  [TYPE]  Map  tags  
[REPLACE]  canContainInline  =  true;	[BUGGY]  canContainInline  =  false  ;  [FE]  AssertionFailedError    expected:<12>  but  was:<0>  assertEquals( "ipod  -  Google  Search "  ,  doc.title())  ;  assertEquals(12  ,  results.size())  ;  assertEquals( "http://news.google.com/news?hl  =  en&q  =  ipod&um  =  1&ie  =  UTF-8&ei  =  uYlKS4SbBoGg6gPf-5XXCw&sa  =  X&oi  =  news_group&ct  =  title&resnum  =  1&ved  =  0CCIQsQQwAA "  ,  assertEquals( "http://www.apple.com/itunes/ "  ,  [CONTEXT]  private  Tag  setContainInlineOnly  (  )  {  canContainBlock  =  false  ;  [ATTENTION]  canContainInline  =  false  ;  return  this  ;  }    [METHOD]  setContainInlineOnly  [TYPE]  Tag  [PARAMETER]  [CLASS]  Tag    [TYPE]  List  ancestors  [TYPE]  boolean  canContainBlock  canContainInline  empty  false  isBlock  optionalClosing  preserveWhitespace  true  [TYPE]  Tag  child  defaultAncestor  inline  tag  [TYPE]  String  tagName  [TYPE]  Map  tags  
[REPLACE]  return  this;	[BUGGY]  return  null  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  private  Tag  setContainInlineOnly  (  )  {  canContainBlock  =  false  ;  canContainInline  =  true  ;  [ATTENTION]  return  null  ;  }    [METHOD]  setContainInlineOnly  [TYPE]  Tag  [PARAMETER]  [CLASS]  Tag    [TYPE]  List  ancestors  [TYPE]  boolean  canContainBlock  canContainInline  empty  false  isBlock  optionalClosing  preserveWhitespace  true  [TYPE]  Tag  child  defaultAncestor  inline  tag  [TYPE]  String  tagName  [TYPE]  Map  tags  
[REPLACE]  canContainBlock  =  false;	[BUGGY]  canContainBlock  =  true  ;  [FE]  AssertionFailedError    expected:<<textarea>[three]</textarea>>  but  was:<<textarea>[  assertEquals(2  ,  els.size())  ;  assertEquals( "one "  ,  els.val())  ;  assertEquals( "two "  ,  els.last().val())  ;  assertEquals( "three "  ,  els.first().val())  ;  assertEquals( "three "  ,  els.last().val())  ;  assertEquals( "<textarea>three</textarea> "  ,  els.last().outerHtml())  ;  [CONTEXT]  private  Tag  setContainDataOnly  (  )  {  [ATTENTION]  canContainBlock  =  true  ;  canContainInline  =  false  ;  preserveWhitespace  =  true  ;  return  this  ;  }    [METHOD]  setContainDataOnly  [TYPE]  Tag  [PARAMETER]  [CLASS]  Tag    [TYPE]  List  ancestors  [TYPE]  boolean  canContainBlock  canContainInline  empty  false  isBlock  optionalClosing  preserveWhitespace  true  [TYPE]  Tag  child  defaultAncestor  inline  tag  [TYPE]  String  tagName  [TYPE]  Map  tags  
[REPLACE]  canContainInline  =  false;	[BUGGY]  canContainInline  =  true  ;  [FE]  AssertionFailedError    expected:<[font-family:  bold]>  but  was:<[]>  assertEquals( "font-family:  bold "  ,  tels.get(0).data())  ;  assertEquals( " "  ,  tels.get(0).text())  ;  assertEquals( "Hello  There "  ,  doc.text())  ;  assertEquals( "Nope "  ,  doc.data())  ;  [CONTEXT]  private  Tag  setContainDataOnly  (  )  {  canContainBlock  =  false  ;  [ATTENTION]  canContainInline  =  true  ;  preserveWhitespace  =  true  ;  return  this  ;  }    [METHOD]  setContainDataOnly  [TYPE]  Tag  [PARAMETER]  [CLASS]  Tag    [TYPE]  List  ancestors  [TYPE]  boolean  canContainBlock  canContainInline  empty  false  isBlock  optionalClosing  preserveWhitespace  true  [TYPE]  Tag  child  defaultAncestor  inline  tag  [TYPE]  String  tagName  [TYPE]  Map  tags  
[REPLACE]  preserveWhitespace  =  true;	[BUGGY]  preserveWhitespace  =  false  ;  [NO-ERROR]  [CONTEXT]  private  Tag  setContainDataOnly  (  )  {  canContainBlock  =  false  ;  canContainInline  =  false  ;  [ATTENTION]  preserveWhitespace  =  false  ;  return  this  ;  }    [METHOD]  setContainDataOnly  [TYPE]  Tag  [PARAMETER]  [CLASS]  Tag    [TYPE]  List  ancestors  [TYPE]  boolean  canContainBlock  canContainInline  empty  false  isBlock  optionalClosing  preserveWhitespace  true  [TYPE]  Tag  child  defaultAncestor  inline  tag  [TYPE]  String  tagName  [TYPE]  Map  tags  
[REPLACE]  return  this;	[BUGGY]  return  null  ;  [NO-ERROR]  [CONTEXT]  private  Tag  setContainDataOnly  (  )  {  canContainBlock  =  false  ;  canContainInline  =  false  ;  preserveWhitespace  =  true  ;  [ATTENTION]  return  null  ;  }    [METHOD]  setContainDataOnly  [TYPE]  Tag  [PARAMETER]  [CLASS]  Tag    [TYPE]  List  ancestors  [TYPE]  boolean  canContainBlock  canContainInline  empty  false  isBlock  optionalClosing  preserveWhitespace  true  [TYPE]  Tag  child  defaultAncestor  inline  tag  [TYPE]  String  tagName  [TYPE]  Map  tags  
[REPLACE]  canContainBlock  =  false;	[BUGGY]  canContainBlock  =  true  ;  [NO-ERROR]  [CONTEXT]  private  Tag  setEmpty  (  )  {  [ATTENTION]  canContainBlock  =  true  ;  canContainInline  =  false  ;  empty  =  true  ;  return  this  ;  }    [METHOD]  setEmpty  [TYPE]  Tag  [PARAMETER]  [CLASS]  Tag    [TYPE]  List  ancestors  [TYPE]  boolean  canContainBlock  canContainInline  empty  false  isBlock  optionalClosing  preserveWhitespace  true  [TYPE]  Tag  child  defaultAncestor  inline  tag  [TYPE]  String  tagName  [TYPE]  Map  tags  
[REPLACE]  canContainInline  =  false;	[BUGGY]  canContainInline  =  true  ;  [NO-ERROR]  [CONTEXT]  private  Tag  setEmpty  (  )  {  canContainBlock  =  false  ;  [ATTENTION]  canContainInline  =  true  ;  empty  =  true  ;  return  this  ;  }    [METHOD]  setEmpty  [TYPE]  Tag  [PARAMETER]  [CLASS]  Tag    [TYPE]  List  ancestors  [TYPE]  boolean  canContainBlock  canContainInline  empty  false  isBlock  optionalClosing  preserveWhitespace  true  [TYPE]  Tag  child  defaultAncestor  inline  tag  [TYPE]  String  tagName  [TYPE]  Map  tags  
[REPLACE]  empty  =  true;	[BUGGY]  empty  =  false  ;  [FE]  AssertionFailedError    expected:<[Yahoo!  JAPAN]>  but  was:<[]>  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  private  Tag  setEmpty  (  )  {  canContainBlock  =  false  ;  canContainInline  =  false  ;  [ATTENTION]  empty  =  false  ;  return  this  ;  }    [METHOD]  setEmpty  [TYPE]  Tag  [PARAMETER]  [CLASS]  Tag    [TYPE]  List  ancestors  [TYPE]  boolean  canContainBlock  canContainInline  empty  false  isBlock  optionalClosing  preserveWhitespace  true  [TYPE]  Tag  child  defaultAncestor  inline  tag  [TYPE]  String  tagName  [TYPE]  Map  tags  
[REPLACE]  return  this;	[BUGGY]  return  null  ;  [NO-ERROR]  [CONTEXT]  private  Tag  setEmpty  (  )  {  canContainBlock  =  false  ;  canContainInline  =  false  ;  empty  =  true  ;  [ATTENTION]  return  null  ;  }    [METHOD]  setEmpty  [TYPE]  Tag  [PARAMETER]  [CLASS]  Tag    [TYPE]  List  ancestors  [TYPE]  boolean  canContainBlock  canContainInline  empty  false  isBlock  optionalClosing  preserveWhitespace  true  [TYPE]  Tag  child  defaultAncestor  inline  tag  [TYPE]  String  tagName  [TYPE]  Map  tags  
[REPLACE]  optionalClosing  =  true;	[BUGGY]  optionalClosing  =  false  ;  [FE]  AssertionFailedError    expected:<2>  but  was:<1>  assertEquals(1  ,  ol.size())  ;  assertEquals(2  ,  ol.get(0).children().size())  ;  assertEquals(0  ,  doc2.select( "ul ").size())  ;  assertEquals(1  ,  doc2.select( "ol ").size())  ;  assertEquals(2  ,  doc2.select( "ol  li ").size())  ;  assertEquals(2  ,  doc2.select( "ol  li  p ").size())  ;  assertEquals(1  ,  doc2.select( "ol  li ").get(0).children().size())  ;  //  one  p  in  first  li  [CONTEXT]  private  Tag  setOptionalClosing  (  )  {  [ATTENTION]  optionalClosing  =  false  ;  return  this  ;  }    [METHOD]  setOptionalClosing  [TYPE]  Tag  [PARAMETER]  [CLASS]  Tag    [TYPE]  List  ancestors  [TYPE]  boolean  canContainBlock  canContainInline  empty  false  isBlock  optionalClosing  preserveWhitespace  true  [TYPE]  Tag  child  defaultAncestor  inline  tag  [TYPE]  String  tagName  [TYPE]  Map  tags  
[ADD]  optionalClosing  =  true;	[BUGGY]  [FE]  AssertionFailedError    expected:<2>  but  was:<1>  assertEquals(1  ,  ol.size())  ;  assertEquals(2  ,  ol.get(0).children().size())  ;  assertEquals(0  ,  doc2.select( "ul ").size())  ;  assertEquals(1  ,  doc2.select( "ol ").size())  ;  assertEquals(2  ,  doc2.select( "ol  li ").size())  ;  assertEquals(2  ,  doc2.select( "ol  li  p ").size())  ;  assertEquals(1  ,  doc2.select( "ol  li ").get(0).children().size())  ;  //  one  p  in  first  li  [CONTEXT]  private  Tag  setOptionalClosing  (  )  {  [ATTENTION]  return  this  ;  }    [METHOD]  setOptionalClosing  [TYPE]  Tag  [PARAMETER]  [CLASS]  Tag    [TYPE]  List  ancestors  [TYPE]  boolean  canContainBlock  canContainInline  empty  false  isBlock  optionalClosing  preserveWhitespace  true  [TYPE]  Tag  child  defaultAncestor  inline  tag  [TYPE]  String  tagName  [TYPE]  Map  tags  
[REPLACE]  return  this;	[BUGGY]  return  null  ;  [NO-ERROR]  [CONTEXT]  private  Tag  setOptionalClosing  (  )  {  optionalClosing  =  true  ;  [ATTENTION]  return  null  ;  }    [METHOD]  setOptionalClosing  [TYPE]  Tag  [PARAMETER]  [CLASS]  Tag    [TYPE]  List  ancestors  [TYPE]  boolean  canContainBlock  canContainInline  empty  false  isBlock  optionalClosing  preserveWhitespace  true  [TYPE]  Tag  child  defaultAncestor  inline  tag  [TYPE]  String  tagName  [TYPE]  Map  tags  
[REPLACE]  preserveWhitespace  =  true;	[BUGGY]  preserveWhitespace  =  false  ;  [FE]  expected:<code[  assertEquals( "code\n\ncode "  ,  doc.text())  ;  assertEquals( "<pre><code>code\n\ncode</code></pre> "  ,  doc.body().html())  ;  [CONTEXT]  private  Tag  setPreserveWhitespace  (  )  {  [ATTENTION]  preserveWhitespace  =  false  ;  return  this  ;  }    [METHOD]  setPreserveWhitespace  [TYPE]  Tag  [PARAMETER]  [CLASS]  Tag    [TYPE]  List  ancestors  [TYPE]  boolean  canContainBlock  canContainInline  empty  false  isBlock  optionalClosing  preserveWhitespace  true  [TYPE]  Tag  child  defaultAncestor  inline  tag  [TYPE]  String  tagName  [TYPE]  Map  tags  
[REPLACE]  return  this;	[BUGGY]  return  null  ;  [NO-ERROR]  [CONTEXT]  private  Tag  setPreserveWhitespace  (  )  {  preserveWhitespace  =  true  ;  [ATTENTION]  return  null  ;  }    [METHOD]  setPreserveWhitespace  [TYPE]  Tag  [PARAMETER]  [CLASS]  Tag    [TYPE]  List  ancestors  [TYPE]  boolean  canContainBlock  canContainInline  empty  false  isBlock  optionalClosing  preserveWhitespace  true  [TYPE]  Tag  child  defaultAncestor  inline  tag  [TYPE]  String  tagName  [TYPE]  Map  tags  
[REPLACE]  if  (  tagNames  ==  null  )  {	[BUGGY]  if  (  tagNames  !  =  null  )  {[FE]  AssertionFailedError    expected:<[]Replaced>  but  was:<[Hello  ]Replaced>  assertEquals( "Replaced "  ,  doc.text())  ;  assertEquals( "Replaced "  ,  doc.body().text())  ;  assertEquals(1  ,  doc.select( "head ").size())  ;  [CONTEXT]  private  Tag  setAncestor  (  String  .  .  .  tagNames  )  {  [ATTENTION]  if  (  tagNames  !  =  null  )  {  ancestors  =  Collections  .  emptyList  (  )  ;  }  else  {  ancestors  =  new  ArrayList<Tag>  (  tagNames  .  length  )  ;  for  (  String  name  :  tagNames  )  {  ancestors  .  add  (  Tag  .  valueOf  (  name  )  )  ;  }  }  return  this  ;  }    [METHOD]  setAncestor  [TYPE]  Tag  [PARAMETER]  tagNames  [CLASS]  Tag    [TYPE]  List  ancestors  [TYPE]  boolean  canContainBlock  canContainInline  empty  false  isBlock  optionalClosing  preserveWhitespace  true  [TYPE]  Tag  child  defaultAncestor  inline  tag  [TYPE]  String  name  tagName  [TYPE]  String[]  tagNames  [TYPE]  Map  tags  
[REPLACE]  ancestors  =  new  ArrayList<Tag>  (  tagNames  .  length  )  ;	[BUGGY]  ancestors  =    new  ArrayList<Tag>  (  null  .  length  )  ;  [CE]  <null>  cannot  be  dereferenced  [CONTEXT]  private  Tag  setAncestor  (  String  .  .  .  tagNames  )  {  if  (  tagNames  =  =  null  )  {  ancestors  =  Collections  .  emptyList  (  )  ;  }  else  {  [ATTENTION]  ancestors  =  new  ArrayList<Tag>  (  null  .  length  )    ;  for  (  String  name  :  tagNames  )  {  ancestors  .  add  (  Tag  .  valueOf  (  name  )  )  ;  }  }  return  this  ;  }    [METHOD]  setAncestor  [TYPE]  Tag  [PARAMETER]  tagNames  [CLASS]  Tag    [TYPE]  List  ancestors  [TYPE]  boolean  canContainBlock  canContainInline  empty  false  isBlock  optionalClosing  preserveWhitespace  true  [TYPE]  Tag  child  defaultAncestor  inline  tag  [TYPE]  String  name  tagName  [TYPE]  String[]  tagNames  [TYPE]  Map  tags  
[ADD]  ancestors  =  new  ArrayList<Tag>  (  tagNames  .  length  )  ;	[BUGGY]  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  private  Tag  setAncestor  (  String  .  .  .  tagNames  )  {  if  (  tagNames  =  =  null  )  {  ancestors  =  Collections  .  emptyList  (  )  ;  }  else  {  [ATTENTION]  for  (  String  name  :  tagNames  )  {  ancestors  .  add  (  Tag  .  valueOf  (  name  )  )  ;  }  }  return  this  ;  }    [METHOD]  setAncestor  [TYPE]  Tag  [PARAMETER]  tagNames  [CLASS]  Tag    [TYPE]  List  ancestors  [TYPE]  boolean  canContainBlock  canContainInline  empty  false  isBlock  optionalClosing  preserveWhitespace  true  [TYPE]  Tag  child  defaultAncestor  inline  tag  [TYPE]  String  name  tagName  [TYPE]  String[]  tagNames  [TYPE]  Map  tags  
[REPLACE]  for  (  String  name  :  tagNames  )  {	[BUGGY]  Tag  tag  =  tags  .  get  (  tagName  )  ;  [CE]  illegal  start  of  type  [CONTEXT]  private  Tag  setAncestor  (  String  .  .  .  tagNames  )  {  if  (  tagNames  =  =  null  )  {  ancestors  =  Collections  .  emptyList  (  )  ;  }  else  {  ancestors  =  new  ArrayList<Tag>  (  tagNames  .  length  )  ;  [ATTENTION]  Tag  tag  =  tags  .  get  (  tagName  )    ;  ancestors  .  add  (  Tag  .  valueOf  (  name  )  )  ;  }  }  return  this  ;  }    [METHOD]  setAncestor  [TYPE]  Tag  [PARAMETER]  tagNames  [CLASS]  Tag    [TYPE]  List  ancestors  [TYPE]  boolean  canContainBlock  canContainInline  empty  false  isBlock  optionalClosing  preserveWhitespace  true  [TYPE]  Tag  child  defaultAncestor  inline  tag  [TYPE]  String  name  tagName  [TYPE]  String[]  tagNames  [TYPE]  Map  tags  
[REPLACE]  ancestors  =  Collections  .  emptyList  (  )  ;	[BUGGY]  ancestors    =    ancestors  ;  [NO-ERROR]  [CONTEXT]  private  Tag  setAncestor  (  String  .  .  .  tagNames  )  {  if  (  tagNames  =  =  null  )  {  [ATTENTION]  ancestors  =  ancestors  ;  }  else  {  ancestors  =  new  ArrayList<Tag>  (  tagNames  .  length  )  ;  for  (  String  name  :  tagNames  )  {  ancestors  .  add  (  Tag  .  valueOf  (  name  )  )  ;  }  }  return  this  ;  }    [METHOD]  setAncestor  [TYPE]  Tag  [PARAMETER]  tagNames  [CLASS]  Tag    [TYPE]  List  ancestors  [TYPE]  boolean  canContainBlock  canContainInline  empty  false  isBlock  optionalClosing  preserveWhitespace  true  [TYPE]  Tag  child  defaultAncestor  inline  tag  [TYPE]  String  name  tagName  [TYPE]  String[]  tagNames  [TYPE]  Map  tags  
[ADD]  for  (  String  name  :  tagNames  )  {  ancestors  .  add  (  Tag  .  valueOf  (  name  )  )  ;  }	[BUGGY]  [FE]  AssertionFailedError    expected:<[]Replaced>  but  was:<[Hello  ]Replaced>  assertEquals( "Replaced "  ,  doc.text())  ;  assertEquals( "Replaced "  ,  doc.body().text())  ;  assertEquals(1  ,  doc.select( "head ").size())  ;  [CONTEXT]  private  Tag  setAncestor  (  String  .  .  .  tagNames  )  {  if  (  tagNames  =  =  null  )  {  ancestors  =  Collections  .  emptyList  (  )  ;  }  else  {  ancestors  =  new  ArrayList<Tag>  (  tagNames  .  length  )  ;  [ATTENTION]    }  return  this  ;  }    [METHOD]  setAncestor  [TYPE]  Tag  [PARAMETER]  tagNames  [CLASS]  Tag    [TYPE]  List  ancestors  [TYPE]  boolean  canContainBlock  canContainInline  empty  false  isBlock  optionalClosing  preserveWhitespace  true  [TYPE]  Tag  child  defaultAncestor  inline  tag  [TYPE]  String  name  tagName  [TYPE]  String[]  tagNames  [TYPE]  Map  tags  
[REPLACE]  return  this;	[BUGGY]  return  null  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  private  Tag  setAncestor  (  String  .  .  .  tagNames  )  {  if  (  tagNames  =  =  null  )  {  ancestors  =  Collections  .  emptyList  (  )  ;  }  else  {  ancestors  =  new  ArrayList<Tag>  (  tagNames  .  length  )  ;  for  (  String  name  :  tagNames  )  {  ancestors  .  add  (  Tag  .  valueOf  (  name  )  )  ;  }  }  [ATTENTION]  return  null  ;  }    [METHOD]  setAncestor  [TYPE]  Tag  [PARAMETER]  tagNames  [CLASS]  Tag    [TYPE]  List  ancestors  [TYPE]  boolean  canContainBlock  canContainInline  empty  false  isBlock  optionalClosing  preserveWhitespace  true  [TYPE]  Tag  child  defaultAncestor  inline  tag  [TYPE]  String  name  tagName  [TYPE]  String[]  tagNames  [TYPE]  Map  tags  
[REPLACE]  Validate  .  notNull  (  data  )  ;	[BUGGY]  data    ;  [CE]  not  a  statement  [CONTEXT]  public  TokenQueue  (  String  data  )  {  [ATTENTION]  data  ;    queue  =  new  LinkedList<Character>  (  )  ;  char[]  chars  =  data  .  toCharArray  (  )  ;  for  (  char  c  :  chars  )  {  queue  .  add  (  c  )  ;  }  }    [METHOD]  <init>  [TYPE]  String)  [PARAMETER]  String  data  [CLASS]  TokenQueue    [TYPE]  char  c  [TYPE]  String  data  [TYPE]  boolean  false  true  [TYPE]  LinkedList  queue  [TYPE]  char[]  chars  
[REPLACE]  queue  =  new  LinkedList<Character>  (  )  ;	[BUGGY]  queue  ;  [CE]  not  a  statement  [CONTEXT]  public  TokenQueue  (  String  data  )  {  Validate  .  notNull  (  data  )  ;    [ATTENTION]  queue  ;  char[]  chars  =  data  .  toCharArray  (  )  ;  for  (  char  c  :  chars  )  {  queue  .  add  (  c  )  ;  }  }    [METHOD]  <init>  [TYPE]  String)  [PARAMETER]  String  data  [CLASS]  TokenQueue    [TYPE]  char  c  [TYPE]  String  data  [TYPE]  boolean  false  true  [TYPE]  LinkedList  queue  [TYPE]  char[]  chars  
[REPLACE]  char[]  chars  =  data  .  toCharArray  (  )  ;	[BUGGY]  char[]  chars  =  seq  .  toCharArray  (  )  ;  [CE]  cannot  find  symbol  seq  [CONTEXT]  public  TokenQueue  (  String  data  )  {  Validate  .  notNull  (  data  )  ;    queue  =  new  LinkedList<Character>  (  )  ;  [ATTENTION]  char[]  chars  =  seq  .  toCharArray  (  )    ;  for  (  char  c  :  chars  )  {  queue  .  add  (  c  )  ;  }  }    [METHOD]  <init>  [TYPE]  String)  [PARAMETER]  String  data  [CLASS]  TokenQueue    [TYPE]  char  c  [TYPE]  String  data  [TYPE]  boolean  false  true  [TYPE]  LinkedList  queue  [TYPE]  char[]  chars  
[REPLACE]  for  (  char  c  :  chars  )  {	[BUGGY]  for  (  char  c  :  chars  )  {  queue  .  add  (  c  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  TokenQueue  (  String  data  )  {  Validate  .  notNull  (  data  )  ;    queue  =  new  LinkedList<Character>  (  )  ;  char[]  chars  =  data  .  toCharArray  (  )  ;  [ATTENTION]  for  (  char  c  :  chars  )  {  queue  .  add  (  c  )    ;  queue  .  add  (  c  )  ;  }  }    [METHOD]  <init>  [TYPE]  String)  [PARAMETER]  String  data  [CLASS]  TokenQueue    [TYPE]  char  c  [TYPE]  String  data  [TYPE]  boolean  false  true  [TYPE]  LinkedList  queue  [TYPE]  char[]  chars  
[REPLACE]  return  queue  .  isEmpty  (  )  ;	[BUGGY]  return  queue  .  toString  (  )    ;  [CE]  incompatible  types  [CONTEXT]  public  boolean  isEmpty  (  )  {  [ATTENTION]  return  queue  .  toString  (  )  ;  }    [METHOD]  isEmpty  [TYPE]  boolean  [PARAMETER]  [CLASS]  TokenQueue    [TYPE]  LinkedList  queue  [TYPE]  boolean  false  true  
[REPLACE]  return  queue  .  peek  (  )  ;	[BUGGY]  return  queue  .  removeFirst  (  )    ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  Character  peek  (  )  {  [ATTENTION]  return  queue  .  removeFirst  (  )  ;  }    [METHOD]  peek  [TYPE]  Character  [PARAMETER]  [CLASS]  TokenQueue    [TYPE]  LinkedList  queue  [TYPE]  boolean  false  true  
[REPLACE]  queue  .  addFirst  (  c  )  ;	[BUGGY]  queue  .  add  (  c  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  void  addFirst  (  Character  c  )  {  [ATTENTION]  queue  .  add  (  c  )    ;  }    [METHOD]  addFirst  [TYPE]  void  [PARAMETER]  Character  c  [CLASS]  TokenQueue    [TYPE]  Character  c  [TYPE]  LinkedList  queue  [TYPE]  boolean  false  true  
[REPLACE]  char[]  chars  =  seq  .  toCharArray  (  )  ;	[BUGGY]  char[]  chars  =  seq  .  length  (  )  ;  [CE]  incompatible  types  [CONTEXT]  public  void  addFirst  (  String  seq  )  {  [ATTENTION]  char[]  chars  =  seq  .  length  (  )    ;  for  (  int  i  =  chars  .  length  -  1  ;  i  >  =  0  ;  i--  )  {  addFirst  (  chars[i]  )  ;  }  }    [METHOD]  addFirst  [TYPE]  void  [PARAMETER]  String  seq  [CLASS]  TokenQueue    [TYPE]  String  seq  [TYPE]  boolean  false  true  [TYPE]  LinkedList  queue  [TYPE]  int  i  [TYPE]  char[]  chars  
[REPLACE]  for  (  int  i  =  chars  .  length  -  1;  i  >=  0;  i--  )  {	[BUGGY]  for  (  int  i  =  chars  .  length  %  2  -  1  ;  i  >  =  0  ;  i--  )  {[FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  void  addFirst  (  String  seq  )  {  char[]  chars  =  seq  .  toCharArray  (  )  ;  [ATTENTION]  for  (  int  i  =  chars  .  length  %2  -  1  ;  i  >  =  0  ;  i--  )  {  addFirst  (  chars[i]  )  ;  }  }    [METHOD]  addFirst  [TYPE]  void  [PARAMETER]  String  seq  [CLASS]  TokenQueue    [TYPE]  String  seq  [TYPE]  boolean  false  true  [TYPE]  LinkedList  queue  [TYPE]  int  i  [TYPE]  char[]  chars  
[REPLACE]  addFirst  (  chars[i]  )  ;	[BUGGY]  queue  .  addFirst  (  c  )  ;  [CE]  cannot  find  symbol  c  [CONTEXT]  public  void  addFirst  (  String  seq  )  {  char[]  chars  =  seq  .  toCharArray  (  )  ;  for  (  int  i  =  chars  .  length  -  1  ;  i  >  =  0  ;  i--  )  {  [ATTENTION]  queue  .  addFirst  (  c  )    ;  }  }    [METHOD]  addFirst  [TYPE]  void  [PARAMETER]  String  seq  [CLASS]  TokenQueue    [TYPE]  String  seq  [TYPE]  boolean  false  true  [TYPE]  LinkedList  queue  [TYPE]  int  i  [TYPE]  char[]  chars  
[REPLACE]  for  (  int  i  =  chars  .  length  -  1;  i  >=  0;  i--  )  {	[BUGGY]  for  (  int  i  =  chars  .  length  -  5  -  1  ;  i  >  =  0  ;  i--  )  {[FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  void  addFirst  (  String  seq  )  {  char[]  chars  =  seq  .  toCharArray  (  )  ;  [ATTENTION]  for  (  int  i  =  chars  .  length  -  5  -  1  ;  i  >  =  0  ;  i--  )  {  addFirst  (  chars[i]  )  ;  }  }    [METHOD]  addFirst  [TYPE]  void  [PARAMETER]  String  seq  [CLASS]  TokenQueue    [TYPE]  String  seq  [TYPE]  boolean  false  true  [TYPE]  LinkedList  queue  [TYPE]  int  i  [TYPE]  char[]  chars  
[REPLACE]  int  len  =  seq  .  length  (  )  ;	[BUGGY]  int  len  =  seq  .  toCharArray  (  )  ;  [CE]  incompatible  types  [CONTEXT]  public  boolean  matches  (  String  seq  )  {  [ATTENTION]  int  len  =  seq  .  toCharArray  (  )    ;  if  (  len  >  queue  .  size  (  )  )  return  false  ;  List<Character>  chars  =  queue  .  subList  (  0  ,  len  )  ;  char[]  seqChars  =  seq  .  toCharArray  (  )  ;  for  (  int  i  =  0  ;  i  <  len  ;  i++  )  {  Character  found  =  Character  .  toLowerCase  (  chars  .  get  (  i  )  )  ;  Character  check  =  Character  .  toLowerCase  (  seqChars[i]  )  ;  if  (  !found  .  equals  (  check  )  )  return  false  ;  }  return  true  ;  }    [METHOD]  matches  [TYPE]  boolean  [PARAMETER]  String  seq  [CLASS]  TokenQueue    [TYPE]  boolean  false  true  [TYPE]  Character  check  found  [TYPE]  List  chars  [TYPE]  String  seq  [TYPE]  LinkedList  queue  [TYPE]  int  i  len  [TYPE]  char[]  seqChars  
[REPLACE]  if  (  len  >  queue  .  size  (  )  )  return  false;	[BUGGY]  if  (  len  >  queue  .  size  (  )  %  0  .  5  )  return  false  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  boolean  matches  (  String  seq  )  {  int  len  =  seq  .  length  (  )  ;  [ATTENTION]  if  (  len  >  queue  .  size  (  )  %0  .  5  )  return  false  ;    List<Character>  chars  =  queue  .  subList  (  0  ,  len  )  ;  char[]  seqChars  =  seq  .  toCharArray  (  )  ;  for  (  int  i  =  0  ;  i  <  len  ;  i++  )  {  Character  found  =  Character  .  toLowerCase  (  chars  .  get  (  i  )  )  ;  Character  check  =  Character  .  toLowerCase  (  seqChars[i]  )  ;  if  (  !found  .  equals  (  check  )  )  return  false  ;  }  return  true  ;  }    [METHOD]  matches  [TYPE]  boolean  [PARAMETER]  String  seq  [CLASS]  TokenQueue    [TYPE]  boolean  false  true  [TYPE]  Character  check  found  [TYPE]  List  chars  [TYPE]  String  seq  [TYPE]  LinkedList  queue  [TYPE]  int  i  len  [TYPE]  char[]  seqChars  
[REPLACE]  return  false;	[BUGGY]  return  true  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  boolean  matches  (  String  seq  )  {  int  len  =  seq  .  length  (  )  ;  if  (  len  >  queue  .  size  (  )  )  [ATTENTION]  return  true  ;  List<Character>  chars  =  queue  .  subList  (  0  ,  len  )  ;  char[]  seqChars  =  seq  .  toCharArray  (  )  ;  for  (  int  i  =  0  ;  i  <  len  ;  i++  )  {  Character  found  =  Character  .  toLowerCase  (  chars  .  get  (  i  )  )  ;  Character  check  =  Character  .  toLowerCase  (  seqChars[i]  )  ;  if  (  !found  .  equals  (  check  )  )  return  false  ;  }  return  true  ;  }    [METHOD]  matches  [TYPE]  boolean  [PARAMETER]  String  seq  [CLASS]  TokenQueue    [TYPE]  boolean  false  true  [TYPE]  Character  check  found  [TYPE]  List  chars  [TYPE]  String  seq  [TYPE]  LinkedList  queue  [TYPE]  int  i  len  [TYPE]  char[]  seqChars  
[REPLACE]  List<Character>  chars  =  queue  .  subList  (  0,  len  )  ;	[BUGGY]  List<Character>  chars  =  queue  .  subList  (  0  -  1  ,  len  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  boolean  matches  (  String  seq  )  {  int  len  =  seq  .  length  (  )  ;  if  (  len  >  queue  .  size  (  )  )  return  false  ;  [ATTENTION]  List<Character>  chars  =  queue  .  subList  (  0  -  1  ,  len  )    ;  char[]  seqChars  =  seq  .  toCharArray  (  )  ;  for  (  int  i  =  0  ;  i  <  len  ;  i++  )  {  Character  found  =  Character  .  toLowerCase  (  chars  .  get  (  i  )  )  ;  Character  check  =  Character  .  toLowerCase  (  seqChars[i]  )  ;  if  (  !found  .  equals  (  check  )  )  return  false  ;  }  return  true  ;  }    [METHOD]  matches  [TYPE]  boolean  [PARAMETER]  String  seq  [CLASS]  TokenQueue    [TYPE]  boolean  false  true  [TYPE]  Character  check  found  [TYPE]  List  chars  [TYPE]  String  seq  [TYPE]  LinkedList  queue  [TYPE]  int  i  len  [TYPE]  char[]  seqChars  
[ADD]  List<Character>  chars  =  queue  .  subList  (  0,  len  )  ;	[BUGGY]  [CE]  cannot  find  symbol  chars  [CONTEXT]  public  boolean  matches  (  String  seq  )  {  int  len  =  seq  .  length  (  )  ;  if  (  len  >  queue  .  size  (  )  )  return  false  ;  [ATTENTION]  char[]  seqChars  =  seq  .  toCharArray  (  )  ;  for  (  int  i  =  0  ;  i  <  len  ;  i++  )  {  Character  found  =  Character  .  toLowerCase  (  chars  .  get  (  i  )  )  ;  Character  check  =  Character  .  toLowerCase  (  seqChars[i]  )  ;  if  (  !found  .  equals  (  check  )  )  return  false  ;  }  return  true  ;  }    [METHOD]  matches  [TYPE]  boolean  [PARAMETER]  String  seq  [CLASS]  TokenQueue    [TYPE]  boolean  false  true  [TYPE]  Character  check  found  [TYPE]  List  chars  [TYPE]  String  seq  [TYPE]  LinkedList  queue  [TYPE]  int  i  len  [TYPE]  char[]  seqChars  
[REPLACE]  char[]  seqChars  =  seq  .  toCharArray  (  )  ;	[BUGGY]  char[]  chars  =  seq  .  toCharArray  (  )  ;  [CE]  variable  chars  is  already  defined  in  method  matches(String)  [CONTEXT]  public  boolean  matches  (  String  seq  )  {  int  len  =  seq  .  length  (  )  ;  if  (  len  >  queue  .  size  (  )  )  return  false  ;  List<Character>  chars  =  queue  .  subList  (  0  ,  len  )  ;  [ATTENTION]  char[]  chars  =  seq  .  toCharArray  (  )    ;  for  (  int  i  =  0  ;  i  <  len  ;  i++  )  {  Character  found  =  Character  .  toLowerCase  (  chars  .  get  (  i  )  )  ;  Character  check  =  Character  .  toLowerCase  (  seqChars[i]  )  ;  if  (  !found  .  equals  (  check  )  )  return  false  ;  }  return  true  ;  }    [METHOD]  matches  [TYPE]  boolean  [PARAMETER]  String  seq  [CLASS]  TokenQueue    [TYPE]  boolean  false  true  [TYPE]  Character  check  found  [TYPE]  List  chars  [TYPE]  String  seq  [TYPE]  LinkedList  queue  [TYPE]  int  i  len  [TYPE]  char[]  seqChars  
[REPLACE]  if  (  !found  .  equals  (  check  )  )  return  false;	[BUGGY]  if  (  !found  .  equals  (  check  )  )  return  true  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  boolean  matches  (  String  seq  )  {  int  len  =  seq  .  length  (  )  ;  if  (  len  >  queue  .  size  (  )  )  return  false  ;  List<Character>  chars  =  queue  .  subList  (  0  ,  len  )  ;  char[]  seqChars  =  seq  .  toCharArray  (  )  ;  for  (  int  i  =  0  ;  i  <  len  ;  i++  )  {  Character  found  =  Character  .  toLowerCase  (  chars  .  get  (  i  )  )  ;  Character  check  =  Character  .  toLowerCase  (  seqChars[i]  )  ;  [ATTENTION]  if  (  !found  .  equals  (  check  )  )  return  true  ;    }  return  true  ;  }    [METHOD]  matches  [TYPE]  boolean  [PARAMETER]  String  seq  [CLASS]  TokenQueue    [TYPE]  boolean  false  true  [TYPE]  Character  check  found  [TYPE]  List  chars  [TYPE]  String  seq  [TYPE]  LinkedList  queue  [TYPE]  int  i  len  [TYPE]  char[]  seqChars  
[REPLACE]  return  false;	[BUGGY]  return  true  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  boolean  matches  (  String  seq  )  {  int  len  =  seq  .  length  (  )  ;  if  (  len  >  queue  .  size  (  )  )  return  false  ;  List<Character>  chars  =  queue  .  subList  (  0  ,  len  )  ;  char[]  seqChars  =  seq  .  toCharArray  (  )  ;  for  (  int  i  =  0  ;  i  <  len  ;  i++  )  {  Character  found  =  Character  .  toLowerCase  (  chars  .  get  (  i  )  )  ;  Character  check  =  Character  .  toLowerCase  (  seqChars[i]  )  ;  if  (  !found  .  equals  (  check  )  )  [ATTENTION]  return  true  ;  }  return  true  ;  }    [METHOD]  matches  [TYPE]  boolean  [PARAMETER]  String  seq  [CLASS]  TokenQueue    [TYPE]  boolean  false  true  [TYPE]  Character  check  found  [TYPE]  List  chars  [TYPE]  String  seq  [TYPE]  LinkedList  queue  [TYPE]  int  i  len  [TYPE]  char[]  seqChars  
[REPLACE]  for  (  int  i  =  0;  i  <  len;  i++  )  {	[BUGGY]  for  (  int  i  =  0  ;  i  >  len  ;  i++  )  {[FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  boolean  matches  (  String  seq  )  {  int  len  =  seq  .  length  (  )  ;  if  (  len  >  queue  .  size  (  )  )  return  false  ;  List<Character>  chars  =  queue  .  subList  (  0  ,  len  )  ;  char[]  seqChars  =  seq  .  toCharArray  (  )  ;  [ATTENTION]  for  (  int  i  =  0  ;  i>len  ;  i++  )  {  Character  found  =  Character  .  toLowerCase  (  chars  .  get  (  i  )  )  ;  Character  check  =  Character  .  toLowerCase  (  seqChars[i]  )  ;  if  (  !found  .  equals  (  check  )  )  return  false  ;  }  return  true  ;  }    [METHOD]  matches  [TYPE]  boolean  [PARAMETER]  String  seq  [CLASS]  TokenQueue    [TYPE]  boolean  false  true  [TYPE]  Character  check  found  [TYPE]  List  chars  [TYPE]  String  seq  [TYPE]  LinkedList  queue  [TYPE]  int  i  len  [TYPE]  char[]  seqChars  
[REPLACE]  if  (  !found  .  equals  (  check  )  )  return  false;	[BUGGY]  if  (  !found  .  toLowerCase  (  check  )  )  return  true  ;  [CE]  bad  operand  type  char  for  unary  operator  '!'  [CONTEXT]  public  boolean  matches  (  String  seq  )  {  int  len  =  seq  .  length  (  )  ;  if  (  len  >  queue  .  size  (  )  )  return  false  ;  List<Character>  chars  =  queue  .  subList  (  0  ,  len  )  ;  char[]  seqChars  =  seq  .  toCharArray  (  )  ;  for  (  int  i  =  0  ;  i  <  len  ;  i++  )  {  Character  found  =  Character  .  toLowerCase  (  chars  .  get  (  i  )  )  ;  Character  check  =  Character  .  toLowerCase  (  seqChars[i]  )  ;  [ATTENTION]  if  (  !found  .  toLowerCase  (  check  )  )  return  true  ;    }  return  true  ;  }    [METHOD]  matches  [TYPE]  boolean  [PARAMETER]  String  seq  [CLASS]  TokenQueue    [TYPE]  boolean  false  true  [TYPE]  Character  check  found  [TYPE]  List  chars  [TYPE]  String  seq  [TYPE]  LinkedList  queue  [TYPE]  int  i  len  [TYPE]  char[]  seqChars  
[REPLACE]  Character  found  =  Character  .  toLowerCase  (  chars  .  get  (  i  )  )  ;	[BUGGY]  Character  found  =  Character  .  toLowerCase  (  null  .  get  (  i  )  )  ;  [CE]  <null>  cannot  be  dereferenced  [CONTEXT]  public  boolean  matches  (  String  seq  )  {  int  len  =  seq  .  length  (  )  ;  if  (  len  >  queue  .  size  (  )  )  return  false  ;  List<Character>  chars  =  queue  .  subList  (  0  ,  len  )  ;  char[]  seqChars  =  seq  .  toCharArray  (  )  ;  for  (  int  i  =  0  ;  i  <  len  ;  i++  )  {  [ATTENTION]  Character  found  =  Character  .  toLowerCase  (  null  .  get  (  i  )  )    ;  Character  check  =  Character  .  toLowerCase  (  seqChars[i]  )  ;  if  (  !found  .  equals  (  check  )  )  return  false  ;  }  return  true  ;  }    [METHOD]  matches  [TYPE]  boolean  [PARAMETER]  String  seq  [CLASS]  TokenQueue    [TYPE]  boolean  false  true  [TYPE]  Character  check  found  [TYPE]  List  chars  [TYPE]  String  seq  [TYPE]  LinkedList  queue  [TYPE]  int  i  len  [TYPE]  char[]  seqChars  
[REPLACE]  Character  check  =  Character  .  toLowerCase  (  seqChars[i]  )  ;	[BUGGY]  Character  check  =  Character  .  isWhitespace  (  null  )    ;  [CE]  no  suitable  method  found  for  isWhitespace(<null>)  [CONTEXT]  public  boolean  matches  (  String  seq  )  {  int  len  =  seq  .  length  (  )  ;  if  (  len  >  queue  .  size  (  )  )  return  false  ;  List<Character>  chars  =  queue  .  subList  (  0  ,  len  )  ;  char[]  seqChars  =  seq  .  toCharArray  (  )  ;  for  (  int  i  =  0  ;  i  <  len  ;  i++  )  {  Character  found  =  Character  .  toLowerCase  (  chars  .  get  (  i  )  )  ;  [ATTENTION]  Character  check  =  Character  .  isWhitespace  (  null  )  ;  if  (  !found  .  equals  (  check  )  )  return  false  ;  }  return  true  ;  }    [METHOD]  matches  [TYPE]  boolean  [PARAMETER]  String  seq  [CLASS]  TokenQueue    [TYPE]  boolean  false  true  [TYPE]  Character  check  found  [TYPE]  List  chars  [TYPE]  String  seq  [TYPE]  LinkedList  queue  [TYPE]  int  i  len  [TYPE]  char[]  seqChars  
[REPLACE]  for  (  int  i  =  0;  i  <  len;  i++  )  {	[BUGGY]  for  (  int  i  =  2  ;  i  <  len  ;  i++  )  {[FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  boolean  matches  (  String  seq  )  {  int  len  =  seq  .  length  (  )  ;  if  (  len  >  queue  .  size  (  )  )  return  false  ;  List<Character>  chars  =  queue  .  subList  (  0  ,  len  )  ;  char[]  seqChars  =  seq  .  toCharArray  (  )  ;  [ATTENTION]  for  (  int  i  =  2  ;  i  <  len  ;  i++  )  {  Character  found  =  Character  .  toLowerCase  (  chars  .  get  (  i  )  )  ;  Character  check  =  Character  .  toLowerCase  (  seqChars[i]  )  ;  if  (  !found  .  equals  (  check  )  )  return  false  ;  }  return  true  ;  }    [METHOD]  matches  [TYPE]  boolean  [PARAMETER]  String  seq  [CLASS]  TokenQueue    [TYPE]  boolean  false  true  [TYPE]  Character  check  found  [TYPE]  List  chars  [TYPE]  String  seq  [TYPE]  LinkedList  queue  [TYPE]  int  i  len  [TYPE]  char[]  seqChars  
[REPLACE]  Character  found  =  Character  .  toLowerCase  (  chars  .  get  (  i  )  )  ;	[BUGGY]  Character  found  =  Character  .  toLowerCase  (  this  .  get  (  i  )  )  ;  [CE]  cannot  find  symbol  [CONTEXT]  public  boolean  matches  (  String  seq  )  {  int  len  =  seq  .  length  (  )  ;  if  (  len  >  queue  .  size  (  )  )  return  false  ;  List<Character>  chars  =  queue  .  subList  (  0  ,  len  )  ;  char[]  seqChars  =  seq  .  toCharArray  (  )  ;  for  (  int  i  =  0  ;  i  <  len  ;  i++  )  {  [ATTENTION]  Character  found  =  Character  .  toLowerCase  (  this  .  get  (  i  )  )    ;  Character  check  =  Character  .  toLowerCase  (  seqChars[i]  )  ;  if  (  !found  .  equals  (  check  )  )  return  false  ;  }  return  true  ;  }    [METHOD]  matches  [TYPE]  boolean  [PARAMETER]  String  seq  [CLASS]  TokenQueue    [TYPE]  boolean  false  true  [TYPE]  Character  check  found  [TYPE]  List  chars  [TYPE]  String  seq  [TYPE]  LinkedList  queue  [TYPE]  int  i  len  [TYPE]  char[]  seqChars  
[REPLACE]  Character  check  =  Character  .  toLowerCase  (  seqChars[i]  )  ;	[BUGGY]  Character  check  =  Character  .  isWhitespace  (  true  )    ;  [CE]  no  suitable  method  found  for  isWhitespace(boolean)  [CONTEXT]  public  boolean  matches  (  String  seq  )  {  int  len  =  seq  .  length  (  )  ;  if  (  len  >  queue  .  size  (  )  )  return  false  ;  List<Character>  chars  =  queue  .  subList  (  0  ,  len  )  ;  char[]  seqChars  =  seq  .  toCharArray  (  )  ;  for  (  int  i  =  0  ;  i  <  len  ;  i++  )  {  Character  found  =  Character  .  toLowerCase  (  chars  .  get  (  i  )  )  ;  [ATTENTION]  Character  check  =  Character  .  isWhitespace  (  true  )  ;  if  (  !found  .  equals  (  check  )  )  return  false  ;  }  return  true  ;  }    [METHOD]  matches  [TYPE]  boolean  [PARAMETER]  String  seq  [CLASS]  TokenQueue    [TYPE]  boolean  false  true  [TYPE]  Character  check  found  [TYPE]  List  chars  [TYPE]  String  seq  [TYPE]  LinkedList  queue  [TYPE]  int  i  len  [TYPE]  char[]  seqChars  
[REPLACE]  return  true;	[BUGGY]  return  false  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  boolean  matches  (  String  seq  )  {  int  len  =  seq  .  length  (  )  ;  if  (  len  >  queue  .  size  (  )  )  return  false  ;  List<Character>  chars  =  queue  .  subList  (  0  ,  len  )  ;  char[]  seqChars  =  seq  .  toCharArray  (  )  ;  for  (  int  i  =  0  ;  i  <  len  ;  i++  )  {  Character  found  =  Character  .  toLowerCase  (  chars  .  get  (  i  )  )  ;  Character  check  =  Character  .  toLowerCase  (  seqChars[i]  )  ;  if  (  !found  .  equals  (  check  )  )  return  false  ;  }  [ATTENTION]  return  false  ;  }    [METHOD]  matches  [TYPE]  boolean  [PARAMETER]  String  seq  [CLASS]  TokenQueue    [TYPE]  boolean  false  true  [TYPE]  Character  check  found  [TYPE]  List  chars  [TYPE]  String  seq  [TYPE]  LinkedList  queue  [TYPE]  int  i  len  [TYPE]  char[]  seqChars  
[REPLACE]  if  (  matches  (  s  )  )  return  true;	[BUGGY]  if  (  matches  (  s  )  )  return  false  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  boolean  matchesAny  (  String  .  .  .  seq  )  {  for  (  String  s  :  seq  )  {  [ATTENTION]  if  (  matches  (  s  )  )  return  false  ;    }  return  false  ;  }    [METHOD]  matchesAny  [TYPE]  boolean  [PARAMETER]  seq  [CLASS]  TokenQueue    [TYPE]  String[]  seq  [TYPE]  String  s  [TYPE]  boolean  false  true  [TYPE]  LinkedList  queue  
[REPLACE]  return  true;	[BUGGY]  return  false  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  boolean  matchesAny  (  String  .  .  .  seq  )  {  for  (  String  s  :  seq  )  {  if  (  matches  (  s  )  )  [ATTENTION]  return  false  ;  }  return  false  ;  }    [METHOD]  matchesAny  [TYPE]  boolean  [PARAMETER]  seq  [CLASS]  TokenQueue    [TYPE]  String[]  seq  [TYPE]  String  s  [TYPE]  boolean  false  true  [TYPE]  LinkedList  queue  
[REPLACE]  for  (  String  s  :  seq  )  {	[BUGGY]  for  (  char  c  :  chars  )  {  queue  .  add  (  c  )  ;  [CE]  cannot  find  symbol  chars  [CONTEXT]  public  boolean  matchesAny  (  String  .  .  .  seq  )  {  [ATTENTION]  for  (  char  c  :  chars  )  {  queue  .  add  (  c  )    ;  if  (  matches  (  s  )  )  return  true  ;  }  return  false  ;  }    [METHOD]  matchesAny  [TYPE]  boolean  [PARAMETER]  seq  [CLASS]  TokenQueue    [TYPE]  String[]  seq  [TYPE]  String  s  [TYPE]  boolean  false  true  [TYPE]  LinkedList  queue  
[REPLACE]  return  false;	[BUGGY]  return  true  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  boolean  matchesAny  (  String  .  .  .  seq  )  {  for  (  String  s  :  seq  )  {  if  (  matches  (  s  )  )  return  true  ;  }  [ATTENTION]  return  true  ;  }    [METHOD]  matchesAny  [TYPE]  boolean  [PARAMETER]  seq  [CLASS]  TokenQueue    [TYPE]  String[]  seq  [TYPE]  String  s  [TYPE]  boolean  false  true  [TYPE]  LinkedList  queue  
[REPLACE]  if  (  matches  (  seq  )  )  {	[BUGGY]  if  (  !found  .  equals  (  check  )  )  return  false  ;  [CE]  illegal  start  of  type  [CONTEXT]  public  boolean  matchChomp  (  String  seq  )  {  [ATTENTION]  if  (  !found  .  equals  (  check  )  )  return  false  ;  consume  (  seq  )  ;  return  true  ;  }  else  {  return  false  ;  }  }    [METHOD]  matchChomp  [TYPE]  boolean  [PARAMETER]  String  seq  [CLASS]  TokenQueue    [TYPE]  LinkedList  queue  [TYPE]  String  seq  [TYPE]  boolean  false  true  
[REPLACE]  return  false;	[BUGGY]  return  true  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  boolean  matchChomp  (  String  seq  )  {  if  (  matches  (  seq  )  )  {  consume  (  seq  )  ;  return  true  ;  }  else  {  [ATTENTION]  return  true  ;  }  }    [METHOD]  matchChomp  [TYPE]  boolean  [PARAMETER]  String  seq  [CLASS]  TokenQueue    [TYPE]  LinkedList  queue  [TYPE]  String  seq  [TYPE]  boolean  false  true  
[REPLACE]  return  true;	[BUGGY]  return  false  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  boolean  matchChomp  (  String  seq  )  {  if  (  matches  (  seq  )  )  {  consume  (  seq  )  ;  [ATTENTION]  return  false  ;  }  else  {  return  false  ;  }  }    [METHOD]  matchChomp  [TYPE]  boolean  [PARAMETER]  String  seq  [CLASS]  TokenQueue    [TYPE]  LinkedList  queue  [TYPE]  String  seq  [TYPE]  boolean  false  true  
[REPLACE]  return  !queue  .  isEmpty  (  )  &&  Character  .  isWhitespace  (  queue  .  peek  (  )  )  ;	[BUGGY]  return  !queue  .  isEmpty  (  )  &&    queue  .  peek  (  )    ;  [CE]  bad  operand  types  for  binary  operator  '&&'  [CONTEXT]  public  boolean  matchesWhitespace  (  )  {  [ATTENTION]  return  !queue  .  isEmpty  (  )  &&  queue  .  peek  (  )  ;  }    [METHOD]  matchesWhitespace  [TYPE]  boolean  [PARAMETER]  [CLASS]  TokenQueue    [TYPE]  LinkedList  queue  [TYPE]  boolean  false  true  
[REPLACE]  return  !queue  .  isEmpty  (  )  &&  Character  .  isLetterOrDigit  (  queue  .  peek  (  )  )  ;	[BUGGY]  returntrue  (  )    ;  [CE]  cannot  find  symbol  [CONTEXT]  public  boolean  matchesWord  (  )  {  [ATTENTION]  returntrue  (  )  ;  }    [METHOD]  matchesWord  [TYPE]  boolean  [PARAMETER]  [CLASS]  TokenQueue    [TYPE]  LinkedList  queue  [TYPE]  boolean  false  true  
[REPLACE]  return  queue  .  removeFirst  (  )  ;	[BUGGY]  return  queue  .  LinkedList  (  )  ;  [CE]  cannot  find  symbol  [CONTEXT]  public  Character  consume  (  )  {  [ATTENTION]  return  queue  .  LinkedList  (  )    ;  }    [METHOD]  consume  [TYPE]  Character  [PARAMETER]  [CLASS]  TokenQueue    [TYPE]  LinkedList  queue  [TYPE]  boolean  false  true  
[REPLACE]  if  (  !matches  (  seq  )  )  throw  new  IllegalStateException  ( "   ")  ;	[BUGGY]  if  (  len  >  queue  .  size  (  )  )  throw  new  IllegalStateException  ( "   ")    ;  [CE]  cannot  find  symbol  len  [CONTEXT]  public  void  consume  (  String  seq  )  {  [ATTENTION]  if  (  len  >  queue  .  size  (  )  )  throw  new  IllegalStateException  (   "   "  )  ;    int  len  =  seq  .  length  (  )  ;  if  (  len  >  queue  .  size  (  )  )  throw  new  IllegalStateException  (   "Queue  not  long  enough  to  consume  sequence "  )  ;  for  (  int  i  =  0  ;  i  <  len  ;  i++  )  {  consume  (  )  ;  }  }    [METHOD]  consume  [TYPE]  void  [PARAMETER]  String  seq  [CLASS]  TokenQueue    [TYPE]  String  seq  [TYPE]  boolean  false  true  [TYPE]  LinkedList  queue  [TYPE]  int  i  len  
[REMOVE]  	[BUGGY]  if  (  len  >  (  queue  .  size  (  )  )  )      throw  new  IllegalStateException  (   "Queue  not  long  enough  to  consume  sequence "  )  ;  [CE]  cannot  find  symbol  len  [CONTEXT]  public  void  consume  (  String  seq  )  {  [ATTENTION]  if  (  !matches  (  seq  )  )    if  (  len  >  (  queue  .  size  (  )  )  )  throw  new  IllegalStateException  (   "Queue  not  long  enough  to  consume  sequence "  )    ;  throw  new  IllegalStateException  (   "Queue  did  not  match  expected  sequence "  )  ;  int  len  =  seq  .  length  (  )  ;  if  (  len  >  queue  .  size  (  )  )  throw  new  IllegalStateException  (   "Queue  not  long  enough  to  consume  sequence "  )  ;  for  (  int  i  =  0  ;  i  <  len  ;  i++  )  {  consume  (  )  ;  }    [METHOD]  consume  [TYPE]  void  [PARAMETER]  String  seq  [CLASS]  TokenQueue    [TYPE]  String  seq  [TYPE]  boolean  false  true  [TYPE]  LinkedList  queue  [TYPE]  int  i  len  
[REPLACE]  throw  new  IllegalStateException  ( "   ")  ;	[BUGGY]  return  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  void  consume  (  String  seq  )  {  if  (  !matches  (  seq  )  )  [ATTENTION]  return  ;  int  len  =  seq  .  length  (  )  ;  if  (  len  >  queue  .  size  (  )  )  throw  new  IllegalStateException  (   "Queue  not  long  enough  to  consume  sequence "  )  ;  for  (  int  i  =  0  ;  i  <  len  ;  i++  )  {  consume  (  )  ;  }  }    [METHOD]  consume  [TYPE]  void  [PARAMETER]  String  seq  [CLASS]  TokenQueue    [TYPE]  String  seq  [TYPE]  boolean  false  true  [TYPE]  LinkedList  queue  [TYPE]  int  i  len  
[ADD]  throw  new  IllegalStateException  ( "   ")  ;	[BUGGY]  [CE]  '.class'  expected  [CONTEXT]  public  void  consume  (  String  seq  )  {  if  (  !matches  (  seq  )  )  [ATTENTION]  int  len  =  seq  .  length  (  )  ;  if  (  len  >  queue  .  size  (  )  )  throw  new  IllegalStateException  (   "Queue  not  long  enough  to  consume  sequence "  )  ;  for  (  int  i  =  0  ;  i  <  len  ;  i++  )  {  consume  (  )  ;  }  }    [METHOD]  consume  [TYPE]  void  [PARAMETER]  String  seq  [CLASS]  TokenQueue    [TYPE]  String  seq  [TYPE]  boolean  false  true  [TYPE]  LinkedList  queue  [TYPE]  int  i  len  
[REPLACE]  int  len  =  seq  .  length  (  )  ;	[BUGGY]  int  len  =  seq  .  toCharArray  (  )  ;  [CE]  incompatible  types  [CONTEXT]  public  void  consume  (  String  seq  )  {  if  (  !matches  (  seq  )  )  throw  new  IllegalStateException  (   "Queue  did  not  match  expected  sequence "  )  ;  [ATTENTION]  int  len  =  seq  .  toCharArray  (  )    ;  if  (  len  >  queue  .  size  (  )  )  throw  new  IllegalStateException  (   "Queue  not  long  enough  to  consume  sequence "  )  ;  for  (  int  i  =  0  ;  i  <  len  ;  i++  )  {  consume  (  )  ;  }  }    [METHOD]  consume  [TYPE]  void  [PARAMETER]  String  seq  [CLASS]  TokenQueue    [TYPE]  String  seq  [TYPE]  boolean  false  true  [TYPE]  LinkedList  queue  [TYPE]  int  i  len  
[ADD]  int  len  =  seq  .  length  (  )  ;	[BUGGY]  [CE]  cannot  find  symbol  len  [CONTEXT]  public  void  consume  (  String  seq  )  {  if  (  !matches  (  seq  )  )  throw  new  IllegalStateException  (   "Queue  did  not  match  expected  sequence "  )  ;  [ATTENTION]  if  (  len  >  queue  .  size  (  )  )  throw  new  IllegalStateException  (   "Queue  not  long  enough  to  consume  sequence "  )  ;  for  (  int  i  =  0  ;  i  <  len  ;  i++  )  {  consume  (  )  ;  }  }    [METHOD]  consume  [TYPE]  void  [PARAMETER]  String  seq  [CLASS]  TokenQueue    [TYPE]  String  seq  [TYPE]  boolean  false  true  [TYPE]  LinkedList  queue  [TYPE]  int  i  len  
[REPLACE]  if  (  len  >  queue  .  size  (  )  )  throw  new  IllegalStateException  ( "   ")  ;	[BUGGY]  if  (  len  >  queue  .  size  (  )  +  1  )  throw  new  IllegalStateException    (   "   "  )    ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  void  consume  (  String  seq  )  {  if  (  !matches  (  seq  )  )  throw  new  IllegalStateException  (   "Queue  did  not  match  expected  sequence "  )  ;  int  len  =  seq  .  length  (  )  ;  [ATTENTION]  if  (  len  >  queue  .  size  (  )  +  1  )  throw  new  IllegalStateException  (   "   "  )    ;    for  (  int  i  =  0  ;  i  <  len  ;  i++  )  {  consume  (  )  ;  }  }    [METHOD]  consume  [TYPE]  void  [PARAMETER]  String  seq  [CLASS]  TokenQueue    [TYPE]  String  seq  [TYPE]  boolean  false  true  [TYPE]  LinkedList  queue  [TYPE]  int  i  len  
[ADD]  if  (  len  >  queue  .  size  (  )  )  throw  new  IllegalStateException  ( "   ")  ;  for  (  int  i  =  0;  i  <  len;  i++  )  {  consume  (  )  ;  }	[BUGGY]  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  void  consume  (  String  seq  )  {  if  (  !matches  (  seq  )  )  throw  new  IllegalStateException  (   "Queue  did  not  match  expected  sequence "  )  ;  int  len  =  seq  .  length  (  )  ;  [ATTENTION]      }    [METHOD]  consume  [TYPE]  void  [PARAMETER]  String  seq  [CLASS]  TokenQueue    [TYPE]  String  seq  [TYPE]  boolean  false  true  [TYPE]  LinkedList  queue  [TYPE]  int  i  len  
[REPLACE]  throw  new  IllegalStateException  ( "   ")  ;	[BUGGY]  return  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  void  consume  (  String  seq  )  {  if  (  !matches  (  seq  )  )  throw  new  IllegalStateException  (   "Queue  did  not  match  expected  sequence "  )  ;  int  len  =  seq  .  length  (  )  ;  if  (  len  >  queue  .  size  (  )  )  [ATTENTION]  return  ;  for  (  int  i  =  0  ;  i  <  len  ;  i++  )  {  consume  (  )  ;  }  }    [METHOD]  consume  [TYPE]  void  [PARAMETER]  String  seq  [CLASS]  TokenQueue    [TYPE]  String  seq  [TYPE]  boolean  false  true  [TYPE]  LinkedList  queue  [TYPE]  int  i  len  
[ADD]  throw  new  IllegalStateException  ( "   ")  ;	[BUGGY]  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  void  consume  (  String  seq  )  {  if  (  !matches  (  seq  )  )  throw  new  IllegalStateException  (   "Queue  did  not  match  expected  sequence "  )  ;  int  len  =  seq  .  length  (  )  ;  if  (  len  >  queue  .  size  (  )  )  [ATTENTION]  for  (  int  i  =  0  ;  i  <  len  ;  i++  )  {  consume  (  )  ;  }  }    [METHOD]  consume  [TYPE]  void  [PARAMETER]  String  seq  [CLASS]  TokenQueue    [TYPE]  String  seq  [TYPE]  boolean  false  true  [TYPE]  LinkedList  queue  [TYPE]  int  i  len  
[REPLACE]  for  (  int  i  =  0;  i  <  len;  i++  )  {	[BUGGY]  for  (  int  i  =  2  ;  i  >  =    len  ;  i++  )  {[FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  void  consume  (  String  seq  )  {  if  (  !matches  (  seq  )  )  throw  new  IllegalStateException  (   "Queue  did  not  match  expected  sequence "  )  ;  int  len  =  seq  .  length  (  )  ;  if  (  len  >  queue  .  size  (  )  )  throw  new  IllegalStateException  (   "Queue  not  long  enough  to  consume  sequence "  )  ;  [ATTENTION]  for  (  int  i  =  2  ;  i>  =  len  ;  i++  )  {  consume  (  )  ;  }  }    [METHOD]  consume  [TYPE]  void  [PARAMETER]  String  seq  [CLASS]  TokenQueue    [TYPE]  String  seq  [TYPE]  boolean  false  true  [TYPE]  LinkedList  queue  [TYPE]  int  i  len  
[ADD]  for  (  int  i  =  0;  i  <  len;  i++  )  {  consume  (  )  ;  }	[BUGGY]  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  void  consume  (  String  seq  )  {  if  (  !matches  (  seq  )  )  throw  new  IllegalStateException  (   "Queue  did  not  match  expected  sequence "  )  ;  int  len  =  seq  .  length  (  )  ;  if  (  len  >  queue  .  size  (  )  )  throw  new  IllegalStateException  (   "Queue  not  long  enough  to  consume  sequence "  )  ;  [ATTENTION]    }    [METHOD]  consume  [TYPE]  void  [PARAMETER]  String  seq  [CLASS]  TokenQueue    [TYPE]  String  seq  [TYPE]  boolean  false  true  [TYPE]  LinkedList  queue  [TYPE]  int  i  len  
[REPLACE]  consume  (  )  ;	[BUGGY]  consume  (  seq  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  void  consume  (  String  seq  )  {  if  (  !matches  (  seq  )  )  throw  new  IllegalStateException  (   "Queue  did  not  match  expected  sequence "  )  ;  int  len  =  seq  .  length  (  )  ;  if  (  len  >  queue  .  size  (  )  )  throw  new  IllegalStateException  (   "Queue  not  long  enough  to  consume  sequence "  )  ;  for  (  int  i  =  0  ;  i  <  len  ;  i++  )  {  [ATTENTION]  consume  (  seq  )    ;  }  }    [METHOD]  consume  [TYPE]  void  [PARAMETER]  String  seq  [CLASS]  TokenQueue    [TYPE]  String  seq  [TYPE]  boolean  false  true  [TYPE]  LinkedList  queue  [TYPE]  int  i  len  
[REPLACE]  for  (  int  i  =  0;  i  <  len;  i++  )  {	[BUGGY]  for  (  int  i  =  4  ;  i  <  len  ;  i++  )  {[FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  void  consume  (  String  seq  )  {  if  (  !matches  (  seq  )  )  throw  new  IllegalStateException  (   "Queue  did  not  match  expected  sequence "  )  ;  int  len  =  seq  .  length  (  )  ;  if  (  len  >  queue  .  size  (  )  )  throw  new  IllegalStateException  (   "Queue  not  long  enough  to  consume  sequence "  )  ;  [ATTENTION]  for  (  int  i  =  4  ;  i  <  len  ;  i++  )  {  consume  (  )  ;  }  }    [METHOD]  consume  [TYPE]  void  [PARAMETER]  String  seq  [CLASS]  TokenQueue    [TYPE]  String  seq  [TYPE]  boolean  false  true  [TYPE]  LinkedList  queue  [TYPE]  int  i  len  
[REPLACE]  return  consumeToAny  (  seq  )  ;	[BUGGY]  return  data  ;  [CE]  cannot  find  symbol  data  [CONTEXT]  public  String  consumeTo  (  String  seq  )  {  [ATTENTION]  return  data  ;  }    [METHOD]  consumeTo  [TYPE]  String  [PARAMETER]  String  seq  [CLASS]  TokenQueue    [TYPE]  LinkedList  queue  [TYPE]  String  seq  [TYPE]  boolean  false  true  
[REPLACE]  StringBuilder  accum  =  new  StringBuilder  (  )  ;	[BUGGY]  StringBuilder  wordAccum  =  new  StringBuilder  (  )  ;  [CE]  cannot  find  symbol  accum  [CONTEXT]  public  String  consumeToAny  (  String  .  .  .  seq  )  {  [ATTENTION]  StringBuilder  wordAccum  =  new  StringBuilder  (  )    ;  while  (  !queue  .  isEmpty  (  )  &&  !matchesAny  (  seq  )  )  accum  .  append  (  consume  (  )  )  ;    return  accum  .  toString  (  )  ;  }    [METHOD]  consumeToAny  [TYPE]  String  [PARAMETER]  seq  [CLASS]  TokenQueue    [TYPE]  String[]  seq  [TYPE]  boolean  false  true  [TYPE]  StringBuilder  accum  [TYPE]  LinkedList  queue  
[REPLACE]  while  (  !queue  .  isEmpty  (  )  &&  !matchesAny  (  seq  )  )  accum  .  append  (  consume  (  )  )  ;	[BUGGY]  while  (true  (  )    ;  [CE]  ')'  expected  [CONTEXT]  public  String  consumeToAny  (  String  .  .  .  seq  )  {  StringBuilder  accum  =  new  StringBuilder  (  )  ;  [ATTENTION]  while  (  true  (  )  ;    return  accum  .  toString  (  )  ;  }    [METHOD]  consumeToAny  [TYPE]  String  [PARAMETER]  seq  [CLASS]  TokenQueue    [TYPE]  String[]  seq  [TYPE]  boolean  false  true  [TYPE]  StringBuilder  accum  [TYPE]  LinkedList  queue  
[ADD]  while  (  !queue  .  isEmpty  (  )  &&  !matchesAny  (  seq  )  )  accum  .  append  (  consume  (  )  )  ;	[BUGGY]  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  String  consumeToAny  (  String  .  .  .  seq  )  {  StringBuilder  accum  =  new  StringBuilder  (  )  ;  [ATTENTION]    return  accum  .  toString  (  )  ;  }    [METHOD]  consumeToAny  [TYPE]  String  [PARAMETER]  seq  [CLASS]  TokenQueue    [TYPE]  String[]  seq  [TYPE]  boolean  false  true  [TYPE]  StringBuilder  accum  [TYPE]  LinkedList  queue  
[REPLACE]  accum  .  append  (  consume  (  )  )  ;	[BUGGY]  while  (  !queue  .  isEmpty  (  )  )  {  accum  .  append  (  consume  (  )  )  ;  [CE]  illegal  start  of  expression  [CONTEXT]  public  String  consumeToAny  (  String  .  .  .  seq  )  {  StringBuilder  accum  =  new  StringBuilder  (  )  ;  while  (  !queue  .  isEmpty  (  )  &&  !matchesAny  (  seq  )  )  [ATTENTION]  while  (  !queue  .  isEmpty  (  )  )  {  accum  .  append  (  consume  (  )  )    ;    return  accum  .  toString  (  )  ;  }    [METHOD]  consumeToAny  [TYPE]  String  [PARAMETER]  seq  [CLASS]  TokenQueue    [TYPE]  String[]  seq  [TYPE]  boolean  false  true  [TYPE]  StringBuilder  accum  [TYPE]  LinkedList  queue  
[REPLACE]  return  accum  .  toString  (  )  ;	[BUGGY]  return  accum  .  StringBuilder  (  )    ;  [CE]  cannot  find  symbol  [CONTEXT]  public  String  consumeToAny  (  String  .  .  .  seq  )  {  StringBuilder  accum  =  new  StringBuilder  (  )  ;  while  (  !queue  .  isEmpty  (  )  &&  !matchesAny  (  seq  )  )  accum  .  append  (  consume  (  )  )  ;    [ATTENTION]  return  accum  .  StringBuilder  (  )  ;  }    [METHOD]  consumeToAny  [TYPE]  String  [PARAMETER]  seq  [CLASS]  TokenQueue    [TYPE]  String[]  seq  [TYPE]  boolean  false  true  [TYPE]  StringBuilder  accum  [TYPE]  LinkedList  queue  
[REPLACE]  String  data  =  consumeTo  (  seq  )  ;	[BUGGY]  List<Character>  chars  =  queue  .  subList  (  0  ,  len  )  ;  [CE]  cannot  find  symbol  len  [CONTEXT]  public  String  chompTo  (  String  seq  )  {  [ATTENTION]  List<Character>  chars  =  queue  .  subList  (  0  ,  len  )    ;  matchChomp  (  seq  )  ;  return  data  ;  }    [METHOD]  chompTo  [TYPE]  String  [PARAMETER]  String  seq  [CLASS]  TokenQueue    [TYPE]  LinkedList  queue  [TYPE]  String  data  seq  [TYPE]  boolean  false  true  
[REPLACE]  matchChomp  (  seq  )  ;	[BUGGY]  consume  (  seq  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  String  chompTo  (  String  seq  )  {  String  data  =  consumeTo  (  seq  )  ;  [ATTENTION]  consume  (  seq  )    ;  return  data  ;  }    [METHOD]  chompTo  [TYPE]  String  [PARAMETER]  String  seq  [CLASS]  TokenQueue    [TYPE]  LinkedList  queue  [TYPE]  String  data  seq  [TYPE]  boolean  false  true  
[REPLACE]  return  data;	[BUGGY]  return  consumeToAny  (  seq  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  String  chompTo  (  String  seq  )  {  String  data  =  consumeTo  (  seq  )  ;  matchChomp  (  seq  )  ;  [ATTENTION]  return  consumeToAny  (  seq  )    ;  }    [METHOD]  chompTo  [TYPE]  String  [PARAMETER]  String  seq  [CLASS]  TokenQueue    [TYPE]  LinkedList  queue  [TYPE]  String  data  seq  [TYPE]  boolean  false  true  
[REPLACE]  boolean  seen  =  false;	[BUGGY]  boolean  seen  =  true  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  boolean  consumeWhitespace  (  )  {  [ATTENTION]  boolean  seen  =  true  ;  while  (  !queue  .  isEmpty  (  )  &&  Character  .  isWhitespace  (  queue  .  peek  (  )  )  )  {  consume  (  )  ;  seen  =  true  ;  }  return  seen  ;  }    [METHOD]  consumeWhitespace  [TYPE]  boolean  [PARAMETER]  [CLASS]  TokenQueue    [TYPE]  LinkedList  queue  [TYPE]  boolean  false  seen  true  
[REPLACE]  while  (  !queue  .  isEmpty  (  )  &&  Character  .  isWhitespace  (  queue  .  peek  (  )  )  )  {	[BUGGY]  while  (  !queue  .  isEmpty  (  )    ||  Character  .  isWhitespace  (  queue  .  peek  (  )  )  )  {[FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  boolean  consumeWhitespace  (  )  {  boolean  seen  =  false  ;  [ATTENTION]  while  (  !queue  .  isEmpty  (  )  ||Character  .  isWhitespace  (  queue  .  peek  (  )  )  )  {  consume  (  )  ;  seen  =  true  ;  }  return  seen  ;  }    [METHOD]  consumeWhitespace  [TYPE]  boolean  [PARAMETER]  [CLASS]  TokenQueue    [TYPE]  LinkedList  queue  [TYPE]  boolean  false  seen  true  
[REPLACE]  seen  =  true;	[BUGGY]  seen  =  false  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  boolean  consumeWhitespace  (  )  {  boolean  seen  =  false  ;  while  (  !queue  .  isEmpty  (  )  &&  Character  .  isWhitespace  (  queue  .  peek  (  )  )  )  {  consume  (  )  ;  [ATTENTION]  seen  =  false  ;  }  return  seen  ;  }    [METHOD]  consumeWhitespace  [TYPE]  boolean  [PARAMETER]  [CLASS]  TokenQueue    [TYPE]  LinkedList  queue  [TYPE]  boolean  false  seen  true  
[REPLACE]  return  seen;	[BUGGY]  return  data  ;  [CE]  cannot  find  symbol  data  [CONTEXT]  public  boolean  consumeWhitespace  (  )  {  boolean  seen  =  false  ;  while  (  !queue  .  isEmpty  (  )  &&  Character  .  isWhitespace  (  queue  .  peek  (  )  )  )  {  consume  (  )  ;  seen  =  true  ;  }  [ATTENTION]  return  data  ;  }    [METHOD]  consumeWhitespace  [TYPE]  boolean  [PARAMETER]  [CLASS]  TokenQueue    [TYPE]  LinkedList  queue  [TYPE]  boolean  false  seen  true  
[REPLACE]  StringBuilder  wordAccum  =  new  StringBuilder  (  )  ;	[BUGGY]  StringBuilder  accum  =  new  StringBuilder  (  )  ;  [CE]  cannot  find  symbol  wordAccum  [CONTEXT]  public  String  consumeWord  (  )  {  [ATTENTION]  StringBuilder  accum  =  new  StringBuilder  (  )    ;  while  (  !queue  .  isEmpty  (  )  &&  Character  .  isLetterOrDigit  (  queue  .  peek  (  )  )  )  {  wordAccum  .  append  (  queue  .  removeFirst  (  )  )  ;  }  return  wordAccum  .  toString  (  )  ;  }    [METHOD]  consumeWord  [TYPE]  String  [PARAMETER]  [CLASS]  TokenQueue    [TYPE]  StringBuilder  wordAccum  [TYPE]  LinkedList  queue  [TYPE]  boolean  false  true  
[ADD]  while  (  !queue  .  isEmpty  (  )  &&  Character  .  isLetterOrDigit  (  queue  .  peek  (  )  )  )  {  wordAccum  .  append  (  queue  .  removeFirst  (  )  )  ;	[BUGGY]  [CE]  illegal  start  of  type  [CONTEXT]  public  String  consumeWord  (  )  {  StringBuilder  wordAccum  =  new  StringBuilder  (  )  ;  [ATTENTION]    }  return  wordAccum  .  toString  (  )  ;  }    [METHOD]  consumeWord  [TYPE]  String  [PARAMETER]  [CLASS]  TokenQueue    [TYPE]  StringBuilder  wordAccum  [TYPE]  LinkedList  queue  [TYPE]  boolean  false  true  
[REPLACE]  wordAccum  .  append  (  queue  .  removeFirst  (  )  )  ;	[BUGGY]  wordAccum  .  append  (  queue  .  addFirst  (  1  )    )  ;  [CE]  method  addFirst  in  class  LinkedList<E>  cannot  be  applied  to  given  types  ;  [CONTEXT]  public  String  consumeWord  (  )  {  StringBuilder  wordAccum  =  new  StringBuilder  (  )  ;  while  (  !queue  .  isEmpty  (  )  &&  Character  .  isLetterOrDigit  (  queue  .  peek  (  )  )  )  {  [ATTENTION]  wordAccum  .  append  (  queue  .  addFirst  (  1  )    )    ;  }  return  wordAccum  .  toString  (  )  ;  }    [METHOD]  consumeWord  [TYPE]  String  [PARAMETER]  [CLASS]  TokenQueue    [TYPE]  StringBuilder  wordAccum  [TYPE]  LinkedList  queue  [TYPE]  boolean  false  true  
[REPLACE]  wordAccum  .  append  (  queue  .  removeFirst  (  )  )  ;	[BUGGY]  wordAccum  .  append  (  queue  .  addFirst  (  null  )    )  ;  [CE]  'void'  type  not  allowed  here  [CONTEXT]  public  String  consumeWord  (  )  {  StringBuilder  wordAccum  =  new  StringBuilder  (  )  ;  while  (  !queue  .  isEmpty  (  )  &&  Character  .  isLetterOrDigit  (  queue  .  peek  (  )  )  )  {  [ATTENTION]  wordAccum  .  append  (  queue  .  addFirst  (  null  )    )    ;  }  return  wordAccum  .  toString  (  )  ;  }    [METHOD]  consumeWord  [TYPE]  String  [PARAMETER]  [CLASS]  TokenQueue    [TYPE]  StringBuilder  wordAccum  [TYPE]  LinkedList  queue  [TYPE]  boolean  false  true  
[REPLACE]  return  wordAccum  .  toString  (  )  ;	[BUGGY]  return  wordAccum  .  StringBuilder  (  )    ;  [CE]  cannot  find  symbol  [CONTEXT]  public  String  consumeWord  (  )  {  StringBuilder  wordAccum  =  new  StringBuilder  (  )  ;  while  (  !queue  .  isEmpty  (  )  &&  Character  .  isLetterOrDigit  (  queue  .  peek  (  )  )  )  {  wordAccum  .  append  (  queue  .  removeFirst  (  )  )  ;  }  [ATTENTION]  return  wordAccum  .  StringBuilder  (  )  ;  }    [METHOD]  consumeWord  [TYPE]  String  [PARAMETER]  [CLASS]  TokenQueue    [TYPE]  StringBuilder  wordAccum  [TYPE]  LinkedList  queue  [TYPE]  boolean  false  true  
[REPLACE]  StringBuilder  accum  =  new  StringBuilder  (  )  ;	[BUGGY]  StringBuilder  wordAccum  =  new  StringBuilder  (  )  ;  [CE]  cannot  find  symbol  accum  [CONTEXT]  public  String  consumeCssIdentifier  (  )  {  [ATTENTION]  StringBuilder  wordAccum  =  new  StringBuilder  (  )    ;  Character  c  =  queue  .  peek  (  )  ;  while  (  !queue  .  isEmpty  (  )  &&  (  Character  .  isLetterOrDigit  (  c  )  ||  c  .  equals  (  '-'  )  ||  c  .  equals  (  '_'  )  )  )  {  accum  .  append  (  queue  .  removeFirst  (  )  )  ;  c  =  queue  .  peek  (  )  ;  }  return  accum  .  toString  (  )  ;  }    [METHOD]  consumeCssIdentifier  [TYPE]  String  [PARAMETER]  [CLASS]  TokenQueue    [TYPE]  boolean  false  true  [TYPE]  StringBuilder  accum  [TYPE]  Character  c  [TYPE]  LinkedList  queue  
[REPLACE]  Character  c  =  queue  .  peek  (  )  ;	[BUGGY]  Character  c  =  queue  .  size  (  )  ;  [CE]  incompatible  types  [CONTEXT]  public  String  consumeCssIdentifier  (  )  {  StringBuilder  accum  =  new  StringBuilder  (  )  ;  [ATTENTION]  Character  c  =  queue  .  size  (  )    ;  while  (  !queue  .  isEmpty  (  )  &&  (  Character  .  isLetterOrDigit  (  c  )  ||  c  .  equals  (  '-'  )  ||  c  .  equals  (  '_'  )  )  )  {  accum  .  append  (  queue  .  removeFirst  (  )  )  ;  c  =  queue  .  peek  (  )  ;  }  return  accum  .  toString  (  )  ;  }    [METHOD]  consumeCssIdentifier  [TYPE]  String  [PARAMETER]  [CLASS]  TokenQueue    [TYPE]  boolean  false  true  [TYPE]  StringBuilder  accum  [TYPE]  Character  c  [TYPE]  LinkedList  queue  
[REPLACE]  while  (  !queue  .  isEmpty  (  )  &&  (  Character  .  isLetterOrDigit  (  c  )  ||  c  .  equals  (  '-'  )  ||  c  .  equals  (  '_'  )  )  )  {	[BUGGY]  while  (  !queue  .  isEmpty  (  )  ||  (  Character  .  isLetterOrDigit  (  c  )  ||  c  .  equals  (  '-'  )  ||  c  .  equals  (  '_'  )  )  )  {[FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  String  consumeCssIdentifier  (  )  {  StringBuilder  accum  =  new  StringBuilder  (  )  ;  Character  c  =  queue  .  peek  (  )  ;  [ATTENTION]  while  (  !queue  .  isEmpty  (  )  ||  (  Character  .  isLetterOrDigit  (  c  )  ||  c  .  equals  (  '-'  )  ||  c  .  equals  (  '_'  )  )  )  {  accum  .  append  (  queue  .  removeFirst  (  )  )  ;  c  =  queue  .  peek  (  )  ;  }  return  accum  .  toString  (  )  ;  }    [METHOD]  consumeCssIdentifier  [TYPE]  String  [PARAMETER]  [CLASS]  TokenQueue    [TYPE]  boolean  false  true  [TYPE]  StringBuilder  accum  [TYPE]  Character  c  [TYPE]  LinkedList  queue  
[REPLACE]  c  =  queue  .  peek  (  )  ;	[BUGGY]  c    =    c  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  String  consumeCssIdentifier  (  )  {  StringBuilder  accum  =  new  StringBuilder  (  )  ;  Character  c  =  queue  .  peek  (  )  ;  while  (  !queue  .  isEmpty  (  )  &&  (  Character  .  isLetterOrDigit  (  c  )  ||  c  .  equals  (  '-'  )  ||  c  .  equals  (  '_'  )  )  )  {  accum  .  append  (  queue  .  removeFirst  (  )  )  ;  [ATTENTION]  c  =  c  ;  }  return  accum  .  toString  (  )  ;  }    [METHOD]  consumeCssIdentifier  [TYPE]  String  [PARAMETER]  [CLASS]  TokenQueue    [TYPE]  boolean  false  true  [TYPE]  StringBuilder  accum  [TYPE]  Character  c  [TYPE]  LinkedList  queue  
[ADD]  c  =  queue  .  peek  (  )  ;	[BUGGY]  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  String  consumeCssIdentifier  (  )  {  StringBuilder  accum  =  new  StringBuilder  (  )  ;  Character  c  =  queue  .  peek  (  )  ;  while  (  !queue  .  isEmpty  (  )  &&  (  Character  .  isLetterOrDigit  (  c  )  ||  c  .  equals  (  '-'  )  ||  c  .  equals  (  '_'  )  )  )  {  accum  .  append  (  queue  .  removeFirst  (  )  )  ;  [ATTENTION]  }  return  accum  .  toString  (  )  ;  }    [METHOD]  consumeCssIdentifier  [TYPE]  String  [PARAMETER]  [CLASS]  TokenQueue    [TYPE]  boolean  false  true  [TYPE]  StringBuilder  accum  [TYPE]  Character  c  [TYPE]  LinkedList  queue  
[REPLACE]  return  accum  .  toString  (  )  ;	[BUGGY]  return  accum  .  StringBuilder  (  )    ;  [CE]  cannot  find  symbol  [CONTEXT]  public  String  consumeCssIdentifier  (  )  {  StringBuilder  accum  =  new  StringBuilder  (  )  ;  Character  c  =  queue  .  peek  (  )  ;  while  (  !queue  .  isEmpty  (  )  &&  (  Character  .  isLetterOrDigit  (  c  )  ||  c  .  equals  (  '-'  )  ||  c  .  equals  (  '_'  )  )  )  {  accum  .  append  (  queue  .  removeFirst  (  )  )  ;  c  =  queue  .  peek  (  )  ;  }  [ATTENTION]  return  accum  .  StringBuilder  (  )  ;  }    [METHOD]  consumeCssIdentifier  [TYPE]  String  [PARAMETER]  [CLASS]  TokenQueue    [TYPE]  boolean  false  true  [TYPE]  StringBuilder  accum  [TYPE]  Character  c  [TYPE]  LinkedList  queue  
[REPLACE]  StringBuilder  accum  =  new  StringBuilder  (  )  ;	[BUGGY]  StringBuilder  wordAccum  =  new  StringBuilder  (  )  ;  [CE]  cannot  find  symbol  accum  [CONTEXT]  public  String  consumeAttributeKey  (  )  {  [ATTENTION]  StringBuilder  wordAccum  =  new  StringBuilder  (  )    ;  while  (  !queue  .  isEmpty  (  )  &&  (  Character  .  isLetterOrDigit  (  queue  .  peek  (  )  )  ||  matchesAny  (   "- "  ,   "_ "  ,   ": "  )  )  )  {  accum  .  append  (  queue  .  removeFirst  (  )  )  ;  }  return  accum  .  toString  (  )  ;  }    [METHOD]  consumeAttributeKey  [TYPE]  String  [PARAMETER]  [CLASS]  TokenQueue    [TYPE]  StringBuilder  accum  [TYPE]  LinkedList  queue  [TYPE]  boolean  false  true  
[REPLACE]  while  (  !queue  .  isEmpty  (  )  &&  (  Character  .  isLetterOrDigit  (  queue  .  peek  (  )  )  ||  matchesAny  (   "- ",   "_ ",   ": "  )  )  )  {	[BUGGY]  while  (  !queue  .  isEmpty  (  )    !  =    (  Character  .  isWhitespace  (  queue  .  peek  (  )  )  ||  matchesAny  (   "- "  ,   "_ "  ,   ": "  )  )  )  {[FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  String  consumeAttributeKey  (  )  {  StringBuilder  accum  =  new  StringBuilder  (  )  ;  [ATTENTION]  while  (  !queue  .  isEmpty  (  )  !  =    (  Character  .  isWhitespace  (  queue  .  peek  (  )  )  ||  matchesAny  (   "- "  ,   "_ "  ,   ": "  )  )  )  {  accum  .  append  (  queue  .  removeFirst  (  )  )  ;  }  return  accum  .  toString  (  )  ;  }    [METHOD]  consumeAttributeKey  [TYPE]  String  [PARAMETER]  [CLASS]  TokenQueue    [TYPE]  StringBuilder  accum  [TYPE]  LinkedList  queue  [TYPE]  boolean  false  true  
[REPLACE]  accum  .  append  (  queue  .  removeFirst  (  )  )  ;	[BUGGY]  accum  .  StringBuilder  (  )    ;  [CE]  cannot  find  symbol  [CONTEXT]  public  String  consumeAttributeKey  (  )  {  StringBuilder  accum  =  new  StringBuilder  (  )  ;  while  (  !queue  .  isEmpty  (  )  &&  (  Character  .  isLetterOrDigit  (  queue  .  peek  (  )  )  ||  matchesAny  (   "- "  ,   "_ "  ,   ": "  )  )  )  {  [ATTENTION]  accum  .  StringBuilder  (  )  ;  }  return  accum  .  toString  (  )  ;  }    [METHOD]  consumeAttributeKey  [TYPE]  String  [PARAMETER]  [CLASS]  TokenQueue    [TYPE]  StringBuilder  accum  [TYPE]  LinkedList  queue  [TYPE]  boolean  false  true  
[REPLACE]  accum  .  append  (  queue  .  removeFirst  (  )  )  ;	[BUGGY]  accum  .  append  (  queue  .  LinkedList  (  )  )  ;  [CE]  cannot  find  symbol  [CONTEXT]  public  String  consumeAttributeKey  (  )  {  StringBuilder  accum  =  new  StringBuilder  (  )  ;  while  (  !queue  .  isEmpty  (  )  &&  (  Character  .  isLetterOrDigit  (  queue  .  peek  (  )  )  ||  matchesAny  (   "- "  ,   "_ "  ,   ": "  )  )  )  {  [ATTENTION]  accum  .  append  (  queue  .  LinkedList  (  )  )    ;  }  return  accum  .  toString  (  )  ;  }    [METHOD]  consumeAttributeKey  [TYPE]  String  [PARAMETER]  [CLASS]  TokenQueue    [TYPE]  StringBuilder  accum  [TYPE]  LinkedList  queue  [TYPE]  boolean  false  true  
[REPLACE]  return  accum  .  toString  (  )  ;	[BUGGY]  return  accum  .  StringBuilder  (  )  ;  [CE]  cannot  find  symbol  [CONTEXT]  public  String  consumeAttributeKey  (  )  {  StringBuilder  accum  =  new  StringBuilder  (  )  ;  while  (  !queue  .  isEmpty  (  )  &&  (  Character  .  isLetterOrDigit  (  queue  .  peek  (  )  )  ||  matchesAny  (   "- "  ,   "_ "  ,   ": "  )  )  )  {  accum  .  append  (  queue  .  removeFirst  (  )  )  ;  }  [ATTENTION]  return  accum  .  StringBuilder  (  )    ;  }    [METHOD]  consumeAttributeKey  [TYPE]  String  [PARAMETER]  [CLASS]  TokenQueue    [TYPE]  StringBuilder  accum  [TYPE]  LinkedList  queue  [TYPE]  boolean  false  true  
[REPLACE]  StringBuilder  accum  =  new  StringBuilder  (  )  ;	[BUGGY]  StringBuilder  wordAccum  =  new  StringBuilder  (  )  ;  [CE]  cannot  find  symbol  accum  [CONTEXT]  public  String  remainder  (  )  {  [ATTENTION]  StringBuilder  wordAccum  =  new  StringBuilder  (  )    ;  while  (  !queue  .  isEmpty  (  )  )  {  accum  .  append  (  consume  (  )  )  ;  }  return  accum  .  toString  (  )  ;  }    [METHOD]  remainder  [TYPE]  String  [PARAMETER]  [CLASS]  TokenQueue    [TYPE]  StringBuilder  accum  [TYPE]  LinkedList  queue  [TYPE]  boolean  false  true  
[ADD]  StringBuilder  accum  =  new  StringBuilder  (  )  ;	[BUGGY]  [CE]  cannot  find  symbol  accum  [CONTEXT]  public  String  remainder  (  )  {  [ATTENTION]  while  (  !queue  .  isEmpty  (  )  )  {  accum  .  append  (  consume  (  )  )  ;  }  return  accum  .  toString  (  )  ;  }    [METHOD]  remainder  [TYPE]  String  [PARAMETER]  [CLASS]  TokenQueue    [TYPE]  StringBuilder  accum  [TYPE]  LinkedList  queue  [TYPE]  boolean  false  true  
[REPLACE]  accum  .  append  (  consume  (  )  )  ;	[BUGGY]  while  (  !queue  .  isEmpty  (  )  )  {  accum  .  append  (  consume  (  )  )  ;  [CE]  illegal  start  of  expression  [CONTEXT]  public  String  remainder  (  )  {  StringBuilder  accum  =  new  StringBuilder  (  )  ;  while  (  !queue  .  isEmpty  (  )  )  {  [ATTENTION]  while  (  !queue  .  isEmpty  (  )  )  {  accum  .  append  (  consume  (  )  )    ;  }  return  accum  .  toString  (  )  ;  }    [METHOD]  remainder  [TYPE]  String  [PARAMETER]  [CLASS]  TokenQueue    [TYPE]  StringBuilder  accum  [TYPE]  LinkedList  queue  [TYPE]  boolean  false  true  
[REMOVE]  	[BUGGY]  while  (  !queue  .  isEmpty  (  )  )  {  accum  .  append  (  consume  (  )  )  ;  [CE]  illegal  start  of  expression  [CONTEXT]  public  String  remainder  (  )  {  StringBuilder  accum  =  new  StringBuilder  (  )  ;  while  (  !queue  .  isEmpty  (  )  )  {  [ATTENTION]  accum  .  append  (  consume  (  )  )  ;    while  (  !queue  .  isEmpty  (  )  )  {  accum  .  append  (  consume  (  )  )    ;  }  return  accum  .  toString  (  )  ;      [METHOD]  remainder  [TYPE]  String  [PARAMETER]  [CLASS]  TokenQueue    [TYPE]  StringBuilder  accum  [TYPE]  LinkedList  queue  [TYPE]  boolean  false  true  
[REPLACE]  return  accum  .  toString  (  )  ;	[BUGGY]  return  accum  .  StringBuilder  (  )    ;  [CE]  cannot  find  symbol  [CONTEXT]  public  String  remainder  (  )  {  StringBuilder  accum  =  new  StringBuilder  (  )  ;  while  (  !queue  .  isEmpty  (  )  )  {  accum  .  append  (  consume  (  )  )  ;  }  [ATTENTION]  return  accum  .  StringBuilder  (  )  ;  }    [METHOD]  remainder  [TYPE]  String  [PARAMETER]  [CLASS]  TokenQueue    [TYPE]  StringBuilder  accum  [TYPE]  LinkedList  queue  [TYPE]  boolean  false  true  
[REPLACE]  return  queue  .  toString  (  )  ;	[BUGGY]  return  queue  .  isEmpty  (  )  ;  [CE]  incompatible  types  [CONTEXT]  public  String  toString  (  )  {  [ATTENTION]  return  queue  .  isEmpty  (  )    ;  }    [METHOD]  toString  [TYPE]  String  [PARAMETER]  [CLASS]  TokenQueue    [TYPE]  LinkedList  queue  [TYPE]  boolean  false  true  
[REPLACE]  private  static  final  String  SQ  =   "' ";	[BUGGY]  private  static    int  SQ  =   "' "  ;  [CE]  incompatible  types  [CONTEXT]      [CLASS]  Parser  
[REPLACE]  private  static  final  String  DQ  =   "\ " ";	[BUGGY]  private  static  final  double  DQ  =   "\ " "  ;  [CE]  incompatible  types  [CONTEXT]      [CLASS]  Parser  
[REPLACE]  private  static  final  Tag  htmlTag  =  Tag  .  valueOf  (   "html "  )  ;	[BUGGY]  private  static  final  Tag  htmlTag    =  null  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]      [CLASS]  Parser  
[REPLACE]  private  static  final  Tag  headTag  =  Tag  .  valueOf  (   "head "  )  ;	[BUGGY]  private  static  Tag  headTag  =  Tag  .  valueOf  (   "head "  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]      [CLASS]  Parser  
[REPLACE]  private  static  final  Tag  bodyTag  =  Tag  .  valueOf  (   "body "  )  ;	[BUGGY]  private  static  final  Tag  bodyTag  ;  [CE]  variable  bodyTag  might  not  have  been  initialized  [CONTEXT]      [CLASS]  Parser  
[REPLACE]  private  static  final  Tag  titleTag  =  Tag  .  valueOf  (   "title "  )  ;	[BUGGY]  private  static  final  Tag  titleTag  ;  [CE]  variable  titleTag  might  not  have  been  initialized  [CONTEXT]      [CLASS]  Parser  
[REPLACE]  private  static  final  Tag  textareaTag  =  Tag  .  valueOf  (   "textarea "  )  ;	[BUGGY]  private  static  final  Tag  textareaTag    =  null  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]      [CLASS]  Parser  
[REPLACE]  private  final  LinkedList<Element>  stack;	[BUGGY]  private  LinkedList<Element>  stack  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]      [CLASS]  Parser  
[REPLACE]  private  final  TokenQueue  tq;	[BUGGY]  private  TokenQueue  tq  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]      [CLASS]  Parser  
[REPLACE]  Validate  .  notNull  (  html  )  ;	[BUGGY]  html    ;  [CE]  not  a  statement  [CONTEXT]  private  Parser  (  String  html  ,  String  baseUri  ,  boolean  isBodyFragment  )  {  [ATTENTION]  html  ;  Validate  .  notNull  (  baseUri  )  ;    stack  =  new  LinkedList<Element>  (  )  ;  tq  =  new  TokenQueue  (  html  )  ;  this  .  baseUri  =  baseUri  ;    if  (  isBodyFragment  )  {  doc  =  Document  .  createShell  (  baseUri  )  ;  stack  .  add  (  doc  .  body  (  )  )  ;  }  else  {  doc  =  new  Document  (  baseUri  )  ;  stack  .  add  (  doc  )  ;  }  }    [METHOD]  <init>  [TYPE]  String  ,  boolean)  [PARAMETER]  String  html  String  baseUri  boolean  isBodyFragment  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  String  DQ  SQ  baseUri  html  [TYPE]  Tag  bodyTag  headTag  htmlTag  textareaTag  titleTag  [TYPE]  boolean  false  isBodyFragment  true  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[REPLACE]  Validate  .  notNull  (  baseUri  )  ;	[BUGGY]  Validate  .  notNull  (  SQ  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  private  Parser  (  String  html  ,  String  baseUri  ,  boolean  isBodyFragment  )  {  Validate  .  notNull  (  html  )  ;  [ATTENTION]  Validate  .  notNull  (  SQ  )    ;    stack  =  new  LinkedList<Element>  (  )  ;  tq  =  new  TokenQueue  (  html  )  ;  this  .  baseUri  =  baseUri  ;    if  (  isBodyFragment  )  {  doc  =  Document  .  createShell  (  baseUri  )  ;  stack  .  add  (  doc  .  body  (  )  )  ;  }  else  {  doc  =  new  Document  (  baseUri  )  ;  stack  .  add  (  doc  )  ;  }  }    [METHOD]  <init>  [TYPE]  String  ,  boolean)  [PARAMETER]  String  html  String  baseUri  boolean  isBodyFragment  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  String  DQ  SQ  baseUri  html  [TYPE]  Tag  bodyTag  headTag  htmlTag  textareaTag  titleTag  [TYPE]  boolean  false  isBodyFragment  true  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[REPLACE]  stack  =  new  LinkedList<Element>  (  )  ;	[BUGGY]  stack    =  null  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  private  Parser  (  String  html  ,  String  baseUri  ,  boolean  isBodyFragment  )  {  Validate  .  notNull  (  html  )  ;  Validate  .  notNull  (  baseUri  )  ;    [ATTENTION]  stack  =  null  ;  tq  =  new  TokenQueue  (  html  )  ;  this  .  baseUri  =  baseUri  ;    if  (  isBodyFragment  )  {  doc  =  Document  .  createShell  (  baseUri  )  ;  stack  .  add  (  doc  .  body  (  )  )  ;  }  else  {  doc  =  new  Document  (  baseUri  )  ;  stack  .  add  (  doc  )  ;  }  }    [METHOD]  <init>  [TYPE]  String  ,  boolean)  [PARAMETER]  String  html  String  baseUri  boolean  isBodyFragment  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  String  DQ  SQ  baseUri  html  [TYPE]  Tag  bodyTag  headTag  htmlTag  textareaTag  titleTag  [TYPE]  boolean  false  isBodyFragment  true  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[REPLACE]  tq  =  new  TokenQueue  (  html  )  ;	[BUGGY]  tq  =    new  TokenQueue  (  null  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  private  Parser  (  String  html  ,  String  baseUri  ,  boolean  isBodyFragment  )  {  Validate  .  notNull  (  html  )  ;  Validate  .  notNull  (  baseUri  )  ;    stack  =  new  LinkedList<Element>  (  )  ;  [ATTENTION]  tq  =  new  TokenQueue  (  null  )    ;  this  .  baseUri  =  baseUri  ;    if  (  isBodyFragment  )  {  doc  =  Document  .  createShell  (  baseUri  )  ;  stack  .  add  (  doc  .  body  (  )  )  ;  }  else  {  doc  =  new  Document  (  baseUri  )  ;  stack  .  add  (  doc  )  ;  }  }    [METHOD]  <init>  [TYPE]  String  ,  boolean)  [PARAMETER]  String  html  String  baseUri  boolean  isBodyFragment  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  String  DQ  SQ  baseUri  html  [TYPE]  Tag  bodyTag  headTag  htmlTag  textareaTag  titleTag  [TYPE]  boolean  false  isBodyFragment  true  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[ADD]  tq  =  new  TokenQueue  (  html  )  ;  this  .  baseUri  =  baseUri;	[BUGGY]  this  .  baseUri  =  baseUri  ;  [CE]  variable  tq  might  not  have  been  initialized  [CONTEXT]  private  Parser  (  String  html  ,  String  baseUri  ,  boolean  isBodyFragment  )  {  Validate  .  notNull  (  html  )  ;  Validate  .  notNull  (  baseUri  )  ;    stack  =  new  LinkedList<Element>  (  )  ;  [ATTENTION]  this  .  baseUri  =  baseUri  ;    if  (  isBodyFragment  )  {  doc  =  Document  .  createShell  (  baseUri  )  ;  stack  .  add  (  doc  .  body  (  )  )  ;  }  else  {  doc  =  new  Document  (  baseUri  )  ;  stack  .  add  (  doc  )  ;  }  }    [METHOD]  <init>  [TYPE]  String  ,  boolean)  [PARAMETER]  String  html  String  baseUri  boolean  isBodyFragment  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  String  DQ  SQ  baseUri  html  [TYPE]  Tag  bodyTag  headTag  htmlTag  textareaTag  titleTag  [TYPE]  boolean  false  isBodyFragment  true  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[REPLACE]  this  .  baseUri  =  baseUri;	[BUGGY]  this  .  baseUri  =    SQ  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  private  Parser  (  String  html  ,  String  baseUri  ,  boolean  isBodyFragment  )  {  Validate  .  notNull  (  html  )  ;  Validate  .  notNull  (  baseUri  )  ;    stack  =  new  LinkedList<Element>  (  )  ;  tq  =  new  TokenQueue  (  html  )  ;  [ATTENTION]  this  .  baseUri  =  SQ  ;    if  (  isBodyFragment  )  {  doc  =  Document  .  createShell  (  baseUri  )  ;  stack  .  add  (  doc  .  body  (  )  )  ;  }  else  {  doc  =  new  Document  (  baseUri  )  ;  stack  .  add  (  doc  )  ;  }  }    [METHOD]  <init>  [TYPE]  String  ,  boolean)  [PARAMETER]  String  html  String  baseUri  boolean  isBodyFragment  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  String  DQ  SQ  baseUri  html  [TYPE]  Tag  bodyTag  headTag  htmlTag  textareaTag  titleTag  [TYPE]  boolean  false  isBodyFragment  true  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[REPLACE]  if  (  isBodyFragment  )  {	[BUGGY]  if  (  true  )  {[FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  private  Parser  (  String  html  ,  String  baseUri  ,  boolean  isBodyFragment  )  {  Validate  .  notNull  (  html  )  ;  Validate  .  notNull  (  baseUri  )  ;    stack  =  new  LinkedList<Element>  (  )  ;  tq  =  new  TokenQueue  (  html  )  ;  this  .  baseUri  =  baseUri  ;    [ATTENTION]  if  (  true  )  {  doc  =  Document  .  createShell  (  baseUri  )  ;  stack  .  add  (  doc  .  body  (  )  )  ;  }  else  {  doc  =  new  Document  (  baseUri  )  ;  stack  .  add  (  doc  )  ;  }  }    [METHOD]  <init>  [TYPE]  String  ,  boolean)  [PARAMETER]  String  html  String  baseUri  boolean  isBodyFragment  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  String  DQ  SQ  baseUri  html  [TYPE]  Tag  bodyTag  headTag  htmlTag  textareaTag  titleTag  [TYPE]  boolean  false  isBodyFragment  true  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[REPLACE]  doc  =  new  Document  (  baseUri  )  ;	[BUGGY]  doc  =    new  Document  (  SQ  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  private  Parser  (  String  html  ,  String  baseUri  ,  boolean  isBodyFragment  )  {  Validate  .  notNull  (  html  )  ;  Validate  .  notNull  (  baseUri  )  ;    stack  =  new  LinkedList<Element>  (  )  ;  tq  =  new  TokenQueue  (  html  )  ;  this  .  baseUri  =  baseUri  ;    if  (  isBodyFragment  )  {  doc  =  Document  .  createShell  (  baseUri  )  ;  stack  .  add  (  doc  .  body  (  )  )  ;  }  else  {  [ATTENTION]  doc  =  new  Document  (  SQ  )    ;  stack  .  add  (  doc  )  ;  }  }    [METHOD]  <init>  [TYPE]  String  ,  boolean)  [PARAMETER]  String  html  String  baseUri  boolean  isBodyFragment  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  String  DQ  SQ  baseUri  html  [TYPE]  Tag  bodyTag  headTag  htmlTag  textareaTag  titleTag  [TYPE]  boolean  false  isBodyFragment  true  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[ADD]  doc  =  new  Document  (  baseUri  )  ;  stack  .  add  (  doc  )  ;	[BUGGY]  stack  .  add  (  doc  )  ;  [CE]  variable  doc  might  not  have  been  initialized  [CONTEXT]  private  Parser  (  String  html  ,  String  baseUri  ,  boolean  isBodyFragment  )  {  Validate  .  notNull  (  html  )  ;  Validate  .  notNull  (  baseUri  )  ;    stack  =  new  LinkedList<Element>  (  )  ;  tq  =  new  TokenQueue  (  html  )  ;  this  .  baseUri  =  baseUri  ;    if  (  isBodyFragment  )  {  doc  =  Document  .  createShell  (  baseUri  )  ;  stack  .  add  (  doc  .  body  (  )  )  ;  }  else  {  [ATTENTION]  stack  .  add  (  doc  )    ;    }  }    [METHOD]  <init>  [TYPE]  String  ,  boolean)  [PARAMETER]  String  html  String  baseUri  boolean  isBodyFragment  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  String  DQ  SQ  baseUri  html  [TYPE]  Tag  bodyTag  headTag  htmlTag  textareaTag  titleTag  [TYPE]  boolean  false  isBodyFragment  true  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[REPLACE]  doc  =  Document  .  createShell  (  baseUri  )  ;	[BUGGY]  doc  =    Document  .  createShell  (  SQ  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  private  Parser  (  String  html  ,  String  baseUri  ,  boolean  isBodyFragment  )  {  Validate  .  notNull  (  html  )  ;  Validate  .  notNull  (  baseUri  )  ;    stack  =  new  LinkedList<Element>  (  )  ;  tq  =  new  TokenQueue  (  html  )  ;  this  .  baseUri  =  baseUri  ;    if  (  isBodyFragment  )  {  [ATTENTION]  doc  =  Document  .  createShell  (  SQ  )    ;  stack  .  add  (  doc  .  body  (  )  )  ;  }  else  {  doc  =  new  Document  (  baseUri  )  ;  stack  .  add  (  doc  )  ;  }  }    [METHOD]  <init>  [TYPE]  String  ,  boolean)  [PARAMETER]  String  html  String  baseUri  boolean  isBodyFragment  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  String  DQ  SQ  baseUri  html  [TYPE]  Tag  bodyTag  headTag  htmlTag  textareaTag  titleTag  [TYPE]  boolean  false  isBodyFragment  true  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[REPLACE]  Parser  parser  =  new  Parser  (  html,  baseUri,  false  )  ;	[BUGGY]  Parser  parser  =  new  Parser  (  html  ,  baseUri  ,  true  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  static  Document  parse  (  String  html  ,  String  baseUri  )  {  [ATTENTION]  Parser  parser  =  new  Parser  (  html  ,  baseUri  ,  true  )    ;  return  parser  .  parse  (  )  ;  }    [METHOD]  parse  [TYPE]  Document  [PARAMETER]  String  html  String  baseUri  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  String  DQ  SQ  baseUri  html  [TYPE]  Tag  bodyTag  headTag  htmlTag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  [TYPE]  Parser  parser  
[REPLACE]  return  parser  .  parse  (  )  ;	[BUGGY]  return  .  lastr  .  parse  (  )  ;  [CE]  illegal  start  of  expression  [CONTEXT]  public  static  Document  parse  (  String  html  ,  String  baseUri  )  {  Parser  parser  =  new  Parser  (  html  ,  baseUri  ,  false  )  ;  [ATTENTION]  return  .  lastr  .  parse  (  )    ;  }    [METHOD]  parse  [TYPE]  Document  [PARAMETER]  String  html  String  baseUri  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  String  DQ  SQ  baseUri  html  [TYPE]  Tag  bodyTag  headTag  htmlTag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  [TYPE]  Parser  parser  
[REPLACE]  Parser  parser  =  new  Parser  (  bodyHtml,  baseUri,  true  )  ;	[BUGGY]  Parser  parser  =  new  Parser  (  bodyHtml  ,  baseUri  ,  false  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  static  Document  parseBodyFragment  (  String  bodyHtml  ,  String  baseUri  )  {  [ATTENTION]  Parser  parser  =  new  Parser  (  bodyHtml  ,  baseUri  ,  false  )    ;  return  parser  .  parse  (  )  ;  }    [METHOD]  parseBodyFragment  [TYPE]  Document  [PARAMETER]  String  bodyHtml  String  baseUri  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  html  [TYPE]  Tag  bodyTag  headTag  htmlTag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  [TYPE]  Parser  parser  
[REPLACE]  return  parser  .  parse  (  )  ;	[BUGGY]  return  parser  .  parse  (  SQ  ,  DQ  )    ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  static  Document  parseBodyFragment  (  String  bodyHtml  ,  String  baseUri  )  {  Parser  parser  =  new  Parser  (  bodyHtml  ,  baseUri  ,  true  )  ;  [ATTENTION]  return  parser  .  parse  (  SQ  ,  DQ  )  ;  }    [METHOD]  parseBodyFragment  [TYPE]  Document  [PARAMETER]  String  bodyHtml  String  baseUri  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  html  [TYPE]  Tag  bodyTag  headTag  htmlTag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  [TYPE]  Parser  parser  
[REPLACE]  while  (  !tq  .  isEmpty  (  )  )  {	[BUGGY]  while  (  tq  .  isEmpty  (  )  )  {[FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  private  Document  parse  (  )  {  [ATTENTION]  while  (  tq  .  isEmpty  (  )  )  {  if  (  tq  .  matches  (   "<!-- "  )  )  {  parseComment  (  )  ;  }  else  if  (  tq  .  matches  (   "<![CDATA[ "  )  )  {  parseCdata  (  )  ;  }  else  if  (  tq  .  matches  (   "<? "  )  ||  tq  .  matches  (   "<! "  )  )  {  parseXmlDecl  (  )  ;  }  else  if  (  tq  .  matches  (   "</ "  )  )  {  parseEndTag  (  )  ;  }  else  if  (  tq  .  matches  (   "< "  )  )  {  parseStartTag  (  )  ;  }  else  {  parseTextNode  (  )  ;  }  }  return  doc  .  normalise  (  )  ;  }    [METHOD]  parse  [TYPE]  Document  [PARAMETER]  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  html  [TYPE]  Tag  bodyTag  headTag  htmlTag  textareaTag  titleTag  [TYPE]  boolean  false  true  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[REPLACE]  if  (  tq  .  matches  (   "<!-- "  )  )  {	[BUGGY]  if  (  tq  .  matches  (   "<-- "  )  )  {[FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  private  Document  parse  (  )  {  while  (  !tq  .  isEmpty  (  )  )  {  [ATTENTION]  if  (  tq  .  matches  (   "<-- "  )  )  {  parseComment  (  )  ;  }  else  if  (  tq  .  matches  (   "<![CDATA[ "  )  )  {  parseCdata  (  )  ;  }  else  if  (  tq  .  matches  (   "<? "  )  ||  tq  .  matches  (   "<! "  )  )  {  parseXmlDecl  (  )  ;  }  else  if  (  tq  .  matches  (   "</ "  )  )  {  parseEndTag  (  )  ;  }  else  if  (  tq  .  matches  (   "< "  )  )  {  parseStartTag  (  )  ;  }  else  {  parseTextNode  (  )  ;  }  }  return  doc  .  normalise  (  )  ;  }    [METHOD]  parse  [TYPE]  Document  [PARAMETER]  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  html  [TYPE]  Tag  bodyTag  headTag  htmlTag  textareaTag  titleTag  [TYPE]  boolean  false  true  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[REMOVE]  	[BUGGY]  if  (  tq  .  matches  (   "<![CDATA[ "  )  )  {      parseCdata  (  )  ;  }else      if  (  (  tq  .  matches  (   "<? "  )  )  ||  (  tq  .  matches  (   "<! "  )  )  )  {          parseXmlDecl  (  )  ;      }else          if  (  tq  .  matches  (   "</ "  )  )  {              parseEndTag  (  )  ;          }else              if  (  tq  .  matches  (   "< "  )  )  {                  parseStartTag  (  )  ;              }else  {                  parseTextNode  (  )  ;              }[FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  private  Document  parse  (  )  {  while  (  !tq  .  isEmpty  (  )  )  {  [ATTENTION]  if  (  tq  .  matches  (   "<!-- "  )  )  {  if  (  tq  .  matches  (   "<![CDATA[ "  )  )  {  parseCdata  (  )    ;  }else  if  (  (  tq  .  matches  (   "<? "  )  )  ||  (  tq  .  matches  (   "<! "  )  )  )  {  parseXmlDecl  (  )    ;  }else  if  (  tq  .  matches  (   "</ "  )  )  {  parseEndTag  (  )    ;  }else  if  (  tq  .  matches  (   "< "  )  )  {  parseStartTag  (  )    ;  }else  {  parseTextNode  (  )    ;  }parseComment  (  )  ;  }  else  if  (  tq  .  matches  (   "<![CDATA[ "  )  )  {  parseCdata  (  )  ;  }  else  if  (  tq  .  matches  (   "<? "  )  ||  tq  .  matches  (   "<! "  )  )  {  parseXmlDecl  (  )  ;  }  else  if  (  tq  .  matches  (   "</ "  )  )  {  parseEndTag  (  )  ;  }  else  if  (  tq  .  matches  (   "< "  )  )  {  parseStartTag  (  )  ;  }  else  {  parseTextNode  (  )  ;  }  }  return  doc  .  normalise  (  )  ;      [METHOD]  parse  [TYPE]  Document  [PARAMETER]  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  html  [TYPE]  Tag  bodyTag  headTag  htmlTag  textareaTag  titleTag  [TYPE]  boolean  false  true  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[REPLACE]  }  else  if  (  tq  .  matches  (   "<![CDATA[ "  )  )  {	[BUGGY]    else  {[CE]  [CONTEXT]  private  Document  parse  (  )  {  while  (  !tq  .  isEmpty  (  )  )  {  if  (  tq  .  matches  (   "<!-- "  )  )  {  parseComment  (  )  ;  [ATTENTION]  }else  {  parseCdata  (  )  ;  }  else  if  (  tq  .  matches  (   "<? "  )  ||  tq  .  matches  (   "<! "  )  )  {  parseXmlDecl  (  )  ;  }  else  if  (  tq  .  matches  (   "</ "  )  )  {  parseEndTag  (  )  ;  }  else  if  (  tq  .  matches  (   "< "  )  )  {  parseStartTag  (  )  ;  }  else  {  parseTextNode  (  )  ;  }  }  return  doc  .  normalise  (  )  ;  }    [METHOD]  parse  [TYPE]  Document  [PARAMETER]  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  html  [TYPE]  Tag  bodyTag  headTag  htmlTag  textareaTag  titleTag  [TYPE]  boolean  false  true  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[REPLACE]  }  else  if  (  tq  .  matches  (   "<? "  )  ||  tq  .  matches  (   "<! "  )  )  {	[BUGGY]    if  (  tq  .  matches  (   "<? "  )  )  {[FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  private  Document  parse  (  )  {  while  (  !tq  .  isEmpty  (  )  )  {  if  (  tq  .  matches  (   "<!-- "  )  )  {  parseComment  (  )  ;  }  else  if  (  tq  .  matches  (   "<![CDATA[ "  )  )  {  parseCdata  (  )  ;  [ATTENTION]  }if  (  tq  .  matches  (   "<? "  )  )  {  parseXmlDecl  (  )  ;  }  else  if  (  tq  .  matches  (   "</ "  )  )  {  parseEndTag  (  )  ;  }  else  if  (  tq  .  matches  (   "< "  )  )  {  parseStartTag  (  )  ;  }  else  {  parseTextNode  (  )  ;  }  }  return  doc  .  normalise  (  )  ;  }    [METHOD]  parse  [TYPE]  Document  [PARAMETER]  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  html  [TYPE]  Tag  bodyTag  headTag  htmlTag  textareaTag  titleTag  [TYPE]  boolean  false  true  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[REPLACE]  }  else  if  (  tq  .  matches  (   "</ "  )  )  {	[BUGGY]  else  if  (  tq  .  matchChomp  (  DQ  )  )  {[FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  private  Document  parse  (  )  {  while  (  !tq  .  isEmpty  (  )  )  {  if  (  tq  .  matches  (   "<!-- "  )  )  {  parseComment  (  )  ;  }  else  if  (  tq  .  matches  (   "<![CDATA[ "  )  )  {  parseCdata  (  )  ;  }  else  if  (  tq  .  matches  (   "<? "  )  ||  tq  .  matches  (   "<! "  )  )  {  parseXmlDecl  (  )  ;  [ATTENTION]  }  else  if  (  tq  .  matchChomp  (  DQ  )  )  {  parseEndTag  (  )  ;  }  else  if  (  tq  .  matches  (   "< "  )  )  {  parseStartTag  (  )  ;  }  else  {  parseTextNode  (  )  ;  }  }  return  doc  .  normalise  (  )  ;  }    [METHOD]  parse  [TYPE]  Document  [PARAMETER]  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  html  [TYPE]  Tag  bodyTag  headTag  htmlTag  textareaTag  titleTag  [TYPE]  boolean  false  true  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[REPLACE]  }  else  if  (  tq  .  matches  (   "< "  )  )  {	[BUGGY]    else  {[CE]  'else'  without  'if'  [CONTEXT]  private  Document  parse  (  )  {  while  (  !tq  .  isEmpty  (  )  )  {  if  (  tq  .  matches  (   "<!-- "  )  )  {  parseComment  (  )  ;  }  else  if  (  tq  .  matches  (   "<![CDATA[ "  )  )  {  parseCdata  (  )  ;  }  else  if  (  tq  .  matches  (   "<? "  )  ||  tq  .  matches  (   "<! "  )  )  {  parseXmlDecl  (  )  ;  }  else  if  (  tq  .  matches  (   "</ "  )  )  {  parseEndTag  (  )  ;  [ATTENTION]  }else  {  parseStartTag  (  )  ;  }  else  {  parseTextNode  (  )  ;  }  }  return  doc  .  normalise  (  )  ;  }    [METHOD]  parse  [TYPE]  Document  [PARAMETER]  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  html  [TYPE]  Tag  bodyTag  headTag  htmlTag  textareaTag  titleTag  [TYPE]  boolean  false  true  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[REPLACE]  parseTextNode  (  )  ;	[BUGGY]  Validate  .  notNull  (  html  )  ;  [CE]  cannot  find  symbol  html  [CONTEXT]  private  Document  parse  (  )  {  while  (  !tq  .  isEmpty  (  )  )  {  if  (  tq  .  matches  (   "<!-- "  )  )  {  parseComment  (  )  ;  }  else  if  (  tq  .  matches  (   "<![CDATA[ "  )  )  {  parseCdata  (  )  ;  }  else  if  (  tq  .  matches  (   "<? "  )  ||  tq  .  matches  (   "<! "  )  )  {  parseXmlDecl  (  )  ;  }  else  if  (  tq  .  matches  (   "</ "  )  )  {  parseEndTag  (  )  ;  }  else  if  (  tq  .  matches  (   "< "  )  )  {  parseStartTag  (  )  ;  }  else  {  [ATTENTION]  Validate  .  notNull  (  html  )    ;  }  }  return  doc  .  normalise  (  )  ;  }    [METHOD]  parse  [TYPE]  Document  [PARAMETER]  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  html  [TYPE]  Tag  bodyTag  headTag  htmlTag  textareaTag  titleTag  [TYPE]  boolean  false  true  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[REPLACE]  parseStartTag  (  )  ;	[BUGGY]  Validate  .  notNull  (  html  )  ;  [CE]  cannot  find  symbol  html  [CONTEXT]  private  Document  parse  (  )  {  while  (  !tq  .  isEmpty  (  )  )  {  if  (  tq  .  matches  (   "<!-- "  )  )  {  parseComment  (  )  ;  }  else  if  (  tq  .  matches  (   "<![CDATA[ "  )  )  {  parseCdata  (  )  ;  }  else  if  (  tq  .  matches  (   "<? "  )  ||  tq  .  matches  (   "<! "  )  )  {  parseXmlDecl  (  )  ;  }  else  if  (  tq  .  matches  (   "</ "  )  )  {  parseEndTag  (  )  ;  }  else  if  (  tq  .  matches  (   "< "  )  )  {  [ATTENTION]  Validate  .  notNull  (  html  )    ;  }  else  {  parseTextNode  (  )  ;  }  }  return  doc  .  normalise  (  )  ;  }    [METHOD]  parse  [TYPE]  Document  [PARAMETER]  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  html  [TYPE]  Tag  bodyTag  headTag  htmlTag  textareaTag  titleTag  [TYPE]  boolean  false  true  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[REPLACE]  parseEndTag  (  )  ;	[BUGGY]  Validate  .  notNull  (  html  )  ;  [CE]  cannot  find  symbol  html  [CONTEXT]  private  Document  parse  (  )  {  while  (  !tq  .  isEmpty  (  )  )  {  if  (  tq  .  matches  (   "<!-- "  )  )  {  parseComment  (  )  ;  }  else  if  (  tq  .  matches  (   "<![CDATA[ "  )  )  {  parseCdata  (  )  ;  }  else  if  (  tq  .  matches  (   "<? "  )  ||  tq  .  matches  (   "<! "  )  )  {  parseXmlDecl  (  )  ;  }  else  if  (  tq  .  matches  (   "</ "  )  )  {  [ATTENTION]  Validate  .  notNull  (  html  )    ;  }  else  if  (  tq  .  matches  (   "< "  )  )  {  parseStartTag  (  )  ;  }  else  {  parseTextNode  (  )  ;  }  }  return  doc  .  normalise  (  )  ;  }    [METHOD]  parse  [TYPE]  Document  [PARAMETER]  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  html  [TYPE]  Tag  bodyTag  headTag  htmlTag  textareaTag  titleTag  [TYPE]  boolean  false  true  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[REPLACE]  }  else  if  (  tq  .  matches  (   "< "  )  )  {	[BUGGY]    if  (  tq  .  matches  (   "< "  )  )  {[FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  private  Document  parse  (  )  {  while  (  !tq  .  isEmpty  (  )  )  {  if  (  tq  .  matches  (   "<!-- "  )  )  {  parseComment  (  )  ;  }  else  if  (  tq  .  matches  (   "<![CDATA[ "  )  )  {  parseCdata  (  )  ;  }  else  if  (  tq  .  matches  (   "<? "  )  ||  tq  .  matches  (   "<! "  )  )  {  parseXmlDecl  (  )  ;  }  else  if  (  tq  .  matches  (   "</ "  )  )  {  parseEndTag  (  )  ;  [ATTENTION]  }if  (  tq  .  matches  (   "< "  )  )  {  parseStartTag  (  )  ;  }  else  {  parseTextNode  (  )  ;  }  }  return  doc  .  normalise  (  )  ;  }    [METHOD]  parse  [TYPE]  Document  [PARAMETER]  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  html  [TYPE]  Tag  bodyTag  headTag  htmlTag  textareaTag  titleTag  [TYPE]  boolean  false  true  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[ADD]  else  if  (  tq  .  matches  (   "< "  )  )  {  parseStartTag  (  )  ;  }  else  {  parseTextNode  (  )  ;  }	[BUGGY]    parseTextNode  (  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  private  Document  parse  (  )  {  while  (  !tq  .  isEmpty  (  )  )  {  if  (  tq  .  matches  (   "<!-- "  )  )  {  parseComment  (  )  ;  }  else  if  (  tq  .  matches  (   "<![CDATA[ "  )  )  {  parseCdata  (  )  ;  }  else  if  (  tq  .  matches  (   "<? "  )  ||  tq  .  matches  (   "<! "  )  )  {  parseXmlDecl  (  )  ;  }  else  if  (  tq  .  matches  (   "</ "  )  )  {  parseEndTag  (  )  ;  [ATTENTION]  }  parseTextNode  (  )    ;      }  return  doc  .  normalise  (  )  ;  }    [METHOD]  parse  [TYPE]  Document  [PARAMETER]  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  html  [TYPE]  Tag  bodyTag  headTag  htmlTag  textareaTag  titleTag  [TYPE]  boolean  false  true  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[REMOVE]  	[BUGGY]  valueAccum  .  append  (  tq  .  consume  (  )  )  ;  [CE]  cannot  find  symbol  valueAccum  [CONTEXT]  private  Document  parse  (  )  {  while  (  !tq  .  isEmpty  (  )  )  {  if  (  tq  .  matches  (   "<!-- "  )  )  {  parseComment  (  )  ;  }  else  if  (  tq  .  matches  (   "<![CDATA[ "  )  )  {  parseCdata  (  )  ;  }  else  if  (  tq  .  matches  (   "<? "  )  ||  tq  .  matches  (   "<! "  )  )  {  parseXmlDecl  (  )  ;  }  else  if  (  tq  .  matches  (   "</ "  )  )  {  parseEndTag  (  )  ;  }  else  if  (  tq  .  matches  (   "< "  )  )  {  parseStartTag  (  )  ;  }  else  {  [ATTENTION]  parseTextNode  (  )  ;    valueAccum  .  append  (  tq  .  consume  (  )  )    ;  }  }  return  doc  .  normalise  (  )  ;      [METHOD]  parse  [TYPE]  Document  [PARAMETER]  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  html  [TYPE]  Tag  bodyTag  headTag  htmlTag  textareaTag  titleTag  [TYPE]  boolean  false  true  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[REPLACE]  parseXmlDecl  (  )  ;	[BUGGY]  Validate  .  notNull  (  html  )  ;  [CE]  cannot  find  symbol  html  [CONTEXT]  private  Document  parse  (  )  {  while  (  !tq  .  isEmpty  (  )  )  {  if  (  tq  .  matches  (   "<!-- "  )  )  {  parseComment  (  )  ;  }  else  if  (  tq  .  matches  (   "<![CDATA[ "  )  )  {  parseCdata  (  )  ;  }  else  if  (  tq  .  matches  (   "<? "  )  ||  tq  .  matches  (   "<! "  )  )  {  [ATTENTION]  Validate  .  notNull  (  html  )    ;  }  else  if  (  tq  .  matches  (   "</ "  )  )  {  parseEndTag  (  )  ;  }  else  if  (  tq  .  matches  (   "< "  )  )  {  parseStartTag  (  )  ;  }  else  {  parseTextNode  (  )  ;  }  }  return  doc  .  normalise  (  )  ;  }    [METHOD]  parse  [TYPE]  Document  [PARAMETER]  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  html  [TYPE]  Tag  bodyTag  headTag  htmlTag  textareaTag  titleTag  [TYPE]  boolean  false  true  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[REPLACE]  }  else  if  (  tq  .  matches  (   "</ "  )  )  {	[BUGGY]    if  (  tq  .  matchesAny  (  html  ,  html  ,  baseUri  )    )  {[CE]  cannot  find  symbol  html  [CONTEXT]  private  Document  parse  (  )  {  while  (  !tq  .  isEmpty  (  )  )  {  if  (  tq  .  matches  (   "<!-- "  )  )  {  parseComment  (  )  ;  }  else  if  (  tq  .  matches  (   "<![CDATA[ "  )  )  {  parseCdata  (  )  ;  }  else  if  (  tq  .  matches  (   "<? "  )  ||  tq  .  matches  (   "<! "  )  )  {  parseXmlDecl  (  )  ;  [ATTENTION]  }if  (  tq  .  matchesAny  (  html  ,  html  ,  baseUri  )    )  {  parseEndTag  (  )  ;  }  else  if  (  tq  .  matches  (   "< "  )  )  {  parseStartTag  (  )  ;  }  else  {  parseTextNode  (  )  ;  }  }  return  doc  .  normalise  (  )  ;  }    [METHOD]  parse  [TYPE]  Document  [PARAMETER]  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  html  [TYPE]  Tag  bodyTag  headTag  htmlTag  textareaTag  titleTag  [TYPE]  boolean  false  true  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[ADD]  else  if  (  tq  .  matches  (   "< "  )  )  {  parseStartTag  (  )  ;  }  else  {  parseTextNode  (  )  ;  }	[BUGGY]    parseStartTag  (  )  ;  parseTextNode  (  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  private  Document  parse  (  )  {  while  (  !tq  .  isEmpty  (  )  )  {  if  (  tq  .  matches  (   "<!-- "  )  )  {  parseComment  (  )  ;  }  else  if  (  tq  .  matches  (   "<![CDATA[ "  )  )  {  parseCdata  (  )  ;  }  else  if  (  tq  .  matches  (   "<? "  )  ||  tq  .  matches  (   "<! "  )  )  {  parseXmlDecl  (  )  ;  }  else  if  (  tq  .  matches  (   "</ "  )  )  {  parseEndTag  (  )  ;  [ATTENTION]  }  parseStartTag  (  )    ;  parseTextNode  (  )    ;      }  return  doc  .  normalise  (  )  ;  }    [METHOD]  parse  [TYPE]  Document  [PARAMETER]  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  html  [TYPE]  Tag  bodyTag  headTag  htmlTag  textareaTag  titleTag  [TYPE]  boolean  false  true  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[REPLACE]  parseCdata  (  )  ;	[BUGGY]  Validate  .  notNull  (  html  )  ;  [CE]  cannot  find  symbol  html  [CONTEXT]  private  Document  parse  (  )  {  while  (  !tq  .  isEmpty  (  )  )  {  if  (  tq  .  matches  (   "<!-- "  )  )  {  parseComment  (  )  ;  }  else  if  (  tq  .  matches  (   "<![CDATA[ "  )  )  {  [ATTENTION]  Validate  .  notNull  (  html  )    ;  }  else  if  (  tq  .  matches  (   "<? "  )  ||  tq  .  matches  (   "<! "  )  )  {  parseXmlDecl  (  )  ;  }  else  if  (  tq  .  matches  (   "</ "  )  )  {  parseEndTag  (  )  ;  }  else  if  (  tq  .  matches  (   "< "  )  )  {  parseStartTag  (  )  ;  }  else  {  parseTextNode  (  )  ;  }  }  return  doc  .  normalise  (  )  ;  }    [METHOD]  parse  [TYPE]  Document  [PARAMETER]  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  html  [TYPE]  Tag  bodyTag  headTag  htmlTag  textareaTag  titleTag  [TYPE]  boolean  false  true  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[REPLACE]  }  else  if  (  tq  .  matches  (   "<? "  )  ||  tq  .  matches  (   "<! "  )  )  {	[BUGGY]    else  {[CE]  [CONTEXT]  private  Document  parse  (  )  {  while  (  !tq  .  isEmpty  (  )  )  {  if  (  tq  .  matches  (   "<!-- "  )  )  {  parseComment  (  )  ;  }  else  if  (  tq  .  matches  (   "<![CDATA[ "  )  )  {  parseCdata  (  )  ;  [ATTENTION]  }else  {  parseXmlDecl  (  )  ;  }  else  if  (  tq  .  matches  (   "</ "  )  )  {  parseEndTag  (  )  ;  }  else  if  (  tq  .  matches  (   "< "  )  )  {  parseStartTag  (  )  ;  }  else  {  parseTextNode  (  )  ;  }  }  return  doc  .  normalise  (  )  ;  }    [METHOD]  parse  [TYPE]  Document  [PARAMETER]  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  html  [TYPE]  Tag  bodyTag  headTag  htmlTag  textareaTag  titleTag  [TYPE]  boolean  false  true  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[REPLACE]  }  else  if  (  tq  .  matches  (   "</ "  )  )  {	[BUGGY]  else  if  (  tq  .  matchesAny  (  bodyHtml  ,  SQ  ,  SQ  )    )  {[CE]  cannot  find  symbol  bodyHtml  [CONTEXT]  private  Document  parse  (  )  {  while  (  !tq  .  isEmpty  (  )  )  {  if  (  tq  .  matches  (   "<!-- "  )  )  {  parseComment  (  )  ;  }  else  if  (  tq  .  matches  (   "<![CDATA[ "  )  )  {  parseCdata  (  )  ;  }  else  if  (  tq  .  matches  (   "<? "  )  ||  tq  .  matches  (   "<! "  )  )  {  parseXmlDecl  (  )  ;  [ATTENTION]  }  else  if  (  tq  .  matchesAny  (  bodyHtml  ,  SQ  ,  SQ  )    )  {  parseEndTag  (  )  ;  }  else  if  (  tq  .  matches  (   "< "  )  )  {  parseStartTag  (  )  ;  }  else  {  parseTextNode  (  )  ;  }  }  return  doc  .  normalise  (  )  ;  }    [METHOD]  parse  [TYPE]  Document  [PARAMETER]  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  html  [TYPE]  Tag  bodyTag  headTag  htmlTag  textareaTag  titleTag  [TYPE]  boolean  false  true  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[REPLACE]  }  else  if  (  tq  .  matches  (   "</ "  )  )  {	[BUGGY]  else  if  (  tq  .  matchChomp  (   "</ "  )  )  {[FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  private  Document  parse  (  )  {  while  (  !tq  .  isEmpty  (  )  )  {  if  (  tq  .  matches  (   "<!-- "  )  )  {  parseComment  (  )  ;  }  else  if  (  tq  .  matches  (   "<![CDATA[ "  )  )  {  parseCdata  (  )  ;  }  else  if  (  tq  .  matches  (   "<? "  )  ||  tq  .  matches  (   "<! "  )  )  {  parseXmlDecl  (  )  ;  [ATTENTION]  }  else  if  (  tq  .  matchChomp  (   "</ "  )  )  {  parseEndTag  (  )  ;  }  else  if  (  tq  .  matches  (   "< "  )  )  {  parseStartTag  (  )  ;  }  else  {  parseTextNode  (  )  ;  }  }  return  doc  .  normalise  (  )  ;  }    [METHOD]  parse  [TYPE]  Document  [PARAMETER]  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  html  [TYPE]  Tag  bodyTag  headTag  htmlTag  textareaTag  titleTag  [TYPE]  boolean  false  true  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[REPLACE]  }  else  if  (  tq  .  matches  (   "< "  )  )  {	[BUGGY]  else  if  (  tq  .  matchChomp  (   "< "  )  )  {[FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  private  Document  parse  (  )  {  while  (  !tq  .  isEmpty  (  )  )  {  if  (  tq  .  matches  (   "<!-- "  )  )  {  parseComment  (  )  ;  }  else  if  (  tq  .  matches  (   "<![CDATA[ "  )  )  {  parseCdata  (  )  ;  }  else  if  (  tq  .  matches  (   "<? "  )  ||  tq  .  matches  (   "<! "  )  )  {  parseXmlDecl  (  )  ;  }  else  if  (  tq  .  matches  (   "</ "  )  )  {  parseEndTag  (  )  ;  [ATTENTION]  }  else  if  (  tq  .  matchChomp  (   "< "  )  )  {  parseStartTag  (  )  ;  }  else  {  parseTextNode  (  )  ;  }  }  return  doc  .  normalise  (  )  ;  }    [METHOD]  parse  [TYPE]  Document  [PARAMETER]  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  html  [TYPE]  Tag  bodyTag  headTag  htmlTag  textareaTag  titleTag  [TYPE]  boolean  false  true  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[REMOVE]  	[BUGGY]  if  (  tq  .  matches  (   "</ "  )  )  {      parseEndTag  (  )  ;  }else      if  (  tq  .  matches  (   "< "  )  )  {          parseStartTag  (  )  ;      }else  {          parseTextNode  (  )  ;      }[FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  private  Document  parse  (  )  {  while  (  !tq  .  isEmpty  (  )  )  {  if  (  tq  .  matches  (   "<!-- "  )  )  {  parseComment  (  )  ;  }  else  if  (  tq  .  matches  (   "<![CDATA[ "  )  )  {  parseCdata  (  )  ;  }  else  if  (  tq  .  matches  (   "<? "  )  ||  tq  .  matches  (   "<! "  )  )  {  parseXmlDecl  (  )  ;  }  else  if  (  tq  .  matches  (   "</ "  )  )  {  parseEndTag  (  )  ;  [ATTENTION]  }  else  if  (  tq  .  matches  (   "< "  )  )  {  if  (  tq  .  matches  (   "</ "  )  )  {  parseEndTag  (  )    ;  }else  if  (  tq  .  matches  (   "< "  )  )  {  parseStartTag  (  )    ;  }else  {  parseTextNode  (  )    ;  }parseStartTag  (  )  ;  }  else  {  parseTextNode  (  )  ;  }  }  return  doc  .  normalise  (  )  ;      [METHOD]  parse  [TYPE]  Document  [PARAMETER]  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  html  [TYPE]  Tag  bodyTag  headTag  htmlTag  textareaTag  titleTag  [TYPE]  boolean  false  true  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[ADD]  parseTextNode  (  )  ;	[BUGGY]  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  private  Document  parse  (  )  {  while  (  !tq  .  isEmpty  (  )  )  {  if  (  tq  .  matches  (   "<!-- "  )  )  {  parseComment  (  )  ;  }  else  if  (  tq  .  matches  (   "<![CDATA[ "  )  )  {  parseCdata  (  )  ;  }  else  if  (  tq  .  matches  (   "<? "  )  ||  tq  .  matches  (   "<! "  )  )  {  parseXmlDecl  (  )  ;  }  else  if  (  tq  .  matches  (   "</ "  )  )  {  parseEndTag  (  )  ;  }  else  if  (  tq  .  matches  (   "< "  )  )  {  parseStartTag  (  )  ;  }  else  {  [ATTENTION]  }  }  return  doc  .  normalise  (  )  ;  }    [METHOD]  parse  [TYPE]  Document  [PARAMETER]  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  html  [TYPE]  Tag  bodyTag  headTag  htmlTag  textareaTag  titleTag  [TYPE]  boolean  false  true  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[REPLACE]  parseComment  (  )  ;	[BUGGY]  Validate  .  notNull  (  html  )  ;  [CE]  cannot  find  symbol  html  [CONTEXT]  private  Document  parse  (  )  {  while  (  !tq  .  isEmpty  (  )  )  {  if  (  tq  .  matches  (   "<!-- "  )  )  {  [ATTENTION]  Validate  .  notNull  (  html  )    ;  }  else  if  (  tq  .  matches  (   "<![CDATA[ "  )  )  {  parseCdata  (  )  ;  }  else  if  (  tq  .  matches  (   "<? "  )  ||  tq  .  matches  (   "<! "  )  )  {  parseXmlDecl  (  )  ;  }  else  if  (  tq  .  matches  (   "</ "  )  )  {  parseEndTag  (  )  ;  }  else  if  (  tq  .  matches  (   "< "  )  )  {  parseStartTag  (  )  ;  }  else  {  parseTextNode  (  )  ;  }  }  return  doc  .  normalise  (  )  ;  }    [METHOD]  parse  [TYPE]  Document  [PARAMETER]  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  html  [TYPE]  Tag  bodyTag  headTag  htmlTag  textareaTag  titleTag  [TYPE]  boolean  false  true  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[REPLACE]  }  else  if  (  tq  .  matches  (   "<![CDATA[ "  )  )  {	[BUGGY]    if  (  tq  .  matches  (   "<[CDATA[ "  )  )  {[FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  private  Document  parse  (  )  {  while  (  !tq  .  isEmpty  (  )  )  {  if  (  tq  .  matches  (   "<!-- "  )  )  {  parseComment  (  )  ;  [ATTENTION]  }if  (  tq  .  matches  (   "<[CDATA[ "  )  )  {  parseCdata  (  )  ;  }  else  if  (  tq  .  matches  (   "<? "  )  ||  tq  .  matches  (   "<! "  )  )  {  parseXmlDecl  (  )  ;  }  else  if  (  tq  .  matches  (   "</ "  )  )  {  parseEndTag  (  )  ;  }  else  if  (  tq  .  matches  (   "< "  )  )  {  parseStartTag  (  )  ;  }  else  {  parseTextNode  (  )  ;  }  }  return  doc  .  normalise  (  )  ;  }    [METHOD]  parse  [TYPE]  Document  [PARAMETER]  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  html  [TYPE]  Tag  bodyTag  headTag  htmlTag  textareaTag  titleTag  [TYPE]  boolean  false  true  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[ADD]  else  if  (  tq  .  matches  (   "<![CDATA[ "  )  )  {  parseCdata  (  )  ;  }  else  if  (  tq  .  matches  (   "<? "  )  ||  tq  .  matches  (   "<! "  )  )  {  parseXmlDecl  (  )  ;	[BUGGY]    parseXmlDecl  (  )  ;  [CE]  [CONTEXT]  private  Document  parse  (  )  {  while  (  !tq  .  isEmpty  (  )  )  {  if  (  tq  .  matches  (   "<!-- "  )  )  {  parseComment  (  )  ;  [ATTENTION]  }  parseXmlDecl  (  )    ;      }  else  if  (  tq  .  matches  (   "</ "  )  )  {  parseEndTag  (  )  ;  }  else  if  (  tq  .  matches  (   "< "  )  )  {  parseStartTag  (  )  ;  }  else  {  parseTextNode  (  )  ;  }  }  return  doc  .  normalise  (  )  ;  }    [METHOD]  parse  [TYPE]  Document  [PARAMETER]  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  html  [TYPE]  Tag  bodyTag  headTag  htmlTag  textareaTag  titleTag  [TYPE]  boolean  false  true  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[REPLACE]  }  else  if  (  tq  .  matches  (   "<? "  )  ||  tq  .  matches  (   "<! "  )  )  {	[BUGGY]  else  if  (  tq  .  matches  (   "<? "  )  )  {[FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  private  Document  parse  (  )  {  while  (  !tq  .  isEmpty  (  )  )  {  if  (  tq  .  matches  (   "<!-- "  )  )  {  parseComment  (  )  ;  }  else  if  (  tq  .  matches  (   "<![CDATA[ "  )  )  {  parseCdata  (  )  ;  [ATTENTION]  }  else  if  (  tq  .  matches  (   "<? "  )  )  {  parseXmlDecl  (  )  ;  }  else  if  (  tq  .  matches  (   "</ "  )  )  {  parseEndTag  (  )  ;  }  else  if  (  tq  .  matches  (   "< "  )  )  {  parseStartTag  (  )  ;  }  else  {  parseTextNode  (  )  ;  }  }  return  doc  .  normalise  (  )  ;  }    [METHOD]  parse  [TYPE]  Document  [PARAMETER]  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  html  [TYPE]  Tag  bodyTag  headTag  htmlTag  textareaTag  titleTag  [TYPE]  boolean  false  true  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[ADD]  else  if  (  tq  .  matches  (   "<? "  )  ||  tq  .  matches  (   "<! "  )  )  {  parseXmlDecl  (  )  ;  }  else  if  (  tq  .  matches  (   "</ "  )  )  {  parseEndTag  (  )  ;	[BUGGY]    parseEndTag  (  )  ;  [CE]  [CONTEXT]  private  Document  parse  (  )  {  while  (  !tq  .  isEmpty  (  )  )  {  if  (  tq  .  matches  (   "<!-- "  )  )  {  parseComment  (  )  ;  }  else  if  (  tq  .  matches  (   "<![CDATA[ "  )  )  {  parseCdata  (  )  ;  [ATTENTION]  }  parseEndTag  (  )    ;      }  else  if  (  tq  .  matches  (   "< "  )  )  {  parseStartTag  (  )  ;  }  else  {  parseTextNode  (  )  ;  }  }  return  doc  .  normalise  (  )  ;  }    [METHOD]  parse  [TYPE]  Document  [PARAMETER]  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  html  [TYPE]  Tag  bodyTag  headTag  htmlTag  textareaTag  titleTag  [TYPE]  boolean  false  true  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[REPLACE]  }  else  if  (  tq  .  matches  (   "</ "  )  )  {	[BUGGY]  else  if  (  tq  .  matchesAny  (  baseUri  ,  SQ  ,  DQ  )    )  {[FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  private  Document  parse  (  )  {  while  (  !tq  .  isEmpty  (  )  )  {  if  (  tq  .  matches  (   "<!-- "  )  )  {  parseComment  (  )  ;  }  else  if  (  tq  .  matches  (   "<![CDATA[ "  )  )  {  parseCdata  (  )  ;  }  else  if  (  tq  .  matches  (   "<? "  )  ||  tq  .  matches  (   "<! "  )  )  {  parseXmlDecl  (  )  ;  [ATTENTION]  }  else  if  (  tq  .  matchesAny  (  baseUri  ,  SQ  ,  DQ  )    )  {  parseEndTag  (  )  ;  }  else  if  (  tq  .  matches  (   "< "  )  )  {  parseStartTag  (  )  ;  }  else  {  parseTextNode  (  )  ;  }  }  return  doc  .  normalise  (  )  ;  }    [METHOD]  parse  [TYPE]  Document  [PARAMETER]  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  html  [TYPE]  Tag  bodyTag  headTag  htmlTag  textareaTag  titleTag  [TYPE]  boolean  false  true  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[REPLACE]  }  else  if  (  tq  .  matches  (   "< "  )  )  {	[BUGGY]    if  (  tq  .  matchChomp  (   "< "  )  )  {[FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  private  Document  parse  (  )  {  while  (  !tq  .  isEmpty  (  )  )  {  if  (  tq  .  matches  (   "<!-- "  )  )  {  parseComment  (  )  ;  }  else  if  (  tq  .  matches  (   "<![CDATA[ "  )  )  {  parseCdata  (  )  ;  }  else  if  (  tq  .  matches  (   "<? "  )  ||  tq  .  matches  (   "<! "  )  )  {  parseXmlDecl  (  )  ;  }  else  if  (  tq  .  matches  (   "</ "  )  )  {  parseEndTag  (  )  ;  [ATTENTION]  }if  (  tq  .  matchChomp  (   "< "  )  )  {  parseStartTag  (  )  ;  }  else  {  parseTextNode  (  )  ;  }  }  return  doc  .  normalise  (  )  ;  }    [METHOD]  parse  [TYPE]  Document  [PARAMETER]  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  html  [TYPE]  Tag  bodyTag  headTag  htmlTag  textareaTag  titleTag  [TYPE]  boolean  false  true  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[ADD]  parseXmlDecl  (  )  ;	[BUGGY]  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  private  Document  parse  (  )  {  while  (  !tq  .  isEmpty  (  )  )  {  if  (  tq  .  matches  (   "<!-- "  )  )  {  parseComment  (  )  ;  }  else  if  (  tq  .  matches  (   "<![CDATA[ "  )  )  {  parseCdata  (  )  ;  }  else  if  (  tq  .  matches  (   "<? "  )  ||  tq  .  matches  (   "<! "  )  )  {  [ATTENTION]  }  else  if  (  tq  .  matches  (   "</ "  )  )  {  parseEndTag  (  )  ;  }  else  if  (  tq  .  matches  (   "< "  )  )  {  parseStartTag  (  )  ;  }  else  {  parseTextNode  (  )  ;  }  }  return  doc  .  normalise  (  )  ;  }    [METHOD]  parse  [TYPE]  Document  [PARAMETER]  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  html  [TYPE]  Tag  bodyTag  headTag  htmlTag  textareaTag  titleTag  [TYPE]  boolean  false  true  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[ADD]  parseStartTag  (  )  ;	[BUGGY]  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  private  Document  parse  (  )  {  while  (  !tq  .  isEmpty  (  )  )  {  if  (  tq  .  matches  (   "<!-- "  )  )  {  parseComment  (  )  ;  }  else  if  (  tq  .  matches  (   "<![CDATA[ "  )  )  {  parseCdata  (  )  ;  }  else  if  (  tq  .  matches  (   "<? "  )  ||  tq  .  matches  (   "<! "  )  )  {  parseXmlDecl  (  )  ;  }  else  if  (  tq  .  matches  (   "</ "  )  )  {  parseEndTag  (  )  ;  }  else  if  (  tq  .  matches  (   "< "  )  )  {  [ATTENTION]  }  else  {  parseTextNode  (  )  ;  }  }  return  doc  .  normalise  (  )  ;  }    [METHOD]  parse  [TYPE]  Document  [PARAMETER]  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  html  [TYPE]  Tag  bodyTag  headTag  htmlTag  textareaTag  titleTag  [TYPE]  boolean  false  true  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[ADD]  parseCdata  (  )  ;	[BUGGY]  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  private  Document  parse  (  )  {  while  (  !tq  .  isEmpty  (  )  )  {  if  (  tq  .  matches  (   "<!-- "  )  )  {  parseComment  (  )  ;  }  else  if  (  tq  .  matches  (   "<![CDATA[ "  )  )  {  [ATTENTION]  }  else  if  (  tq  .  matches  (   "<? "  )  ||  tq  .  matches  (   "<! "  )  )  {  parseXmlDecl  (  )  ;  }  else  if  (  tq  .  matches  (   "</ "  )  )  {  parseEndTag  (  )  ;  }  else  if  (  tq  .  matches  (   "< "  )  )  {  parseStartTag  (  )  ;  }  else  {  parseTextNode  (  )  ;  }  }  return  doc  .  normalise  (  )  ;  }    [METHOD]  parse  [TYPE]  Document  [PARAMETER]  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  html  [TYPE]  Tag  bodyTag  headTag  htmlTag  textareaTag  titleTag  [TYPE]  boolean  false  true  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[REPLACE]  }  else  if  (  tq  .  matches  (   "</ "  )  )  {	[BUGGY]    else  {[CE]  [CONTEXT]  private  Document  parse  (  )  {  while  (  !tq  .  isEmpty  (  )  )  {  if  (  tq  .  matches  (   "<!-- "  )  )  {  parseComment  (  )  ;  }  else  if  (  tq  .  matches  (   "<![CDATA[ "  )  )  {  parseCdata  (  )  ;  }  else  if  (  tq  .  matches  (   "<? "  )  ||  tq  .  matches  (   "<! "  )  )  {  parseXmlDecl  (  )  ;  [ATTENTION]  }else  {  parseEndTag  (  )  ;  }  else  if  (  tq  .  matches  (   "< "  )  )  {  parseStartTag  (  )  ;  }  else  {  parseTextNode  (  )  ;  }  }  return  doc  .  normalise  (  )  ;  }    [METHOD]  parse  [TYPE]  Document  [PARAMETER]  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  html  [TYPE]  Tag  bodyTag  headTag  htmlTag  textareaTag  titleTag  [TYPE]  boolean  false  true  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[REPLACE]  }  else  if  (  tq  .  matches  (   "</ "  )  )  {	[BUGGY]    if  (  tq  .  matchesAny  (  html  ,  baseUri  ,  DQ  )    )  {[CE]  cannot  find  symbol  html  [CONTEXT]  private  Document  parse  (  )  {  while  (  !tq  .  isEmpty  (  )  )  {  if  (  tq  .  matches  (   "<!-- "  )  )  {  parseComment  (  )  ;  }  else  if  (  tq  .  matches  (   "<![CDATA[ "  )  )  {  parseCdata  (  )  ;  }  else  if  (  tq  .  matches  (   "<? "  )  ||  tq  .  matches  (   "<! "  )  )  {  parseXmlDecl  (  )  ;  [ATTENTION]  }if  (  tq  .  matchesAny  (  html  ,  baseUri  ,  DQ  )    )  {  parseEndTag  (  )  ;  }  else  if  (  tq  .  matches  (   "< "  )  )  {  parseStartTag  (  )  ;  }  else  {  parseTextNode  (  )  ;  }  }  return  doc  .  normalise  (  )  ;  }    [METHOD]  parse  [TYPE]  Document  [PARAMETER]  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  html  [TYPE]  Tag  bodyTag  headTag  htmlTag  textareaTag  titleTag  [TYPE]  boolean  false  true  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[REMOVE]  	[BUGGY]  if  (  tq  .  matches  (   "< "  )  )  {      parseStartTag  (  )  ;  }else  {      parseTextNode  (  )  ;  }[FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  private  Document  parse  (  )  {  while  (  !tq  .  isEmpty  (  )  )  {  if  (  tq  .  matches  (   "<!-- "  )  )  {  parseComment  (  )  ;  }  else  if  (  tq  .  matches  (   "<![CDATA[ "  )  )  {  parseCdata  (  )  ;  }  else  if  (  tq  .  matches  (   "<? "  )  ||  tq  .  matches  (   "<! "  )  )  {  parseXmlDecl  (  )  ;  [ATTENTION]  }  else  if  (  tq  .  matches  (   "</ "  )  )  {  if  (  tq  .  matches  (   "< "  )  )  {  parseStartTag  (  )    ;  }else  {  parseTextNode  (  )    ;  }parseEndTag  (  )  ;  }  else  if  (  tq  .  matches  (   "< "  )  )  {  parseStartTag  (  )  ;  }  else  {  parseTextNode  (  )  ;  }  }  return  doc  .  normalise  (  )  ;      [METHOD]  parse  [TYPE]  Document  [PARAMETER]  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  html  [TYPE]  Tag  bodyTag  headTag  htmlTag  textareaTag  titleTag  [TYPE]  boolean  false  true  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[REMOVE]  	[BUGGY]  else  if  (  tq  .  matches  (   "</ "  )  )  {  parseEndTag  (  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  private  Document  parse  (  )  {  while  (  !tq  .  isEmpty  (  )  )  {  if  (  tq  .  matches  (   "<!-- "  )  )  {  parseComment  (  )  ;  }  else  if  (  tq  .  matches  (   "<![CDATA[ "  )  )  {  parseCdata  (  )  ;  }  else  if  (  tq  .  matches  (   "<? "  )  ||  tq  .  matches  (   "<! "  )  )  {  parseXmlDecl  (  )  ;  }  else  if  (  tq  .  matches  (   "</ "  )  )  {  [ATTENTION]  parseEndTag  (  )  ;    }  else  if  (  tq  .  matches  (   "</ "  )  )  {  parseEndTag  (  )    ;  }  else  if  (  tq  .  matches  (   "< "  )  )  {  parseStartTag  (  )  ;  }  else  {  parseTextNode  (  )  ;  }  }  return  doc  .  normalise  (  )  ;      [METHOD]  parse  [TYPE]  Document  [PARAMETER]  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  html  [TYPE]  Tag  bodyTag  headTag  htmlTag  textareaTag  titleTag  [TYPE]  boolean  false  true  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[REMOVE]  	[BUGGY]  Validate  .  notNull  (  html  )  ;  [CE]  cannot  find  symbol  html  [CONTEXT]  private  Document  parse  (  )  {  while  (  !tq  .  isEmpty  (  )  )  {  if  (  tq  .  matches  (   "<!-- "  )  )  {  parseComment  (  )  ;  }  else  if  (  tq  .  matches  (   "<![CDATA[ "  )  )  {  parseCdata  (  )  ;  }  else  if  (  tq  .  matches  (   "<? "  )  ||  tq  .  matches  (   "<! "  )  )  {  parseXmlDecl  (  )  ;  }  else  if  (  tq  .  matches  (   "</ "  )  )  {  parseEndTag  (  )  ;  }  else  if  (  tq  .  matches  (   "< "  )  )  {  [ATTENTION]  parseStartTag  (  )  ;    Validate  .  notNull  (  html  )    ;  }  else  {  parseTextNode  (  )  ;  }  }  return  doc  .  normalise  (  )  ;      [METHOD]  parse  [TYPE]  Document  [PARAMETER]  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  html  [TYPE]  Tag  bodyTag  headTag  htmlTag  textareaTag  titleTag  [TYPE]  boolean  false  true  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[REPLACE]  }  else  if  (  tq  .  matches  (   "<? "  )  ||  tq  .  matches  (   "<! "  )  )  {	[BUGGY]    if  (  tq  .  matches  (   "<? "  )  ||  tq  .  matches  (   "< "  )  )  {[FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  private  Document  parse  (  )  {  while  (  !tq  .  isEmpty  (  )  )  {  if  (  tq  .  matches  (   "<!-- "  )  )  {  parseComment  (  )  ;  }  else  if  (  tq  .  matches  (   "<![CDATA[ "  )  )  {  parseCdata  (  )  ;  [ATTENTION]  }if  (  tq  .  matches  (   "<? "  )  ||  tq  .  matches  (   "< "  )  )  {  parseXmlDecl  (  )  ;  }  else  if  (  tq  .  matches  (   "</ "  )  )  {  parseEndTag  (  )  ;  }  else  if  (  tq  .  matches  (   "< "  )  )  {  parseStartTag  (  )  ;  }  else  {  parseTextNode  (  )  ;  }  }  return  doc  .  normalise  (  )  ;  }    [METHOD]  parse  [TYPE]  Document  [PARAMETER]  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  html  [TYPE]  Tag  bodyTag  headTag  htmlTag  textareaTag  titleTag  [TYPE]  boolean  false  true  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[REPLACE]  }  else  if  (  tq  .  matches  (   "</ "  )  )  {	[BUGGY]    if  (  tq  .  matches  (   "</ "  )  )  {[FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  private  Document  parse  (  )  {  while  (  !tq  .  isEmpty  (  )  )  {  if  (  tq  .  matches  (   "<!-- "  )  )  {  parseComment  (  )  ;  }  else  if  (  tq  .  matches  (   "<![CDATA[ "  )  )  {  parseCdata  (  )  ;  }  else  if  (  tq  .  matches  (   "<? "  )  ||  tq  .  matches  (   "<! "  )  )  {  parseXmlDecl  (  )  ;  [ATTENTION]  }if  (  tq  .  matches  (   "</ "  )  )  {  parseEndTag  (  )  ;  }  else  if  (  tq  .  matches  (   "< "  )  )  {  parseStartTag  (  )  ;  }  else  {  parseTextNode  (  )  ;  }  }  return  doc  .  normalise  (  )  ;  }    [METHOD]  parse  [TYPE]  Document  [PARAMETER]  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  html  [TYPE]  Tag  bodyTag  headTag  htmlTag  textareaTag  titleTag  [TYPE]  boolean  false  true  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[ADD]  else  if  (  tq  .  matches  (   "</ "  )  )  {  parseEndTag  (  )  ;  }  else  if  (  tq  .  matches  (   "< "  )  )  {  parseStartTag  (  )  ;	[BUGGY]    parseStartTag  (  )  ;  [CE]  [CONTEXT]  private  Document  parse  (  )  {  while  (  !tq  .  isEmpty  (  )  )  {  if  (  tq  .  matches  (   "<!-- "  )  )  {  parseComment  (  )  ;  }  else  if  (  tq  .  matches  (   "<![CDATA[ "  )  )  {  parseCdata  (  )  ;  }  else  if  (  tq  .  matches  (   "<? "  )  ||  tq  .  matches  (   "<! "  )  )  {  parseXmlDecl  (  )  ;  [ATTENTION]  }  parseStartTag  (  )    ;      }  else  {  parseTextNode  (  )  ;  }  }  return  doc  .  normalise  (  )  ;  }    [METHOD]  parse  [TYPE]  Document  [PARAMETER]  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  html  [TYPE]  Tag  bodyTag  headTag  htmlTag  textareaTag  titleTag  [TYPE]  boolean  false  true  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[REMOVE]  	[BUGGY]  Validate  .  notNull  (  html  )  ;  [CE]  cannot  find  symbol  html  [CONTEXT]  private  Document  parse  (  )  {  while  (  !tq  .  isEmpty  (  )  )  {  if  (  tq  .  matches  (   "<!-- "  )  )  {  parseComment  (  )  ;  }  else  if  (  tq  .  matches  (   "<![CDATA[ "  )  )  {  [ATTENTION]  parseCdata  (  )  ;    Validate  .  notNull  (  html  )    ;  }  else  if  (  tq  .  matches  (   "<? "  )  ||  tq  .  matches  (   "<! "  )  )  {  parseXmlDecl  (  )  ;  }  else  if  (  tq  .  matches  (   "</ "  )  )  {  parseEndTag  (  )  ;  }  else  if  (  tq  .  matches  (   "< "  )  )  {  parseStartTag  (  )  ;  }  else  {  parseTextNode  (  )  ;  }  }  return  doc  .  normalise  (  )  ;      [METHOD]  parse  [TYPE]  Document  [PARAMETER]  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  html  [TYPE]  Tag  bodyTag  headTag  htmlTag  textareaTag  titleTag  [TYPE]  boolean  false  true  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[REPLACE]  }  else  if  (  tq  .  matches  (   "<? "  )  ||  tq  .  matches  (   "<! "  )  )  {	[BUGGY]    if  (  tq  .  matchChomp  (   "<? "  )  ||  tq  .  matches  (   "< "  )  )  {[FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  private  Document  parse  (  )  {  while  (  !tq  .  isEmpty  (  )  )  {  if  (  tq  .  matches  (   "<!-- "  )  )  {  parseComment  (  )  ;  }  else  if  (  tq  .  matches  (   "<![CDATA[ "  )  )  {  parseCdata  (  )  ;  [ATTENTION]  }if  (  tq  .  matchChomp  (   "<? "  )  ||  tq  .  matches  (   "< "  )  )  {  parseXmlDecl  (  )  ;  }  else  if  (  tq  .  matches  (   "</ "  )  )  {  parseEndTag  (  )  ;  }  else  if  (  tq  .  matches  (   "< "  )  )  {  parseStartTag  (  )  ;  }  else  {  parseTextNode  (  )  ;  }  }  return  doc  .  normalise  (  )  ;  }    [METHOD]  parse  [TYPE]  Document  [PARAMETER]  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  html  [TYPE]  Tag  bodyTag  headTag  htmlTag  textareaTag  titleTag  [TYPE]  boolean  false  true  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[ADD]  parseEndTag  (  )  ;	[BUGGY]  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  private  Document  parse  (  )  {  while  (  !tq  .  isEmpty  (  )  )  {  if  (  tq  .  matches  (   "<!-- "  )  )  {  parseComment  (  )  ;  }  else  if  (  tq  .  matches  (   "<![CDATA[ "  )  )  {  parseCdata  (  )  ;  }  else  if  (  tq  .  matches  (   "<? "  )  ||  tq  .  matches  (   "<! "  )  )  {  parseXmlDecl  (  )  ;  }  else  if  (  tq  .  matches  (   "</ "  )  )  {  [ATTENTION]  }  else  if  (  tq  .  matches  (   "< "  )  )  {  parseStartTag  (  )  ;  }  else  {  parseTextNode  (  )  ;  }  }  return  doc  .  normalise  (  )  ;  }    [METHOD]  parse  [TYPE]  Document  [PARAMETER]  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  html  [TYPE]  Tag  bodyTag  headTag  htmlTag  textareaTag  titleTag  [TYPE]  boolean  false  true  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[REPLACE]  return  doc  .  normalise  (  )  ;	[BUGGY]  return  doc  .  body  (  )  ;  [CE]  incompatible  types  [CONTEXT]  private  Document  parse  (  )  {  while  (  !tq  .  isEmpty  (  )  )  {  if  (  tq  .  matches  (   "<!-- "  )  )  {  parseComment  (  )  ;  }  else  if  (  tq  .  matches  (   "<![CDATA[ "  )  )  {  parseCdata  (  )  ;  }  else  if  (  tq  .  matches  (   "<? "  )  ||  tq  .  matches  (   "<! "  )  )  {  parseXmlDecl  (  )  ;  }  else  if  (  tq  .  matches  (   "</ "  )  )  {  parseEndTag  (  )  ;  }  else  if  (  tq  .  matches  (   "< "  )  )  {  parseStartTag  (  )  ;  }  else  {  parseTextNode  (  )  ;  }  }  [ATTENTION]  return  doc  .  body  (  )    ;  }    [METHOD]  parse  [TYPE]  Document  [PARAMETER]  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  html  [TYPE]  Tag  bodyTag  headTag  htmlTag  textareaTag  titleTag  [TYPE]  boolean  false  true  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[REPLACE]  tq  .  consume  (   "<!-- "  )  ;	[BUGGY]  tq  .  consumeTo  (  bodyHtml  )    ;  [CE]  cannot  find  symbol  bodyHtml  [CONTEXT]  private  void  parseComment  (  )  {  [ATTENTION]  tq  .  consumeTo  (  bodyHtml  )  ;  String  data  =  tq  .  chompTo  (   "-> "  )  ;    if  (  data  .  endsWith  (   "- "  )  )  //  i  .  e  .  was  -->  data  =  data  .  substring  (  0  ,  data  .  length  (  )  -1  )  ;  Comment  comment  =  new  Comment  (  data  ,  baseUri  )  ;  last  (  )  .  appendChild  (  comment  )  ;  }    [METHOD]  parseComment  [TYPE]  void  [PARAMETER]  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  Comment  comment  [TYPE]  boolean  false  true  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  html  [TYPE]  Tag  bodyTag  headTag  htmlTag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[REMOVE]  	[BUGGY]  valueAccum  .  append  (  tq  .  consume  (  )  )  ;  [CE]  cannot  find  symbol  valueAccum  [CONTEXT]  private  void  parseComment  (  )  {  [ATTENTION]  tq  .  consume  (   "<!-- "  )  ;    valueAccum  .  append  (  tq  .  consume  (  )  )    ;  String  data  =  tq  .  chompTo  (   "-> "  )  ;    if  (  data  .  endsWith  (   "- "  )  )  //  i  .  e  .  was  -->  data  =  data  .  substring  (  0  ,  data  .  length  (  )  -1  )  ;  Comment  comment  =  new  Comment  (  data  ,  baseUri  )  ;  last  (  )  .  appendChild  (  comment  )  ;      [METHOD]  parseComment  [TYPE]  void  [PARAMETER]  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  Comment  comment  [TYPE]  boolean  false  true  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  html  [TYPE]  Tag  bodyTag  headTag  htmlTag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[REPLACE]  String  data  =  tq  .  chompTo  (   "-> "  )  ;	[BUGGY]  String  data  =  tq  .  consumeTo  (   "-> "  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  private  void  parseComment  (  )  {  tq  .  consume  (   "<!-- "  )  ;  [ATTENTION]  String  data  =  tq  .  consumeTo  (   "-> "  )    ;    if  (  data  .  endsWith  (   "- "  )  )  //  i  .  e  .  was  -->  data  =  data  .  substring  (  0  ,  data  .  length  (  )  -1  )  ;  Comment  comment  =  new  Comment  (  data  ,  baseUri  )  ;  last  (  )  .  appendChild  (  comment  )  ;  }    [METHOD]  parseComment  [TYPE]  void  [PARAMETER]  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  Comment  comment  [TYPE]  boolean  false  true  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  html  [TYPE]  Tag  bodyTag  headTag  htmlTag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[REPLACE]  if  (  data  .  endsWith  (   "- "  )  )  data  =  data  .  substring  (  0,  data  .  length  (  )  -1  )  ;	[BUGGY]  if  (  data  .  endsWith  (   "- "  )  )  data  =  data  .  substring  (  0  ,  data  .  length  (  )  -  3-1  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  private  void  parseComment  (  )  {  tq  .  consume  (   "<!-- "  )  ;  String  data  =  tq  .  chompTo  (   "-> "  )  ;    [ATTENTION]  if  (  data  .  endsWith  (   "- "  )  )  data  =  data  .  substring  (  0  ,  data  .  length  (  )  -  3-1  )    ;    Comment  comment  =  new  Comment  (  data  ,  baseUri  )  ;  last  (  )  .  appendChild  (  comment  )  ;  }    [METHOD]  parseComment  [TYPE]  void  [PARAMETER]  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  Comment  comment  [TYPE]  boolean  false  true  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  html  [TYPE]  Tag  bodyTag  headTag  htmlTag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[REPLACE]  data  =  data  .  substring  (  0,  data  .  length  (  )  -1  )  ;	[BUGGY]  data  =  data  .  substring  (  0  ,  data  .  length  (  )  *  2-1  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  private  void  parseComment  (  )  {  tq  .  consume  (   "<!-- "  )  ;  String  data  =  tq  .  chompTo  (   "-> "  )  ;    if  (  data  .  endsWith  (   "- "  )  )  //  i  .  e  .  was  -->  [ATTENTION]  data  =  data  .  substring  (  0  ,  data  .  length  (  )  *2-1  )    ;  Comment  comment  =  new  Comment  (  data  ,  baseUri  )  ;  last  (  )  .  appendChild  (  comment  )  ;  }    [METHOD]  parseComment  [TYPE]  void  [PARAMETER]  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  Comment  comment  [TYPE]  boolean  false  true  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  html  [TYPE]  Tag  bodyTag  headTag  htmlTag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[REPLACE]  data  =  data  .  substring  (  0,  data  .  length  (  )  -1  )  ;	[BUGGY]  data  =  data  .  substring  (  0  ,  data  .  length  (  )  +  3-1  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  private  void  parseComment  (  )  {  tq  .  consume  (   "<!-- "  )  ;  String  data  =  tq  .  chompTo  (   "-> "  )  ;    if  (  data  .  endsWith  (   "- "  )  )  //  i  .  e  .  was  -->  [ATTENTION]  data  =  data  .  substring  (  0  ,  data  .  length  (  )  +  3-1  )    ;  Comment  comment  =  new  Comment  (  data  ,  baseUri  )  ;  last  (  )  .  appendChild  (  comment  )  ;  }    [METHOD]  parseComment  [TYPE]  void  [PARAMETER]  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  Comment  comment  [TYPE]  boolean  false  true  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  html  [TYPE]  Tag  bodyTag  headTag  htmlTag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[ADD]  data  =  data  .  substring  (  0,  data  .  length  (  )  -1  )  ;  Comment  comment  =  new  Comment  (  data,  baseUri  )  ;	[BUGGY]  Comment  comment  =  new  Comment  (  data  ,  baseUri  )  ;  [CE]  not  a  statement  [CONTEXT]  private  void  parseComment  (  )  {  tq  .  consume  (   "<!-- "  )  ;  String  data  =  tq  .  chompTo  (   "-> "  )  ;    if  (  data  .  endsWith  (   "- "  )  )  //  i  .  e  .  was  -->  [ATTENTION]  Comment  comment  =  new  Comment  (  data  ,  baseUri  )    ;    last  (  )  .  appendChild  (  comment  )  ;  }    [METHOD]  parseComment  [TYPE]  void  [PARAMETER]  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  Comment  comment  [TYPE]  boolean  false  true  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  html  [TYPE]  Tag  bodyTag  headTag  htmlTag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[REPLACE]  Comment  comment  =  new  Comment  (  data,  baseUri  )  ;	[BUGGY]  Comment  comment  =  new  Comment  (  bodyHtml  ,  baseUri  )  ;  [CE]  cannot  find  symbol  bodyHtml  [CONTEXT]  private  void  parseComment  (  )  {  tq  .  consume  (   "<!-- "  )  ;  String  data  =  tq  .  chompTo  (   "-> "  )  ;    if  (  data  .  endsWith  (   "- "  )  )  //  i  .  e  .  was  -->  data  =  data  .  substring  (  0  ,  data  .  length  (  )  -1  )  ;  [ATTENTION]  Comment  comment  =  new  Comment  (  bodyHtml  ,  baseUri  )    ;  last  (  )  .  appendChild  (  comment  )  ;  }    [METHOD]  parseComment  [TYPE]  void  [PARAMETER]  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  Comment  comment  [TYPE]  boolean  false  true  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  html  [TYPE]  Tag  bodyTag  headTag  htmlTag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[REPLACE]  last  (  )    .  appendChild  (  comment  )  ;	[BUGGY]  last  (  )    .  absUrl  (  bodyHtml  )    ;  [CE]  cannot  find  symbol  bodyHtml  [CONTEXT]  private  void  parseComment  (  )  {  tq  .  consume  (   "<!-- "  )  ;  String  data  =  tq  .  chompTo  (   "-> "  )  ;    if  (  data  .  endsWith  (   "- "  )  )  //  i  .  e  .  was  -->  data  =  data  .  substring  (  0  ,  data  .  length  (  )  -1  )  ;  Comment  comment  =  new  Comment  (  data  ,  baseUri  )  ;  [ATTENTION]  last  (  )  .  absUrl  (  bodyHtml  )  ;  }    [METHOD]  parseComment  [TYPE]  void  [PARAMETER]  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  Comment  comment  [TYPE]  boolean  false  true  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  html  [TYPE]  Tag  bodyTag  headTag  htmlTag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[REPLACE]  last  (  )    .  appendChild  (  comment  )  ;	[BUGGY]  implicit  .  appendChild  (  child  )  ;  [CE]  cannot  find  symbol  child  [CONTEXT]  private  void  parseComment  (  )  {  tq  .  consume  (   "<!-- "  )  ;  String  data  =  tq  .  chompTo  (   "-> "  )  ;    if  (  data  .  endsWith  (   "- "  )  )  //  i  .  e  .  was  -->  data  =  data  .  substring  (  0  ,  data  .  length  (  )  -1  )  ;  Comment  comment  =  new  Comment  (  data  ,  baseUri  )  ;  [ATTENTION]  implicit  .  appendChild  (  child  )    ;  }    [METHOD]  parseComment  [TYPE]  void  [PARAMETER]  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  Comment  comment  [TYPE]  boolean  false  true  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  html  [TYPE]  Tag  bodyTag  headTag  htmlTag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[REPLACE]  tq  .  consume  (   "< "  )  ;	[BUGGY]  tq  .  consumeTo  (   "< "  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  private  void  parseXmlDecl  (  )  {  [ATTENTION]  tq  .  consumeTo  (   "< "  )    ;  Character  firstChar  =  tq  .  consume  (  )  ;  //  <?  or  <!  ,  from  initial  match  .  boolean  procInstr  =  firstChar  .  toString  (  )  .  equals  (   "! "  )  ;  String  data  =  tq  .  chompTo  (   "> "  )  ;    XmlDeclaration  decl  =  new  XmlDeclaration  (  data  ,  baseUri  ,  procInstr  )  ;  last  (  )  .  appendChild  (  decl  )  ;  }    [METHOD]  parseXmlDecl  [TYPE]  void  [PARAMETER]  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  procInstr  true  [TYPE]  Character  firstChar  [TYPE]  XmlDeclaration  decl  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  html  [TYPE]  Tag  bodyTag  headTag  htmlTag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[REPLACE]  Character  firstChar  =  tq  .  consume  (  )  ;	[BUGGY]  Character  firstChar  =  tq  .  consumeWord  (  )  ;  [CE]  incompatible  types  [CONTEXT]  private  void  parseXmlDecl  (  )  {  tq  .  consume  (   "< "  )  ;  [ATTENTION]  Character  firstChar  =  tq  .  consumeWord  (  )    ;  boolean  procInstr  =  firstChar  .  toString  (  )  .  equals  (   "! "  )  ;  String  data  =  tq  .  chompTo  (   "> "  )  ;    XmlDeclaration  decl  =  new  XmlDeclaration  (  data  ,  baseUri  ,  procInstr  )  ;  last  (  )  .  appendChild  (  decl  )  ;  }    [METHOD]  parseXmlDecl  [TYPE]  void  [PARAMETER]  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  procInstr  true  [TYPE]  Character  firstChar  [TYPE]  XmlDeclaration  decl  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  html  [TYPE]  Tag  bodyTag  headTag  htmlTag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[ADD]  Character  firstChar  =  tq  .  consume  (  )  ;	[BUGGY]  [CE]  cannot  find  symbol  firstChar  [CONTEXT]  private  void  parseXmlDecl  (  )  {  tq  .  consume  (   "< "  )  ;  [ATTENTION]  boolean  procInstr  =  firstChar  .  toString  (  )  .  equals  (   "! "  )  ;  String  data  =  tq  .  chompTo  (   "> "  )  ;    XmlDeclaration  decl  =  new  XmlDeclaration  (  data  ,  baseUri  ,  procInstr  )  ;  last  (  )  .  appendChild  (  decl  )  ;  }    [METHOD]  parseXmlDecl  [TYPE]  void  [PARAMETER]  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  procInstr  true  [TYPE]  Character  firstChar  [TYPE]  XmlDeclaration  decl  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  html  [TYPE]  Tag  bodyTag  headTag  htmlTag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[REPLACE]  boolean  procInstr  =  firstChar  .  toString  (  )    .  equals  (   "! "  )  ;	[BUGGY]  boolean  procInstr  =  firstChar  .  toString  (  )  .  endsWith  (   "! "  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  private  void  parseXmlDecl  (  )  {  tq  .  consume  (   "< "  )  ;  Character  firstChar  =  tq  .  consume  (  )  ;  //  <?  or  <!  ,  from  initial  match  .  [ATTENTION]  boolean  procInstr  =  firstChar  .  toString  (  )    .  endsWith  (   "! "  )    ;  String  data  =  tq  .  chompTo  (   "> "  )  ;    XmlDeclaration  decl  =  new  XmlDeclaration  (  data  ,  baseUri  ,  procInstr  )  ;  last  (  )  .  appendChild  (  decl  )  ;  }    [METHOD]  parseXmlDecl  [TYPE]  void  [PARAMETER]  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  procInstr  true  [TYPE]  Character  firstChar  [TYPE]  XmlDeclaration  decl  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  html  [TYPE]  Tag  bodyTag  headTag  htmlTag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[REPLACE]  String  data  =  tq  .  chompTo  (   "> "  )  ;	[BUGGY]  String  data  =  tq  .  consumeTo  (   "> "  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  private  void  parseXmlDecl  (  )  {  tq  .  consume  (   "< "  )  ;  Character  firstChar  =  tq  .  consume  (  )  ;  //  <?  or  <!  ,  from  initial  match  .  boolean  procInstr  =  firstChar  .  toString  (  )  .  equals  (   "! "  )  ;  [ATTENTION]  String  data  =  tq  .  consumeTo  (   "> "  )    ;    XmlDeclaration  decl  =  new  XmlDeclaration  (  data  ,  baseUri  ,  procInstr  )  ;  last  (  )  .  appendChild  (  decl  )  ;  }    [METHOD]  parseXmlDecl  [TYPE]  void  [PARAMETER]  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  procInstr  true  [TYPE]  Character  firstChar  [TYPE]  XmlDeclaration  decl  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  html  [TYPE]  Tag  bodyTag  headTag  htmlTag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[REPLACE]  XmlDeclaration  decl  =  new  XmlDeclaration  (  data,  baseUri,  procInstr  )  ;	[BUGGY]  XmlDeclaration  decl  =  new  XmlDeclaration  (  data  ,  baseUri  ,  true  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  private  void  parseXmlDecl  (  )  {  tq  .  consume  (   "< "  )  ;  Character  firstChar  =  tq  .  consume  (  )  ;  //  <?  or  <!  ,  from  initial  match  .  boolean  procInstr  =  firstChar  .  toString  (  )  .  equals  (   "! "  )  ;  String  data  =  tq  .  chompTo  (   "> "  )  ;    [ATTENTION]  XmlDeclaration  decl  =  new  XmlDeclaration  (  data  ,  baseUri  ,  true  )    ;  last  (  )  .  appendChild  (  decl  )  ;  }    [METHOD]  parseXmlDecl  [TYPE]  void  [PARAMETER]  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  procInstr  true  [TYPE]  Character  firstChar  [TYPE]  XmlDeclaration  decl  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  html  [TYPE]  Tag  bodyTag  headTag  htmlTag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[REPLACE]  last  (  )    .  appendChild  (  decl  )  ;	[BUGGY]  last  (  )    .  absUrl  (  html  )    ;  [CE]  cannot  find  symbol  html  [CONTEXT]  private  void  parseXmlDecl  (  )  {  tq  .  consume  (   "< "  )  ;  Character  firstChar  =  tq  .  consume  (  )  ;  //  <?  or  <!  ,  from  initial  match  .  boolean  procInstr  =  firstChar  .  toString  (  )  .  equals  (   "! "  )  ;  String  data  =  tq  .  chompTo  (   "> "  )  ;    XmlDeclaration  decl  =  new  XmlDeclaration  (  data  ,  baseUri  ,  procInstr  )  ;  [ATTENTION]  last  (  )  .  absUrl  (  html  )  ;  }    [METHOD]  parseXmlDecl  [TYPE]  void  [PARAMETER]  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  procInstr  true  [TYPE]  Character  firstChar  [TYPE]  XmlDeclaration  decl  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  html  [TYPE]  Tag  bodyTag  headTag  htmlTag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[REPLACE]  last  (  )    .  appendChild  (  decl  )  ;	[BUGGY]  valueAccum  .  append  (  tq  .  consume  (  )  )  ;  [CE]  cannot  find  symbol  valueAccum  [CONTEXT]  private  void  parseXmlDecl  (  )  {  tq  .  consume  (   "< "  )  ;  Character  firstChar  =  tq  .  consume  (  )  ;  //  <?  or  <!  ,  from  initial  match  .  boolean  procInstr  =  firstChar  .  toString  (  )  .  equals  (   "! "  )  ;  String  data  =  tq  .  chompTo  (   "> "  )  ;    XmlDeclaration  decl  =  new  XmlDeclaration  (  data  ,  baseUri  ,  procInstr  )  ;  [ATTENTION]  valueAccum  .  append  (  tq  .  consume  (  )  )    ;  }    [METHOD]  parseXmlDecl  [TYPE]  void  [PARAMETER]  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  procInstr  true  [TYPE]  Character  firstChar  [TYPE]  XmlDeclaration  decl  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  html  [TYPE]  Tag  bodyTag  headTag  htmlTag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[REPLACE]  tq  .  consume  (   "</ "  )  ;	[BUGGY]  tq  .  consumeTo  (   "</ "  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  private  void  parseEndTag  (  )  {  [ATTENTION]  tq  .  consumeTo  (   "</ "  )    ;  String  tagName  =  tq  .  consumeWord  (  )  ;  tq  .  chompTo  (   "> "  )  ;    if  (  tagName  .  length  (  )  !  =  0  )  {  Tag  tag  =  Tag  .  valueOf  (  tagName  )  ;  popStackToClose  (  tag  )  ;  }  }    [METHOD]  parseEndTag  [TYPE]  void  [PARAMETER]  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  html  tagName  [TYPE]  Tag  bodyTag  headTag  htmlTag  tag  textareaTag  titleTag  [TYPE]  boolean  false  true  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[REPLACE]  String  tagName  =  tq  .  consumeWord  (  )  ;	[BUGGY]  String  tagName  =  tq  .  consumeTo  (  data  )    ;  [CE]  cannot  find  symbol  data  [CONTEXT]  private  void  parseEndTag  (  )  {  tq  .  consume  (   "</ "  )  ;  [ATTENTION]  String  tagName  =  tq  .  consumeTo  (  data  )  ;  tq  .  chompTo  (   "> "  )  ;    if  (  tagName  .  length  (  )  !  =  0  )  {  Tag  tag  =  Tag  .  valueOf  (  tagName  )  ;  popStackToClose  (  tag  )  ;  }  }    [METHOD]  parseEndTag  [TYPE]  void  [PARAMETER]  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  html  tagName  [TYPE]  Tag  bodyTag  headTag  htmlTag  tag  textareaTag  titleTag  [TYPE]  boolean  false  true  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[REPLACE]  tq  .  chompTo  (   "> "  )  ;	[BUGGY]  tq  .  consumeTo  (   "> "  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  private  void  parseEndTag  (  )  {  tq  .  consume  (   "</ "  )  ;  String  tagName  =  tq  .  consumeWord  (  )  ;  [ATTENTION]  tq  .  consumeTo  (   "> "  )    ;    if  (  tagName  .  length  (  )  !  =  0  )  {  Tag  tag  =  Tag  .  valueOf  (  tagName  )  ;  popStackToClose  (  tag  )  ;  }  }    [METHOD]  parseEndTag  [TYPE]  void  [PARAMETER]  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  html  tagName  [TYPE]  Tag  bodyTag  headTag  htmlTag  tag  textareaTag  titleTag  [TYPE]  boolean  false  true  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[REPLACE]  if  (  tagName  .  length  (  )  !=  0  )  {	[BUGGY]  if  (  tagName  .  length  (  )  -  1  !  =  0  )  {[FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  private  void  parseEndTag  (  )  {  tq  .  consume  (   "</ "  )  ;  String  tagName  =  tq  .  consumeWord  (  )  ;  tq  .  chompTo  (   "> "  )  ;    [ATTENTION]  if  (  tagName  .  length  (  )  -  1  !  =  0  )  {  Tag  tag  =  Tag  .  valueOf  (  tagName  )  ;  popStackToClose  (  tag  )  ;  }  }    [METHOD]  parseEndTag  [TYPE]  void  [PARAMETER]  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  html  tagName  [TYPE]  Tag  bodyTag  headTag  htmlTag  tag  textareaTag  titleTag  [TYPE]  boolean  false  true  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[ADD]  if  (  tagName  .  length  (  )  !=  0  )  {  Tag  tag  =  Tag  .  valueOf  (  tagName  )  ;  popStackToClose  (  tag  )  ;  }	[BUGGY]  Tag  tag  =  Tag  .  valueOf  (  tagName  )  ;  popStackToClose  (  tag  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  private  void  parseEndTag  (  )  {  tq  .  consume  (   "</ "  )  ;  String  tagName  =  tq  .  consumeWord  (  )  ;  tq  .  chompTo  (   "> "  )  ;    [ATTENTION]  Tag  tag  =  Tag  .  valueOf  (  tagName  )    ;  popStackToClose  (  tag  )    ;      }    [METHOD]  parseEndTag  [TYPE]  void  [PARAMETER]  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  html  tagName  [TYPE]  Tag  bodyTag  headTag  htmlTag  tag  textareaTag  titleTag  [TYPE]  boolean  false  true  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[REPLACE]  Tag  tag  =  Tag  .  valueOf  (  tagName  )  ;	[BUGGY]  Tag  tag  =  Tag  .  valueOf  (  html  )  ;  [CE]  cannot  find  symbol  html  [CONTEXT]  private  void  parseEndTag  (  )  {  tq  .  consume  (   "</ "  )  ;  String  tagName  =  tq  .  consumeWord  (  )  ;  tq  .  chompTo  (   "> "  )  ;    if  (  tagName  .  length  (  )  !  =  0  )  {  [ATTENTION]  Tag  tag  =  Tag  .  valueOf  (  html  )    ;  popStackToClose  (  tag  )  ;  }  }    [METHOD]  parseEndTag  [TYPE]  void  [PARAMETER]  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  html  tagName  [TYPE]  Tag  bodyTag  headTag  htmlTag  tag  textareaTag  titleTag  [TYPE]  boolean  false  true  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[REPLACE]  Tag  tag  =  Tag  .  valueOf  (  tagName  )  ;	[BUGGY]  Tag  tag  =  Tag  .  equals  (  html  )  ;  [CE]  cannot  find  symbol  html  [CONTEXT]  private  void  parseEndTag  (  )  {  tq  .  consume  (   "</ "  )  ;  String  tagName  =  tq  .  consumeWord  (  )  ;  tq  .  chompTo  (   "> "  )  ;    if  (  tagName  .  length  (  )  !  =  0  )  {  [ATTENTION]  Tag  tag  =  Tag  .  equals  (  html  )    ;  popStackToClose  (  tag  )  ;  }  }    [METHOD]  parseEndTag  [TYPE]  void  [PARAMETER]  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  html  tagName  [TYPE]  Tag  bodyTag  headTag  htmlTag  tag  textareaTag  titleTag  [TYPE]  boolean  false  true  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[ADD]  Tag  tag  =  Tag  .  valueOf  (  tagName  )  ;  popStackToClose  (  tag  )  ;	[BUGGY]  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  private  void  parseEndTag  (  )  {  tq  .  consume  (   "</ "  )  ;  String  tagName  =  tq  .  consumeWord  (  )  ;  tq  .  chompTo  (   "> "  )  ;    if  (  tagName  .  length  (  )  !  =  0  )  {  [ATTENTION]    }  }    [METHOD]  parseEndTag  [TYPE]  void  [PARAMETER]  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  html  tagName  [TYPE]  Tag  bodyTag  headTag  htmlTag  tag  textareaTag  titleTag  [TYPE]  boolean  false  true  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[REPLACE]  tq  .  consume  (   "< "  )  ;	[BUGGY]  tq  .  consumeTo  (   "< "  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  private  void  parseStartTag  (  )  {  [ATTENTION]  tq  .  consumeTo  (   "< "  )    ;  String  tagName  =  tq  .  consumeWord  (  )  ;    if  (  tagName  .  length  (  )    =  =  0  )  {  //  doesn't  look  like  a  start  tag  after  all  ;  put  <  back  on  stack  and  handle  as  text  tq  .  addFirst  (   "&lt  ;   "  )  ;  parseTextNode  (  )  ;  return  ;  }  Attributes  attributes  =  new  Attributes  (  )  ;  while  (  !tq  .  matchesAny  (   "< "  ,   "/> "  ,   "> "  )  &&  !tq  .  isEmpty  (  )  )  {  Attribute  attribute  =  parseAttribute  (  )  ;  if  (  attribute  !  =  null  )  attributes  .  put  (  attribute  )  ;  }  Tag  tag  =  Tag  .  valueOf  (  tagName  )  ;  Element  child  =  new  Element  (  tag  ,  baseUri  ,  attributes  )  ;    boolean  isEmptyElement  =  tag  .  isEmpty  (  )  ;  //  empty  element  if  empty  tag  (  e  .  g  .  img  )  or  self-closed  el  (  <div/>  if  (  tq  .  matchChomp  (   "/> "  )  )  {  //  close  empty  element  or  tag  isEmptyElement  =  true  ;  }  else  {  tq  .  matchChomp  (   "> "  )  ;  }    if  (  tag  .  isData  (  )  )  {  String  data  =  tq  .  chompTo  (   "</ "  +  tagName  )  ;  tq  .  chompTo  (   "> "  )  ;    Node  dataNode  ;  if  (  tag  .  equals  (  titleTag  )  ||  tag  .  equals  (  textareaTag  )  )  //  want  to  show  as  text  ,  but  not  contain  inside  tags  (  so  not  a  data  tag?  )  dataNode  =  TextNode  .  createFromEncoded  (  data  ,  baseUri  )  ;  else  dataNode  =  new  DataNode  (  data  ,  baseUri  )  ;  //  data  not  encoded  but  raw  (  for   "  in  script  )  child  .  appendChild  (  dataNode  )  ;  }    if  (  child  .  tagName  (  )  .  equals  (   "base "  )  )  {  String  href  =  child  .  absUrl  (   "href "  )  ;  if  (  href  .  length  (  )  !  =  0  )  {  //  ignore  <base  target>  etc  baseUri  =  href  ;  doc  .  setBaseUri  (  href  )  ;  //  set  on  the  doc  so  doc  .  createElement  (  Tag  )  will  get  updated  base  }  }  addChildToParent  (  child  ,  isEmptyElement  )  ;  }    [METHOD]  parseStartTag  [TYPE]  void  [PARAMETER]  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  isEmptyElement  true  [TYPE]  Attribute  attribute  [TYPE]  Element  child  [TYPE]  Node  dataNode  [TYPE]  Attributes  attributes  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  href  html  tagName  [TYPE]  Tag  bodyTag  headTag  htmlTag  tag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[REPLACE]  String  tagName  =  tq  .  consumeWord  (  )  ;	[BUGGY]  String  tagName  =  tq  .  consume  (  )  ;  [CE]  incompatible  types  [CONTEXT]  private  void  parseStartTag  (  )  {  tq  .  consume  (   "< "  )  ;  [ATTENTION]  String  tagName  =  tq  .  consume  (  )    ;    if  (  tagName  .  length  (  )    =  =  0  )  {  //  doesn't  look  like  a  start  tag  after  all  ;  put  <  back  on  stack  and  handle  as  text  tq  .  addFirst  (   "&lt  ;   "  )  ;  parseTextNode  (  )  ;  return  ;  }  Attributes  attributes  =  new  Attributes  (  )  ;  while  (  !tq  .  matchesAny  (   "< "  ,   "/> "  ,   "> "  )  &&  !tq  .  isEmpty  (  )  )  {  Attribute  attribute  =  parseAttribute  (  )  ;  if  (  attribute  !  =  null  )  attributes  .  put  (  attribute  )  ;  }  Tag  tag  =  Tag  .  valueOf  (  tagName  )  ;  Element  child  =  new  Element  (  tag  ,  baseUri  ,  attributes  )  ;    boolean  isEmptyElement  =  tag  .  isEmpty  (  )  ;  //  empty  element  if  empty  tag  (  e  .  g  .  img  )  or  self-closed  el  (  <div/>  if  (  tq  .  matchChomp  (   "/> "  )  )  {  //  close  empty  element  or  tag  isEmptyElement  =  true  ;  }  else  {  tq  .  matchChomp  (   "> "  )  ;  }    if  (  tag  .  isData  (  )  )  {  String  data  =  tq  .  chompTo  (   "</ "  +  tagName  )  ;  tq  .  chompTo  (   "> "  )  ;    Node  dataNode  ;  if  (  tag  .  equals  (  titleTag  )  ||  tag  .  equals  (  textareaTag  )  )  //  want  to  show  as  text  ,  but  not  contain  inside  tags  (  so  not  a  data  tag?  )  dataNode  =  TextNode  .  createFromEncoded  (  data  ,  baseUri  )  ;  else  dataNode  =  new  DataNode  (  data  ,  baseUri  )  ;  //  data  not  encoded  but  raw  (  for   "  in  script  )  child  .  appendChild  (  dataNode  )  ;  }    if  (  child  .  tagName  (  )  .  equals  (   "base "  )  )  {  String  href  =  child  .  absUrl  (   "href "  )  ;  if  (  href  .  length  (  )  !  =  0  )  {  //  ignore  <base  target>  etc  baseUri  =  href  ;  doc  .  setBaseUri  (  href  )  ;  //  set  on  the  doc  so  doc  .  createElement  (  Tag  )  will  get  updated  base  }  }  addChildToParent  (  child  ,  isEmptyElement  )  ;  }    [METHOD]  parseStartTag  [TYPE]  void  [PARAMETER]  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  isEmptyElement  true  [TYPE]  Attribute  attribute  [TYPE]  Element  child  [TYPE]  Node  dataNode  [TYPE]  Attributes  attributes  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  href  html  tagName  [TYPE]  Tag  bodyTag  headTag  htmlTag  tag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[REPLACE]  if  (  tagName  .  length  (  )  ==  0  )  {	[BUGGY]  if  (  tagName  .  size  (  )    =  =  0  )  {[CE]  cannot  find  symbol  [CONTEXT]  private  void  parseStartTag  (  )  {  tq  .  consume  (   "< "  )  ;  String  tagName  =  tq  .  consumeWord  (  )  ;    [ATTENTION]  if  (  tagName  .  size  (  )  =  =  0  )  {  tq  .  addFirst  (   "&lt  ;   "  )  ;  parseTextNode  (  )  ;  return  ;  }  Attributes  attributes  =  new  Attributes  (  )  ;  while  (  !tq  .  matchesAny  (   "< "  ,   "/> "  ,   "> "  )  &&  !tq  .  isEmpty  (  )  )  {  Attribute  attribute  =  parseAttribute  (  )  ;  if  (  attribute  !  =  null  )  attributes  .  put  (  attribute  )  ;  }  Tag  tag  =  Tag  .  valueOf  (  tagName  )  ;  Element  child  =  new  Element  (  tag  ,  baseUri  ,  attributes  )  ;    boolean  isEmptyElement  =  tag  .  isEmpty  (  )  ;  //  empty  element  if  empty  tag  (  e  .  g  .  img  )  or  self-closed  el  (  <div/>  if  (  tq  .  matchChomp  (   "/> "  )  )  {  //  close  empty  element  or  tag  isEmptyElement  =  true  ;  }  else  {  tq  .  matchChomp  (   "> "  )  ;  }    if  (  tag  .  isData  (  )  )  {  String  data  =  tq  .  chompTo  (   "</ "  +  tagName  )  ;  tq  .  chompTo  (   "> "  )  ;    Node  dataNode  ;  if  (  tag  .  equals  (  titleTag  )  ||  tag  .  equals  (  textareaTag  )  )  //  want  to  show  as  text  ,  but  not  contain  inside  tags  (  so  not  a  data  tag?  )  dataNode  =  TextNode  .  createFromEncoded  (  data  ,  baseUri  )  ;  else  dataNode  =  new  DataNode  (  data  ,  baseUri  )  ;  //  data  not  encoded  but  raw  (  for   "  in  script  )  child  .  appendChild  (  dataNode  )  ;  }    if  (  child  .  tagName  (  )  .  equals  (   "base "  )  )  {  String  href  =  child  .  absUrl  (   "href "  )  ;  if  (  href  .  length  (  )  !  =  0  )  {  //  ignore  <base  target>  etc  baseUri  =  href  ;  doc  .  setBaseUri  (  href  )  ;  //  set  on  the  doc  so  doc  .  createElement  (  Tag  )  will  get  updated  base  }  }  addChildToParent  (  child  ,  isEmptyElement  )  ;  }    [METHOD]  parseStartTag  [TYPE]  void  [PARAMETER]  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  isEmptyElement  true  [TYPE]  Attribute  attribute  [TYPE]  Element  child  [TYPE]  Node  dataNode  [TYPE]  Attributes  attributes  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  href  html  tagName  [TYPE]  Tag  bodyTag  headTag  htmlTag  tag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[REPLACE]  return;	[BUGGY]  return  parent  ;  [CE]  cannot  return  a  value  from  method  whose  result  type  is  void  [CONTEXT]  private  void  parseStartTag  (  )  {  tq  .  consume  (   "< "  )  ;  String  tagName  =  tq  .  consumeWord  (  )  ;    if  (  tagName  .  length  (  )    =  =  0  )  {  //  doesn't  look  like  a  start  tag  after  all  ;  put  <  back  on  stack  and  handle  as  text  tq  .  addFirst  (   "&lt  ;   "  )  ;  parseTextNode  (  )  ;  [ATTENTION]  return  parent  ;  }  Attributes  attributes  =  new  Attributes  (  )  ;  while  (  !tq  .  matchesAny  (   "< "  ,   "/> "  ,   "> "  )  &&  !tq  .  isEmpty  (  )  )  {  Attribute  attribute  =  parseAttribute  (  )  ;  if  (  attribute  !  =  null  )  attributes  .  put  (  attribute  )  ;  }  Tag  tag  =  Tag  .  valueOf  (  tagName  )  ;  Element  child  =  new  Element  (  tag  ,  baseUri  ,  attributes  )  ;    boolean  isEmptyElement  =  tag  .  isEmpty  (  )  ;  //  empty  element  if  empty  tag  (  e  .  g  .  img  )  or  self-closed  el  (  <div/>  if  (  tq  .  matchChomp  (   "/> "  )  )  {  //  close  empty  element  or  tag  isEmptyElement  =  true  ;  }  else  {  tq  .  matchChomp  (   "> "  )  ;  }    if  (  tag  .  isData  (  )  )  {  String  data  =  tq  .  chompTo  (   "</ "  +  tagName  )  ;  tq  .  chompTo  (   "> "  )  ;    Node  dataNode  ;  if  (  tag  .  equals  (  titleTag  )  ||  tag  .  equals  (  textareaTag  )  )  //  want  to  show  as  text  ,  but  not  contain  inside  tags  (  so  not  a  data  tag?  )  dataNode  =  TextNode  .  createFromEncoded  (  data  ,  baseUri  )  ;  else  dataNode  =  new  DataNode  (  data  ,  baseUri  )  ;  //  data  not  encoded  but  raw  (  for   "  in  script  )  child  .  appendChild  (  dataNode  )  ;  }    if  (  child  .  tagName  (  )  .  equals  (   "base "  )  )  {  String  href  =  child  .  absUrl  (   "href "  )  ;  if  (  href  .  length  (  )  !  =  0  )  {  //  ignore  <base  target>  etc  baseUri  =  href  ;  doc  .  setBaseUri  (  href  )  ;  //  set  on  the  doc  so  doc  .  createElement  (  Tag  )  will  get  updated  base  }  }  addChildToParent  (  child  ,  isEmptyElement  )  ;  }    [METHOD]  parseStartTag  [TYPE]  void  [PARAMETER]  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  isEmptyElement  true  [TYPE]  Attribute  attribute  [TYPE]  Element  child  [TYPE]  Node  dataNode  [TYPE]  Attributes  attributes  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  href  html  tagName  [TYPE]  Tag  bodyTag  headTag  htmlTag  tag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[REPLACE]  Attributes  attributes  =  new  Attributes  (  )  ;	[BUGGY]  StringBuilder  valueAccum  =  new  StringBuilder  (  )  ;  [CE]  cannot  find  symbol  attributes  [CONTEXT]  private  void  parseStartTag  (  )  {  tq  .  consume  (   "< "  )  ;  String  tagName  =  tq  .  consumeWord  (  )  ;    if  (  tagName  .  length  (  )    =  =  0  )  {  //  doesn't  look  like  a  start  tag  after  all  ;  put  <  back  on  stack  and  handle  as  text  tq  .  addFirst  (   "&lt  ;   "  )  ;  parseTextNode  (  )  ;  return  ;  }  [ATTENTION]  StringBuilder  valueAccum  =  new  StringBuilder  (  )    ;  while  (  !tq  .  matchesAny  (   "< "  ,   "/> "  ,   "> "  )  &&  !tq  .  isEmpty  (  )  )  {  Attribute  attribute  =  parseAttribute  (  )  ;  if  (  attribute  !  =  null  )  attributes  .  put  (  attribute  )  ;  }  Tag  tag  =  Tag  .  valueOf  (  tagName  )  ;  Element  child  =  new  Element  (  tag  ,  baseUri  ,  attributes  )  ;    boolean  isEmptyElement  =  tag  .  isEmpty  (  )  ;  //  empty  element  if  empty  tag  (  e  .  g  .  img  )  or  self-closed  el  (  <div/>  if  (  tq  .  matchChomp  (   "/> "  )  )  {  //  close  empty  element  or  tag  isEmptyElement  =  true  ;  }  else  {  tq  .  matchChomp  (   "> "  )  ;  }    if  (  tag  .  isData  (  )  )  {  String  data  =  tq  .  chompTo  (   "</ "  +  tagName  )  ;  tq  .  chompTo  (   "> "  )  ;    Node  dataNode  ;  if  (  tag  .  equals  (  titleTag  )  ||  tag  .  equals  (  textareaTag  )  )  //  want  to  show  as  text  ,  but  not  contain  inside  tags  (  so  not  a  data  tag?  )  dataNode  =  TextNode  .  createFromEncoded  (  data  ,  baseUri  )  ;  else  dataNode  =  new  DataNode  (  data  ,  baseUri  )  ;  //  data  not  encoded  but  raw  (  for   "  in  script  )  child  .  appendChild  (  dataNode  )  ;  }    if  (  child  .  tagName  (  )  .  equals  (   "base "  )  )  {  String  href  =  child  .  absUrl  (   "href "  )  ;  if  (  href  .  length  (  )  !  =  0  )  {  //  ignore  <base  target>  etc  baseUri  =  href  ;  doc  .  setBaseUri  (  href  )  ;  //  set  on  the  doc  so  doc  .  createElement  (  Tag  )  will  get  updated  base  }  }  addChildToParent  (  child  ,  isEmptyElement  )  ;  }    [METHOD]  parseStartTag  [TYPE]  void  [PARAMETER]  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  isEmptyElement  true  [TYPE]  Attribute  attribute  [TYPE]  Element  child  [TYPE]  Node  dataNode  [TYPE]  Attributes  attributes  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  href  html  tagName  [TYPE]  Tag  bodyTag  headTag  htmlTag  tag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[REPLACE]  while  (  !tq  .  matchesAny  (   "< ",   "/> ",   "> "  )  &&  !tq  .  isEmpty  (  )  )  {	[BUGGY]  while  (  !tq  .  matchesAny  (   "< "  ,   "/> "  ,   "> "  )    ;  [CE]  [CONTEXT]  private  void  parseStartTag  (  )  {  tq  .  consume  (   "< "  )  ;  String  tagName  =  tq  .  consumeWord  (  )  ;    if  (  tagName  .  length  (  )    =  =  0  )  {  //  doesn't  look  like  a  start  tag  after  all  ;  put  <  back  on  stack  and  handle  as  text  tq  .  addFirst  (   "&lt  ;   "  )  ;  parseTextNode  (  )  ;  return  ;  }  Attributes  attributes  =  new  Attributes  (  )  ;  [ATTENTION]  while  (  !tq  .  matchesAny  (   "< "  ,   "/> "  ,   "> "  )  ;  Attribute  attribute  =  parseAttribute  (  )  ;  if  (  attribute  !  =  null  )  attributes  .  put  (  attribute  )  ;  }  Tag  tag  =  Tag  .  valueOf  (  tagName  )  ;  Element  child  =  new  Element  (  tag  ,  baseUri  ,  attributes  )  ;    boolean  isEmptyElement  =  tag  .  isEmpty  (  )  ;  //  empty  element  if  empty  tag  (  e  .  g  .  img  )  or  self-closed  el  (  <div/>  if  (  tq  .  matchChomp  (   "/> "  )  )  {  //  close  empty  element  or  tag  isEmptyElement  =  true  ;  }  else  {  tq  .  matchChomp  (   "> "  )  ;  }    if  (  tag  .  isData  (  )  )  {  String  data  =  tq  .  chompTo  (   "</ "  +  tagName  )  ;  tq  .  chompTo  (   "> "  )  ;    Node  dataNode  ;  if  (  tag  .  equals  (  titleTag  )  ||  tag  .  equals  (  textareaTag  )  )  //  want  to  show  as  text  ,  but  not  contain  inside  tags  (  so  not  a  data  tag?  )  dataNode  =  TextNode  .  createFromEncoded  (  data  ,  baseUri  )  ;  else  dataNode  =  new  DataNode  (  data  ,  baseUri  )  ;  //  data  not  encoded  but  raw  (  for   "  in  script  )  child  .  appendChild  (  dataNode  )  ;  }    if  (  child  .  tagName  (  )  .  equals  (   "base "  )  )  {  String  href  =  child  .  absUrl  (   "href "  )  ;  if  (  href  .  length  (  )  !  =  0  )  {  //  ignore  <base  target>  etc  baseUri  =  href  ;  doc  .  setBaseUri  (  href  )  ;  //  set  on  the  doc  so  doc  .  createElement  (  Tag  )  will  get  updated  base  }  }  addChildToParent  (  child  ,  isEmptyElement  )  ;  }    [METHOD]  parseStartTag  [TYPE]  void  [PARAMETER]  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  isEmptyElement  true  [TYPE]  Attribute  attribute  [TYPE]  Element  child  [TYPE]  Node  dataNode  [TYPE]  Attributes  attributes  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  href  html  tagName  [TYPE]  Tag  bodyTag  headTag  htmlTag  tag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[REPLACE]  if  (  attribute  !=  null  )  attributes  .  put  (  attribute  )  ;	[BUGGY]  if  (  attribute  =  =  this  )  attributes  .  put  (  attribute  )  ;  [CE]  incomparable  types:  Attribute  and  Parser  [CONTEXT]  private  void  parseStartTag  (  )  {  tq  .  consume  (   "< "  )  ;  String  tagName  =  tq  .  consumeWord  (  )  ;    if  (  tagName  .  length  (  )    =  =  0  )  {  //  doesn't  look  like  a  start  tag  after  all  ;  put  <  back  on  stack  and  handle  as  text  tq  .  addFirst  (   "&lt  ;   "  )  ;  parseTextNode  (  )  ;  return  ;  }  Attributes  attributes  =  new  Attributes  (  )  ;  while  (  !tq  .  matchesAny  (   "< "  ,   "/> "  ,   "> "  )  &&  !tq  .  isEmpty  (  )  )  {  Attribute  attribute  =  parseAttribute  (  )  ;  [ATTENTION]  if  (  attribute  =  =  this  )  attributes  .  put  (  attribute  )    ;    }  Tag  tag  =  Tag  .  valueOf  (  tagName  )  ;  Element  child  =  new  Element  (  tag  ,  baseUri  ,  attributes  )  ;    boolean  isEmptyElement  =  tag  .  isEmpty  (  )  ;  //  empty  element  if  empty  tag  (  e  .  g  .  img  )  or  self-closed  el  (  <div/>  if  (  tq  .  matchChomp  (   "/> "  )  )  {  //  close  empty  element  or  tag  isEmptyElement  =  true  ;  }  else  {  tq  .  matchChomp  (   "> "  )  ;  }    if  (  tag  .  isData  (  )  )  {  String  data  =  tq  .  chompTo  (   "</ "  +  tagName  )  ;  tq  .  chompTo  (   "> "  )  ;    Node  dataNode  ;  if  (  tag  .  equals  (  titleTag  )  ||  tag  .  equals  (  textareaTag  )  )  //  want  to  show  as  text  ,  but  not  contain  inside  tags  (  so  not  a  data  tag?  )  dataNode  =  TextNode  .  createFromEncoded  (  data  ,  baseUri  )  ;  else  dataNode  =  new  DataNode  (  data  ,  baseUri  )  ;  //  data  not  encoded  but  raw  (  for   "  in  script  )  child  .  appendChild  (  dataNode  )  ;  }    if  (  child  .  tagName  (  )  .  equals  (   "base "  )  )  {  String  href  =  child  .  absUrl  (   "href "  )  ;  if  (  href  .  length  (  )  !  =  0  )  {  //  ignore  <base  target>  etc  baseUri  =  href  ;  doc  .  setBaseUri  (  href  )  ;  //  set  on  the  doc  so  doc  .  createElement  (  Tag  )  will  get  updated  base  }  }  addChildToParent  (  child  ,  isEmptyElement  )  ;  }    [METHOD]  parseStartTag  [TYPE]  void  [PARAMETER]  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  isEmptyElement  true  [TYPE]  Attribute  attribute  [TYPE]  Element  child  [TYPE]  Node  dataNode  [TYPE]  Attributes  attributes  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  href  html  tagName  [TYPE]  Tag  bodyTag  headTag  htmlTag  tag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[REPLACE]  attributes  .  put  (  attribute  )  ;	[BUGGY]  attributes  .  Attributes  (  )    ;  [CE]  cannot  find  symbol  [CONTEXT]  private  void  parseStartTag  (  )  {  tq  .  consume  (   "< "  )  ;  String  tagName  =  tq  .  consumeWord  (  )  ;    if  (  tagName  .  length  (  )    =  =  0  )  {  //  doesn't  look  like  a  start  tag  after  all  ;  put  <  back  on  stack  and  handle  as  text  tq  .  addFirst  (   "&lt  ;   "  )  ;  parseTextNode  (  )  ;  return  ;  }  Attributes  attributes  =  new  Attributes  (  )  ;  while  (  !tq  .  matchesAny  (   "< "  ,   "/> "  ,   "> "  )  &&  !tq  .  isEmpty  (  )  )  {  Attribute  attribute  =  parseAttribute  (  )  ;  if  (  attribute  !  =  null  )  [ATTENTION]  attributes  .  Attributes  (  )  ;  }  Tag  tag  =  Tag  .  valueOf  (  tagName  )  ;  Element  child  =  new  Element  (  tag  ,  baseUri  ,  attributes  )  ;    boolean  isEmptyElement  =  tag  .  isEmpty  (  )  ;  //  empty  element  if  empty  tag  (  e  .  g  .  img  )  or  self-closed  el  (  <div/>  if  (  tq  .  matchChomp  (   "/> "  )  )  {  //  close  empty  element  or  tag  isEmptyElement  =  true  ;  }  else  {  tq  .  matchChomp  (   "> "  )  ;  }    if  (  tag  .  isData  (  )  )  {  String  data  =  tq  .  chompTo  (   "</ "  +  tagName  )  ;  tq  .  chompTo  (   "> "  )  ;    Node  dataNode  ;  if  (  tag  .  equals  (  titleTag  )  ||  tag  .  equals  (  textareaTag  )  )  //  want  to  show  as  text  ,  but  not  contain  inside  tags  (  so  not  a  data  tag?  )  dataNode  =  TextNode  .  createFromEncoded  (  data  ,  baseUri  )  ;  else  dataNode  =  new  DataNode  (  data  ,  baseUri  )  ;  //  data  not  encoded  but  raw  (  for   "  in  script  )  child  .  appendChild  (  dataNode  )  ;  }    if  (  child  .  tagName  (  )  .  equals  (   "base "  )  )  {  String  href  =  child  .  absUrl  (   "href "  )  ;  if  (  href  .  length  (  )  !  =  0  )  {  //  ignore  <base  target>  etc  baseUri  =  href  ;  doc  .  setBaseUri  (  href  )  ;  //  set  on  the  doc  so  doc  .  createElement  (  Tag  )  will  get  updated  base  }  }  addChildToParent  (  child  ,  isEmptyElement  )  ;  }    [METHOD]  parseStartTag  [TYPE]  void  [PARAMETER]  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  isEmptyElement  true  [TYPE]  Attribute  attribute  [TYPE]  Element  child  [TYPE]  Node  dataNode  [TYPE]  Attributes  attributes  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  href  html  tagName  [TYPE]  Tag  bodyTag  headTag  htmlTag  tag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[REPLACE]  Attribute  attribute  =  parseAttribute  (  )  ;	[BUGGY]  Attributes  attributes  =  new  Attributes  (  )  ;  [CE]  variable  attributes  is  already  defined  in  method  parseStartTag()  [CONTEXT]  private  void  parseStartTag  (  )  {  tq  .  consume  (   "< "  )  ;  String  tagName  =  tq  .  consumeWord  (  )  ;    if  (  tagName  .  length  (  )    =  =  0  )  {  //  doesn't  look  like  a  start  tag  after  all  ;  put  <  back  on  stack  and  handle  as  text  tq  .  addFirst  (   "&lt  ;   "  )  ;  parseTextNode  (  )  ;  return  ;  }  Attributes  attributes  =  new  Attributes  (  )  ;  while  (  !tq  .  matchesAny  (   "< "  ,   "/> "  ,   "> "  )  &&  !tq  .  isEmpty  (  )  )  {  [ATTENTION]  Attributes  attributes  =  new  Attributes  (  )    ;  if  (  attribute  !  =  null  )  attributes  .  put  (  attribute  )  ;  }  Tag  tag  =  Tag  .  valueOf  (  tagName  )  ;  Element  child  =  new  Element  (  tag  ,  baseUri  ,  attributes  )  ;    boolean  isEmptyElement  =  tag  .  isEmpty  (  )  ;  //  empty  element  if  empty  tag  (  e  .  g  .  img  )  or  self-closed  el  (  <div/>  if  (  tq  .  matchChomp  (   "/> "  )  )  {  //  close  empty  element  or  tag  isEmptyElement  =  true  ;  }  else  {  tq  .  matchChomp  (   "> "  )  ;  }    if  (  tag  .  isData  (  )  )  {  String  data  =  tq  .  chompTo  (   "</ "  +  tagName  )  ;  tq  .  chompTo  (   "> "  )  ;    Node  dataNode  ;  if  (  tag  .  equals  (  titleTag  )  ||  tag  .  equals  (  textareaTag  )  )  //  want  to  show  as  text  ,  but  not  contain  inside  tags  (  so  not  a  data  tag?  )  dataNode  =  TextNode  .  createFromEncoded  (  data  ,  baseUri  )  ;  else  dataNode  =  new  DataNode  (  data  ,  baseUri  )  ;  //  data  not  encoded  but  raw  (  for   "  in  script  )  child  .  appendChild  (  dataNode  )  ;  }    if  (  child  .  tagName  (  )  .  equals  (   "base "  )  )  {  String  href  =  child  .  absUrl  (   "href "  )  ;  if  (  href  .  length  (  )  !  =  0  )  {  //  ignore  <base  target>  etc  baseUri  =  href  ;  doc  .  setBaseUri  (  href  )  ;  //  set  on  the  doc  so  doc  .  createElement  (  Tag  )  will  get  updated  base  }  }  addChildToParent  (  child  ,  isEmptyElement  )  ;  }    [METHOD]  parseStartTag  [TYPE]  void  [PARAMETER]  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  isEmptyElement  true  [TYPE]  Attribute  attribute  [TYPE]  Element  child  [TYPE]  Node  dataNode  [TYPE]  Attributes  attributes  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  href  html  tagName  [TYPE]  Tag  bodyTag  headTag  htmlTag  tag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[REPLACE]  if  (  attribute  !=  null  )  attributes  .  put  (  attribute  )  ;	[BUGGY]  if  (  attribute  =  =  true  )  attributes  .  put  (  attribute  )  ;  [CE]  incomparable  types:  Attribute  and  boolean  [CONTEXT]  private  void  parseStartTag  (  )  {  tq  .  consume  (   "< "  )  ;  String  tagName  =  tq  .  consumeWord  (  )  ;    if  (  tagName  .  length  (  )    =  =  0  )  {  //  doesn't  look  like  a  start  tag  after  all  ;  put  <  back  on  stack  and  handle  as  text  tq  .  addFirst  (   "&lt  ;   "  )  ;  parseTextNode  (  )  ;  return  ;  }  Attributes  attributes  =  new  Attributes  (  )  ;  while  (  !tq  .  matchesAny  (   "< "  ,   "/> "  ,   "> "  )  &&  !tq  .  isEmpty  (  )  )  {  Attribute  attribute  =  parseAttribute  (  )  ;  [ATTENTION]  if  (  attribute  =  =  true  )  attributes  .  put  (  attribute  )    ;    }  Tag  tag  =  Tag  .  valueOf  (  tagName  )  ;  Element  child  =  new  Element  (  tag  ,  baseUri  ,  attributes  )  ;    boolean  isEmptyElement  =  tag  .  isEmpty  (  )  ;  //  empty  element  if  empty  tag  (  e  .  g  .  img  )  or  self-closed  el  (  <div/>  if  (  tq  .  matchChomp  (   "/> "  )  )  {  //  close  empty  element  or  tag  isEmptyElement  =  true  ;  }  else  {  tq  .  matchChomp  (   "> "  )  ;  }    if  (  tag  .  isData  (  )  )  {  String  data  =  tq  .  chompTo  (   "</ "  +  tagName  )  ;  tq  .  chompTo  (   "> "  )  ;    Node  dataNode  ;  if  (  tag  .  equals  (  titleTag  )  ||  tag  .  equals  (  textareaTag  )  )  //  want  to  show  as  text  ,  but  not  contain  inside  tags  (  so  not  a  data  tag?  )  dataNode  =  TextNode  .  createFromEncoded  (  data  ,  baseUri  )  ;  else  dataNode  =  new  DataNode  (  data  ,  baseUri  )  ;  //  data  not  encoded  but  raw  (  for   "  in  script  )  child  .  appendChild  (  dataNode  )  ;  }    if  (  child  .  tagName  (  )  .  equals  (   "base "  )  )  {  String  href  =  child  .  absUrl  (   "href "  )  ;  if  (  href  .  length  (  )  !  =  0  )  {  //  ignore  <base  target>  etc  baseUri  =  href  ;  doc  .  setBaseUri  (  href  )  ;  //  set  on  the  doc  so  doc  .  createElement  (  Tag  )  will  get  updated  base  }  }  addChildToParent  (  child  ,  isEmptyElement  )  ;  }    [METHOD]  parseStartTag  [TYPE]  void  [PARAMETER]  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  isEmptyElement  true  [TYPE]  Attribute  attribute  [TYPE]  Element  child  [TYPE]  Node  dataNode  [TYPE]  Attributes  attributes  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  href  html  tagName  [TYPE]  Tag  bodyTag  headTag  htmlTag  tag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[REPLACE]  attributes  .  put  (  attribute  )  ;	[BUGGY]  Attribute  attribute  =  parseAttribute  (  )  ;  [CE]  not  a  statement  [CONTEXT]  private  void  parseStartTag  (  )  {  tq  .  consume  (   "< "  )  ;  String  tagName  =  tq  .  consumeWord  (  )  ;    if  (  tagName  .  length  (  )    =  =  0  )  {  //  doesn't  look  like  a  start  tag  after  all  ;  put  <  back  on  stack  and  handle  as  text  tq  .  addFirst  (   "&lt  ;   "  )  ;  parseTextNode  (  )  ;  return  ;  }  Attributes  attributes  =  new  Attributes  (  )  ;  while  (  !tq  .  matchesAny  (   "< "  ,   "/> "  ,   "> "  )  &&  !tq  .  isEmpty  (  )  )  {  Attribute  attribute  =  parseAttribute  (  )  ;  if  (  attribute  !  =  null  )  [ATTENTION]  Attribute  attribute  =  parseAttribute  (  )    ;  }  Tag  tag  =  Tag  .  valueOf  (  tagName  )  ;  Element  child  =  new  Element  (  tag  ,  baseUri  ,  attributes  )  ;    boolean  isEmptyElement  =  tag  .  isEmpty  (  )  ;  //  empty  element  if  empty  tag  (  e  .  g  .  img  )  or  self-closed  el  (  <div/>  if  (  tq  .  matchChomp  (   "/> "  )  )  {  //  close  empty  element  or  tag  isEmptyElement  =  true  ;  }  else  {  tq  .  matchChomp  (   "> "  )  ;  }    if  (  tag  .  isData  (  )  )  {  String  data  =  tq  .  chompTo  (   "</ "  +  tagName  )  ;  tq  .  chompTo  (   "> "  )  ;    Node  dataNode  ;  if  (  tag  .  equals  (  titleTag  )  ||  tag  .  equals  (  textareaTag  )  )  //  want  to  show  as  text  ,  but  not  contain  inside  tags  (  so  not  a  data  tag?  )  dataNode  =  TextNode  .  createFromEncoded  (  data  ,  baseUri  )  ;  else  dataNode  =  new  DataNode  (  data  ,  baseUri  )  ;  //  data  not  encoded  but  raw  (  for   "  in  script  )  child  .  appendChild  (  dataNode  )  ;  }    if  (  child  .  tagName  (  )  .  equals  (   "base "  )  )  {  String  href  =  child  .  absUrl  (   "href "  )  ;  if  (  href  .  length  (  )  !  =  0  )  {  //  ignore  <base  target>  etc  baseUri  =  href  ;  doc  .  setBaseUri  (  href  )  ;  //  set  on  the  doc  so  doc  .  createElement  (  Tag  )  will  get  updated  base  }  }  addChildToParent  (  child  ,  isEmptyElement  )  ;  }    [METHOD]  parseStartTag  [TYPE]  void  [PARAMETER]  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  isEmptyElement  true  [TYPE]  Attribute  attribute  [TYPE]  Element  child  [TYPE]  Node  dataNode  [TYPE]  Attributes  attributes  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  href  html  tagName  [TYPE]  Tag  bodyTag  headTag  htmlTag  tag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[ADD]  attributes  .  put  (  attribute  )  ;	[BUGGY]  [CE]  illegal  start  of  expression  [CONTEXT]  private  void  parseStartTag  (  )  {  tq  .  consume  (   "< "  )  ;  String  tagName  =  tq  .  consumeWord  (  )  ;    if  (  tagName  .  length  (  )    =  =  0  )  {  //  doesn't  look  like  a  start  tag  after  all  ;  put  <  back  on  stack  and  handle  as  text  tq  .  addFirst  (   "&lt  ;   "  )  ;  parseTextNode  (  )  ;  return  ;  }  Attributes  attributes  =  new  Attributes  (  )  ;  while  (  !tq  .  matchesAny  (   "< "  ,   "/> "  ,   "> "  )  &&  !tq  .  isEmpty  (  )  )  {  Attribute  attribute  =  parseAttribute  (  )  ;  if  (  attribute  !  =  null  )  [ATTENTION]  }  Tag  tag  =  Tag  .  valueOf  (  tagName  )  ;  Element  child  =  new  Element  (  tag  ,  baseUri  ,  attributes  )  ;    boolean  isEmptyElement  =  tag  .  isEmpty  (  )  ;  //  empty  element  if  empty  tag  (  e  .  g  .  img  )  or  self-closed  el  (  <div/>  if  (  tq  .  matchChomp  (   "/> "  )  )  {  //  close  empty  element  or  tag  isEmptyElement  =  true  ;  }  else  {  tq  .  matchChomp  (   "> "  )  ;  }    if  (  tag  .  isData  (  )  )  {  String  data  =  tq  .  chompTo  (   "</ "  +  tagName  )  ;  tq  .  chompTo  (   "> "  )  ;    Node  dataNode  ;  if  (  tag  .  equals  (  titleTag  )  ||  tag  .  equals  (  textareaTag  )  )  //  want  to  show  as  text  ,  but  not  contain  inside  tags  (  so  not  a  data  tag?  )  dataNode  =  TextNode  .  createFromEncoded  (  data  ,  baseUri  )  ;  else  dataNode  =  new  DataNode  (  data  ,  baseUri  )  ;  //  data  not  encoded  but  raw  (  for   "  in  script  )  child  .  appendChild  (  dataNode  )  ;  }    if  (  child  .  tagName  (  )  .  equals  (   "base "  )  )  {  String  href  =  child  .  absUrl  (   "href "  )  ;  if  (  href  .  length  (  )  !  =  0  )  {  //  ignore  <base  target>  etc  baseUri  =  href  ;  doc  .  setBaseUri  (  href  )  ;  //  set  on  the  doc  so  doc  .  createElement  (  Tag  )  will  get  updated  base  }  }  addChildToParent  (  child  ,  isEmptyElement  )  ;  }    [METHOD]  parseStartTag  [TYPE]  void  [PARAMETER]  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  isEmptyElement  true  [TYPE]  Attribute  attribute  [TYPE]  Element  child  [TYPE]  Node  dataNode  [TYPE]  Attributes  attributes  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  href  html  tagName  [TYPE]  Tag  bodyTag  headTag  htmlTag  tag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[ADD]  Attribute  attribute  =  parseAttribute  (  )  ;	[BUGGY]  [CE]  cannot  find  symbol  attribute  [CONTEXT]  private  void  parseStartTag  (  )  {  tq  .  consume  (   "< "  )  ;  String  tagName  =  tq  .  consumeWord  (  )  ;    if  (  tagName  .  length  (  )    =  =  0  )  {  //  doesn't  look  like  a  start  tag  after  all  ;  put  <  back  on  stack  and  handle  as  text  tq  .  addFirst  (   "&lt  ;   "  )  ;  parseTextNode  (  )  ;  return  ;  }  Attributes  attributes  =  new  Attributes  (  )  ;  while  (  !tq  .  matchesAny  (   "< "  ,   "/> "  ,   "> "  )  &&  !tq  .  isEmpty  (  )  )  {  [ATTENTION]  if  (  attribute  !  =  null  )  attributes  .  put  (  attribute  )  ;  }  Tag  tag  =  Tag  .  valueOf  (  tagName  )  ;  Element  child  =  new  Element  (  tag  ,  baseUri  ,  attributes  )  ;    boolean  isEmptyElement  =  tag  .  isEmpty  (  )  ;  //  empty  element  if  empty  tag  (  e  .  g  .  img  )  or  self-closed  el  (  <div/>  if  (  tq  .  matchChomp  (   "/> "  )  )  {  //  close  empty  element  or  tag  isEmptyElement  =  true  ;  }  else  {  tq  .  matchChomp  (   "> "  )  ;  }    if  (  tag  .  isData  (  )  )  {  String  data  =  tq  .  chompTo  (   "</ "  +  tagName  )  ;  tq  .  chompTo  (   "> "  )  ;    Node  dataNode  ;  if  (  tag  .  equals  (  titleTag  )  ||  tag  .  equals  (  textareaTag  )  )  //  want  to  show  as  text  ,  but  not  contain  inside  tags  (  so  not  a  data  tag?  )  dataNode  =  TextNode  .  createFromEncoded  (  data  ,  baseUri  )  ;  else  dataNode  =  new  DataNode  (  data  ,  baseUri  )  ;  //  data  not  encoded  but  raw  (  for   "  in  script  )  child  .  appendChild  (  dataNode  )  ;  }    if  (  child  .  tagName  (  )  .  equals  (   "base "  )  )  {  String  href  =  child  .  absUrl  (   "href "  )  ;  if  (  href  .  length  (  )  !  =  0  )  {  //  ignore  <base  target>  etc  baseUri  =  href  ;  doc  .  setBaseUri  (  href  )  ;  //  set  on  the  doc  so  doc  .  createElement  (  Tag  )  will  get  updated  base  }  }  addChildToParent  (  child  ,  isEmptyElement  )  ;  }    [METHOD]  parseStartTag  [TYPE]  void  [PARAMETER]  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  isEmptyElement  true  [TYPE]  Attribute  attribute  [TYPE]  Element  child  [TYPE]  Node  dataNode  [TYPE]  Attributes  attributes  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  href  html  tagName  [TYPE]  Tag  bodyTag  headTag  htmlTag  tag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[REPLACE]  Tag  tag  =  Tag  .  valueOf  (  tagName  )  ;	[BUGGY]  Tag  tag  =  Tag  .  valueOf  (  html  )  ;  [CE]  cannot  find  symbol  html  [CONTEXT]  private  void  parseStartTag  (  )  {  tq  .  consume  (   "< "  )  ;  String  tagName  =  tq  .  consumeWord  (  )  ;    if  (  tagName  .  length  (  )    =  =  0  )  {  //  doesn't  look  like  a  start  tag  after  all  ;  put  <  back  on  stack  and  handle  as  text  tq  .  addFirst  (   "&lt  ;   "  )  ;  parseTextNode  (  )  ;  return  ;  }  Attributes  attributes  =  new  Attributes  (  )  ;  while  (  !tq  .  matchesAny  (   "< "  ,   "/> "  ,   "> "  )  &&  !tq  .  isEmpty  (  )  )  {  Attribute  attribute  =  parseAttribute  (  )  ;  if  (  attribute  !  =  null  )  attributes  .  put  (  attribute  )  ;  }  [ATTENTION]  Tag  tag  =  Tag  .  valueOf  (  html  )    ;  Element  child  =  new  Element  (  tag  ,  baseUri  ,  attributes  )  ;    boolean  isEmptyElement  =  tag  .  isEmpty  (  )  ;  //  empty  element  if  empty  tag  (  e  .  g  .  img  )  or  self-closed  el  (  <div/>  if  (  tq  .  matchChomp  (   "/> "  )  )  {  //  close  empty  element  or  tag  isEmptyElement  =  true  ;  }  else  {  tq  .  matchChomp  (   "> "  )  ;  }    if  (  tag  .  isData  (  )  )  {  String  data  =  tq  .  chompTo  (   "</ "  +  tagName  )  ;  tq  .  chompTo  (   "> "  )  ;    Node  dataNode  ;  if  (  tag  .  equals  (  titleTag  )  ||  tag  .  equals  (  textareaTag  )  )  //  want  to  show  as  text  ,  but  not  contain  inside  tags  (  so  not  a  data  tag?  )  dataNode  =  TextNode  .  createFromEncoded  (  data  ,  baseUri  )  ;  else  dataNode  =  new  DataNode  (  data  ,  baseUri  )  ;  //  data  not  encoded  but  raw  (  for   "  in  script  )  child  .  appendChild  (  dataNode  )  ;  }    if  (  child  .  tagName  (  )  .  equals  (   "base "  )  )  {  String  href  =  child  .  absUrl  (   "href "  )  ;  if  (  href  .  length  (  )  !  =  0  )  {  //  ignore  <base  target>  etc  baseUri  =  href  ;  doc  .  setBaseUri  (  href  )  ;  //  set  on  the  doc  so  doc  .  createElement  (  Tag  )  will  get  updated  base  }  }  addChildToParent  (  child  ,  isEmptyElement  )  ;  }    [METHOD]  parseStartTag  [TYPE]  void  [PARAMETER]  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  isEmptyElement  true  [TYPE]  Attribute  attribute  [TYPE]  Element  child  [TYPE]  Node  dataNode  [TYPE]  Attributes  attributes  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  href  html  tagName  [TYPE]  Tag  bodyTag  headTag  htmlTag  tag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[ADD]  Tag  tag  =  Tag  .  valueOf  (  tagName  )  ;  Element  child  =  new  Element  (  tag,  baseUri,  attributes  )  ;	[BUGGY]  Element  child  =  new  Element  (  tag  ,  baseUri  ,  attributes  )  ;  [CE]  cannot  find  symbol  tag  [CONTEXT]  private  void  parseStartTag  (  )  {  tq  .  consume  (   "< "  )  ;  String  tagName  =  tq  .  consumeWord  (  )  ;    if  (  tagName  .  length  (  )    =  =  0  )  {  //  doesn't  look  like  a  start  tag  after  all  ;  put  <  back  on  stack  and  handle  as  text  tq  .  addFirst  (   "&lt  ;   "  )  ;  parseTextNode  (  )  ;  return  ;  }  Attributes  attributes  =  new  Attributes  (  )  ;  while  (  !tq  .  matchesAny  (   "< "  ,   "/> "  ,   "> "  )  &&  !tq  .  isEmpty  (  )  )  {  Attribute  attribute  =  parseAttribute  (  )  ;  if  (  attribute  !  =  null  )  attributes  .  put  (  attribute  )  ;  }  [ATTENTION]  Element  child  =  new  Element  (  tag  ,  baseUri  ,  attributes  )    ;    boolean  isEmptyElement  =  tag  .  isEmpty  (  )  ;  //  empty  element  if  empty  tag  (  e  .  g  .  img  )  or  self-closed  el  (  <div/>  if  (  tq  .  matchChomp  (   "/> "  )  )  {  //  close  empty  element  or  tag  isEmptyElement  =  true  ;  }  else  {  tq  .  matchChomp  (   "> "  )  ;  }    if  (  tag  .  isData  (  )  )  {  String  data  =  tq  .  chompTo  (   "</ "  +  tagName  )  ;  tq  .  chompTo  (   "> "  )  ;    Node  dataNode  ;  if  (  tag  .  equals  (  titleTag  )  ||  tag  .  equals  (  textareaTag  )  )  //  want  to  show  as  text  ,  but  not  contain  inside  tags  (  so  not  a  data  tag?  )  dataNode  =  TextNode  .  createFromEncoded  (  data  ,  baseUri  )  ;  else  dataNode  =  new  DataNode  (  data  ,  baseUri  )  ;  //  data  not  encoded  but  raw  (  for   "  in  script  )  child  .  appendChild  (  dataNode  )  ;  }    if  (  child  .  tagName  (  )  .  equals  (   "base "  )  )  {  String  href  =  child  .  absUrl  (   "href "  )  ;  if  (  href  .  length  (  )  !  =  0  )  {  //  ignore  <base  target>  etc  baseUri  =  href  ;  doc  .  setBaseUri  (  href  )  ;  //  set  on  the  doc  so  doc  .  createElement  (  Tag  )  will  get  updated  base  }  }  addChildToParent  (  child  ,  isEmptyElement  )  ;  }    [METHOD]  parseStartTag  [TYPE]  void  [PARAMETER]  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  isEmptyElement  true  [TYPE]  Attribute  attribute  [TYPE]  Element  child  [TYPE]  Node  dataNode  [TYPE]  Attributes  attributes  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  href  html  tagName  [TYPE]  Tag  bodyTag  headTag  htmlTag  tag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[REPLACE]  Element  child  =  new  Element  (  tag,  baseUri,  attributes  )  ;	[BUGGY]  Element  el  =  stack  .  get  (  i  )  ;  [CE]  cannot  find  symbol  i  [CONTEXT]  private  void  parseStartTag  (  )  {  tq  .  consume  (   "< "  )  ;  String  tagName  =  tq  .  consumeWord  (  )  ;    if  (  tagName  .  length  (  )    =  =  0  )  {  //  doesn't  look  like  a  start  tag  after  all  ;  put  <  back  on  stack  and  handle  as  text  tq  .  addFirst  (   "&lt  ;   "  )  ;  parseTextNode  (  )  ;  return  ;  }  Attributes  attributes  =  new  Attributes  (  )  ;  while  (  !tq  .  matchesAny  (   "< "  ,   "/> "  ,   "> "  )  &&  !tq  .  isEmpty  (  )  )  {  Attribute  attribute  =  parseAttribute  (  )  ;  if  (  attribute  !  =  null  )  attributes  .  put  (  attribute  )  ;  }  Tag  tag  =  Tag  .  valueOf  (  tagName  )  ;  [ATTENTION]  Element  el  =  stack  .  get  (  i  )    ;    boolean  isEmptyElement  =  tag  .  isEmpty  (  )  ;  //  empty  element  if  empty  tag  (  e  .  g  .  img  )  or  self-closed  el  (  <div/>  if  (  tq  .  matchChomp  (   "/> "  )  )  {  //  close  empty  element  or  tag  isEmptyElement  =  true  ;  }  else  {  tq  .  matchChomp  (   "> "  )  ;  }    if  (  tag  .  isData  (  )  )  {  String  data  =  tq  .  chompTo  (   "</ "  +  tagName  )  ;  tq  .  chompTo  (   "> "  )  ;    Node  dataNode  ;  if  (  tag  .  equals  (  titleTag  )  ||  tag  .  equals  (  textareaTag  )  )  //  want  to  show  as  text  ,  but  not  contain  inside  tags  (  so  not  a  data  tag?  )  dataNode  =  TextNode  .  createFromEncoded  (  data  ,  baseUri  )  ;  else  dataNode  =  new  DataNode  (  data  ,  baseUri  )  ;  //  data  not  encoded  but  raw  (  for   "  in  script  )  child  .  appendChild  (  dataNode  )  ;  }    if  (  child  .  tagName  (  )  .  equals  (   "base "  )  )  {  String  href  =  child  .  absUrl  (   "href "  )  ;  if  (  href  .  length  (  )  !  =  0  )  {  //  ignore  <base  target>  etc  baseUri  =  href  ;  doc  .  setBaseUri  (  href  )  ;  //  set  on  the  doc  so  doc  .  createElement  (  Tag  )  will  get  updated  base  }  }  addChildToParent  (  child  ,  isEmptyElement  )  ;  }    [METHOD]  parseStartTag  [TYPE]  void  [PARAMETER]  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  isEmptyElement  true  [TYPE]  Attribute  attribute  [TYPE]  Element  child  [TYPE]  Node  dataNode  [TYPE]  Attributes  attributes  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  href  html  tagName  [TYPE]  Tag  bodyTag  headTag  htmlTag  tag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[REPLACE]  boolean  isEmptyElement  =  tag  .  isEmpty  (  )  ;	[BUGGY]  boolean  .  isDataElement  =  textareaTag  .  isEmpty  (  )  ;  [CE]  class  expected  [CONTEXT]  private  void  parseStartTag  (  )  {  tq  .  consume  (   "< "  )  ;  String  tagName  =  tq  .  consumeWord  (  )  ;    if  (  tagName  .  length  (  )    =  =  0  )  {  //  doesn't  look  like  a  start  tag  after  all  ;  put  <  back  on  stack  and  handle  as  text  tq  .  addFirst  (   "&lt  ;   "  )  ;  parseTextNode  (  )  ;  return  ;  }  Attributes  attributes  =  new  Attributes  (  )  ;  while  (  !tq  .  matchesAny  (   "< "  ,   "/> "  ,   "> "  )  &&  !tq  .  isEmpty  (  )  )  {  Attribute  attribute  =  parseAttribute  (  )  ;  if  (  attribute  !  =  null  )  attributes  .  put  (  attribute  )  ;  }  Tag  tag  =  Tag  .  valueOf  (  tagName  )  ;  Element  child  =  new  Element  (  tag  ,  baseUri  ,  attributes  )  ;    [ATTENTION]  boolean  .  isDataElement  =  textareaTag  .  isEmpty  (  )    ;  if  (  tq  .  matchChomp  (   "/> "  )  )  {  //  close  empty  element  or  tag  isEmptyElement  =  true  ;  }  else  {  tq  .  matchChomp  (   "> "  )  ;  }    if  (  tag  .  isData  (  )  )  {  String  data  =  tq  .  chompTo  (   "</ "  +  tagName  )  ;  tq  .  chompTo  (   "> "  )  ;    Node  dataNode  ;  if  (  tag  .  equals  (  titleTag  )  ||  tag  .  equals  (  textareaTag  )  )  //  want  to  show  as  text  ,  but  not  contain  inside  tags  (  so  not  a  data  tag?  )  dataNode  =  TextNode  .  createFromEncoded  (  data  ,  baseUri  )  ;  else  dataNode  =  new  DataNode  (  data  ,  baseUri  )  ;  //  data  not  encoded  but  raw  (  for   "  in  script  )  child  .  appendChild  (  dataNode  )  ;  }    if  (  child  .  tagName  (  )  .  equals  (   "base "  )  )  {  String  href  =  child  .  absUrl  (   "href "  )  ;  if  (  href  .  length  (  )  !  =  0  )  {  //  ignore  <base  target>  etc  baseUri  =  href  ;  doc  .  setBaseUri  (  href  )  ;  //  set  on  the  doc  so  doc  .  createElement  (  Tag  )  will  get  updated  base  }  }  addChildToParent  (  child  ,  isEmptyElement  )  ;  }    [METHOD]  parseStartTag  [TYPE]  void  [PARAMETER]  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  isEmptyElement  true  [TYPE]  Attribute  attribute  [TYPE]  Element  child  [TYPE]  Node  dataNode  [TYPE]  Attributes  attributes  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  href  html  tagName  [TYPE]  Tag  bodyTag  headTag  htmlTag  tag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[ADD]  boolean  isEmptyElement  =  tag  .  isEmpty  (  )  ;	[BUGGY]  [CE]  cannot  find  symbol  isEmptyElement  [CONTEXT]  private  void  parseStartTag  (  )  {  tq  .  consume  (   "< "  )  ;  String  tagName  =  tq  .  consumeWord  (  )  ;    if  (  tagName  .  length  (  )    =  =  0  )  {  //  doesn't  look  like  a  start  tag  after  all  ;  put  <  back  on  stack  and  handle  as  text  tq  .  addFirst  (   "&lt  ;   "  )  ;  parseTextNode  (  )  ;  return  ;  }  Attributes  attributes  =  new  Attributes  (  )  ;  while  (  !tq  .  matchesAny  (   "< "  ,   "/> "  ,   "> "  )  &&  !tq  .  isEmpty  (  )  )  {  Attribute  attribute  =  parseAttribute  (  )  ;  if  (  attribute  !  =  null  )  attributes  .  put  (  attribute  )  ;  }  Tag  tag  =  Tag  .  valueOf  (  tagName  )  ;  Element  child  =  new  Element  (  tag  ,  baseUri  ,  attributes  )  ;    [ATTENTION]  if  (  tq  .  matchChomp  (   "/> "  )  )  {  //  close  empty  element  or  tag  isEmptyElement  =  true  ;  }  else  {  tq  .  matchChomp  (   "> "  )  ;  }    if  (  tag  .  isData  (  )  )  {  String  data  =  tq  .  chompTo  (   "</ "  +  tagName  )  ;  tq  .  chompTo  (   "> "  )  ;    Node  dataNode  ;  if  (  tag  .  equals  (  titleTag  )  ||  tag  .  equals  (  textareaTag  )  )  //  want  to  show  as  text  ,  but  not  contain  inside  tags  (  so  not  a  data  tag?  )  dataNode  =  TextNode  .  createFromEncoded  (  data  ,  baseUri  )  ;  else  dataNode  =  new  DataNode  (  data  ,  baseUri  )  ;  //  data  not  encoded  but  raw  (  for   "  in  script  )  child  .  appendChild  (  dataNode  )  ;  }    if  (  child  .  tagName  (  )  .  equals  (   "base "  )  )  {  String  href  =  child  .  absUrl  (   "href "  )  ;  if  (  href  .  length  (  )  !  =  0  )  {  //  ignore  <base  target>  etc  baseUri  =  href  ;  doc  .  setBaseUri  (  href  )  ;  //  set  on  the  doc  so  doc  .  createElement  (  Tag  )  will  get  updated  base  }  }  addChildToParent  (  child  ,  isEmptyElement  )  ;  }    [METHOD]  parseStartTag  [TYPE]  void  [PARAMETER]  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  isEmptyElement  true  [TYPE]  Attribute  attribute  [TYPE]  Element  child  [TYPE]  Node  dataNode  [TYPE]  Attributes  attributes  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  href  html  tagName  [TYPE]  Tag  bodyTag  headTag  htmlTag  tag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[REPLACE]  if  (  tq  .  matchChomp  (   "/> "  )  )  {	[BUGGY]  if  (  tq  .  matches  (  baseUri  )    )  {[FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  private  void  parseStartTag  (  )  {  tq  .  consume  (   "< "  )  ;  String  tagName  =  tq  .  consumeWord  (  )  ;    if  (  tagName  .  length  (  )    =  =  0  )  {  //  doesn't  look  like  a  start  tag  after  all  ;  put  <  back  on  stack  and  handle  as  text  tq  .  addFirst  (   "&lt  ;   "  )  ;  parseTextNode  (  )  ;  return  ;  }  Attributes  attributes  =  new  Attributes  (  )  ;  while  (  !tq  .  matchesAny  (   "< "  ,   "/> "  ,   "> "  )  &&  !tq  .  isEmpty  (  )  )  {  Attribute  attribute  =  parseAttribute  (  )  ;  if  (  attribute  !  =  null  )  attributes  .  put  (  attribute  )  ;  }  Tag  tag  =  Tag  .  valueOf  (  tagName  )  ;  Element  child  =  new  Element  (  tag  ,  baseUri  ,  attributes  )  ;    boolean  isEmptyElement  =  tag  .  isEmpty  (  )  ;  //  empty  element  if  empty  tag  (  e  .  g  .  img  )  or  self-closed  el  (  <div/>  [ATTENTION]  if  (  tq  .  matches  (  baseUri  )    )  {  isEmptyElement  =  true  ;  }  else  {  tq  .  matchChomp  (   "> "  )  ;  }    if  (  tag  .  isData  (  )  )  {  String  data  =  tq  .  chompTo  (   "</ "  +  tagName  )  ;  tq  .  chompTo  (   "> "  )  ;    Node  dataNode  ;  if  (  tag  .  equals  (  titleTag  )  ||  tag  .  equals  (  textareaTag  )  )  //  want  to  show  as  text  ,  but  not  contain  inside  tags  (  so  not  a  data  tag?  )  dataNode  =  TextNode  .  createFromEncoded  (  data  ,  baseUri  )  ;  else  dataNode  =  new  DataNode  (  data  ,  baseUri  )  ;  //  data  not  encoded  but  raw  (  for   "  in  script  )  child  .  appendChild  (  dataNode  )  ;  }    if  (  child  .  tagName  (  )  .  equals  (   "base "  )  )  {  String  href  =  child  .  absUrl  (   "href "  )  ;  if  (  href  .  length  (  )  !  =  0  )  {  //  ignore  <base  target>  etc  baseUri  =  href  ;  doc  .  setBaseUri  (  href  )  ;  //  set  on  the  doc  so  doc  .  createElement  (  Tag  )  will  get  updated  base  }  }  addChildToParent  (  child  ,  isEmptyElement  )  ;  }    [METHOD]  parseStartTag  [TYPE]  void  [PARAMETER]  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  isEmptyElement  true  [TYPE]  Attribute  attribute  [TYPE]  Element  child  [TYPE]  Node  dataNode  [TYPE]  Attributes  attributes  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  href  html  tagName  [TYPE]  Tag  bodyTag  headTag  htmlTag  tag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[ADD]  if  (  tq  .  matchChomp  (   "/> "  )  )  {  isEmptyElement  =  true;  }  else  {  tq  .  matchChomp  (   "> "  )  ;  }	[BUGGY]  isEmptyElement  =  true  ;  tq  .  matchChomp  (   "> "  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  private  void  parseStartTag  (  )  {  tq  .  consume  (   "< "  )  ;  String  tagName  =  tq  .  consumeWord  (  )  ;    if  (  tagName  .  length  (  )    =  =  0  )  {  //  doesn't  look  like  a  start  tag  after  all  ;  put  <  back  on  stack  and  handle  as  text  tq  .  addFirst  (   "&lt  ;   "  )  ;  parseTextNode  (  )  ;  return  ;  }  Attributes  attributes  =  new  Attributes  (  )  ;  while  (  !tq  .  matchesAny  (   "< "  ,   "/> "  ,   "> "  )  &&  !tq  .  isEmpty  (  )  )  {  Attribute  attribute  =  parseAttribute  (  )  ;  if  (  attribute  !  =  null  )  attributes  .  put  (  attribute  )  ;  }  Tag  tag  =  Tag  .  valueOf  (  tagName  )  ;  Element  child  =  new  Element  (  tag  ,  baseUri  ,  attributes  )  ;    boolean  isEmptyElement  =  tag  .  isEmpty  (  )  ;  //  empty  element  if  empty  tag  (  e  .  g  .  img  )  or  self-closed  el  (  <div/>  [ATTENTION]  isEmptyElement  =  true  ;  tq  .  matchChomp  (   "> "  )    ;          if  (  tag  .  isData  (  )  )  {  String  data  =  tq  .  chompTo  (   "</ "  +  tagName  )  ;  tq  .  chompTo  (   "> "  )  ;    Node  dataNode  ;  if  (  tag  .  equals  (  titleTag  )  ||  tag  .  equals  (  textareaTag  )  )  //  want  to  show  as  text  ,  but  not  contain  inside  tags  (  so  not  a  data  tag?  )  dataNode  =  TextNode  .  createFromEncoded  (  data  ,  baseUri  )  ;  else  dataNode  =  new  DataNode  (  data  ,  baseUri  )  ;  //  data  not  encoded  but  raw  (  for   "  in  script  )  child  .  appendChild  (  dataNode  )  ;  }    if  (  child  .  tagName  (  )  .  equals  (   "base "  )  )  {  String  href  =  child  .  absUrl  (   "href "  )  ;  if  (  href  .  length  (  )  !  =  0  )  {  //  ignore  <base  target>  etc  baseUri  =  href  ;  doc  .  setBaseUri  (  href  )  ;  //  set  on  the  doc  so  doc  .  createElement  (  Tag  )  will  get  updated  base  }  }  addChildToParent  (  child  ,  isEmptyElement  )  ;  }    [METHOD]  parseStartTag  [TYPE]  void  [PARAMETER]  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  isEmptyElement  true  [TYPE]  Attribute  attribute  [TYPE]  Element  child  [TYPE]  Node  dataNode  [TYPE]  Attributes  attributes  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  href  html  tagName  [TYPE]  Tag  bodyTag  headTag  htmlTag  tag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[REPLACE]  tq  .  matchChomp  (   "> "  )  ;	[BUGGY]  tq  .  matches  (  data  )    ;  [CE]  cannot  find  symbol  data  [CONTEXT]  if  (  tq  .  matchChomp  (   "/> "  )  )  {  //  close  empty  element  or  tag  isEmptyElement  =  true  ;  }  else  {  [ATTENTION]  tq  .  matches  (  data  )  ;  }    [METHOD]  parseStartTag  [TYPE]  void  [PARAMETER]  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  isEmptyElement  true  [TYPE]  Attribute  attribute  [TYPE]  Element  child  [TYPE]  Node  dataNode  [TYPE]  Attributes  attributes  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  href  html  tagName  [TYPE]  Tag  bodyTag  headTag  htmlTag  tag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[REPLACE]  isEmptyElement  =  true;	[BUGGY]  isEmptyElement  =  false  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  private  void  parseStartTag  (  )  {  tq  .  consume  (   "< "  )  ;  String  tagName  =  tq  .  consumeWord  (  )  ;    if  (  tagName  .  length  (  )    =  =  0  )  {  //  doesn't  look  like  a  start  tag  after  all  ;  put  <  back  on  stack  and  handle  as  text  tq  .  addFirst  (   "&lt  ;   "  )  ;  parseTextNode  (  )  ;  return  ;  }  Attributes  attributes  =  new  Attributes  (  )  ;  while  (  !tq  .  matchesAny  (   "< "  ,   "/> "  ,   "> "  )  &&  !tq  .  isEmpty  (  )  )  {  Attribute  attribute  =  parseAttribute  (  )  ;  if  (  attribute  !  =  null  )  attributes  .  put  (  attribute  )  ;  }  Tag  tag  =  Tag  .  valueOf  (  tagName  )  ;  Element  child  =  new  Element  (  tag  ,  baseUri  ,  attributes  )  ;    boolean  isEmptyElement  =  tag  .  isEmpty  (  )  ;  //  empty  element  if  empty  tag  (  e  .  g  .  img  )  or  self-closed  el  (  <div/>  if  (  tq  .  matchChomp  (   "/> "  )  )  {  //  close  empty  element  or  tag  [ATTENTION]  isEmptyElement  =  false  ;  }  else  {  tq  .  matchChomp  (   "> "  )  ;  }    if  (  tag  .  isData  (  )  )  {  String  data  =  tq  .  chompTo  (   "</ "  +  tagName  )  ;  tq  .  chompTo  (   "> "  )  ;    Node  dataNode  ;  if  (  tag  .  equals  (  titleTag  )  ||  tag  .  equals  (  textareaTag  )  )  //  want  to  show  as  text  ,  but  not  contain  inside  tags  (  so  not  a  data  tag?  )  dataNode  =  TextNode  .  createFromEncoded  (  data  ,  baseUri  )  ;  else  dataNode  =  new  DataNode  (  data  ,  baseUri  )  ;  //  data  not  encoded  but  raw  (  for   "  in  script  )  child  .  appendChild  (  dataNode  )  ;  }    if  (  child  .  tagName  (  )  .  equals  (   "base "  )  )  {  String  href  =  child  .  absUrl  (   "href "  )  ;  if  (  href  .  length  (  )  !  =  0  )  {  //  ignore  <base  target>  etc  baseUri  =  href  ;  doc  .  setBaseUri  (  href  )  ;  //  set  on  the  doc  so  doc  .  createElement  (  Tag  )  will  get  updated  base  }  }  addChildToParent  (  child  ,  isEmptyElement  )  ;  }    [METHOD]  parseStartTag  [TYPE]  void  [PARAMETER]  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  isEmptyElement  true  [TYPE]  Attribute  attribute  [TYPE]  Element  child  [TYPE]  Node  dataNode  [TYPE]  Attributes  attributes  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  href  html  tagName  [TYPE]  Tag  bodyTag  headTag  htmlTag  tag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[ADD]  isEmptyElement  =  true;	[BUGGY]  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  private  void  parseStartTag  (  )  {  tq  .  consume  (   "< "  )  ;  String  tagName  =  tq  .  consumeWord  (  )  ;    if  (  tagName  .  length  (  )    =  =  0  )  {  //  doesn't  look  like  a  start  tag  after  all  ;  put  <  back  on  stack  and  handle  as  text  tq  .  addFirst  (   "&lt  ;   "  )  ;  parseTextNode  (  )  ;  return  ;  }  Attributes  attributes  =  new  Attributes  (  )  ;  while  (  !tq  .  matchesAny  (   "< "  ,   "/> "  ,   "> "  )  &&  !tq  .  isEmpty  (  )  )  {  Attribute  attribute  =  parseAttribute  (  )  ;  if  (  attribute  !  =  null  )  attributes  .  put  (  attribute  )  ;  }  Tag  tag  =  Tag  .  valueOf  (  tagName  )  ;  Element  child  =  new  Element  (  tag  ,  baseUri  ,  attributes  )  ;    boolean  isEmptyElement  =  tag  .  isEmpty  (  )  ;  //  empty  element  if  empty  tag  (  e  .  g  .  img  )  or  self-closed  el  (  <div/>  if  (  tq  .  matchChomp  (   "/> "  )  )  {  //  close  empty  element  or  tag  [ATTENTION]  }  else  {  tq  .  matchChomp  (   "> "  )  ;  }    if  (  tag  .  isData  (  )  )  {  String  data  =  tq  .  chompTo  (   "</ "  +  tagName  )  ;  tq  .  chompTo  (   "> "  )  ;    Node  dataNode  ;  if  (  tag  .  equals  (  titleTag  )  ||  tag  .  equals  (  textareaTag  )  )  //  want  to  show  as  text  ,  but  not  contain  inside  tags  (  so  not  a  data  tag?  )  dataNode  =  TextNode  .  createFromEncoded  (  data  ,  baseUri  )  ;  else  dataNode  =  new  DataNode  (  data  ,  baseUri  )  ;  //  data  not  encoded  but  raw  (  for   "  in  script  )  child  .  appendChild  (  dataNode  )  ;  }    if  (  child  .  tagName  (  )  .  equals  (   "base "  )  )  {  String  href  =  child  .  absUrl  (   "href "  )  ;  if  (  href  .  length  (  )  !  =  0  )  {  //  ignore  <base  target>  etc  baseUri  =  href  ;  doc  .  setBaseUri  (  href  )  ;  //  set  on  the  doc  so  doc  .  createElement  (  Tag  )  will  get  updated  base  }  }  addChildToParent  (  child  ,  isEmptyElement  )  ;  }    [METHOD]  parseStartTag  [TYPE]  void  [PARAMETER]  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  isEmptyElement  true  [TYPE]  Attribute  attribute  [TYPE]  Element  child  [TYPE]  Node  dataNode  [TYPE]  Attributes  attributes  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  href  html  tagName  [TYPE]  Tag  bodyTag  headTag  htmlTag  tag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[REPLACE]  if  (  tag  .  isData  (  )  )  {	[BUGGY]  if  (  href  .  length  (  )  !  =  0  )  {[CE]  cannot  find  symbol  href  [CONTEXT]  private  void  parseStartTag  (  )  {  tq  .  consume  (   "< "  )  ;  String  tagName  =  tq  .  consumeWord  (  )  ;    if  (  tagName  .  length  (  )    =  =  0  )  {  //  doesn't  look  like  a  start  tag  after  all  ;  put  <  back  on  stack  and  handle  as  text  tq  .  addFirst  (   "&lt  ;   "  )  ;  parseTextNode  (  )  ;  return  ;  }  Attributes  attributes  =  new  Attributes  (  )  ;  while  (  !tq  .  matchesAny  (   "< "  ,   "/> "  ,   "> "  )  &&  !tq  .  isEmpty  (  )  )  {  Attribute  attribute  =  parseAttribute  (  )  ;  if  (  attribute  !  =  null  )  attributes  .  put  (  attribute  )  ;  }  Tag  tag  =  Tag  .  valueOf  (  tagName  )  ;  Element  child  =  new  Element  (  tag  ,  baseUri  ,  attributes  )  ;    boolean  isEmptyElement  =  tag  .  isEmpty  (  )  ;  //  empty  element  if  empty  tag  (  e  .  g  .  img  )  or  self-closed  el  (  <div/>  if  (  tq  .  matchChomp  (   "/> "  )  )  {  //  close  empty  element  or  tag  isEmptyElement  =  true  ;  }  else  {  tq  .  matchChomp  (   "> "  )  ;  }    [ATTENTION]  if  (  href  .  length  (  )  !  =  0  )  {  String  data  =  tq  .  chompTo  (   "</ "  +  tagName  )  ;  tq  .  chompTo  (   "> "  )  ;    Node  dataNode  ;  if  (  tag  .  equals  (  titleTag  )  ||  tag  .  equals  (  textareaTag  )  )  //  want  to  show  as  text  ,  but  not  contain  inside  tags  (  so  not  a  data  tag?  )  dataNode  =  TextNode  .  createFromEncoded  (  data  ,  baseUri  )  ;  else  dataNode  =  new  DataNode  (  data  ,  baseUri  )  ;  //  data  not  encoded  but  raw  (  for   "  in  script  )  child  .  appendChild  (  dataNode  )  ;  }    if  (  child  .  tagName  (  )  .  equals  (   "base "  )  )  {  String  href  =  child  .  absUrl  (   "href "  )  ;  if  (  href  .  length  (  )  !  =  0  )  {  //  ignore  <base  target>  etc  baseUri  =  href  ;  doc  .  setBaseUri  (  href  )  ;  //  set  on  the  doc  so  doc  .  createElement  (  Tag  )  will  get  updated  base  }  }  addChildToParent  (  child  ,  isEmptyElement  )  ;  }    [METHOD]  parseStartTag  [TYPE]  void  [PARAMETER]  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  isEmptyElement  true  [TYPE]  Attribute  attribute  [TYPE]  Element  child  [TYPE]  Node  dataNode  [TYPE]  Attributes  attributes  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  href  html  tagName  [TYPE]  Tag  bodyTag  headTag  htmlTag  tag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[REPLACE]  if  (  tag  .  equals  (  titleTag  )  ||  tag  .  equals  (  textareaTag  )  )  dataNode  =  TextNode  .  createFromEncoded  (  data,  baseUri  )  ;	[BUGGY]  if  (  tag  .  equals  (  titleTag  )  &&  tag  .  equals  (  textareaTag  )  )  dataNode  =  TextNode  .  createFromEncoded  (  data  ,  baseUri  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  private  void  parseStartTag  (  )  {  tq  .  consume  (   "< "  )  ;  String  tagName  =  tq  .  consumeWord  (  )  ;    if  (  tagName  .  length  (  )    =  =  0  )  {  //  doesn't  look  like  a  start  tag  after  all  ;  put  <  back  on  stack  and  handle  as  text  tq  .  addFirst  (   "&lt  ;   "  )  ;  parseTextNode  (  )  ;  return  ;  }  Attributes  attributes  =  new  Attributes  (  )  ;  while  (  !tq  .  matchesAny  (   "< "  ,   "/> "  ,   "> "  )  &&  !tq  .  isEmpty  (  )  )  {  Attribute  attribute  =  parseAttribute  (  )  ;  if  (  attribute  !  =  null  )  attributes  .  put  (  attribute  )  ;  }  Tag  tag  =  Tag  .  valueOf  (  tagName  )  ;  Element  child  =  new  Element  (  tag  ,  baseUri  ,  attributes  )  ;    boolean  isEmptyElement  =  tag  .  isEmpty  (  )  ;  //  empty  element  if  empty  tag  (  e  .  g  .  img  )  or  self-closed  el  (  <div/>  if  (  tq  .  matchChomp  (   "/> "  )  )  {  //  close  empty  element  or  tag  isEmptyElement  =  true  ;  }  else  {  tq  .  matchChomp  (   "> "  )  ;  }    if  (  tag  .  isData  (  )  )  {  String  data  =  tq  .  chompTo  (   "</ "  +  tagName  )  ;  tq  .  chompTo  (   "> "  )  ;    Node  dataNode  ;  [ATTENTION]  if  (  tag  .  equals  (  titleTag  )  &&  tag  .  equals  (  textareaTag  )  )  dataNode  =  TextNode  .  createFromEncoded  (  data  ,  baseUri  )    ;    else  dataNode  =  new  DataNode  (  data  ,  baseUri  )  ;  //  data  not  encoded  but  raw  (  for   "  in  script  )  child  .  appendChild  (  dataNode  )  ;  }    if  (  child  .  tagName  (  )  .  equals  (   "base "  )  )  {  String  href  =  child  .  absUrl  (   "href "  )  ;  if  (  href  .  length  (  )  !  =  0  )  {  //  ignore  <base  target>  etc  baseUri  =  href  ;  doc  .  setBaseUri  (  href  )  ;  //  set  on  the  doc  so  doc  .  createElement  (  Tag  )  will  get  updated  base  }  }  addChildToParent  (  child  ,  isEmptyElement  )  ;  }    [METHOD]  parseStartTag  [TYPE]  void  [PARAMETER]  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  isEmptyElement  true  [TYPE]  Attribute  attribute  [TYPE]  Element  child  [TYPE]  Node  dataNode  [TYPE]  Attributes  attributes  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  href  html  tagName  [TYPE]  Tag  bodyTag  headTag  htmlTag  tag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[ADD]  if  (  tag  .  equals  (  titleTag  )  ||  tag  .  equals  (  textareaTag  )  )  dataNode  =  TextNode  .  createFromEncoded  (  data,  baseUri  )  ;  else  dataNode  =  new  DataNode  (  data,  baseUri  )  ;  child  .  appendChild  (  dataNode  )  ;	[BUGGY]  dataNode  =  TextNode  .  createFromEncoded  (  data  ,  baseUri  )  ;  dataNode  =  new  DataNode  (  data  ,  baseUri  )  ;  child  .  appendChild  (  dataNode  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  private  void  parseStartTag  (  )  {  tq  .  consume  (   "< "  )  ;  String  tagName  =  tq  .  consumeWord  (  )  ;    if  (  tagName  .  length  (  )    =  =  0  )  {  //  doesn't  look  like  a  start  tag  after  all  ;  put  <  back  on  stack  and  handle  as  text  tq  .  addFirst  (   "&lt  ;   "  )  ;  parseTextNode  (  )  ;  return  ;  }  Attributes  attributes  =  new  Attributes  (  )  ;  while  (  !tq  .  matchesAny  (   "< "  ,   "/> "  ,   "> "  )  &&  !tq  .  isEmpty  (  )  )  {  Attribute  attribute  =  parseAttribute  (  )  ;  if  (  attribute  !  =  null  )  attributes  .  put  (  attribute  )  ;  }  Tag  tag  =  Tag  .  valueOf  (  tagName  )  ;  Element  child  =  new  Element  (  tag  ,  baseUri  ,  attributes  )  ;    boolean  isEmptyElement  =  tag  .  isEmpty  (  )  ;  //  empty  element  if  empty  tag  (  e  .  g  .  img  )  or  self-closed  el  (  <div/>  if  (  tq  .  matchChomp  (   "/> "  )  )  {  //  close  empty  element  or  tag  isEmptyElement  =  true  ;  }  else  {  tq  .  matchChomp  (   "> "  )  ;  }    if  (  tag  .  isData  (  )  )  {  String  data  =  tq  .  chompTo  (   "</ "  +  tagName  )  ;  tq  .  chompTo  (   "> "  )  ;    Node  dataNode  ;  [ATTENTION]  dataNode  =  TextNode  .  createFromEncoded  (  data  ,  baseUri  )    ;  dataNode  =  new  DataNode  (  data  ,  baseUri  )    ;  child  .  appendChild  (  dataNode  )    ;      }    if  (  child  .  tagName  (  )  .  equals  (   "base "  )  )  {  String  href  =  child  .  absUrl  (   "href "  )  ;  if  (  href  .  length  (  )  !  =  0  )  {  //  ignore  <base  target>  etc  baseUri  =  href  ;  doc  .  setBaseUri  (  href  )  ;  //  set  on  the  doc  so  doc  .  createElement  (  Tag  )  will  get  updated  base  }  }  addChildToParent  (  child  ,  isEmptyElement  )  ;  }    [METHOD]  parseStartTag  [TYPE]  void  [PARAMETER]  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  isEmptyElement  true  [TYPE]  Attribute  attribute  [TYPE]  Element  child  [TYPE]  Node  dataNode  [TYPE]  Attributes  attributes  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  href  html  tagName  [TYPE]  Tag  bodyTag  headTag  htmlTag  tag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[REPLACE]  dataNode  =  new  DataNode  (  data,  baseUri  )  ;	[BUGGY]  dataNode  =    new  DataNode  (  tagName  ,  baseUri  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  private  void  parseStartTag  (  )  {  tq  .  consume  (   "< "  )  ;  String  tagName  =  tq  .  consumeWord  (  )  ;    if  (  tagName  .  length  (  )    =  =  0  )  {  //  doesn't  look  like  a  start  tag  after  all  ;  put  <  back  on  stack  and  handle  as  text  tq  .  addFirst  (   "&lt  ;   "  )  ;  parseTextNode  (  )  ;  return  ;  }  Attributes  attributes  =  new  Attributes  (  )  ;  while  (  !tq  .  matchesAny  (   "< "  ,   "/> "  ,   "> "  )  &&  !tq  .  isEmpty  (  )  )  {  Attribute  attribute  =  parseAttribute  (  )  ;  if  (  attribute  !  =  null  )  attributes  .  put  (  attribute  )  ;  }  Tag  tag  =  Tag  .  valueOf  (  tagName  )  ;  Element  child  =  new  Element  (  tag  ,  baseUri  ,  attributes  )  ;    boolean  isEmptyElement  =  tag  .  isEmpty  (  )  ;  //  empty  element  if  empty  tag  (  e  .  g  .  img  )  or  self-closed  el  (  <div/>  if  (  tq  .  matchChomp  (   "/> "  )  )  {  //  close  empty  element  or  tag  isEmptyElement  =  true  ;  }  else  {  tq  .  matchChomp  (   "> "  )  ;  }    if  (  tag  .  isData  (  )  )  {  String  data  =  tq  .  chompTo  (   "</ "  +  tagName  )  ;  tq  .  chompTo  (   "> "  )  ;    Node  dataNode  ;  if  (  tag  .  equals  (  titleTag  )  ||  tag  .  equals  (  textareaTag  )  )  //  want  to  show  as  text  ,  but  not  contain  inside  tags  (  so  not  a  data  tag?  )  dataNode  =  TextNode  .  createFromEncoded  (  data  ,  baseUri  )  ;  else  [ATTENTION]  dataNode  =  new  DataNode  (  tagName  ,  baseUri  )    ;  child  .  appendChild  (  dataNode  )  ;  }    if  (  child  .  tagName  (  )  .  equals  (   "base "  )  )  {  String  href  =  child  .  absUrl  (   "href "  )  ;  if  (  href  .  length  (  )  !  =  0  )  {  //  ignore  <base  target>  etc  baseUri  =  href  ;  doc  .  setBaseUri  (  href  )  ;  //  set  on  the  doc  so  doc  .  createElement  (  Tag  )  will  get  updated  base  }  }  addChildToParent  (  child  ,  isEmptyElement  )  ;  }    [METHOD]  parseStartTag  [TYPE]  void  [PARAMETER]  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  isEmptyElement  true  [TYPE]  Attribute  attribute  [TYPE]  Element  child  [TYPE]  Node  dataNode  [TYPE]  Attributes  attributes  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  href  html  tagName  [TYPE]  Tag  bodyTag  headTag  htmlTag  tag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[ADD]  dataNode  =  new  DataNode  (  data,  baseUri  )  ;  child  .  appendChild  (  dataNode  )  ;	[BUGGY]  child  .  appendChild  (  dataNode  )  ;  [CE]  variable  dataNode  might  not  have  been  initialized  [CONTEXT]  private  void  parseStartTag  (  )  {  tq  .  consume  (   "< "  )  ;  String  tagName  =  tq  .  consumeWord  (  )  ;    if  (  tagName  .  length  (  )    =  =  0  )  {  //  doesn't  look  like  a  start  tag  after  all  ;  put  <  back  on  stack  and  handle  as  text  tq  .  addFirst  (   "&lt  ;   "  )  ;  parseTextNode  (  )  ;  return  ;  }  Attributes  attributes  =  new  Attributes  (  )  ;  while  (  !tq  .  matchesAny  (   "< "  ,   "/> "  ,   "> "  )  &&  !tq  .  isEmpty  (  )  )  {  Attribute  attribute  =  parseAttribute  (  )  ;  if  (  attribute  !  =  null  )  attributes  .  put  (  attribute  )  ;  }  Tag  tag  =  Tag  .  valueOf  (  tagName  )  ;  Element  child  =  new  Element  (  tag  ,  baseUri  ,  attributes  )  ;    boolean  isEmptyElement  =  tag  .  isEmpty  (  )  ;  //  empty  element  if  empty  tag  (  e  .  g  .  img  )  or  self-closed  el  (  <div/>  if  (  tq  .  matchChomp  (   "/> "  )  )  {  //  close  empty  element  or  tag  isEmptyElement  =  true  ;  }  else  {  tq  .  matchChomp  (   "> "  )  ;  }    if  (  tag  .  isData  (  )  )  {  String  data  =  tq  .  chompTo  (   "</ "  +  tagName  )  ;  tq  .  chompTo  (   "> "  )  ;    Node  dataNode  ;  if  (  tag  .  equals  (  titleTag  )  ||  tag  .  equals  (  textareaTag  )  )  //  want  to  show  as  text  ,  but  not  contain  inside  tags  (  so  not  a  data  tag?  )  dataNode  =  TextNode  .  createFromEncoded  (  data  ,  baseUri  )  ;  else  [ATTENTION]  child  .  appendChild  (  dataNode  )    ;    }    if  (  child  .  tagName  (  )  .  equals  (   "base "  )  )  {  String  href  =  child  .  absUrl  (   "href "  )  ;  if  (  href  .  length  (  )  !  =  0  )  {  //  ignore  <base  target>  etc  baseUri  =  href  ;  doc  .  setBaseUri  (  href  )  ;  //  set  on  the  doc  so  doc  .  createElement  (  Tag  )  will  get  updated  base  }  }  addChildToParent  (  child  ,  isEmptyElement  )  ;  }    [METHOD]  parseStartTag  [TYPE]  void  [PARAMETER]  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  isEmptyElement  true  [TYPE]  Attribute  attribute  [TYPE]  Element  child  [TYPE]  Node  dataNode  [TYPE]  Attributes  attributes  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  href  html  tagName  [TYPE]  Tag  bodyTag  headTag  htmlTag  tag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[REPLACE]  dataNode  =  TextNode  .  createFromEncoded  (  data,  baseUri  )  ;	[BUGGY]  dataNode  =    TextNode  .  createFromEncoded  (  tagName  ,  baseUri  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  private  void  parseStartTag  (  )  {  tq  .  consume  (   "< "  )  ;  String  tagName  =  tq  .  consumeWord  (  )  ;    if  (  tagName  .  length  (  )    =  =  0  )  {  //  doesn't  look  like  a  start  tag  after  all  ;  put  <  back  on  stack  and  handle  as  text  tq  .  addFirst  (   "&lt  ;   "  )  ;  parseTextNode  (  )  ;  return  ;  }  Attributes  attributes  =  new  Attributes  (  )  ;  while  (  !tq  .  matchesAny  (   "< "  ,   "/> "  ,   "> "  )  &&  !tq  .  isEmpty  (  )  )  {  Attribute  attribute  =  parseAttribute  (  )  ;  if  (  attribute  !  =  null  )  attributes  .  put  (  attribute  )  ;  }  Tag  tag  =  Tag  .  valueOf  (  tagName  )  ;  Element  child  =  new  Element  (  tag  ,  baseUri  ,  attributes  )  ;    boolean  isEmptyElement  =  tag  .  isEmpty  (  )  ;  //  empty  element  if  empty  tag  (  e  .  g  .  img  )  or  self-closed  el  (  <div/>  if  (  tq  .  matchChomp  (   "/> "  )  )  {  //  close  empty  element  or  tag  isEmptyElement  =  true  ;  }  else  {  tq  .  matchChomp  (   "> "  )  ;  }    if  (  tag  .  isData  (  )  )  {  String  data  =  tq  .  chompTo  (   "</ "  +  tagName  )  ;  tq  .  chompTo  (   "> "  )  ;    Node  dataNode  ;  if  (  tag  .  equals  (  titleTag  )  ||  tag  .  equals  (  textareaTag  )  )  //  want  to  show  as  text  ,  but  not  contain  inside  tags  (  so  not  a  data  tag?  )  [ATTENTION]  dataNode  =  TextNode  .  createFromEncoded  (  tagName  ,  baseUri  )    ;  else  dataNode  =  new  DataNode  (  data  ,  baseUri  )  ;  //  data  not  encoded  but  raw  (  for   "  in  script  )  child  .  appendChild  (  dataNode  )  ;  }    if  (  child  .  tagName  (  )  .  equals  (   "base "  )  )  {  String  href  =  child  .  absUrl  (   "href "  )  ;  if  (  href  .  length  (  )  !  =  0  )  {  //  ignore  <base  target>  etc  baseUri  =  href  ;  doc  .  setBaseUri  (  href  )  ;  //  set  on  the  doc  so  doc  .  createElement  (  Tag  )  will  get  updated  base  }  }  addChildToParent  (  child  ,  isEmptyElement  )  ;  }    [METHOD]  parseStartTag  [TYPE]  void  [PARAMETER]  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  isEmptyElement  true  [TYPE]  Attribute  attribute  [TYPE]  Element  child  [TYPE]  Node  dataNode  [TYPE]  Attributes  attributes  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  href  html  tagName  [TYPE]  Tag  bodyTag  headTag  htmlTag  tag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[ADD]  dataNode  =  TextNode  .  createFromEncoded  (  data,  baseUri  )  ;	[BUGGY]  [CE]  'else'  without  'if'  [CONTEXT]  private  void  parseStartTag  (  )  {  tq  .  consume  (   "< "  )  ;  String  tagName  =  tq  .  consumeWord  (  )  ;    if  (  tagName  .  length  (  )    =  =  0  )  {  //  doesn't  look  like  a  start  tag  after  all  ;  put  <  back  on  stack  and  handle  as  text  tq  .  addFirst  (   "&lt  ;   "  )  ;  parseTextNode  (  )  ;  return  ;  }  Attributes  attributes  =  new  Attributes  (  )  ;  while  (  !tq  .  matchesAny  (   "< "  ,   "/> "  ,   "> "  )  &&  !tq  .  isEmpty  (  )  )  {  Attribute  attribute  =  parseAttribute  (  )  ;  if  (  attribute  !  =  null  )  attributes  .  put  (  attribute  )  ;  }  Tag  tag  =  Tag  .  valueOf  (  tagName  )  ;  Element  child  =  new  Element  (  tag  ,  baseUri  ,  attributes  )  ;    boolean  isEmptyElement  =  tag  .  isEmpty  (  )  ;  //  empty  element  if  empty  tag  (  e  .  g  .  img  )  or  self-closed  el  (  <div/>  if  (  tq  .  matchChomp  (   "/> "  )  )  {  //  close  empty  element  or  tag  isEmptyElement  =  true  ;  }  else  {  tq  .  matchChomp  (   "> "  )  ;  }    if  (  tag  .  isData  (  )  )  {  String  data  =  tq  .  chompTo  (   "</ "  +  tagName  )  ;  tq  .  chompTo  (   "> "  )  ;    Node  dataNode  ;  if  (  tag  .  equals  (  titleTag  )  ||  tag  .  equals  (  textareaTag  )  )  //  want  to  show  as  text  ,  but  not  contain  inside  tags  (  so  not  a  data  tag?  )  [ATTENTION]  else  dataNode  =  new  DataNode  (  data  ,  baseUri  )  ;  //  data  not  encoded  but  raw  (  for   "  in  script  )  child  .  appendChild  (  dataNode  )  ;  }    if  (  child  .  tagName  (  )  .  equals  (   "base "  )  )  {  String  href  =  child  .  absUrl  (   "href "  )  ;  if  (  href  .  length  (  )  !  =  0  )  {  //  ignore  <base  target>  etc  baseUri  =  href  ;  doc  .  setBaseUri  (  href  )  ;  //  set  on  the  doc  so  doc  .  createElement  (  Tag  )  will  get  updated  base  }  }  addChildToParent  (  child  ,  isEmptyElement  )  ;  }    [METHOD]  parseStartTag  [TYPE]  void  [PARAMETER]  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  isEmptyElement  true  [TYPE]  Attribute  attribute  [TYPE]  Element  child  [TYPE]  Node  dataNode  [TYPE]  Attributes  attributes  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  href  html  tagName  [TYPE]  Tag  bodyTag  headTag  htmlTag  tag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[REPLACE]  dataNode  =  new  DataNode  (  data,  baseUri  )  ;	[BUGGY]  dataNode  =    new  Element  (  parentTag  ,  baseUri  )    ;  [CE]  cannot  find  symbol  parentTag  [CONTEXT]  private  void  parseStartTag  (  )  {  tq  .  consume  (   "< "  )  ;  String  tagName  =  tq  .  consumeWord  (  )  ;    if  (  tagName  .  length  (  )    =  =  0  )  {  //  doesn't  look  like  a  start  tag  after  all  ;  put  <  back  on  stack  and  handle  as  text  tq  .  addFirst  (   "&lt  ;   "  )  ;  parseTextNode  (  )  ;  return  ;  }  Attributes  attributes  =  new  Attributes  (  )  ;  while  (  !tq  .  matchesAny  (   "< "  ,   "/> "  ,   "> "  )  &&  !tq  .  isEmpty  (  )  )  {  Attribute  attribute  =  parseAttribute  (  )  ;  if  (  attribute  !  =  null  )  attributes  .  put  (  attribute  )  ;  }  Tag  tag  =  Tag  .  valueOf  (  tagName  )  ;  Element  child  =  new  Element  (  tag  ,  baseUri  ,  attributes  )  ;    boolean  isEmptyElement  =  tag  .  isEmpty  (  )  ;  //  empty  element  if  empty  tag  (  e  .  g  .  img  )  or  self-closed  el  (  <div/>  if  (  tq  .  matchChomp  (   "/> "  )  )  {  //  close  empty  element  or  tag  isEmptyElement  =  true  ;  }  else  {  tq  .  matchChomp  (   "> "  )  ;  }    if  (  tag  .  isData  (  )  )  {  String  data  =  tq  .  chompTo  (   "</ "  +  tagName  )  ;  tq  .  chompTo  (   "> "  )  ;    Node  dataNode  ;  if  (  tag  .  equals  (  titleTag  )  ||  tag  .  equals  (  textareaTag  )  )  //  want  to  show  as  text  ,  but  not  contain  inside  tags  (  so  not  a  data  tag?  )  dataNode  =  TextNode  .  createFromEncoded  (  data  ,  baseUri  )  ;  else  [ATTENTION]  dataNode  =  new  Element  (  parentTag  ,  baseUri  )  ;  child  .  appendChild  (  dataNode  )  ;  }    if  (  child  .  tagName  (  )  .  equals  (   "base "  )  )  {  String  href  =  child  .  absUrl  (   "href "  )  ;  if  (  href  .  length  (  )  !  =  0  )  {  //  ignore  <base  target>  etc  baseUri  =  href  ;  doc  .  setBaseUri  (  href  )  ;  //  set  on  the  doc  so  doc  .  createElement  (  Tag  )  will  get  updated  base  }  }  addChildToParent  (  child  ,  isEmptyElement  )  ;  }    [METHOD]  parseStartTag  [TYPE]  void  [PARAMETER]  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  isEmptyElement  true  [TYPE]  Attribute  attribute  [TYPE]  Element  child  [TYPE]  Node  dataNode  [TYPE]  Attributes  attributes  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  href  html  tagName  [TYPE]  Tag  bodyTag  headTag  htmlTag  tag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[REPLACE]  String  data  =  tq  .  chompTo  (   "</ "  +  tagName  )  ;	[BUGGY]  String  data  =  tq  .  chompTo  (   "</ "  !  =    html  )  ;  [CE]  cannot  find  symbol  html  [CONTEXT]  private  void  parseStartTag  (  )  {  tq  .  consume  (   "< "  )  ;  String  tagName  =  tq  .  consumeWord  (  )  ;    if  (  tagName  .  length  (  )    =  =  0  )  {  //  doesn't  look  like  a  start  tag  after  all  ;  put  <  back  on  stack  and  handle  as  text  tq  .  addFirst  (   "&lt  ;   "  )  ;  parseTextNode  (  )  ;  return  ;  }  Attributes  attributes  =  new  Attributes  (  )  ;  while  (  !tq  .  matchesAny  (   "< "  ,   "/> "  ,   "> "  )  &&  !tq  .  isEmpty  (  )  )  {  Attribute  attribute  =  parseAttribute  (  )  ;  if  (  attribute  !  =  null  )  attributes  .  put  (  attribute  )  ;  }  Tag  tag  =  Tag  .  valueOf  (  tagName  )  ;  Element  child  =  new  Element  (  tag  ,  baseUri  ,  attributes  )  ;    boolean  isEmptyElement  =  tag  .  isEmpty  (  )  ;  //  empty  element  if  empty  tag  (  e  .  g  .  img  )  or  self-closed  el  (  <div/>  if  (  tq  .  matchChomp  (   "/> "  )  )  {  //  close  empty  element  or  tag  isEmptyElement  =  true  ;  }  else  {  tq  .  matchChomp  (   "> "  )  ;  }    if  (  tag  .  isData  (  )  )  {  [ATTENTION]  String  data  =  tq  .  chompTo  (   "</ "!  =  html  )    ;  tq  .  chompTo  (   "> "  )  ;    Node  dataNode  ;  if  (  tag  .  equals  (  titleTag  )  ||  tag  .  equals  (  textareaTag  )  )  //  want  to  show  as  text  ,  but  not  contain  inside  tags  (  so  not  a  data  tag?  )  dataNode  =  TextNode  .  createFromEncoded  (  data  ,  baseUri  )  ;  else  dataNode  =  new  DataNode  (  data  ,  baseUri  )  ;  //  data  not  encoded  but  raw  (  for   "  in  script  )  child  .  appendChild  (  dataNode  )  ;  }    if  (  child  .  tagName  (  )  .  equals  (   "base "  )  )  {  String  href  =  child  .  absUrl  (   "href "  )  ;  if  (  href  .  length  (  )  !  =  0  )  {  //  ignore  <base  target>  etc  baseUri  =  href  ;  doc  .  setBaseUri  (  href  )  ;  //  set  on  the  doc  so  doc  .  createElement  (  Tag  )  will  get  updated  base  }  }  addChildToParent  (  child  ,  isEmptyElement  )  ;  }    [METHOD]  parseStartTag  [TYPE]  void  [PARAMETER]  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  isEmptyElement  true  [TYPE]  Attribute  attribute  [TYPE]  Element  child  [TYPE]  Node  dataNode  [TYPE]  Attributes  attributes  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  href  html  tagName  [TYPE]  Tag  bodyTag  headTag  htmlTag  tag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[REPLACE]  Node  dataNode;	[BUGGY]  Element  child  =  new  Element  (  tag  ,  baseUri  ,  attributes  )  ;  [CE]  variable  child  is  already  defined  in  method  parseStartTag()  [CONTEXT]  private  void  parseStartTag  (  )  {  tq  .  consume  (   "< "  )  ;  String  tagName  =  tq  .  consumeWord  (  )  ;    if  (  tagName  .  length  (  )    =  =  0  )  {  //  doesn't  look  like  a  start  tag  after  all  ;  put  <  back  on  stack  and  handle  as  text  tq  .  addFirst  (   "&lt  ;   "  )  ;  parseTextNode  (  )  ;  return  ;  }  Attributes  attributes  =  new  Attributes  (  )  ;  while  (  !tq  .  matchesAny  (   "< "  ,   "/> "  ,   "> "  )  &&  !tq  .  isEmpty  (  )  )  {  Attribute  attribute  =  parseAttribute  (  )  ;  if  (  attribute  !  =  null  )  attributes  .  put  (  attribute  )  ;  }  Tag  tag  =  Tag  .  valueOf  (  tagName  )  ;  Element  child  =  new  Element  (  tag  ,  baseUri  ,  attributes  )  ;    boolean  isEmptyElement  =  tag  .  isEmpty  (  )  ;  //  empty  element  if  empty  tag  (  e  .  g  .  img  )  or  self-closed  el  (  <div/>  if  (  tq  .  matchChomp  (   "/> "  )  )  {  //  close  empty  element  or  tag  isEmptyElement  =  true  ;  }  else  {  tq  .  matchChomp  (   "> "  )  ;  }    if  (  tag  .  isData  (  )  )  {  String  data  =  tq  .  chompTo  (   "</ "  +  tagName  )  ;  tq  .  chompTo  (   "> "  )  ;    [ATTENTION]  Element  child  =  new  Element  (  tag  ,  baseUri  ,  attributes  )    ;  if  (  tag  .  equals  (  titleTag  )  ||  tag  .  equals  (  textareaTag  )  )  //  want  to  show  as  text  ,  but  not  contain  inside  tags  (  so  not  a  data  tag?  )  dataNode  =  TextNode  .  createFromEncoded  (  data  ,  baseUri  )  ;  else  dataNode  =  new  DataNode  (  data  ,  baseUri  )  ;  //  data  not  encoded  but  raw  (  for   "  in  script  )  child  .  appendChild  (  dataNode  )  ;  }    if  (  child  .  tagName  (  )  .  equals  (   "base "  )  )  {  String  href  =  child  .  absUrl  (   "href "  )  ;  if  (  href  .  length  (  )  !  =  0  )  {  //  ignore  <base  target>  etc  baseUri  =  href  ;  doc  .  setBaseUri  (  href  )  ;  //  set  on  the  doc  so  doc  .  createElement  (  Tag  )  will  get  updated  base  }  }  addChildToParent  (  child  ,  isEmptyElement  )  ;  }    [METHOD]  parseStartTag  [TYPE]  void  [PARAMETER]  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  isEmptyElement  true  [TYPE]  Attribute  attribute  [TYPE]  Element  child  [TYPE]  Node  dataNode  [TYPE]  Attributes  attributes  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  href  html  tagName  [TYPE]  Tag  bodyTag  headTag  htmlTag  tag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[ADD]  Node  dataNode;	[BUGGY]  [CE]  cannot  find  symbol  dataNode  [CONTEXT]  private  void  parseStartTag  (  )  {  tq  .  consume  (   "< "  )  ;  String  tagName  =  tq  .  consumeWord  (  )  ;    if  (  tagName  .  length  (  )    =  =  0  )  {  //  doesn't  look  like  a  start  tag  after  all  ;  put  <  back  on  stack  and  handle  as  text  tq  .  addFirst  (   "&lt  ;   "  )  ;  parseTextNode  (  )  ;  return  ;  }  Attributes  attributes  =  new  Attributes  (  )  ;  while  (  !tq  .  matchesAny  (   "< "  ,   "/> "  ,   "> "  )  &&  !tq  .  isEmpty  (  )  )  {  Attribute  attribute  =  parseAttribute  (  )  ;  if  (  attribute  !  =  null  )  attributes  .  put  (  attribute  )  ;  }  Tag  tag  =  Tag  .  valueOf  (  tagName  )  ;  Element  child  =  new  Element  (  tag  ,  baseUri  ,  attributes  )  ;    boolean  isEmptyElement  =  tag  .  isEmpty  (  )  ;  //  empty  element  if  empty  tag  (  e  .  g  .  img  )  or  self-closed  el  (  <div/>  if  (  tq  .  matchChomp  (   "/> "  )  )  {  //  close  empty  element  or  tag  isEmptyElement  =  true  ;  }  else  {  tq  .  matchChomp  (   "> "  )  ;  }    if  (  tag  .  isData  (  )  )  {  String  data  =  tq  .  chompTo  (   "</ "  +  tagName  )  ;  tq  .  chompTo  (   "> "  )  ;    [ATTENTION]  if  (  tag  .  equals  (  titleTag  )  ||  tag  .  equals  (  textareaTag  )  )  //  want  to  show  as  text  ,  but  not  contain  inside  tags  (  so  not  a  data  tag?  )  dataNode  =  TextNode  .  createFromEncoded  (  data  ,  baseUri  )  ;  else  dataNode  =  new  DataNode  (  data  ,  baseUri  )  ;  //  data  not  encoded  but  raw  (  for   "  in  script  )  child  .  appendChild  (  dataNode  )  ;  }    if  (  child  .  tagName  (  )  .  equals  (   "base "  )  )  {  String  href  =  child  .  absUrl  (   "href "  )  ;  if  (  href  .  length  (  )  !  =  0  )  {  //  ignore  <base  target>  etc  baseUri  =  href  ;  doc  .  setBaseUri  (  href  )  ;  //  set  on  the  doc  so  doc  .  createElement  (  Tag  )  will  get  updated  base  }  }  addChildToParent  (  child  ,  isEmptyElement  )  ;  }    [METHOD]  parseStartTag  [TYPE]  void  [PARAMETER]  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  isEmptyElement  true  [TYPE]  Attribute  attribute  [TYPE]  Element  child  [TYPE]  Node  dataNode  [TYPE]  Attributes  attributes  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  href  html  tagName  [TYPE]  Tag  bodyTag  headTag  htmlTag  tag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[ADD]  dataNode  =  new  DataNode  (  data,  baseUri  )  ;	[BUGGY]  [CE]  variable  dataNode  might  not  have  been  initialized  [CONTEXT]  private  void  parseStartTag  (  )  {  tq  .  consume  (   "< "  )  ;  String  tagName  =  tq  .  consumeWord  (  )  ;    if  (  tagName  .  length  (  )    =  =  0  )  {  //  doesn't  look  like  a  start  tag  after  all  ;  put  <  back  on  stack  and  handle  as  text  tq  .  addFirst  (   "&lt  ;   "  )  ;  parseTextNode  (  )  ;  return  ;  }  Attributes  attributes  =  new  Attributes  (  )  ;  while  (  !tq  .  matchesAny  (   "< "  ,   "/> "  ,   "> "  )  &&  !tq  .  isEmpty  (  )  )  {  Attribute  attribute  =  parseAttribute  (  )  ;  if  (  attribute  !  =  null  )  attributes  .  put  (  attribute  )  ;  }  Tag  tag  =  Tag  .  valueOf  (  tagName  )  ;  Element  child  =  new  Element  (  tag  ,  baseUri  ,  attributes  )  ;    boolean  isEmptyElement  =  tag  .  isEmpty  (  )  ;  //  empty  element  if  empty  tag  (  e  .  g  .  img  )  or  self-closed  el  (  <div/>  if  (  tq  .  matchChomp  (   "/> "  )  )  {  //  close  empty  element  or  tag  isEmptyElement  =  true  ;  }  else  {  tq  .  matchChomp  (   "> "  )  ;  }    if  (  tag  .  isData  (  )  )  {  String  data  =  tq  .  chompTo  (   "</ "  +  tagName  )  ;  tq  .  chompTo  (   "> "  )  ;    Node  dataNode  ;  if  (  tag  .  equals  (  titleTag  )  ||  tag  .  equals  (  textareaTag  )  )  //  want  to  show  as  text  ,  but  not  contain  inside  tags  (  so  not  a  data  tag?  )  dataNode  =  TextNode  .  createFromEncoded  (  data  ,  baseUri  )  ;  else  [ATTENTION]  child  .  appendChild  (  dataNode  )  ;  }    if  (  child  .  tagName  (  )  .  equals  (   "base "  )  )  {  String  href  =  child  .  absUrl  (   "href "  )  ;  if  (  href  .  length  (  )  !  =  0  )  {  //  ignore  <base  target>  etc  baseUri  =  href  ;  doc  .  setBaseUri  (  href  )  ;  //  set  on  the  doc  so  doc  .  createElement  (  Tag  )  will  get  updated  base  }  }  addChildToParent  (  child  ,  isEmptyElement  )  ;  }    [METHOD]  parseStartTag  [TYPE]  void  [PARAMETER]  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  isEmptyElement  true  [TYPE]  Attribute  attribute  [TYPE]  Element  child  [TYPE]  Node  dataNode  [TYPE]  Attributes  attributes  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  href  html  tagName  [TYPE]  Tag  bodyTag  headTag  htmlTag  tag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[REPLACE]  String  data  =  tq  .  chompTo  (   "</ "  +  tagName  )  ;	[BUGGY]  String  data  =  tq  .  chompTo  (   "</ "  >  =    tagName  )  ;  [CE]  bad  operand  types  for  binary  operator  [CONTEXT]  private  void  parseStartTag  (  )  {  tq  .  consume  (   "< "  )  ;  String  tagName  =  tq  .  consumeWord  (  )  ;    if  (  tagName  .  length  (  )    =  =  0  )  {  //  doesn't  look  like  a  start  tag  after  all  ;  put  <  back  on  stack  and  handle  as  text  tq  .  addFirst  (   "&lt  ;   "  )  ;  parseTextNode  (  )  ;  return  ;  }  Attributes  attributes  =  new  Attributes  (  )  ;  while  (  !tq  .  matchesAny  (   "< "  ,   "/> "  ,   "> "  )  &&  !tq  .  isEmpty  (  )  )  {  Attribute  attribute  =  parseAttribute  (  )  ;  if  (  attribute  !  =  null  )  attributes  .  put  (  attribute  )  ;  }  Tag  tag  =  Tag  .  valueOf  (  tagName  )  ;  Element  child  =  new  Element  (  tag  ,  baseUri  ,  attributes  )  ;    boolean  isEmptyElement  =  tag  .  isEmpty  (  )  ;  //  empty  element  if  empty  tag  (  e  .  g  .  img  )  or  self-closed  el  (  <div/>  if  (  tq  .  matchChomp  (   "/> "  )  )  {  //  close  empty  element  or  tag  isEmptyElement  =  true  ;  }  else  {  tq  .  matchChomp  (   "> "  )  ;  }    if  (  tag  .  isData  (  )  )  {  [ATTENTION]  String  data  =  tq  .  chompTo  (   "</ ">  =  tagName  )    ;  tq  .  chompTo  (   "> "  )  ;    Node  dataNode  ;  if  (  tag  .  equals  (  titleTag  )  ||  tag  .  equals  (  textareaTag  )  )  //  want  to  show  as  text  ,  but  not  contain  inside  tags  (  so  not  a  data  tag?  )  dataNode  =  TextNode  .  createFromEncoded  (  data  ,  baseUri  )  ;  else  dataNode  =  new  DataNode  (  data  ,  baseUri  )  ;  //  data  not  encoded  but  raw  (  for   "  in  script  )  child  .  appendChild  (  dataNode  )  ;  }    if  (  child  .  tagName  (  )  .  equals  (   "base "  )  )  {  String  href  =  child  .  absUrl  (   "href "  )  ;  if  (  href  .  length  (  )  !  =  0  )  {  //  ignore  <base  target>  etc  baseUri  =  href  ;  doc  .  setBaseUri  (  href  )  ;  //  set  on  the  doc  so  doc  .  createElement  (  Tag  )  will  get  updated  base  }  }  addChildToParent  (  child  ,  isEmptyElement  )  ;  }    [METHOD]  parseStartTag  [TYPE]  void  [PARAMETER]  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  isEmptyElement  true  [TYPE]  Attribute  attribute  [TYPE]  Element  child  [TYPE]  Node  dataNode  [TYPE]  Attributes  attributes  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  href  html  tagName  [TYPE]  Tag  bodyTag  headTag  htmlTag  tag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[REPLACE]  if  (  child  .  tagName  (  )    .  equals  (   "base "  )  )  {	[BUGGY]  if  (  child  .  tag  (  )  .  equals  (  bodyTag  )  )  {[FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  private  void  parseStartTag  (  )  {  tq  .  consume  (   "< "  )  ;  String  tagName  =  tq  .  consumeWord  (  )  ;    if  (  tagName  .  length  (  )    =  =  0  )  {  //  doesn't  look  like  a  start  tag  after  all  ;  put  <  back  on  stack  and  handle  as  text  tq  .  addFirst  (   "&lt  ;   "  )  ;  parseTextNode  (  )  ;  return  ;  }  Attributes  attributes  =  new  Attributes  (  )  ;  while  (  !tq  .  matchesAny  (   "< "  ,   "/> "  ,   "> "  )  &&  !tq  .  isEmpty  (  )  )  {  Attribute  attribute  =  parseAttribute  (  )  ;  if  (  attribute  !  =  null  )  attributes  .  put  (  attribute  )  ;  }  Tag  tag  =  Tag  .  valueOf  (  tagName  )  ;  Element  child  =  new  Element  (  tag  ,  baseUri  ,  attributes  )  ;    boolean  isEmptyElement  =  tag  .  isEmpty  (  )  ;  //  empty  element  if  empty  tag  (  e  .  g  .  img  )  or  self-closed  el  (  <div/>  if  (  tq  .  matchChomp  (   "/> "  )  )  {  //  close  empty  element  or  tag  isEmptyElement  =  true  ;  }  else  {  tq  .  matchChomp  (   "> "  )  ;  }    if  (  tag  .  isData  (  )  )  {  String  data  =  tq  .  chompTo  (   "</ "  +  tagName  )  ;  tq  .  chompTo  (   "> "  )  ;    Node  dataNode  ;  if  (  tag  .  equals  (  titleTag  )  ||  tag  .  equals  (  textareaTag  )  )  //  want  to  show  as  text  ,  but  not  contain  inside  tags  (  so  not  a  data  tag?  )  dataNode  =  TextNode  .  createFromEncoded  (  data  ,  baseUri  )  ;  else  dataNode  =  new  DataNode  (  data  ,  baseUri  )  ;  //  data  not  encoded  but  raw  (  for   "  in  script  )  child  .  appendChild  (  dataNode  )  ;  }    [ATTENTION]  if  (  child  .  tag  (  )    .  equals  (  bodyTag  )  )  {  String  href  =  child  .  absUrl  (   "href "  )  ;  if  (  href  .  length  (  )  !  =  0  )  {  //  ignore  <base  target>  etc  baseUri  =  href  ;  doc  .  setBaseUri  (  href  )  ;  //  set  on  the  doc  so  doc  .  createElement  (  Tag  )  will  get  updated  base  }  }  addChildToParent  (  child  ,  isEmptyElement  )  ;  }    [METHOD]  parseStartTag  [TYPE]  void  [PARAMETER]  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  isEmptyElement  true  [TYPE]  Attribute  attribute  [TYPE]  Element  child  [TYPE]  Node  dataNode  [TYPE]  Attributes  attributes  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  href  html  tagName  [TYPE]  Tag  bodyTag  headTag  htmlTag  tag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[REPLACE]  if  (  href  .  length  (  )  !=  0  )  {	[BUGGY]  if  (  href  .  length  (  )  *  0  .  5  !  =  0  )  {[FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  private  void  parseStartTag  (  )  {  tq  .  consume  (   "< "  )  ;  String  tagName  =  tq  .  consumeWord  (  )  ;    if  (  tagName  .  length  (  )    =  =  0  )  {  //  doesn't  look  like  a  start  tag  after  all  ;  put  <  back  on  stack  and  handle  as  text  tq  .  addFirst  (   "&lt  ;   "  )  ;  parseTextNode  (  )  ;  return  ;  }  Attributes  attributes  =  new  Attributes  (  )  ;  while  (  !tq  .  matchesAny  (   "< "  ,   "/> "  ,   "> "  )  &&  !tq  .  isEmpty  (  )  )  {  Attribute  attribute  =  parseAttribute  (  )  ;  if  (  attribute  !  =  null  )  attributes  .  put  (  attribute  )  ;  }  Tag  tag  =  Tag  .  valueOf  (  tagName  )  ;  Element  child  =  new  Element  (  tag  ,  baseUri  ,  attributes  )  ;    boolean  isEmptyElement  =  tag  .  isEmpty  (  )  ;  //  empty  element  if  empty  tag  (  e  .  g  .  img  )  or  self-closed  el  (  <div/>  if  (  tq  .  matchChomp  (   "/> "  )  )  {  //  close  empty  element  or  tag  isEmptyElement  =  true  ;  }  else  {  tq  .  matchChomp  (   "> "  )  ;  }    if  (  tag  .  isData  (  )  )  {  String  data  =  tq  .  chompTo  (   "</ "  +  tagName  )  ;  tq  .  chompTo  (   "> "  )  ;    Node  dataNode  ;  if  (  tag  .  equals  (  titleTag  )  ||  tag  .  equals  (  textareaTag  )  )  //  want  to  show  as  text  ,  but  not  contain  inside  tags  (  so  not  a  data  tag?  )  dataNode  =  TextNode  .  createFromEncoded  (  data  ,  baseUri  )  ;  else  dataNode  =  new  DataNode  (  data  ,  baseUri  )  ;  //  data  not  encoded  but  raw  (  for   "  in  script  )  child  .  appendChild  (  dataNode  )  ;  }    if  (  child  .  tagName  (  )  .  equals  (   "base "  )  )  {  String  href  =  child  .  absUrl  (   "href "  )  ;  [ATTENTION]  if  (  href  .  length  (  )  *0  .  5!  =  0  )  {  baseUri  =  href  ;  doc  .  setBaseUri  (  href  )  ;  //  set  on  the  doc  so  doc  .  createElement  (  Tag  )  will  get  updated  base  }  }  addChildToParent  (  child  ,  isEmptyElement  )  ;  }    [METHOD]  parseStartTag  [TYPE]  void  [PARAMETER]  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  isEmptyElement  true  [TYPE]  Attribute  attribute  [TYPE]  Element  child  [TYPE]  Node  dataNode  [TYPE]  Attributes  attributes  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  href  html  tagName  [TYPE]  Tag  bodyTag  headTag  htmlTag  tag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[ADD]  if  (  href  .  length  (  )  !=  0  )  {  baseUri  =  href;  doc  .  setBaseUri  (  href  )  ;  }	[BUGGY]  baseUri  =  href  ;  doc  .  setBaseUri  (  href  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  private  void  parseStartTag  (  )  {  tq  .  consume  (   "< "  )  ;  String  tagName  =  tq  .  consumeWord  (  )  ;    if  (  tagName  .  length  (  )    =  =  0  )  {  //  doesn't  look  like  a  start  tag  after  all  ;  put  <  back  on  stack  and  handle  as  text  tq  .  addFirst  (   "&lt  ;   "  )  ;  parseTextNode  (  )  ;  return  ;  }  Attributes  attributes  =  new  Attributes  (  )  ;  while  (  !tq  .  matchesAny  (   "< "  ,   "/> "  ,   "> "  )  &&  !tq  .  isEmpty  (  )  )  {  Attribute  attribute  =  parseAttribute  (  )  ;  if  (  attribute  !  =  null  )  attributes  .  put  (  attribute  )  ;  }  Tag  tag  =  Tag  .  valueOf  (  tagName  )  ;  Element  child  =  new  Element  (  tag  ,  baseUri  ,  attributes  )  ;    boolean  isEmptyElement  =  tag  .  isEmpty  (  )  ;  //  empty  element  if  empty  tag  (  e  .  g  .  img  )  or  self-closed  el  (  <div/>  if  (  tq  .  matchChomp  (   "/> "  )  )  {  //  close  empty  element  or  tag  isEmptyElement  =  true  ;  }  else  {  tq  .  matchChomp  (   "> "  )  ;  }    if  (  tag  .  isData  (  )  )  {  String  data  =  tq  .  chompTo  (   "</ "  +  tagName  )  ;  tq  .  chompTo  (   "> "  )  ;    Node  dataNode  ;  if  (  tag  .  equals  (  titleTag  )  ||  tag  .  equals  (  textareaTag  )  )  //  want  to  show  as  text  ,  but  not  contain  inside  tags  (  so  not  a  data  tag?  )  dataNode  =  TextNode  .  createFromEncoded  (  data  ,  baseUri  )  ;  else  dataNode  =  new  DataNode  (  data  ,  baseUri  )  ;  //  data  not  encoded  but  raw  (  for   "  in  script  )  child  .  appendChild  (  dataNode  )  ;  }    if  (  child  .  tagName  (  )  .  equals  (   "base "  )  )  {  String  href  =  child  .  absUrl  (   "href "  )  ;  [ATTENTION]  baseUri  =  href  ;  doc  .  setBaseUri  (  href  )    ;      }  addChildToParent  (  child  ,  isEmptyElement  )  ;  }    [METHOD]  parseStartTag  [TYPE]  void  [PARAMETER]  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  isEmptyElement  true  [TYPE]  Attribute  attribute  [TYPE]  Element  child  [TYPE]  Node  dataNode  [TYPE]  Attributes  attributes  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  href  html  tagName  [TYPE]  Tag  bodyTag  headTag  htmlTag  tag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[REPLACE]  baseUri  =  href;	[BUGGY]  baseUri  =    html  ;  [CE]  cannot  find  symbol  html  [CONTEXT]  private  void  parseStartTag  (  )  {  tq  .  consume  (   "< "  )  ;  String  tagName  =  tq  .  consumeWord  (  )  ;    if  (  tagName  .  length  (  )    =  =  0  )  {  //  doesn't  look  like  a  start  tag  after  all  ;  put  <  back  on  stack  and  handle  as  text  tq  .  addFirst  (   "&lt  ;   "  )  ;  parseTextNode  (  )  ;  return  ;  }  Attributes  attributes  =  new  Attributes  (  )  ;  while  (  !tq  .  matchesAny  (   "< "  ,   "/> "  ,   "> "  )  &&  !tq  .  isEmpty  (  )  )  {  Attribute  attribute  =  parseAttribute  (  )  ;  if  (  attribute  !  =  null  )  attributes  .  put  (  attribute  )  ;  }  Tag  tag  =  Tag  .  valueOf  (  tagName  )  ;  Element  child  =  new  Element  (  tag  ,  baseUri  ,  attributes  )  ;    boolean  isEmptyElement  =  tag  .  isEmpty  (  )  ;  //  empty  element  if  empty  tag  (  e  .  g  .  img  )  or  self-closed  el  (  <div/>  if  (  tq  .  matchChomp  (   "/> "  )  )  {  //  close  empty  element  or  tag  isEmptyElement  =  true  ;  }  else  {  tq  .  matchChomp  (   "> "  )  ;  }    if  (  tag  .  isData  (  )  )  {  String  data  =  tq  .  chompTo  (   "</ "  +  tagName  )  ;  tq  .  chompTo  (   "> "  )  ;    Node  dataNode  ;  if  (  tag  .  equals  (  titleTag  )  ||  tag  .  equals  (  textareaTag  )  )  //  want  to  show  as  text  ,  but  not  contain  inside  tags  (  so  not  a  data  tag?  )  dataNode  =  TextNode  .  createFromEncoded  (  data  ,  baseUri  )  ;  else  dataNode  =  new  DataNode  (  data  ,  baseUri  )  ;  //  data  not  encoded  but  raw  (  for   "  in  script  )  child  .  appendChild  (  dataNode  )  ;  }    if  (  child  .  tagName  (  )  .  equals  (   "base "  )  )  {  String  href  =  child  .  absUrl  (   "href "  )  ;  if  (  href  .  length  (  )  !  =  0  )  {  //  ignore  <base  target>  etc  [ATTENTION]  baseUri  =  html  ;  doc  .  setBaseUri  (  href  )  ;  //  set  on  the  doc  so  doc  .  createElement  (  Tag  )  will  get  updated  base  }  }  addChildToParent  (  child  ,  isEmptyElement  )  ;  }    [METHOD]  parseStartTag  [TYPE]  void  [PARAMETER]  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  isEmptyElement  true  [TYPE]  Attribute  attribute  [TYPE]  Element  child  [TYPE]  Node  dataNode  [TYPE]  Attributes  attributes  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  href  html  tagName  [TYPE]  Tag  bodyTag  headTag  htmlTag  tag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[REPLACE]  String  href  =  child  .  absUrl  (   "href "  )  ;	[BUGGY]  String  href  =  child  .  appendChild  (   "href "  )  ;  [CE]  method  appendChild  in  class  Element  cannot  be  applied  to  given  types  ;  [CONTEXT]  private  void  parseStartTag  (  )  {  tq  .  consume  (   "< "  )  ;  String  tagName  =  tq  .  consumeWord  (  )  ;    if  (  tagName  .  length  (  )    =  =  0  )  {  //  doesn't  look  like  a  start  tag  after  all  ;  put  <  back  on  stack  and  handle  as  text  tq  .  addFirst  (   "&lt  ;   "  )  ;  parseTextNode  (  )  ;  return  ;  }  Attributes  attributes  =  new  Attributes  (  )  ;  while  (  !tq  .  matchesAny  (   "< "  ,   "/> "  ,   "> "  )  &&  !tq  .  isEmpty  (  )  )  {  Attribute  attribute  =  parseAttribute  (  )  ;  if  (  attribute  !  =  null  )  attributes  .  put  (  attribute  )  ;  }  Tag  tag  =  Tag  .  valueOf  (  tagName  )  ;  Element  child  =  new  Element  (  tag  ,  baseUri  ,  attributes  )  ;    boolean  isEmptyElement  =  tag  .  isEmpty  (  )  ;  //  empty  element  if  empty  tag  (  e  .  g  .  img  )  or  self-closed  el  (  <div/>  if  (  tq  .  matchChomp  (   "/> "  )  )  {  //  close  empty  element  or  tag  isEmptyElement  =  true  ;  }  else  {  tq  .  matchChomp  (   "> "  )  ;  }    if  (  tag  .  isData  (  )  )  {  String  data  =  tq  .  chompTo  (   "</ "  +  tagName  )  ;  tq  .  chompTo  (   "> "  )  ;    Node  dataNode  ;  if  (  tag  .  equals  (  titleTag  )  ||  tag  .  equals  (  textareaTag  )  )  //  want  to  show  as  text  ,  but  not  contain  inside  tags  (  so  not  a  data  tag?  )  dataNode  =  TextNode  .  createFromEncoded  (  data  ,  baseUri  )  ;  else  dataNode  =  new  DataNode  (  data  ,  baseUri  )  ;  //  data  not  encoded  but  raw  (  for   "  in  script  )  child  .  appendChild  (  dataNode  )  ;  }    if  (  child  .  tagName  (  )  .  equals  (   "base "  )  )  {  [ATTENTION]  String  href  =  child  .  appendChild  (   "href "  )    ;  if  (  href  .  length  (  )  !  =  0  )  {  //  ignore  <base  target>  etc  baseUri  =  href  ;  doc  .  setBaseUri  (  href  )  ;  //  set  on  the  doc  so  doc  .  createElement  (  Tag  )  will  get  updated  base  }  }  addChildToParent  (  child  ,  isEmptyElement  )  ;  }    [METHOD]  parseStartTag  [TYPE]  void  [PARAMETER]  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  isEmptyElement  true  [TYPE]  Attribute  attribute  [TYPE]  Element  child  [TYPE]  Node  dataNode  [TYPE]  Attributes  attributes  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  href  html  tagName  [TYPE]  Tag  bodyTag  headTag  htmlTag  tag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[ADD]  String  href  =  child  .  absUrl  (   "href "  )  ;	[BUGGY]  [CE]  cannot  find  symbol  href  [CONTEXT]  private  void  parseStartTag  (  )  {  tq  .  consume  (   "< "  )  ;  String  tagName  =  tq  .  consumeWord  (  )  ;    if  (  tagName  .  length  (  )    =  =  0  )  {  //  doesn't  look  like  a  start  tag  after  all  ;  put  <  back  on  stack  and  handle  as  text  tq  .  addFirst  (   "&lt  ;   "  )  ;  parseTextNode  (  )  ;  return  ;  }  Attributes  attributes  =  new  Attributes  (  )  ;  while  (  !tq  .  matchesAny  (   "< "  ,   "/> "  ,   "> "  )  &&  !tq  .  isEmpty  (  )  )  {  Attribute  attribute  =  parseAttribute  (  )  ;  if  (  attribute  !  =  null  )  attributes  .  put  (  attribute  )  ;  }  Tag  tag  =  Tag  .  valueOf  (  tagName  )  ;  Element  child  =  new  Element  (  tag  ,  baseUri  ,  attributes  )  ;    boolean  isEmptyElement  =  tag  .  isEmpty  (  )  ;  //  empty  element  if  empty  tag  (  e  .  g  .  img  )  or  self-closed  el  (  <div/>  if  (  tq  .  matchChomp  (   "/> "  )  )  {  //  close  empty  element  or  tag  isEmptyElement  =  true  ;  }  else  {  tq  .  matchChomp  (   "> "  )  ;  }    if  (  tag  .  isData  (  )  )  {  String  data  =  tq  .  chompTo  (   "</ "  +  tagName  )  ;  tq  .  chompTo  (   "> "  )  ;    Node  dataNode  ;  if  (  tag  .  equals  (  titleTag  )  ||  tag  .  equals  (  textareaTag  )  )  //  want  to  show  as  text  ,  but  not  contain  inside  tags  (  so  not  a  data  tag?  )  dataNode  =  TextNode  .  createFromEncoded  (  data  ,  baseUri  )  ;  else  dataNode  =  new  DataNode  (  data  ,  baseUri  )  ;  //  data  not  encoded  but  raw  (  for   "  in  script  )  child  .  appendChild  (  dataNode  )  ;  }    if  (  child  .  tagName  (  )  .  equals  (   "base "  )  )  {  [ATTENTION]  if  (  href  .  length  (  )  !  =  0  )  {  //  ignore  <base  target>  etc  baseUri  =  href  ;  doc  .  setBaseUri  (  href  )  ;  //  set  on  the  doc  so  doc  .  createElement  (  Tag  )  will  get  updated  base  }  }  addChildToParent  (  child  ,  isEmptyElement  )  ;  }    [METHOD]  parseStartTag  [TYPE]  void  [PARAMETER]  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  isEmptyElement  true  [TYPE]  Attribute  attribute  [TYPE]  Element  child  [TYPE]  Node  dataNode  [TYPE]  Attributes  attributes  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  href  html  tagName  [TYPE]  Tag  bodyTag  headTag  htmlTag  tag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[REPLACE]  if  (  href  .  length  (  )  !=  0  )  {	[BUGGY]  if  (  href  .  equals  (  )  +  1  !  =  0  )  {[CE]  no  suitable  method  found  for  equals()  [CONTEXT]  private  void  parseStartTag  (  )  {  tq  .  consume  (   "< "  )  ;  String  tagName  =  tq  .  consumeWord  (  )  ;    if  (  tagName  .  length  (  )    =  =  0  )  {  //  doesn't  look  like  a  start  tag  after  all  ;  put  <  back  on  stack  and  handle  as  text  tq  .  addFirst  (   "&lt  ;   "  )  ;  parseTextNode  (  )  ;  return  ;  }  Attributes  attributes  =  new  Attributes  (  )  ;  while  (  !tq  .  matchesAny  (   "< "  ,   "/> "  ,   "> "  )  &&  !tq  .  isEmpty  (  )  )  {  Attribute  attribute  =  parseAttribute  (  )  ;  if  (  attribute  !  =  null  )  attributes  .  put  (  attribute  )  ;  }  Tag  tag  =  Tag  .  valueOf  (  tagName  )  ;  Element  child  =  new  Element  (  tag  ,  baseUri  ,  attributes  )  ;    boolean  isEmptyElement  =  tag  .  isEmpty  (  )  ;  //  empty  element  if  empty  tag  (  e  .  g  .  img  )  or  self-closed  el  (  <div/>  if  (  tq  .  matchChomp  (   "/> "  )  )  {  //  close  empty  element  or  tag  isEmptyElement  =  true  ;  }  else  {  tq  .  matchChomp  (   "> "  )  ;  }    if  (  tag  .  isData  (  )  )  {  String  data  =  tq  .  chompTo  (   "</ "  +  tagName  )  ;  tq  .  chompTo  (   "> "  )  ;    Node  dataNode  ;  if  (  tag  .  equals  (  titleTag  )  ||  tag  .  equals  (  textareaTag  )  )  //  want  to  show  as  text  ,  but  not  contain  inside  tags  (  so  not  a  data  tag?  )  dataNode  =  TextNode  .  createFromEncoded  (  data  ,  baseUri  )  ;  else  dataNode  =  new  DataNode  (  data  ,  baseUri  )  ;  //  data  not  encoded  but  raw  (  for   "  in  script  )  child  .  appendChild  (  dataNode  )  ;  }    if  (  child  .  tagName  (  )  .  equals  (   "base "  )  )  {  String  href  =  child  .  absUrl  (   "href "  )  ;  [ATTENTION]  if  (  href  .  equals  (  )  +  1  !  =  0  )  {  baseUri  =  href  ;  doc  .  setBaseUri  (  href  )  ;  //  set  on  the  doc  so  doc  .  createElement  (  Tag  )  will  get  updated  base  }  }  addChildToParent  (  child  ,  isEmptyElement  )  ;  }    [METHOD]  parseStartTag  [TYPE]  void  [PARAMETER]  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  isEmptyElement  true  [TYPE]  Attribute  attribute  [TYPE]  Element  child  [TYPE]  Node  dataNode  [TYPE]  Attributes  attributes  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  href  html  tagName  [TYPE]  Tag  bodyTag  headTag  htmlTag  tag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[REPLACE]  baseUri  =  href;	[BUGGY]  baseUri  =    null  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  private  void  parseStartTag  (  )  {  tq  .  consume  (   "< "  )  ;  String  tagName  =  tq  .  consumeWord  (  )  ;    if  (  tagName  .  length  (  )    =  =  0  )  {  //  doesn't  look  like  a  start  tag  after  all  ;  put  <  back  on  stack  and  handle  as  text  tq  .  addFirst  (   "&lt  ;   "  )  ;  parseTextNode  (  )  ;  return  ;  }  Attributes  attributes  =  new  Attributes  (  )  ;  while  (  !tq  .  matchesAny  (   "< "  ,   "/> "  ,   "> "  )  &&  !tq  .  isEmpty  (  )  )  {  Attribute  attribute  =  parseAttribute  (  )  ;  if  (  attribute  !  =  null  )  attributes  .  put  (  attribute  )  ;  }  Tag  tag  =  Tag  .  valueOf  (  tagName  )  ;  Element  child  =  new  Element  (  tag  ,  baseUri  ,  attributes  )  ;    boolean  isEmptyElement  =  tag  .  isEmpty  (  )  ;  //  empty  element  if  empty  tag  (  e  .  g  .  img  )  or  self-closed  el  (  <div/>  if  (  tq  .  matchChomp  (   "/> "  )  )  {  //  close  empty  element  or  tag  isEmptyElement  =  true  ;  }  else  {  tq  .  matchChomp  (   "> "  )  ;  }    if  (  tag  .  isData  (  )  )  {  String  data  =  tq  .  chompTo  (   "</ "  +  tagName  )  ;  tq  .  chompTo  (   "> "  )  ;    Node  dataNode  ;  if  (  tag  .  equals  (  titleTag  )  ||  tag  .  equals  (  textareaTag  )  )  //  want  to  show  as  text  ,  but  not  contain  inside  tags  (  so  not  a  data  tag?  )  dataNode  =  TextNode  .  createFromEncoded  (  data  ,  baseUri  )  ;  else  dataNode  =  new  DataNode  (  data  ,  baseUri  )  ;  //  data  not  encoded  but  raw  (  for   "  in  script  )  child  .  appendChild  (  dataNode  )  ;  }    if  (  child  .  tagName  (  )  .  equals  (   "base "  )  )  {  String  href  =  child  .  absUrl  (   "href "  )  ;  if  (  href  .  length  (  )  !  =  0  )  {  //  ignore  <base  target>  etc  [ATTENTION]  baseUri  =  null  ;  doc  .  setBaseUri  (  href  )  ;  //  set  on  the  doc  so  doc  .  createElement  (  Tag  )  will  get  updated  base  }  }  addChildToParent  (  child  ,  isEmptyElement  )  ;  }    [METHOD]  parseStartTag  [TYPE]  void  [PARAMETER]  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  isEmptyElement  true  [TYPE]  Attribute  attribute  [TYPE]  Element  child  [TYPE]  Node  dataNode  [TYPE]  Attributes  attributes  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  href  html  tagName  [TYPE]  Tag  bodyTag  headTag  htmlTag  tag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[REPLACE]  addChildToParent  (  child,  isEmptyElement  )  ;	[BUGGY]  if  (  parent2  .  isValidParent  (  childTag  )  )  {  return  true  ;  [CE]  illegal  start  of  expression  [CONTEXT]  private  void  parseStartTag  (  )  {  tq  .  consume  (   "< "  )  ;  String  tagName  =  tq  .  consumeWord  (  )  ;    if  (  tagName  .  length  (  )    =  =  0  )  {  //  doesn't  look  like  a  start  tag  after  all  ;  put  <  back  on  stack  and  handle  as  text  tq  .  addFirst  (   "&lt  ;   "  )  ;  parseTextNode  (  )  ;  return  ;  }  Attributes  attributes  =  new  Attributes  (  )  ;  while  (  !tq  .  matchesAny  (   "< "  ,   "/> "  ,   "> "  )  &&  !tq  .  isEmpty  (  )  )  {  Attribute  attribute  =  parseAttribute  (  )  ;  if  (  attribute  !  =  null  )  attributes  .  put  (  attribute  )  ;  }  Tag  tag  =  Tag  .  valueOf  (  tagName  )  ;  Element  child  =  new  Element  (  tag  ,  baseUri  ,  attributes  )  ;    boolean  isEmptyElement  =  tag  .  isEmpty  (  )  ;  //  empty  element  if  empty  tag  (  e  .  g  .  img  )  or  self-closed  el  (  <div/>  if  (  tq  .  matchChomp  (   "/> "  )  )  {  //  close  empty  element  or  tag  isEmptyElement  =  true  ;  }  else  {  tq  .  matchChomp  (   "> "  )  ;  }    if  (  tag  .  isData  (  )  )  {  String  data  =  tq  .  chompTo  (   "</ "  +  tagName  )  ;  tq  .  chompTo  (   "> "  )  ;    Node  dataNode  ;  if  (  tag  .  equals  (  titleTag  )  ||  tag  .  equals  (  textareaTag  )  )  //  want  to  show  as  text  ,  but  not  contain  inside  tags  (  so  not  a  data  tag?  )  dataNode  =  TextNode  .  createFromEncoded  (  data  ,  baseUri  )  ;  else  dataNode  =  new  DataNode  (  data  ,  baseUri  )  ;  //  data  not  encoded  but  raw  (  for   "  in  script  )  child  .  appendChild  (  dataNode  )  ;  }    if  (  child  .  tagName  (  )  .  equals  (   "base "  )  )  {  String  href  =  child  .  absUrl  (   "href "  )  ;  if  (  href  .  length  (  )  !  =  0  )  {  //  ignore  <base  target>  etc  baseUri  =  href  ;  doc  .  setBaseUri  (  href  )  ;  //  set  on  the  doc  so  doc  .  createElement  (  Tag  )  will  get  updated  base  }  }  [ATTENTION]  if  (  parent2  .  isValidParent  (  childTag  )  )  {  return  true  ;  }    [METHOD]  parseStartTag  [TYPE]  void  [PARAMETER]  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  isEmptyElement  true  [TYPE]  Attribute  attribute  [TYPE]  Element  child  [TYPE]  Node  dataNode  [TYPE]  Attributes  attributes  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  href  html  tagName  [TYPE]  Tag  bodyTag  headTag  htmlTag  tag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[REPLACE]  tq  .  consumeWhitespace  (  )  ;	[BUGGY]  tq  .  matchesWhitespace  (  )    ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  private  Attribute  parseAttribute  (  )  {  [ATTENTION]  tq  .  matchesWhitespace  (  )  ;  String  key  =  tq  .  consumeAttributeKey  (  )  ;  String  value  =   " "  ;  tq  .  consumeWhitespace  (  )  ;  if  (  tq  .  matchChomp  (   "  =   "  )  )  {  tq  .  consumeWhitespace  (  )  ;    if  (  tq  .  matchChomp  (  SQ  )  )  {  value  =  tq  .  chompTo  (  SQ  )  ;  }  else  if  (  tq  .  matchChomp  (  DQ  )  )  {  value  =  tq  .  chompTo  (  DQ  )  ;  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder  (  )  ;    while  (  !tq  .  matchesAny  (   "< "  ,   "/> "  ,   "> "  )  &&  !tq  .  matchesWhitespace  (  )  &&  !tq  .  isEmpty  (  )  )  {  valueAccum  .  append  (  tq  .  consume  (  )  )  ;  }  value  =  valueAccum  .  toString  (  )  ;  }  tq  .  consumeWhitespace  (  )  ;  }  if  (  key  .  length  (  )  !  =  0  )  return  Attribute  .  createFromEncoded  (  key  ,  value  )  ;  else  {  tq  .  consume  (  )  ;  //  unknown  char  ,  keep  popping  so  not  get  stuck  return  null  ;  }  }    [METHOD]  parseAttribute  [TYPE]  Attribute  [PARAMETER]  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  StringBuilder  valueAccum  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  href  html  key  tagName  value  [TYPE]  Tag  bodyTag  headTag  htmlTag  tag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[ADD]  tq  .  consumeWhitespace  (  )  ;	[BUGGY]  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  private  Attribute  parseAttribute  (  )  {  [ATTENTION]  String  key  =  tq  .  consumeAttributeKey  (  )  ;  String  value  =   " "  ;  tq  .  consumeWhitespace  (  )  ;  if  (  tq  .  matchChomp  (   "  =   "  )  )  {  tq  .  consumeWhitespace  (  )  ;    if  (  tq  .  matchChomp  (  SQ  )  )  {  value  =  tq  .  chompTo  (  SQ  )  ;  }  else  if  (  tq  .  matchChomp  (  DQ  )  )  {  value  =  tq  .  chompTo  (  DQ  )  ;  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder  (  )  ;    while  (  !tq  .  matchesAny  (   "< "  ,   "/> "  ,   "> "  )  &&  !tq  .  matchesWhitespace  (  )  &&  !tq  .  isEmpty  (  )  )  {  valueAccum  .  append  (  tq  .  consume  (  )  )  ;  }  value  =  valueAccum  .  toString  (  )  ;  }  tq  .  consumeWhitespace  (  )  ;  }  if  (  key  .  length  (  )  !  =  0  )  return  Attribute  .  createFromEncoded  (  key  ,  value  )  ;  else  {  tq  .  consume  (  )  ;  //  unknown  char  ,  keep  popping  so  not  get  stuck  return  null  ;  }  }    [METHOD]  parseAttribute  [TYPE]  Attribute  [PARAMETER]  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  StringBuilder  valueAccum  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  href  html  key  tagName  value  [TYPE]  Tag  bodyTag  headTag  htmlTag  tag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[REPLACE]  String  key  =  tq  .  consumeAttributeKey  (  )  ;	[BUGGY]  String  key  =  tq  .  consumeWord  (  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  private  Attribute  parseAttribute  (  )  {  tq  .  consumeWhitespace  (  )  ;  [ATTENTION]  String  key  =  tq  .  consumeWord  (  )    ;  String  value  =   " "  ;  tq  .  consumeWhitespace  (  )  ;  if  (  tq  .  matchChomp  (   "  =   "  )  )  {  tq  .  consumeWhitespace  (  )  ;    if  (  tq  .  matchChomp  (  SQ  )  )  {  value  =  tq  .  chompTo  (  SQ  )  ;  }  else  if  (  tq  .  matchChomp  (  DQ  )  )  {  value  =  tq  .  chompTo  (  DQ  )  ;  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder  (  )  ;    while  (  !tq  .  matchesAny  (   "< "  ,   "/> "  ,   "> "  )  &&  !tq  .  matchesWhitespace  (  )  &&  !tq  .  isEmpty  (  )  )  {  valueAccum  .  append  (  tq  .  consume  (  )  )  ;  }  value  =  valueAccum  .  toString  (  )  ;  }  tq  .  consumeWhitespace  (  )  ;  }  if  (  key  .  length  (  )  !  =  0  )  return  Attribute  .  createFromEncoded  (  key  ,  value  )  ;  else  {  tq  .  consume  (  )  ;  //  unknown  char  ,  keep  popping  so  not  get  stuck  return  null  ;  }  }    [METHOD]  parseAttribute  [TYPE]  Attribute  [PARAMETER]  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  StringBuilder  valueAccum  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  href  html  key  tagName  value  [TYPE]  Tag  bodyTag  headTag  htmlTag  tag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[REPLACE]  String  value  =   " ";	[BUGGY]  String  href  =  child  .  absUrl  (   "href "  )  ;  [CE]  cannot  find  symbol  child  [CONTEXT]  private  Attribute  parseAttribute  (  )  {  tq  .  consumeWhitespace  (  )  ;  String  key  =  tq  .  consumeAttributeKey  (  )  ;  [ATTENTION]  String  href  =  child  .  absUrl  (   "href "  )    ;  tq  .  consumeWhitespace  (  )  ;  if  (  tq  .  matchChomp  (   "  =   "  )  )  {  tq  .  consumeWhitespace  (  )  ;    if  (  tq  .  matchChomp  (  SQ  )  )  {  value  =  tq  .  chompTo  (  SQ  )  ;  }  else  if  (  tq  .  matchChomp  (  DQ  )  )  {  value  =  tq  .  chompTo  (  DQ  )  ;  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder  (  )  ;    while  (  !tq  .  matchesAny  (   "< "  ,   "/> "  ,   "> "  )  &&  !tq  .  matchesWhitespace  (  )  &&  !tq  .  isEmpty  (  )  )  {  valueAccum  .  append  (  tq  .  consume  (  )  )  ;  }  value  =  valueAccum  .  toString  (  )  ;  }  tq  .  consumeWhitespace  (  )  ;  }  if  (  key  .  length  (  )  !  =  0  )  return  Attribute  .  createFromEncoded  (  key  ,  value  )  ;  else  {  tq  .  consume  (  )  ;  //  unknown  char  ,  keep  popping  so  not  get  stuck  return  null  ;  }  }    [METHOD]  parseAttribute  [TYPE]  Attribute  [PARAMETER]  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  StringBuilder  valueAccum  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  href  html  key  tagName  value  [TYPE]  Tag  bodyTag  headTag  htmlTag  tag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[REPLACE]  tq  .  consumeWhitespace  (  )  ;	[BUGGY]  tq  .  matchesWhitespace  (  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  private  Attribute  parseAttribute  (  )  {  tq  .  consumeWhitespace  (  )  ;  String  key  =  tq  .  consumeAttributeKey  (  )  ;  String  value  =   " "  ;  [ATTENTION]  tq  .  matchesWhitespace  (  )    ;  if  (  tq  .  matchChomp  (   "  =   "  )  )  {  tq  .  consumeWhitespace  (  )  ;    if  (  tq  .  matchChomp  (  SQ  )  )  {  value  =  tq  .  chompTo  (  SQ  )  ;  }  else  if  (  tq  .  matchChomp  (  DQ  )  )  {  value  =  tq  .  chompTo  (  DQ  )  ;  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder  (  )  ;    while  (  !tq  .  matchesAny  (   "< "  ,   "/> "  ,   "> "  )  &&  !tq  .  matchesWhitespace  (  )  &&  !tq  .  isEmpty  (  )  )  {  valueAccum  .  append  (  tq  .  consume  (  )  )  ;  }  value  =  valueAccum  .  toString  (  )  ;  }  tq  .  consumeWhitespace  (  )  ;  }  if  (  key  .  length  (  )  !  =  0  )  return  Attribute  .  createFromEncoded  (  key  ,  value  )  ;  else  {  tq  .  consume  (  )  ;  //  unknown  char  ,  keep  popping  so  not  get  stuck  return  null  ;  }  }    [METHOD]  parseAttribute  [TYPE]  Attribute  [PARAMETER]  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  StringBuilder  valueAccum  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  href  html  key  tagName  value  [TYPE]  Tag  bodyTag  headTag  htmlTag  tag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[REPLACE]  while  (  !tq  .  matchesAny  (   "< ",   "/> ",   "> "  )  &&  !tq  .  matchesWhitespace  (  )  &&  !tq  .  isEmpty  (  )  )  {	[BUGGY]  while  (  tq  .  matchesAny  (   "< "  ,   "/> "  ,   "> "  )    |  !tq  .  matchesWhitespace  (  )    |  !tq  .  isEmpty  (  )  )  {[FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  private  Attribute  parseAttribute  (  )  {  tq  .  consumeWhitespace  (  )  ;  String  key  =  tq  .  consumeAttributeKey  (  )  ;  String  value  =   " "  ;  tq  .  consumeWhitespace  (  )  ;  if  (  tq  .  matchChomp  (   "  =   "  )  )  {  tq  .  consumeWhitespace  (  )  ;    if  (  tq  .  matchChomp  (  SQ  )  )  {  value  =  tq  .  chompTo  (  SQ  )  ;  }  else  if  (  tq  .  matchChomp  (  DQ  )  )  {  value  =  tq  .  chompTo  (  DQ  )  ;  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder  (  )  ;    [ATTENTION]  while  (  tq  .  matchesAny  (   "< "  ,   "/> "  ,   "> "  )  |!tq  .  matchesWhitespace  (  )  |!tq  .  isEmpty  (  )  )  {  valueAccum  .  append  (  tq  .  consume  (  )  )  ;  }  value  =  valueAccum  .  toString  (  )  ;  }  tq  .  consumeWhitespace  (  )  ;  }  if  (  key  .  length  (  )  !  =  0  )  return  Attribute  .  createFromEncoded  (  key  ,  value  )  ;  else  {  tq  .  consume  (  )  ;  //  unknown  char  ,  keep  popping  so  not  get  stuck  return  null  ;  }  }    [METHOD]  parseAttribute  [TYPE]  Attribute  [PARAMETER]  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  StringBuilder  valueAccum  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  href  html  key  tagName  value  [TYPE]  Tag  bodyTag  headTag  htmlTag  tag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[ADD]  while  (  !tq  .  matchesAny  (   "< ",   "/> ",   "> "  )  &&  !tq  .  matchesWhitespace  (  )  &&  !tq  .  isEmpty  (  )  )  {  valueAccum  .  append  (  tq  .  consume  (  )  )  ;	[BUGGY]  [CE]  illegal  start  of  type  [CONTEXT]  private  Attribute  parseAttribute  (  )  {  tq  .  consumeWhitespace  (  )  ;  String  key  =  tq  .  consumeAttributeKey  (  )  ;  String  value  =   " "  ;  tq  .  consumeWhitespace  (  )  ;  if  (  tq  .  matchChomp  (   "  =   "  )  )  {  tq  .  consumeWhitespace  (  )  ;    if  (  tq  .  matchChomp  (  SQ  )  )  {  value  =  tq  .  chompTo  (  SQ  )  ;  }  else  if  (  tq  .  matchChomp  (  DQ  )  )  {  value  =  tq  .  chompTo  (  DQ  )  ;  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder  (  )  ;    [ATTENTION]    }  value  =  valueAccum  .  toString  (  )  ;  }  tq  .  consumeWhitespace  (  )  ;  }  if  (  key  .  length  (  )  !  =  0  )  return  Attribute  .  createFromEncoded  (  key  ,  value  )  ;  else  {  tq  .  consume  (  )  ;  //  unknown  char  ,  keep  popping  so  not  get  stuck  return  null  ;  }  }    [METHOD]  parseAttribute  [TYPE]  Attribute  [PARAMETER]  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  StringBuilder  valueAccum  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  href  html  key  tagName  value  [TYPE]  Tag  bodyTag  headTag  htmlTag  tag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[REPLACE]  valueAccum  .  append  (  tq  .  consume  (  )  )  ;	[BUGGY]  valueAccum  .  append  (  tq  .  consume  (  baseUri  )    )  ;  [CE]  'void'  type  not  allowed  here  [CONTEXT]  private  Attribute  parseAttribute  (  )  {  tq  .  consumeWhitespace  (  )  ;  String  key  =  tq  .  consumeAttributeKey  (  )  ;  String  value  =   " "  ;  tq  .  consumeWhitespace  (  )  ;  if  (  tq  .  matchChomp  (   "  =   "  )  )  {  tq  .  consumeWhitespace  (  )  ;    if  (  tq  .  matchChomp  (  SQ  )  )  {  value  =  tq  .  chompTo  (  SQ  )  ;  }  else  if  (  tq  .  matchChomp  (  DQ  )  )  {  value  =  tq  .  chompTo  (  DQ  )  ;  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder  (  )  ;    while  (  !tq  .  matchesAny  (   "< "  ,   "/> "  ,   "> "  )  &&  !tq  .  matchesWhitespace  (  )  &&  !tq  .  isEmpty  (  )  )  {  [ATTENTION]  valueAccum  .  append  (  tq  .  consume  (  baseUri  )    )    ;  }  value  =  valueAccum  .  toString  (  )  ;  }  tq  .  consumeWhitespace  (  )  ;  }  if  (  key  .  length  (  )  !  =  0  )  return  Attribute  .  createFromEncoded  (  key  ,  value  )  ;  else  {  tq  .  consume  (  )  ;  //  unknown  char  ,  keep  popping  so  not  get  stuck  return  null  ;  }  }    [METHOD]  parseAttribute  [TYPE]  Attribute  [PARAMETER]  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  StringBuilder  valueAccum  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  href  html  key  tagName  value  [TYPE]  Tag  bodyTag  headTag  htmlTag  tag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[ADD]  valueAccum  .  append  (  tq  .  consume  (  )  )  ;	[BUGGY]  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  private  Attribute  parseAttribute  (  )  {  tq  .  consumeWhitespace  (  )  ;  String  key  =  tq  .  consumeAttributeKey  (  )  ;  String  value  =   " "  ;  tq  .  consumeWhitespace  (  )  ;  if  (  tq  .  matchChomp  (   "  =   "  )  )  {  tq  .  consumeWhitespace  (  )  ;    if  (  tq  .  matchChomp  (  SQ  )  )  {  value  =  tq  .  chompTo  (  SQ  )  ;  }  else  if  (  tq  .  matchChomp  (  DQ  )  )  {  value  =  tq  .  chompTo  (  DQ  )  ;  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder  (  )  ;    while  (  !tq  .  matchesAny  (   "< "  ,   "/> "  ,   "> "  )  &&  !tq  .  matchesWhitespace  (  )  &&  !tq  .  isEmpty  (  )  )  {  [ATTENTION]  }  value  =  valueAccum  .  toString  (  )  ;  }  tq  .  consumeWhitespace  (  )  ;  }  if  (  key  .  length  (  )  !  =  0  )  return  Attribute  .  createFromEncoded  (  key  ,  value  )  ;  else  {  tq  .  consume  (  )  ;  //  unknown  char  ,  keep  popping  so  not  get  stuck  return  null  ;  }  }    [METHOD]  parseAttribute  [TYPE]  Attribute  [PARAMETER]  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  StringBuilder  valueAccum  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  href  html  key  tagName  value  [TYPE]  Tag  bodyTag  headTag  htmlTag  tag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[REPLACE]  valueAccum  .  append  (  tq  .  consume  (  )  )  ;	[BUGGY]  valueAccum  .  append  (  tq  .  consume  (  DQ  )    )  ;  [CE]  'void'  type  not  allowed  here  [CONTEXT]  private  Attribute  parseAttribute  (  )  {  tq  .  consumeWhitespace  (  )  ;  String  key  =  tq  .  consumeAttributeKey  (  )  ;  String  value  =   " "  ;  tq  .  consumeWhitespace  (  )  ;  if  (  tq  .  matchChomp  (   "  =   "  )  )  {  tq  .  consumeWhitespace  (  )  ;    if  (  tq  .  matchChomp  (  SQ  )  )  {  value  =  tq  .  chompTo  (  SQ  )  ;  }  else  if  (  tq  .  matchChomp  (  DQ  )  )  {  value  =  tq  .  chompTo  (  DQ  )  ;  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder  (  )  ;    while  (  !tq  .  matchesAny  (   "< "  ,   "/> "  ,   "> "  )  &&  !tq  .  matchesWhitespace  (  )  &&  !tq  .  isEmpty  (  )  )  {  [ATTENTION]  valueAccum  .  append  (  tq  .  consume  (  DQ  )    )    ;  }  value  =  valueAccum  .  toString  (  )  ;  }  tq  .  consumeWhitespace  (  )  ;  }  if  (  key  .  length  (  )  !  =  0  )  return  Attribute  .  createFromEncoded  (  key  ,  value  )  ;  else  {  tq  .  consume  (  )  ;  //  unknown  char  ,  keep  popping  so  not  get  stuck  return  null  ;  }  }    [METHOD]  parseAttribute  [TYPE]  Attribute  [PARAMETER]  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  StringBuilder  valueAccum  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  href  html  key  tagName  value  [TYPE]  Tag  bodyTag  headTag  htmlTag  tag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[REPLACE]  if  (  tq  .  matchChomp  (   "= "  )  )  {	[BUGGY]  if  (  tq  .  matchChomp  (   "/> "  )  )  {[FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  private  Attribute  parseAttribute  (  )  {  tq  .  consumeWhitespace  (  )  ;  String  key  =  tq  .  consumeAttributeKey  (  )  ;  String  value  =   " "  ;  tq  .  consumeWhitespace  (  )  ;  [ATTENTION]  if  (  tq  .  matchChomp  (   "/> "  )  )  {  tq  .  consumeWhitespace  (  )  ;    if  (  tq  .  matchChomp  (  SQ  )  )  {  value  =  tq  .  chompTo  (  SQ  )  ;  }  else  if  (  tq  .  matchChomp  (  DQ  )  )  {  value  =  tq  .  chompTo  (  DQ  )  ;  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder  (  )  ;    while  (  !tq  .  matchesAny  (   "< "  ,   "/> "  ,   "> "  )  &&  !tq  .  matchesWhitespace  (  )  &&  !tq  .  isEmpty  (  )  )  {  valueAccum  .  append  (  tq  .  consume  (  )  )  ;  }  value  =  valueAccum  .  toString  (  )  ;  }  tq  .  consumeWhitespace  (  )  ;  }  if  (  key  .  length  (  )  !  =  0  )  return  Attribute  .  createFromEncoded  (  key  ,  value  )  ;  else  {  tq  .  consume  (  )  ;  //  unknown  char  ,  keep  popping  so  not  get  stuck  return  null  ;  }  }    [METHOD]  parseAttribute  [TYPE]  Attribute  [PARAMETER]  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  StringBuilder  valueAccum  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  href  html  key  tagName  value  [TYPE]  Tag  bodyTag  headTag  htmlTag  tag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[REMOVE]  	[BUGGY]  if  (  tq  .  matchChomp  (  SQ  )  )  {      value  =  tq  .  chompTo  (  SQ  )  ;  }else      if  (  tq  .  matchChomp  (  DQ  )  )  {          value  =  tq  .  chompTo  (  DQ  )  ;      }else  {          StringBuilder  valueAccum  =  new  StringBuilder  (  )  ;          while  (  (  (  !  (  tq  .  matchesAny  (   "< "  ,   "/> "  ,   "> "  )  )  )  &&  (  !  (  tq  .  matchesWhitespace  (  )  )  )  )  &&  (  !  (  tq  .  isEmpty  (  )  )  )  )  {              valueAccum  .  append  (  tq  .  consume  (  )  )  ;          }          value  =  valueAccum  .  toString  (  )  ;      }[FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  private  Attribute  parseAttribute  (  )  {  tq  .  consumeWhitespace  (  )  ;  String  key  =  tq  .  consumeAttributeKey  (  )  ;  String  value  =   " "  ;  tq  .  consumeWhitespace  (  )  ;  [ATTENTION]  if  (  tq  .  matchChomp  (   "  =   "  )  )  {  if  (  tq  .  matchChomp  (  SQ  )  )  {  value  =  tq  .  chompTo  (  SQ  )    ;  }else  if  (  tq  .  matchChomp  (  DQ  )  )  {  value  =  tq  .  chompTo  (  DQ  )    ;  }else  {  StringBuilder  valueAccum  =  new  StringBuilder  (  )    ;  while  (  (  (  !  (  tq  .  matchesAny  (   "< "  ,   "/> "  ,   "> "  )  )  )  &&  (  !  (  tq  .  matchesWhitespace  (  )  )  )  )  &&  (  !  (  tq  .  isEmpty  (  )  )  )  )  {  valueAccum  .  append  (  tq  .  consume  (  )  )    ;  }value  =  valueAccum  .  toString  (  )    ;  }tq  .  consumeWhitespace  (  )  ;    if  (  tq  .  matchChomp  (  SQ  )  )  {  value  =  tq  .  chompTo  (  SQ  )  ;  }  else  if  (  tq  .  matchChomp  (  DQ  )  )  {  value  =  tq  .  chompTo  (  DQ  )  ;  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder  (  )  ;    while  (  !tq  .  matchesAny  (   "< "  ,   "/> "  ,   "> "  )  &&  !tq  .  matchesWhitespace  (  )  &&  !tq  .  isEmpty  (  )  )  {  valueAccum  .  append  (  tq  .  consume  (  )  )  ;  }  value  =  valueAccum  .  toString  (  )  ;  }  tq  .  consumeWhitespace  (  )  ;  }  if  (  key  .  length  (  )  !  =  0  )  return  Attribute  .  createFromEncoded  (  key  ,  value  )  ;  else  {  tq  .  consume  (  )  ;  //  unknown  char  ,  keep  popping  so  not  get  stuck  return  null  ;  }    [METHOD]  parseAttribute  [TYPE]  Attribute  [PARAMETER]  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  StringBuilder  valueAccum  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  href  html  key  tagName  value  [TYPE]  Tag  bodyTag  headTag  htmlTag  tag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[REPLACE]  while  (  !tq  .  matchesAny  (   "< ",   "/> ",   "> "  )  &&  !tq  .  matchesWhitespace  (  )  &&  !tq  .  isEmpty  (  )  )  {	[BUGGY]  while  (  !tq  .  matchesAny  (   "< "  ,   "/> "  ,   "> "  )    ;  [CE]  [CONTEXT]  private  Attribute  parseAttribute  (  )  {  tq  .  consumeWhitespace  (  )  ;  String  key  =  tq  .  consumeAttributeKey  (  )  ;  String  value  =   " "  ;  tq  .  consumeWhitespace  (  )  ;  if  (  tq  .  matchChomp  (   "  =   "  )  )  {  tq  .  consumeWhitespace  (  )  ;    if  (  tq  .  matchChomp  (  SQ  )  )  {  value  =  tq  .  chompTo  (  SQ  )  ;  }  else  if  (  tq  .  matchChomp  (  DQ  )  )  {  value  =  tq  .  chompTo  (  DQ  )  ;  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder  (  )  ;    [ATTENTION]  while  (  !tq  .  matchesAny  (   "< "  ,   "/> "  ,   "> "  )  ;  valueAccum  .  append  (  tq  .  consume  (  )  )  ;  }  value  =  valueAccum  .  toString  (  )  ;  }  tq  .  consumeWhitespace  (  )  ;  }  if  (  key  .  length  (  )  !  =  0  )  return  Attribute  .  createFromEncoded  (  key  ,  value  )  ;  else  {  tq  .  consume  (  )  ;  //  unknown  char  ,  keep  popping  so  not  get  stuck  return  null  ;  }  }    [METHOD]  parseAttribute  [TYPE]  Attribute  [PARAMETER]  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  StringBuilder  valueAccum  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  href  html  key  tagName  value  [TYPE]  Tag  bodyTag  headTag  htmlTag  tag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[REPLACE]  valueAccum  .  append  (  tq  .  consume  (  )  )  ;	[BUGGY]  valueAccum  .  append  (  tq  .  consumeWord  (  )  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  private  Attribute  parseAttribute  (  )  {  tq  .  consumeWhitespace  (  )  ;  String  key  =  tq  .  consumeAttributeKey  (  )  ;  String  value  =   " "  ;  tq  .  consumeWhitespace  (  )  ;  if  (  tq  .  matchChomp  (   "  =   "  )  )  {  tq  .  consumeWhitespace  (  )  ;    if  (  tq  .  matchChomp  (  SQ  )  )  {  value  =  tq  .  chompTo  (  SQ  )  ;  }  else  if  (  tq  .  matchChomp  (  DQ  )  )  {  value  =  tq  .  chompTo  (  DQ  )  ;  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder  (  )  ;    while  (  !tq  .  matchesAny  (   "< "  ,   "/> "  ,   "> "  )  &&  !tq  .  matchesWhitespace  (  )  &&  !tq  .  isEmpty  (  )  )  {  [ATTENTION]  valueAccum  .  append  (  tq  .  consumeWord  (  )  )    ;  }  value  =  valueAccum  .  toString  (  )  ;  }  tq  .  consumeWhitespace  (  )  ;  }  if  (  key  .  length  (  )  !  =  0  )  return  Attribute  .  createFromEncoded  (  key  ,  value  )  ;  else  {  tq  .  consume  (  )  ;  //  unknown  char  ,  keep  popping  so  not  get  stuck  return  null  ;  }  }    [METHOD]  parseAttribute  [TYPE]  Attribute  [PARAMETER]  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  StringBuilder  valueAccum  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  href  html  key  tagName  value  [TYPE]  Tag  bodyTag  headTag  htmlTag  tag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[REPLACE]  valueAccum  .  append  (  tq  .  consume  (  )  )  ;	[BUGGY]  valueAccum  .  append  (  tq  .  consume  (  data  )    )  ;  [CE]  cannot  find  symbol  data  [CONTEXT]  private  Attribute  parseAttribute  (  )  {  tq  .  consumeWhitespace  (  )  ;  String  key  =  tq  .  consumeAttributeKey  (  )  ;  String  value  =   " "  ;  tq  .  consumeWhitespace  (  )  ;  if  (  tq  .  matchChomp  (   "  =   "  )  )  {  tq  .  consumeWhitespace  (  )  ;    if  (  tq  .  matchChomp  (  SQ  )  )  {  value  =  tq  .  chompTo  (  SQ  )  ;  }  else  if  (  tq  .  matchChomp  (  DQ  )  )  {  value  =  tq  .  chompTo  (  DQ  )  ;  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder  (  )  ;    while  (  !tq  .  matchesAny  (   "< "  ,   "/> "  ,   "> "  )  &&  !tq  .  matchesWhitespace  (  )  &&  !tq  .  isEmpty  (  )  )  {  [ATTENTION]  valueAccum  .  append  (  tq  .  consume  (  data  )    )    ;  }  value  =  valueAccum  .  toString  (  )  ;  }  tq  .  consumeWhitespace  (  )  ;  }  if  (  key  .  length  (  )  !  =  0  )  return  Attribute  .  createFromEncoded  (  key  ,  value  )  ;  else  {  tq  .  consume  (  )  ;  //  unknown  char  ,  keep  popping  so  not  get  stuck  return  null  ;  }  }    [METHOD]  parseAttribute  [TYPE]  Attribute  [PARAMETER]  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  StringBuilder  valueAccum  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  href  html  key  tagName  value  [TYPE]  Tag  bodyTag  headTag  htmlTag  tag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[REPLACE]  if  (  tq  .  matchChomp  (  SQ  )  )  {	[BUGGY]  else  if  (  tq  .  matchChomp  (  DQ  )  )  {[CE]  illegal  start  of  type  [CONTEXT]  private  Attribute  parseAttribute  (  )  {  tq  .  consumeWhitespace  (  )  ;  String  key  =  tq  .  consumeAttributeKey  (  )  ;  String  value  =   " "  ;  tq  .  consumeWhitespace  (  )  ;  if  (  tq  .  matchChomp  (   "  =   "  )  )  {  tq  .  consumeWhitespace  (  )  ;    [ATTENTION]  }  else  if  (  tq  .  matchChomp  (  DQ  )  )  {  value  =  tq  .  chompTo  (  SQ  )  ;  }  else  if  (  tq  .  matchChomp  (  DQ  )  )  {  value  =  tq  .  chompTo  (  DQ  )  ;  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder  (  )  ;    while  (  !tq  .  matchesAny  (   "< "  ,   "/> "  ,   "> "  )  &&  !tq  .  matchesWhitespace  (  )  &&  !tq  .  isEmpty  (  )  )  {  valueAccum  .  append  (  tq  .  consume  (  )  )  ;  }  value  =  valueAccum  .  toString  (  )  ;  }  tq  .  consumeWhitespace  (  )  ;  }  if  (  key  .  length  (  )  !  =  0  )  return  Attribute  .  createFromEncoded  (  key  ,  value  )  ;  else  {  tq  .  consume  (  )  ;  //  unknown  char  ,  keep  popping  so  not  get  stuck  return  null  ;  }  }    [METHOD]  parseAttribute  [TYPE]  Attribute  [PARAMETER]  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  StringBuilder  valueAccum  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  href  html  key  tagName  value  [TYPE]  Tag  bodyTag  headTag  htmlTag  tag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[ADD]  if  (  tq  .  matchChomp  (  SQ  )  )  {  value  =  tq  .  chompTo  (  SQ  )  ;  }  else  if  (  tq  .  matchChomp  (  DQ  )  )  {  value  =  tq  .  chompTo  (  DQ  )  ;	[BUGGY]  [CE]  illegal  start  of  type  [CONTEXT]  private  Attribute  parseAttribute  (  )  {  tq  .  consumeWhitespace  (  )  ;  String  key  =  tq  .  consumeAttributeKey  (  )  ;  String  value  =   " "  ;  tq  .  consumeWhitespace  (  )  ;  if  (  tq  .  matchChomp  (   "  =   "  )  )  {  tq  .  consumeWhitespace  (  )  ;    [ATTENTION]      }  else  {  StringBuilder  valueAccum  =  new  StringBuilder  (  )  ;    while  (  !tq  .  matchesAny  (   "< "  ,   "/> "  ,   "> "  )  &&  !tq  .  matchesWhitespace  (  )  &&  !tq  .  isEmpty  (  )  )  {  valueAccum  .  append  (  tq  .  consume  (  )  )  ;  }  value  =  valueAccum  .  toString  (  )  ;  }  tq  .  consumeWhitespace  (  )  ;  }  if  (  key  .  length  (  )  !  =  0  )  return  Attribute  .  createFromEncoded  (  key  ,  value  )  ;  else  {  tq  .  consume  (  )  ;  //  unknown  char  ,  keep  popping  so  not  get  stuck  return  null  ;  }  }    [METHOD]  parseAttribute  [TYPE]  Attribute  [PARAMETER]  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  StringBuilder  valueAccum  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  href  html  key  tagName  value  [TYPE]  Tag  bodyTag  headTag  htmlTag  tag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[REMOVE]  	[BUGGY]  Validate  .  notNull  (  html  )  ;  [CE]  cannot  find  symbol  html  [CONTEXT]  private  Attribute  parseAttribute  (  )  {  tq  .  consumeWhitespace  (  )  ;  String  key  =  tq  .  consumeAttributeKey  (  )  ;  String  value  =   " "  ;  tq  .  consumeWhitespace  (  )  ;  if  (  tq  .  matchChomp  (   "  =   "  )  )  {  tq  .  consumeWhitespace  (  )  ;    if  (  tq  .  matchChomp  (  SQ  )  )  {  value  =  tq  .  chompTo  (  SQ  )  ;  }  else  if  (  tq  .  matchChomp  (  DQ  )  )  {  value  =  tq  .  chompTo  (  DQ  )  ;  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder  (  )  ;    while  (  !tq  .  matchesAny  (   "< "  ,   "/> "  ,   "> "  )  &&  !tq  .  matchesWhitespace  (  )  &&  !tq  .  isEmpty  (  )  )  {  [ATTENTION]  valueAccum  .  append  (  tq  .  consume  (  )  )  ;    Validate  .  notNull  (  html  )    ;  }  value  =  valueAccum  .  toString  (  )  ;  }  tq  .  consumeWhitespace  (  )  ;  }  if  (  key  .  length  (  )  !  =  0  )  return  Attribute  .  createFromEncoded  (  key  ,  value  )  ;  else  {  tq  .  consume  (  )  ;  //  unknown  char  ,  keep  popping  so  not  get  stuck  return  null  ;  }    [METHOD]  parseAttribute  [TYPE]  Attribute  [PARAMETER]  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  StringBuilder  valueAccum  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  href  html  key  tagName  value  [TYPE]  Tag  bodyTag  headTag  htmlTag  tag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[REPLACE]  }  else  if  (  tq  .  matchChomp  (  DQ  )  )  {	[BUGGY]    else  {[CE]  'else'  without  'if'  [CONTEXT]  private  Attribute  parseAttribute  (  )  {  tq  .  consumeWhitespace  (  )  ;  String  key  =  tq  .  consumeAttributeKey  (  )  ;  String  value  =   " "  ;  tq  .  consumeWhitespace  (  )  ;  if  (  tq  .  matchChomp  (   "  =   "  )  )  {  tq  .  consumeWhitespace  (  )  ;    if  (  tq  .  matchChomp  (  SQ  )  )  {  value  =  tq  .  chompTo  (  SQ  )  ;  [ATTENTION]  }else  {  value  =  tq  .  chompTo  (  DQ  )  ;  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder  (  )  ;    while  (  !tq  .  matchesAny  (   "< "  ,   "/> "  ,   "> "  )  &&  !tq  .  matchesWhitespace  (  )  &&  !tq  .  isEmpty  (  )  )  {  valueAccum  .  append  (  tq  .  consume  (  )  )  ;  }  value  =  valueAccum  .  toString  (  )  ;  }  tq  .  consumeWhitespace  (  )  ;  }  if  (  key  .  length  (  )  !  =  0  )  return  Attribute  .  createFromEncoded  (  key  ,  value  )  ;  else  {  tq  .  consume  (  )  ;  //  unknown  char  ,  keep  popping  so  not  get  stuck  return  null  ;  }  }    [METHOD]  parseAttribute  [TYPE]  Attribute  [PARAMETER]  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  StringBuilder  valueAccum  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  href  html  key  tagName  value  [TYPE]  Tag  bodyTag  headTag  htmlTag  tag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[ADD]  else  if  (  tq  .  matchChomp  (  DQ  )  )  {  value  =  tq  .  chompTo  (  DQ  )  ;  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder  (  )  ;	[BUGGY]    value  =  tq  .  chompTo  (  DQ  )  ;  StringBuilder  valueAccum  =  new  StringBuilder  (  )  ;  [CE]  illegal  start  of  type  [CONTEXT]  private  Attribute  parseAttribute  (  )  {  tq  .  consumeWhitespace  (  )  ;  String  key  =  tq  .  consumeAttributeKey  (  )  ;  String  value  =   " "  ;  tq  .  consumeWhitespace  (  )  ;  if  (  tq  .  matchChomp  (   "  =   "  )  )  {  tq  .  consumeWhitespace  (  )  ;    if  (  tq  .  matchChomp  (  SQ  )  )  {  value  =  tq  .  chompTo  (  SQ  )  ;  [ATTENTION]  }  value  =  tq  .  chompTo  (  DQ  )    ;  StringBuilder  valueAccum  =  new  StringBuilder  (  )    ;        while  (  !tq  .  matchesAny  (   "< "  ,   "/> "  ,   "> "  )  &&  !tq  .  matchesWhitespace  (  )  &&  !tq  .  isEmpty  (  )  )  {  valueAccum  .  append  (  tq  .  consume  (  )  )  ;  }  value  =  valueAccum  .  toString  (  )  ;  }  tq  .  consumeWhitespace  (  )  ;  }  if  (  key  .  length  (  )  !  =  0  )  return  Attribute  .  createFromEncoded  (  key  ,  value  )  ;  else  {  tq  .  consume  (  )  ;  //  unknown  char  ,  keep  popping  so  not  get  stuck  return  null  ;  }  }    [METHOD]  parseAttribute  [TYPE]  Attribute  [PARAMETER]  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  StringBuilder  valueAccum  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  href  html  key  tagName  value  [TYPE]  Tag  bodyTag  headTag  htmlTag  tag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[REPLACE]  while  (  !tq  .  matchesAny  (   "< ",   "/> ",   "> "  )  &&  !tq  .  matchesWhitespace  (  )  &&  !tq  .  isEmpty  (  )  )  {	[BUGGY]  while  (  !tq  .  matchesAny  (   "< "  ,   "/> "  ,   "> "  )    ;  [CE]  [CONTEXT]  }  else  if  (  tq  .  matchChomp  (  DQ  )  )  {  value  =  tq  .  chompTo  (  DQ  )  ;  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder  (  )  ;    [ATTENTION]  while  (  !tq  .  matchesAny  (   "< "  ,   "/> "  ,   "> "  )  ;  valueAccum  .  append  (  tq  .  consume  (  )  )  ;  }  value  =  valueAccum  .  toString  (  )  ;  }    [METHOD]  parseAttribute  [TYPE]  Attribute  [PARAMETER]  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  StringBuilder  valueAccum  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  href  html  key  tagName  value  [TYPE]  Tag  bodyTag  headTag  htmlTag  tag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[ADD]  while  (  !tq  .  matchesAny  (   "< ",   "/> ",   "> "  )  &&  !tq  .  matchesWhitespace  (  )  &&  !tq  .  isEmpty  (  )  )  {  valueAccum  .  append  (  tq  .  consume  (  )  )  ;	[BUGGY]  [CE]  illegal  start  of  type  [CONTEXT]  }  else  if  (  tq  .  matchChomp  (  DQ  )  )  {  value  =  tq  .  chompTo  (  DQ  )  ;  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder  (  )  ;    [ATTENTION]    }  value  =  valueAccum  .  toString  (  )  ;  }    [METHOD]  parseAttribute  [TYPE]  Attribute  [PARAMETER]  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  StringBuilder  valueAccum  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  href  html  key  tagName  value  [TYPE]  Tag  bodyTag  headTag  htmlTag  tag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[REPLACE]  valueAccum  .  append  (  tq  .  consume  (  )  )  ;	[BUGGY]  valueAccum  .  append  (  tq  .  consumeWord  (  )  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  }  else  if  (  tq  .  matchChomp  (  DQ  )  )  {  value  =  tq  .  chompTo  (  DQ  )  ;  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder  (  )  ;    while  (  !tq  .  matchesAny  (   "< "  ,   "/> "  ,   "> "  )  &&  !tq  .  matchesWhitespace  (  )  &&  !tq  .  isEmpty  (  )  )  {  [ATTENTION]  valueAccum  .  append  (  tq  .  consumeWord  (  )  )    ;  }  value  =  valueAccum  .  toString  (  )  ;  }    [METHOD]  parseAttribute  [TYPE]  Attribute  [PARAMETER]  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  StringBuilder  valueAccum  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  href  html  key  tagName  value  [TYPE]  Tag  bodyTag  headTag  htmlTag  tag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[REPLACE]  value  =  valueAccum  .  toString  (  )  ;	[BUGGY]  value  =    null  .  toString  (  )  ;  [CE]  <null>  cannot  be  dereferenced  [CONTEXT]  }  else  if  (  tq  .  matchChomp  (  DQ  )  )  {  value  =  tq  .  chompTo  (  DQ  )  ;  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder  (  )  ;    while  (  !tq  .  matchesAny  (   "< "  ,   "/> "  ,   "> "  )  &&  !tq  .  matchesWhitespace  (  )  &&  !tq  .  isEmpty  (  )  )  {  valueAccum  .  append  (  tq  .  consume  (  )  )  ;  }  [ATTENTION]  value  =  null  .  toString  (  )    ;  }    [METHOD]  parseAttribute  [TYPE]  Attribute  [PARAMETER]  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  StringBuilder  valueAccum  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  href  html  key  tagName  value  [TYPE]  Tag  bodyTag  headTag  htmlTag  tag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[REPLACE]  StringBuilder  valueAccum  =  new  StringBuilder  (  )  ;	[BUGGY]  Attributes  attributes  =  new  Attributes  (  )  ;  [CE]  cannot  find  symbol  valueAccum  [CONTEXT]  }  else  if  (  tq  .  matchChomp  (  DQ  )  )  {  value  =  tq  .  chompTo  (  DQ  )  ;  }  else  {  [ATTENTION]  Attributes  attributes  =  new  Attributes  (  )    ;    while  (  !tq  .  matchesAny  (   "< "  ,   "/> "  ,   "> "  )  &&  !tq  .  matchesWhitespace  (  )  &&  !tq  .  isEmpty  (  )  )  {  valueAccum  .  append  (  tq  .  consume  (  )  )  ;  }  value  =  valueAccum  .  toString  (  )  ;  }    [METHOD]  parseAttribute  [TYPE]  Attribute  [PARAMETER]  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  StringBuilder  valueAccum  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  href  html  key  tagName  value  [TYPE]  Tag  bodyTag  headTag  htmlTag  tag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[REPLACE]  value  =  tq  .  chompTo  (  DQ  )  ;	[BUGGY]  value  =  tq  .  chompTo  (  SQ  )  ;    ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  private  Attribute  parseAttribute  (  )  {  tq  .  consumeWhitespace  (  )  ;  String  key  =  tq  .  consumeAttributeKey  (  )  ;  String  value  =   " "  ;  tq  .  consumeWhitespace  (  )  ;  if  (  tq  .  matchChomp  (   "  =   "  )  )  {  tq  .  consumeWhitespace  (  )  ;    if  (  tq  .  matchChomp  (  SQ  )  )  {  value  =  tq  .  chompTo  (  SQ  )  ;  }  else  if  (  tq  .  matchChomp  (  DQ  )  )  {  [ATTENTION]  value  =  tq  .  chompTo  (  SQ  )    ;    ;  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder  (  )  ;    while  (  !tq  .  matchesAny  (   "< "  ,   "/> "  ,   "> "  )  &&  !tq  .  matchesWhitespace  (  )  &&  !tq  .  isEmpty  (  )  )  {  valueAccum  .  append  (  tq  .  consume  (  )  )  ;  }  value  =  valueAccum  .  toString  (  )  ;  }  tq  .  consumeWhitespace  (  )  ;  }  if  (  key  .  length  (  )  !  =  0  )  return  Attribute  .  createFromEncoded  (  key  ,  value  )  ;  else  {  tq  .  consume  (  )  ;  //  unknown  char  ,  keep  popping  so  not  get  stuck  return  null  ;  }  }    [METHOD]  parseAttribute  [TYPE]  Attribute  [PARAMETER]  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  StringBuilder  valueAccum  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  href  html  key  tagName  value  [TYPE]  Tag  bodyTag  headTag  htmlTag  tag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[ADD]  value  =  tq  .  chompTo  (  DQ  )  ;	[BUGGY]  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  private  Attribute  parseAttribute  (  )  {  tq  .  consumeWhitespace  (  )  ;  String  key  =  tq  .  consumeAttributeKey  (  )  ;  String  value  =   " "  ;  tq  .  consumeWhitespace  (  )  ;  if  (  tq  .  matchChomp  (   "  =   "  )  )  {  tq  .  consumeWhitespace  (  )  ;    if  (  tq  .  matchChomp  (  SQ  )  )  {  value  =  tq  .  chompTo  (  SQ  )  ;  }  else  if  (  tq  .  matchChomp  (  DQ  )  )  {  [ATTENTION]  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder  (  )  ;    while  (  !tq  .  matchesAny  (   "< "  ,   "/> "  ,   "> "  )  &&  !tq  .  matchesWhitespace  (  )  &&  !tq  .  isEmpty  (  )  )  {  valueAccum  .  append  (  tq  .  consume  (  )  )  ;  }  value  =  valueAccum  .  toString  (  )  ;  }  tq  .  consumeWhitespace  (  )  ;  }  if  (  key  .  length  (  )  !  =  0  )  return  Attribute  .  createFromEncoded  (  key  ,  value  )  ;  else  {  tq  .  consume  (  )  ;  //  unknown  char  ,  keep  popping  so  not  get  stuck  return  null  ;  }  }    [METHOD]  parseAttribute  [TYPE]  Attribute  [PARAMETER]  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  StringBuilder  valueAccum  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  href  html  key  tagName  value  [TYPE]  Tag  bodyTag  headTag  htmlTag  tag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[REPLACE]  value  =  valueAccum  .  toString  (  )  ;	[BUGGY]  value  =    null  .  toString  (  )  ;  [CE]  <null>  cannot  be  dereferenced  [CONTEXT]  private  Attribute  parseAttribute  (  )  {  tq  .  consumeWhitespace  (  )  ;  String  key  =  tq  .  consumeAttributeKey  (  )  ;  String  value  =   " "  ;  tq  .  consumeWhitespace  (  )  ;  if  (  tq  .  matchChomp  (   "  =   "  )  )  {  tq  .  consumeWhitespace  (  )  ;    if  (  tq  .  matchChomp  (  SQ  )  )  {  value  =  tq  .  chompTo  (  SQ  )  ;  }  else  if  (  tq  .  matchChomp  (  DQ  )  )  {  value  =  tq  .  chompTo  (  DQ  )  ;  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder  (  )  ;    while  (  !tq  .  matchesAny  (   "< "  ,   "/> "  ,   "> "  )  &&  !tq  .  matchesWhitespace  (  )  &&  !tq  .  isEmpty  (  )  )  {  valueAccum  .  append  (  tq  .  consume  (  )  )  ;  }  [ATTENTION]  value  =  null  .  toString  (  )    ;  }  tq  .  consumeWhitespace  (  )  ;  }  if  (  key  .  length  (  )  !  =  0  )  return  Attribute  .  createFromEncoded  (  key  ,  value  )  ;  else  {  tq  .  consume  (  )  ;  //  unknown  char  ,  keep  popping  so  not  get  stuck  return  null  ;  }  }    [METHOD]  parseAttribute  [TYPE]  Attribute  [PARAMETER]  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  StringBuilder  valueAccum  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  href  html  key  tagName  value  [TYPE]  Tag  bodyTag  headTag  htmlTag  tag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[ADD]  value  =  valueAccum  .  toString  (  )  ;	[BUGGY]  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  private  Attribute  parseAttribute  (  )  {  tq  .  consumeWhitespace  (  )  ;  String  key  =  tq  .  consumeAttributeKey  (  )  ;  String  value  =   " "  ;  tq  .  consumeWhitespace  (  )  ;  if  (  tq  .  matchChomp  (   "  =   "  )  )  {  tq  .  consumeWhitespace  (  )  ;    if  (  tq  .  matchChomp  (  SQ  )  )  {  value  =  tq  .  chompTo  (  SQ  )  ;  }  else  if  (  tq  .  matchChomp  (  DQ  )  )  {  value  =  tq  .  chompTo  (  DQ  )  ;  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder  (  )  ;    while  (  !tq  .  matchesAny  (   "< "  ,   "/> "  ,   "> "  )  &&  !tq  .  matchesWhitespace  (  )  &&  !tq  .  isEmpty  (  )  )  {  valueAccum  .  append  (  tq  .  consume  (  )  )  ;  }  [ATTENTION]  }  tq  .  consumeWhitespace  (  )  ;  }  if  (  key  .  length  (  )  !  =  0  )  return  Attribute  .  createFromEncoded  (  key  ,  value  )  ;  else  {  tq  .  consume  (  )  ;  //  unknown  char  ,  keep  popping  so  not  get  stuck  return  null  ;  }  }    [METHOD]  parseAttribute  [TYPE]  Attribute  [PARAMETER]  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  StringBuilder  valueAccum  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  href  html  key  tagName  value  [TYPE]  Tag  bodyTag  headTag  htmlTag  tag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[REPLACE]  StringBuilder  valueAccum  =  new  StringBuilder  (  )  ;	[BUGGY]  Attributes  attributes  =  new  Attributes  (  )  ;  [CE]  cannot  find  symbol  valueAccum  [CONTEXT]  private  Attribute  parseAttribute  (  )  {  tq  .  consumeWhitespace  (  )  ;  String  key  =  tq  .  consumeAttributeKey  (  )  ;  String  value  =   " "  ;  tq  .  consumeWhitespace  (  )  ;  if  (  tq  .  matchChomp  (   "  =   "  )  )  {  tq  .  consumeWhitespace  (  )  ;    if  (  tq  .  matchChomp  (  SQ  )  )  {  value  =  tq  .  chompTo  (  SQ  )  ;  }  else  if  (  tq  .  matchChomp  (  DQ  )  )  {  value  =  tq  .  chompTo  (  DQ  )  ;  }  else  {  [ATTENTION]  Attributes  attributes  =  new  Attributes  (  )    ;    while  (  !tq  .  matchesAny  (   "< "  ,   "/> "  ,   "> "  )  &&  !tq  .  matchesWhitespace  (  )  &&  !tq  .  isEmpty  (  )  )  {  valueAccum  .  append  (  tq  .  consume  (  )  )  ;  }  value  =  valueAccum  .  toString  (  )  ;  }  tq  .  consumeWhitespace  (  )  ;  }  if  (  key  .  length  (  )  !  =  0  )  return  Attribute  .  createFromEncoded  (  key  ,  value  )  ;  else  {  tq  .  consume  (  )  ;  //  unknown  char  ,  keep  popping  so  not  get  stuck  return  null  ;  }  }    [METHOD]  parseAttribute  [TYPE]  Attribute  [PARAMETER]  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  StringBuilder  valueAccum  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  href  html  key  tagName  value  [TYPE]  Tag  bodyTag  headTag  htmlTag  tag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[REPLACE]  value  =  tq  .  chompTo  (  SQ  )  ;	[BUGGY]  value  =  tq  .  chompTo  (  DQ  )  ;    ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  private  Attribute  parseAttribute  (  )  {  tq  .  consumeWhitespace  (  )  ;  String  key  =  tq  .  consumeAttributeKey  (  )  ;  String  value  =   " "  ;  tq  .  consumeWhitespace  (  )  ;  if  (  tq  .  matchChomp  (   "  =   "  )  )  {  tq  .  consumeWhitespace  (  )  ;    if  (  tq  .  matchChomp  (  SQ  )  )  {  [ATTENTION]  value  =  tq  .  chompTo  (  DQ  )    ;    ;  }  else  if  (  tq  .  matchChomp  (  DQ  )  )  {  value  =  tq  .  chompTo  (  DQ  )  ;  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder  (  )  ;    while  (  !tq  .  matchesAny  (   "< "  ,   "/> "  ,   "> "  )  &&  !tq  .  matchesWhitespace  (  )  &&  !tq  .  isEmpty  (  )  )  {  valueAccum  .  append  (  tq  .  consume  (  )  )  ;  }  value  =  valueAccum  .  toString  (  )  ;  }  tq  .  consumeWhitespace  (  )  ;  }  if  (  key  .  length  (  )  !  =  0  )  return  Attribute  .  createFromEncoded  (  key  ,  value  )  ;  else  {  tq  .  consume  (  )  ;  //  unknown  char  ,  keep  popping  so  not  get  stuck  return  null  ;  }  }    [METHOD]  parseAttribute  [TYPE]  Attribute  [PARAMETER]  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  StringBuilder  valueAccum  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  href  html  key  tagName  value  [TYPE]  Tag  bodyTag  headTag  htmlTag  tag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[ADD]  value  =  tq  .  chompTo  (  SQ  )  ;	[BUGGY]  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  private  Attribute  parseAttribute  (  )  {  tq  .  consumeWhitespace  (  )  ;  String  key  =  tq  .  consumeAttributeKey  (  )  ;  String  value  =   " "  ;  tq  .  consumeWhitespace  (  )  ;  if  (  tq  .  matchChomp  (   "  =   "  )  )  {  tq  .  consumeWhitespace  (  )  ;    if  (  tq  .  matchChomp  (  SQ  )  )  {  [ATTENTION]  }  else  if  (  tq  .  matchChomp  (  DQ  )  )  {  value  =  tq  .  chompTo  (  DQ  )  ;  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder  (  )  ;    while  (  !tq  .  matchesAny  (   "< "  ,   "/> "  ,   "> "  )  &&  !tq  .  matchesWhitespace  (  )  &&  !tq  .  isEmpty  (  )  )  {  valueAccum  .  append  (  tq  .  consume  (  )  )  ;  }  value  =  valueAccum  .  toString  (  )  ;  }  tq  .  consumeWhitespace  (  )  ;  }  if  (  key  .  length  (  )  !  =  0  )  return  Attribute  .  createFromEncoded  (  key  ,  value  )  ;  else  {  tq  .  consume  (  )  ;  //  unknown  char  ,  keep  popping  so  not  get  stuck  return  null  ;  }  }    [METHOD]  parseAttribute  [TYPE]  Attribute  [PARAMETER]  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  StringBuilder  valueAccum  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  href  html  key  tagName  value  [TYPE]  Tag  bodyTag  headTag  htmlTag  tag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[REPLACE]  }  else  if  (  tq  .  matchChomp  (  DQ  )  )  {	[BUGGY]  else  if  (  tq  .  matches  (   "</ "  )  )  {[FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  private  Attribute  parseAttribute  (  )  {  tq  .  consumeWhitespace  (  )  ;  String  key  =  tq  .  consumeAttributeKey  (  )  ;  String  value  =   " "  ;  tq  .  consumeWhitespace  (  )  ;  if  (  tq  .  matchChomp  (   "  =   "  )  )  {  tq  .  consumeWhitespace  (  )  ;    if  (  tq  .  matchChomp  (  SQ  )  )  {  value  =  tq  .  chompTo  (  SQ  )  ;  [ATTENTION]  }  else  if  (  tq  .  matches  (   "</ "  )  )  {  value  =  tq  .  chompTo  (  DQ  )  ;  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder  (  )  ;    while  (  !tq  .  matchesAny  (   "< "  ,   "/> "  ,   "> "  )  &&  !tq  .  matchesWhitespace  (  )  &&  !tq  .  isEmpty  (  )  )  {  valueAccum  .  append  (  tq  .  consume  (  )  )  ;  }  value  =  valueAccum  .  toString  (  )  ;  }  tq  .  consumeWhitespace  (  )  ;  }  if  (  key  .  length  (  )  !  =  0  )  return  Attribute  .  createFromEncoded  (  key  ,  value  )  ;  else  {  tq  .  consume  (  )  ;  //  unknown  char  ,  keep  popping  so  not  get  stuck  return  null  ;  }  }    [METHOD]  parseAttribute  [TYPE]  Attribute  [PARAMETER]  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  StringBuilder  valueAccum  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  href  html  key  tagName  value  [TYPE]  Tag  bodyTag  headTag  htmlTag  tag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[REMOVE]  	[BUGGY]  if  (  tq  .  matchChomp  (  SQ  )  )  {      value  =  tq  .  chompTo  (  SQ  )  ;  }else      if  (  tq  .  matchChomp  (  DQ  )  )  {          value  =  tq  .  chompTo  (  DQ  )  ;      }else  {          StringBuilder  valueAccum  =  new  StringBuilder  (  )  ;          while  (  (  (  !  (  tq  .  matchesAny  (   "< "  ,   "/> "  ,   "> "  )  )  )  &&  (  !  (  tq  .  matchesWhitespace  (  )  )  )  )  &&  (  !  (  tq  .  isEmpty  (  )  )  )  )  {              valueAccum  .  append  (  tq  .  consume  (  )  )  ;          }          value  =  valueAccum  .  toString  (  )  ;      }[FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  private  Attribute  parseAttribute  (  )  {  tq  .  consumeWhitespace  (  )  ;  String  key  =  tq  .  consumeAttributeKey  (  )  ;  String  value  =   " "  ;  tq  .  consumeWhitespace  (  )  ;  if  (  tq  .  matchChomp  (   "  =   "  )  )  {  tq  .  consumeWhitespace  (  )  ;    if  (  tq  .  matchChomp  (  SQ  )  )  {  value  =  tq  .  chompTo  (  SQ  )  ;  [ATTENTION]  }  else  if  (  tq  .  matchChomp  (  DQ  )  )  {  if  (  tq  .  matchChomp  (  SQ  )  )  {  value  =  tq  .  chompTo  (  SQ  )    ;  }else  if  (  tq  .  matchChomp  (  DQ  )  )  {  value  =  tq  .  chompTo  (  DQ  )    ;  }else  {  StringBuilder  valueAccum  =  new  StringBuilder  (  )    ;  while  (  (  (  !  (  tq  .  matchesAny  (   "< "  ,   "/> "  ,   "> "  )  )  )  &&  (  !  (  tq  .  matchesWhitespace  (  )  )  )  )  &&  (  !  (  tq  .  isEmpty  (  )  )  )  )  {  valueAccum  .  append  (  tq  .  consume  (  )  )    ;  }value  =  valueAccum  .  toString  (  )    ;  }value  =  tq  .  chompTo  (  DQ  )  ;  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder  (  )  ;    while  (  !tq  .  matchesAny  (   "< "  ,   "/> "  ,   "> "  )  &&  !tq  .  matchesWhitespace  (  )  &&  !tq  .  isEmpty  (  )  )  {  valueAccum  .  append  (  tq  .  consume  (  )  )  ;  }  value  =  valueAccum  .  toString  (  )  ;  }  tq  .  consumeWhitespace  (  )  ;  }  if  (  key  .  length  (  )  !  =  0  )  return  Attribute  .  createFromEncoded  (  key  ,  value  )  ;  else  {  tq  .  consume  (  )  ;  //  unknown  char  ,  keep  popping  so  not  get  stuck  return  null  ;  }    [METHOD]  parseAttribute  [TYPE]  Attribute  [PARAMETER]  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  StringBuilder  valueAccum  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  href  html  key  tagName  value  [TYPE]  Tag  bodyTag  headTag  htmlTag  tag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[REPLACE]  while  (  !tq  .  matchesAny  (   "< ",   "/> ",   "> "  )  &&  !tq  .  matchesWhitespace  (  )  &&  !tq  .  isEmpty  (  )  )  {	[BUGGY]  while  (  !tq  .  matches  (   "< "  ,   "/> "  ,   "> "  )    ;  [CE]  [CONTEXT]  }  else  if  (  tq  .  matchChomp  (  DQ  )  )  {  value  =  tq  .  chompTo  (  DQ  )  ;  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder  (  )  ;    [ATTENTION]  while  (  !tq  .  matches  (   "< "  ,   "/> "  ,   "> "  )  ;  valueAccum  .  append  (  tq  .  consume  (  )  )  ;  }  value  =  valueAccum  .  toString  (  )  ;  }    [METHOD]  parseAttribute  [TYPE]  Attribute  [PARAMETER]  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  StringBuilder  valueAccum  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  href  html  key  tagName  value  [TYPE]  Tag  bodyTag  headTag  htmlTag  tag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[ADD]  if  (  tq  .  matchChomp  (  SQ  )  )  {  value  =  tq  .  chompTo  (  SQ  )  ;  }  else  if  (  tq  .  matchChomp  (  DQ  )  )  {  value  =  tq  .  chompTo  (  DQ  )  ;	[BUGGY]  value  =  tq  .  chompTo  (  SQ  )  ;  value  =  tq  .  chompTo  (  DQ  )  ;  [CE]  illegal  start  of  type  [CONTEXT]  private  Attribute  parseAttribute  (  )  {  tq  .  consumeWhitespace  (  )  ;  String  key  =  tq  .  consumeAttributeKey  (  )  ;  String  value  =   " "  ;  tq  .  consumeWhitespace  (  )  ;  if  (  tq  .  matchChomp  (   "  =   "  )  )  {  tq  .  consumeWhitespace  (  )  ;    [ATTENTION]  value  =  tq  .  chompTo  (  SQ  )    ;  value  =  tq  .  chompTo  (  DQ  )    ;      }  else  {  StringBuilder  valueAccum  =  new  StringBuilder  (  )  ;    while  (  !tq  .  matchesAny  (   "< "  ,   "/> "  ,   "> "  )  &&  !tq  .  matchesWhitespace  (  )  &&  !tq  .  isEmpty  (  )  )  {  valueAccum  .  append  (  tq  .  consume  (  )  )  ;  }  value  =  valueAccum  .  toString  (  )  ;  }  tq  .  consumeWhitespace  (  )  ;  }  if  (  key  .  length  (  )  !  =  0  )  return  Attribute  .  createFromEncoded  (  key  ,  value  )  ;  else  {  tq  .  consume  (  )  ;  //  unknown  char  ,  keep  popping  so  not  get  stuck  return  null  ;  }  }    [METHOD]  parseAttribute  [TYPE]  Attribute  [PARAMETER]  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  StringBuilder  valueAccum  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  href  html  key  tagName  value  [TYPE]  Tag  bodyTag  headTag  htmlTag  tag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[REPLACE]  while  (  !tq  .  matchesAny  (   "< ",   "/> ",   "> "  )  &&  !tq  .  matchesWhitespace  (  )  &&  !tq  .  isEmpty  (  )  )  {	[BUGGY]  while  (  tq  .  matchesAny  (   "< "  ,   "/> "  ,   "> "  )    <  =    !tq  .  matchesWhitespace  (  )    <  =    !tq  .  isEmpty  (  )  )  {[CE]  bad  operand  types  for  binary  operator  [CONTEXT]  }  else  if  (  tq  .  matchChomp  (  DQ  )  )  {  value  =  tq  .  chompTo  (  DQ  )  ;  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder  (  )  ;    [ATTENTION]  while  (  tq  .  matchesAny  (   "< "  ,   "/> "  ,   "> "  )  <  =  !tq  .  matchesWhitespace  (  )  <  =  !tq  .  isEmpty  (  )  )  {  valueAccum  .  append  (  tq  .  consume  (  )  )  ;  }  value  =  valueAccum  .  toString  (  )  ;  }    [METHOD]  parseAttribute  [TYPE]  Attribute  [PARAMETER]  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  StringBuilder  valueAccum  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  href  html  key  tagName  value  [TYPE]  Tag  bodyTag  headTag  htmlTag  tag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[ADD]  valueAccum  .  append  (  tq  .  consume  (  )  )  ;	[BUGGY]  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  }  else  if  (  tq  .  matchChomp  (  DQ  )  )  {  value  =  tq  .  chompTo  (  DQ  )  ;  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder  (  )  ;    while  (  !tq  .  matchesAny  (   "< "  ,   "/> "  ,   "> "  )  &&  !tq  .  matchesWhitespace  (  )  &&  !tq  .  isEmpty  (  )  )  {  [ATTENTION]  }  value  =  valueAccum  .  toString  (  )  ;  }    [METHOD]  parseAttribute  [TYPE]  Attribute  [PARAMETER]  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  StringBuilder  valueAccum  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  href  html  key  tagName  value  [TYPE]  Tag  bodyTag  headTag  htmlTag  tag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[REPLACE]  valueAccum  .  append  (  tq  .  consume  (  )  )  ;	[BUGGY]  valueAccum  .  append  (  tq  .  consume  (  baseUri  )    )  ;  [CE]  'void'  type  not  allowed  here  [CONTEXT]  }  else  if  (  tq  .  matchChomp  (  DQ  )  )  {  value  =  tq  .  chompTo  (  DQ  )  ;  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder  (  )  ;    while  (  !tq  .  matchesAny  (   "< "  ,   "/> "  ,   "> "  )  &&  !tq  .  matchesWhitespace  (  )  &&  !tq  .  isEmpty  (  )  )  {  [ATTENTION]  valueAccum  .  append  (  tq  .  consume  (  baseUri  )    )    ;  }  value  =  valueAccum  .  toString  (  )  ;  }    [METHOD]  parseAttribute  [TYPE]  Attribute  [PARAMETER]  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  StringBuilder  valueAccum  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  href  html  key  tagName  value  [TYPE]  Tag  bodyTag  headTag  htmlTag  tag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[REPLACE]  }  else  if  (  tq  .  matchChomp  (  DQ  )  )  {	[BUGGY]    if  (  tq  .  matchChomp  (  DQ  )  )  {[FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  private  Attribute  parseAttribute  (  )  {  tq  .  consumeWhitespace  (  )  ;  String  key  =  tq  .  consumeAttributeKey  (  )  ;  String  value  =   " "  ;  tq  .  consumeWhitespace  (  )  ;  if  (  tq  .  matchChomp  (   "  =   "  )  )  {  tq  .  consumeWhitespace  (  )  ;    if  (  tq  .  matchChomp  (  SQ  )  )  {  value  =  tq  .  chompTo  (  SQ  )  ;  [ATTENTION]  }if  (  tq  .  matchChomp  (  DQ  )  )  {  value  =  tq  .  chompTo  (  DQ  )  ;  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder  (  )  ;    while  (  !tq  .  matchesAny  (   "< "  ,   "/> "  ,   "> "  )  &&  !tq  .  matchesWhitespace  (  )  &&  !tq  .  isEmpty  (  )  )  {  valueAccum  .  append  (  tq  .  consume  (  )  )  ;  }  value  =  valueAccum  .  toString  (  )  ;  }  tq  .  consumeWhitespace  (  )  ;  }  if  (  key  .  length  (  )  !  =  0  )  return  Attribute  .  createFromEncoded  (  key  ,  value  )  ;  else  {  tq  .  consume  (  )  ;  //  unknown  char  ,  keep  popping  so  not  get  stuck  return  null  ;  }  }    [METHOD]  parseAttribute  [TYPE]  Attribute  [PARAMETER]  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  StringBuilder  valueAccum  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  href  html  key  tagName  value  [TYPE]  Tag  bodyTag  headTag  htmlTag  tag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[REPLACE]  if  (  key  .  length  (  )  !=  0  )  return  Attribute  .  createFromEncoded  (  key,  value  )  ;	[BUGGY]  if  (  key  .  length  (  )  %  0  .  5  !  =  0  )  return  Attribute  .  createFromEncoded  (  key  ,  value  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  private  Attribute  parseAttribute  (  )  {  tq  .  consumeWhitespace  (  )  ;  String  key  =  tq  .  consumeAttributeKey  (  )  ;  String  value  =   " "  ;  tq  .  consumeWhitespace  (  )  ;  if  (  tq  .  matchChomp  (   "  =   "  )  )  {  tq  .  consumeWhitespace  (  )  ;    if  (  tq  .  matchChomp  (  SQ  )  )  {  value  =  tq  .  chompTo  (  SQ  )  ;  }  else  if  (  tq  .  matchChomp  (  DQ  )  )  {  value  =  tq  .  chompTo  (  DQ  )  ;  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder  (  )  ;    while  (  !tq  .  matchesAny  (   "< "  ,   "/> "  ,   "> "  )  &&  !tq  .  matchesWhitespace  (  )  &&  !tq  .  isEmpty  (  )  )  {  valueAccum  .  append  (  tq  .  consume  (  )  )  ;  }  value  =  valueAccum  .  toString  (  )  ;  }  tq  .  consumeWhitespace  (  )  ;  }  [ATTENTION]  if  (  key  .  length  (  )  %0  .  5!  =  0  )  return  Attribute  .  createFromEncoded  (  key  ,  value  )    ;    else  {  tq  .  consume  (  )  ;  //  unknown  char  ,  keep  popping  so  not  get  stuck  return  null  ;  }  }    [METHOD]  parseAttribute  [TYPE]  Attribute  [PARAMETER]  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  StringBuilder  valueAccum  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  href  html  key  tagName  value  [TYPE]  Tag  bodyTag  headTag  htmlTag  tag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[ADD]  if  (  key  .  length  (  )  !=  0  )  return  Attribute  .  createFromEncoded  (  key,  value  )  ;  else  {  tq  .  consume  (  )  ;  return  null;	[BUGGY]  return  Attribute  .  createFromEncoded  (  key  ,  value  )  ;  tq  .  consume  (  )  ;  return  null  ;  [CE]  class  ,  interface  ,  or  enum  expected  [CONTEXT]  private  Attribute  parseAttribute  (  )  {  tq  .  consumeWhitespace  (  )  ;  String  key  =  tq  .  consumeAttributeKey  (  )  ;  String  value  =   " "  ;  tq  .  consumeWhitespace  (  )  ;  if  (  tq  .  matchChomp  (   "  =   "  )  )  {  tq  .  consumeWhitespace  (  )  ;    if  (  tq  .  matchChomp  (  SQ  )  )  {  value  =  tq  .  chompTo  (  SQ  )  ;  }  else  if  (  tq  .  matchChomp  (  DQ  )  )  {  value  =  tq  .  chompTo  (  DQ  )  ;  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder  (  )  ;    while  (  !tq  .  matchesAny  (   "< "  ,   "/> "  ,   "> "  )  &&  !tq  .  matchesWhitespace  (  )  &&  !tq  .  isEmpty  (  )  )  {  valueAccum  .  append  (  tq  .  consume  (  )  )  ;  }  value  =  valueAccum  .  toString  (  )  ;  }  tq  .  consumeWhitespace  (  )  ;  }  [ATTENTION]  return  Attribute  .  createFromEncoded  (  key  ,  value  )    ;  tq  .  consume  (  )    ;  return  null  ;      }  }    [METHOD]  parseAttribute  [TYPE]  Attribute  [PARAMETER]  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  StringBuilder  valueAccum  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  href  html  key  tagName  value  [TYPE]  Tag  bodyTag  headTag  htmlTag  tag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[REPLACE]  return  null;	[BUGGY]  return  this  ;  [CE]  incompatible  types  [CONTEXT]  if  (  key  .  length  (  )  !  =  0  )  return  Attribute  .  createFromEncoded  (  key  ,  value  )  ;  else  {  tq  .  consume  (  )  ;  //  unknown  char  ,  keep  popping  so  not  get  stuck  [ATTENTION]  return  this  ;  }    [METHOD]  parseAttribute  [TYPE]  Attribute  [PARAMETER]  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  StringBuilder  valueAccum  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  href  html  key  tagName  value  [TYPE]  Tag  bodyTag  headTag  htmlTag  tag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[REPLACE]  return  Attribute  .  createFromEncoded  (  key,  value  )  ;	[BUGGY]  return  Attribute  .  createFromEncoded  (  href  ,  value  )  ;  [CE]  cannot  find  symbol  href  [CONTEXT]  private  Attribute  parseAttribute  (  )  {  tq  .  consumeWhitespace  (  )  ;  String  key  =  tq  .  consumeAttributeKey  (  )  ;  String  value  =   " "  ;  tq  .  consumeWhitespace  (  )  ;  if  (  tq  .  matchChomp  (   "  =   "  )  )  {  tq  .  consumeWhitespace  (  )  ;    if  (  tq  .  matchChomp  (  SQ  )  )  {  value  =  tq  .  chompTo  (  SQ  )  ;  }  else  if  (  tq  .  matchChomp  (  DQ  )  )  {  value  =  tq  .  chompTo  (  DQ  )  ;  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder  (  )  ;    while  (  !tq  .  matchesAny  (   "< "  ,   "/> "  ,   "> "  )  &&  !tq  .  matchesWhitespace  (  )  &&  !tq  .  isEmpty  (  )  )  {  valueAccum  .  append  (  tq  .  consume  (  )  )  ;  }  value  =  valueAccum  .  toString  (  )  ;  }  tq  .  consumeWhitespace  (  )  ;  }  if  (  key  .  length  (  )  !  =  0  )  [ATTENTION]  return  Attribute  .  createFromEncoded  (  href  ,  value  )    ;  else  {  tq  .  consume  (  )  ;  //  unknown  char  ,  keep  popping  so  not  get  stuck  return  null  ;  }  }    [METHOD]  parseAttribute  [TYPE]  Attribute  [PARAMETER]  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  StringBuilder  valueAccum  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  href  html  key  tagName  value  [TYPE]  Tag  bodyTag  headTag  htmlTag  tag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[REPLACE]  return  null;	[BUGGY]  return  false  ;  [CE]  incompatible  types  [CONTEXT]  private  Attribute  parseAttribute  (  )  {  tq  .  consumeWhitespace  (  )  ;  String  key  =  tq  .  consumeAttributeKey  (  )  ;  String  value  =   " "  ;  tq  .  consumeWhitespace  (  )  ;  if  (  tq  .  matchChomp  (   "  =   "  )  )  {  tq  .  consumeWhitespace  (  )  ;    if  (  tq  .  matchChomp  (  SQ  )  )  {  value  =  tq  .  chompTo  (  SQ  )  ;  }  else  if  (  tq  .  matchChomp  (  DQ  )  )  {  value  =  tq  .  chompTo  (  DQ  )  ;  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder  (  )  ;    while  (  !tq  .  matchesAny  (   "< "  ,   "/> "  ,   "> "  )  &&  !tq  .  matchesWhitespace  (  )  &&  !tq  .  isEmpty  (  )  )  {  valueAccum  .  append  (  tq  .  consume  (  )  )  ;  }  value  =  valueAccum  .  toString  (  )  ;  }  tq  .  consumeWhitespace  (  )  ;  }  if  (  key  .  length  (  )  !  =  0  )  return  Attribute  .  createFromEncoded  (  key  ,  value  )  ;  else  {  tq  .  consume  (  )  ;  //  unknown  char  ,  keep  popping  so  not  get  stuck  [ATTENTION]  return  false  ;  }  }    [METHOD]  parseAttribute  [TYPE]  Attribute  [PARAMETER]  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  StringBuilder  valueAccum  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  href  html  key  tagName  value  [TYPE]  Tag  bodyTag  headTag  htmlTag  tag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[REPLACE]  String  text  =  tq  .  consumeTo  (   "< "  )  ;	[BUGGY]  String  text  =  tq  .  consume  (   "< "  )  ;  [CE]  incompatible  types  [CONTEXT]  private  void  parseTextNode  (  )  {  [ATTENTION]  String  text  =  tq  .  consume  (   "< "  )    ;  TextNode  textNode  =  TextNode  .  createFromEncoded  (  text  ,  baseUri  )  ;  last  (  )  .  appendChild  (  textNode  )  ;  }    [METHOD]  parseTextNode  [TYPE]  void  [PARAMETER]  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  TextNode  textNode  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  href  html  key  tagName  text  value  [TYPE]  Tag  bodyTag  headTag  htmlTag  tag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[REPLACE]  TextNode  textNode  =  TextNode  .  createFromEncoded  (  text,  baseUri  )  ;	[BUGGY]  TextNode  textNode  =  TextNode  .  TextNode  (  text  ,  baseUri  )  ;  [CE]  cannot  find  symbol  [CONTEXT]  private  void  parseTextNode  (  )  {  String  text  =  tq  .  consumeTo  (   "< "  )  ;  [ATTENTION]  TextNode  textNode  =  TextNode  .  TextNode  (  text  ,  baseUri  )    ;  last  (  )  .  appendChild  (  textNode  )  ;  }    [METHOD]  parseTextNode  [TYPE]  void  [PARAMETER]  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  TextNode  textNode  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  href  html  key  tagName  text  value  [TYPE]  Tag  bodyTag  headTag  htmlTag  tag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[REPLACE]  last  (  )    .  appendChild  (  textNode  )  ;	[BUGGY]  last  (  )    .  absUrl  (  text  )    ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  private  void  parseTextNode  (  )  {  String  text  =  tq  .  consumeTo  (   "< "  )  ;  TextNode  textNode  =  TextNode  .  createFromEncoded  (  text  ,  baseUri  )  ;  [ATTENTION]  last  (  )  .  absUrl  (  text  )  ;  }    [METHOD]  parseTextNode  [TYPE]  void  [PARAMETER]  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  TextNode  textNode  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  href  html  key  tagName  text  value  [TYPE]  Tag  bodyTag  headTag  htmlTag  tag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[REPLACE]  last  (  )    .  appendChild  (  textNode  )  ;	[BUGGY]  last  (  )  .  appendChild  (  comment  )  ;  [CE]  cannot  find  symbol  comment  [CONTEXT]  private  void  parseTextNode  (  )  {  String  text  =  tq  .  consumeTo  (   "< "  )  ;  TextNode  textNode  =  TextNode  .  createFromEncoded  (  text  ,  baseUri  )  ;  [ATTENTION]  last  (  )    .  appendChild  (  comment  )    ;  }    [METHOD]  parseTextNode  [TYPE]  void  [PARAMETER]  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  TextNode  textNode  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  href  html  key  tagName  text  value  [TYPE]  Tag  bodyTag  headTag  htmlTag  tag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[REPLACE]  tq  .  consume  (   "<![CDATA[ "  )  ;	[BUGGY]  tq  .  consumeTo  (  value  )    ;  [CE]  cannot  find  symbol  value  [CONTEXT]  private  void  parseCdata  (  )  {  [ATTENTION]  tq  .  consumeTo  (  value  )  ;  String  rawText  =  tq  .  chompTo  (   "]]> "  )  ;  TextNode  textNode  =  new  TextNode  (  rawText  ,  baseUri  )  ;  //  constructor  does  not  escape  last  (  )  .  appendChild  (  textNode  )  ;  }    [METHOD]  parseCdata  [TYPE]  void  [PARAMETER]  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  TextNode  textNode  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  href  html  key  rawText  tagName  text  value  [TYPE]  Tag  bodyTag  headTag  htmlTag  tag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[REPLACE]  String  rawText  =  tq  .  chompTo  (   "]]> "  )  ;	[BUGGY]  String  rawText  =  tq  .  consumeTo  (  tagName  )    ;  [CE]  cannot  find  symbol  tagName  [CONTEXT]  private  void  parseCdata  (  )  {  tq  .  consume  (   "<![CDATA[ "  )  ;  [ATTENTION]  String  rawText  =  tq  .  consumeTo  (  tagName  )  ;  TextNode  textNode  =  new  TextNode  (  rawText  ,  baseUri  )  ;  //  constructor  does  not  escape  last  (  )  .  appendChild  (  textNode  )  ;  }    [METHOD]  parseCdata  [TYPE]  void  [PARAMETER]  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  TextNode  textNode  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  href  html  key  rawText  tagName  text  value  [TYPE]  Tag  bodyTag  headTag  htmlTag  tag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[REPLACE]  TextNode  textNode  =  new  TextNode  (  rawText,  baseUri  )  ;	[BUGGY]  TextNode  textNode  =  new  TextNode  (  value  ,  baseUri  )  ;  [CE]  cannot  find  symbol  value  [CONTEXT]  private  void  parseCdata  (  )  {  tq  .  consume  (   "<![CDATA[ "  )  ;  String  rawText  =  tq  .  chompTo  (   "]]> "  )  ;  [ATTENTION]  TextNode  textNode  =  new  TextNode  (  value  ,  baseUri  )    ;  last  (  )  .  appendChild  (  textNode  )  ;  }    [METHOD]  parseCdata  [TYPE]  void  [PARAMETER]  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  TextNode  textNode  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  href  html  key  rawText  tagName  text  value  [TYPE]  Tag  bodyTag  headTag  htmlTag  tag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[REPLACE]  last  (  )    .  appendChild  (  textNode  )  ;	[BUGGY]  last  (  )  .  appendChild  (  comment  )  ;  [CE]  cannot  find  symbol  comment  [CONTEXT]  private  void  parseCdata  (  )  {  tq  .  consume  (   "<![CDATA[ "  )  ;  String  rawText  =  tq  .  chompTo  (   "]]> "  )  ;  TextNode  textNode  =  new  TextNode  (  rawText  ,  baseUri  )  ;  //  constructor  does  not  escape  [ATTENTION]  last  (  )    .  appendChild  (  comment  )    ;  }    [METHOD]  parseCdata  [TYPE]  void  [PARAMETER]  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  TextNode  textNode  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  href  html  key  rawText  tagName  text  value  [TYPE]  Tag  bodyTag  headTag  htmlTag  tag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[REMOVE]  	[BUGGY]  String  data  =  tq  .  chompTo  (   "</ "  +  tagName  )  ;  [CE]  cannot  find  symbol  tagName  [CONTEXT]  private  void  parseCdata  (  )  {  tq  .  consume  (   "<![CDATA[ "  )  ;  String  rawText  =  tq  .  chompTo  (   "]]> "  )  ;  TextNode  textNode  =  new  TextNode  (  rawText  ,  baseUri  )  ;  //  constructor  does  not  escape  [ATTENTION]  last  (  )  .  appendChild  (  textNode  )  ;      [METHOD]  parseCdata  [TYPE]  void  [PARAMETER]  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  TextNode  textNode  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  href  html  key  rawText  tagName  text  value  [TYPE]  Tag  bodyTag  headTag  htmlTag  tag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[REPLACE]  Element  parent  =  popStackToSuitableContainer  (  child  .  tag  (  )  )  ;	[BUGGY]  Element  parent  =  popStackToSuitableContainer  (  implicit  .  tag  (  )  )  ;  [CE]  cannot  find  symbol  implicit  [CONTEXT]  private  Element  addChildToParent  (  Element  child  ,  boolean  isEmptyElement  )  {  [ATTENTION]  Element  parent  =  popStackToSuitableContainer  (  implicit  .  tag  (  )  )    ;  Tag  childTag  =  child  .  tag  (  )  ;  boolean  validAncestor  =  stackHasValidParent  (  childTag  )  ;    if  (  !validAncestor  )  {    Tag  parentTag  =  childTag  .  getImplicitParent  (  )  ;  Element  implicit  =  new  Element  (  parentTag  ,  baseUri  )  ;    if  (  child  .  tag  (  )  .  equals  (  bodyTag  )  )  {  Element  head  =  new  Element  (  headTag  ,  baseUri  )  ;  implicit  .  appendChild  (  head  )  ;  }  implicit  .  appendChild  (  child  )  ;      Element  root  =  addChildToParent  (  implicit  ,  false  )  ;  if  (  !isEmptyElement  )  stack  .  addLast  (  child  )  ;  return  root  ;  }  parent  .  appendChild  (  child  )  ;    if  (  !isEmptyElement  )  stack  .  addLast  (  child  )  ;  return  parent  ;  }    [METHOD]  addChildToParent  [TYPE]  Element  [PARAMETER]  Element  child  boolean  isEmptyElement  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  isEmptyElement  true  validAncestor  [TYPE]  Element  child  head  implicit  parent  root  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  href  html  key  rawText  tagName  text  value  [TYPE]  Tag  bodyTag  childTag  headTag  htmlTag  parentTag  tag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[REPLACE]  Tag  childTag  =  child  .  tag  (  )  ;	[BUGGY]  Tag  childTag  =  child  .  tagName  (  )  ;  [CE]  incompatible  types  [CONTEXT]  private  Element  addChildToParent  (  Element  child  ,  boolean  isEmptyElement  )  {  Element  parent  =  popStackToSuitableContainer  (  child  .  tag  (  )  )  ;  [ATTENTION]  Tag  childTag  =  child  .  tagName  (  )    ;  boolean  validAncestor  =  stackHasValidParent  (  childTag  )  ;    if  (  !validAncestor  )  {    Tag  parentTag  =  childTag  .  getImplicitParent  (  )  ;  Element  implicit  =  new  Element  (  parentTag  ,  baseUri  )  ;    if  (  child  .  tag  (  )  .  equals  (  bodyTag  )  )  {  Element  head  =  new  Element  (  headTag  ,  baseUri  )  ;  implicit  .  appendChild  (  head  )  ;  }  implicit  .  appendChild  (  child  )  ;      Element  root  =  addChildToParent  (  implicit  ,  false  )  ;  if  (  !isEmptyElement  )  stack  .  addLast  (  child  )  ;  return  root  ;  }  parent  .  appendChild  (  child  )  ;    if  (  !isEmptyElement  )  stack  .  addLast  (  child  )  ;  return  parent  ;  }    [METHOD]  addChildToParent  [TYPE]  Element  [PARAMETER]  Element  child  boolean  isEmptyElement  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  isEmptyElement  true  validAncestor  [TYPE]  Element  child  head  implicit  parent  root  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  href  html  key  rawText  tagName  text  value  [TYPE]  Tag  bodyTag  childTag  headTag  htmlTag  parentTag  tag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[ADD]  Tag  childTag  =  child  .  tag  (  )  ;	[BUGGY]  [CE]  cannot  find  symbol  childTag  [CONTEXT]  private  Element  addChildToParent  (  Element  child  ,  boolean  isEmptyElement  )  {  Element  parent  =  popStackToSuitableContainer  (  child  .  tag  (  )  )  ;  [ATTENTION]  boolean  validAncestor  =  stackHasValidParent  (  childTag  )  ;    if  (  !validAncestor  )  {    Tag  parentTag  =  childTag  .  getImplicitParent  (  )  ;  Element  implicit  =  new  Element  (  parentTag  ,  baseUri  )  ;    if  (  child  .  tag  (  )  .  equals  (  bodyTag  )  )  {  Element  head  =  new  Element  (  headTag  ,  baseUri  )  ;  implicit  .  appendChild  (  head  )  ;  }  implicit  .  appendChild  (  child  )  ;      Element  root  =  addChildToParent  (  implicit  ,  false  )  ;  if  (  !isEmptyElement  )  stack  .  addLast  (  child  )  ;  return  root  ;  }  parent  .  appendChild  (  child  )  ;    if  (  !isEmptyElement  )  stack  .  addLast  (  child  )  ;  return  parent  ;  }    [METHOD]  addChildToParent  [TYPE]  Element  [PARAMETER]  Element  child  boolean  isEmptyElement  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  isEmptyElement  true  validAncestor  [TYPE]  Element  child  head  implicit  parent  root  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  href  html  key  rawText  tagName  text  value  [TYPE]  Tag  bodyTag  childTag  headTag  htmlTag  parentTag  tag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[REPLACE]  boolean  validAncestor  =  stackHasValidParent  (  childTag  )  ;	[BUGGY]  boolean  validAncestor  =  stackHasValidParent  (  titleTag  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  private  Element  addChildToParent  (  Element  child  ,  boolean  isEmptyElement  )  {  Element  parent  =  popStackToSuitableContainer  (  child  .  tag  (  )  )  ;  Tag  childTag  =  child  .  tag  (  )  ;  [ATTENTION]  boolean  validAncestor  =  stackHasValidParent  (  titleTag  )    ;    if  (  !validAncestor  )  {    Tag  parentTag  =  childTag  .  getImplicitParent  (  )  ;  Element  implicit  =  new  Element  (  parentTag  ,  baseUri  )  ;    if  (  child  .  tag  (  )  .  equals  (  bodyTag  )  )  {  Element  head  =  new  Element  (  headTag  ,  baseUri  )  ;  implicit  .  appendChild  (  head  )  ;  }  implicit  .  appendChild  (  child  )  ;      Element  root  =  addChildToParent  (  implicit  ,  false  )  ;  if  (  !isEmptyElement  )  stack  .  addLast  (  child  )  ;  return  root  ;  }  parent  .  appendChild  (  child  )  ;    if  (  !isEmptyElement  )  stack  .  addLast  (  child  )  ;  return  parent  ;  }    [METHOD]  addChildToParent  [TYPE]  Element  [PARAMETER]  Element  child  boolean  isEmptyElement  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  isEmptyElement  true  validAncestor  [TYPE]  Element  child  head  implicit  parent  root  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  href  html  key  rawText  tagName  text  value  [TYPE]  Tag  bodyTag  childTag  headTag  htmlTag  parentTag  tag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[ADD]  boolean  validAncestor  =  stackHasValidParent  (  childTag  )  ;	[BUGGY]  [CE]  cannot  find  symbol  validAncestor  [CONTEXT]  private  Element  addChildToParent  (  Element  child  ,  boolean  isEmptyElement  )  {  Element  parent  =  popStackToSuitableContainer  (  child  .  tag  (  )  )  ;  Tag  childTag  =  child  .  tag  (  )  ;  [ATTENTION]    if  (  !validAncestor  )  {    Tag  parentTag  =  childTag  .  getImplicitParent  (  )  ;  Element  implicit  =  new  Element  (  parentTag  ,  baseUri  )  ;    if  (  child  .  tag  (  )  .  equals  (  bodyTag  )  )  {  Element  head  =  new  Element  (  headTag  ,  baseUri  )  ;  implicit  .  appendChild  (  head  )  ;  }  implicit  .  appendChild  (  child  )  ;      Element  root  =  addChildToParent  (  implicit  ,  false  )  ;  if  (  !isEmptyElement  )  stack  .  addLast  (  child  )  ;  return  root  ;  }  parent  .  appendChild  (  child  )  ;    if  (  !isEmptyElement  )  stack  .  addLast  (  child  )  ;  return  parent  ;  }    [METHOD]  addChildToParent  [TYPE]  Element  [PARAMETER]  Element  child  boolean  isEmptyElement  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  isEmptyElement  true  validAncestor  [TYPE]  Element  child  head  implicit  parent  root  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  href  html  key  rawText  tagName  text  value  [TYPE]  Tag  bodyTag  childTag  headTag  htmlTag  parentTag  tag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[REPLACE]  if  (  !validAncestor  )  {	[BUGGY]  if  (  validAncestor  )  {[FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  private  Element  addChildToParent  (  Element  child  ,  boolean  isEmptyElement  )  {  Element  parent  =  popStackToSuitableContainer  (  child  .  tag  (  )  )  ;  Tag  childTag  =  child  .  tag  (  )  ;  boolean  validAncestor  =  stackHasValidParent  (  childTag  )  ;    [ATTENTION]  if  (  validAncestor  )  {    Tag  parentTag  =  childTag  .  getImplicitParent  (  )  ;  Element  implicit  =  new  Element  (  parentTag  ,  baseUri  )  ;    if  (  child  .  tag  (  )  .  equals  (  bodyTag  )  )  {  Element  head  =  new  Element  (  headTag  ,  baseUri  )  ;  implicit  .  appendChild  (  head  )  ;  }  implicit  .  appendChild  (  child  )  ;      Element  root  =  addChildToParent  (  implicit  ,  false  )  ;  if  (  !isEmptyElement  )  stack  .  addLast  (  child  )  ;  return  root  ;  }  parent  .  appendChild  (  child  )  ;    if  (  !isEmptyElement  )  stack  .  addLast  (  child  )  ;  return  parent  ;  }    [METHOD]  addChildToParent  [TYPE]  Element  [PARAMETER]  Element  child  boolean  isEmptyElement  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  isEmptyElement  true  validAncestor  [TYPE]  Element  child  head  implicit  parent  root  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  href  html  key  rawText  tagName  text  value  [TYPE]  Tag  bodyTag  childTag  headTag  htmlTag  parentTag  tag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[REPLACE]  if  (  child  .  tag  (  )    .  equals  (  bodyTag  )  )  {	[BUGGY]  if  (  head  .  tag  (  )  .  equals  (  bodyTag  )  )  {[CE]  cannot  find  symbol  head  [CONTEXT]  private  Element  addChildToParent  (  Element  child  ,  boolean  isEmptyElement  )  {  Element  parent  =  popStackToSuitableContainer  (  child  .  tag  (  )  )  ;  Tag  childTag  =  child  .  tag  (  )  ;  boolean  validAncestor  =  stackHasValidParent  (  childTag  )  ;    if  (  !validAncestor  )  {    Tag  parentTag  =  childTag  .  getImplicitParent  (  )  ;  Element  implicit  =  new  Element  (  parentTag  ,  baseUri  )  ;    [ATTENTION]  if  (  head  .  tag  (  )    .  equals  (  bodyTag  )  )  {  Element  head  =  new  Element  (  headTag  ,  baseUri  )  ;  implicit  .  appendChild  (  head  )  ;  }  implicit  .  appendChild  (  child  )  ;      Element  root  =  addChildToParent  (  implicit  ,  false  )  ;  if  (  !isEmptyElement  )  stack  .  addLast  (  child  )  ;  return  root  ;  }  parent  .  appendChild  (  child  )  ;    if  (  !isEmptyElement  )  stack  .  addLast  (  child  )  ;  return  parent  ;  }    [METHOD]  addChildToParent  [TYPE]  Element  [PARAMETER]  Element  child  boolean  isEmptyElement  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  isEmptyElement  true  validAncestor  [TYPE]  Element  child  head  implicit  parent  root  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  href  html  key  rawText  tagName  text  value  [TYPE]  Tag  bodyTag  childTag  headTag  htmlTag  parentTag  tag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[ADD]  if  (  child  .  tag  (  )    .  equals  (  bodyTag  )  )  {  Element  head  =  new  Element  (  headTag,  baseUri  )  ;  implicit  .  appendChild  (  head  )  ;  }	[BUGGY]  Element  head  =  new  Element  (  headTag  ,  baseUri  )  ;  implicit  .  appendChild  (  head  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  private  Element  addChildToParent  (  Element  child  ,  boolean  isEmptyElement  )  {  Element  parent  =  popStackToSuitableContainer  (  child  .  tag  (  )  )  ;  Tag  childTag  =  child  .  tag  (  )  ;  boolean  validAncestor  =  stackHasValidParent  (  childTag  )  ;    if  (  !validAncestor  )  {    Tag  parentTag  =  childTag  .  getImplicitParent  (  )  ;  Element  implicit  =  new  Element  (  parentTag  ,  baseUri  )  ;    [ATTENTION]  Element  head  =  new  Element  (  headTag  ,  baseUri  )    ;  implicit  .  appendChild  (  head  )    ;      implicit  .  appendChild  (  child  )  ;      Element  root  =  addChildToParent  (  implicit  ,  false  )  ;  if  (  !isEmptyElement  )  stack  .  addLast  (  child  )  ;  return  root  ;  }  parent  .  appendChild  (  child  )  ;    if  (  !isEmptyElement  )  stack  .  addLast  (  child  )  ;  return  parent  ;  }    [METHOD]  addChildToParent  [TYPE]  Element  [PARAMETER]  Element  child  boolean  isEmptyElement  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  isEmptyElement  true  validAncestor  [TYPE]  Element  child  head  implicit  parent  root  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  href  html  key  rawText  tagName  text  value  [TYPE]  Tag  bodyTag  childTag  headTag  htmlTag  parentTag  tag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[REPLACE]  Element  head  =  new  Element  (  headTag,  baseUri  )  ;	[BUGGY]  Element  child  =  new  Element  (  tag  ,  baseUri  ,  attributes  )  ;  [CE]  variable  child  is  already  defined  in  method  addChildToParent(Element  ,  boolean)  [CONTEXT]  private  Element  addChildToParent  (  Element  child  ,  boolean  isEmptyElement  )  {  Element  parent  =  popStackToSuitableContainer  (  child  .  tag  (  )  )  ;  Tag  childTag  =  child  .  tag  (  )  ;  boolean  validAncestor  =  stackHasValidParent  (  childTag  )  ;    if  (  !validAncestor  )  {    Tag  parentTag  =  childTag  .  getImplicitParent  (  )  ;  Element  implicit  =  new  Element  (  parentTag  ,  baseUri  )  ;    if  (  child  .  tag  (  )  .  equals  (  bodyTag  )  )  {  [ATTENTION]  Element  child  =  new  Element  (  tag  ,  baseUri  ,  attributes  )    ;  implicit  .  appendChild  (  head  )  ;  }  implicit  .  appendChild  (  child  )  ;      Element  root  =  addChildToParent  (  implicit  ,  false  )  ;  if  (  !isEmptyElement  )  stack  .  addLast  (  child  )  ;  return  root  ;  }  parent  .  appendChild  (  child  )  ;    if  (  !isEmptyElement  )  stack  .  addLast  (  child  )  ;  return  parent  ;  }    [METHOD]  addChildToParent  [TYPE]  Element  [PARAMETER]  Element  child  boolean  isEmptyElement  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  isEmptyElement  true  validAncestor  [TYPE]  Element  child  head  implicit  parent  root  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  href  html  key  rawText  tagName  text  value  [TYPE]  Tag  bodyTag  childTag  headTag  htmlTag  parentTag  tag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[REPLACE]  if  (  !isEmptyElement  )  stack  .  addLast  (  child  )  ;	[BUGGY]  if  (  !isEmptyElement  )  stack  .  add  (  implicit  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  private  Element  addChildToParent  (  Element  child  ,  boolean  isEmptyElement  )  {  Element  parent  =  popStackToSuitableContainer  (  child  .  tag  (  )  )  ;  Tag  childTag  =  child  .  tag  (  )  ;  boolean  validAncestor  =  stackHasValidParent  (  childTag  )  ;    if  (  !validAncestor  )  {    Tag  parentTag  =  childTag  .  getImplicitParent  (  )  ;  Element  implicit  =  new  Element  (  parentTag  ,  baseUri  )  ;    if  (  child  .  tag  (  )  .  equals  (  bodyTag  )  )  {  Element  head  =  new  Element  (  headTag  ,  baseUri  )  ;  implicit  .  appendChild  (  head  )  ;  }  implicit  .  appendChild  (  child  )  ;      Element  root  =  addChildToParent  (  implicit  ,  false  )  ;  [ATTENTION]  if  (  !isEmptyElement  )  stack  .  add  (  implicit  )    ;    return  root  ;  }  parent  .  appendChild  (  child  )  ;    if  (  !isEmptyElement  )  stack  .  addLast  (  child  )  ;  return  parent  ;  }    [METHOD]  addChildToParent  [TYPE]  Element  [PARAMETER]  Element  child  boolean  isEmptyElement  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  isEmptyElement  true  validAncestor  [TYPE]  Element  child  head  implicit  parent  root  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  href  html  key  rawText  tagName  text  value  [TYPE]  Tag  bodyTag  childTag  headTag  htmlTag  parentTag  tag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[ADD]  if  (  !isEmptyElement  )  stack  .  addLast  (  child  )  ;  return  root;  }	[BUGGY]  [CE]  illegal  start  of  expression  [CONTEXT]  private  Element  addChildToParent  (  Element  child  ,  boolean  isEmptyElement  )  {  Element  parent  =  popStackToSuitableContainer  (  child  .  tag  (  )  )  ;  Tag  childTag  =  child  .  tag  (  )  ;  boolean  validAncestor  =  stackHasValidParent  (  childTag  )  ;    if  (  !validAncestor  )  {    Tag  parentTag  =  childTag  .  getImplicitParent  (  )  ;  Element  implicit  =  new  Element  (  parentTag  ,  baseUri  )  ;    if  (  child  .  tag  (  )  .  equals  (  bodyTag  )  )  {  Element  head  =  new  Element  (  headTag  ,  baseUri  )  ;  implicit  .  appendChild  (  head  )  ;  }  implicit  .  appendChild  (  child  )  ;      Element  root  =  addChildToParent  (  implicit  ,  false  )  ;  [ATTENTION]      parent  .  appendChild  (  child  )  ;    if  (  !isEmptyElement  )  stack  .  addLast  (  child  )  ;  return  parent  ;  }    [METHOD]  addChildToParent  [TYPE]  Element  [PARAMETER]  Element  child  boolean  isEmptyElement  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  isEmptyElement  true  validAncestor  [TYPE]  Element  child  head  implicit  parent  root  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  href  html  key  rawText  tagName  text  value  [TYPE]  Tag  bodyTag  childTag  headTag  htmlTag  parentTag  tag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[REPLACE]  stack  .  addLast  (  child  )  ;	[BUGGY]  stack  .  add  (  implicit  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  private  Element  addChildToParent  (  Element  child  ,  boolean  isEmptyElement  )  {  Element  parent  =  popStackToSuitableContainer  (  child  .  tag  (  )  )  ;  Tag  childTag  =  child  .  tag  (  )  ;  boolean  validAncestor  =  stackHasValidParent  (  childTag  )  ;    if  (  !validAncestor  )  {    Tag  parentTag  =  childTag  .  getImplicitParent  (  )  ;  Element  implicit  =  new  Element  (  parentTag  ,  baseUri  )  ;    if  (  child  .  tag  (  )  .  equals  (  bodyTag  )  )  {  Element  head  =  new  Element  (  headTag  ,  baseUri  )  ;  implicit  .  appendChild  (  head  )  ;  }  implicit  .  appendChild  (  child  )  ;      Element  root  =  addChildToParent  (  implicit  ,  false  )  ;  if  (  !isEmptyElement  )  [ATTENTION]  stack  .  add  (  implicit  )    ;  return  root  ;  }  parent  .  appendChild  (  child  )  ;    if  (  !isEmptyElement  )  stack  .  addLast  (  child  )  ;  return  parent  ;  }    [METHOD]  addChildToParent  [TYPE]  Element  [PARAMETER]  Element  child  boolean  isEmptyElement  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  isEmptyElement  true  validAncestor  [TYPE]  Element  child  head  implicit  parent  root  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  href  html  key  rawText  tagName  text  value  [TYPE]  Tag  bodyTag  childTag  headTag  htmlTag  parentTag  tag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[REPLACE]  return  root;	[BUGGY]  return  parent  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  private  Element  addChildToParent  (  Element  child  ,  boolean  isEmptyElement  )  {  Element  parent  =  popStackToSuitableContainer  (  child  .  tag  (  )  )  ;  Tag  childTag  =  child  .  tag  (  )  ;  boolean  validAncestor  =  stackHasValidParent  (  childTag  )  ;    if  (  !validAncestor  )  {    Tag  parentTag  =  childTag  .  getImplicitParent  (  )  ;  Element  implicit  =  new  Element  (  parentTag  ,  baseUri  )  ;    if  (  child  .  tag  (  )  .  equals  (  bodyTag  )  )  {  Element  head  =  new  Element  (  headTag  ,  baseUri  )  ;  implicit  .  appendChild  (  head  )  ;  }  implicit  .  appendChild  (  child  )  ;      Element  root  =  addChildToParent  (  implicit  ,  false  )  ;  if  (  !isEmptyElement  )  stack  .  addLast  (  child  )  ;  [ATTENTION]  return  parent  ;  }  parent  .  appendChild  (  child  )  ;    if  (  !isEmptyElement  )  stack  .  addLast  (  child  )  ;  return  parent  ;  }    [METHOD]  addChildToParent  [TYPE]  Element  [PARAMETER]  Element  child  boolean  isEmptyElement  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  isEmptyElement  true  validAncestor  [TYPE]  Element  child  head  implicit  parent  root  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  href  html  key  rawText  tagName  text  value  [TYPE]  Tag  bodyTag  childTag  headTag  htmlTag  parentTag  tag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[REPLACE]  Tag  parentTag  =  childTag  .  getImplicitParent  (  )  ;	[BUGGY]  Tag  parentTag  =  titleTag  .  getImplicitParent  (  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  private  Element  addChildToParent  (  Element  child  ,  boolean  isEmptyElement  )  {  Element  parent  =  popStackToSuitableContainer  (  child  .  tag  (  )  )  ;  Tag  childTag  =  child  .  tag  (  )  ;  boolean  validAncestor  =  stackHasValidParent  (  childTag  )  ;    if  (  !validAncestor  )  {    [ATTENTION]  Tag  parentTag  =  titleTag  .  getImplicitParent  (  )    ;  Element  implicit  =  new  Element  (  parentTag  ,  baseUri  )  ;    if  (  child  .  tag  (  )  .  equals  (  bodyTag  )  )  {  Element  head  =  new  Element  (  headTag  ,  baseUri  )  ;  implicit  .  appendChild  (  head  )  ;  }  implicit  .  appendChild  (  child  )  ;      Element  root  =  addChildToParent  (  implicit  ,  false  )  ;  if  (  !isEmptyElement  )  stack  .  addLast  (  child  )  ;  return  root  ;  }  parent  .  appendChild  (  child  )  ;    if  (  !isEmptyElement  )  stack  .  addLast  (  child  )  ;  return  parent  ;  }    [METHOD]  addChildToParent  [TYPE]  Element  [PARAMETER]  Element  child  boolean  isEmptyElement  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  isEmptyElement  true  validAncestor  [TYPE]  Element  child  head  implicit  parent  root  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  href  html  key  rawText  tagName  text  value  [TYPE]  Tag  bodyTag  childTag  headTag  htmlTag  parentTag  tag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[ADD]  Tag  parentTag  =  childTag  .  getImplicitParent  (  )  ;	[BUGGY]  [CE]  cannot  find  symbol  parentTag  [CONTEXT]  private  Element  addChildToParent  (  Element  child  ,  boolean  isEmptyElement  )  {  Element  parent  =  popStackToSuitableContainer  (  child  .  tag  (  )  )  ;  Tag  childTag  =  child  .  tag  (  )  ;  boolean  validAncestor  =  stackHasValidParent  (  childTag  )  ;    if  (  !validAncestor  )  {    [ATTENTION]  Element  implicit  =  new  Element  (  parentTag  ,  baseUri  )  ;    if  (  child  .  tag  (  )  .  equals  (  bodyTag  )  )  {  Element  head  =  new  Element  (  headTag  ,  baseUri  )  ;  implicit  .  appendChild  (  head  )  ;  }  implicit  .  appendChild  (  child  )  ;      Element  root  =  addChildToParent  (  implicit  ,  false  )  ;  if  (  !isEmptyElement  )  stack  .  addLast  (  child  )  ;  return  root  ;  }  parent  .  appendChild  (  child  )  ;    if  (  !isEmptyElement  )  stack  .  addLast  (  child  )  ;  return  parent  ;  }    [METHOD]  addChildToParent  [TYPE]  Element  [PARAMETER]  Element  child  boolean  isEmptyElement  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  isEmptyElement  true  validAncestor  [TYPE]  Element  child  head  implicit  parent  root  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  href  html  key  rawText  tagName  text  value  [TYPE]  Tag  bodyTag  childTag  headTag  htmlTag  parentTag  tag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[REPLACE]  Element  implicit  =  new  Element  (  parentTag,  baseUri  )  ;	[BUGGY]  Element  implicit  =  new  Element  (  titleTag  ,  baseUri  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  private  Element  addChildToParent  (  Element  child  ,  boolean  isEmptyElement  )  {  Element  parent  =  popStackToSuitableContainer  (  child  .  tag  (  )  )  ;  Tag  childTag  =  child  .  tag  (  )  ;  boolean  validAncestor  =  stackHasValidParent  (  childTag  )  ;    if  (  !validAncestor  )  {    Tag  parentTag  =  childTag  .  getImplicitParent  (  )  ;  [ATTENTION]  Element  implicit  =  new  Element  (  titleTag  ,  baseUri  )    ;    if  (  child  .  tag  (  )  .  equals  (  bodyTag  )  )  {  Element  head  =  new  Element  (  headTag  ,  baseUri  )  ;  implicit  .  appendChild  (  head  )  ;  }  implicit  .  appendChild  (  child  )  ;      Element  root  =  addChildToParent  (  implicit  ,  false  )  ;  if  (  !isEmptyElement  )  stack  .  addLast  (  child  )  ;  return  root  ;  }  parent  .  appendChild  (  child  )  ;    if  (  !isEmptyElement  )  stack  .  addLast  (  child  )  ;  return  parent  ;  }    [METHOD]  addChildToParent  [TYPE]  Element  [PARAMETER]  Element  child  boolean  isEmptyElement  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  isEmptyElement  true  validAncestor  [TYPE]  Element  child  head  implicit  parent  root  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  href  html  key  rawText  tagName  text  value  [TYPE]  Tag  bodyTag  childTag  headTag  htmlTag  parentTag  tag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[REPLACE]  Element  root  =  addChildToParent  (  implicit,  false  )  ;	[BUGGY]  Element  root  =  addChildToParent  (  implicit  ,  true  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  private  Element  addChildToParent  (  Element  child  ,  boolean  isEmptyElement  )  {  Element  parent  =  popStackToSuitableContainer  (  child  .  tag  (  )  )  ;  Tag  childTag  =  child  .  tag  (  )  ;  boolean  validAncestor  =  stackHasValidParent  (  childTag  )  ;    if  (  !validAncestor  )  {    Tag  parentTag  =  childTag  .  getImplicitParent  (  )  ;  Element  implicit  =  new  Element  (  parentTag  ,  baseUri  )  ;    if  (  child  .  tag  (  )  .  equals  (  bodyTag  )  )  {  Element  head  =  new  Element  (  headTag  ,  baseUri  )  ;  implicit  .  appendChild  (  head  )  ;  }  implicit  .  appendChild  (  child  )  ;      [ATTENTION]  Element  root  =  addChildToParent  (  implicit  ,  true  )    ;  if  (  !isEmptyElement  )  stack  .  addLast  (  child  )  ;  return  root  ;  }  parent  .  appendChild  (  child  )  ;    if  (  !isEmptyElement  )  stack  .  addLast  (  child  )  ;  return  parent  ;  }    [METHOD]  addChildToParent  [TYPE]  Element  [PARAMETER]  Element  child  boolean  isEmptyElement  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  isEmptyElement  true  validAncestor  [TYPE]  Element  child  head  implicit  parent  root  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  href  html  key  rawText  tagName  text  value  [TYPE]  Tag  bodyTag  childTag  headTag  htmlTag  parentTag  tag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[REPLACE]  if  (  child  .  tag  (  )    .  equals  (  bodyTag  )  )  {	[BUGGY]  if  (  child  .  tag  (  )  .  canContain  (  bodyTag  )  )  {[FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  private  Element  addChildToParent  (  Element  child  ,  boolean  isEmptyElement  )  {  Element  parent  =  popStackToSuitableContainer  (  child  .  tag  (  )  )  ;  Tag  childTag  =  child  .  tag  (  )  ;  boolean  validAncestor  =  stackHasValidParent  (  childTag  )  ;    if  (  !validAncestor  )  {    Tag  parentTag  =  childTag  .  getImplicitParent  (  )  ;  Element  implicit  =  new  Element  (  parentTag  ,  baseUri  )  ;    [ATTENTION]  if  (  child  .  tag  (  )    .  canContain  (  bodyTag  )  )  {  Element  head  =  new  Element  (  headTag  ,  baseUri  )  ;  implicit  .  appendChild  (  head  )  ;  }  implicit  .  appendChild  (  child  )  ;      Element  root  =  addChildToParent  (  implicit  ,  false  )  ;  if  (  !isEmptyElement  )  stack  .  addLast  (  child  )  ;  return  root  ;  }  parent  .  appendChild  (  child  )  ;    if  (  !isEmptyElement  )  stack  .  addLast  (  child  )  ;  return  parent  ;  }    [METHOD]  addChildToParent  [TYPE]  Element  [PARAMETER]  Element  child  boolean  isEmptyElement  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  isEmptyElement  true  validAncestor  [TYPE]  Element  child  head  implicit  parent  root  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  href  html  key  rawText  tagName  text  value  [TYPE]  Tag  bodyTag  childTag  headTag  htmlTag  parentTag  tag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[ADD]  if  (  child  .  tag  (  )    .  equals  (  bodyTag  )  )  {  Element  head  =  new  Element  (  headTag,  baseUri  )  ;  implicit  .  appendChild  (  head  )  ;  }	[BUGGY]  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  private  Element  addChildToParent  (  Element  child  ,  boolean  isEmptyElement  )  {  Element  parent  =  popStackToSuitableContainer  (  child  .  tag  (  )  )  ;  Tag  childTag  =  child  .  tag  (  )  ;  boolean  validAncestor  =  stackHasValidParent  (  childTag  )  ;    if  (  !validAncestor  )  {    Tag  parentTag  =  childTag  .  getImplicitParent  (  )  ;  Element  implicit  =  new  Element  (  parentTag  ,  baseUri  )  ;    [ATTENTION]      implicit  .  appendChild  (  child  )  ;      Element  root  =  addChildToParent  (  implicit  ,  false  )  ;  if  (  !isEmptyElement  )  stack  .  addLast  (  child  )  ;  return  root  ;  }  parent  .  appendChild  (  child  )  ;    if  (  !isEmptyElement  )  stack  .  addLast  (  child  )  ;  return  parent  ;  }    [METHOD]  addChildToParent  [TYPE]  Element  [PARAMETER]  Element  child  boolean  isEmptyElement  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  isEmptyElement  true  validAncestor  [TYPE]  Element  child  head  implicit  parent  root  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  href  html  key  rawText  tagName  text  value  [TYPE]  Tag  bodyTag  childTag  headTag  htmlTag  parentTag  tag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[REPLACE]  if  (  !isEmptyElement  )  stack  .  addLast  (  child  )  ;	[BUGGY]  if  (  !isEmptyElement  )  stack  .  addLast  (  implicit  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  private  Element  addChildToParent  (  Element  child  ,  boolean  isEmptyElement  )  {  Element  parent  =  popStackToSuitableContainer  (  child  .  tag  (  )  )  ;  Tag  childTag  =  child  .  tag  (  )  ;  boolean  validAncestor  =  stackHasValidParent  (  childTag  )  ;    if  (  !validAncestor  )  {    Tag  parentTag  =  childTag  .  getImplicitParent  (  )  ;  Element  implicit  =  new  Element  (  parentTag  ,  baseUri  )  ;    if  (  child  .  tag  (  )  .  equals  (  bodyTag  )  )  {  Element  head  =  new  Element  (  headTag  ,  baseUri  )  ;  implicit  .  appendChild  (  head  )  ;  }  implicit  .  appendChild  (  child  )  ;      Element  root  =  addChildToParent  (  implicit  ,  false  )  ;  [ATTENTION]  if  (  !isEmptyElement  )  stack  .  addLast  (  implicit  )    ;    return  root  ;  }  parent  .  appendChild  (  child  )  ;    if  (  !isEmptyElement  )  stack  .  addLast  (  child  )  ;  return  parent  ;  }    [METHOD]  addChildToParent  [TYPE]  Element  [PARAMETER]  Element  child  boolean  isEmptyElement  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  isEmptyElement  true  validAncestor  [TYPE]  Element  child  head  implicit  parent  root  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  href  html  key  rawText  tagName  text  value  [TYPE]  Tag  bodyTag  childTag  headTag  htmlTag  parentTag  tag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[REPLACE]  stack  .  addLast  (  child  )  ;	[BUGGY]  stack  .  addLast  (  implicit  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  private  Element  addChildToParent  (  Element  child  ,  boolean  isEmptyElement  )  {  Element  parent  =  popStackToSuitableContainer  (  child  .  tag  (  )  )  ;  Tag  childTag  =  child  .  tag  (  )  ;  boolean  validAncestor  =  stackHasValidParent  (  childTag  )  ;    if  (  !validAncestor  )  {    Tag  parentTag  =  childTag  .  getImplicitParent  (  )  ;  Element  implicit  =  new  Element  (  parentTag  ,  baseUri  )  ;    if  (  child  .  tag  (  )  .  equals  (  bodyTag  )  )  {  Element  head  =  new  Element  (  headTag  ,  baseUri  )  ;  implicit  .  appendChild  (  head  )  ;  }  implicit  .  appendChild  (  child  )  ;      Element  root  =  addChildToParent  (  implicit  ,  false  )  ;  if  (  !isEmptyElement  )  [ATTENTION]  stack  .  addLast  (  implicit  )    ;  return  root  ;  }  parent  .  appendChild  (  child  )  ;    if  (  !isEmptyElement  )  stack  .  addLast  (  child  )  ;  return  parent  ;  }    [METHOD]  addChildToParent  [TYPE]  Element  [PARAMETER]  Element  child  boolean  isEmptyElement  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  isEmptyElement  true  validAncestor  [TYPE]  Element  child  head  implicit  parent  root  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  href  html  key  rawText  tagName  text  value  [TYPE]  Tag  bodyTag  childTag  headTag  htmlTag  parentTag  tag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[ADD]  stack  .  addLast  (  child  )  ;  return  root;	[BUGGY]  return  root  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  private  Element  addChildToParent  (  Element  child  ,  boolean  isEmptyElement  )  {  Element  parent  =  popStackToSuitableContainer  (  child  .  tag  (  )  )  ;  Tag  childTag  =  child  .  tag  (  )  ;  boolean  validAncestor  =  stackHasValidParent  (  childTag  )  ;    if  (  !validAncestor  )  {    Tag  parentTag  =  childTag  .  getImplicitParent  (  )  ;  Element  implicit  =  new  Element  (  parentTag  ,  baseUri  )  ;    if  (  child  .  tag  (  )  .  equals  (  bodyTag  )  )  {  Element  head  =  new  Element  (  headTag  ,  baseUri  )  ;  implicit  .  appendChild  (  head  )  ;  }  implicit  .  appendChild  (  child  )  ;      Element  root  =  addChildToParent  (  implicit  ,  false  )  ;  if  (  !isEmptyElement  )  [ATTENTION]  return  root  ;    }  parent  .  appendChild  (  child  )  ;    if  (  !isEmptyElement  )  stack  .  addLast  (  child  )  ;  return  parent  ;  }    [METHOD]  addChildToParent  [TYPE]  Element  [PARAMETER]  Element  child  boolean  isEmptyElement  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  isEmptyElement  true  validAncestor  [TYPE]  Element  child  head  implicit  parent  root  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  href  html  key  rawText  tagName  text  value  [TYPE]  Tag  bodyTag  childTag  headTag  htmlTag  parentTag  tag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[REPLACE]  Element  root  =  addChildToParent  (  implicit,  false  )  ;	[BUGGY]  Element  root  =  addChildToParent  (  root  ,  true  )  ;  [CE]  variable  root  might  not  have  been  initialized  [CONTEXT]  private  Element  addChildToParent  (  Element  child  ,  boolean  isEmptyElement  )  {  Element  parent  =  popStackToSuitableContainer  (  child  .  tag  (  )  )  ;  Tag  childTag  =  child  .  tag  (  )  ;  boolean  validAncestor  =  stackHasValidParent  (  childTag  )  ;    if  (  !validAncestor  )  {    Tag  parentTag  =  childTag  .  getImplicitParent  (  )  ;  Element  implicit  =  new  Element  (  parentTag  ,  baseUri  )  ;    if  (  child  .  tag  (  )  .  equals  (  bodyTag  )  )  {  Element  head  =  new  Element  (  headTag  ,  baseUri  )  ;  implicit  .  appendChild  (  head  )  ;  }  implicit  .  appendChild  (  child  )  ;      [ATTENTION]  Element  root  =  addChildToParent  (  root  ,  true  )    ;  if  (  !isEmptyElement  )  stack  .  addLast  (  child  )  ;  return  root  ;  }  parent  .  appendChild  (  child  )  ;    if  (  !isEmptyElement  )  stack  .  addLast  (  child  )  ;  return  parent  ;  }    [METHOD]  addChildToParent  [TYPE]  Element  [PARAMETER]  Element  child  boolean  isEmptyElement  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  isEmptyElement  true  validAncestor  [TYPE]  Element  child  head  implicit  parent  root  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  href  html  key  rawText  tagName  text  value  [TYPE]  Tag  bodyTag  childTag  headTag  htmlTag  parentTag  tag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[REPLACE]  parent  .  appendChild  (  child  )  ;	[BUGGY]  parent  .  absUrl  (  text  )    ;  [CE]  cannot  find  symbol  text  [CONTEXT]  private  Element  addChildToParent  (  Element  child  ,  boolean  isEmptyElement  )  {  Element  parent  =  popStackToSuitableContainer  (  child  .  tag  (  )  )  ;  Tag  childTag  =  child  .  tag  (  )  ;  boolean  validAncestor  =  stackHasValidParent  (  childTag  )  ;    if  (  !validAncestor  )  {    Tag  parentTag  =  childTag  .  getImplicitParent  (  )  ;  Element  implicit  =  new  Element  (  parentTag  ,  baseUri  )  ;    if  (  child  .  tag  (  )  .  equals  (  bodyTag  )  )  {  Element  head  =  new  Element  (  headTag  ,  baseUri  )  ;  implicit  .  appendChild  (  head  )  ;  }  implicit  .  appendChild  (  child  )  ;      Element  root  =  addChildToParent  (  implicit  ,  false  )  ;  if  (  !isEmptyElement  )  stack  .  addLast  (  child  )  ;  return  root  ;  }  [ATTENTION]  parent  .  absUrl  (  text  )  ;    if  (  !isEmptyElement  )  stack  .  addLast  (  child  )  ;  return  parent  ;  }    [METHOD]  addChildToParent  [TYPE]  Element  [PARAMETER]  Element  child  boolean  isEmptyElement  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  isEmptyElement  true  validAncestor  [TYPE]  Element  child  head  implicit  parent  root  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  href  html  key  rawText  tagName  text  value  [TYPE]  Tag  bodyTag  childTag  headTag  htmlTag  parentTag  tag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[ADD]  parent  .  appendChild  (  child  )  ;	[BUGGY]  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  private  Element  addChildToParent  (  Element  child  ,  boolean  isEmptyElement  )  {  Element  parent  =  popStackToSuitableContainer  (  child  .  tag  (  )  )  ;  Tag  childTag  =  child  .  tag  (  )  ;  boolean  validAncestor  =  stackHasValidParent  (  childTag  )  ;    if  (  !validAncestor  )  {    Tag  parentTag  =  childTag  .  getImplicitParent  (  )  ;  Element  implicit  =  new  Element  (  parentTag  ,  baseUri  )  ;    if  (  child  .  tag  (  )  .  equals  (  bodyTag  )  )  {  Element  head  =  new  Element  (  headTag  ,  baseUri  )  ;  implicit  .  appendChild  (  head  )  ;  }  implicit  .  appendChild  (  child  )  ;      Element  root  =  addChildToParent  (  implicit  ,  false  )  ;  if  (  !isEmptyElement  )  stack  .  addLast  (  child  )  ;  return  root  ;  }  [ATTENTION]    if  (  !isEmptyElement  )  stack  .  addLast  (  child  )  ;  return  parent  ;  }    [METHOD]  addChildToParent  [TYPE]  Element  [PARAMETER]  Element  child  boolean  isEmptyElement  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  isEmptyElement  true  validAncestor  [TYPE]  Element  child  head  implicit  parent  root  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  href  html  key  rawText  tagName  text  value  [TYPE]  Tag  bodyTag  childTag  headTag  htmlTag  parentTag  tag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[REPLACE]  if  (  !isEmptyElement  )  stack  .  addLast  (  child  )  ;	[BUGGY]  if  (  !validAncestor  )  stack  .  addLast  (  child  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  private  Element  addChildToParent  (  Element  child  ,  boolean  isEmptyElement  )  {  Element  parent  =  popStackToSuitableContainer  (  child  .  tag  (  )  )  ;  Tag  childTag  =  child  .  tag  (  )  ;  boolean  validAncestor  =  stackHasValidParent  (  childTag  )  ;    if  (  !validAncestor  )  {    Tag  parentTag  =  childTag  .  getImplicitParent  (  )  ;  Element  implicit  =  new  Element  (  parentTag  ,  baseUri  )  ;    if  (  child  .  tag  (  )  .  equals  (  bodyTag  )  )  {  Element  head  =  new  Element  (  headTag  ,  baseUri  )  ;  implicit  .  appendChild  (  head  )  ;  }  implicit  .  appendChild  (  child  )  ;      Element  root  =  addChildToParent  (  implicit  ,  false  )  ;  if  (  !isEmptyElement  )  stack  .  addLast  (  child  )  ;  return  root  ;  }  parent  .  appendChild  (  child  )  ;    [ATTENTION]  if  (  !validAncestor  )  stack  .  addLast  (  child  )    ;    return  parent  ;  }    [METHOD]  addChildToParent  [TYPE]  Element  [PARAMETER]  Element  child  boolean  isEmptyElement  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  isEmptyElement  true  validAncestor  [TYPE]  Element  child  head  implicit  parent  root  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  href  html  key  rawText  tagName  text  value  [TYPE]  Tag  bodyTag  childTag  headTag  htmlTag  parentTag  tag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[ADD]  if  (  !isEmptyElement  )  stack  .  addLast  (  child  )  ;  return  parent;  }	[BUGGY]  stack  .  addLast  (  child  )  ;  return  parent  ;  [CE]  illegal  start  of  expression  [CONTEXT]  private  Element  addChildToParent  (  Element  child  ,  boolean  isEmptyElement  )  {  Element  parent  =  popStackToSuitableContainer  (  child  .  tag  (  )  )  ;  Tag  childTag  =  child  .  tag  (  )  ;  boolean  validAncestor  =  stackHasValidParent  (  childTag  )  ;    if  (  !validAncestor  )  {    Tag  parentTag  =  childTag  .  getImplicitParent  (  )  ;  Element  implicit  =  new  Element  (  parentTag  ,  baseUri  )  ;    if  (  child  .  tag  (  )  .  equals  (  bodyTag  )  )  {  Element  head  =  new  Element  (  headTag  ,  baseUri  )  ;  implicit  .  appendChild  (  head  )  ;  }  implicit  .  appendChild  (  child  )  ;      Element  root  =  addChildToParent  (  implicit  ,  false  )  ;  if  (  !isEmptyElement  )  stack  .  addLast  (  child  )  ;  return  root  ;  }  parent  .  appendChild  (  child  )  ;    [ATTENTION]  stack  .  addLast  (  child  )    ;  return  parent  ;        [METHOD]  addChildToParent  [TYPE]  Element  [PARAMETER]  Element  child  boolean  isEmptyElement  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  isEmptyElement  true  validAncestor  [TYPE]  Element  child  head  implicit  parent  root  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  href  html  key  rawText  tagName  text  value  [TYPE]  Tag  bodyTag  childTag  headTag  htmlTag  parentTag  tag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[REPLACE]  stack  .  addLast  (  child  )  ;	[BUGGY]  stack  .  addLast  (  implicit  )  ;  [CE]  cannot  find  symbol  implicit  [CONTEXT]  private  Element  addChildToParent  (  Element  child  ,  boolean  isEmptyElement  )  {  Element  parent  =  popStackToSuitableContainer  (  child  .  tag  (  )  )  ;  Tag  childTag  =  child  .  tag  (  )  ;  boolean  validAncestor  =  stackHasValidParent  (  childTag  )  ;    if  (  !validAncestor  )  {    Tag  parentTag  =  childTag  .  getImplicitParent  (  )  ;  Element  implicit  =  new  Element  (  parentTag  ,  baseUri  )  ;    if  (  child  .  tag  (  )  .  equals  (  bodyTag  )  )  {  Element  head  =  new  Element  (  headTag  ,  baseUri  )  ;  implicit  .  appendChild  (  head  )  ;  }  implicit  .  appendChild  (  child  )  ;      Element  root  =  addChildToParent  (  implicit  ,  false  )  ;  if  (  !isEmptyElement  )  stack  .  addLast  (  child  )  ;  return  root  ;  }  parent  .  appendChild  (  child  )  ;    if  (  !isEmptyElement  )  [ATTENTION]  stack  .  addLast  (  implicit  )    ;  return  parent  ;  }    [METHOD]  addChildToParent  [TYPE]  Element  [PARAMETER]  Element  child  boolean  isEmptyElement  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  isEmptyElement  true  validAncestor  [TYPE]  Element  child  head  implicit  parent  root  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  href  html  key  rawText  tagName  text  value  [TYPE]  Tag  bodyTag  childTag  headTag  htmlTag  parentTag  tag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[REPLACE]  return  parent;	[BUGGY]  return  stack  .  getLast  (  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  private  Element  addChildToParent  (  Element  child  ,  boolean  isEmptyElement  )  {  Element  parent  =  popStackToSuitableContainer  (  child  .  tag  (  )  )  ;  Tag  childTag  =  child  .  tag  (  )  ;  boolean  validAncestor  =  stackHasValidParent  (  childTag  )  ;    if  (  !validAncestor  )  {    Tag  parentTag  =  childTag  .  getImplicitParent  (  )  ;  Element  implicit  =  new  Element  (  parentTag  ,  baseUri  )  ;    if  (  child  .  tag  (  )  .  equals  (  bodyTag  )  )  {  Element  head  =  new  Element  (  headTag  ,  baseUri  )  ;  implicit  .  appendChild  (  head  )  ;  }  implicit  .  appendChild  (  child  )  ;      Element  root  =  addChildToParent  (  implicit  ,  false  )  ;  if  (  !isEmptyElement  )  stack  .  addLast  (  child  )  ;  return  root  ;  }  parent  .  appendChild  (  child  )  ;    if  (  !isEmptyElement  )  stack  .  addLast  (  child  )  ;  [ATTENTION]  return  stack  .  getLast  (  )    ;  }    [METHOD]  addChildToParent  [TYPE]  Element  [PARAMETER]  Element  child  boolean  isEmptyElement  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  isEmptyElement  true  validAncestor  [TYPE]  Element  child  head  implicit  parent  root  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  href  html  key  rawText  tagName  text  value  [TYPE]  Tag  bodyTag  childTag  headTag  htmlTag  parentTag  tag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[REPLACE]  if  (  stack  .  size  (  )  ==  1  &&  childTag  .  equals  (  htmlTag  )  )  return  true;	[BUGGY]  if  (  stack  .  get  (  )  -  3  =  =  0  &&  childTag  .  equals  (  htmlTag  )  )  return  true  ;  [CE]  no  suitable  method  found  for  get()  [CONTEXT]  private  boolean  stackHasValidParent  (  Tag  childTag  )  {  [ATTENTION]  if  (  stack  .  get  (  )  -  3  =  =  0&&  childTag  .  equals  (  htmlTag  )  )  return  true  ;    for  (  int  i  =  stack  .  size  (  )  -1  ;  i  >  =  0  ;  i--  )  {  Element  el  =  stack  .  get  (  i  )  ;  Tag  parent2  =  el  .  tag  (  )  ;  if  (  parent2  .  isValidParent  (  childTag  )  )  {  return  true  ;  }  }  return  false  ;  }    [METHOD]  stackHasValidParent  [TYPE]  boolean  [PARAMETER]  Tag  childTag  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  Element  el  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  href  html  key  rawText  tagName  text  value  [TYPE]  Tag  bodyTag  childTag  headTag  htmlTag  parent2  parentTag  tag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  [TYPE]  int  i  
[REPLACE]  return  true;	[BUGGY]  return  false  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  private  boolean  stackHasValidParent  (  Tag  childTag  )  {  if  (  stack  .  size  (  )    =  =  1  &&  childTag  .  equals  (  htmlTag  )  )  [ATTENTION]  return  false  ;    for  (  int  i  =  stack  .  size  (  )  -1  ;  i  >  =  0  ;  i--  )  {  Element  el  =  stack  .  get  (  i  )  ;  Tag  parent2  =  el  .  tag  (  )  ;  if  (  parent2  .  isValidParent  (  childTag  )  )  {  return  true  ;  }  }  return  false  ;  }    [METHOD]  stackHasValidParent  [TYPE]  boolean  [PARAMETER]  Tag  childTag  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  Element  el  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  href  html  key  rawText  tagName  text  value  [TYPE]  Tag  bodyTag  childTag  headTag  htmlTag  parent2  parentTag  tag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  [TYPE]  int  i  
[REPLACE]  if  (  parent2  .  isValidParent  (  childTag  )  )  {	[BUGGY]  if  (  parent2  .  equals  (  childTag  )  )  {[FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  private  boolean  stackHasValidParent  (  Tag  childTag  )  {  if  (  stack  .  size  (  )    =  =  1  &&  childTag  .  equals  (  htmlTag  )  )  return  true  ;  //  root  is  valid  for  html  node  for  (  int  i  =  stack  .  size  (  )  -1  ;  i  >  =  0  ;  i--  )  {  Element  el  =  stack  .  get  (  i  )  ;  Tag  parent2  =  el  .  tag  (  )  ;  [ATTENTION]  if  (  parent2  .  equals  (  childTag  )  )  {  return  true  ;  }  }  return  false  ;  }    [METHOD]  stackHasValidParent  [TYPE]  boolean  [PARAMETER]  Tag  childTag  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  Element  el  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  href  html  key  rawText  tagName  text  value  [TYPE]  Tag  bodyTag  childTag  headTag  htmlTag  parent2  parentTag  tag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  [TYPE]  int  i  
[REPLACE]  return  true;	[BUGGY]  return  false  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  private  boolean  stackHasValidParent  (  Tag  childTag  )  {  if  (  stack  .  size  (  )    =  =  1  &&  childTag  .  equals  (  htmlTag  )  )  return  true  ;  //  root  is  valid  for  html  node  for  (  int  i  =  stack  .  size  (  )  -1  ;  i  >  =  0  ;  i--  )  {  Element  el  =  stack  .  get  (  i  )  ;  Tag  parent2  =  el  .  tag  (  )  ;  if  (  parent2  .  isValidParent  (  childTag  )  )  {  [ATTENTION]  return  false  ;  }  }  return  false  ;  }    [METHOD]  stackHasValidParent  [TYPE]  boolean  [PARAMETER]  Tag  childTag  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  Element  el  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  href  html  key  rawText  tagName  text  value  [TYPE]  Tag  bodyTag  childTag  headTag  htmlTag  parent2  parentTag  tag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  [TYPE]  int  i  
[REPLACE]  for  (  int  i  =  stack  .  size  (  )  -1;  i  >=  0;  i--  )  {	[BUGGY]  for  (  int  i  =  stack  .  size  (  )  +  1  -1  ;  i  >  =  0  ;  i--  )  {[FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  private  boolean  stackHasValidParent  (  Tag  childTag  )  {  if  (  stack  .  size  (  )    =  =  1  &&  childTag  .  equals  (  htmlTag  )  )  return  true  ;  //  root  is  valid  for  html  node  [ATTENTION]  for  (  int  i  =  stack  .  size  (  )  +  1  -1  ;  i  >  =  0  ;  i--  )  {  Element  el  =  stack  .  get  (  i  )  ;  Tag  parent2  =  el  .  tag  (  )  ;  if  (  parent2  .  isValidParent  (  childTag  )  )  {  return  true  ;  }  }  return  false  ;  }    [METHOD]  stackHasValidParent  [TYPE]  boolean  [PARAMETER]  Tag  childTag  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  Element  el  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  href  html  key  rawText  tagName  text  value  [TYPE]  Tag  bodyTag  childTag  headTag  htmlTag  parent2  parentTag  tag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  [TYPE]  int  i  
[REPLACE]  Element  el  =  stack  .  get  (  i  )  ;	[BUGGY]  Element  el  =  stack  .  getLast  (  )    ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  private  boolean  stackHasValidParent  (  Tag  childTag  )  {  if  (  stack  .  size  (  )    =  =  1  &&  childTag  .  equals  (  htmlTag  )  )  return  true  ;  //  root  is  valid  for  html  node  for  (  int  i  =  stack  .  size  (  )  -1  ;  i  >  =  0  ;  i--  )  {  [ATTENTION]  Element  el  =  stack  .  getLast  (  )  ;  Tag  parent2  =  el  .  tag  (  )  ;  if  (  parent2  .  isValidParent  (  childTag  )  )  {  return  true  ;  }  }  return  false  ;  }    [METHOD]  stackHasValidParent  [TYPE]  boolean  [PARAMETER]  Tag  childTag  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  Element  el  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  href  html  key  rawText  tagName  text  value  [TYPE]  Tag  bodyTag  childTag  headTag  htmlTag  parent2  parentTag  tag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  [TYPE]  int  i  
[REPLACE]  Tag  parent2  =  el  .  tag  (  )  ;	[BUGGY]  Tag  parent2  =  el  .  tagName  (  )  ;  [CE]  incompatible  types  [CONTEXT]  private  boolean  stackHasValidParent  (  Tag  childTag  )  {  if  (  stack  .  size  (  )    =  =  1  &&  childTag  .  equals  (  htmlTag  )  )  return  true  ;  //  root  is  valid  for  html  node  for  (  int  i  =  stack  .  size  (  )  -1  ;  i  >  =  0  ;  i--  )  {  Element  el  =  stack  .  get  (  i  )  ;  [ATTENTION]  Tag  parent2  =  el  .  tagName  (  )    ;  if  (  parent2  .  isValidParent  (  childTag  )  )  {  return  true  ;  }  }  return  false  ;  }    [METHOD]  stackHasValidParent  [TYPE]  boolean  [PARAMETER]  Tag  childTag  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  Element  el  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  href  html  key  rawText  tagName  text  value  [TYPE]  Tag  bodyTag  childTag  headTag  htmlTag  parent2  parentTag  tag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  [TYPE]  int  i  
[ADD]  Tag  parent2  =  el  .  tag  (  )  ;	[BUGGY]  [CE]  cannot  find  symbol  parent2  [CONTEXT]  private  boolean  stackHasValidParent  (  Tag  childTag  )  {  if  (  stack  .  size  (  )    =  =  1  &&  childTag  .  equals  (  htmlTag  )  )  return  true  ;  //  root  is  valid  for  html  node  for  (  int  i  =  stack  .  size  (  )  -1  ;  i  >  =  0  ;  i--  )  {  Element  el  =  stack  .  get  (  i  )  ;  [ATTENTION]  if  (  parent2  .  isValidParent  (  childTag  )  )  {  return  true  ;  }  }  return  false  ;  }    [METHOD]  stackHasValidParent  [TYPE]  boolean  [PARAMETER]  Tag  childTag  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  Element  el  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  href  html  key  rawText  tagName  text  value  [TYPE]  Tag  bodyTag  childTag  headTag  htmlTag  parent2  parentTag  tag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  [TYPE]  int  i  
[REPLACE]  for  (  int  i  =  stack  .  size  (  )  -1;  i  >=  0;  i--  )  {	[BUGGY]  for  (  int  i  =  stack  .  size  (  )  -  5  -0  ;  i  >  =  0  ;  i--  )  {[FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  private  boolean  stackHasValidParent  (  Tag  childTag  )  {  if  (  stack  .  size  (  )    =  =  1  &&  childTag  .  equals  (  htmlTag  )  )  return  true  ;  //  root  is  valid  for  html  node  [ATTENTION]  for  (  int  i  =  stack  .  size  (  )  -  5  -0  ;  i  >  =  0  ;  i--  )  {  Element  el  =  stack  .  get  (  i  )  ;  Tag  parent2  =  el  .  tag  (  )  ;  if  (  parent2  .  isValidParent  (  childTag  )  )  {  return  true  ;  }  }  return  false  ;  }    [METHOD]  stackHasValidParent  [TYPE]  boolean  [PARAMETER]  Tag  childTag  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  Element  el  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  href  html  key  rawText  tagName  text  value  [TYPE]  Tag  bodyTag  childTag  headTag  htmlTag  parent2  parentTag  tag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  [TYPE]  int  i  
[ADD]  for  (  int  i  =  stack  .  size  (  )  -1;  i  >=  0;  i--  )  {  Element  el  =  stack  .  get  (  i  )  ;  Tag  parent2  =  el  .  tag  (  )  ;  if  (  parent2  .  isValidParent  (  childTag  )  )  {  return  true;	[BUGGY]  [CE]  class  ,  interface  ,  or  enum  expected  [CONTEXT]  private  boolean  stackHasValidParent  (  Tag  childTag  )  {  if  (  stack  .  size  (  )    =  =  1  &&  childTag  .  equals  (  htmlTag  )  )  return  true  ;  //  root  is  valid  for  html  node  [ATTENTION]      }  }  return  false  ;  }    [METHOD]  stackHasValidParent  [TYPE]  boolean  [PARAMETER]  Tag  childTag  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  Element  el  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  href  html  key  rawText  tagName  text  value  [TYPE]  Tag  bodyTag  childTag  headTag  htmlTag  parent2  parentTag  tag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  [TYPE]  int  i  
[REPLACE]  Element  el  =  stack  .  get  (  i  )  ;	[BUGGY]  Element  el  =  stack  .  add  (  i  )  ;  [CE]  no  suitable  method  found  for  add(int)  [CONTEXT]  private  boolean  stackHasValidParent  (  Tag  childTag  )  {  if  (  stack  .  size  (  )    =  =  1  &&  childTag  .  equals  (  htmlTag  )  )  return  true  ;  //  root  is  valid  for  html  node  for  (  int  i  =  stack  .  size  (  )  -1  ;  i  >  =  0  ;  i--  )  {  [ATTENTION]  Element  el  =  stack  .  add  (  i  )    ;  Tag  parent2  =  el  .  tag  (  )  ;  if  (  parent2  .  isValidParent  (  childTag  )  )  {  return  true  ;  }  }  return  false  ;  }    [METHOD]  stackHasValidParent  [TYPE]  boolean  [PARAMETER]  Tag  childTag  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  Element  el  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  href  html  key  rawText  tagName  text  value  [TYPE]  Tag  bodyTag  childTag  headTag  htmlTag  parent2  parentTag  tag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  [TYPE]  int  i  
[REPLACE]  return  false;	[BUGGY]  return  true  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  private  boolean  stackHasValidParent  (  Tag  childTag  )  {  if  (  stack  .  size  (  )    =  =  1  &&  childTag  .  equals  (  htmlTag  )  )  return  true  ;  //  root  is  valid  for  html  node  for  (  int  i  =  stack  .  size  (  )  -1  ;  i  >  =  0  ;  i--  )  {  Element  el  =  stack  .  get  (  i  )  ;  Tag  parent2  =  el  .  tag  (  )  ;  if  (  parent2  .  isValidParent  (  childTag  )  )  {  return  true  ;  }  }  [ATTENTION]  return  true  ;  }    [METHOD]  stackHasValidParent  [TYPE]  boolean  [PARAMETER]  Tag  childTag  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  Element  el  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  href  html  key  rawText  tagName  text  value  [TYPE]  Tag  bodyTag  childTag  headTag  htmlTag  parent2  parentTag  tag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  [TYPE]  int  i  
[REPLACE]  if  (  last  (  )    .  tag  (  )    .  canContain  (  tag  )  )  return  last  (  )  ;	[BUGGY]  if  (  last  (  )  .  tag  (  )  .  equals  (  titleTag  )  )  return  last  (  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  private  Element  popStackToSuitableContainer  (  Tag  tag  )  {  while  (  !stack  .  isEmpty  (  )  )  {  [ATTENTION]  if  (  last  (  )    .  tag  (  )    .  equals  (  titleTag  )  )  return  last  (  )    ;    else  stack  .  removeLast  (  )  ;  }  return  null  ;  }    [METHOD]  popStackToSuitableContainer  [TYPE]  Element  [PARAMETER]  Tag  tag  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  href  html  key  rawText  tagName  text  value  [TYPE]  Tag  bodyTag  childTag  headTag  htmlTag  parent2  parentTag  tag  textareaTag  titleTag  [TYPE]  boolean  false  true  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[ADD]  if  (  last  (  )    .  tag  (  )    .  canContain  (  tag  )  )  return  last  (  )  ;  else  stack  .  removeLast  (  )  ;  }	[BUGGY]  return  last  (  )  ;  stack  .  removeLast  (  )  ;  [CE]  illegal  start  of  expression  [CONTEXT]  private  Element  popStackToSuitableContainer  (  Tag  tag  )  {  while  (  !stack  .  isEmpty  (  )  )  {  [ATTENTION]  return  last  (  )    ;  stack  .  removeLast  (  )    ;      return  null  ;  }    [METHOD]  popStackToSuitableContainer  [TYPE]  Element  [PARAMETER]  Tag  tag  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  href  html  key  rawText  tagName  text  value  [TYPE]  Tag  bodyTag  childTag  headTag  htmlTag  parent2  parentTag  tag  textareaTag  titleTag  [TYPE]  boolean  false  true  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[REPLACE]  stack  .  removeLast  (  )  ;	[BUGGY]  stack  .  getLast  (  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  private  Element  popStackToSuitableContainer  (  Tag  tag  )  {  while  (  !stack  .  isEmpty  (  )  )  {  if  (  last  (  )  .  tag  (  )  .  canContain  (  tag  )  )  return  last  (  )  ;  else  [ATTENTION]  stack  .  getLast  (  )    ;  }  return  null  ;  }    [METHOD]  popStackToSuitableContainer  [TYPE]  Element  [PARAMETER]  Tag  tag  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  href  html  key  rawText  tagName  text  value  [TYPE]  Tag  bodyTag  childTag  headTag  htmlTag  parent2  parentTag  tag  textareaTag  titleTag  [TYPE]  boolean  false  true  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[ADD]  stack  .  removeLast  (  )  ;	[BUGGY]  [CE]  illegal  start  of  expression  [CONTEXT]  private  Element  popStackToSuitableContainer  (  Tag  tag  )  {  while  (  !stack  .  isEmpty  (  )  )  {  if  (  last  (  )  .  tag  (  )  .  canContain  (  tag  )  )  return  last  (  )  ;  else  [ATTENTION]  }  return  null  ;  }    [METHOD]  popStackToSuitableContainer  [TYPE]  Element  [PARAMETER]  Tag  tag  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  href  html  key  rawText  tagName  text  value  [TYPE]  Tag  bodyTag  childTag  headTag  htmlTag  parent2  parentTag  tag  textareaTag  titleTag  [TYPE]  boolean  false  true  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[REPLACE]  return  last  (  )  ;	[BUGGY]  return  parent  ;  [CE]  cannot  find  symbol  parent  [CONTEXT]  private  Element  popStackToSuitableContainer  (  Tag  tag  )  {  while  (  !stack  .  isEmpty  (  )  )  {  if  (  last  (  )  .  tag  (  )  .  canContain  (  tag  )  )  [ATTENTION]  return  parent  ;  else  stack  .  removeLast  (  )  ;  }  return  null  ;  }    [METHOD]  popStackToSuitableContainer  [TYPE]  Element  [PARAMETER]  Tag  tag  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  href  html  key  rawText  tagName  text  value  [TYPE]  Tag  bodyTag  childTag  headTag  htmlTag  parent2  parentTag  tag  textareaTag  titleTag  [TYPE]  boolean  false  true  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[REPLACE]  if  (  last  (  )    .  tag  (  )    .  canContain  (  tag  )  )  return  last  (  )  ;	[BUGGY]  if  (  last  (  )  .  tag  (  )  .  canContain  (  parentTag  )  )  return  last  (  )  ;  [CE]  cannot  find  symbol  parentTag  [CONTEXT]  private  Element  popStackToSuitableContainer  (  Tag  tag  )  {  while  (  !stack  .  isEmpty  (  )  )  {  [ATTENTION]  if  (  last  (  )    .  tag  (  )    .  canContain  (  parentTag  )  )  return  last  (  )    ;    else  stack  .  removeLast  (  )  ;  }  return  null  ;  }    [METHOD]  popStackToSuitableContainer  [TYPE]  Element  [PARAMETER]  Tag  tag  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  href  html  key  rawText  tagName  text  value  [TYPE]  Tag  bodyTag  childTag  headTag  htmlTag  parent2  parentTag  tag  textareaTag  titleTag  [TYPE]  boolean  false  true  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[REPLACE]  return  null;	[BUGGY]  return  true  ;  [CE]  incompatible  types  [CONTEXT]  private  Element  popStackToSuitableContainer  (  Tag  tag  )  {  while  (  !stack  .  isEmpty  (  )  )  {  if  (  last  (  )  .  tag  (  )  .  canContain  (  tag  )  )  return  last  (  )  ;  else  stack  .  removeLast  (  )  ;  }  [ATTENTION]  return  true  ;  }    [METHOD]  popStackToSuitableContainer  [TYPE]  Element  [PARAMETER]  Tag  tag  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  href  html  key  rawText  tagName  text  value  [TYPE]  Tag  bodyTag  childTag  headTag  htmlTag  parent2  parentTag  tag  textareaTag  titleTag  [TYPE]  boolean  false  true  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[REPLACE]  int  counter  =  0;	[BUGGY]  int  counter  =  3  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  private  Element  popStackToClose  (  Tag  tag  )  {    [ATTENTION]  int  counter  =  3  ;  Element  elToClose  =  null  ;  for  (  int  i  =  stack  .  size  (  )  -1  ;  i  >  0  ;  i--  )  {  counter++  ;  Element  el  =  stack  .  get  (  i  )  ;  Tag  elTag  =  el  .  tag  (  )  ;  if  (  elTag  .  equals  (  bodyTag  )  ||  elTag  .  equals  (  htmlTag  )  )  {  //  once  in  body  ,  don't  close  past  body  break  ;  }  else  if  (  elTag  .  equals  (  tag  )  )  {  elToClose  =  el  ;  break  ;  }  }  if  (  elToClose  !  =  null  )  {  for  (  int  i  =  0  ;  i  <  counter  ;  i++  )  {  stack  .  removeLast  (  )  ;  }  }  return  elToClose  ;  }    [METHOD]  popStackToClose  [TYPE]  Element  [PARAMETER]  Tag  tag  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  Element  el  elToClose  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  href  html  key  rawText  tagName  text  value  [TYPE]  Tag  bodyTag  childTag  elTag  headTag  htmlTag  parent2  parentTag  tag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  [TYPE]  int  counter  i  
[ADD]  int  counter  =  0;  Element  elToClose  =  null;	[BUGGY]  Element  elToClose  =  null  ;  [CE]  cannot  find  symbol  counter  [CONTEXT]  private  Element  popStackToClose  (  Tag  tag  )  {    [ATTENTION]  Element  elToClose  =  null  ;    for  (  int  i  =  stack  .  size  (  )  -1  ;  i  >  0  ;  i--  )  {  counter++  ;  Element  el  =  stack  .  get  (  i  )  ;  Tag  elTag  =  el  .  tag  (  )  ;  if  (  elTag  .  equals  (  bodyTag  )  ||  elTag  .  equals  (  htmlTag  )  )  {  //  once  in  body  ,  don't  close  past  body  break  ;  }  else  if  (  elTag  .  equals  (  tag  )  )  {  elToClose  =  el  ;  break  ;  }  }  if  (  elToClose  !  =  null  )  {  for  (  int  i  =  0  ;  i  <  counter  ;  i++  )  {  stack  .  removeLast  (  )  ;  }  }  return  elToClose  ;  }    [METHOD]  popStackToClose  [TYPE]  Element  [PARAMETER]  Tag  tag  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  Element  el  elToClose  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  href  html  key  rawText  tagName  text  value  [TYPE]  Tag  bodyTag  childTag  elTag  headTag  htmlTag  parent2  parentTag  tag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  [TYPE]  int  counter  i  
[REPLACE]  Element  elToClose  =  null;	[BUGGY]  Element  elToClose  =  true  ;  [CE]  incompatible  types  [CONTEXT]  private  Element  popStackToClose  (  Tag  tag  )  {    int  counter  =  0  ;  [ATTENTION]  Element  elToClose  =  true  ;  for  (  int  i  =  stack  .  size  (  )  -1  ;  i  >  0  ;  i--  )  {  counter++  ;  Element  el  =  stack  .  get  (  i  )  ;  Tag  elTag  =  el  .  tag  (  )  ;  if  (  elTag  .  equals  (  bodyTag  )  ||  elTag  .  equals  (  htmlTag  )  )  {  //  once  in  body  ,  don't  close  past  body  break  ;  }  else  if  (  elTag  .  equals  (  tag  )  )  {  elToClose  =  el  ;  break  ;  }  }  if  (  elToClose  !  =  null  )  {  for  (  int  i  =  0  ;  i  <  counter  ;  i++  )  {  stack  .  removeLast  (  )  ;  }  }  return  elToClose  ;  }    [METHOD]  popStackToClose  [TYPE]  Element  [PARAMETER]  Tag  tag  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  Element  el  elToClose  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  href  html  key  rawText  tagName  text  value  [TYPE]  Tag  bodyTag  childTag  elTag  headTag  htmlTag  parent2  parentTag  tag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  [TYPE]  int  counter  i  
[REPLACE]  if  (  elTag  .  equals  (  bodyTag  )  ||  elTag  .  equals  (  htmlTag  )  )  {	[BUGGY]  if  (  elTag  .  isValidParent  (  bodyTag  )  &&  elTag  .  equals  (  htmlTag  )  )  {[FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  private  Element  popStackToClose  (  Tag  tag  )  {    int  counter  =  0  ;  Element  elToClose  =  null  ;  for  (  int  i  =  stack  .  size  (  )  -1  ;  i  >  0  ;  i--  )  {  counter++  ;  Element  el  =  stack  .  get  (  i  )  ;  Tag  elTag  =  el  .  tag  (  )  ;  [ATTENTION]  if  (  elTag  .  isValidParent  (  bodyTag  )  &&  elTag  .  equals  (  htmlTag  )  )  {  break  ;  }  else  if  (  elTag  .  equals  (  tag  )  )  {  elToClose  =  el  ;  break  ;  }  }  if  (  elToClose  !  =  null  )  {  for  (  int  i  =  0  ;  i  <  counter  ;  i++  )  {  stack  .  removeLast  (  )  ;  }  }  return  elToClose  ;  }    [METHOD]  popStackToClose  [TYPE]  Element  [PARAMETER]  Tag  tag  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  Element  el  elToClose  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  href  html  key  rawText  tagName  text  value  [TYPE]  Tag  bodyTag  childTag  elTag  headTag  htmlTag  parent2  parentTag  tag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  [TYPE]  int  counter  i  
[REPLACE]  }  else  if  (  elTag  .  equals  (  tag  )  )  {	[BUGGY]    if  (  elTag  .  equals  (  titleTag  )  )  {[FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  private  Element  popStackToClose  (  Tag  tag  )  {    int  counter  =  0  ;  Element  elToClose  =  null  ;  for  (  int  i  =  stack  .  size  (  )  -1  ;  i  >  0  ;  i--  )  {  counter++  ;  Element  el  =  stack  .  get  (  i  )  ;  Tag  elTag  =  el  .  tag  (  )  ;  if  (  elTag  .  equals  (  bodyTag  )  ||  elTag  .  equals  (  htmlTag  )  )  {  //  once  in  body  ,  don't  close  past  body  break  ;  [ATTENTION]  }if  (  elTag  .  equals  (  titleTag  )  )  {  elToClose  =  el  ;  break  ;  }  }  if  (  elToClose  !  =  null  )  {  for  (  int  i  =  0  ;  i  <  counter  ;  i++  )  {  stack  .  removeLast  (  )  ;  }  }  return  elToClose  ;  }    [METHOD]  popStackToClose  [TYPE]  Element  [PARAMETER]  Tag  tag  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  Element  el  elToClose  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  href  html  key  rawText  tagName  text  value  [TYPE]  Tag  bodyTag  childTag  elTag  headTag  htmlTag  parent2  parentTag  tag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  [TYPE]  int  counter  i  
[ADD]  else  if  (  elTag  .  equals  (  tag  )  )  {  elToClose  =  el;  break;  }	[BUGGY]    break  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  private  Element  popStackToClose  (  Tag  tag  )  {    int  counter  =  0  ;  Element  elToClose  =  null  ;  for  (  int  i  =  stack  .  size  (  )  -1  ;  i  >  0  ;  i--  )  {  counter++  ;  Element  el  =  stack  .  get  (  i  )  ;  Tag  elTag  =  el  .  tag  (  )  ;  if  (  elTag  .  equals  (  bodyTag  )  ||  elTag  .  equals  (  htmlTag  )  )  {  //  once  in  body  ,  don't  close  past  body  break  ;  [ATTENTION]  }  break  ;      }  if  (  elToClose  !  =  null  )  {  for  (  int  i  =  0  ;  i  <  counter  ;  i++  )  {  stack  .  removeLast  (  )  ;  }  }  return  elToClose  ;  }    [METHOD]  popStackToClose  [TYPE]  Element  [PARAMETER]  Tag  tag  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  Element  el  elToClose  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  href  html  key  rawText  tagName  text  value  [TYPE]  Tag  bodyTag  childTag  elTag  headTag  htmlTag  parent2  parentTag  tag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  [TYPE]  int  counter  i  
[REPLACE]  elToClose  =  el;	[BUGGY]  elToClose  =    null  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  private  Element  popStackToClose  (  Tag  tag  )  {    int  counter  =  0  ;  Element  elToClose  =  null  ;  for  (  int  i  =  stack  .  size  (  )  -1  ;  i  >  0  ;  i--  )  {  counter++  ;  Element  el  =  stack  .  get  (  i  )  ;  Tag  elTag  =  el  .  tag  (  )  ;  if  (  elTag  .  equals  (  bodyTag  )  ||  elTag  .  equals  (  htmlTag  )  )  {  //  once  in  body  ,  don't  close  past  body  break  ;  }  else  if  (  elTag  .  equals  (  tag  )  )  {  [ATTENTION]  elToClose  =  null  ;  break  ;  }  }  if  (  elToClose  !  =  null  )  {  for  (  int  i  =  0  ;  i  <  counter  ;  i++  )  {  stack  .  removeLast  (  )  ;  }  }  return  elToClose  ;  }    [METHOD]  popStackToClose  [TYPE]  Element  [PARAMETER]  Tag  tag  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  Element  el  elToClose  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  href  html  key  rawText  tagName  text  value  [TYPE]  Tag  bodyTag  childTag  elTag  headTag  htmlTag  parent2  parentTag  tag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  [TYPE]  int  counter  i  
[ADD]  elToClose  =  el;  break;	[BUGGY]  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  private  Element  popStackToClose  (  Tag  tag  )  {    int  counter  =  0  ;  Element  elToClose  =  null  ;  for  (  int  i  =  stack  .  size  (  )  -1  ;  i  >  0  ;  i--  )  {  counter++  ;  Element  el  =  stack  .  get  (  i  )  ;  Tag  elTag  =  el  .  tag  (  )  ;  if  (  elTag  .  equals  (  bodyTag  )  ||  elTag  .  equals  (  htmlTag  )  )  {  //  once  in  body  ,  don't  close  past  body  break  ;  }  else  if  (  elTag  .  equals  (  tag  )  )  {  [ATTENTION]    }  }  if  (  elToClose  !  =  null  )  {  for  (  int  i  =  0  ;  i  <  counter  ;  i++  )  {  stack  .  removeLast  (  )  ;  }  }  return  elToClose  ;  }    [METHOD]  popStackToClose  [TYPE]  Element  [PARAMETER]  Tag  tag  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  Element  el  elToClose  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  href  html  key  rawText  tagName  text  value  [TYPE]  Tag  bodyTag  childTag  elTag  headTag  htmlTag  parent2  parentTag  tag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  [TYPE]  int  counter  i  
[ADD]  elToClose  =  el;	[BUGGY]  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  private  Element  popStackToClose  (  Tag  tag  )  {    int  counter  =  0  ;  Element  elToClose  =  null  ;  for  (  int  i  =  stack  .  size  (  )  -1  ;  i  >  0  ;  i--  )  {  counter++  ;  Element  el  =  stack  .  get  (  i  )  ;  Tag  elTag  =  el  .  tag  (  )  ;  if  (  elTag  .  equals  (  bodyTag  )  ||  elTag  .  equals  (  htmlTag  )  )  {  //  once  in  body  ,  don't  close  past  body  break  ;  }  else  if  (  elTag  .  equals  (  tag  )  )  {  [ATTENTION]  break  ;  }  }  if  (  elToClose  !  =  null  )  {  for  (  int  i  =  0  ;  i  <  counter  ;  i++  )  {  stack  .  removeLast  (  )  ;  }  }  return  elToClose  ;  }    [METHOD]  popStackToClose  [TYPE]  Element  [PARAMETER]  Tag  tag  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  Element  el  elToClose  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  href  html  key  rawText  tagName  text  value  [TYPE]  Tag  bodyTag  childTag  elTag  headTag  htmlTag  parent2  parentTag  tag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  [TYPE]  int  counter  i  
[REPLACE]  }  else  if  (  elTag  .  equals  (  tag  )  )  {	[BUGGY]  else  if  (  elTag  .  equals  (  titleTag  )  )  {[FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  private  Element  popStackToClose  (  Tag  tag  )  {    int  counter  =  0  ;  Element  elToClose  =  null  ;  for  (  int  i  =  stack  .  size  (  )  -1  ;  i  >  0  ;  i--  )  {  counter++  ;  Element  el  =  stack  .  get  (  i  )  ;  Tag  elTag  =  el  .  tag  (  )  ;  if  (  elTag  .  equals  (  bodyTag  )  ||  elTag  .  equals  (  htmlTag  )  )  {  //  once  in  body  ,  don't  close  past  body  break  ;  [ATTENTION]  }  else  if  (  elTag  .  equals  (  titleTag  )  )  {  elToClose  =  el  ;  break  ;  }  }  if  (  elToClose  !  =  null  )  {  for  (  int  i  =  0  ;  i  <  counter  ;  i++  )  {  stack  .  removeLast  (  )  ;  }  }  return  elToClose  ;  }    [METHOD]  popStackToClose  [TYPE]  Element  [PARAMETER]  Tag  tag  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  Element  el  elToClose  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  href  html  key  rawText  tagName  text  value  [TYPE]  Tag  bodyTag  childTag  elTag  headTag  htmlTag  parent2  parentTag  tag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  [TYPE]  int  counter  i  
[ADD]  else  if  (  elTag  .  equals  (  tag  )  )  {  elToClose  =  el;  break;  }	[BUGGY]    elToClose  =  el  ;  break  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  private  Element  popStackToClose  (  Tag  tag  )  {    int  counter  =  0  ;  Element  elToClose  =  null  ;  for  (  int  i  =  stack  .  size  (  )  -1  ;  i  >  0  ;  i--  )  {  counter++  ;  Element  el  =  stack  .  get  (  i  )  ;  Tag  elTag  =  el  .  tag  (  )  ;  if  (  elTag  .  equals  (  bodyTag  )  ||  elTag  .  equals  (  htmlTag  )  )  {  //  once  in  body  ,  don't  close  past  body  break  ;  [ATTENTION]  }  elToClose  =  el  ;  break  ;      }  if  (  elToClose  !  =  null  )  {  for  (  int  i  =  0  ;  i  <  counter  ;  i++  )  {  stack  .  removeLast  (  )  ;  }  }  return  elToClose  ;  }    [METHOD]  popStackToClose  [TYPE]  Element  [PARAMETER]  Tag  tag  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  Element  el  elToClose  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  href  html  key  rawText  tagName  text  value  [TYPE]  Tag  bodyTag  childTag  elTag  headTag  htmlTag  parent2  parentTag  tag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  [TYPE]  int  counter  i  
[REPLACE]  for  (  int  i  =  stack  .  size  (  )  -1;  i  >  0;  i--  )  {	[BUGGY]  for  (  int  i  =  stack  .  size  (  )  +  5  -0  ;  i  >  0  ;  i--  )  {[FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  private  Element  popStackToClose  (  Tag  tag  )  {    int  counter  =  0  ;  Element  elToClose  =  null  ;  [ATTENTION]  for  (  int  i  =  stack  .  size  (  )  +  5  -0  ;  i  >  0  ;  i--  )  {  counter++  ;  Element  el  =  stack  .  get  (  i  )  ;  Tag  elTag  =  el  .  tag  (  )  ;  if  (  elTag  .  equals  (  bodyTag  )  ||  elTag  .  equals  (  htmlTag  )  )  {  //  once  in  body  ,  don't  close  past  body  break  ;  }  else  if  (  elTag  .  equals  (  tag  )  )  {  elToClose  =  el  ;  break  ;  }  }  if  (  elToClose  !  =  null  )  {  for  (  int  i  =  0  ;  i  <  counter  ;  i++  )  {  stack  .  removeLast  (  )  ;  }  }  return  elToClose  ;  }    [METHOD]  popStackToClose  [TYPE]  Element  [PARAMETER]  Tag  tag  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  Element  el  elToClose  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  href  html  key  rawText  tagName  text  value  [TYPE]  Tag  bodyTag  childTag  elTag  headTag  htmlTag  parent2  parentTag  tag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  [TYPE]  int  counter  i  
[REPLACE]  if  (  elTag  .  equals  (  bodyTag  )  ||  elTag  .  equals  (  htmlTag  )  )  {	[BUGGY]  if  (  elTag  .  endsWith  (  DQ  )    &&  elTag[CE]  ')'  expected  [CONTEXT]  private  Element  popStackToClose  (  Tag  tag  )  {    int  counter  =  0  ;  Element  elToClose  =  null  ;  for  (  int  i  =  stack  .  size  (  )  -1  ;  i  >  0  ;  i--  )  {  counter++  ;  Element  el  =  stack  .  get  (  i  )  ;  Tag  elTag  =  el  .  tag  (  )  ;  [ATTENTION]  if  (  elTag  .  endsWith  (  DQ  )  &&  elTag  break  ;  }  else  if  (  elTag  .  equals  (  tag  )  )  {  elToClose  =  el  ;  break  ;  }  }  if  (  elToClose  !  =  null  )  {  for  (  int  i  =  0  ;  i  <  counter  ;  i++  )  {  stack  .  removeLast  (  )  ;  }  }  return  elToClose  ;  }    [METHOD]  popStackToClose  [TYPE]  Element  [PARAMETER]  Tag  tag  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  Element  el  elToClose  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  href  html  key  rawText  tagName  text  value  [TYPE]  Tag  bodyTag  childTag  elTag  headTag  htmlTag  parent2  parentTag  tag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  [TYPE]  int  counter  i  
[ADD]  if  (  elTag  .  equals  (  bodyTag  )  ||  elTag  .  equals  (  htmlTag  )  )  {  break;  }  else  if  (  elTag  .  equals  (  tag  )  )  {  elToClose  =  el;  break;	[BUGGY]  break  ;  elToClose  =  el  ;  break  ;  [CE]  illegal  start  of  type  [CONTEXT]  private  Element  popStackToClose  (  Tag  tag  )  {    int  counter  =  0  ;  Element  elToClose  =  null  ;  for  (  int  i  =  stack  .  size  (  )  -1  ;  i  >  0  ;  i--  )  {  counter++  ;  Element  el  =  stack  .  get  (  i  )  ;  Tag  elTag  =  el  .  tag  (  )  ;  [ATTENTION]  break  ;  elToClose  =  el  ;  break  ;      }  }  if  (  elToClose  !  =  null  )  {  for  (  int  i  =  0  ;  i  <  counter  ;  i++  )  {  stack  .  removeLast  (  )  ;  }  }  return  elToClose  ;  }    [METHOD]  popStackToClose  [TYPE]  Element  [PARAMETER]  Tag  tag  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  Element  el  elToClose  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  href  html  key  rawText  tagName  text  value  [TYPE]  Tag  bodyTag  childTag  elTag  headTag  htmlTag  parent2  parentTag  tag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  [TYPE]  int  counter  i  
[REPLACE]  }  else  if  (  elTag  .  equals  (  tag  )  )  {	[BUGGY]  else  if  (  el  tag    )  {[CE]  ')'  expected  [CONTEXT]  private  Element  popStackToClose  (  Tag  tag  )  {    int  counter  =  0  ;  Element  elToClose  =  null  ;  for  (  int  i  =  stack  .  size  (  )  -1  ;  i  >  0  ;  i--  )  {  counter++  ;  Element  el  =  stack  .  get  (  i  )  ;  Tag  elTag  =  el  .  tag  (  )  ;  if  (  elTag  .  equals  (  bodyTag  )  ||  elTag  .  equals  (  htmlTag  )  )  {  //  once  in  body  ,  don't  close  past  body  break  ;  [ATTENTION]  }  else  if  (  eltag  )  {  elToClose  =  el  ;  break  ;  }  }  if  (  elToClose  !  =  null  )  {  for  (  int  i  =  0  ;  i  <  counter  ;  i++  )  {  stack  .  removeLast  (  )  ;  }  }  return  elToClose  ;  }    [METHOD]  popStackToClose  [TYPE]  Element  [PARAMETER]  Tag  tag  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  Element  el  elToClose  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  href  html  key  rawText  tagName  text  value  [TYPE]  Tag  bodyTag  childTag  elTag  headTag  htmlTag  parent2  parentTag  tag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  [TYPE]  int  counter  i  
[REPLACE]  }  else  if  (  elTag  .  equals  (  tag  )  )  {	[BUGGY]  else  if  (  elTag  .  equals  (  parentTag  )  )  {[CE]  cannot  find  symbol  parentTag  [CONTEXT]  private  Element  popStackToClose  (  Tag  tag  )  {    int  counter  =  0  ;  Element  elToClose  =  null  ;  for  (  int  i  =  stack  .  size  (  )  -1  ;  i  >  0  ;  i--  )  {  counter++  ;  Element  el  =  stack  .  get  (  i  )  ;  Tag  elTag  =  el  .  tag  (  )  ;  if  (  elTag  .  equals  (  bodyTag  )  ||  elTag  .  equals  (  htmlTag  )  )  {  //  once  in  body  ,  don't  close  past  body  break  ;  [ATTENTION]  }  else  if  (  elTag  .  equals  (  parentTag  )  )  {  elToClose  =  el  ;  break  ;  }  }  if  (  elToClose  !  =  null  )  {  for  (  int  i  =  0  ;  i  <  counter  ;  i++  )  {  stack  .  removeLast  (  )  ;  }  }  return  elToClose  ;  }    [METHOD]  popStackToClose  [TYPE]  Element  [PARAMETER]  Tag  tag  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  Element  el  elToClose  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  href  html  key  rawText  tagName  text  value  [TYPE]  Tag  bodyTag  childTag  elTag  headTag  htmlTag  parent2  parentTag  tag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  [TYPE]  int  counter  i  
[REPLACE]  Element  el  =  stack  .  get  (  i  )  ;	[BUGGY]  Element  el  =  stack  .  add  (  i  )  ;  [CE]  no  suitable  method  found  for  add(int)  [CONTEXT]  private  Element  popStackToClose  (  Tag  tag  )  {    int  counter  =  0  ;  Element  elToClose  =  null  ;  for  (  int  i  =  stack  .  size  (  )  -1  ;  i  >  0  ;  i--  )  {  counter++  ;  [ATTENTION]  Element  el  =  stack  .  add  (  i  )    ;  Tag  elTag  =  el  .  tag  (  )  ;  if  (  elTag  .  equals  (  bodyTag  )  ||  elTag  .  equals  (  htmlTag  )  )  {  //  once  in  body  ,  don't  close  past  body  break  ;  }  else  if  (  elTag  .  equals  (  tag  )  )  {  elToClose  =  el  ;  break  ;  }  }  if  (  elToClose  !  =  null  )  {  for  (  int  i  =  0  ;  i  <  counter  ;  i++  )  {  stack  .  removeLast  (  )  ;  }  }  return  elToClose  ;  }    [METHOD]  popStackToClose  [TYPE]  Element  [PARAMETER]  Tag  tag  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  Element  el  elToClose  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  href  html  key  rawText  tagName  text  value  [TYPE]  Tag  bodyTag  childTag  elTag  headTag  htmlTag  parent2  parentTag  tag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  [TYPE]  int  counter  i  
[REPLACE]  Tag  elTag  =  el  .  tag  (  )  ;	[BUGGY]  Tag  elToCloseTag  =  el  .  tag  (  )  ;  [CE]  cannot  find  symbol  elTag  [CONTEXT]  private  Element  popStackToClose  (  Tag  tag  )  {    int  counter  =  0  ;  Element  elToClose  =  null  ;  for  (  int  i  =  stack  .  size  (  )  -1  ;  i  >  0  ;  i--  )  {  counter++  ;  Element  el  =  stack  .  get  (  i  )  ;  [ATTENTION]  Tag  elToCloseTag  =  el  .  tag  (  )    ;  if  (  elTag  .  equals  (  bodyTag  )  ||  elTag  .  equals  (  htmlTag  )  )  {  //  once  in  body  ,  don't  close  past  body  break  ;  }  else  if  (  elTag  .  equals  (  tag  )  )  {  elToClose  =  el  ;  break  ;  }  }  if  (  elToClose  !  =  null  )  {  for  (  int  i  =  0  ;  i  <  counter  ;  i++  )  {  stack  .  removeLast  (  )  ;  }  }  return  elToClose  ;  }    [METHOD]  popStackToClose  [TYPE]  Element  [PARAMETER]  Tag  tag  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  Element  el  elToClose  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  href  html  key  rawText  tagName  text  value  [TYPE]  Tag  bodyTag  childTag  elTag  headTag  htmlTag  parent2  parentTag  tag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  [TYPE]  int  counter  i  
[REPLACE]  for  (  int  i  =  stack  .  size  (  )  -1;  i  >  0;  i--  )  {	[BUGGY]  for  (  int  i  =  stack  .  size  (  )  /  2  -1  ;  i  >  0  ;  i--  )  {[FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  private  Element  popStackToClose  (  Tag  tag  )  {    int  counter  =  0  ;  Element  elToClose  =  null  ;  [ATTENTION]  for  (  int  i  =  stack  .  size  (  )  /2  -1  ;  i  >  0  ;  i--  )  {  counter++  ;  Element  el  =  stack  .  get  (  i  )  ;  Tag  elTag  =  el  .  tag  (  )  ;  if  (  elTag  .  equals  (  bodyTag  )  ||  elTag  .  equals  (  htmlTag  )  )  {  //  once  in  body  ,  don't  close  past  body  break  ;  }  else  if  (  elTag  .  equals  (  tag  )  )  {  elToClose  =  el  ;  break  ;  }  }  if  (  elToClose  !  =  null  )  {  for  (  int  i  =  0  ;  i  <  counter  ;  i++  )  {  stack  .  removeLast  (  )  ;  }  }  return  elToClose  ;  }    [METHOD]  popStackToClose  [TYPE]  Element  [PARAMETER]  Tag  tag  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  Element  el  elToClose  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  href  html  key  rawText  tagName  text  value  [TYPE]  Tag  bodyTag  childTag  elTag  headTag  htmlTag  parent2  parentTag  tag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  [TYPE]  int  counter  i  
[REPLACE]  Tag  elTag  =  el  .  tag  (  )  ;	[BUGGY]  Tag  elToCloseTag  =  el  .  tagName  (  )  ;  [CE]  incompatible  types  [CONTEXT]  private  Element  popStackToClose  (  Tag  tag  )  {    int  counter  =  0  ;  Element  elToClose  =  null  ;  for  (  int  i  =  stack  .  size  (  )  -1  ;  i  >  0  ;  i--  )  {  counter++  ;  Element  el  =  stack  .  get  (  i  )  ;  [ATTENTION]  Tag  elToCloseTag  =  el  .  tagName  (  )    ;  if  (  elTag  .  equals  (  bodyTag  )  ||  elTag  .  equals  (  htmlTag  )  )  {  //  once  in  body  ,  don't  close  past  body  break  ;  }  else  if  (  elTag  .  equals  (  tag  )  )  {  elToClose  =  el  ;  break  ;  }  }  if  (  elToClose  !  =  null  )  {  for  (  int  i  =  0  ;  i  <  counter  ;  i++  )  {  stack  .  removeLast  (  )  ;  }  }  return  elToClose  ;  }    [METHOD]  popStackToClose  [TYPE]  Element  [PARAMETER]  Tag  tag  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  Element  el  elToClose  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  href  html  key  rawText  tagName  text  value  [TYPE]  Tag  bodyTag  childTag  elTag  headTag  htmlTag  parent2  parentTag  tag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  [TYPE]  int  counter  i  
[REPLACE]  if  (  elToClose  !=  null  )  {	[BUGGY]  if  (  elToClose  =  =  null  )  {[FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  private  Element  popStackToClose  (  Tag  tag  )  {    int  counter  =  0  ;  Element  elToClose  =  null  ;  for  (  int  i  =  stack  .  size  (  )  -1  ;  i  >  0  ;  i--  )  {  counter++  ;  Element  el  =  stack  .  get  (  i  )  ;  Tag  elTag  =  el  .  tag  (  )  ;  if  (  elTag  .  equals  (  bodyTag  )  ||  elTag  .  equals  (  htmlTag  )  )  {  //  once  in  body  ,  don't  close  past  body  break  ;  }  else  if  (  elTag  .  equals  (  tag  )  )  {  elToClose  =  el  ;  break  ;  }  }  [ATTENTION]  if  (  elToClose  =  =  null  )  {  for  (  int  i  =  0  ;  i  <  counter  ;  i++  )  {  stack  .  removeLast  (  )  ;  }  }  return  elToClose  ;  }    [METHOD]  popStackToClose  [TYPE]  Element  [PARAMETER]  Tag  tag  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  Element  el  elToClose  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  href  html  key  rawText  tagName  text  value  [TYPE]  Tag  bodyTag  childTag  elTag  headTag  htmlTag  parent2  parentTag  tag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  [TYPE]  int  counter  i  
[ADD]  if  (  elToClose  !=  null  )  {  for  (  int  i  =  0;  i  <  counter;  i++  )  {  stack  .  removeLast  (  )  ;  }	[BUGGY]  [CE]  illegal  start  of  type  [CONTEXT]  private  Element  popStackToClose  (  Tag  tag  )  {    int  counter  =  0  ;  Element  elToClose  =  null  ;  for  (  int  i  =  stack  .  size  (  )  -1  ;  i  >  0  ;  i--  )  {  counter++  ;  Element  el  =  stack  .  get  (  i  )  ;  Tag  elTag  =  el  .  tag  (  )  ;  if  (  elTag  .  equals  (  bodyTag  )  ||  elTag  .  equals  (  htmlTag  )  )  {  //  once  in  body  ,  don't  close  past  body  break  ;  }  else  if  (  elTag  .  equals  (  tag  )  )  {  elToClose  =  el  ;  break  ;  }  }  [ATTENTION]      }  return  elToClose  ;  }    [METHOD]  popStackToClose  [TYPE]  Element  [PARAMETER]  Tag  tag  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  Element  el  elToClose  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  href  html  key  rawText  tagName  text  value  [TYPE]  Tag  bodyTag  childTag  elTag  headTag  htmlTag  parent2  parentTag  tag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  [TYPE]  int  counter  i  
[REPLACE]  for  (  int  i  =  0;  i  <  counter;  i++  )  {	[BUGGY]  for  (  int  i  =  0  ;  i  >  counter  ;  i++  )  {[FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  private  Element  popStackToClose  (  Tag  tag  )  {    int  counter  =  0  ;  Element  elToClose  =  null  ;  for  (  int  i  =  stack  .  size  (  )  -1  ;  i  >  0  ;  i--  )  {  counter++  ;  Element  el  =  stack  .  get  (  i  )  ;  Tag  elTag  =  el  .  tag  (  )  ;  if  (  elTag  .  equals  (  bodyTag  )  ||  elTag  .  equals  (  htmlTag  )  )  {  //  once  in  body  ,  don't  close  past  body  break  ;  }  else  if  (  elTag  .  equals  (  tag  )  )  {  elToClose  =  el  ;  break  ;  }  }  if  (  elToClose  !  =  null  )  {  [ATTENTION]  for  (  int  i  =  0  ;  i>counter  ;  i++  )  {  stack  .  removeLast  (  )  ;  }  }  return  elToClose  ;  }    [METHOD]  popStackToClose  [TYPE]  Element  [PARAMETER]  Tag  tag  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  Element  el  elToClose  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  href  html  key  rawText  tagName  text  value  [TYPE]  Tag  bodyTag  childTag  elTag  headTag  htmlTag  parent2  parentTag  tag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  [TYPE]  int  counter  i  
[ADD]  for  (  int  i  =  0;  i  <  counter;  i++  )  {  stack  .  removeLast  (  )  ;  }	[BUGGY]  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  private  Element  popStackToClose  (  Tag  tag  )  {    int  counter  =  0  ;  Element  elToClose  =  null  ;  for  (  int  i  =  stack  .  size  (  )  -1  ;  i  >  0  ;  i--  )  {  counter++  ;  Element  el  =  stack  .  get  (  i  )  ;  Tag  elTag  =  el  .  tag  (  )  ;  if  (  elTag  .  equals  (  bodyTag  )  ||  elTag  .  equals  (  htmlTag  )  )  {  //  once  in  body  ,  don't  close  past  body  break  ;  }  else  if  (  elTag  .  equals  (  tag  )  )  {  elToClose  =  el  ;  break  ;  }  }  if  (  elToClose  !  =  null  )  {  [ATTENTION]    }  return  elToClose  ;  }    [METHOD]  popStackToClose  [TYPE]  Element  [PARAMETER]  Tag  tag  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  Element  el  elToClose  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  href  html  key  rawText  tagName  text  value  [TYPE]  Tag  bodyTag  childTag  elTag  headTag  htmlTag  parent2  parentTag  tag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  [TYPE]  int  counter  i  
[REPLACE]  stack  .  removeLast  (  )  ;	[BUGGY]  stack  .  getLast  (  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  private  Element  popStackToClose  (  Tag  tag  )  {    int  counter  =  0  ;  Element  elToClose  =  null  ;  for  (  int  i  =  stack  .  size  (  )  -1  ;  i  >  0  ;  i--  )  {  counter++  ;  Element  el  =  stack  .  get  (  i  )  ;  Tag  elTag  =  el  .  tag  (  )  ;  if  (  elTag  .  equals  (  bodyTag  )  ||  elTag  .  equals  (  htmlTag  )  )  {  //  once  in  body  ,  don't  close  past  body  break  ;  }  else  if  (  elTag  .  equals  (  tag  )  )  {  elToClose  =  el  ;  break  ;  }  }  if  (  elToClose  !  =  null  )  {  for  (  int  i  =  0  ;  i  <  counter  ;  i++  )  {  [ATTENTION]  stack  .  getLast  (  )    ;  }  }  return  elToClose  ;  }    [METHOD]  popStackToClose  [TYPE]  Element  [PARAMETER]  Tag  tag  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  Element  el  elToClose  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  href  html  key  rawText  tagName  text  value  [TYPE]  Tag  bodyTag  childTag  elTag  headTag  htmlTag  parent2  parentTag  tag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  [TYPE]  int  counter  i  
[ADD]  stack  .  removeLast  (  )  ;	[BUGGY]  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  private  Element  popStackToClose  (  Tag  tag  )  {    int  counter  =  0  ;  Element  elToClose  =  null  ;  for  (  int  i  =  stack  .  size  (  )  -1  ;  i  >  0  ;  i--  )  {  counter++  ;  Element  el  =  stack  .  get  (  i  )  ;  Tag  elTag  =  el  .  tag  (  )  ;  if  (  elTag  .  equals  (  bodyTag  )  ||  elTag  .  equals  (  htmlTag  )  )  {  //  once  in  body  ,  don't  close  past  body  break  ;  }  else  if  (  elTag  .  equals  (  tag  )  )  {  elToClose  =  el  ;  break  ;  }  }  if  (  elToClose  !  =  null  )  {  for  (  int  i  =  0  ;  i  <  counter  ;  i++  )  {  [ATTENTION]  }  }  return  elToClose  ;  }    [METHOD]  popStackToClose  [TYPE]  Element  [PARAMETER]  Tag  tag  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  Element  el  elToClose  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  href  html  key  rawText  tagName  text  value  [TYPE]  Tag  bodyTag  childTag  elTag  headTag  htmlTag  parent2  parentTag  tag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  [TYPE]  int  counter  i  
[REPLACE]  for  (  int  i  =  0;  i  <  counter;  i++  )  {	[BUGGY]  for  (  int  i  =  2  ;  i  <  counter  ;  i++  )  {[FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  private  Element  popStackToClose  (  Tag  tag  )  {    int  counter  =  0  ;  Element  elToClose  =  null  ;  for  (  int  i  =  stack  .  size  (  )  -1  ;  i  >  0  ;  i--  )  {  counter++  ;  Element  el  =  stack  .  get  (  i  )  ;  Tag  elTag  =  el  .  tag  (  )  ;  if  (  elTag  .  equals  (  bodyTag  )  ||  elTag  .  equals  (  htmlTag  )  )  {  //  once  in  body  ,  don't  close  past  body  break  ;  }  else  if  (  elTag  .  equals  (  tag  )  )  {  elToClose  =  el  ;  break  ;  }  }  if  (  elToClose  !  =  null  )  {  [ATTENTION]  for  (  int  i  =  2  ;  i  <  counter  ;  i++  )  {  stack  .  removeLast  (  )  ;  }  }  return  elToClose  ;  }    [METHOD]  popStackToClose  [TYPE]  Element  [PARAMETER]  Tag  tag  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  Element  el  elToClose  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  href  html  key  rawText  tagName  text  value  [TYPE]  Tag  bodyTag  childTag  elTag  headTag  htmlTag  parent2  parentTag  tag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  [TYPE]  int  counter  i  
[REPLACE]  for  (  int  i  =  0;  i  <  counter;  i++  )  {	[BUGGY]  for  (  int  i  =  0  ;  i  >  =    counter  ;  i++  )  {[FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  private  Element  popStackToClose  (  Tag  tag  )  {    int  counter  =  0  ;  Element  elToClose  =  null  ;  for  (  int  i  =  stack  .  size  (  )  -1  ;  i  >  0  ;  i--  )  {  counter++  ;  Element  el  =  stack  .  get  (  i  )  ;  Tag  elTag  =  el  .  tag  (  )  ;  if  (  elTag  .  equals  (  bodyTag  )  ||  elTag  .  equals  (  htmlTag  )  )  {  //  once  in  body  ,  don't  close  past  body  break  ;  }  else  if  (  elTag  .  equals  (  tag  )  )  {  elToClose  =  el  ;  break  ;  }  }  if  (  elToClose  !  =  null  )  {  [ATTENTION]  for  (  int  i  =  0  ;  i>  =  counter  ;  i++  )  {  stack  .  removeLast  (  )  ;  }  }  return  elToClose  ;  }    [METHOD]  popStackToClose  [TYPE]  Element  [PARAMETER]  Tag  tag  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  Element  el  elToClose  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  href  html  key  rawText  tagName  text  value  [TYPE]  Tag  bodyTag  childTag  elTag  headTag  htmlTag  parent2  parentTag  tag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  [TYPE]  int  counter  i  
[REPLACE]  for  (  int  i  =  0;  i  <  counter;  i++  )  {	[BUGGY]  for  (  int  i  =  0  +  0  ;  i  <  counter  ;  i++  )  {[FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  private  Element  popStackToClose  (  Tag  tag  )  {    int  counter  =  0  ;  Element  elToClose  =  null  ;  for  (  int  i  =  stack  .  size  (  )  -1  ;  i  >  0  ;  i--  )  {  counter++  ;  Element  el  =  stack  .  get  (  i  )  ;  Tag  elTag  =  el  .  tag  (  )  ;  if  (  elTag  .  equals  (  bodyTag  )  ||  elTag  .  equals  (  htmlTag  )  )  {  //  once  in  body  ,  don't  close  past  body  break  ;  }  else  if  (  elTag  .  equals  (  tag  )  )  {  elToClose  =  el  ;  break  ;  }  }  if  (  elToClose  !  =  null  )  {  [ATTENTION]  for  (  int  i  =  0  +  0  ;  i  <  counter  ;  i++  )  {  stack  .  removeLast  (  )  ;  }  }  return  elToClose  ;  }    [METHOD]  popStackToClose  [TYPE]  Element  [PARAMETER]  Tag  tag  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  Element  el  elToClose  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  href  html  key  rawText  tagName  text  value  [TYPE]  Tag  bodyTag  childTag  elTag  headTag  htmlTag  parent2  parentTag  tag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  [TYPE]  int  counter  i  
[REPLACE]  return  elToClose;	[BUGGY]  return  el  ;  [CE]  cannot  find  symbol  el  [CONTEXT]  private  Element  popStackToClose  (  Tag  tag  )  {    int  counter  =  0  ;  Element  elToClose  =  null  ;  for  (  int  i  =  stack  .  size  (  )  -1  ;  i  >  0  ;  i--  )  {  counter++  ;  Element  el  =  stack  .  get  (  i  )  ;  Tag  elTag  =  el  .  tag  (  )  ;  if  (  elTag  .  equals  (  bodyTag  )  ||  elTag  .  equals  (  htmlTag  )  )  {  //  once  in  body  ,  don't  close  past  body  break  ;  }  else  if  (  elTag  .  equals  (  tag  )  )  {  elToClose  =  el  ;  break  ;  }  }  if  (  elToClose  !  =  null  )  {  for  (  int  i  =  0  ;  i  <  counter  ;  i++  )  {  stack  .  removeLast  (  )  ;  }  }  [ATTENTION]  return  el  ;  }    [METHOD]  popStackToClose  [TYPE]  Element  [PARAMETER]  Tag  tag  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  Element  el  elToClose  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  href  html  key  rawText  tagName  text  value  [TYPE]  Tag  bodyTag  childTag  elTag  headTag  htmlTag  parent2  parentTag  tag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  [TYPE]  int  counter  i  
[REPLACE]  return  stack  .  getLast  (  )  ;	[BUGGY]  return  stack  .  removeLast  (  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  private  Element  last  (  )  {  [ATTENTION]  return  stack  .  removeLast  (  )    ;  }    [METHOD]  last  [TYPE]  Element  [PARAMETER]  [CLASS]  Parser    [TYPE]  TokenQueue  tq  [TYPE]  String  DQ  SQ  baseUri  bodyHtml  data  href  html  key  rawText  tagName  text  value  [TYPE]  Tag  bodyTag  childTag  elTag  headTag  htmlTag  parent2  parentTag  tag  textareaTag  titleTag  [TYPE]  boolean  false  true  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  
[REPLACE]  InputStream  inStream  =  new  FileInputStream  (  in  )  ;	[BUGGY]  int  res  =  conn  .  getResponseCode  (  )  ;  [CE]  cannot  find  symbol  conn  [CONTEXT]  static  String  load  (  File  in  ,  String  charsetName  )  throws  IOException  {  [ATTENTION]  int  res  =  conn  .  getResponseCode  (  )    ;  String  data  =  readInputStream  (  inStream  ,  charsetName  )  ;  inStream  .  close  (  )  ;  return  data  ;  }    [METHOD]  load  [TYPE]  String  [PARAMETER]  File  in  String  charsetName  [CLASS]  DataUtil    [TYPE]  boolean  false  true  [TYPE]  InputStream  inStream  [TYPE]  String  charsetName  data  [TYPE]  File  in  
[REPLACE]  String  data  =  readInputStream  (  inStream,  charsetName  )  ;	[BUGGY]  String  data  =  readInputStream  (  inStream  ,  data  )  ;  [CE]  variable  data  might  not  have  been  initialized  [CONTEXT]  static  String  load  (  File  in  ,  String  charsetName  )  throws  IOException  {  InputStream  inStream  =  new  FileInputStream  (  in  )  ;  [ATTENTION]  String  data  =  readInputStream  (  inStream  ,  data  )    ;  inStream  .  close  (  )  ;  return  data  ;  }    [METHOD]  load  [TYPE]  String  [PARAMETER]  File  in  String  charsetName  [CLASS]  DataUtil    [TYPE]  boolean  false  true  [TYPE]  InputStream  inStream  [TYPE]  String  charsetName  data  [TYPE]  File  in  
[ADD]  String  data  =  readInputStream  (  inStream,  charsetName  )  ;	[BUGGY]  [CE]  cannot  find  symbol  data  [CONTEXT]  static  String  load  (  File  in  ,  String  charsetName  )  throws  IOException  {  InputStream  inStream  =  new  FileInputStream  (  in  )  ;  [ATTENTION]  inStream  .  close  (  )  ;  return  data  ;  }    [METHOD]  load  [TYPE]  String  [PARAMETER]  File  in  String  charsetName  [CLASS]  DataUtil    [TYPE]  boolean  false  true  [TYPE]  InputStream  inStream  [TYPE]  String  charsetName  data  [TYPE]  File  in  
[REPLACE]  inStream  .  close  (  )  ;	[BUGGY]  int  res  =  conn  .  getResponseCode  (  )  ;  [CE]  cannot  find  symbol  conn  [CONTEXT]  static  String  load  (  File  in  ,  String  charsetName  )  throws  IOException  {  InputStream  inStream  =  new  FileInputStream  (  in  )  ;  String  data  =  readInputStream  (  inStream  ,  charsetName  )  ;  [ATTENTION]  int  res  =  conn  .  getResponseCode  (  )    ;  return  data  ;  }    [METHOD]  load  [TYPE]  String  [PARAMETER]  File  in  String  charsetName  [CLASS]  DataUtil    [TYPE]  boolean  false  true  [TYPE]  InputStream  inStream  [TYPE]  String  charsetName  data  [TYPE]  File  in  
[REPLACE]  return  data;	[BUGGY]  return  data  .  toString  (  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  static  String  load  (  File  in  ,  String  charsetName  )  throws  IOException  {  InputStream  inStream  =  new  FileInputStream  (  in  )  ;  String  data  =  readInputStream  (  inStream  ,  charsetName  )  ;  inStream  .  close  (  )  ;  [ATTENTION]  return  data  .  toString  (  )    ;  }    [METHOD]  load  [TYPE]  String  [PARAMETER]  File  in  String  charsetName  [CLASS]  DataUtil    [TYPE]  boolean  false  true  [TYPE]  InputStream  inStream  [TYPE]  String  charsetName  data  [TYPE]  File  in  
[REPLACE]  String  protocol  =  url  .  getProtocol  (  )  ;	[BUGGY]  String  protocol  =  url  .  toString  (  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  static  String  load  (  URL  url  ,  int  timeoutMillis  )  throws  IOException  {  [ATTENTION]  String  protocol  =  url  .  toString  (  )    ;  Validate  .  isTrue  (  protocol  .  equals  (   "http "  )  ||  protocol  .  equals  (   "https "  )  ,   "Only  http  &  https  protocols  supported "  )  ;    HttpURLConnection  conn  =    (  HttpURLConnection  )  url  .  openConnection  (  )  ;  conn  .  setInstanceFollowRedirects  (  true  )  ;  conn  .  setConnectTimeout  (  timeoutMillis  )  ;  conn  .  setReadTimeout  (  timeoutMillis  )  ;  conn  .  connect  (  )  ;    int  res  =  conn  .  getResponseCode  (  )  ;  if  (  res  !  =  HttpURLConnection  .  HTTP_OK  )  throw  new  IOException  (  res  +   "  error  loading  URL   "  +  url  .  toString  (  )  )  ;    String  contentType  =  conn  .  getContentType  (  )  ;  if  (  contentType  =  =  null  ||  !contentType  .  startsWith  (   "text/ "  )  )  throw  new  IOException  (  String  .  format  (   "Unhandled  content  type  \ "%s\ "  on  URL  %s  .  Must  be  text/* "  ,  contentType  ,  url  .  toString  (  )  )  )  ;    InputStream  inStream  =  new  BufferedInputStream  (  conn  .  getInputStream  (  )  )  ;  String  charSet  =   "UTF-8 "  ;  //  todo[must]:  get  from  content-encoding  ,  or  http-equiv  (  two-pass?  )    String  data  =  readInputStream  (  inStream  ,  charSet  )  ;  inStream  .  close  (  )  ;  return  data  ;  }    [METHOD]  load  [TYPE]  String  [PARAMETER]  URL  url  int  timeoutMillis  [CLASS]  DataUtil    [TYPE]  HttpURLConnection  conn  [TYPE]  boolean  false  true  [TYPE]  InputStream  inStream  [TYPE]  String  charSet  contentType  data  protocol  [TYPE]  URL  url  [TYPE]  int  res  timeoutMillis  
[ADD]  String  protocol  =  url  .  getProtocol  (  )  ;	[BUGGY]  [CE]  cannot  find  symbol  protocol  [CONTEXT]  static  String  load  (  URL  url  ,  int  timeoutMillis  )  throws  IOException  {  [ATTENTION]  Validate  .  isTrue  (  protocol  .  equals  (   "http "  )  ||  protocol  .  equals  (   "https "  )  ,   "Only  http  &  https  protocols  supported "  )  ;    HttpURLConnection  conn  =    (  HttpURLConnection  )  url  .  openConnection  (  )  ;  conn  .  setInstanceFollowRedirects  (  true  )  ;  conn  .  setConnectTimeout  (  timeoutMillis  )  ;  conn  .  setReadTimeout  (  timeoutMillis  )  ;  conn  .  connect  (  )  ;    int  res  =  conn  .  getResponseCode  (  )  ;  if  (  res  !  =  HttpURLConnection  .  HTTP_OK  )  throw  new  IOException  (  res  +   "  error  loading  URL   "  +  url  .  toString  (  )  )  ;    String  contentType  =  conn  .  getContentType  (  )  ;  if  (  contentType  =  =  null  ||  !contentType  .  startsWith  (   "text/ "  )  )  throw  new  IOException  (  String  .  format  (   "Unhandled  content  type  \ "%s\ "  on  URL  %s  .  Must  be  text/* "  ,  contentType  ,  url  .  toString  (  )  )  )  ;    InputStream  inStream  =  new  BufferedInputStream  (  conn  .  getInputStream  (  )  )  ;  String  charSet  =   "UTF-8 "  ;  //  todo[must]:  get  from  content-encoding  ,  or  http-equiv  (  two-pass?  )    String  data  =  readInputStream  (  inStream  ,  charSet  )  ;  inStream  .  close  (  )  ;  return  data  ;  }    [METHOD]  load  [TYPE]  String  [PARAMETER]  URL  url  int  timeoutMillis  [CLASS]  DataUtil    [TYPE]  HttpURLConnection  conn  [TYPE]  boolean  false  true  [TYPE]  InputStream  inStream  [TYPE]  String  charSet  contentType  data  protocol  [TYPE]  URL  url  [TYPE]  int  res  timeoutMillis  
[REPLACE]  Validate  .  isTrue  (  protocol  .  equals  (   "http "  )  ||  protocol  .  equals  (   "https "  )  ,   "Only  http  &  https  protocols  supported "  )  ;	[BUGGY]  Validate  .  isTrue  (  protocol  .  equals  (   "http "  )  &&  protocol  .  equals  (   "https "  )  ,   "Only  http  &  https  protocols  supported "  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  static  String  load  (  URL  url  ,  int  timeoutMillis  )  throws  IOException  {  String  protocol  =  url  .  getProtocol  (  )  ;  [ATTENTION]  Validate  .  isTrue  (  protocol  .  equals  (   "http "  )  &&  protocol  .  equals  (   "https "  )    ,   "Only  http  &  https  protocols  supported "  )    ;    HttpURLConnection  conn  =    (  HttpURLConnection  )  url  .  openConnection  (  )  ;  conn  .  setInstanceFollowRedirects  (  true  )  ;  conn  .  setConnectTimeout  (  timeoutMillis  )  ;  conn  .  setReadTimeout  (  timeoutMillis  )  ;  conn  .  connect  (  )  ;    int  res  =  conn  .  getResponseCode  (  )  ;  if  (  res  !  =  HttpURLConnection  .  HTTP_OK  )  throw  new  IOException  (  res  +   "  error  loading  URL   "  +  url  .  toString  (  )  )  ;    String  contentType  =  conn  .  getContentType  (  )  ;  if  (  contentType  =  =  null  ||  !contentType  .  startsWith  (   "text/ "  )  )  throw  new  IOException  (  String  .  format  (   "Unhandled  content  type  \ "%s\ "  on  URL  %s  .  Must  be  text/* "  ,  contentType  ,  url  .  toString  (  )  )  )  ;    InputStream  inStream  =  new  BufferedInputStream  (  conn  .  getInputStream  (  )  )  ;  String  charSet  =   "UTF-8 "  ;  //  todo[must]:  get  from  content-encoding  ,  or  http-equiv  (  two-pass?  )    String  data  =  readInputStream  (  inStream  ,  charSet  )  ;  inStream  .  close  (  )  ;  return  data  ;  }    [METHOD]  load  [TYPE]  String  [PARAMETER]  URL  url  int  timeoutMillis  [CLASS]  DataUtil    [TYPE]  HttpURLConnection  conn  [TYPE]  boolean  false  true  [TYPE]  InputStream  inStream  [TYPE]  String  charSet  contentType  data  protocol  [TYPE]  URL  url  [TYPE]  int  res  timeoutMillis  
[REPLACE]  Validate  .  isTrue  (  protocol  .  equals  (   "http "  )  ||  protocol  .  equals  (   "https "  )  ,   "Only  http  &  https  protocols  supported "  )  ;	[BUGGY]  Validate  .  isTrue  (  protocol  .  startsWith  (  data  )    ||  protocol[CE]  ')'  expected  [CONTEXT]  static  String  load  (  URL  url  ,  int  timeoutMillis  )  throws  IOException  {  String  protocol  =  url  .  getProtocol  (  )  ;  [ATTENTION]  Validate  .  isTrue  (  protocol  .  startsWith  (  data  )  ||  protocol  HttpURLConnection  conn  =    (  HttpURLConnection  )  url  .  openConnection  (  )  ;  conn  .  setInstanceFollowRedirects  (  true  )  ;  conn  .  setConnectTimeout  (  timeoutMillis  )  ;  conn  .  setReadTimeout  (  timeoutMillis  )  ;  conn  .  connect  (  )  ;    int  res  =  conn  .  getResponseCode  (  )  ;  if  (  res  !  =  HttpURLConnection  .  HTTP_OK  )  throw  new  IOException  (  res  +   "  error  loading  URL   "  +  url  .  toString  (  )  )  ;    String  contentType  =  conn  .  getContentType  (  )  ;  if  (  contentType  =  =  null  ||  !contentType  .  startsWith  (   "text/ "  )  )  throw  new  IOException  (  String  .  format  (   "Unhandled  content  type  \ "%s\ "  on  URL  %s  .  Must  be  text/* "  ,  contentType  ,  url  .  toString  (  )  )  )  ;    InputStream  inStream  =  new  BufferedInputStream  (  conn  .  getInputStream  (  )  )  ;  String  charSet  =   "UTF-8 "  ;  //  todo[must]:  get  from  content-encoding  ,  or  http-equiv  (  two-pass?  )    String  data  =  readInputStream  (  inStream  ,  charSet  )  ;  inStream  .  close  (  )  ;  return  data  ;  }    [METHOD]  load  [TYPE]  String  [PARAMETER]  URL  url  int  timeoutMillis  [CLASS]  DataUtil    [TYPE]  HttpURLConnection  conn  [TYPE]  boolean  false  true  [TYPE]  InputStream  inStream  [TYPE]  String  charSet  contentType  data  protocol  [TYPE]  URL  url  [TYPE]  int  res  timeoutMillis  
[REPLACE]  Validate  .  isTrue  (  protocol  .  equals  (   "http "  )  ||  protocol  .  equals  (   "https "  )  ,   "Only  http  &  https  protocols  supported "  )  ;	[BUGGY]  Validate  .  isTrue  (  data  .  equals  (   "http "  )  ||  protocol  .  equals  (   "https "  )  ,   "Only  http  &  https  protocols  supported "  )  ;  [CE]  cannot  find  symbol  data  [CONTEXT]  static  String  load  (  URL  url  ,  int  timeoutMillis  )  throws  IOException  {  String  protocol  =  url  .  getProtocol  (  )  ;  [ATTENTION]  Validate  .  isTrue  (  data  .  equals  (   "http "  )  ||  protocol  .  equals  (   "https "  )    ,   "Only  http  &  https  protocols  supported "  )    ;    HttpURLConnection  conn  =    (  HttpURLConnection  )  url  .  openConnection  (  )  ;  conn  .  setInstanceFollowRedirects  (  true  )  ;  conn  .  setConnectTimeout  (  timeoutMillis  )  ;  conn  .  setReadTimeout  (  timeoutMillis  )  ;  conn  .  connect  (  )  ;    int  res  =  conn  .  getResponseCode  (  )  ;  if  (  res  !  =  HttpURLConnection  .  HTTP_OK  )  throw  new  IOException  (  res  +   "  error  loading  URL   "  +  url  .  toString  (  )  )  ;    String  contentType  =  conn  .  getContentType  (  )  ;  if  (  contentType  =  =  null  ||  !contentType  .  startsWith  (   "text/ "  )  )  throw  new  IOException  (  String  .  format  (   "Unhandled  content  type  \ "%s\ "  on  URL  %s  .  Must  be  text/* "  ,  contentType  ,  url  .  toString  (  )  )  )  ;    InputStream  inStream  =  new  BufferedInputStream  (  conn  .  getInputStream  (  )  )  ;  String  charSet  =   "UTF-8 "  ;  //  todo[must]:  get  from  content-encoding  ,  or  http-equiv  (  two-pass?  )    String  data  =  readInputStream  (  inStream  ,  charSet  )  ;  inStream  .  close  (  )  ;  return  data  ;  }    [METHOD]  load  [TYPE]  String  [PARAMETER]  URL  url  int  timeoutMillis  [CLASS]  DataUtil    [TYPE]  HttpURLConnection  conn  [TYPE]  boolean  false  true  [TYPE]  InputStream  inStream  [TYPE]  String  charSet  contentType  data  protocol  [TYPE]  URL  url  [TYPE]  int  res  timeoutMillis  
[REPLACE]  HttpURLConnection  conn  =  (  HttpURLConnection  )  url  .  openConnection  (  )  ;	[BUGGY]  HttpURLConnection  conn  =    (  HttpURLConnection  )  url  .  getProtocol  (  )  ;  [CE]  inconvertible  types  [CONTEXT]  static  String  load  (  URL  url  ,  int  timeoutMillis  )  throws  IOException  {  String  protocol  =  url  .  getProtocol  (  )  ;  Validate  .  isTrue  (  protocol  .  equals  (   "http "  )  ||  protocol  .  equals  (   "https "  )  ,   "Only  http  &  https  protocols  supported "  )  ;    [ATTENTION]  HttpURLConnection  conn  =  (  HttpURLConnection  )  url  .  getProtocol  (  )    ;  conn  .  setInstanceFollowRedirects  (  true  )  ;  conn  .  setConnectTimeout  (  timeoutMillis  )  ;  conn  .  setReadTimeout  (  timeoutMillis  )  ;  conn  .  connect  (  )  ;    int  res  =  conn  .  getResponseCode  (  )  ;  if  (  res  !  =  HttpURLConnection  .  HTTP_OK  )  throw  new  IOException  (  res  +   "  error  loading  URL   "  +  url  .  toString  (  )  )  ;    String  contentType  =  conn  .  getContentType  (  )  ;  if  (  contentType  =  =  null  ||  !contentType  .  startsWith  (   "text/ "  )  )  throw  new  IOException  (  String  .  format  (   "Unhandled  content  type  \ "%s\ "  on  URL  %s  .  Must  be  text/* "  ,  contentType  ,  url  .  toString  (  )  )  )  ;    InputStream  inStream  =  new  BufferedInputStream  (  conn  .  getInputStream  (  )  )  ;  String  charSet  =   "UTF-8 "  ;  //  todo[must]:  get  from  content-encoding  ,  or  http-equiv  (  two-pass?  )    String  data  =  readInputStream  (  inStream  ,  charSet  )  ;  inStream  .  close  (  )  ;  return  data  ;  }    [METHOD]  load  [TYPE]  String  [PARAMETER]  URL  url  int  timeoutMillis  [CLASS]  DataUtil    [TYPE]  HttpURLConnection  conn  [TYPE]  boolean  false  true  [TYPE]  InputStream  inStream  [TYPE]  String  charSet  contentType  data  protocol  [TYPE]  URL  url  [TYPE]  int  res  timeoutMillis  
[REPLACE]  conn  .  setInstanceFollowRedirects  (  true  )  ;	[BUGGY]  conn  .  getResponseCode  (  )    ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  static  String  load  (  URL  url  ,  int  timeoutMillis  )  throws  IOException  {  String  protocol  =  url  .  getProtocol  (  )  ;  Validate  .  isTrue  (  protocol  .  equals  (   "http "  )  ||  protocol  .  equals  (   "https "  )  ,   "Only  http  &  https  protocols  supported "  )  ;    HttpURLConnection  conn  =    (  HttpURLConnection  )  url  .  openConnection  (  )  ;  [ATTENTION]  conn  .  getResponseCode  (  )  ;  conn  .  setConnectTimeout  (  timeoutMillis  )  ;  conn  .  setReadTimeout  (  timeoutMillis  )  ;  conn  .  connect  (  )  ;    int  res  =  conn  .  getResponseCode  (  )  ;  if  (  res  !  =  HttpURLConnection  .  HTTP_OK  )  throw  new  IOException  (  res  +   "  error  loading  URL   "  +  url  .  toString  (  )  )  ;    String  contentType  =  conn  .  getContentType  (  )  ;  if  (  contentType  =  =  null  ||  !contentType  .  startsWith  (   "text/ "  )  )  throw  new  IOException  (  String  .  format  (   "Unhandled  content  type  \ "%s\ "  on  URL  %s  .  Must  be  text/* "  ,  contentType  ,  url  .  toString  (  )  )  )  ;    InputStream  inStream  =  new  BufferedInputStream  (  conn  .  getInputStream  (  )  )  ;  String  charSet  =   "UTF-8 "  ;  //  todo[must]:  get  from  content-encoding  ,  or  http-equiv  (  two-pass?  )    String  data  =  readInputStream  (  inStream  ,  charSet  )  ;  inStream  .  close  (  )  ;  return  data  ;  }    [METHOD]  load  [TYPE]  String  [PARAMETER]  URL  url  int  timeoutMillis  [CLASS]  DataUtil    [TYPE]  HttpURLConnection  conn  [TYPE]  boolean  false  true  [TYPE]  InputStream  inStream  [TYPE]  String  charSet  contentType  data  protocol  [TYPE]  URL  url  [TYPE]  int  res  timeoutMillis  
[REPLACE]  conn  .  setConnectTimeout  (  timeoutMillis  )  ;	[BUGGY]  conn  .  setConnectTimeout  (  res  )  ;  [CE]  cannot  find  symbol  res  [CONTEXT]  static  String  load  (  URL  url  ,  int  timeoutMillis  )  throws  IOException  {  String  protocol  =  url  .  getProtocol  (  )  ;  Validate  .  isTrue  (  protocol  .  equals  (   "http "  )  ||  protocol  .  equals  (   "https "  )  ,   "Only  http  &  https  protocols  supported "  )  ;    HttpURLConnection  conn  =    (  HttpURLConnection  )  url  .  openConnection  (  )  ;  conn  .  setInstanceFollowRedirects  (  true  )  ;  [ATTENTION]  conn  .  setConnectTimeout  (  res  )    ;  conn  .  setReadTimeout  (  timeoutMillis  )  ;  conn  .  connect  (  )  ;    int  res  =  conn  .  getResponseCode  (  )  ;  if  (  res  !  =  HttpURLConnection  .  HTTP_OK  )  throw  new  IOException  (  res  +   "  error  loading  URL   "  +  url  .  toString  (  )  )  ;    String  contentType  =  conn  .  getContentType  (  )  ;  if  (  contentType  =  =  null  ||  !contentType  .  startsWith  (   "text/ "  )  )  throw  new  IOException  (  String  .  format  (   "Unhandled  content  type  \ "%s\ "  on  URL  %s  .  Must  be  text/* "  ,  contentType  ,  url  .  toString  (  )  )  )  ;    InputStream  inStream  =  new  BufferedInputStream  (  conn  .  getInputStream  (  )  )  ;  String  charSet  =   "UTF-8 "  ;  //  todo[must]:  get  from  content-encoding  ,  or  http-equiv  (  two-pass?  )    String  data  =  readInputStream  (  inStream  ,  charSet  )  ;  inStream  .  close  (  )  ;  return  data  ;  }    [METHOD]  load  [TYPE]  String  [PARAMETER]  URL  url  int  timeoutMillis  [CLASS]  DataUtil    [TYPE]  HttpURLConnection  conn  [TYPE]  boolean  false  true  [TYPE]  InputStream  inStream  [TYPE]  String  charSet  contentType  data  protocol  [TYPE]  URL  url  [TYPE]  int  res  timeoutMillis  
[REPLACE]  conn  .  setReadTimeout  (  timeoutMillis  )  ;	[BUGGY]  conn  .  setReadTimeout  (  res  )  ;  [CE]  cannot  find  symbol  res  [CONTEXT]  static  String  load  (  URL  url  ,  int  timeoutMillis  )  throws  IOException  {  String  protocol  =  url  .  getProtocol  (  )  ;  Validate  .  isTrue  (  protocol  .  equals  (   "http "  )  ||  protocol  .  equals  (   "https "  )  ,   "Only  http  &  https  protocols  supported "  )  ;    HttpURLConnection  conn  =    (  HttpURLConnection  )  url  .  openConnection  (  )  ;  conn  .  setInstanceFollowRedirects  (  true  )  ;  conn  .  setConnectTimeout  (  timeoutMillis  )  ;  [ATTENTION]  conn  .  setReadTimeout  (  res  )    ;  conn  .  connect  (  )  ;    int  res  =  conn  .  getResponseCode  (  )  ;  if  (  res  !  =  HttpURLConnection  .  HTTP_OK  )  throw  new  IOException  (  res  +   "  error  loading  URL   "  +  url  .  toString  (  )  )  ;    String  contentType  =  conn  .  getContentType  (  )  ;  if  (  contentType  =  =  null  ||  !contentType  .  startsWith  (   "text/ "  )  )  throw  new  IOException  (  String  .  format  (   "Unhandled  content  type  \ "%s\ "  on  URL  %s  .  Must  be  text/* "  ,  contentType  ,  url  .  toString  (  )  )  )  ;    InputStream  inStream  =  new  BufferedInputStream  (  conn  .  getInputStream  (  )  )  ;  String  charSet  =   "UTF-8 "  ;  //  todo[must]:  get  from  content-encoding  ,  or  http-equiv  (  two-pass?  )    String  data  =  readInputStream  (  inStream  ,  charSet  )  ;  inStream  .  close  (  )  ;  return  data  ;  }    [METHOD]  load  [TYPE]  String  [PARAMETER]  URL  url  int  timeoutMillis  [CLASS]  DataUtil    [TYPE]  HttpURLConnection  conn  [TYPE]  boolean  false  true  [TYPE]  InputStream  inStream  [TYPE]  String  charSet  contentType  data  protocol  [TYPE]  URL  url  [TYPE]  int  res  timeoutMillis  
[REPLACE]  conn  .  connect  (  )  ;	[BUGGY]  conn  .  getContentType  (  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  static  String  load  (  URL  url  ,  int  timeoutMillis  )  throws  IOException  {  String  protocol  =  url  .  getProtocol  (  )  ;  Validate  .  isTrue  (  protocol  .  equals  (   "http "  )  ||  protocol  .  equals  (   "https "  )  ,   "Only  http  &  https  protocols  supported "  )  ;    HttpURLConnection  conn  =    (  HttpURLConnection  )  url  .  openConnection  (  )  ;  conn  .  setInstanceFollowRedirects  (  true  )  ;  conn  .  setConnectTimeout  (  timeoutMillis  )  ;  conn  .  setReadTimeout  (  timeoutMillis  )  ;  [ATTENTION]  conn  .  getContentType  (  )    ;    int  res  =  conn  .  getResponseCode  (  )  ;  if  (  res  !  =  HttpURLConnection  .  HTTP_OK  )  throw  new  IOException  (  res  +   "  error  loading  URL   "  +  url  .  toString  (  )  )  ;    String  contentType  =  conn  .  getContentType  (  )  ;  if  (  contentType  =  =  null  ||  !contentType  .  startsWith  (   "text/ "  )  )  throw  new  IOException  (  String  .  format  (   "Unhandled  content  type  \ "%s\ "  on  URL  %s  .  Must  be  text/* "  ,  contentType  ,  url  .  toString  (  )  )  )  ;    InputStream  inStream  =  new  BufferedInputStream  (  conn  .  getInputStream  (  )  )  ;  String  charSet  =   "UTF-8 "  ;  //  todo[must]:  get  from  content-encoding  ,  or  http-equiv  (  two-pass?  )    String  data  =  readInputStream  (  inStream  ,  charSet  )  ;  inStream  .  close  (  )  ;  return  data  ;  }    [METHOD]  load  [TYPE]  String  [PARAMETER]  URL  url  int  timeoutMillis  [CLASS]  DataUtil    [TYPE]  HttpURLConnection  conn  [TYPE]  boolean  false  true  [TYPE]  InputStream  inStream  [TYPE]  String  charSet  contentType  data  protocol  [TYPE]  URL  url  [TYPE]  int  res  timeoutMillis  
[REPLACE]  int  res  =  conn  .  getResponseCode  (  )  ;	[BUGGY]  int  res  =  conn  .  setInstanceFollowRedirects  (  false  )    ;  [CE]  incompatible  types  [CONTEXT]  static  String  load  (  URL  url  ,  int  timeoutMillis  )  throws  IOException  {  String  protocol  =  url  .  getProtocol  (  )  ;  Validate  .  isTrue  (  protocol  .  equals  (   "http "  )  ||  protocol  .  equals  (   "https "  )  ,   "Only  http  &  https  protocols  supported "  )  ;    HttpURLConnection  conn  =    (  HttpURLConnection  )  url  .  openConnection  (  )  ;  conn  .  setInstanceFollowRedirects  (  true  )  ;  conn  .  setConnectTimeout  (  timeoutMillis  )  ;  conn  .  setReadTimeout  (  timeoutMillis  )  ;  conn  .  connect  (  )  ;    [ATTENTION]  int  res  =  conn  .  setInstanceFollowRedirects  (  false  )  ;  if  (  res  !  =  HttpURLConnection  .  HTTP_OK  )  throw  new  IOException  (  res  +   "  error  loading  URL   "  +  url  .  toString  (  )  )  ;    String  contentType  =  conn  .  getContentType  (  )  ;  if  (  contentType  =  =  null  ||  !contentType  .  startsWith  (   "text/ "  )  )  throw  new  IOException  (  String  .  format  (   "Unhandled  content  type  \ "%s\ "  on  URL  %s  .  Must  be  text/* "  ,  contentType  ,  url  .  toString  (  )  )  )  ;    InputStream  inStream  =  new  BufferedInputStream  (  conn  .  getInputStream  (  )  )  ;  String  charSet  =   "UTF-8 "  ;  //  todo[must]:  get  from  content-encoding  ,  or  http-equiv  (  two-pass?  )    String  data  =  readInputStream  (  inStream  ,  charSet  )  ;  inStream  .  close  (  )  ;  return  data  ;  }    [METHOD]  load  [TYPE]  String  [PARAMETER]  URL  url  int  timeoutMillis  [CLASS]  DataUtil    [TYPE]  HttpURLConnection  conn  [TYPE]  boolean  false  true  [TYPE]  InputStream  inStream  [TYPE]  String  charSet  contentType  data  protocol  [TYPE]  URL  url  [TYPE]  int  res  timeoutMillis  
[REPLACE]  if  (  res  !=  HttpURLConnection  .  HTTP_OK  )  throw  new  IOException  ( "   ")  ;	[BUGGY]  if  (  res    =  =    HttpURLConnection  .  HTTP_OK  )  throw  new  IOException  ( "   ")    ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  static  String  load  (  URL  url  ,  int  timeoutMillis  )  throws  IOException  {  String  protocol  =  url  .  getProtocol  (  )  ;  Validate  .  isTrue  (  protocol  .  equals  (   "http "  )  ||  protocol  .  equals  (   "https "  )  ,   "Only  http  &  https  protocols  supported "  )  ;    HttpURLConnection  conn  =    (  HttpURLConnection  )  url  .  openConnection  (  )  ;  conn  .  setInstanceFollowRedirects  (  true  )  ;  conn  .  setConnectTimeout  (  timeoutMillis  )  ;  conn  .  setReadTimeout  (  timeoutMillis  )  ;  conn  .  connect  (  )  ;    int  res  =  conn  .  getResponseCode  (  )  ;  [ATTENTION]  if  (  res  =  =  HttpURLConnection  .  HTTP_OK  )  throw  new  IOException  (   "   "  )  ;    String  contentType  =  conn  .  getContentType  (  )  ;  if  (  contentType  =  =  null  ||  !contentType  .  startsWith  (   "text/ "  )  )  throw  new  IOException  (  String  .  format  (   "Unhandled  content  type  \ "%s\ "  on  URL  %s  .  Must  be  text/* "  ,  contentType  ,  url  .  toString  (  )  )  )  ;    InputStream  inStream  =  new  BufferedInputStream  (  conn  .  getInputStream  (  )  )  ;  String  charSet  =   "UTF-8 "  ;  //  todo[must]:  get  from  content-encoding  ,  or  http-equiv  (  two-pass?  )    String  data  =  readInputStream  (  inStream  ,  charSet  )  ;  inStream  .  close  (  )  ;  return  data  ;  }    [METHOD]  load  [TYPE]  String  [PARAMETER]  URL  url  int  timeoutMillis  [CLASS]  DataUtil    [TYPE]  HttpURLConnection  conn  [TYPE]  boolean  false  true  [TYPE]  InputStream  inStream  [TYPE]  String  charSet  contentType  data  protocol  [TYPE]  URL  url  [TYPE]  int  res  timeoutMillis  
[ADD]  if  (  res  !=  HttpURLConnection  .  HTTP_OK  )  throw  new  IOException  ( "   ")  ;  String  contentType  =  conn  .  getContentType  (  )  ;  if  (  contentType  ==  null  ||  !contentType  .  startsWith  (   "text/ "  )  )	[BUGGY]  [CE]  cannot  find  symbol  contentType  [CONTEXT]  static  String  load  (  URL  url  ,  int  timeoutMillis  )  throws  IOException  {  String  protocol  =  url  .  getProtocol  (  )  ;  Validate  .  isTrue  (  protocol  .  equals  (   "http "  )  ||  protocol  .  equals  (   "https "  )  ,   "Only  http  &  https  protocols  supported "  )  ;    HttpURLConnection  conn  =    (  HttpURLConnection  )  url  .  openConnection  (  )  ;  conn  .  setInstanceFollowRedirects  (  true  )  ;  conn  .  setConnectTimeout  (  timeoutMillis  )  ;  conn  .  setReadTimeout  (  timeoutMillis  )  ;  conn  .  connect  (  )  ;    int  res  =  conn  .  getResponseCode  (  )  ;  [ATTENTION]      throw  new  IOException  (  String  .  format  (   "Unhandled  content  type  \ "%s\ "  on  URL  %s  .  Must  be  text/* "  ,  contentType  ,  url  .  toString  (  )  )  )  ;    InputStream  inStream  =  new  BufferedInputStream  (  conn  .  getInputStream  (  )  )  ;  String  charSet  =   "UTF-8 "  ;  //  todo[must]:  get  from  content-encoding  ,  or  http-equiv  (  two-pass?  )    String  data  =  readInputStream  (  inStream  ,  charSet  )  ;  inStream  .  close  (  )  ;  return  data  ;  }    [METHOD]  load  [TYPE]  String  [PARAMETER]  URL  url  int  timeoutMillis  [CLASS]  DataUtil    [TYPE]  HttpURLConnection  conn  [TYPE]  boolean  false  true  [TYPE]  InputStream  inStream  [TYPE]  String  charSet  contentType  data  protocol  [TYPE]  URL  url  [TYPE]  int  res  timeoutMillis  
[REPLACE]  throw  new  IOException  ( "   ")  ;	[BUGGY]  return  ;  [CE]  missing  return  value  [CONTEXT]  static  String  load  (  URL  url  ,  int  timeoutMillis  )  throws  IOException  {  String  protocol  =  url  .  getProtocol  (  )  ;  Validate  .  isTrue  (  protocol  .  equals  (   "http "  )  ||  protocol  .  equals  (   "https "  )  ,   "Only  http  &  https  protocols  supported "  )  ;    HttpURLConnection  conn  =    (  HttpURLConnection  )  url  .  openConnection  (  )  ;  conn  .  setInstanceFollowRedirects  (  true  )  ;  conn  .  setConnectTimeout  (  timeoutMillis  )  ;  conn  .  setReadTimeout  (  timeoutMillis  )  ;  conn  .  connect  (  )  ;    int  res  =  conn  .  getResponseCode  (  )  ;  if  (  res  !  =  HttpURLConnection  .  HTTP_OK  )  [ATTENTION]  return  ;    String  contentType  =  conn  .  getContentType  (  )  ;  if  (  contentType  =  =  null  ||  !contentType  .  startsWith  (   "text/ "  )  )  throw  new  IOException  (  String  .  format  (   "Unhandled  content  type  \ "%s\ "  on  URL  %s  .  Must  be  text/* "  ,  contentType  ,  url  .  toString  (  )  )  )  ;    InputStream  inStream  =  new  BufferedInputStream  (  conn  .  getInputStream  (  )  )  ;  String  charSet  =   "UTF-8 "  ;  //  todo[must]:  get  from  content-encoding  ,  or  http-equiv  (  two-pass?  )    String  data  =  readInputStream  (  inStream  ,  charSet  )  ;  inStream  .  close  (  )  ;  return  data  ;  }    [METHOD]  load  [TYPE]  String  [PARAMETER]  URL  url  int  timeoutMillis  [CLASS]  DataUtil    [TYPE]  HttpURLConnection  conn  [TYPE]  boolean  false  true  [TYPE]  InputStream  inStream  [TYPE]  String  charSet  contentType  data  protocol  [TYPE]  URL  url  [TYPE]  int  res  timeoutMillis  
[REPLACE]  throw  new  IOException  ( "   ")  ;	[BUGGY]  conn  .  connect  (  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  static  String  load  (  URL  url  ,  int  timeoutMillis  )  throws  IOException  {  String  protocol  =  url  .  getProtocol  (  )  ;  Validate  .  isTrue  (  protocol  .  equals  (   "http "  )  ||  protocol  .  equals  (   "https "  )  ,   "Only  http  &  https  protocols  supported "  )  ;    HttpURLConnection  conn  =    (  HttpURLConnection  )  url  .  openConnection  (  )  ;  conn  .  setInstanceFollowRedirects  (  true  )  ;  conn  .  setConnectTimeout  (  timeoutMillis  )  ;  conn  .  setReadTimeout  (  timeoutMillis  )  ;  conn  .  connect  (  )  ;    int  res  =  conn  .  getResponseCode  (  )  ;  if  (  res  !  =  HttpURLConnection  .  HTTP_OK  )  [ATTENTION]  conn  .  connect  (  )    ;    String  contentType  =  conn  .  getContentType  (  )  ;  if  (  contentType  =  =  null  ||  !contentType  .  startsWith  (   "text/ "  )  )  throw  new  IOException  (  String  .  format  (   "Unhandled  content  type  \ "%s\ "  on  URL  %s  .  Must  be  text/* "  ,  contentType  ,  url  .  toString  (  )  )  )  ;    InputStream  inStream  =  new  BufferedInputStream  (  conn  .  getInputStream  (  )  )  ;  String  charSet  =   "UTF-8 "  ;  //  todo[must]:  get  from  content-encoding  ,  or  http-equiv  (  two-pass?  )    String  data  =  readInputStream  (  inStream  ,  charSet  )  ;  inStream  .  close  (  )  ;  return  data  ;  }    [METHOD]  load  [TYPE]  String  [PARAMETER]  URL  url  int  timeoutMillis  [CLASS]  DataUtil    [TYPE]  HttpURLConnection  conn  [TYPE]  boolean  false  true  [TYPE]  InputStream  inStream  [TYPE]  String  charSet  contentType  data  protocol  [TYPE]  URL  url  [TYPE]  int  res  timeoutMillis  
[ADD]  throw  new  IOException  ( "   ")  ;	[BUGGY]  [CE]  not  a  statement  [CONTEXT]  static  String  load  (  URL  url  ,  int  timeoutMillis  )  throws  IOException  {  String  protocol  =  url  .  getProtocol  (  )  ;  Validate  .  isTrue  (  protocol  .  equals  (   "http "  )  ||  protocol  .  equals  (   "https "  )  ,   "Only  http  &  https  protocols  supported "  )  ;    HttpURLConnection  conn  =    (  HttpURLConnection  )  url  .  openConnection  (  )  ;  conn  .  setInstanceFollowRedirects  (  true  )  ;  conn  .  setConnectTimeout  (  timeoutMillis  )  ;  conn  .  setReadTimeout  (  timeoutMillis  )  ;  conn  .  connect  (  )  ;    int  res  =  conn  .  getResponseCode  (  )  ;  if  (  res  !  =  HttpURLConnection  .  HTTP_OK  )  [ATTENTION]    String  contentType  =  conn  .  getContentType  (  )  ;  if  (  contentType  =  =  null  ||  !contentType  .  startsWith  (   "text/ "  )  )  throw  new  IOException  (  String  .  format  (   "Unhandled  content  type  \ "%s\ "  on  URL  %s  .  Must  be  text/* "  ,  contentType  ,  url  .  toString  (  )  )  )  ;    InputStream  inStream  =  new  BufferedInputStream  (  conn  .  getInputStream  (  )  )  ;  String  charSet  =   "UTF-8 "  ;  //  todo[must]:  get  from  content-encoding  ,  or  http-equiv  (  two-pass?  )    String  data  =  readInputStream  (  inStream  ,  charSet  )  ;  inStream  .  close  (  )  ;  return  data  ;  }    [METHOD]  load  [TYPE]  String  [PARAMETER]  URL  url  int  timeoutMillis  [CLASS]  DataUtil    [TYPE]  HttpURLConnection  conn  [TYPE]  boolean  false  true  [TYPE]  InputStream  inStream  [TYPE]  String  charSet  contentType  data  protocol  [TYPE]  URL  url  [TYPE]  int  res  timeoutMillis  
[REPLACE]  String  contentType  =  conn  .  getContentType  (  )  ;	[BUGGY]  String  contentType  =  conn  .  connect  (  )  ;  [CE]  incompatible  types  [CONTEXT]  static  String  load  (  URL  url  ,  int  timeoutMillis  )  throws  IOException  {  String  protocol  =  url  .  getProtocol  (  )  ;  Validate  .  isTrue  (  protocol  .  equals  (   "http "  )  ||  protocol  .  equals  (   "https "  )  ,   "Only  http  &  https  protocols  supported "  )  ;    HttpURLConnection  conn  =    (  HttpURLConnection  )  url  .  openConnection  (  )  ;  conn  .  setInstanceFollowRedirects  (  true  )  ;  conn  .  setConnectTimeout  (  timeoutMillis  )  ;  conn  .  setReadTimeout  (  timeoutMillis  )  ;  conn  .  connect  (  )  ;    int  res  =  conn  .  getResponseCode  (  )  ;  if  (  res  !  =  HttpURLConnection  .  HTTP_OK  )  throw  new  IOException  (  res  +   "  error  loading  URL   "  +  url  .  toString  (  )  )  ;    [ATTENTION]  String  contentType  =  conn  .  connect  (  )    ;  if  (  contentType  =  =  null  ||  !contentType  .  startsWith  (   "text/ "  )  )  throw  new  IOException  (  String  .  format  (   "Unhandled  content  type  \ "%s\ "  on  URL  %s  .  Must  be  text/* "  ,  contentType  ,  url  .  toString  (  )  )  )  ;    InputStream  inStream  =  new  BufferedInputStream  (  conn  .  getInputStream  (  )  )  ;  String  charSet  =   "UTF-8 "  ;  //  todo[must]:  get  from  content-encoding  ,  or  http-equiv  (  two-pass?  )    String  data  =  readInputStream  (  inStream  ,  charSet  )  ;  inStream  .  close  (  )  ;  return  data  ;  }    [METHOD]  load  [TYPE]  String  [PARAMETER]  URL  url  int  timeoutMillis  [CLASS]  DataUtil    [TYPE]  HttpURLConnection  conn  [TYPE]  boolean  false  true  [TYPE]  InputStream  inStream  [TYPE]  String  charSet  contentType  data  protocol  [TYPE]  URL  url  [TYPE]  int  res  timeoutMillis  
[REPLACE]  if  (  contentType  ==  null  ||  !contentType  .  startsWith  (   "text/ "  )  )  t  contentType,  url  .  toString  (  )  )  )  ;	[BUGGY]  if  (  contentType  !  =  null  ||  !contentType  .  startsWith  (   "text/ "  )  )  t  contentType  ,  url  .  getProtocol  (  )  )  )  ;  [CE]  not  a  statement  [CONTEXT]  static  String  load  (  URL  url  ,  int  timeoutMillis  )  throws  IOException  {  String  protocol  =  url  .  getProtocol  (  )  ;  Validate  .  isTrue  (  protocol  .  equals  (   "http "  )  ||  protocol  .  equals  (   "https "  )  ,   "Only  http  &  https  protocols  supported "  )  ;    HttpURLConnection  conn  =    (  HttpURLConnection  )  url  .  openConnection  (  )  ;  conn  .  setInstanceFollowRedirects  (  true  )  ;  conn  .  setConnectTimeout  (  timeoutMillis  )  ;  conn  .  setReadTimeout  (  timeoutMillis  )  ;  conn  .  connect  (  )  ;    int  res  =  conn  .  getResponseCode  (  )  ;  if  (  res  !  =  HttpURLConnection  .  HTTP_OK  )  throw  new  IOException  (  res  +   "  error  loading  URL   "  +  url  .  toString  (  )  )  ;    String  contentType  =  conn  .  getContentType  (  )  ;  [ATTENTION]  if  (  contentType  !  =  null  ||  !contentType  .  startsWith  (   "text/ "  )  )  t  contentType  ,  url  .  getProtocol  (  )  )  )    ;      InputStream  inStream  =  new  BufferedInputStream  (  conn  .  getInputStream  (  )  )  ;  String  charSet  =   "UTF-8 "  ;  //  todo[must]:  get  from  content-encoding  ,  or  http-equiv  (  two-pass?  )    String  data  =  readInputStream  (  inStream  ,  charSet  )  ;  inStream  .  close  (  )  ;  return  data  ;  }    [METHOD]  load  [TYPE]  String  [PARAMETER]  URL  url  int  timeoutMillis  [CLASS]  DataUtil    [TYPE]  HttpURLConnection  conn  [TYPE]  boolean  false  true  [TYPE]  InputStream  inStream  [TYPE]  String  charSet  contentType  data  protocol  [TYPE]  URL  url  [TYPE]  int  res  timeoutMillis  
[REPLACE]  t  contentType,  url  .  toString  (  )  )  )  ;	[BUGGY]  return  ;  [CE]  missing  return  value  [CONTEXT]  static  String  load  (  URL  url  ,  int  timeoutMillis  )  throws  IOException  {  String  protocol  =  url  .  getProtocol  (  )  ;  Validate  .  isTrue  (  protocol  .  equals  (   "http "  )  ||  protocol  .  equals  (   "https "  )  ,   "Only  http  &  https  protocols  supported "  )  ;    HttpURLConnection  conn  =    (  HttpURLConnection  )  url  .  openConnection  (  )  ;  conn  .  setInstanceFollowRedirects  (  true  )  ;  conn  .  setConnectTimeout  (  timeoutMillis  )  ;  conn  .  setReadTimeout  (  timeoutMillis  )  ;  conn  .  connect  (  )  ;    int  res  =  conn  .  getResponseCode  (  )  ;  if  (  res  !  =  HttpURLConnection  .  HTTP_OK  )  throw  new  IOException  (  res  +   "  error  loading  URL   "  +  url  .  toString  (  )  )  ;    String  contentType  =  conn  .  getContentType  (  )  ;  if  (  contentType  =  =  null  ||  !contentType  .  startsWith  (   "text/ "  )  )  [ATTENTION]  return  ;    InputStream  inStream  =  new  BufferedInputStream  (  conn  .  getInputStream  (  )  )  ;  String  charSet  =   "UTF-8 "  ;  //  todo[must]:  get  from  content-encoding  ,  or  http-equiv  (  two-pass?  )    String  data  =  readInputStream  (  inStream  ,  charSet  )  ;  inStream  .  close  (  )  ;  return  data  ;  }    [METHOD]  load  [TYPE]  String  [PARAMETER]  URL  url  int  timeoutMillis  [CLASS]  DataUtil    [TYPE]  HttpURLConnection  conn  [TYPE]  boolean  false  true  [TYPE]  InputStream  inStream  [TYPE]  String  charSet  contentType  data  protocol  [TYPE]  URL  url  [TYPE]  int  res  timeoutMillis  
[REPLACE]  t  contentType,  url  .  toString  (  )  )  )  ;	[BUGGY]  t  protocol  ,  url  .  toString  (  )  )  )  ;  [CE]  not  a  statement  [CONTEXT]  static  String  load  (  URL  url  ,  int  timeoutMillis  )  throws  IOException  {  String  protocol  =  url  .  getProtocol  (  )  ;  Validate  .  isTrue  (  protocol  .  equals  (   "http "  )  ||  protocol  .  equals  (   "https "  )  ,   "Only  http  &  https  protocols  supported "  )  ;    HttpURLConnection  conn  =    (  HttpURLConnection  )  url  .  openConnection  (  )  ;  conn  .  setInstanceFollowRedirects  (  true  )  ;  conn  .  setConnectTimeout  (  timeoutMillis  )  ;  conn  .  setReadTimeout  (  timeoutMillis  )  ;  conn  .  connect  (  )  ;    int  res  =  conn  .  getResponseCode  (  )  ;  if  (  res  !  =  HttpURLConnection  .  HTTP_OK  )  throw  new  IOException  (  res  +   "  error  loading  URL   "  +  url  .  toString  (  )  )  ;    String  contentType  =  conn  .  getContentType  (  )  ;  if  (  contentType  =  =  null  ||  !contentType  .  startsWith  (   "text/ "  )  )  [ATTENTION]  t  protocol  ,  url  .  toString  (  )  )  )    ;    InputStream  inStream  =  new  BufferedInputStream  (  conn  .  getInputStream  (  )  )  ;  String  charSet  =   "UTF-8 "  ;  //  todo[must]:  get  from  content-encoding  ,  or  http-equiv  (  two-pass?  )    String  data  =  readInputStream  (  inStream  ,  charSet  )  ;  inStream  .  close  (  )  ;  return  data  ;  }    [METHOD]  load  [TYPE]  String  [PARAMETER]  URL  url  int  timeoutMillis  [CLASS]  DataUtil    [TYPE]  HttpURLConnection  conn  [TYPE]  boolean  false  true  [TYPE]  InputStream  inStream  [TYPE]  String  charSet  contentType  data  protocol  [TYPE]  URL  url  [TYPE]  int  res  timeoutMillis  
[REPLACE]  contentType,  url  .  toString  (  )  )  )  ;	[BUGGY]  contentType  ,  url  .  getProtocol  (  )    )  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  static  String  load  (  URL  url  ,  int  timeoutMillis  )  throws  IOException  {  String  protocol  =  url  .  getProtocol  (  )  ;  Validate  .  isTrue  (  protocol  .  equals  (   "http "  )  ||  protocol  .  equals  (   "https "  )  ,   "Only  http  &  https  protocols  supported "  )  ;    HttpURLConnection  conn  =    (  HttpURLConnection  )  url  .  openConnection  (  )  ;  conn  .  setInstanceFollowRedirects  (  true  )  ;  conn  .  setConnectTimeout  (  timeoutMillis  )  ;  conn  .  setReadTimeout  (  timeoutMillis  )  ;  conn  .  connect  (  )  ;    int  res  =  conn  .  getResponseCode  (  )  ;  if  (  res  !  =  HttpURLConnection  .  HTTP_OK  )  throw  new  IOException  (  res  +   "  error  loading  URL   "  +  url  .  toString  (  )  )  ;    String  contentType  =  conn  .  getContentType  (  )  ;  if  (  contentType  =  =  null  ||  !contentType  .  startsWith  (   "text/ "  )  )  throw  new  IOException  (  String  .  format  (   "Unhandled  content  type  \ "%s\ "  on  URL  %s  .  Must  be  text/* "  ,  [ATTENTION]  contentType  ,  url  .  getProtocol  (  )    )  )    ;    InputStream  inStream  =  new  BufferedInputStream  (  conn  .  getInputStream  (  )  )  ;  String  charSet  =   "UTF-8 "  ;  //  todo[must]:  get  from  content-encoding  ,  or  http-equiv  (  two-pass?  )    String  data  =  readInputStream  (  inStream  ,  charSet  )  ;  inStream  .  close  (  )  ;  return  data  ;  }    [METHOD]  load  [TYPE]  String  [PARAMETER]  URL  url  int  timeoutMillis  [CLASS]  DataUtil    [TYPE]  HttpURLConnection  conn  [TYPE]  boolean  false  true  [TYPE]  InputStream  inStream  [TYPE]  String  charSet  contentType  data  protocol  [TYPE]  URL  url  [TYPE]  int  res  timeoutMillis  
[REPLACE]  InputStream  inStream  =  new  BufferedInputStream  (  conn  .  getInputStream  (  )  )  ;	[BUGGY]  InputStream  inStream  =  new  BufferedInputStream  (  conn  .  getContentType  (  )  )  ;  [CE]  no  suitable  constructor  found  for  BufferedInputStream(String)  [CONTEXT]  static  String  load  (  URL  url  ,  int  timeoutMillis  )  throws  IOException  {  String  protocol  =  url  .  getProtocol  (  )  ;  Validate  .  isTrue  (  protocol  .  equals  (   "http "  )  ||  protocol  .  equals  (   "https "  )  ,   "Only  http  &  https  protocols  supported "  )  ;    HttpURLConnection  conn  =    (  HttpURLConnection  )  url  .  openConnection  (  )  ;  conn  .  setInstanceFollowRedirects  (  true  )  ;  conn  .  setConnectTimeout  (  timeoutMillis  )  ;  conn  .  setReadTimeout  (  timeoutMillis  )  ;  conn  .  connect  (  )  ;    int  res  =  conn  .  getResponseCode  (  )  ;  if  (  res  !  =  HttpURLConnection  .  HTTP_OK  )  throw  new  IOException  (  res  +   "  error  loading  URL   "  +  url  .  toString  (  )  )  ;    String  contentType  =  conn  .  getContentType  (  )  ;  if  (  contentType  =  =  null  ||  !contentType  .  startsWith  (   "text/ "  )  )  throw  new  IOException  (  String  .  format  (   "Unhandled  content  type  \ "%s\ "  on  URL  %s  .  Must  be  text/* "  ,  contentType  ,  url  .  toString  (  )  )  )  ;    [ATTENTION]  InputStream  inStream  =  new  BufferedInputStream  (  conn  .  getContentType  (  )  )    ;  String  charSet  =   "UTF-8 "  ;  //  todo[must]:  get  from  content-encoding  ,  or  http-equiv  (  two-pass?  )    String  data  =  readInputStream  (  inStream  ,  charSet  )  ;  inStream  .  close  (  )  ;  return  data  ;  }    [METHOD]  load  [TYPE]  String  [PARAMETER]  URL  url  int  timeoutMillis  [CLASS]  DataUtil    [TYPE]  HttpURLConnection  conn  [TYPE]  boolean  false  true  [TYPE]  InputStream  inStream  [TYPE]  String  charSet  contentType  data  protocol  [TYPE]  URL  url  [TYPE]  int  res  timeoutMillis  
[REPLACE]  String  charSet  =   "UTF-8 ";	[BUGGY]  int  res  =  conn  .  getResponseCode  (  )  ;  [CE]  variable  res  is  already  defined  in  method  load(URL  ,  int)  [CONTEXT]  static  String  load  (  URL  url  ,  int  timeoutMillis  )  throws  IOException  {  String  protocol  =  url  .  getProtocol  (  )  ;  Validate  .  isTrue  (  protocol  .  equals  (   "http "  )  ||  protocol  .  equals  (   "https "  )  ,   "Only  http  &  https  protocols  supported "  )  ;    HttpURLConnection  conn  =    (  HttpURLConnection  )  url  .  openConnection  (  )  ;  conn  .  setInstanceFollowRedirects  (  true  )  ;  conn  .  setConnectTimeout  (  timeoutMillis  )  ;  conn  .  setReadTimeout  (  timeoutMillis  )  ;  conn  .  connect  (  )  ;    int  res  =  conn  .  getResponseCode  (  )  ;  if  (  res  !  =  HttpURLConnection  .  HTTP_OK  )  throw  new  IOException  (  res  +   "  error  loading  URL   "  +  url  .  toString  (  )  )  ;    String  contentType  =  conn  .  getContentType  (  )  ;  if  (  contentType  =  =  null  ||  !contentType  .  startsWith  (   "text/ "  )  )  throw  new  IOException  (  String  .  format  (   "Unhandled  content  type  \ "%s\ "  on  URL  %s  .  Must  be  text/* "  ,  contentType  ,  url  .  toString  (  )  )  )  ;    InputStream  inStream  =  new  BufferedInputStream  (  conn  .  getInputStream  (  )  )  ;  [ATTENTION]  int  res  =  conn  .  getResponseCode  (  )    ;    String  data  =  readInputStream  (  inStream  ,  charSet  )  ;  inStream  .  close  (  )  ;  return  data  ;  }    [METHOD]  load  [TYPE]  String  [PARAMETER]  URL  url  int  timeoutMillis  [CLASS]  DataUtil    [TYPE]  HttpURLConnection  conn  [TYPE]  boolean  false  true  [TYPE]  InputStream  inStream  [TYPE]  String  charSet  contentType  data  protocol  [TYPE]  URL  url  [TYPE]  int  res  timeoutMillis  
[REPLACE]  String  data  =  readInputStream  (  inStream,  charSet  )  ;	[BUGGY]  String  data  =  readInputStream  (  inStream  ,  charsetName  )  ;  [CE]  cannot  find  symbol  charsetName  [CONTEXT]  static  String  load  (  URL  url  ,  int  timeoutMillis  )  throws  IOException  {  String  protocol  =  url  .  getProtocol  (  )  ;  Validate  .  isTrue  (  protocol  .  equals  (   "http "  )  ||  protocol  .  equals  (   "https "  )  ,   "Only  http  &  https  protocols  supported "  )  ;    HttpURLConnection  conn  =    (  HttpURLConnection  )  url  .  openConnection  (  )  ;  conn  .  setInstanceFollowRedirects  (  true  )  ;  conn  .  setConnectTimeout  (  timeoutMillis  )  ;  conn  .  setReadTimeout  (  timeoutMillis  )  ;  conn  .  connect  (  )  ;    int  res  =  conn  .  getResponseCode  (  )  ;  if  (  res  !  =  HttpURLConnection  .  HTTP_OK  )  throw  new  IOException  (  res  +   "  error  loading  URL   "  +  url  .  toString  (  )  )  ;    String  contentType  =  conn  .  getContentType  (  )  ;  if  (  contentType  =  =  null  ||  !contentType  .  startsWith  (   "text/ "  )  )  throw  new  IOException  (  String  .  format  (   "Unhandled  content  type  \ "%s\ "  on  URL  %s  .  Must  be  text/* "  ,  contentType  ,  url  .  toString  (  )  )  )  ;    InputStream  inStream  =  new  BufferedInputStream  (  conn  .  getInputStream  (  )  )  ;  String  charSet  =   "UTF-8 "  ;  //  todo[must]:  get  from  content-encoding  ,  or  http-equiv  (  two-pass?  )    [ATTENTION]  String  data  =  readInputStream  (  inStream  ,  charsetName  )    ;  inStream  .  close  (  )  ;  return  data  ;  }    [METHOD]  load  [TYPE]  String  [PARAMETER]  URL  url  int  timeoutMillis  [CLASS]  DataUtil    [TYPE]  HttpURLConnection  conn  [TYPE]  boolean  false  true  [TYPE]  InputStream  inStream  [TYPE]  String  charSet  contentType  data  protocol  [TYPE]  URL  url  [TYPE]  int  res  timeoutMillis  
[REPLACE]  inStream  .  close  (  )  ;	[BUGGY]  int  res  =  conn  .  getResponseCode  (  )  ;  [CE]  variable  res  is  already  defined  in  method  load(URL  ,  int)  [CONTEXT]  static  String  load  (  URL  url  ,  int  timeoutMillis  )  throws  IOException  {  String  protocol  =  url  .  getProtocol  (  )  ;  Validate  .  isTrue  (  protocol  .  equals  (   "http "  )  ||  protocol  .  equals  (   "https "  )  ,   "Only  http  &  https  protocols  supported "  )  ;    HttpURLConnection  conn  =    (  HttpURLConnection  )  url  .  openConnection  (  )  ;  conn  .  setInstanceFollowRedirects  (  true  )  ;  conn  .  setConnectTimeout  (  timeoutMillis  )  ;  conn  .  setReadTimeout  (  timeoutMillis  )  ;  conn  .  connect  (  )  ;    int  res  =  conn  .  getResponseCode  (  )  ;  if  (  res  !  =  HttpURLConnection  .  HTTP_OK  )  throw  new  IOException  (  res  +   "  error  loading  URL   "  +  url  .  toString  (  )  )  ;    String  contentType  =  conn  .  getContentType  (  )  ;  if  (  contentType  =  =  null  ||  !contentType  .  startsWith  (   "text/ "  )  )  throw  new  IOException  (  String  .  format  (   "Unhandled  content  type  \ "%s\ "  on  URL  %s  .  Must  be  text/* "  ,  contentType  ,  url  .  toString  (  )  )  )  ;    InputStream  inStream  =  new  BufferedInputStream  (  conn  .  getInputStream  (  )  )  ;  String  charSet  =   "UTF-8 "  ;  //  todo[must]:  get  from  content-encoding  ,  or  http-equiv  (  two-pass?  )    String  data  =  readInputStream  (  inStream  ,  charSet  )  ;  [ATTENTION]  int  res  =  conn  .  getResponseCode  (  )    ;  return  data  ;  }    [METHOD]  load  [TYPE]  String  [PARAMETER]  URL  url  int  timeoutMillis  [CLASS]  DataUtil    [TYPE]  HttpURLConnection  conn  [TYPE]  boolean  false  true  [TYPE]  InputStream  inStream  [TYPE]  String  charSet  contentType  data  protocol  [TYPE]  URL  url  [TYPE]  int  res  timeoutMillis  
[REPLACE]  return  data;	[BUGGY]  return  protocol  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  static  String  load  (  URL  url  ,  int  timeoutMillis  )  throws  IOException  {  String  protocol  =  url  .  getProtocol  (  )  ;  Validate  .  isTrue  (  protocol  .  equals  (   "http "  )  ||  protocol  .  equals  (   "https "  )  ,   "Only  http  &  https  protocols  supported "  )  ;    HttpURLConnection  conn  =    (  HttpURLConnection  )  url  .  openConnection  (  )  ;  conn  .  setInstanceFollowRedirects  (  true  )  ;  conn  .  setConnectTimeout  (  timeoutMillis  )  ;  conn  .  setReadTimeout  (  timeoutMillis  )  ;  conn  .  connect  (  )  ;    int  res  =  conn  .  getResponseCode  (  )  ;  if  (  res  !  =  HttpURLConnection  .  HTTP_OK  )  throw  new  IOException  (  res  +   "  error  loading  URL   "  +  url  .  toString  (  )  )  ;    String  contentType  =  conn  .  getContentType  (  )  ;  if  (  contentType  =  =  null  ||  !contentType  .  startsWith  (   "text/ "  )  )  throw  new  IOException  (  String  .  format  (   "Unhandled  content  type  \ "%s\ "  on  URL  %s  .  Must  be  text/* "  ,  contentType  ,  url  .  toString  (  )  )  )  ;    InputStream  inStream  =  new  BufferedInputStream  (  conn  .  getInputStream  (  )  )  ;  String  charSet  =   "UTF-8 "  ;  //  todo[must]:  get  from  content-encoding  ,  or  http-equiv  (  two-pass?  )    String  data  =  readInputStream  (  inStream  ,  charSet  )  ;  inStream  .  close  (  )  ;  [ATTENTION]  return  protocol  ;  }    [METHOD]  load  [TYPE]  String  [PARAMETER]  URL  url  int  timeoutMillis  [CLASS]  DataUtil    [TYPE]  HttpURLConnection  conn  [TYPE]  boolean  false  true  [TYPE]  InputStream  inStream  [TYPE]  String  charSet  contentType  data  protocol  [TYPE]  URL  url  [TYPE]  int  res  timeoutMillis  
[REPLACE]  char[]  buffer  =  new  char[0x20000];	[BUGGY]  StringBuilder  data  =  new  StringBuilder  (  0x20000  )  ;  [CE]  variable  data  is  already  defined  in  method  readInputStream(InputStream  ,  String)  [CONTEXT]  private  static  String  readInputStream  (  InputStream  inStream  ,  String  charsetName  )  throws  IOException  {  [ATTENTION]  StringBuilder  data  =  new  StringBuilder  (  0x20000  )    ;  StringBuilder  data  =  new  StringBuilder  (  0x20000  )  ;  Reader  inReader  =  new  InputStreamReader  (  inStream  ,  charsetName  )  ;  int  read  ;  do  {  read  =  inReader  .  read  (  buffer  ,  0  ,  buffer  .  length  )  ;  if  (  read  >  0  )  {  data  .  append  (  buffer  ,  0  ,  read  )  ;  }  }  while  (  read  >  =  0  )  ;    return  data  .  toString  (  )  ;  }    [METHOD]  readInputStream  [TYPE]  String  [PARAMETER]  InputStream  inStream  String  charsetName  [CLASS]  DataUtil    [TYPE]  boolean  false  true  [TYPE]  StringBuilder  data  [TYPE]  InputStream  inStream  [TYPE]  Reader  inReader  [TYPE]  String  charsetName  [TYPE]  int  read  [TYPE]  char[]  buffer  
[REPLACE]  StringBuilder  data  =  new  StringBuilder  (  0x20000  )  ;	[BUGGY]  char[]  buffer  =  new  char[0x20000]  ;  [CE]  variable  buffer  is  already  defined  in  method  readInputStream(InputStream  ,  String)  [CONTEXT]  private  static  String  readInputStream  (  InputStream  inStream  ,  String  charsetName  )  throws  IOException  {  char[]  buffer  =  new  char[0x20000]  ;  //  ~  130K  [ATTENTION]  char[]  buffer  =  new  char[0x20000]  ;  Reader  inReader  =  new  InputStreamReader  (  inStream  ,  charsetName  )  ;  int  read  ;  do  {  read  =  inReader  .  read  (  buffer  ,  0  ,  buffer  .  length  )  ;  if  (  read  >  0  )  {  data  .  append  (  buffer  ,  0  ,  read  )  ;  }  }  while  (  read  >  =  0  )  ;    return  data  .  toString  (  )  ;  }    [METHOD]  readInputStream  [TYPE]  String  [PARAMETER]  InputStream  inStream  String  charsetName  [CLASS]  DataUtil    [TYPE]  boolean  false  true  [TYPE]  StringBuilder  data  [TYPE]  InputStream  inStream  [TYPE]  Reader  inReader  [TYPE]  String  charsetName  [TYPE]  int  read  [TYPE]  char[]  buffer  
[ADD]  StringBuilder  data  =  new  StringBuilder  (  0x20000  )  ;  Reader  inReader  =  new  InputStreamReader  (  inStream,  charsetName  )  ;	[BUGGY]  Reader  inReader  =  new  InputStreamReader  (  inStream  ,  charsetName  )  ;  [CE]  cannot  find  symbol  data  [CONTEXT]  private  static  String  readInputStream  (  InputStream  inStream  ,  String  charsetName  )  throws  IOException  {  char[]  buffer  =  new  char[0x20000]  ;  //  ~  130K  [ATTENTION]  Reader  inReader  =  new  InputStreamReader  (  inStream  ,  charsetName  )    ;    int  read  ;  do  {  read  =  inReader  .  read  (  buffer  ,  0  ,  buffer  .  length  )  ;  if  (  read  >  0  )  {  data  .  append  (  buffer  ,  0  ,  read  )  ;  }  }  while  (  read  >  =  0  )  ;    return  data  .  toString  (  )  ;  }    [METHOD]  readInputStream  [TYPE]  String  [PARAMETER]  InputStream  inStream  String  charsetName  [CLASS]  DataUtil    [TYPE]  boolean  false  true  [TYPE]  StringBuilder  data  [TYPE]  InputStream  inStream  [TYPE]  Reader  inReader  [TYPE]  String  charsetName  [TYPE]  int  read  [TYPE]  char[]  buffer  
[REPLACE]  Reader  inReader  =  new  InputStreamReader  (  inStream,  charsetName  )  ;	[BUGGY]  String  data  =  readInputStream  (  inStream  ,  charSet  )  ;  [CE]  variable  data  is  already  defined  in  method  readInputStream(InputStream  ,  String)  [CONTEXT]  private  static  String  readInputStream  (  InputStream  inStream  ,  String  charsetName  )  throws  IOException  {  char[]  buffer  =  new  char[0x20000]  ;  //  ~  130K  StringBuilder  data  =  new  StringBuilder  (  0x20000  )  ;  [ATTENTION]  String  data  =  readInputStream  (  inStream  ,  charSet  )    ;  int  read  ;  do  {  read  =  inReader  .  read  (  buffer  ,  0  ,  buffer  .  length  )  ;  if  (  read  >  0  )  {  data  .  append  (  buffer  ,  0  ,  read  )  ;  }  }  while  (  read  >  =  0  )  ;    return  data  .  toString  (  )  ;  }    [METHOD]  readInputStream  [TYPE]  String  [PARAMETER]  InputStream  inStream  String  charsetName  [CLASS]  DataUtil    [TYPE]  boolean  false  true  [TYPE]  StringBuilder  data  [TYPE]  InputStream  inStream  [TYPE]  Reader  inReader  [TYPE]  String  charsetName  [TYPE]  int  read  [TYPE]  char[]  buffer  
[ADD]  Reader  inReader  =  new  InputStreamReader  (  inStream,  charsetName  )  ;  int  read;	[BUGGY]  int  read  ;  [CE]  cannot  find  symbol  inReader  [CONTEXT]  private  static  String  readInputStream  (  InputStream  inStream  ,  String  charsetName  )  throws  IOException  {  char[]  buffer  =  new  char[0x20000]  ;  //  ~  130K  StringBuilder  data  =  new  StringBuilder  (  0x20000  )  ;  [ATTENTION]  int  read  ;    do  {  read  =  inReader  .  read  (  buffer  ,  0  ,  buffer  .  length  )  ;  if  (  read  >  0  )  {  data  .  append  (  buffer  ,  0  ,  read  )  ;  }  }  while  (  read  >  =  0  )  ;    return  data  .  toString  (  )  ;  }    [METHOD]  readInputStream  [TYPE]  String  [PARAMETER]  InputStream  inStream  String  charsetName  [CLASS]  DataUtil    [TYPE]  boolean  false  true  [TYPE]  StringBuilder  data  [TYPE]  InputStream  inStream  [TYPE]  Reader  inReader  [TYPE]  String  charsetName  [TYPE]  int  read  [TYPE]  char[]  buffer  
[REPLACE]  int  read;	[BUGGY]  int  res  =  conn  .  getResponseCode  (  )  ;  [CE]  cannot  find  symbol  conn  [CONTEXT]  private  static  String  readInputStream  (  InputStream  inStream  ,  String  charsetName  )  throws  IOException  {  char[]  buffer  =  new  char[0x20000]  ;  //  ~  130K  StringBuilder  data  =  new  StringBuilder  (  0x20000  )  ;  Reader  inReader  =  new  InputStreamReader  (  inStream  ,  charsetName  )  ;  [ATTENTION]  int  res  =  conn  .  getResponseCode  (  )    ;  do  {  read  =  inReader  .  read  (  buffer  ,  0  ,  buffer  .  length  )  ;  if  (  read  >  0  )  {  data  .  append  (  buffer  ,  0  ,  read  )  ;  }  }  while  (  read  >  =  0  )  ;    return  data  .  toString  (  )  ;  }    [METHOD]  readInputStream  [TYPE]  String  [PARAMETER]  InputStream  inStream  String  charsetName  [CLASS]  DataUtil    [TYPE]  boolean  false  true  [TYPE]  StringBuilder  data  [TYPE]  InputStream  inStream  [TYPE]  Reader  inReader  [TYPE]  String  charsetName  [TYPE]  int  read  [TYPE]  char[]  buffer  
[REPLACE]  if  (  read  >  0  )  {	[BUGGY]  if  (  read  !  =    0  )  {[FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  private  static  String  readInputStream  (  InputStream  inStream  ,  String  charsetName  )  throws  IOException  {  char[]  buffer  =  new  char[0x20000]  ;  //  ~  130K  StringBuilder  data  =  new  StringBuilder  (  0x20000  )  ;  Reader  inReader  =  new  InputStreamReader  (  inStream  ,  charsetName  )  ;  int  read  ;  do  {  read  =  inReader  .  read  (  buffer  ,  0  ,  buffer  .  length  )  ;  [ATTENTION]  if  (  read!  =  0  )  {  data  .  append  (  buffer  ,  0  ,  read  )  ;  }  }  while  (  read  >  =  0  )  ;    return  data  .  toString  (  )  ;  }    [METHOD]  readInputStream  [TYPE]  String  [PARAMETER]  InputStream  inStream  String  charsetName  [CLASS]  DataUtil    [TYPE]  boolean  false  true  [TYPE]  StringBuilder  data  [TYPE]  InputStream  inStream  [TYPE]  Reader  inReader  [TYPE]  String  charsetName  [TYPE]  int  read  [TYPE]  char[]  buffer  
[REPLACE]  data  .  append  (  buffer,  0,  read  )  ;	[BUGGY]  data  .  append  (  buffer  ,  0  %  2  ,  read  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  private  static  String  readInputStream  (  InputStream  inStream  ,  String  charsetName  )  throws  IOException  {  char[]  buffer  =  new  char[0x20000]  ;  //  ~  130K  StringBuilder  data  =  new  StringBuilder  (  0x20000  )  ;  Reader  inReader  =  new  InputStreamReader  (  inStream  ,  charsetName  )  ;  int  read  ;  do  {  read  =  inReader  .  read  (  buffer  ,  0  ,  buffer  .  length  )  ;  if  (  read  >  0  )  {  [ATTENTION]  data  .  append  (  buffer  ,  0  %  2  ,  read  )    ;  }  }  while  (  read  >  =  0  )  ;    return  data  .  toString  (  )  ;  }    [METHOD]  readInputStream  [TYPE]  String  [PARAMETER]  InputStream  inStream  String  charsetName  [CLASS]  DataUtil    [TYPE]  boolean  false  true  [TYPE]  StringBuilder  data  [TYPE]  InputStream  inStream  [TYPE]  Reader  inReader  [TYPE]  String  charsetName  [TYPE]  int  read  [TYPE]  char[]  buffer  
[REPLACE]  read  =  inReader  .  read  (  buffer,  0,  buffer  .  length  )  ;	[BUGGY]  read  =  inReader  .  read  (  buffer  ,  0  ,  buffer  .  length  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  private  static  String  readInputStream  (  InputStream  inStream  ,  String  charsetName  )  throws  IOException  {  char[]  buffer  =  new  char[0x20000]  ;  //  ~  130K  StringBuilder  data  =  new  StringBuilder  (  0x20000  )  ;  Reader  inReader  =  new  InputStreamReader  (  inStream  ,  charsetName  )  ;  int  read  ;  do  {  [ATTENTION]  read  =  inReader  .  read  (  buffer  ,  0  ,  buffer  .  length  )    ;  if  (  read  >  0  )  {  data  .  append  (  buffer  ,  0  ,  read  )  ;  }  }  while  (  read  >  =  0  )  ;    return  data  .  toString  (  )  ;  }    [METHOD]  readInputStream  [TYPE]  String  [PARAMETER]  InputStream  inStream  String  charsetName  [CLASS]  DataUtil    [TYPE]  boolean  false  true  [TYPE]  StringBuilder  data  [TYPE]  InputStream  inStream  [TYPE]  Reader  inReader  [TYPE]  String  charsetName  [TYPE]  int  read  [TYPE]  char[]  buffer  
[ADD]  read  =  inReader  .  read  (  buffer,  0,  buffer  .  length  )  ;	[BUGGY]  [CE]  variable  read  might  not  have  been  initialized  [CONTEXT]  private  static  String  readInputStream  (  InputStream  inStream  ,  String  charsetName  )  throws  IOException  {  char[]  buffer  =  new  char[0x20000]  ;  //  ~  130K  StringBuilder  data  =  new  StringBuilder  (  0x20000  )  ;  Reader  inReader  =  new  InputStreamReader  (  inStream  ,  charsetName  )  ;  int  read  ;  do  {  [ATTENTION]  if  (  read  >  0  )  {  data  .  append  (  buffer  ,  0  ,  read  )  ;  }  }  while  (  read  >  =  0  )  ;    return  data  .  toString  (  )  ;  }    [METHOD]  readInputStream  [TYPE]  String  [PARAMETER]  InputStream  inStream  String  charsetName  [CLASS]  DataUtil    [TYPE]  boolean  false  true  [TYPE]  StringBuilder  data  [TYPE]  InputStream  inStream  [TYPE]  Reader  inReader  [TYPE]  String  charsetName  [TYPE]  int  read  [TYPE]  char[]  buffer  
[REPLACE]  return  data  .  toString  (  )  ;	[BUGGY]  return  data  ;  [CE]  incompatible  types  [CONTEXT]  private  static  String  readInputStream  (  InputStream  inStream  ,  String  charsetName  )  throws  IOException  {  char[]  buffer  =  new  char[0x20000]  ;  //  ~  130K  StringBuilder  data  =  new  StringBuilder  (  0x20000  )  ;  Reader  inReader  =  new  InputStreamReader  (  inStream  ,  charsetName  )  ;  int  read  ;  do  {  read  =  inReader  .  read  (  buffer  ,  0  ,  buffer  .  length  )  ;  if  (  read  >  0  )  {  data  .  append  (  buffer  ,  0  ,  read  )  ;  }  }  while  (  read  >  =  0  )  ;    [ATTENTION]  return  data  ;  }    [METHOD]  readInputStream  [TYPE]  String  [PARAMETER]  InputStream  inStream  String  charsetName  [CLASS]  DataUtil    [TYPE]  boolean  false  true  [TYPE]  StringBuilder  data  [TYPE]  InputStream  inStream  [TYPE]  Reader  inReader  [TYPE]  String  charsetName  [TYPE]  int  read  [TYPE]  char[]  buffer  
[REPLACE]  super  (  Tag  .  valueOf  (   "#root "  )  ,  baseUri  )  ;	[BUGGY]  super  (     "#root "    ,  baseUri  )  ;  [CE]  no  suitable  constructor  found  for  Element(String  ,  String)  [CONTEXT]  public  Document  (  String  baseUri  )  {  [ATTENTION]  super  (   "#root "  ,  baseUri  )    ;  }    [METHOD]  <init>  [TYPE]  String)  [PARAMETER]  String  baseUri  [CLASS]  Document    [TYPE]  boolean  false  true  [TYPE]  String  baseUri  
[ADD]  super  (  Tag  .  valueOf  (   "#root "  )  ,  baseUri  )  ;	[BUGGY]  [CE]  no  suitable  constructor  found  for  Element()  [CONTEXT]  public  Document  (  String  baseUri  )  {  [ATTENTION]  }    [METHOD]  <init>  [TYPE]  String)  [PARAMETER]  String  baseUri  [CLASS]  Document    [TYPE]  boolean  false  true  [TYPE]  String  baseUri  
[REPLACE]  Validate  .  notNull  (  baseUri  )  ;	[BUGGY]  baseUri    ;  [CE]  not  a  statement  [CONTEXT]  static  public  Document  createShell  (  String  baseUri  )  {  [ATTENTION]  baseUri  ;    Document  doc  =  new  Document  (  baseUri  )  ;  Element  html  =  doc  .  appendElement  (   "html "  )  ;  html  .  appendElement  (   "head "  )  ;  html  .  appendElement  (   "body "  )  ;    return  doc  ;  }    [METHOD]  createShell  [TYPE]  Document  [PARAMETER]  String  baseUri  [CLASS]  Document    [TYPE]  boolean  false  true  [TYPE]  Element  html  [TYPE]  String  baseUri  [TYPE]  Document  doc  
[REPLACE]  Document  doc  =  new  Document  (  baseUri  )  ;	[BUGGY]  Element  html  =  doc  .  appendElement  (   "html "  )  ;  [CE]  cannot  find  symbol  doc  [CONTEXT]  static  public  Document  createShell  (  String  baseUri  )  {  Validate  .  notNull  (  baseUri  )  ;    [ATTENTION]  Element  html  =  doc  .  appendElement  (   "html "  )    ;  Element  html  =  doc  .  appendElement  (   "html "  )  ;  html  .  appendElement  (   "head "  )  ;  html  .  appendElement  (   "body "  )  ;    return  doc  ;  }    [METHOD]  createShell  [TYPE]  Document  [PARAMETER]  String  baseUri  [CLASS]  Document    [TYPE]  boolean  false  true  [TYPE]  Element  html  [TYPE]  String  baseUri  [TYPE]  Document  doc  
[ADD]  Document  doc  =  new  Document  (  baseUri  )  ;  Element  html  =  doc  .  appendElement  (   "html "  )  ;	[BUGGY]  Element  html  =  doc  .  appendElement  (   "html "  )  ;  [CE]  cannot  find  symbol  doc  [CONTEXT]  static  public  Document  createShell  (  String  baseUri  )  {  Validate  .  notNull  (  baseUri  )  ;    [ATTENTION]  Element  html  =  doc  .  appendElement  (   "html "  )    ;    html  .  appendElement  (   "head "  )  ;  html  .  appendElement  (   "body "  )  ;    return  doc  ;  }    [METHOD]  createShell  [TYPE]  Document  [PARAMETER]  String  baseUri  [CLASS]  Document    [TYPE]  boolean  false  true  [TYPE]  Element  html  [TYPE]  String  baseUri  [TYPE]  Document  doc  
[REPLACE]  Element  html  =  doc  .  appendElement  (   "html "  )  ;	[BUGGY]  Element  html  =  doc  .  prependElement  (   "html "  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  static  public  Document  createShell  (  String  baseUri  )  {  Validate  .  notNull  (  baseUri  )  ;    Document  doc  =  new  Document  (  baseUri  )  ;  [ATTENTION]  Element  html  =  doc  .  prependElement  (   "html "  )    ;  html  .  appendElement  (   "head "  )  ;  html  .  appendElement  (   "body "  )  ;    return  doc  ;  }    [METHOD]  createShell  [TYPE]  Document  [PARAMETER]  String  baseUri  [CLASS]  Document    [TYPE]  boolean  false  true  [TYPE]  Element  html  [TYPE]  String  baseUri  [TYPE]  Document  doc  
[REPLACE]  html  .  appendElement  (   "head "  )  ;	[BUGGY]  html  .  prependElement  (  baseUri  )    ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  static  public  Document  createShell  (  String  baseUri  )  {  Validate  .  notNull  (  baseUri  )  ;    Document  doc  =  new  Document  (  baseUri  )  ;  Element  html  =  doc  .  appendElement  (   "html "  )  ;  [ATTENTION]  html  .  prependElement  (  baseUri  )  ;  html  .  appendElement  (   "body "  )  ;    return  doc  ;  }    [METHOD]  createShell  [TYPE]  Document  [PARAMETER]  String  baseUri  [CLASS]  Document    [TYPE]  boolean  false  true  [TYPE]  Element  html  [TYPE]  String  baseUri  [TYPE]  Document  doc  
[REPLACE]  html  .  appendElement  (   "body "  )  ;	[BUGGY]  html  .  text  (   "body "  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  static  public  Document  createShell  (  String  baseUri  )  {  Validate  .  notNull  (  baseUri  )  ;    Document  doc  =  new  Document  (  baseUri  )  ;  Element  html  =  doc  .  appendElement  (   "html "  )  ;  html  .  appendElement  (   "head "  )  ;  [ATTENTION]  html  .  text  (   "body "  )    ;    return  doc  ;  }    [METHOD]  createShell  [TYPE]  Document  [PARAMETER]  String  baseUri  [CLASS]  Document    [TYPE]  boolean  false  true  [TYPE]  Element  html  [TYPE]  String  baseUri  [TYPE]  Document  doc  
[ADD]  html  .  appendElement  (   "body "  )  ;	[BUGGY]  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  static  public  Document  createShell  (  String  baseUri  )  {  Validate  .  notNull  (  baseUri  )  ;    Document  doc  =  new  Document  (  baseUri  )  ;  Element  html  =  doc  .  appendElement  (   "html "  )  ;  html  .  appendElement  (   "head "  )  ;  [ATTENTION]    return  doc  ;  }    [METHOD]  createShell  [TYPE]  Document  [PARAMETER]  String  baseUri  [CLASS]  Document    [TYPE]  boolean  false  true  [TYPE]  Element  html  [TYPE]  String  baseUri  [TYPE]  Document  doc  
[REPLACE]  return  doc;	[BUGGY]  return   "#document "  ;  [CE]  incompatible  types  [CONTEXT]  static  public  Document  createShell  (  String  baseUri  )  {  Validate  .  notNull  (  baseUri  )  ;    Document  doc  =  new  Document  (  baseUri  )  ;  Element  html  =  doc  .  appendElement  (   "html "  )  ;  html  .  appendElement  (   "head "  )  ;  html  .  appendElement  (   "body "  )  ;    [ATTENTION]  return   "#document "  ;  }    [METHOD]  createShell  [TYPE]  Document  [PARAMETER]  String  baseUri  [CLASS]  Document    [TYPE]  boolean  false  true  [TYPE]  Element  html  [TYPE]  String  baseUri  [TYPE]  Document  doc  
[REPLACE]  return  getElementsByTag  (   "head "  )    .  first  (  )  ;	[BUGGY]  return  getElementsByTag  (   "body "  )  .  first  (  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  Element  head  (  )  {  [ATTENTION]  return  getElementsByTag  (   "body "  )    .  first  (  )    ;  }    [METHOD]  head  [TYPE]  Element  [PARAMETER]  [CLASS]  Document    [TYPE]  boolean  false  true  
[REPLACE]  return  getElementsByTag  (   "body "  )    .  first  (  )  ;	[BUGGY]  return  getElementsByTag  (   "head "  )  .  first  (  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  Element  body  (  )  {  [ATTENTION]  return  getElementsByTag  (   "head "  )    .  first  (  )    ;  }    [METHOD]  body  [TYPE]  Element  [PARAMETER]  [CLASS]  Document    [TYPE]  boolean  false  true  
[REPLACE]  Element  titleEl  =  getElementsByTag  (   "title "  )    .  first  (  )  ;	[BUGGY]  Element  titleEl  =  getElementsByTag  (   "title "  )    .  trim  (  )    ;  [CE]  cannot  find  symbol  [CONTEXT]  public  String  title  (  )  {  [ATTENTION]  Element  titleEl  =  getElementsByTag  (   "title "  )  .  trim  (  )  ;  return  titleEl  !  =  null  ?  titleEl  .  text  (  )  .  trim  (  )  :   " "  ;  }    [METHOD]  title  [TYPE]  String  [PARAMETER]  [CLASS]  Document    [TYPE]  boolean  false  true  [TYPE]  Element  titleEl  
[ADD]  Element  titleEl  =  getElementsByTag  (   "title "  )    .  first  (  )  ;  return  titleEl  !=  null  ?  titleEl  .  text  (  )    .  trim  (  )  :   " ";	[BUGGY]  [CE]  missing  return  statement  [CONTEXT]  public  String  title  (  )  {  [ATTENTION]    }    [METHOD]  title  [TYPE]  String  [PARAMETER]  [CLASS]  Document    [TYPE]  boolean  false  true  [TYPE]  Element  titleEl  
[REPLACE]  return  titleEl  !=  null  ?  titleEl  .  text  (  )    .  trim  (  )  :   " ";	[BUGGY]  return  titleEl  !  =  true  ?  titleEl  .  text  (  )  .  text  (  )  :   " "  ;  [CE]  incomparable  types:  Element  and  boolean  [CONTEXT]  public  String  title  (  )  {  Element  titleEl  =  getElementsByTag  (   "title "  )  .  first  (  )  ;  [ATTENTION]  return  titleEl  !  =  true  ?  titleEl  .  text  (  )    .  text  (  )  :   " "  ;  }    [METHOD]  title  [TYPE]  String  [PARAMETER]  [CLASS]  Document    [TYPE]  boolean  false  true  [TYPE]  Element  titleEl  
[REPLACE]  Validate  .  notNull  (  title  )  ;	[BUGGY]  title    ;  [CE]  not  a  statement  [CONTEXT]  public  void  title  (  String  title  )  {  [ATTENTION]  title  ;  Element  titleEl  =  getElementsByTag  (   "title "  )  .  first  (  )  ;  if  (  titleEl  =  =  null  )  {  //  add  to  head  head  (  )  .  appendElement  (   "title "  )  .  text  (  title  )  ;  }  else  {  titleEl  .  text  (  title  )  ;  }  }    [METHOD]  title  [TYPE]  void  [PARAMETER]  String  title  [CLASS]  Document    [TYPE]  boolean  false  true  [TYPE]  Element  titleEl  [TYPE]  String  title  
[REMOVE]  	[BUGGY]  Validate  .  notNull  (  baseUri  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  void  title  (  String  title  )  {  [ATTENTION]  Validate  .  notNull  (  title  )  ;    Validate  .  notNull  (  baseUri  )    ;  Element  titleEl  =  getElementsByTag  (   "title "  )  .  first  (  )  ;  if  (  titleEl  =  =  null  )  {  //  add  to  head  head  (  )  .  appendElement  (   "title "  )  .  text  (  title  )  ;  }  else  {  titleEl  .  text  (  title  )  ;  }    [METHOD]  title  [TYPE]  void  [PARAMETER]  String  title  [CLASS]  Document    [TYPE]  boolean  false  true  [TYPE]  Element  titleEl  [TYPE]  String  title  
[REPLACE]  Element  titleEl  =  getElementsByTag  (   "title "  )    .  first  (  )  ;	[BUGGY]  Element  html  =  doc  .  appendElement  (   "html "  )  ;  [CE]  cannot  find  symbol  doc  [CONTEXT]  public  void  title  (  String  title  )  {  Validate  .  notNull  (  title  )  ;  [ATTENTION]  Element  html  =  doc  .  appendElement  (   "html "  )    ;  if  (  titleEl  =  =  null  )  {  //  add  to  head  head  (  )  .  appendElement  (   "title "  )  .  text  (  title  )  ;  }  else  {  titleEl  .  text  (  title  )  ;  }  }    [METHOD]  title  [TYPE]  void  [PARAMETER]  String  title  [CLASS]  Document    [TYPE]  boolean  false  true  [TYPE]  Element  titleEl  [TYPE]  String  title  
[REPLACE]  if  (  titleEl  ==  null  )  {	[BUGGY]  if  (  titleEl  !  =  null  )  {[FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  void  title  (  String  title  )  {  Validate  .  notNull  (  title  )  ;  Element  titleEl  =  getElementsByTag  (   "title "  )  .  first  (  )  ;  [ATTENTION]  if  (  titleEl  !  =  null  )  {  head  (  )  .  appendElement  (   "title "  )  .  text  (  title  )  ;  }  else  {  titleEl  .  text  (  title  )  ;  }  }    [METHOD]  title  [TYPE]  void  [PARAMETER]  String  title  [CLASS]  Document    [TYPE]  boolean  false  true  [TYPE]  Element  titleEl  [TYPE]  String  title  
[REPLACE]  titleEl  .  text  (  title  )  ;	[BUGGY]  titleEl  .  appendElement  (  title  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  void  title  (  String  title  )  {  Validate  .  notNull  (  title  )  ;  Element  titleEl  =  getElementsByTag  (   "title "  )  .  first  (  )  ;  if  (  titleEl  =  =  null  )  {  //  add  to  head  head  (  )  .  appendElement  (   "title "  )  .  text  (  title  )  ;  }  else  {  [ATTENTION]  titleEl  .  appendElement  (  title  )    ;  }  }    [METHOD]  title  [TYPE]  void  [PARAMETER]  String  title  [CLASS]  Document    [TYPE]  boolean  false  true  [TYPE]  Element  titleEl  [TYPE]  String  title  
[ADD]  titleEl  .  text  (  title  )  ;	[BUGGY]  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  void  title  (  String  title  )  {  Validate  .  notNull  (  title  )  ;  Element  titleEl  =  getElementsByTag  (   "title "  )  .  first  (  )  ;  if  (  titleEl  =  =  null  )  {  //  add  to  head  head  (  )  .  appendElement  (   "title "  )  .  text  (  title  )  ;  }  else  {  [ATTENTION]  }  }    [METHOD]  title  [TYPE]  void  [PARAMETER]  String  title  [CLASS]  Document    [TYPE]  boolean  false  true  [TYPE]  Element  titleEl  [TYPE]  String  title  
[REPLACE]  head  (  )    .  appendElement  (   "title "  )    .  text  (  title  )  ;	[BUGGY]  head  (  )  .  appendElement  (   "title "  )  .  select  (  title  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  void  title  (  String  title  )  {  Validate  .  notNull  (  title  )  ;  Element  titleEl  =  getElementsByTag  (   "title "  )  .  first  (  )  ;  if  (  titleEl  =  =  null  )  {  //  add  to  head  [ATTENTION]  head  (  )    .  appendElement  (   "title "  )    .  select  (  title  )    ;  }  else  {  titleEl  .  text  (  title  )  ;  }  }    [METHOD]  title  [TYPE]  void  [PARAMETER]  String  title  [CLASS]  Document    [TYPE]  boolean  false  true  [TYPE]  Element  titleEl  [TYPE]  String  title  
[ADD]  head  (  )    .  appendElement  (   "title "  )    .  text  (  title  )  ;	[BUGGY]  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  void  title  (  String  title  )  {  Validate  .  notNull  (  title  )  ;  Element  titleEl  =  getElementsByTag  (   "title "  )  .  first  (  )  ;  if  (  titleEl  =  =  null  )  {  //  add  to  head  [ATTENTION]  }  else  {  titleEl  .  text  (  title  )  ;  }  }    [METHOD]  title  [TYPE]  void  [PARAMETER]  String  title  [CLASS]  Document    [TYPE]  boolean  false  true  [TYPE]  Element  titleEl  [TYPE]  String  title  
[REPLACE]  head  (  )    .  appendElement  (   "title "  )    .  text  (  title  )  ;	[BUGGY]  head  (  )    .  prependElement  (  title  )    .  text  (  title  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  void  title  (  String  title  )  {  Validate  .  notNull  (  title  )  ;  Element  titleEl  =  getElementsByTag  (   "title "  )  .  first  (  )  ;  if  (  titleEl  =  =  null  )  {  //  add  to  head  [ATTENTION]  head  (  )  .  prependElement  (  title  )  .  text  (  title  )    ;  }  else  {  titleEl  .  text  (  title  )  ;  }  }    [METHOD]  title  [TYPE]  void  [PARAMETER]  String  title  [CLASS]  Document    [TYPE]  boolean  false  true  [TYPE]  Element  titleEl  [TYPE]  String  title  
[REPLACE]  head  (  )    .  appendElement  (   "title "  )    .  text  (  title  )  ;	[BUGGY]  body  (  )  .  text  (  text  )  ;  [CE]  cannot  find  symbol  text  [CONTEXT]  public  void  title  (  String  title  )  {  Validate  .  notNull  (  title  )  ;  Element  titleEl  =  getElementsByTag  (   "title "  )  .  first  (  )  ;  if  (  titleEl  =  =  null  )  {  //  add  to  head  [ATTENTION]  body  (  )    .  text  (  text  )    ;  }  else  {  titleEl  .  text  (  title  )  ;  }  }    [METHOD]  title  [TYPE]  void  [PARAMETER]  String  title  [CLASS]  Document    [TYPE]  boolean  false  true  [TYPE]  Element  titleEl  [TYPE]  String  title  
[REPLACE]  return  new  Element  (  Tag  .  valueOf  (  tagName  )  ,  this  .  baseUri  (  )  )  ;	[BUGGY]  return  new  Element  (    tagName    ,  this  .  baseUri  (  )  )  ;  [CE]  no  suitable  constructor  found  for  Element(String  ,  String)  [CONTEXT]  public  Element  createElement  (  String  tagName  )  {  [ATTENTION]  return  new  Element  (  tagName  ,  this  .  baseUri  (  )  )    ;  }    [METHOD]  createElement  [TYPE]  Element  [PARAMETER]  String  tagName  [CLASS]  Document    [TYPE]  boolean  false  true  [TYPE]  String  tagName  
[REPLACE]  if  (  select  (   "html "  )    .  isEmpty  (  )  )  appendElement  (   "html "  )  ;	[BUGGY]  if  (  select  (   "html "  )    .  text  (  )    )  appendElement  (   "html "  )  ;  [CE]  incompatible  types  [CONTEXT]  public  Document  normalise  (  )  {  [ATTENTION]  if  (  select  (   "html "  )  .  text  (  )    )  appendElement  (   "html "  )    ;    if  (  head  (  )    =  =  null  )  select  (   "html "  )  .  first  (  )  .  prependElement  (   "head "  )  ;  if  (  body  (  )    =  =  null  )  select  (   "html "  )  .  first  (  )  .  appendElement  (   "body "  )  ;        normalise  (  head  (  )  )  ;  normalise  (  select  (   "html "  )  .  first  (  )  )  ;  normalise  (  this  )  ;    return  this  ;  }    [METHOD]  normalise  [TYPE]  Document  [PARAMETER]  [CLASS]  Document    [TYPE]  boolean  false  true  
[REPLACE]  appendElement  (   "html "  )  ;	[BUGGY]  select  (   "html "  )  .  first  (  )  .  appendElement  (   "body "  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  Document  normalise  (  )  {  if  (  select  (   "html "  )  .  isEmpty  (  )  )  [ATTENTION]  select  (   "html "  )    .  first  (  )    .  appendElement  (   "body "  )    ;  if  (  head  (  )    =  =  null  )  select  (   "html "  )  .  first  (  )  .  prependElement  (   "head "  )  ;  if  (  body  (  )    =  =  null  )  select  (   "html "  )  .  first  (  )  .  appendElement  (   "body "  )  ;        normalise  (  head  (  )  )  ;  normalise  (  select  (   "html "  )  .  first  (  )  )  ;  normalise  (  this  )  ;    return  this  ;  }    [METHOD]  normalise  [TYPE]  Document  [PARAMETER]  [CLASS]  Document    [TYPE]  boolean  false  true  
[ADD]  appendElement  (   "html "  )  ;	[BUGGY]  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  Document  normalise  (  )  {  if  (  select  (   "html "  )  .  isEmpty  (  )  )  [ATTENTION]  if  (  head  (  )    =  =  null  )  select  (   "html "  )  .  first  (  )  .  prependElement  (   "head "  )  ;  if  (  body  (  )    =  =  null  )  select  (   "html "  )  .  first  (  )  .  appendElement  (   "body "  )  ;        normalise  (  head  (  )  )  ;  normalise  (  select  (   "html "  )  .  first  (  )  )  ;  normalise  (  this  )  ;    return  this  ;  }    [METHOD]  normalise  [TYPE]  Document  [PARAMETER]  [CLASS]  Document    [TYPE]  boolean  false  true  
[REPLACE]  if  (  head  (  )  ==  null  )  select  (   "html "  )    .  first  (  )    .  prependElement  (   "head "  )  ;	[BUGGY]  if  (  head  (  )  !  =  null  )  select  (   "html "  )  .  first  (  )  .  appendElement  (   "head "  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  Document  normalise  (  )  {  if  (  select  (   "html "  )  .  isEmpty  (  )  )  appendElement  (   "html "  )  ;  [ATTENTION]  if  (  head  (  )  !  =  null  )  select  (   "html "  )    .  first  (  )    .  appendElement  (   "head "  )    ;    if  (  body  (  )    =  =  null  )  select  (   "html "  )  .  first  (  )  .  appendElement  (   "body "  )  ;        normalise  (  head  (  )  )  ;  normalise  (  select  (   "html "  )  .  first  (  )  )  ;  normalise  (  this  )  ;    return  this  ;  }    [METHOD]  normalise  [TYPE]  Document  [PARAMETER]  [CLASS]  Document    [TYPE]  boolean  false  true  
[ADD]  if  (  head  (  )  ==  null  )  select  (   "html "  )    .  first  (  )    .  prependElement  (   "head "  )  ;  if  (  body  (  )  ==  null  )  select  (   "html "  )    .  first  (  )    .  appendElement  (   "body "  )  ;	[BUGGY]  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  Document  normalise  (  )  {  if  (  select  (   "html "  )  .  isEmpty  (  )  )  appendElement  (   "html "  )  ;  [ATTENTION]          normalise  (  head  (  )  )  ;  normalise  (  select  (   "html "  )  .  first  (  )  )  ;  normalise  (  this  )  ;    return  this  ;  }    [METHOD]  normalise  [TYPE]  Document  [PARAMETER]  [CLASS]  Document    [TYPE]  boolean  false  true  
[REPLACE]  select  (   "html "  )    .  first  (  )    .  prependElement  (   "head "  )  ;	[BUGGY]  select  (   "html "  )  .  first  (  )  .  appendElement  (   "body "  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  Document  normalise  (  )  {  if  (  select  (   "html "  )  .  isEmpty  (  )  )  appendElement  (   "html "  )  ;  if  (  head  (  )    =  =  null  )  [ATTENTION]  select  (   "html "  )    .  first  (  )    .  appendElement  (   "body "  )    ;  if  (  body  (  )    =  =  null  )  select  (   "html "  )  .  first  (  )  .  appendElement  (   "body "  )  ;        normalise  (  head  (  )  )  ;  normalise  (  select  (   "html "  )  .  first  (  )  )  ;  normalise  (  this  )  ;    return  this  ;  }    [METHOD]  normalise  [TYPE]  Document  [PARAMETER]  [CLASS]  Document    [TYPE]  boolean  false  true  
[REPLACE]  select  (   "html "  )    .  first  (  )    .  prependElement  (   "head "  )  ;	[BUGGY]  select  (   "html "  )    .  trim  (  )    .  prependElement  (   "head "  )  ;  [CE]  cannot  find  symbol  [CONTEXT]  public  Document  normalise  (  )  {  if  (  select  (   "html "  )  .  isEmpty  (  )  )  appendElement  (   "html "  )  ;  if  (  head  (  )    =  =  null  )  [ATTENTION]  select  (   "html "  )  .  trim  (  )  .  prependElement  (   "head "  )    ;  if  (  body  (  )    =  =  null  )  select  (   "html "  )  .  first  (  )  .  appendElement  (   "body "  )  ;        normalise  (  head  (  )  )  ;  normalise  (  select  (   "html "  )  .  first  (  )  )  ;  normalise  (  this  )  ;    return  this  ;  }    [METHOD]  normalise  [TYPE]  Document  [PARAMETER]  [CLASS]  Document    [TYPE]  boolean  false  true  
[REPLACE]  if  (  body  (  )  ==  null  )  select  (   "html "  )    .  first  (  )    .  appendElement  (   "body "  )  ;	[BUGGY]  if  (  body  (  )  !  =  null  )  select  (   "html "  )    .  trim  (  )    .  appendElement  (   "body "  )  ;  [CE]  cannot  find  symbol  [CONTEXT]  public  Document  normalise  (  )  {  if  (  select  (   "html "  )  .  isEmpty  (  )  )  appendElement  (   "html "  )  ;  if  (  head  (  )    =  =  null  )  select  (   "html "  )  .  first  (  )  .  prependElement  (   "head "  )  ;  [ATTENTION]  if  (  body  (  )  !  =  null  )  select  (   "html "  )  .  trim  (  )  .  appendElement  (   "body "  )    ;        normalise  (  head  (  )  )  ;  normalise  (  select  (   "html "  )  .  first  (  )  )  ;  normalise  (  this  )  ;    return  this  ;  }    [METHOD]  normalise  [TYPE]  Document  [PARAMETER]  [CLASS]  Document    [TYPE]  boolean  false  true  
[ADD]  if  (  body  (  )  ==  null  )  select  (   "html "  )    .  first  (  )    .  appendElement  (   "body "  )  ;	[BUGGY]  select  (   "html "  )  .  first  (  )  .  appendElement  (   "body "  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  Document  normalise  (  )  {  if  (  select  (   "html "  )  .  isEmpty  (  )  )  appendElement  (   "html "  )  ;  if  (  head  (  )    =  =  null  )  select  (   "html "  )  .  first  (  )  .  prependElement  (   "head "  )  ;  [ATTENTION]  select  (   "html "  )    .  first  (  )    .  appendElement  (   "body "  )    ;        normalise  (  head  (  )  )  ;  normalise  (  select  (   "html "  )  .  first  (  )  )  ;  normalise  (  this  )  ;    return  this  ;  }    [METHOD]  normalise  [TYPE]  Document  [PARAMETER]  [CLASS]  Document    [TYPE]  boolean  false  true  
[REPLACE]  select  (   "html "  )    .  first  (  )    .  appendElement  (   "body "  )  ;	[BUGGY]  select  (   "html "  )  .  first  (  )  .  prependElement  (   "body "  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  Document  normalise  (  )  {  if  (  select  (   "html "  )  .  isEmpty  (  )  )  appendElement  (   "html "  )  ;  if  (  head  (  )    =  =  null  )  select  (   "html "  )  .  first  (  )  .  prependElement  (   "head "  )  ;  if  (  body  (  )    =  =  null  )  [ATTENTION]  select  (   "html "  )    .  first  (  )    .  prependElement  (   "body "  )    ;        normalise  (  head  (  )  )  ;  normalise  (  select  (   "html "  )  .  first  (  )  )  ;  normalise  (  this  )  ;    return  this  ;  }    [METHOD]  normalise  [TYPE]  Document  [PARAMETER]  [CLASS]  Document    [TYPE]  boolean  false  true  
[REPLACE]  select  (   "html "  )    .  first  (  )    .  appendElement  (   "body "  )  ;	[BUGGY]  select  (   "html "  )  .  first  (  )  .  prependElement  (   "head "  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  Document  normalise  (  )  {  if  (  select  (   "html "  )  .  isEmpty  (  )  )  appendElement  (   "html "  )  ;  if  (  head  (  )    =  =  null  )  select  (   "html "  )  .  first  (  )  .  prependElement  (   "head "  )  ;  if  (  body  (  )    =  =  null  )  [ATTENTION]  select  (   "html "  )    .  first  (  )    .  prependElement  (   "head "  )    ;        normalise  (  head  (  )  )  ;  normalise  (  select  (   "html "  )  .  first  (  )  )  ;  normalise  (  this  )  ;    return  this  ;  }    [METHOD]  normalise  [TYPE]  Document  [PARAMETER]  [CLASS]  Document    [TYPE]  boolean  false  true  
[REPLACE]  normalise  (  head  (  )  )  ;	[BUGGY]  normalise  (  select  (   "html "  )  .  first  (  )  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  Document  normalise  (  )  {  if  (  select  (   "html "  )  .  isEmpty  (  )  )  appendElement  (   "html "  )  ;  if  (  head  (  )    =  =  null  )  select  (   "html "  )  .  first  (  )  .  prependElement  (   "head "  )  ;  if  (  body  (  )    =  =  null  )  select  (   "html "  )  .  first  (  )  .  appendElement  (   "body "  )  ;        [ATTENTION]  normalise  (  select  (   "html "  )    .  first  (  )  )    ;  normalise  (  select  (   "html "  )  .  first  (  )  )  ;  normalise  (  this  )  ;    return  this  ;  }    [METHOD]  normalise  [TYPE]  Document  [PARAMETER]  [CLASS]  Document    [TYPE]  boolean  false  true  
[REMOVE]  	[BUGGY]  body  (  )  .  text  (  text  )  ;  [CE]  cannot  find  symbol  text  [CONTEXT]  public  Document  normalise  (  )  {  if  (  select  (   "html "  )  .  isEmpty  (  )  )  appendElement  (   "html "  )  ;  if  (  head  (  )    =  =  null  )  select  (   "html "  )  .  first  (  )  .  prependElement  (   "head "  )  ;  if  (  body  (  )    =  =  null  )  select  (   "html "  )  .  first  (  )  .  appendElement  (   "body "  )  ;        [ATTENTION]  normalise  (  head  (  )  )  ;    body  (  )    .  text  (  text  )    ;  normalise  (  select  (   "html "  )  .  first  (  )  )  ;  normalise  (  this  )  ;    return  this  ;      [METHOD]  normalise  [TYPE]  Document  [PARAMETER]  [CLASS]  Document    [TYPE]  boolean  false  true  
[REPLACE]  normalise  (  select  (   "html "  )    .  first  (  )  )  ;	[BUGGY]  select  (   "html "  )  .  first  (  )  .  appendElement  (   "body "  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  Document  normalise  (  )  {  if  (  select  (   "html "  )  .  isEmpty  (  )  )  appendElement  (   "html "  )  ;  if  (  head  (  )    =  =  null  )  select  (   "html "  )  .  first  (  )  .  prependElement  (   "head "  )  ;  if  (  body  (  )    =  =  null  )  select  (   "html "  )  .  first  (  )  .  appendElement  (   "body "  )  ;        normalise  (  head  (  )  )  ;  [ATTENTION]  select  (   "html "  )    .  first  (  )    .  appendElement  (   "body "  )    ;  normalise  (  this  )  ;    return  this  ;  }    [METHOD]  normalise  [TYPE]  Document  [PARAMETER]  [CLASS]  Document    [TYPE]  boolean  false  true  
[ADD]  normalise  (  select  (   "html "  )    .  first  (  )  )  ;	[BUGGY]  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  Document  normalise  (  )  {  if  (  select  (   "html "  )  .  isEmpty  (  )  )  appendElement  (   "html "  )  ;  if  (  head  (  )    =  =  null  )  select  (   "html "  )  .  first  (  )  .  prependElement  (   "head "  )  ;  if  (  body  (  )    =  =  null  )  select  (   "html "  )  .  first  (  )  .  appendElement  (   "body "  )  ;        normalise  (  head  (  )  )  ;  [ATTENTION]  normalise  (  this  )  ;    return  this  ;  }    [METHOD]  normalise  [TYPE]  Document  [PARAMETER]  [CLASS]  Document    [TYPE]  boolean  false  true  
[REMOVE]  	[BUGGY]  select  (   "html "  )  .  first  (  )  .  appendElement  (   "body "  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  Document  normalise  (  )  {  if  (  select  (   "html "  )  .  isEmpty  (  )  )  appendElement  (   "html "  )  ;  if  (  head  (  )    =  =  null  )  select  (   "html "  )  .  first  (  )  .  prependElement  (   "head "  )  ;  if  (  body  (  )    =  =  null  )  select  (   "html "  )  .  first  (  )  .  appendElement  (   "body "  )  ;        normalise  (  head  (  )  )  ;  [ATTENTION]  normalise  (  select  (   "html "  )  .  first  (  )  )  ;    select  (   "html "  )    .  first  (  )    .  appendElement  (   "body "  )    ;  normalise  (  this  )  ;    return  this  ;      [METHOD]  normalise  [TYPE]  Document  [PARAMETER]  [CLASS]  Document    [TYPE]  boolean  false  true  
[REPLACE]  normalise  (  this  )  ;	[BUGGY]  body  (  )  .  text  (  text  )  ;  [CE]  cannot  find  symbol  text  [CONTEXT]  public  Document  normalise  (  )  {  if  (  select  (   "html "  )  .  isEmpty  (  )  )  appendElement  (   "html "  )  ;  if  (  head  (  )    =  =  null  )  select  (   "html "  )  .  first  (  )  .  prependElement  (   "head "  )  ;  if  (  body  (  )    =  =  null  )  select  (   "html "  )  .  first  (  )  .  appendElement  (   "body "  )  ;        normalise  (  head  (  )  )  ;  normalise  (  select  (   "html "  )  .  first  (  )  )  ;  [ATTENTION]  body  (  )    .  text  (  text  )    ;    return  this  ;  }    [METHOD]  normalise  [TYPE]  Document  [PARAMETER]  [CLASS]  Document    [TYPE]  boolean  false  true  
[ADD]  normalise  (  this  )  ;	[BUGGY]  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  Document  normalise  (  )  {  if  (  select  (   "html "  )  .  isEmpty  (  )  )  appendElement  (   "html "  )  ;  if  (  head  (  )    =  =  null  )  select  (   "html "  )  .  first  (  )  .  prependElement  (   "head "  )  ;  if  (  body  (  )    =  =  null  )  select  (   "html "  )  .  first  (  )  .  appendElement  (   "body "  )  ;        normalise  (  head  (  )  )  ;  normalise  (  select  (   "html "  )  .  first  (  )  )  ;  [ATTENTION]    return  this  ;  }    [METHOD]  normalise  [TYPE]  Document  [PARAMETER]  [CLASS]  Document    [TYPE]  boolean  false  true  
[REPLACE]  return  this;	[BUGGY]  return  null  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  Document  normalise  (  )  {  if  (  select  (   "html "  )  .  isEmpty  (  )  )  appendElement  (   "html "  )  ;  if  (  head  (  )    =  =  null  )  select  (   "html "  )  .  first  (  )  .  prependElement  (   "head "  )  ;  if  (  body  (  )    =  =  null  )  select  (   "html "  )  .  first  (  )  .  appendElement  (   "body "  )  ;        normalise  (  head  (  )  )  ;  normalise  (  select  (   "html "  )  .  first  (  )  )  ;  normalise  (  this  )  ;    [ATTENTION]  return  null  ;  }    [METHOD]  normalise  [TYPE]  Document  [PARAMETER]  [CLASS]  Document    [TYPE]  boolean  false  true  
[REPLACE]  List<Node>  toMove  =  new  ArrayList<Node>  (  )  ;	[BUGGY]  for  (  Node  node:  toMove  )  {  element  .  removeChild  (  node  )  ;  [CE]  '  ;  '  expected  [CONTEXT]  private  void  normalise  (  Element  element  )  {  [ATTENTION]  for  (  Node  node:  toMove  )  {  element  .  removeChild  (  node  )    ;  for  (  Node  node:  element  .  childNodes  )  {  if  (  node  instanceof  TextNode  )  {  TextNode  tn  =    (  TextNode  )  node  ;  if  (  !tn  .  isBlank  (  )  )  toMove  .  add  (  tn  )  ;  }  }  for  (  Node  node:  toMove  )  {  element  .  removeChild  (  node  )  ;  body  (  )  .  prependChild  (  node  )  ;  body  (  )  .  prependChild  (  new  TextNode  (   "   "  ,   " "  )  )  ;  }  }    [METHOD]  normalise  [TYPE]  void  [PARAMETER]  Element  element  [CLASS]  Document    [TYPE]  boolean  false  true  [TYPE]  Element  element  [TYPE]  Node  node  [TYPE]  List  toMove  [TYPE]  TextNode  tn  
[REPLACE]  if  (  node  instanceof  TextNode  )  {	[BUGGY]  if  (  !  node  instanceof  TextNode  )  {[CE]  bad  operand  type  Node  for  unary  operator  '!'  [CONTEXT]  private  void  normalise  (  Element  element  )  {  List<Node>  toMove  =  new  ArrayList<Node>  (  )  ;  for  (  Node  node:  element  .  childNodes  )  {  [ATTENTION]  if  (  !  node  instanceof  TextNode  )  {  TextNode  tn  =    (  TextNode  )  node  ;  if  (  !tn  .  isBlank  (  )  )  toMove  .  add  (  tn  )  ;  }  }  for  (  Node  node:  toMove  )  {  element  .  removeChild  (  node  )  ;  body  (  )  .  prependChild  (  node  )  ;  body  (  )  .  prependChild  (  new  TextNode  (   "   "  ,   " "  )  )  ;  }  }    [METHOD]  normalise  [TYPE]  void  [PARAMETER]  Element  element  [CLASS]  Document    [TYPE]  boolean  false  true  [TYPE]  Element  element  [TYPE]  Node  node  [TYPE]  List  toMove  [TYPE]  TextNode  tn  
[REPLACE]  if  (  !tn  .  isBlank  (  )  )  toMove  .  add  (  tn  )  ;	[BUGGY]  if  (  !tn  .  isBlank  (  )  )  null  .  add  (  tn  )  ;  [CE]  <null>  cannot  be  dereferenced  [CONTEXT]  private  void  normalise  (  Element  element  )  {  List<Node>  toMove  =  new  ArrayList<Node>  (  )  ;  for  (  Node  node:  element  .  childNodes  )  {  if  (  node  instanceof  TextNode  )  {  TextNode  tn  =    (  TextNode  )  node  ;  [ATTENTION]  if  (  !tn  .  isBlank  (  )  )  null  .  add  (  tn  )    ;    }  }  for  (  Node  node:  toMove  )  {  element  .  removeChild  (  node  )  ;  body  (  )  .  prependChild  (  node  )  ;  body  (  )  .  prependChild  (  new  TextNode  (   "   "  ,   " "  )  )  ;  }  }    [METHOD]  normalise  [TYPE]  void  [PARAMETER]  Element  element  [CLASS]  Document    [TYPE]  boolean  false  true  [TYPE]  Element  element  [TYPE]  Node  node  [TYPE]  List  toMove  [TYPE]  TextNode  tn  
[ADD]  if  (  !tn  .  isBlank  (  )  )  toMove  .  add  (  tn  )  ;  }	[BUGGY]  toMove  .  add  (  tn  )  ;  [CE]  '  ;  '  expected  [CONTEXT]  private  void  normalise  (  Element  element  )  {  List<Node>  toMove  =  new  ArrayList<Node>  (  )  ;  for  (  Node  node:  element  .  childNodes  )  {  if  (  node  instanceof  TextNode  )  {  TextNode  tn  =    (  TextNode  )  node  ;  [ATTENTION]  toMove  .  add  (  tn  )    ;    }  for  (  Node  node:  toMove  )  {  element  .  removeChild  (  node  )  ;  body  (  )  .  prependChild  (  node  )  ;  body  (  )  .  prependChild  (  new  TextNode  (   "   "  ,   " "  )  )  ;  }  }    [METHOD]  normalise  [TYPE]  void  [PARAMETER]  Element  element  [CLASS]  Document    [TYPE]  boolean  false  true  [TYPE]  Element  element  [TYPE]  Node  node  [TYPE]  List  toMove  [TYPE]  TextNode  tn  
[REPLACE]  toMove  .  add  (  tn  )  ;	[BUGGY]  body  (  )  .  text  (  text  )  ;  [CE]  cannot  find  symbol  text  [CONTEXT]  private  void  normalise  (  Element  element  )  {  List<Node>  toMove  =  new  ArrayList<Node>  (  )  ;  for  (  Node  node:  element  .  childNodes  )  {  if  (  node  instanceof  TextNode  )  {  TextNode  tn  =    (  TextNode  )  node  ;  if  (  !tn  .  isBlank  (  )  )  [ATTENTION]  body  (  )    .  text  (  text  )    ;  }  }  for  (  Node  node:  toMove  )  {  element  .  removeChild  (  node  )  ;  body  (  )  .  prependChild  (  node  )  ;  body  (  )  .  prependChild  (  new  TextNode  (   "   "  ,   " "  )  )  ;  }  }    [METHOD]  normalise  [TYPE]  void  [PARAMETER]  Element  element  [CLASS]  Document    [TYPE]  boolean  false  true  [TYPE]  Element  element  [TYPE]  Node  node  [TYPE]  List  toMove  [TYPE]  TextNode  tn  
[REPLACE]  TextNode  tn  =  (  TextNode  )  node;	[BUGGY]  List<Node>  toMove  =  new  ArrayList<Node>  (  )  ;  [CE]  variable  toMove  is  already  defined  in  method  normalise(Element)  [CONTEXT]  private  void  normalise  (  Element  element  )  {  List<Node>  toMove  =  new  ArrayList<Node>  (  )  ;  for  (  Node  node:  element  .  childNodes  )  {  if  (  node  instanceof  TextNode  )  {  [ATTENTION]  List<Node>  toMove  =  new  ArrayList<Node>  (  )    ;  if  (  !tn  .  isBlank  (  )  )  toMove  .  add  (  tn  )  ;  }  }  for  (  Node  node:  toMove  )  {  element  .  removeChild  (  node  )  ;  body  (  )  .  prependChild  (  node  )  ;  body  (  )  .  prependChild  (  new  TextNode  (   "   "  ,   " "  )  )  ;  }  }    [METHOD]  normalise  [TYPE]  void  [PARAMETER]  Element  element  [CLASS]  Document    [TYPE]  boolean  false  true  [TYPE]  Element  element  [TYPE]  Node  node  [TYPE]  List  toMove  [TYPE]  TextNode  tn  
[REPLACE]  if  (  !tn  .  isBlank  (  )  )  toMove  .  add  (  tn  )  ;	[BUGGY]  if  (  tn  .  isBlank  (  )  )  toMove  .  add  (  tn  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  private  void  normalise  (  Element  element  )  {  List<Node>  toMove  =  new  ArrayList<Node>  (  )  ;  for  (  Node  node:  element  .  childNodes  )  {  if  (  node  instanceof  TextNode  )  {  TextNode  tn  =    (  TextNode  )  node  ;  [ATTENTION]  if  (  tn  .  isBlank  (  )  )  toMove  .  add  (  tn  )    ;    }  }  for  (  Node  node:  toMove  )  {  element  .  removeChild  (  node  )  ;  body  (  )  .  prependChild  (  node  )  ;  body  (  )  .  prependChild  (  new  TextNode  (   "   "  ,   " "  )  )  ;  }  }    [METHOD]  normalise  [TYPE]  void  [PARAMETER]  Element  element  [CLASS]  Document    [TYPE]  boolean  false  true  [TYPE]  Element  element  [TYPE]  Node  node  [TYPE]  List  toMove  [TYPE]  TextNode  tn  
[REPLACE]  for  (  Node  node:  element  .  childNodes  )  {	[BUGGY]  for  (  Node  node:  toMove  )  {  element  .  removeChild  (  node  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  private  void  normalise  (  Element  element  )  {  List<Node>  toMove  =  new  ArrayList<Node>  (  )  ;  [ATTENTION]  for  (  Node  node:  toMove  )  {  element  .  removeChild  (  node  )    ;  if  (  node  instanceof  TextNode  )  {  TextNode  tn  =    (  TextNode  )  node  ;  if  (  !tn  .  isBlank  (  )  )  toMove  .  add  (  tn  )  ;  }  }  for  (  Node  node:  toMove  )  {  element  .  removeChild  (  node  )  ;  body  (  )  .  prependChild  (  node  )  ;  body  (  )  .  prependChild  (  new  TextNode  (   "   "  ,   " "  )  )  ;  }  }    [METHOD]  normalise  [TYPE]  void  [PARAMETER]  Element  element  [CLASS]  Document    [TYPE]  boolean  false  true  [TYPE]  Element  element  [TYPE]  Node  node  [TYPE]  List  toMove  [TYPE]  TextNode  tn  
[ADD]  TextNode  tn  =  (  TextNode  )  node;	[BUGGY]  [CE]  cannot  find  symbol  tn  [CONTEXT]  private  void  normalise  (  Element  element  )  {  List<Node>  toMove  =  new  ArrayList<Node>  (  )  ;  for  (  Node  node:  element  .  childNodes  )  {  if  (  node  instanceof  TextNode  )  {  [ATTENTION]  if  (  !tn  .  isBlank  (  )  )  toMove  .  add  (  tn  )  ;  }  }  for  (  Node  node:  toMove  )  {  element  .  removeChild  (  node  )  ;  body  (  )  .  prependChild  (  node  )  ;  body  (  )  .  prependChild  (  new  TextNode  (   "   "  ,   " "  )  )  ;  }  }    [METHOD]  normalise  [TYPE]  void  [PARAMETER]  Element  element  [CLASS]  Document    [TYPE]  boolean  false  true  [TYPE]  Element  element  [TYPE]  Node  node  [TYPE]  List  toMove  [TYPE]  TextNode  tn  
[REPLACE]  for  (  Node  node:  toMove  )  {	[BUGGY]  for  (  Node  node:  toMove  )  {  element  .  removeChild  (  node  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  private  void  normalise  (  Element  element  )  {  List<Node>  toMove  =  new  ArrayList<Node>  (  )  ;  for  (  Node  node:  element  .  childNodes  )  {  if  (  node  instanceof  TextNode  )  {  TextNode  tn  =    (  TextNode  )  node  ;  if  (  !tn  .  isBlank  (  )  )  toMove  .  add  (  tn  )  ;  }  }  [ATTENTION]  for  (  Node  node:  toMove  )  {  element  .  removeChild  (  node  )    ;  element  .  removeChild  (  node  )  ;  body  (  )  .  prependChild  (  node  )  ;  body  (  )  .  prependChild  (  new  TextNode  (   "   "  ,   " "  )  )  ;  }  }    [METHOD]  normalise  [TYPE]  void  [PARAMETER]  Element  element  [CLASS]  Document    [TYPE]  boolean  false  true  [TYPE]  Element  element  [TYPE]  Node  node  [TYPE]  List  toMove  [TYPE]  TextNode  tn  
[REPLACE]  return  super  .  html  (  )  ;	[BUGGY]  return  super  .  isEmpty  (  )    ;  [CE]  cannot  find  symbol  [CONTEXT]  public  String  outerHtml  (  )  {  [ATTENTION]  return  super  .  isEmpty  (  )  ;  }    [METHOD]  outerHtml  [TYPE]  String  [PARAMETER]  [CLASS]  Document    [TYPE]  boolean  false  true  
[REPLACE]  body  (  )    .  text  (  text  )  ;	[BUGGY]  body  (  )  .  appendElement  (  text  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  Element  text  (  String  text  )  {  [ATTENTION]  body  (  )    .  appendElement  (  text  )    ;  return  this  ;  }    [METHOD]  text  [TYPE]  Element  [PARAMETER]  String  text  [CLASS]  Document    [TYPE]  boolean  false  true  [TYPE]  String  text  
[REPLACE]  body  (  )    .  text  (  text  )  ;	[BUGGY]  toMove  .  add  (  tn  )  ;  [CE]  cannot  find  symbol  tn  [CONTEXT]  public  Element  text  (  String  text  )  {  [ATTENTION]  toMove  .  add  (  tn  )    ;  return  this  ;  }    [METHOD]  text  [TYPE]  Element  [PARAMETER]  String  text  [CLASS]  Document    [TYPE]  boolean  false  true  [TYPE]  String  text  
[REPLACE]  return  this;	[BUGGY]  return  null  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  Element  text  (  String  text  )  {  body  (  )  .  text  (  text  )  ;  //  overridden  to  not  nuke  doc  structure  [ATTENTION]  return  null  ;  }    [METHOD]  text  [TYPE]  Element  [PARAMETER]  String  text  [CLASS]  Document    [TYPE]  boolean  false  true  [TYPE]  String  text  
[REPLACE]  return   "#document ";	[BUGGY]  return  doc  ;  [CE]  cannot  find  symbol  doc  [CONTEXT]  public  String  nodeName  (  )  {  [ATTENTION]  return  doc  ;  }    [METHOD]  nodeName  [TYPE]  String  [PARAMETER]  [CLASS]  Document    [TYPE]  boolean  false  true  
[REPLACE]  private  String  tagName;	[BUGGY]  private  char  tagName  ;  [CE]  incompatible  types  [CONTEXT]      [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator  
[REPLACE]  private  String  id;	[BUGGY]  private  char  id  ;  [CE]  incompatible  types  [CONTEXT]      [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator  
[REPLACE]  private  String  className;	[BUGGY]  private  char  className  ;  [CE]  incompatible  types  [CONTEXT]      [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator  
[REPLACE]  protected  String  key;	[BUGGY]  protected  byte  key  ;  [CE]  incompatible  types  [CONTEXT]      [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator  
[REPLACE]  protected  String  value;	[BUGGY]  private  String  value  ;  [CE]  value  has  private  access  in  AttributeKeyPair  [CONTEXT]      [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator  
[REPLACE]  this  .  tagName  =  tagName;	[BUGGY]  this  .  className  =  className  ;    ;  [CE]  cannot  find  symbol  className  [CONTEXT]  Tag  (  String  tagName  )  {  [ATTENTION]  this  .  className  =  className  ;    ;  }    [METHOD]  <init>  [TYPE]  String)  [PARAMETER]  String  tagName  [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [TYPE]  int  index  [TYPE]  String  className  id  key  tagName  value  [TYPE]  boolean  false  true  
[ADD]  this  .  tagName  =  tagName;	[BUGGY]  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  Tag  (  String  tagName  )  {  [ATTENTION]  }    [METHOD]  <init>  [TYPE]  String)  [PARAMETER]  String  tagName  [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [TYPE]  int  index  [TYPE]  String  className  id  key  tagName  value  [TYPE]  boolean  false  true  
[REPLACE]  this  .  id  =  id;	[BUGGY]  this  .  id  =    null  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  Id  (  String  id  )  {  [ATTENTION]  this  .  id  =  null  ;  }    [METHOD]  <init>  [TYPE]  String)  [PARAMETER]  String  id  [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [TYPE]  int  index  [TYPE]  String  className  id  key  tagName  value  [TYPE]  boolean  false  true  
[REPLACE]  this  .  className  =  className;	[BUGGY]  this  .  tagName  =  tagName  ;    ;  [CE]  cannot  find  symbol  tagName  [CONTEXT]  Class  (  String  className  )  {  [ATTENTION]  this  .  tagName  =  tagName  ;    ;  }    [METHOD]  <init>  [TYPE]  String)  [PARAMETER]  String  className  [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [TYPE]  int  index  [TYPE]  String  className  id  key  tagName  value  [TYPE]  boolean  false  true  
[REPLACE]  this  .  key  =  key;	[BUGGY]  this  .  key  =    null  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  Attribute  (  String  key  )  {  [ATTENTION]  this  .  key  =  null  ;  }    [METHOD]  <init>  [TYPE]  String)  [PARAMETER]  String  key  [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [TYPE]  int  index  [TYPE]  String  className  id  key  tagName  value  [TYPE]  boolean  false  true  
[REPLACE]  super  (  key,  value  )  ;	[BUGGY]  super  (  key  ,  tagName  )  ;  [CE]  cannot  find  symbol  tagName  [CONTEXT]  AttributeWithValue  (  String  key  ,  String  value  )  {  [ATTENTION]  super  (  key  ,  tagName  )    ;  }    [METHOD]  <init>  [TYPE]  String)  [PARAMETER]  String  key  String  value  [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [TYPE]  int  index  [TYPE]  String  className  id  key  tagName  value  [TYPE]  boolean  false  true  
[REPLACE]  super  (  key,  value  )  ;	[BUGGY]  super  (  key  ,  tagName  )  ;  [CE]  cannot  find  symbol  tagName  [CONTEXT]  AttributeWithValueNot  (  String  key  ,  String  value  )  {  [ATTENTION]  super  (  key  ,  tagName  )    ;  }    [METHOD]  <init>  [TYPE]  String)  [PARAMETER]  String  key  String  value  [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [TYPE]  int  index  [TYPE]  String  className  id  key  tagName  value  [TYPE]  boolean  false  true  
[REMOVE]  	[BUGGY]  this  .  key  =  key  .  trim  (  )  .  toLowerCase  (  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  AttributeWithValueNot  (  String  key  ,  String  value  )  {  [ATTENTION]  super  (  key  ,  value  )  ;      [METHOD]  <init>  [TYPE]  String)  [PARAMETER]  String  key  String  value  [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [TYPE]  int  index  [TYPE]  String  className  id  key  tagName  value  [TYPE]  boolean  false  true  
[REPLACE]  super  (  key,  value  )  ;	[BUGGY]  super  (  key  ,  tagName  )  ;  [CE]  cannot  find  symbol  tagName  [CONTEXT]  AttributeWithValueStarting  (  String  key  ,  String  value  )  {  [ATTENTION]  super  (  key  ,  tagName  )    ;  }    [METHOD]  <init>  [TYPE]  String)  [PARAMETER]  String  key  String  value  [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [TYPE]  int  index  [TYPE]  String  className  id  key  tagName  value  [TYPE]  boolean  false  true  
[REPLACE]  super  (  key,  value  )  ;	[BUGGY]  Validate  .  notEmpty  (  value  )  ;  [CE]  constructor  AttributeKeyPair  in  class  AttributeKeyPair  cannot  be  applied  to  given  types  ;  [CONTEXT]  AttributeWithValueEnding  (  String  key  ,  String  value  )  {  [ATTENTION]  Validate  .  notEmpty  (  value  )    ;  }    [METHOD]  <init>  [TYPE]  String)  [PARAMETER]  String  key  String  value  [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [TYPE]  int  index  [TYPE]  String  className  id  key  tagName  value  [TYPE]  boolean  false  true  
[REPLACE]  super  (  key,  value  )  ;	[BUGGY]  super  (  key  ,  tagName  )  ;  [CE]  cannot  find  symbol  tagName  [CONTEXT]  AttributeWithValueContaining  (  String  key  ,  String  value  )  {  [ATTENTION]  super  (  key  ,  tagName  )    ;  }    [METHOD]  <init>  [TYPE]  String)  [PARAMETER]  String  key  String  value  [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [TYPE]  int  index  [TYPE]  String  className  id  key  tagName  value  [TYPE]  boolean  false  true  
[ADD]  super  (  key,  value  )  ;	[BUGGY]  [CE]  constructor  AttributeKeyPair  in  class  AttributeKeyPair  cannot  be  applied  to  given  types  ;  [CONTEXT]  AttributeWithValueContaining  (  String  key  ,  String  value  )  {  [ATTENTION]  }    [METHOD]  <init>  [TYPE]  String)  [PARAMETER]  String  key  String  value  [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [TYPE]  int  index  [TYPE]  String  className  id  key  tagName  value  [TYPE]  boolean  false  true  
[REPLACE]  Validate  .  notEmpty  (  key  )  ;	[BUGGY]  key    ;  [CE]  not  a  statement  [CONTEXT]  AttributeKeyPair  (  String  key  ,  String  value  )  {  [ATTENTION]  key  ;  Validate  .  notEmpty  (  value  )  ;    this  .  key  =  key  .  trim  (  )  .  toLowerCase  (  )  ;  this  .  value  =  value  .  trim  (  )  .  toLowerCase  (  )  ;  }    [METHOD]  <init>  [TYPE]  String)  [PARAMETER]  String  key  String  value  [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [TYPE]  int  index  [TYPE]  String  className  id  key  tagName  value  [TYPE]  boolean  false  true  
[ADD]  Validate  .  notEmpty  (  key  )  ;	[BUGGY]  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  AttributeKeyPair  (  String  key  ,  String  value  )  {  [ATTENTION]  Validate  .  notEmpty  (  value  )  ;    this  .  key  =  key  .  trim  (  )  .  toLowerCase  (  )  ;  this  .  value  =  value  .  trim  (  )  .  toLowerCase  (  )  ;  }    [METHOD]  <init>  [TYPE]  String)  [PARAMETER]  String  key  String  value  [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [TYPE]  int  index  [TYPE]  String  className  id  key  tagName  value  [TYPE]  boolean  false  true  
[REPLACE]  Validate  .  notEmpty  (  value  )  ;	[BUGGY]  tagName    ;  [CE]  not  a  statement  [CONTEXT]  AttributeKeyPair  (  String  key  ,  String  value  )  {  Validate  .  notEmpty  (  key  )  ;  [ATTENTION]  tagName  ;    this  .  key  =  key  .  trim  (  )  .  toLowerCase  (  )  ;  this  .  value  =  value  .  trim  (  )  .  toLowerCase  (  )  ;  }    [METHOD]  <init>  [TYPE]  String)  [PARAMETER]  String  key  String  value  [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [TYPE]  int  index  [TYPE]  String  className  id  key  tagName  value  [TYPE]  boolean  false  true  
[REPLACE]  this  .  key  =  key  .  trim  (  )    .  toLowerCase  (  )  ;	[BUGGY]  this  .  value  =  value  .  trim  (  )  .  toLowerCase  (  )  ;    ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  AttributeKeyPair  (  String  key  ,  String  value  )  {  Validate  .  notEmpty  (  key  )  ;  Validate  .  notEmpty  (  value  )  ;    [ATTENTION]  this  .  value  =  value  .  trim  (  )    .  toLowerCase  (  )    ;    ;  this  .  value  =  value  .  trim  (  )  .  toLowerCase  (  )  ;  }    [METHOD]  <init>  [TYPE]  String)  [PARAMETER]  String  key  String  value  [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [TYPE]  int  index  [TYPE]  String  className  id  key  tagName  value  [TYPE]  boolean  false  true  
[ADD]  this  .  key  =  key  .  trim  (  )    .  toLowerCase  (  )  ;	[BUGGY]  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  AttributeKeyPair  (  String  key  ,  String  value  )  {  Validate  .  notEmpty  (  key  )  ;  Validate  .  notEmpty  (  value  )  ;    [ATTENTION]  this  .  value  =  value  .  trim  (  )  .  toLowerCase  (  )  ;  }    [METHOD]  <init>  [TYPE]  String)  [PARAMETER]  String  key  String  value  [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [TYPE]  int  index  [TYPE]  String  className  id  key  tagName  value  [TYPE]  boolean  false  true  
[REPLACE]  this  .  value  =  value  .  trim  (  )    .  toLowerCase  (  )  ;	[BUGGY]  this  .  key  =  key  .  trim  (  )  .  toLowerCase  (  )  ;    ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  AttributeKeyPair  (  String  key  ,  String  value  )  {  Validate  .  notEmpty  (  key  )  ;  Validate  .  notEmpty  (  value  )  ;    this  .  key  =  key  .  trim  (  )  .  toLowerCase  (  )  ;  [ATTENTION]  this  .  key  =  key  .  trim  (  )    .  toLowerCase  (  )    ;    ;  }    [METHOD]  <init>  [TYPE]  String)  [PARAMETER]  String  key  String  value  [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [TYPE]  int  index  [TYPE]  String  className  id  key  tagName  value  [TYPE]  boolean  false  true  
[REPLACE]  super  (  index  )  ;	[BUGGY]  super  (  key  ,  value  )  ;  [CE]  cannot  find  symbol  key  [CONTEXT]  IndexLessThan  (  int  index  )  {  [ATTENTION]  super  (  key  ,  value  )    ;  }    [METHOD]  <init>  [TYPE]  Evaluator$IndexLessThan(int)  [PARAMETER]  int  index  [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [TYPE]  int  index  [TYPE]  String  className  id  key  tagName  value  [TYPE]  boolean  false  true  
[REPLACE]  super  (  index  )  ;	[BUGGY]  super  (  key  ,  value  )  ;  [CE]  cannot  find  symbol  key  [CONTEXT]  IndexGreaterThan  (  int  index  )  {  [ATTENTION]  super  (  key  ,  value  )    ;  }    [METHOD]  <init>  [TYPE]  Evaluator$IndexGreaterThan(int)  [PARAMETER]  int  index  [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [TYPE]  int  index  [TYPE]  String  className  id  key  tagName  value  [TYPE]  boolean  false  true  
[REPLACE]  super  (  index  )  ;	[BUGGY]  super  (  key  ,  value  )  ;  [CE]  cannot  find  symbol  key  [CONTEXT]  IndexEquals  (  int  index  )  {  [ATTENTION]  super  (  key  ,  value  )    ;  }    [METHOD]  <init>  [TYPE]  Evaluator$IndexEquals(int)  [PARAMETER]  int  index  [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [TYPE]  int  index  [TYPE]  String  className  id  key  tagName  value  [TYPE]  boolean  false  true  
[REPLACE]  this  .  index  =  index;	[BUGGY]  this  .  index  =    null  ;  [CE]  incompatible  types  [CONTEXT]  IndexEvaluator  (  int  index  )  {  [ATTENTION]  this  .  index  =  null  ;  }    [METHOD]  <init>  [TYPE]  Evaluator$IndexEvaluator(int)  [PARAMETER]  int  index  [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [TYPE]  int  index  [TYPE]  String  className  id  key  tagName  value  [TYPE]  boolean  false  true  
[REPLACE]  return  (  element  .  tagName  (  )    .  equals  (  tagName  )  )  ;	[BUGGY]  return  (  element  .  tagName  (  )    .  contains  (  className  )    )  ;  [CE]  cannot  find  symbol  className  [CONTEXT]  public  boolean  matches  (  Element  element  )  {  [ATTENTION]  return  (  element  .  tagName  (  )  .  contains  (  className  )    )    ;  }    [METHOD]  matches  [TYPE]  boolean  [PARAMETER]  Element  element  [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [TYPE]  String  className  id  key  tagName  value  [TYPE]  boolean  false  true  [TYPE]  int  index  [TYPE]  Element  element  
[REPLACE]  return  (  id  .  equals  (  element  .  id  (  )  )  )  ;	[BUGGY]  return  (  id  .  equalsIgnoreCase  (  element  .  id  (  )  )  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  boolean  matches  (  Element  element  )  {  [ATTENTION]  return  (  id  .  equalsIgnoreCase  (  element  .  id  (  )  )  )    ;  }    [METHOD]  matches  [TYPE]  boolean  [PARAMETER]  Element  element  [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [TYPE]  String  className  id  key  tagName  value  [TYPE]  boolean  false  true  [TYPE]  int  index  [TYPE]  Element  element  
[REPLACE]  return  (  element  .  hasClass  (  className  )  )  ;	[BUGGY]  return  (  element  .  hasAttr  (  className  )  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  boolean  matches  (  Element  element  )  {  [ATTENTION]  return  (  element  .  hasAttr  (  className  )  )    ;  }    [METHOD]  matches  [TYPE]  boolean  [PARAMETER]  Element  element  [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [TYPE]  String  className  id  key  tagName  value  [TYPE]  boolean  false  true  [TYPE]  int  index  [TYPE]  Element  element  
[REPLACE]  return  (  element  .  hasAttr  (  key  )  )  ;	[BUGGY]  return  (  element  .  attr  (  key  )  )  ;  [CE]  incompatible  types  [CONTEXT]  public  boolean  matches  (  Element  element  )  {  [ATTENTION]  return  (  element  .  attr  (  key  )  )    ;  }    [METHOD]  matches  [TYPE]  boolean  [PARAMETER]  Element  element  [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [TYPE]  String  className  id  key  tagName  value  [TYPE]  boolean  false  true  [TYPE]  int  index  [TYPE]  Element  element  
[REPLACE]  return  (  value  .  equalsIgnoreCase  (  element  .  attr  (  key  )  )  )  ;	[BUGGY]  return  (  value  .  equals  (  element  .  attr  (  key  )  )  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  boolean  matches  (  Element  element  )  {  [ATTENTION]  return  (  value  .  equals  (  element  .  attr  (  key  )  )  )    ;  }    [METHOD]  matches  [TYPE]  boolean  [PARAMETER]  Element  element  [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [TYPE]  String  className  id  key  tagName  value  [TYPE]  boolean  false  true  [TYPE]  int  index  [TYPE]  Element  element  
[REPLACE]  return  (  !value  .  equalsIgnoreCase  (  element  .  attr  (  key  )  )  )  ;	[BUGGY]  return  (  value  .  equalsIgnoreCase  (  element  .  attr  (  key  )  )  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  boolean  matches  (  Element  element  )  {  [ATTENTION]  return  (  value  .  equalsIgnoreCase  (  element  .  attr  (  key  )  )  )    ;  }    [METHOD]  matches  [TYPE]  boolean  [PARAMETER]  Element  element  [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [TYPE]  String  className  id  key  tagName  value  [TYPE]  boolean  false  true  [TYPE]  int  index  [TYPE]  Element  element  
[REPLACE]  return  element  .  attr  (  key  )    .  toLowerCase  (  )    .  startsWith  (  value  )  ;	[BUGGY]  return  element  .  hasAttr  (  key  )  .  toLowerCase  (  )  .  startsWith  (  value  )  ;  [CE]  boolean  cannot  be  dereferenced  [CONTEXT]  public  boolean  matches  (  Element  element  )  {  [ATTENTION]  return  element  .  hasAttr  (  key  )    .  toLowerCase  (  )    .  startsWith  (  value  )    ;  }    [METHOD]  matches  [TYPE]  boolean  [PARAMETER]  Element  element  [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [TYPE]  String  className  id  key  tagName  value  [TYPE]  boolean  false  true  [TYPE]  int  index  [TYPE]  Element  element  
[REPLACE]  return  element  .  attr  (  key  )    .  toLowerCase  (  )    .  endsWith  (  value  )  ;	[BUGGY]  return  element  .  hasAttr  (  className  )    .  toLowerCase  (  )  .  endsWith  (  value  )  ;  [CE]  cannot  find  symbol  className  [CONTEXT]  public  boolean  matches  (  Element  element  )  {  [ATTENTION]  return  element  .  hasAttr  (  className  )  .  toLowerCase  (  )    .  endsWith  (  value  )    ;  }    [METHOD]  matches  [TYPE]  boolean  [PARAMETER]  Element  element  [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [TYPE]  String  className  id  key  tagName  value  [TYPE]  boolean  false  true  [TYPE]  int  index  [TYPE]  Element  element  
[REPLACE]  return  element  .  attr  (  key  )    .  toLowerCase  (  )    .  contains  (  value  )  ;	[BUGGY]  return  element  .  hasAttr  (  key  )  .  toLowerCase  (  )  .  contains  (  value  )  ;  [CE]  boolean  cannot  be  dereferenced  [CONTEXT]  public  boolean  matches  (  Element  element  )  {  [ATTENTION]  return  element  .  hasAttr  (  key  )    .  toLowerCase  (  )    .  contains  (  value  )    ;  }    [METHOD]  matches  [TYPE]  boolean  [PARAMETER]  Element  element  [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [TYPE]  String  className  id  key  tagName  value  [TYPE]  boolean  false  true  [TYPE]  int  index  [TYPE]  Element  element  
[REPLACE]  return  true;	[BUGGY]  return  false  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  boolean  matches  (  Element  element  )  {  [ATTENTION]  return  false  ;  }    [METHOD]  matches  [TYPE]  boolean  [PARAMETER]  Element  element  [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [TYPE]  String  className  id  key  tagName  value  [TYPE]  boolean  false  true  [TYPE]  int  index  [TYPE]  Element  element  
[REPLACE]  return  element  .  elementSiblingIndex  (  )  <  index;	[BUGGY]  return  element  .  attr  (  )  <  index  ;  [CE]  no  suitable  method  found  for  attr()  [CONTEXT]  public  boolean  matches  (  Element  element  )  {  [ATTENTION]  return  element  .  attr  (  )  <  index  ;  }    [METHOD]  matches  [TYPE]  boolean  [PARAMETER]  Element  element  [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [TYPE]  String  className  id  key  tagName  value  [TYPE]  boolean  false  true  [TYPE]  int  index  [TYPE]  Element  element  
[REPLACE]  return  element  .  elementSiblingIndex  (  )  >  index;	[BUGGY]  return  element  .  attr  (  )  >  index  ;  [CE]  no  suitable  method  found  for  attr()  [CONTEXT]  public  boolean  matches  (  Element  element  )  {  [ATTENTION]  return  element  .  attr  (  )  >  index  ;  }    [METHOD]  matches  [TYPE]  boolean  [PARAMETER]  Element  element  [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [TYPE]  String  className  id  key  tagName  value  [TYPE]  boolean  false  true  [TYPE]  int  index  [TYPE]  Element  element  
[REPLACE]  return  element  .  elementSiblingIndex  (  )  ==  index;	[BUGGY]  return  element  .  attr  (  )    =  =  index  ;  [CE]  no  suitable  method  found  for  attr()  [CONTEXT]  public  boolean  matches  (  Element  element  )  {  [ATTENTION]  return  element  .  attr  (  )  =  =  index  ;  }    [METHOD]  matches  [TYPE]  boolean  [PARAMETER]  Element  element  [CLASS]  Evaluator  Tag  Id  Class  Attribute  AttributeWithValue  AttributeWithValueNot  AttributeWithValueStarting  AttributeWithValueEnding  AttributeWithValueContaining  AttributeKeyPair  AllElements  IndexLessThan  IndexGreaterThan  IndexEquals  IndexEvaluator    [TYPE]  String  className  id  key  tagName  value  [TYPE]  boolean  false  true  [TYPE]  int  index  [TYPE]  Element  element  
[REPLACE]  private  String  tagName;	[BUGGY]  private  int  tagName  ;  [CE]  incompatible  types  [CONTEXT]    [METHOD]  matches  [TYPE]  boolean  [PARAMETER]  Element  element  [CLASS]  Tag    [TYPE]  String  className  id  key  tagName  value  [TYPE]  boolean  false  true  [TYPE]  int  index  [TYPE]  Element  element  
[REPLACE]  this  .  tagName  =  tagName;	[BUGGY]  this  .  tagName  =    null  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  Tag  (  String  tagName  )  {  [ATTENTION]  this  .  tagName  =  null  ;  }    [METHOD]  <init>  [TYPE]  String)  [PARAMETER]  String  tagName  [CLASS]  Tag    [TYPE]  String  tagName  [TYPE]  boolean  false  true  
[REPLACE]  this  .  id  =  id;	[BUGGY]  this  .  id  =    null  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  Id  (  String  id  )  {  [ATTENTION]  this  .  id  =  null  ;  }    [METHOD]  <init>  [TYPE]  String)  [PARAMETER]  String  id  [CLASS]  Id    [TYPE]  String  id  [TYPE]  boolean  false  true  
[REPLACE]  private  String  className;	[BUGGY]  private  byte  className  ;  [CE]  incompatible  types  [CONTEXT]    [METHOD]  matches  [TYPE]  boolean  [PARAMETER]  Element  element  [CLASS]  Class    [TYPE]  String  id  [TYPE]  Element  element  [TYPE]  boolean  false  true  
[REPLACE]  this  .  className  =  className;	[BUGGY]  this  .  className  =    null  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  Class  (  String  className  )  {  [ATTENTION]  this  .  className  =  null  ;  }    [METHOD]  <init>  [TYPE]  String)  [PARAMETER]  String  className  [CLASS]  Class    [TYPE]  String  className  [TYPE]  boolean  false  true  
[REPLACE]  private  String  key;	[BUGGY]  private  double  key  ;  [CE]  incompatible  types  [CONTEXT]    [METHOD]  matches  [TYPE]  boolean  [PARAMETER]  Element  element  [CLASS]  Attribute    [TYPE]  String  className  [TYPE]  Element  element  [TYPE]  boolean  false  true  
[REPLACE]  this  .  key  =  key;	[BUGGY]  this  .  key  =    null  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  Attribute  (  String  key  )  {  [ATTENTION]  this  .  key  =  null  ;  }    [METHOD]  <init>  [TYPE]  String)  [PARAMETER]  String  key  [CLASS]  Attribute    [TYPE]  String  key  [TYPE]  boolean  false  true  
[REPLACE]  super  (  key,  value  )  ;	[BUGGY]  return  (  value  .  equalsIgnoreCase  (  element  .  attr  (  key  )  )  )  ;  [CE]  constructor  AttributeKeyPair  in  class  AttributeKeyPair  cannot  be  applied  to  given  types  ;  [CONTEXT]  AttributeWithValue  (  String  key  ,  String  value  )  {  [ATTENTION]  return  (  value  .  equalsIgnoreCase  (  element  .  attr  (  key  )  )  )    ;  }    [METHOD]  <init>  [TYPE]  String)  [PARAMETER]  String  key  String  value  [CLASS]  AttributeWithValue    [TYPE]  boolean  false  true  [TYPE]  String  key  value  
[REPLACE]  super  (  key,  value  )  ;	[BUGGY]  return  (  !value  .  equalsIgnoreCase  (  element  .  attr  (  key  )  )  )  ;  [CE]  constructor  AttributeKeyPair  in  class  AttributeKeyPair  cannot  be  applied  to  given  types  ;  [CONTEXT]  AttributeWithValueNot  (  String  key  ,  String  value  )  {  [ATTENTION]  return  (  !value  .  equalsIgnoreCase  (  element  .  attr  (  key  )  )  )    ;  }    [METHOD]  <init>  [TYPE]  String)  [PARAMETER]  String  key  String  value  [CLASS]  AttributeWithValueNot    [TYPE]  boolean  false  true  [TYPE]  String  key  value  
[REPLACE]  super  (  key,  value  )  ;	[BUGGY]  return  element  .  attr  (  key  )  .  toLowerCase  (  )  .  startsWith  (  value  )  ;  [CE]  constructor  AttributeKeyPair  in  class  AttributeKeyPair  cannot  be  applied  to  given  types  ;  [CONTEXT]  AttributeWithValueStarting  (  String  key  ,  String  value  )  {  [ATTENTION]  return  element  .  attr  (  key  )    .  toLowerCase  (  )    .  startsWith  (  value  )    ;  }    [METHOD]  <init>  [TYPE]  String)  [PARAMETER]  String  key  String  value  [CLASS]  AttributeWithValueStarting    [TYPE]  boolean  false  true  [TYPE]  String  key  value  
[ADD]  super  (  key,  value  )  ;	[BUGGY]  [CE]  constructor  AttributeKeyPair  in  class  AttributeKeyPair  cannot  be  applied  to  given  types  ;  [CONTEXT]  AttributeWithValueStarting  (  String  key  ,  String  value  )  {  [ATTENTION]  }    [METHOD]  <init>  [TYPE]  String)  [PARAMETER]  String  key  String  value  [CLASS]  AttributeWithValueStarting    [TYPE]  boolean  false  true  [TYPE]  String  key  value  
[REPLACE]  super  (  key,  value  )  ;	[BUGGY]  return  element  .  attr  (  key  )  .  toLowerCase  (  )  .  endsWith  (  value  )  ;  [CE]  constructor  AttributeKeyPair  in  class  AttributeKeyPair  cannot  be  applied  to  given  types  ;  [CONTEXT]  AttributeWithValueEnding  (  String  key  ,  String  value  )  {  [ATTENTION]  return  element  .  attr  (  key  )    .  toLowerCase  (  )    .  endsWith  (  value  )    ;  }    [METHOD]  <init>  [TYPE]  String)  [PARAMETER]  String  key  String  value  [CLASS]  AttributeWithValueEnding    [TYPE]  boolean  false  true  [TYPE]  String  key  value  
[REPLACE]  return  element  .  attr  (  key  )    .  toLowerCase  (  )    .  endsWith  (  value  )  ;	[BUGGY]  return  element  .  attr  (  key  )  .  toLowerCase  (  )    .  toLowerCase  (  )    ;  [CE]  incompatible  types  [CONTEXT]  public  boolean  matches  (  Element  element  )  {  [ATTENTION]  return  element  .  attr  (  key  )    .  toLowerCase  (  )  .  toLowerCase  (  )  ;  }    [METHOD]  matches  [TYPE]  boolean  [PARAMETER]  Element  element  [CLASS]  AttributeWithValueEnding    [TYPE]  boolean  false  true  [TYPE]  Element  element  
[REPLACE]  super  (  key,  value  )  ;	[BUGGY]  return  element  .  attr  (  key  )  .  toLowerCase  (  )  .  contains  (  value  )  ;  [CE]  constructor  AttributeKeyPair  in  class  AttributeKeyPair  cannot  be  applied  to  given  types  ;  [CONTEXT]  AttributeWithValueContaining  (  String  key  ,  String  value  )  {  [ATTENTION]  return  element  .  attr  (  key  )    .  toLowerCase  (  )    .  contains  (  value  )    ;  }    [METHOD]  <init>  [TYPE]  String)  [PARAMETER]  String  key  String  value  [CLASS]  AttributeWithValueContaining    [TYPE]  boolean  false  true  [TYPE]  String  key  value  
[ADD]  super  (  key,  value  )  ;	[BUGGY]  [CE]  constructor  AttributeKeyPair  in  class  AttributeKeyPair  cannot  be  applied  to  given  types  ;  [CONTEXT]  AttributeWithValueContaining  (  String  key  ,  String  value  )  {  [ATTENTION]  }    [METHOD]  <init>  [TYPE]  String)  [PARAMETER]  String  key  String  value  [CLASS]  AttributeWithValueContaining    [TYPE]  boolean  false  true  [TYPE]  String  key  value  
[REPLACE]  return  element  .  attr  (  key  )    .  toLowerCase  (  )    .  contains  (  value  )  ;	[BUGGY]  return  element  .  attr  (  key  )  .  contains  (  )  .  contains  (  value  )  ;  [CE]  method  contains  in  class  String  cannot  be  applied  to  given  types  ;  [CONTEXT]  public  boolean  matches  (  Element  element  )  {  [ATTENTION]  return  element  .  attr  (  key  )    .  contains  (  )    .  contains  (  value  )    ;  }    [METHOD]  matches  [TYPE]  boolean  [PARAMETER]  Element  element  [CLASS]  AttributeWithValueContaining    [TYPE]  boolean  false  true  [TYPE]  Element  element  
[REPLACE]  protected  String  key;	[BUGGY]  protected  long  key  ;  [CE]  incompatible  types  [CONTEXT]    [METHOD]  matches  [TYPE]  boolean  [PARAMETER]  Element  element  [CLASS]  AttributeKeyPair    [TYPE]  boolean  false  true  [TYPE]  Element  element  
[REPLACE]  Validate  .  notEmpty  (  key  )  ;	[BUGGY]  key    ;  [CE]  not  a  statement  [CONTEXT]  AttributeKeyPair  (  String  key  ,  String  value  )  {  [ATTENTION]  key  ;  Validate  .  notEmpty  (  value  )  ;    this  .  key  =  key  .  trim  (  )  .  toLowerCase  (  )  ;  this  .  value  =  value  .  trim  (  )  .  toLowerCase  (  )  ;  }    [METHOD]  <init>  [TYPE]  String)  [PARAMETER]  String  key  String  value  [CLASS]  AttributeKeyPair    [TYPE]  String  key  value  [TYPE]  boolean  false  true  
[ADD]  Validate  .  notEmpty  (  key  )  ;  Validate  .  notEmpty  (  value  )  ;	[BUGGY]  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  AttributeKeyPair  (  String  key  ,  String  value  )  {  [ATTENTION]    this  .  key  =  key  .  trim  (  )  .  toLowerCase  (  )  ;  this  .  value  =  value  .  trim  (  )  .  toLowerCase  (  )  ;  }    [METHOD]  <init>  [TYPE]  String)  [PARAMETER]  String  key  String  value  [CLASS]  AttributeKeyPair    [TYPE]  String  key  value  [TYPE]  boolean  false  true  
[REPLACE]  Validate  .  notEmpty  (  value  )  ;	[BUGGY]  value    ;  [CE]  not  a  statement  [CONTEXT]  AttributeKeyPair  (  String  key  ,  String  value  )  {  Validate  .  notEmpty  (  key  )  ;  [ATTENTION]  value  ;    this  .  key  =  key  .  trim  (  )  .  toLowerCase  (  )  ;  this  .  value  =  value  .  trim  (  )  .  toLowerCase  (  )  ;  }    [METHOD]  <init>  [TYPE]  String)  [PARAMETER]  String  key  String  value  [CLASS]  AttributeKeyPair    [TYPE]  String  key  value  [TYPE]  boolean  false  true  
[REPLACE]  this  .  key  =  key  .  trim  (  )    .  toLowerCase  (  )  ;	[BUGGY]  this  .  value  =  value  .  trim  (  )  .  toLowerCase  (  )  ;    ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  AttributeKeyPair  (  String  key  ,  String  value  )  {  Validate  .  notEmpty  (  key  )  ;  Validate  .  notEmpty  (  value  )  ;    [ATTENTION]  this  .  value  =  value  .  trim  (  )    .  toLowerCase  (  )    ;    ;  this  .  value  =  value  .  trim  (  )  .  toLowerCase  (  )  ;  }    [METHOD]  <init>  [TYPE]  String)  [PARAMETER]  String  key  String  value  [CLASS]  AttributeKeyPair    [TYPE]  String  key  value  [TYPE]  boolean  false  true  
[REPLACE]  this  .  value  =  value  .  trim  (  )    .  toLowerCase  (  )  ;	[BUGGY]  this  .  key  =  key  .  trim  (  )  .  toLowerCase  (  )  ;    ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  AttributeKeyPair  (  String  key  ,  String  value  )  {  Validate  .  notEmpty  (  key  )  ;  Validate  .  notEmpty  (  value  )  ;    this  .  key  =  key  .  trim  (  )  .  toLowerCase  (  )  ;  [ATTENTION]  this  .  key  =  key  .  trim  (  )    .  toLowerCase  (  )    ;    ;  }    [METHOD]  <init>  [TYPE]  String)  [PARAMETER]  String  key  String  value  [CLASS]  AttributeKeyPair    [TYPE]  String  key  value  [TYPE]  boolean  false  true  
[REPLACE]  return  true;	[BUGGY]  return  false  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  boolean  matches  (  Element  element  )  {  [ATTENTION]  return  false  ;  }    [METHOD]  matches  [TYPE]  boolean  [PARAMETER]  Element  element  [CLASS]  AllElements    [TYPE]  boolean  false  true  [TYPE]  Element  element  
[REPLACE]  super  (  index  )  ;	[BUGGY]  return  element  .  elementSiblingIndex  (  )  <  index  ;  [CE]  constructor  IndexEvaluator  in  class  IndexEvaluator  cannot  be  applied  to  given  types  ;  [CONTEXT]  IndexLessThan  (  int  index  )  {  [ATTENTION]  return  element  .  elementSiblingIndex  (  )  <  index  ;  }    [METHOD]  <init>  [TYPE]  Evaluator$IndexLessThan(int)  [PARAMETER]  int  index  [CLASS]  IndexLessThan    [TYPE]  boolean  false  true  [TYPE]  int  index  
[REPLACE]  return  element  .  elementSiblingIndex  (  )  <  index;	[BUGGY]  return  true  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  boolean  matches  (  Element  element  )  {  [ATTENTION]  return  true  ;  }    [METHOD]  matches  [TYPE]  boolean  [PARAMETER]  Element  element  [CLASS]  IndexLessThan    [TYPE]  boolean  false  true  [TYPE]  Element  element  
[REPLACE]  super  (  index  )  ;	[BUGGY]  return  element  .  elementSiblingIndex  (  )  >  index  ;  [CE]  constructor  IndexEvaluator  in  class  IndexEvaluator  cannot  be  applied  to  given  types  ;  [CONTEXT]  IndexGreaterThan  (  int  index  )  {  [ATTENTION]  return  element  .  elementSiblingIndex  (  )  >  index  ;  }    [METHOD]  <init>  [TYPE]  Evaluator$IndexGreaterThan(int)  [PARAMETER]  int  index  [CLASS]  IndexGreaterThan    [TYPE]  boolean  false  true  [TYPE]  int  index  
[REPLACE]  return  element  .  elementSiblingIndex  (  )  >  index;	[BUGGY]  return  element  .  elementSiblingIndex  (  )    ;  [CE]  incompatible  types  [CONTEXT]  public  boolean  matches  (  Element  element  )  {  [ATTENTION]  return  element  .  elementSiblingIndex  (  )    ;  }    [METHOD]  matches  [TYPE]  boolean  [PARAMETER]  Element  element  [CLASS]  IndexGreaterThan    [TYPE]  boolean  false  true  [TYPE]  Element  element  
[REPLACE]  super  (  index  )  ;	[BUGGY]  return  element  .  elementSiblingIndex  (  )    =  =  index  ;  [CE]  constructor  IndexEvaluator  in  class  IndexEvaluator  cannot  be  applied  to  given  types  ;  [CONTEXT]  IndexEquals  (  int  index  )  {  [ATTENTION]  return  element  .  elementSiblingIndex  (  )  =  =  index  ;  }    [METHOD]  <init>  [TYPE]  Evaluator$IndexEquals(int)  [PARAMETER]  int  index  [CLASS]  IndexEquals    [TYPE]  boolean  false  true  [TYPE]  int  index  
[REPLACE]  return  element  .  elementSiblingIndex  (  )  ==  index;	[BUGGY]  return  element  .  elementSiblingIndex  (  )    ||  index  ;  [CE]  bad  operand  types  for  binary  operator  '||'  [CONTEXT]  public  boolean  matches  (  Element  element  )  {  [ATTENTION]  return  element  .  elementSiblingIndex  (  )  ||index  ;  }    [METHOD]  matches  [TYPE]  boolean  [PARAMETER]  Element  element  [CLASS]  IndexEquals    [TYPE]  boolean  false  true  [TYPE]  Element  element  
[REPLACE]  protected  int  index;	[BUGGY]  protected  short  index  ;  [CE]  possible  loss  of  precision  [CONTEXT]    [METHOD]  matches  [TYPE]  boolean  [PARAMETER]  Element  element  [CLASS]  IndexEvaluator    [TYPE]  boolean  false  true  [TYPE]  Element  element  
[REPLACE]  this  .  index  =  index;	[BUGGY]  this  .  index  =    null  ;  [CE]  incompatible  types  [CONTEXT]  IndexEvaluator  (  int  index  )  {  [ATTENTION]  this  .  index  =  null  ;  }    [METHOD]  <init>  [TYPE]  Evaluator$IndexEvaluator(int)  [PARAMETER]  int  index  [CLASS]  IndexEvaluator    [TYPE]  int  index  [TYPE]  boolean  false  true  
[REPLACE]  private  static  final  String  DECL_KEY  =   "declaration ";	[BUGGY]  private  static  final  String  DECL_KEY    =  null  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]      [CLASS]  XmlDeclaration  
[REPLACE]  super  (  baseUri  )  ;	[BUGGY]  super  (  data  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  XmlDeclaration  (  String  data  ,  String  baseUri  ,  boolean  isProcessingInstruction  )  {  [ATTENTION]  super  (  data  )    ;  attributes  .  put  (  DECL_KEY  ,  data  )  ;  this  .  isProcessingInstruction  =  isProcessingInstruction  ;  }    [METHOD]  <init>  [TYPE]  String  ,  boolean)  [PARAMETER]  String  data  String  baseUri  boolean  isProcessingInstruction  [CLASS]  XmlDeclaration    [TYPE]  boolean  false  isProcessingInstruction  true  [TYPE]  String  DECL_KEY  baseUri  data  
[ADD]  super  (  baseUri  )  ;	[BUGGY]  [CE]  no  suitable  constructor  found  for  Node()  [CONTEXT]  public  XmlDeclaration  (  String  data  ,  String  baseUri  ,  boolean  isProcessingInstruction  )  {  [ATTENTION]  attributes  .  put  (  DECL_KEY  ,  data  )  ;  this  .  isProcessingInstruction  =  isProcessingInstruction  ;  }    [METHOD]  <init>  [TYPE]  String  ,  boolean)  [PARAMETER]  String  data  String  baseUri  boolean  isProcessingInstruction  [CLASS]  XmlDeclaration    [TYPE]  boolean  false  isProcessingInstruction  true  [TYPE]  String  DECL_KEY  baseUri  data  
[REPLACE]  attributes  .  put  (  DECL_KEY,  data  )  ;	[BUGGY]  attributes  .  put  (  DECL_KEY  ,  baseUri  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  XmlDeclaration  (  String  data  ,  String  baseUri  ,  boolean  isProcessingInstruction  )  {  super  (  baseUri  )  ;  [ATTENTION]  attributes  .  put  (  DECL_KEY  ,  baseUri  )    ;  this  .  isProcessingInstruction  =  isProcessingInstruction  ;  }    [METHOD]  <init>  [TYPE]  String  ,  boolean)  [PARAMETER]  String  data  String  baseUri  boolean  isProcessingInstruction  [CLASS]  XmlDeclaration    [TYPE]  boolean  false  isProcessingInstruction  true  [TYPE]  String  DECL_KEY  baseUri  data  
[REPLACE]  this  .  isProcessingInstruction  =  isProcessingInstruction;	[BUGGY]  this  .  isProcessingInstruction  =    true  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  XmlDeclaration  (  String  data  ,  String  baseUri  ,  boolean  isProcessingInstruction  )  {  super  (  baseUri  )  ;  attributes  .  put  (  DECL_KEY  ,  data  )  ;  [ATTENTION]  this  .  isProcessingInstruction  =  true  ;  }    [METHOD]  <init>  [TYPE]  String  ,  boolean)  [PARAMETER]  String  data  String  baseUri  boolean  isProcessingInstruction  [CLASS]  XmlDeclaration    [TYPE]  boolean  false  isProcessingInstruction  true  [TYPE]  String  DECL_KEY  baseUri  data  
[REPLACE]  return   "#declaration ";	[BUGGY]  return  outerHtml  (  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  String  nodeName  (  )  {  [ATTENTION]  return  outerHtml  (  )    ;  }    [METHOD]  nodeName  [TYPE]  String  [PARAMETER]  [CLASS]  XmlDeclaration    [TYPE]  boolean  false  isProcessingInstruction  true  [TYPE]  String  DECL_KEY  baseUri  data  
[REPLACE]  return  attributes  .  get  (  DECL_KEY  )  ;	[BUGGY]  return    DECL_KEY    ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  String  getWholeDeclaration  (  )  {  [ATTENTION]  return  DECL_KEY  ;  }    [METHOD]  getWholeDeclaration  [TYPE]  String  [PARAMETER]  [CLASS]  XmlDeclaration    [TYPE]  boolean  false  isProcessingInstruction  true  [TYPE]  String  DECL_KEY  baseUri  data  
[REPLACE]  accum  .  append  (  String  .  format  (   "<%s%s> ",  isProcessingInstruction  ?   "! "  :   "? ",  getWholeDeclaration  (  )  )  )  ;	[BUGGY]  return  outerHtml  (  )  ;  [CE]  cannot  return  a  value  from  method  whose  result  type  is  void  [CONTEXT]  void  outerHtml  (  StringBuilder  accum  )  {  [ATTENTION]  return  outerHtml  (  )    ;  }    [METHOD]  outerHtml  [TYPE]  void  [PARAMETER]  StringBuilder  accum  [CLASS]  XmlDeclaration    [TYPE]  StringBuilder  accum  [TYPE]  boolean  false  isProcessingInstruction  true  [TYPE]  String  DECL_KEY  baseUri  data  
[ADD]  accum  .  append  (  String  .  format  (   "<%s%s> ",  isProcessingInstruction  ?   "! "  :   "? ",  getWholeDeclaration  (  )  )  )  ;  }	[BUGGY]  [CE]  illegal  start  of  expression  [CONTEXT]  void  outerHtml  (  StringBuilder  accum  )  {  [ATTENTION]      [METHOD]  outerHtml  [TYPE]  void  [PARAMETER]  StringBuilder  accum  [CLASS]  XmlDeclaration    [TYPE]  StringBuilder  accum  [TYPE]  boolean  false  isProcessingInstruction  true  [TYPE]  String  DECL_KEY  baseUri  data  
[REPLACE]  return  outerHtml  (  )  ;	[BUGGY]  return   "#declaration "  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  String  toString  (  )  {  [ATTENTION]  return   "#declaration "  ;  }    [METHOD]  toString  [TYPE]  String  [PARAMETER]  [CLASS]  XmlDeclaration    [TYPE]  boolean  false  isProcessingInstruction  true  [TYPE]  String  DECL_KEY  baseUri  data  
[REPLACE]  private  LinkedHashMap<String,  Attribute>  attributes  =  new  LinkedHashMap<String,  Attribute>  (  )  ;	[BUGGY]  private  LinkedHashMap<String  ,  Attribute>  attributes    =  null  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]      [CLASS]  Attributes  
[REPLACE]  Validate  .  notEmpty  (  key  )  ;	[BUGGY]  Validate  .  notNull  (  key  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  String  get  (  String  key  )  {  [ATTENTION]  Validate  .  notNull  (  key  )    ;    Attribute  attr  =  attributes  .  get  (  key  .  toLowerCase  (  )  )  ;  return  attr  !  =  null  ?  attr  .  getValue  (  )  :   " "  ;  }    [METHOD]  get  [TYPE]  String  [PARAMETER]  String  key  [CLASS]  Attributes    [TYPE]  String  key  [TYPE]  boolean  false  true  [TYPE]  Attribute  attr  [TYPE]  LinkedHashMap  attributes  
[ADD]  Validate  .  notEmpty  (  key  )  ;	[BUGGY]  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  String  get  (  String  key  )  {  [ATTENTION]    Attribute  attr  =  attributes  .  get  (  key  .  toLowerCase  (  )  )  ;  return  attr  !  =  null  ?  attr  .  getValue  (  )  :   " "  ;  }    [METHOD]  get  [TYPE]  String  [PARAMETER]  String  key  [CLASS]  Attributes    [TYPE]  String  key  [TYPE]  boolean  false  true  [TYPE]  Attribute  attr  [TYPE]  LinkedHashMap  attributes  
[REPLACE]  Attribute  attr  =  attributes  .  get  (  key  .  toLowerCase  (  )  )  ;	[BUGGY]  Attribute  attr  =  attributes  .  put  (  key  ,  key  )    ;  [CE]  no  suitable  method  found  for  put(String  ,  String)  [CONTEXT]  public  String  get  (  String  key  )  {  Validate  .  notEmpty  (  key  )  ;    [ATTENTION]  Attribute  attr  =  attributes  .  put  (  key  ,  key  )  ;  return  attr  !  =  null  ?  attr  .  getValue  (  )  :   " "  ;  }    [METHOD]  get  [TYPE]  String  [PARAMETER]  String  key  [CLASS]  Attributes    [TYPE]  String  key  [TYPE]  boolean  false  true  [TYPE]  Attribute  attr  [TYPE]  LinkedHashMap  attributes  
[ADD]  Attribute  attr  =  attributes  .  get  (  key  .  toLowerCase  (  )  )  ;	[BUGGY]  [CE]  cannot  find  symbol  attr  [CONTEXT]  public  String  get  (  String  key  )  {  Validate  .  notEmpty  (  key  )  ;    [ATTENTION]  return  attr  !  =  null  ?  attr  .  getValue  (  )  :   " "  ;  }    [METHOD]  get  [TYPE]  String  [PARAMETER]  String  key  [CLASS]  Attributes    [TYPE]  String  key  [TYPE]  boolean  false  true  [TYPE]  Attribute  attr  [TYPE]  LinkedHashMap  attributes  
[REPLACE]  return  attr  !=  null  ?  attr  .  getValue  (  )  :   " ";	[BUGGY]  return  attr  !  =  null  ?  attr  .  getKey  (  )  :   " "  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  String  get  (  String  key  )  {  Validate  .  notEmpty  (  key  )  ;    Attribute  attr  =  attributes  .  get  (  key  .  toLowerCase  (  )  )  ;  [ATTENTION]  return  attr  !  =  null  ?  attr  .  getKey  (  )  :   " "  ;  }    [METHOD]  get  [TYPE]  String  [PARAMETER]  String  key  [CLASS]  Attributes    [TYPE]  String  key  [TYPE]  boolean  false  true  [TYPE]  Attribute  attr  [TYPE]  LinkedHashMap  attributes  
[REPLACE]  Attribute  attr  =  new  Attribute  (  key,  value  )  ;	[BUGGY]  List<Attribute>  list  =  new  ArrayList<Attribute>  (  attributes  .  size  (  )  )  ;  [CE]  cannot  find  symbol  attr  [CONTEXT]  public  void  put  (  String  key  ,  String  value  )  {  [ATTENTION]  List<Attribute>  list  =  new  ArrayList<Attribute>  (  attributes  .  size  (  )  )    ;  put  (  attr  )  ;  }    [METHOD]  put  [TYPE]  void  [PARAMETER]  String  key  String  value  [CLASS]  Attributes    [TYPE]  String  key  value  [TYPE]  boolean  false  true  [TYPE]  Attribute  attr  [TYPE]  LinkedHashMap  attributes  
[REPLACE]  put  (  attr  )  ;	[BUGGY]  return  html  (  )  ;  [CE]  cannot  return  a  value  from  method  whose  result  type  is  void  [CONTEXT]  public  void  put  (  String  key  ,  String  value  )  {  Attribute  attr  =  new  Attribute  (  key  ,  value  )  ;  [ATTENTION]  return  html  (  )    ;  }    [METHOD]  put  [TYPE]  void  [PARAMETER]  String  key  String  value  [CLASS]  Attributes    [TYPE]  String  key  value  [TYPE]  boolean  false  true  [TYPE]  Attribute  attr  [TYPE]  LinkedHashMap  attributes  
[REPLACE]  Validate  .  notNull  (  attribute  )  ;	[BUGGY]  Validate  .  notEmpty  (  attribute  )  ;  [CE]  no  suitable  method  found  for  notEmpty(Attribute)  [CONTEXT]  public  void  put  (  Attribute  attribute  )  {  [ATTENTION]  Validate  .  notEmpty  (  attribute  )    ;  attributes  .  put  (  attribute  .  getKey  (  )  ,  attribute  )  ;  }    [METHOD]  put  [TYPE]  void  [PARAMETER]  Attribute  attribute  [CLASS]  Attributes    [TYPE]  Attribute  attribute  [TYPE]  LinkedHashMap  attributes  [TYPE]  boolean  false  true  
[REPLACE]  attributes  .  put  (  attribute  .  getKey  (  )  ,  attribute  )  ;	[BUGGY]  attributes  .  put  (  attribute  .  getValue  (  )    ,  attribute  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  void  put  (  Attribute  attribute  )  {  Validate  .  notNull  (  attribute  )  ;  [ATTENTION]  attributes  .  put  (  attribute  .  getValue  (  )  ,  attribute  )    ;  }    [METHOD]  put  [TYPE]  void  [PARAMETER]  Attribute  attribute  [CLASS]  Attributes    [TYPE]  Attribute  attribute  [TYPE]  LinkedHashMap  attributes  [TYPE]  boolean  false  true  
[ADD]  attributes  .  put  (  attribute  .  getKey  (  )  ,  attribute  )  ;	[BUGGY]  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  void  put  (  Attribute  attribute  )  {  Validate  .  notNull  (  attribute  )  ;  [ATTENTION]  }    [METHOD]  put  [TYPE]  void  [PARAMETER]  Attribute  attribute  [CLASS]  Attributes    [TYPE]  Attribute  attribute  [TYPE]  LinkedHashMap  attributes  [TYPE]  boolean  false  true  
[REPLACE]  attributes  .  put  (  attribute  .  getKey  (  )  ,  attribute  )  ;	[BUGGY]  attributes  .  put  (  attribute  .  getValue  (  )  ,  attribute  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  void  put  (  Attribute  attribute  )  {  Validate  .  notNull  (  attribute  )  ;  [ATTENTION]  attributes  .  put  (  attribute  .  getValue  (  )    ,  attribute  )    ;  }    [METHOD]  put  [TYPE]  void  [PARAMETER]  Attribute  attribute  [CLASS]  Attributes    [TYPE]  Attribute  attribute  [TYPE]  LinkedHashMap  attributes  [TYPE]  boolean  false  true  
[REPLACE]  Validate  .  notEmpty  (  key  )  ;	[BUGGY]  Validate  .  notNull  (  key  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  void  remove  (  String  key  )  {  [ATTENTION]  Validate  .  notNull  (  key  )    ;  attributes  .  remove  (  key  .  toLowerCase  (  )  )  ;  }    [METHOD]  remove  [TYPE]  void  [PARAMETER]  String  key  [CLASS]  Attributes    [TYPE]  LinkedHashMap  attributes  [TYPE]  String  key  [TYPE]  boolean  false  true  
[REPLACE]  attributes  .  remove  (  key  .  toLowerCase  (  )  )  ;	[BUGGY]  attributes  .  get  (  key  .  toLowerCase  (  )  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  void  remove  (  String  key  )  {  Validate  .  notEmpty  (  key  )  ;  [ATTENTION]  attributes  .  get  (  key  .  toLowerCase  (  )  )    ;  }    [METHOD]  remove  [TYPE]  void  [PARAMETER]  String  key  [CLASS]  Attributes    [TYPE]  LinkedHashMap  attributes  [TYPE]  String  key  [TYPE]  boolean  false  true  
[ADD]  attributes  .  remove  (  key  .  toLowerCase  (  )  )  ;	[BUGGY]  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  void  remove  (  String  key  )  {  Validate  .  notEmpty  (  key  )  ;  [ATTENTION]  }    [METHOD]  remove  [TYPE]  void  [PARAMETER]  String  key  [CLASS]  Attributes    [TYPE]  LinkedHashMap  attributes  [TYPE]  String  key  [TYPE]  boolean  false  true  
[REPLACE]  attributes  .  remove  (  key  .  toLowerCase  (  )  )  ;	[BUGGY]  attributes  .  put  (  attribute  .  getKey  (  )  ,  attribute  )  ;  [CE]  cannot  find  symbol  attribute  [CONTEXT]  public  void  remove  (  String  key  )  {  Validate  .  notEmpty  (  key  )  ;  [ATTENTION]  attributes  .  put  (  attribute  .  getKey  (  )    ,  attribute  )    ;  }    [METHOD]  remove  [TYPE]  void  [PARAMETER]  String  key  [CLASS]  Attributes    [TYPE]  LinkedHashMap  attributes  [TYPE]  String  key  [TYPE]  boolean  false  true  
[REPLACE]  return  attributes  .  containsKey  (  key  .  toLowerCase  (  )  )  ;	[BUGGY]  return  asList  (  )  .  iterator  (  )  ;  [CE]  incompatible  types  [CONTEXT]  public  boolean  hasKey  (  String  key  )  {  [ATTENTION]  return  asList  (  )    .  iterator  (  )    ;  }    [METHOD]  hasKey  [TYPE]  boolean  [PARAMETER]  String  key  [CLASS]  Attributes    [TYPE]  LinkedHashMap  attributes  [TYPE]  String  key  [TYPE]  boolean  false  true  
[REPLACE]  return  attributes  .  size  (  )  ;	[BUGGY]  return  attributes  .  hashCode  (  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  int  size  (  )  {  [ATTENTION]  return  attributes  .  hashCode  (  )    ;  }    [METHOD]  size  [TYPE]  int  [PARAMETER]  [CLASS]  Attributes    [TYPE]  LinkedHashMap  attributes  [TYPE]  boolean  false  true  
[REPLACE]  attributes  .  putAll  (  incoming  .  attributes  )  ;	[BUGGY]  attributes  .  equals  (  incoming  .  attributes  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  void  addAll  (  Attributes  incoming  )  {  [ATTENTION]  attributes  .  equals  (  incoming  .  attributes  )    ;  }    [METHOD]  addAll  [TYPE]  void  [PARAMETER]  Attributes  incoming  [CLASS]  Attributes    [TYPE]  Attributes  incoming  [TYPE]  LinkedHashMap  attributes  [TYPE]  boolean  false  true  
[REPLACE]  return  asList  (  )    .  iterator  (  )  ;	[BUGGY]  return  attributes  .  size  (  )  ;  [CE]  incompatible  types  [CONTEXT]  public  Iterator<Attribute>  iterator  (  )  {  [ATTENTION]  return  attributes  .  size  (  )    ;  }    [METHOD]  iterator  [TYPE]  Iterator  [PARAMETER]  [CLASS]  Attributes    [TYPE]  LinkedHashMap  attributes  [TYPE]  boolean  false  true  
[REPLACE]  List<Attribute>  list  =  new  ArrayList<Attribute>  (  attributes  .  size  (  )  )  ;	[BUGGY]  List<Attribute>  list  =  new  ArrayList<Attribute>  (  attributes  .  hashCode  (  )    )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  List<Attribute>  asList  (  )  {  [ATTENTION]  List<Attribute>  list  =  new  ArrayList<Attribute>  (  attributes  .  hashCode  (  )    )    ;  for  (  Map  .  Entry<String  ,  Attribute>  entry  :  attributes  .  entrySet  (  )  )  {  list  .  add  (  entry  .  getValue  (  )  )  ;  }  return  Collections  .  unmodifiableList  (  list  )  ;  }    [METHOD]  asList  [TYPE]  List  [PARAMETER]  [CLASS]  Attributes    [TYPE]  List  list  [TYPE]  Entry  entry  [TYPE]  boolean  false  true  [TYPE]  LinkedHashMap  attributes  
[REPLACE]  for  (  Map  .  Entry<String,  Attribute>  entry  :  attributes  .  entrySet  (  )  )  {	[BUGGY]  for  (  Attribute  attribute  :  this  )  {  accum  .  append  (   "   "  )  ;  [CE]  cannot  find  symbol  accum  [CONTEXT]  public  List<Attribute>  asList  (  )  {  List<Attribute>  list  =  new  ArrayList<Attribute>  (  attributes  .  size  (  )  )  ;  [ATTENTION]  for  (  Attribute  attribute  :  this  )  {  accum  .  append  (   "   "  )    ;  list  .  add  (  entry  .  getValue  (  )  )  ;  }  return  Collections  .  unmodifiableList  (  list  )  ;  }    [METHOD]  asList  [TYPE]  List  [PARAMETER]  [CLASS]  Attributes    [TYPE]  List  list  [TYPE]  Entry  entry  [TYPE]  boolean  false  true  [TYPE]  LinkedHashMap  attributes  
[ADD]  for  (  Map  .  Entry<String,  Attribute>  entry  :  attributes  .  entrySet  (  )  )  {  list  .  add  (  entry  .  getValue  (  )  )  ;  }	[BUGGY]  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  List<Attribute>  asList  (  )  {  List<Attribute>  list  =  new  ArrayList<Attribute>  (  attributes  .  size  (  )  )  ;  [ATTENTION]    return  Collections  .  unmodifiableList  (  list  )  ;  }    [METHOD]  asList  [TYPE]  List  [PARAMETER]  [CLASS]  Attributes    [TYPE]  List  list  [TYPE]  Entry  entry  [TYPE]  boolean  false  true  [TYPE]  LinkedHashMap  attributes  
[REPLACE]  return  Collections  .  unmodifiableList  (  list  )  ;	[BUGGY]  return    null    ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  List<Attribute>  asList  (  )  {  List<Attribute>  list  =  new  ArrayList<Attribute>  (  attributes  .  size  (  )  )  ;  for  (  Map  .  Entry<String  ,  Attribute>  entry  :  attributes  .  entrySet  (  )  )  {  list  .  add  (  entry  .  getValue  (  )  )  ;  }  [ATTENTION]  return  null  ;  }    [METHOD]  asList  [TYPE]  List  [PARAMETER]  [CLASS]  Attributes    [TYPE]  List  list  [TYPE]  Entry  entry  [TYPE]  boolean  false  true  [TYPE]  LinkedHashMap  attributes  
[REPLACE]  StringBuilder  accum  =  new  StringBuilder  (  )  ;	[BUGGY]  Attribute  attr  =  new  Attribute  (  key  ,  value  )  ;  [CE]  cannot  find  symbol  key  [CONTEXT]  public  String  html  (  )  {  [ATTENTION]  Attribute  attr  =  new  Attribute  (  key  ,  value  )    ;  for  (  Attribute  attribute  :  this  )  {  accum  .  append  (   "   "  )  ;  accum  .  append  (  attribute  .  html  (  )  )  ;  }  return  accum  .  toString  (  )  ;  }    [METHOD]  html  [TYPE]  String  [PARAMETER]  [CLASS]  Attributes    [TYPE]  boolean  false  true  [TYPE]  StringBuilder  accum  [TYPE]  Attribute  attribute  [TYPE]  LinkedHashMap  attributes  
[ADD]  StringBuilder  accum  =  new  StringBuilder  (  )  ;	[BUGGY]  [CE]  cannot  find  symbol  accum  [CONTEXT]  public  String  html  (  )  {  [ATTENTION]  for  (  Attribute  attribute  :  this  )  {  accum  .  append  (   "   "  )  ;  accum  .  append  (  attribute  .  html  (  )  )  ;  }  return  accum  .  toString  (  )  ;  }    [METHOD]  html  [TYPE]  String  [PARAMETER]  [CLASS]  Attributes    [TYPE]  boolean  false  true  [TYPE]  StringBuilder  accum  [TYPE]  Attribute  attribute  [TYPE]  LinkedHashMap  attributes  
[REPLACE]  for  (  Attribute  attribute  :  this  )  {	[BUGGY]  List<Attribute>  list  =  new  ArrayList<Attribute>  (  attributes  .  size  (  )  )  ;  [CE]  illegal  start  of  type  [CONTEXT]  public  String  html  (  )  {  StringBuilder  accum  =  new  StringBuilder  (  )  ;  [ATTENTION]  List<Attribute>  list  =  new  ArrayList<Attribute>  (  attributes  .  size  (  )  )    ;  accum  .  append  (   "   "  )  ;  accum  .  append  (  attribute  .  html  (  )  )  ;  }  return  accum  .  toString  (  )  ;  }    [METHOD]  html  [TYPE]  String  [PARAMETER]  [CLASS]  Attributes    [TYPE]  boolean  false  true  [TYPE]  StringBuilder  accum  [TYPE]  Attribute  attribute  [TYPE]  LinkedHashMap  attributes  
[ADD]  for  (  Attribute  attribute  :  this  )  {  accum  .  append  (   "   "  )  ;  accum  .  append  (  attribute  .  html  (  )  )  ;  }	[BUGGY]  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  String  html  (  )  {  StringBuilder  accum  =  new  StringBuilder  (  )  ;  [ATTENTION]      return  accum  .  toString  (  )  ;  }    [METHOD]  html  [TYPE]  String  [PARAMETER]  [CLASS]  Attributes    [TYPE]  boolean  false  true  [TYPE]  StringBuilder  accum  [TYPE]  Attribute  attribute  [TYPE]  LinkedHashMap  attributes  
[REPLACE]  return  accum  .  toString  (  )  ;	[BUGGY]  return  accum  .  StringBuilder  (  )    ;  [CE]  cannot  find  symbol  [CONTEXT]  public  String  html  (  )  {  StringBuilder  accum  =  new  StringBuilder  (  )  ;  for  (  Attribute  attribute  :  this  )  {  accum  .  append  (   "   "  )  ;  accum  .  append  (  attribute  .  html  (  )  )  ;  }  [ATTENTION]  return  accum  .  StringBuilder  (  )  ;  }    [METHOD]  html  [TYPE]  String  [PARAMETER]  [CLASS]  Attributes    [TYPE]  boolean  false  true  [TYPE]  StringBuilder  accum  [TYPE]  Attribute  attribute  [TYPE]  LinkedHashMap  attributes  
[REPLACE]  return  html  (  )  ;	[BUGGY]  return  asList  (  )  .  iterator  (  )  ;  [CE]  incompatible  types  [CONTEXT]  public  String  toString  (  )  {  [ATTENTION]  return  asList  (  )    .  iterator  (  )    ;  }    [METHOD]  toString  [TYPE]  String  [PARAMETER]  [CLASS]  Attributes    [TYPE]  LinkedHashMap  attributes  [TYPE]  boolean  false  true  
[REPLACE]  if  (  this  ==  o  )  return  true;	[BUGGY]  if  (  this  !  =    o  )  return  true  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  boolean  equals  (  Object  o  )  {  [ATTENTION]  if  (  this!  =  o  )  return  true  ;  if  (  !  (  o  instanceof  Attributes  )  )  return  false  ;    Attributes  that  =    (  Attributes  )  o  ;    if  (  attributes  !  =  null  ?  !attributes  .  equals  (  that  .  attributes  )  :  that  .  attributes  !  =  null  )  return  false  ;    return  true  ;  }    [METHOD]  equals  [TYPE]  boolean  [PARAMETER]  Object  o  [CLASS]  Attributes    [TYPE]  Attributes  that  [TYPE]  Object  o  [TYPE]  boolean  false  true  [TYPE]  LinkedHashMap  attributes  
[REPLACE]  if  (  this  ==  o  )  return  true;	[BUGGY]  if  (  this  =  =  o  )  return  false  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  boolean  equals  (  Object  o  )  {  [ATTENTION]  if  (  this  =  =  o  )  return  false  ;  if  (  !  (  o  instanceof  Attributes  )  )  return  false  ;    Attributes  that  =    (  Attributes  )  o  ;    if  (  attributes  !  =  null  ?  !attributes  .  equals  (  that  .  attributes  )  :  that  .  attributes  !  =  null  )  return  false  ;    return  true  ;  }    [METHOD]  equals  [TYPE]  boolean  [PARAMETER]  Object  o  [CLASS]  Attributes    [TYPE]  Attributes  that  [TYPE]  Object  o  [TYPE]  boolean  false  true  [TYPE]  LinkedHashMap  attributes  
[REPLACE]  if  (  !  (  o  instanceof  Attributes  )  )  return  false;	[BUGGY]  if  (  !  !  (  o  instanceof  Attributes  )  )  return  false  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  boolean  equals  (  Object  o  )  {  if  (  this  =  =  o  )  return  true  ;  [ATTENTION]  if  (  !  !  (  o  instanceof  Attributes  )  )  return  false  ;    Attributes  that  =    (  Attributes  )  o  ;    if  (  attributes  !  =  null  ?  !attributes  .  equals  (  that  .  attributes  )  :  that  .  attributes  !  =  null  )  return  false  ;    return  true  ;  }    [METHOD]  equals  [TYPE]  boolean  [PARAMETER]  Object  o  [CLASS]  Attributes    [TYPE]  Attributes  that  [TYPE]  Object  o  [TYPE]  boolean  false  true  [TYPE]  LinkedHashMap  attributes  
[REPLACE]  if  (  !  (  o  instanceof  Attributes  )  )  return  false;	[BUGGY]  if  (  !  (  o  instanceof  Attributes  )  )  return  true  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  boolean  equals  (  Object  o  )  {  if  (  this  =  =  o  )  return  true  ;  [ATTENTION]  if  (  !  (  o  instanceof  Attributes  )  )  return  true  ;    Attributes  that  =    (  Attributes  )  o  ;    if  (  attributes  !  =  null  ?  !attributes  .  equals  (  that  .  attributes  )  :  that  .  attributes  !  =  null  )  return  false  ;    return  true  ;  }    [METHOD]  equals  [TYPE]  boolean  [PARAMETER]  Object  o  [CLASS]  Attributes    [TYPE]  Attributes  that  [TYPE]  Object  o  [TYPE]  boolean  false  true  [TYPE]  LinkedHashMap  attributes  
[REPLACE]  Attributes  that  =  (  Attributes  )  o;	[BUGGY]  List<Attribute>  list  =  new  ArrayList<Attribute>  (  attributes  .  size  (  )  )  ;  [CE]  cannot  find  symbol  that  [CONTEXT]  public  boolean  equals  (  Object  o  )  {  if  (  this  =  =  o  )  return  true  ;  if  (  !  (  o  instanceof  Attributes  )  )  return  false  ;    [ATTENTION]  List<Attribute>  list  =  new  ArrayList<Attribute>  (  attributes  .  size  (  )  )    ;    if  (  attributes  !  =  null  ?  !attributes  .  equals  (  that  .  attributes  )  :  that  .  attributes  !  =  null  )  return  false  ;    return  true  ;  }    [METHOD]  equals  [TYPE]  boolean  [PARAMETER]  Object  o  [CLASS]  Attributes    [TYPE]  Attributes  that  [TYPE]  Object  o  [TYPE]  boolean  false  true  [TYPE]  LinkedHashMap  attributes  
[REPLACE]  if  (  attributes  !=  null  ?  !attributes  .  equals  (  that  .  attributes  )  :  that  .  attributes  !=  null  )  return  false;	[BUGGY]  if  (  attributes  !  =    that  .  attributes  =  =  null  )  return  false  ;  [CE]  ')'  expected  [CONTEXT]  public  boolean  equals  (  Object  o  )  {  if  (  this  =  =  o  )  return  true  ;  if  (  !  (  o  instanceof  Attributes  )  )  return  false  ;    Attributes  that  =    (  Attributes  )  o  ;    [ATTENTION]  if  (  attributes  !  =  that  .  attributes  =  =  null  )  return  false  ;    return  true  ;  }    [METHOD]  equals  [TYPE]  boolean  [PARAMETER]  Object  o  [CLASS]  Attributes    [TYPE]  Attributes  that  [TYPE]  Object  o  [TYPE]  boolean  false  true  [TYPE]  LinkedHashMap  attributes  
[REPLACE]  if  (  attributes  !=  null  ?  !attributes  .  equals  (  that  .  attributes  )  :  that  .  attributes  !=  null  )  return  false;	[BUGGY]  if  (  attributes  !  =  null  ?  !attributes  .  equals  (  that  .  attributes  )  :  that  .  attributes  !  =  null  )  return  true  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  boolean  equals  (  Object  o  )  {  if  (  this  =  =  o  )  return  true  ;  if  (  !  (  o  instanceof  Attributes  )  )  return  false  ;    Attributes  that  =    (  Attributes  )  o  ;    [ATTENTION]  if  (  attributes  !  =  null  ?  !attributes  .  equals  (  that  .  attributes  )  :  that  .  attributes  !  =  null  )  return  true  ;    return  true  ;  }    [METHOD]  equals  [TYPE]  boolean  [PARAMETER]  Object  o  [CLASS]  Attributes    [TYPE]  Attributes  that  [TYPE]  Object  o  [TYPE]  boolean  false  true  [TYPE]  LinkedHashMap  attributes  
[REPLACE]  return  true;	[BUGGY]  return  false  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  boolean  equals  (  Object  o  )  {  if  (  this  =  =  o  )  return  true  ;  if  (  !  (  o  instanceof  Attributes  )  )  return  false  ;    Attributes  that  =    (  Attributes  )  o  ;    if  (  attributes  !  =  null  ?  !attributes  .  equals  (  that  .  attributes  )  :  that  .  attributes  !  =  null  )  return  false  ;    [ATTENTION]  return  false  ;  }    [METHOD]  equals  [TYPE]  boolean  [PARAMETER]  Object  o  [CLASS]  Attributes    [TYPE]  Attributes  that  [TYPE]  Object  o  [TYPE]  boolean  false  true  [TYPE]  LinkedHashMap  attributes  
[REPLACE]  return  attributes  !=  null  ?  attributes  .  hashCode  (  )  :  0;	[BUGGY]  return  attributes  !  =  null  ?  attributes  .  length  (  )  :  0  ;  [CE]  cannot  find  symbol  [CONTEXT]  public  int  hashCode  (  )  {  [ATTENTION]  return  attributes  !  =  null  ?  attributes  .  length  (  )  :  0  ;  }    [METHOD]  hashCode  [TYPE]  int  [PARAMETER]  [CLASS]  Attributes    [TYPE]  LinkedHashMap  attributes  [TYPE]  boolean  false  true  
[REPLACE]  final  Attributes  attributes;	[BUGGY]  Attributes  attributes  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]      [CLASS]  Node  
[REPLACE]  String  baseUri;	[BUGGY]  char  baseUri  ;  [CE]  incompatible  types  [CONTEXT]      [CLASS]  Node  
[REPLACE]  Validate  .  notNull  (  baseUri  )  ;	[BUGGY]  Validate  .  notEmpty  (  baseUri  )    ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  protected  Node  (  String  baseUri  ,  Attributes  attributes  )  {  [ATTENTION]  Validate  .  notEmpty  (  baseUri  )  ;  Validate  .  notNull  (  attributes  )  ;    childNodes  =  new  ArrayList<Node>  (  )  ;  this  .  baseUri  =  baseUri  .  trim  (  )  ;  this  .  attributes  =  attributes  ;  }    [METHOD]  <init>  [TYPE]  Attributes)  [PARAMETER]  String  baseUri  Attributes  attributes  [CLASS]  Node    [TYPE]  Attributes  attributes  [TYPE]  List  childNodes  [TYPE]  String  baseUri  [TYPE]  boolean  false  true  [TYPE]  Node  parentNode  
[REPLACE]  Validate  .  notNull  (  attributes  )  ;	[BUGGY]  Validate  .  notNull  (  attributeKey  )  ;  [CE]  cannot  find  symbol  attributeKey  [CONTEXT]  protected  Node  (  String  baseUri  ,  Attributes  attributes  )  {  Validate  .  notNull  (  baseUri  )  ;  [ATTENTION]  Validate  .  notNull  (  attributeKey  )    ;    childNodes  =  new  ArrayList<Node>  (  )  ;  this  .  baseUri  =  baseUri  .  trim  (  )  ;  this  .  attributes  =  attributes  ;  }    [METHOD]  <init>  [TYPE]  Attributes)  [PARAMETER]  String  baseUri  Attributes  attributes  [CLASS]  Node    [TYPE]  Attributes  attributes  [TYPE]  List  childNodes  [TYPE]  String  baseUri  [TYPE]  boolean  false  true  [TYPE]  Node  parentNode  
[REPLACE]  childNodes  =  new  ArrayList<Node>  (  )  ;	[BUGGY]  childNodes  ;  [CE]  not  a  statement  [CONTEXT]  protected  Node  (  String  baseUri  ,  Attributes  attributes  )  {  Validate  .  notNull  (  baseUri  )  ;  Validate  .  notNull  (  attributes  )  ;    [ATTENTION]  childNodes  ;  this  .  baseUri  =  baseUri  .  trim  (  )  ;  this  .  attributes  =  attributes  ;  }    [METHOD]  <init>  [TYPE]  Attributes)  [PARAMETER]  String  baseUri  Attributes  attributes  [CLASS]  Node    [TYPE]  Attributes  attributes  [TYPE]  List  childNodes  [TYPE]  String  baseUri  [TYPE]  boolean  false  true  [TYPE]  Node  parentNode  
[REPLACE]  this  .  baseUri  =  baseUri  .  trim  (  )  ;	[BUGGY]  this  .  baseUri  =    null  .  trim  (  )  ;  [CE]  <null>  cannot  be  dereferenced  [CONTEXT]  protected  Node  (  String  baseUri  ,  Attributes  attributes  )  {  Validate  .  notNull  (  baseUri  )  ;  Validate  .  notNull  (  attributes  )  ;    childNodes  =  new  ArrayList<Node>  (  )  ;  [ATTENTION]  this  .  baseUri  =  null  .  trim  (  )    ;  this  .  attributes  =  attributes  ;  }    [METHOD]  <init>  [TYPE]  Attributes)  [PARAMETER]  String  baseUri  Attributes  attributes  [CLASS]  Node    [TYPE]  Attributes  attributes  [TYPE]  List  childNodes  [TYPE]  String  baseUri  [TYPE]  boolean  false  true  [TYPE]  Node  parentNode  
[ADD]  this  .  baseUri  =  baseUri  .  trim  (  )  ;	[BUGGY]  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  protected  Node  (  String  baseUri  ,  Attributes  attributes  )  {  Validate  .  notNull  (  baseUri  )  ;  Validate  .  notNull  (  attributes  )  ;    childNodes  =  new  ArrayList<Node>  (  )  ;  [ATTENTION]  this  .  attributes  =  attributes  ;  }    [METHOD]  <init>  [TYPE]  Attributes)  [PARAMETER]  String  baseUri  Attributes  attributes  [CLASS]  Node    [TYPE]  Attributes  attributes  [TYPE]  List  childNodes  [TYPE]  String  baseUri  [TYPE]  boolean  false  true  [TYPE]  Node  parentNode  
[REPLACE]  this  .  attributes  =  attributes;	[BUGGY]  this  .  attributes  =    null  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  protected  Node  (  String  baseUri  ,  Attributes  attributes  )  {  Validate  .  notNull  (  baseUri  )  ;  Validate  .  notNull  (  attributes  )  ;    childNodes  =  new  ArrayList<Node>  (  )  ;  this  .  baseUri  =  baseUri  .  trim  (  )  ;  [ATTENTION]  this  .  attributes  =  null  ;  }    [METHOD]  <init>  [TYPE]  Attributes)  [PARAMETER]  String  baseUri  Attributes  attributes  [CLASS]  Node    [TYPE]  Attributes  attributes  [TYPE]  List  childNodes  [TYPE]  String  baseUri  [TYPE]  boolean  false  true  [TYPE]  Node  parentNode  
[REPLACE]  this  (  baseUri,  new  Attributes  (  )  )  ;	[BUGGY]  if  (  !hasAttr  (  attributeKey  )  )  {  return   " "  ;  [CE]  illegal  start  of  expression  [CONTEXT]  protected  Node  (  String  baseUri  )  {  [ATTENTION]  if  (  !hasAttr  (  attributeKey  )  )  {  return   " "  ;  }    [METHOD]  <init>  [TYPE]  String)  [PARAMETER]  String  baseUri  [CLASS]  Node    [TYPE]  Attributes  attributes  [TYPE]  List  childNodes  [TYPE]  String  baseUri  [TYPE]  boolean  false  true  [TYPE]  Node  parentNode  
[REMOVE]  	[BUGGY]  if  (  !hasAttr  (  attributeKey  )  )  {  return   " "  ;  [CE]  illegal  start  of  expression  [CONTEXT]  protected  Node  (  String  baseUri  )  {  [ATTENTION]  this  (  baseUri  ,  new  Attributes  (  )  )  ;      [METHOD]  <init>  [TYPE]  String)  [PARAMETER]  String  baseUri  [CLASS]  Node    [TYPE]  Attributes  attributes  [TYPE]  List  childNodes  [TYPE]  String  baseUri  [TYPE]  boolean  false  true  [TYPE]  Node  parentNode  
[REPLACE]  Validate  .  notNull  (  attributeKey  )  ;	[BUGGY]  Validate  .  notEmpty  (  baseUri  )    ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  String  attr  (  String  attributeKey  )  {  [ATTENTION]  Validate  .  notEmpty  (  baseUri  )  ;    if  (  hasAttr  (  attributeKey  )  )  return  attributes  .  get  (  attributeKey  )  ;  else  if  (  attributeKey  .  toLowerCase  (  )  .  startsWith  (   "abs: "  )  )  return  absUrl  (  attributeKey  .  substring  (   "abs: "  .  length  (  )  )  )  ;  else  return   " "  ;  }    [METHOD]  attr  [TYPE]  String  [PARAMETER]  String  attributeKey  [CLASS]  Node    [TYPE]  Attributes  attributes  [TYPE]  List  childNodes  [TYPE]  String  attributeKey  baseUri  [TYPE]  boolean  false  true  [TYPE]  Node  parentNode  
[REPLACE]  if  (  hasAttr  (  attributeKey  )  )  return  attributes  .  get  (  attributeKey  )  ;	[BUGGY]  if  (  hasAttr  (  baseUri  )  )  return  attributes  .  get  (  attributeKey  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  String  attr  (  String  attributeKey  )  {  Validate  .  notNull  (  attributeKey  )  ;    [ATTENTION]  if  (  hasAttr  (  baseUri  )  )  return  attributes  .  get  (  attributeKey  )    ;    else  if  (  attributeKey  .  toLowerCase  (  )  .  startsWith  (   "abs: "  )  )  return  absUrl  (  attributeKey  .  substring  (   "abs: "  .  length  (  )  )  )  ;  else  return   " "  ;  }    [METHOD]  attr  [TYPE]  String  [PARAMETER]  String  attributeKey  [CLASS]  Node    [TYPE]  Attributes  attributes  [TYPE]  List  childNodes  [TYPE]  String  attributeKey  baseUri  [TYPE]  boolean  false  true  [TYPE]  Node  parentNode  
[REPLACE]  else  if  (  attributeKey  .  toLowerCase  (  )    .  startsWith  (   "abs: "  )  )  return  absUrl  (  attributeKey  .  substring  (   "abs: "  .  length  (  )  )  )  ;	[BUGGY]  if  (  baseUri  .  toLowerCase  (  )  .  startsWith  (   "abs: "  )  )  return  absUrl  (  attributeKey  .  substring  (   "abs: "  .  length  (  )  )  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  String  attr  (  String  attributeKey  )  {  Validate  .  notNull  (  attributeKey  )  ;    if  (  hasAttr  (  attributeKey  )  )  return  attributes  .  get  (  attributeKey  )  ;  [ATTENTION]  if  (  baseUri  .  toLowerCase  (  )    .  startsWith  (   "abs: "  )  )  return  absUrl  (  attributeKey  .  substring  (   "abs: "  .  length  (  )  )  )    ;    else  return   " "  ;  }    [METHOD]  attr  [TYPE]  String  [PARAMETER]  String  attributeKey  [CLASS]  Node    [TYPE]  Attributes  attributes  [TYPE]  List  childNodes  [TYPE]  String  attributeKey  baseUri  [TYPE]  boolean  false  true  [TYPE]  Node  parentNode  
[ADD]  else  if  (  attributeKey  .  toLowerCase  (  )    .  startsWith  (   "abs: "  )  )  return  absUrl  (  attributeKey  .  substring  (   "abs: "  .  length  (  )  )  )  ;  else  return   " ";  }	[BUGGY]  [CE]  illegal  start  of  expression  [CONTEXT]  public  String  attr  (  String  attributeKey  )  {  Validate  .  notNull  (  attributeKey  )  ;    if  (  hasAttr  (  attributeKey  )  )  return  attributes  .  get  (  attributeKey  )  ;  [ATTENTION]        [METHOD]  attr  [TYPE]  String  [PARAMETER]  String  attributeKey  [CLASS]  Node    [TYPE]  Attributes  attributes  [TYPE]  List  childNodes  [TYPE]  String  attributeKey  baseUri  [TYPE]  boolean  false  true  [TYPE]  Node  parentNode  
[REPLACE]  else  return   " ";	[BUGGY]  return   " "  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  String  attr  (  String  attributeKey  )  {  Validate  .  notNull  (  attributeKey  )  ;    if  (  hasAttr  (  attributeKey  )  )  return  attributes  .  get  (  attributeKey  )  ;  else  if  (  attributeKey  .  toLowerCase  (  )  .  startsWith  (   "abs: "  )  )  return  absUrl  (  attributeKey  .  substring  (   "abs: "  .  length  (  )  )  )  ;  [ATTENTION]  return   " "  ;  }    [METHOD]  attr  [TYPE]  String  [PARAMETER]  String  attributeKey  [CLASS]  Node    [TYPE]  Attributes  attributes  [TYPE]  List  childNodes  [TYPE]  String  attributeKey  baseUri  [TYPE]  boolean  false  true  [TYPE]  Node  parentNode  
[REPLACE]  return  absUrl  (  attributeKey  .  substring  (   "abs: "  .  length  (  )  )  )  ;	[BUGGY]  return  absUrl  (  baseUri  .  substring  (   "abs: "  .  length  (  )  )  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  String  attr  (  String  attributeKey  )  {  Validate  .  notNull  (  attributeKey  )  ;    if  (  hasAttr  (  attributeKey  )  )  return  attributes  .  get  (  attributeKey  )  ;  else  if  (  attributeKey  .  toLowerCase  (  )  .  startsWith  (   "abs: "  )  )  [ATTENTION]  return  absUrl  (  baseUri  .  substring  (   "abs: "  .  length  (  )  )  )    ;  else  return   " "  ;  }    [METHOD]  attr  [TYPE]  String  [PARAMETER]  String  attributeKey  [CLASS]  Node    [TYPE]  Attributes  attributes  [TYPE]  List  childNodes  [TYPE]  String  attributeKey  baseUri  [TYPE]  boolean  false  true  [TYPE]  Node  parentNode  
[REPLACE]  return  absUrl  (  attributeKey  .  substring  (   "abs: "  .  length  (  )  )  )  ;	[BUGGY]  return  absUrl  (  attributeKey  .  substring  (   "abs: "  .  startsWith  (  baseUri  )    )  )  ;  [CE]  no  suitable  method  found  for  substring(boolean)  [CONTEXT]  public  String  attr  (  String  attributeKey  )  {  Validate  .  notNull  (  attributeKey  )  ;    if  (  hasAttr  (  attributeKey  )  )  return  attributes  .  get  (  attributeKey  )  ;  else  if  (  attributeKey  .  toLowerCase  (  )  .  startsWith  (   "abs: "  )  )  [ATTENTION]  return  absUrl  (  attributeKey  .  substring  (   "abs: "  .  startsWith  (  baseUri  )    )  )    ;  else  return   " "  ;  }    [METHOD]  attr  [TYPE]  String  [PARAMETER]  String  attributeKey  [CLASS]  Node    [TYPE]  Attributes  attributes  [TYPE]  List  childNodes  [TYPE]  String  attributeKey  baseUri  [TYPE]  boolean  false  true  [TYPE]  Node  parentNode  
[REPLACE]  return  attributes  .  get  (  attributeKey  )  ;	[BUGGY]  return  attributes  .  hasKey  (  baseUri  )  ;  [CE]  incompatible  types  [CONTEXT]  public  String  attr  (  String  attributeKey  )  {  Validate  .  notNull  (  attributeKey  )  ;    if  (  hasAttr  (  attributeKey  )  )  [ATTENTION]  return  attributes  .  hasKey  (  baseUri  )    ;  else  if  (  attributeKey  .  toLowerCase  (  )  .  startsWith  (   "abs: "  )  )  return  absUrl  (  attributeKey  .  substring  (   "abs: "  .  length  (  )  )  )  ;  else  return   " "  ;  }    [METHOD]  attr  [TYPE]  String  [PARAMETER]  String  attributeKey  [CLASS]  Node    [TYPE]  Attributes  attributes  [TYPE]  List  childNodes  [TYPE]  String  attributeKey  baseUri  [TYPE]  boolean  false  true  [TYPE]  Node  parentNode  
[REPLACE]  return  attributes  .  get  (  attributeKey  )  ;	[BUGGY]  return  attributes  .  put  (  baseUri  ,  baseUri  )    ;  [CE]  incompatible  types  [CONTEXT]  public  String  attr  (  String  attributeKey  )  {  Validate  .  notNull  (  attributeKey  )  ;    if  (  hasAttr  (  attributeKey  )  )  [ATTENTION]  return  attributes  .  put  (  baseUri  ,  baseUri  )  ;  else  if  (  attributeKey  .  toLowerCase  (  )  .  startsWith  (   "abs: "  )  )  return  absUrl  (  attributeKey  .  substring  (   "abs: "  .  length  (  )  )  )  ;  else  return   " "  ;  }    [METHOD]  attr  [TYPE]  String  [PARAMETER]  String  attributeKey  [CLASS]  Node    [TYPE]  Attributes  attributes  [TYPE]  List  childNodes  [TYPE]  String  attributeKey  baseUri  [TYPE]  boolean  false  true  [TYPE]  Node  parentNode  
[REPLACE]  return  absUrl  (  attributeKey  .  substring  (   "abs: "  .  length  (  )  )  )  ;	[BUGGY]  return  absUrl  (  baseUri  .  substring  (   "abs: "  .  startsWith  (  baseUri  )    )  )  ;  [CE]  no  suitable  method  found  for  substring(boolean)  [CONTEXT]  public  String  attr  (  String  attributeKey  )  {  Validate  .  notNull  (  attributeKey  )  ;    if  (  hasAttr  (  attributeKey  )  )  return  attributes  .  get  (  attributeKey  )  ;  else  if  (  attributeKey  .  toLowerCase  (  )  .  startsWith  (   "abs: "  )  )  [ATTENTION]  return  absUrl  (  baseUri  .  substring  (   "abs: "  .  startsWith  (  baseUri  )    )  )    ;  else  return   " "  ;  }    [METHOD]  attr  [TYPE]  String  [PARAMETER]  String  attributeKey  [CLASS]  Node    [TYPE]  Attributes  attributes  [TYPE]  List  childNodes  [TYPE]  String  attributeKey  baseUri  [TYPE]  boolean  false  true  [TYPE]  Node  parentNode  
[REPLACE]  return  attributes;	[BUGGY]  return  siblings  .  get  (  index-1  )  ;  [CE]  cannot  find  symbol  index  [CONTEXT]  public  Attributes  attributes  (  )  {  [ATTENTION]  return  siblings  .  get  (  index-1  )    ;  }    [METHOD]  attributes  [TYPE]  Attributes  [PARAMETER]  [CLASS]  Node    [TYPE]  Attributes  attributes  [TYPE]  List  childNodes  [TYPE]  String  attributeKey  baseUri  [TYPE]  boolean  false  true  [TYPE]  Node  parentNode  
[REPLACE]  attributes  .  put  (  attributeKey,  attributeValue  )  ;	[BUGGY]  attributes  .  put  (  baseUri  ,  attributeValue  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  Node  attr  (  String  attributeKey  ,  String  attributeValue  )  {  [ATTENTION]  attributes  .  put  (  baseUri  ,  attributeValue  )    ;  return  this  ;  }    [METHOD]  attr  [TYPE]  Node  [PARAMETER]  String  attributeKey  String  attributeValue  [CLASS]  Node    [TYPE]  Attributes  attributes  [TYPE]  List  childNodes  [TYPE]  String  attributeKey  attributeValue  baseUri  [TYPE]  boolean  false  true  [TYPE]  Node  parentNode  
[REPLACE]  return  this;	[BUGGY]  return  null  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  Node  attr  (  String  attributeKey  ,  String  attributeValue  )  {  attributes  .  put  (  attributeKey  ,  attributeValue  )  ;  [ATTENTION]  return  null  ;  }    [METHOD]  attr  [TYPE]  Node  [PARAMETER]  String  attributeKey  String  attributeValue  [CLASS]  Node    [TYPE]  Attributes  attributes  [TYPE]  List  childNodes  [TYPE]  String  attributeKey  attributeValue  baseUri  [TYPE]  boolean  false  true  [TYPE]  Node  parentNode  
[REPLACE]  Validate  .  notNull  (  attributeKey  )  ;	[BUGGY]  Validate  .  notEmpty  (  attributeKey  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  boolean  hasAttr  (  String  attributeKey  )  {  [ATTENTION]  Validate  .  notEmpty  (  attributeKey  )    ;  return  attributes  .  hasKey  (  attributeKey  )  ;  }    [METHOD]  hasAttr  [TYPE]  boolean  [PARAMETER]  String  attributeKey  [CLASS]  Node    [TYPE]  Attributes  attributes  [TYPE]  List  childNodes  [TYPE]  String  attributeKey  attributeValue  baseUri  [TYPE]  boolean  false  true  [TYPE]  Node  parentNode  
[REPLACE]  return  attributes  .  hasKey  (  attributeKey  )  ;	[BUGGY]  return  attributes  .  get  (  attributeKey  )  ;  [CE]  incompatible  types  [CONTEXT]  public  boolean  hasAttr  (  String  attributeKey  )  {  Validate  .  notNull  (  attributeKey  )  ;  [ATTENTION]  return  attributes  .  get  (  attributeKey  )    ;  }    [METHOD]  hasAttr  [TYPE]  boolean  [PARAMETER]  String  attributeKey  [CLASS]  Node    [TYPE]  Attributes  attributes  [TYPE]  List  childNodes  [TYPE]  String  attributeKey  attributeValue  baseUri  [TYPE]  boolean  false  true  [TYPE]  Node  parentNode  
[REPLACE]  Validate  .  notNull  (  attributeKey  )  ;	[BUGGY]  Validate  .  notNull  (  baseUri  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  Node  removeAttr  (  String  attributeKey  )  {  [ATTENTION]  Validate  .  notNull  (  baseUri  )    ;  attributes  .  remove  (  attributeKey  )  ;  return  this  ;  }    [METHOD]  removeAttr  [TYPE]  Node  [PARAMETER]  String  attributeKey  [CLASS]  Node    [TYPE]  Attributes  attributes  [TYPE]  List  childNodes  [TYPE]  String  attributeKey  attributeValue  baseUri  [TYPE]  boolean  false  true  [TYPE]  Node  parentNode  
[REPLACE]  attributes  .  remove  (  attributeKey  )  ;	[BUGGY]  attributes  .  get  (  attributeKey  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  Node  removeAttr  (  String  attributeKey  )  {  Validate  .  notNull  (  attributeKey  )  ;  [ATTENTION]  attributes  .  get  (  attributeKey  )    ;  return  this  ;  }    [METHOD]  removeAttr  [TYPE]  Node  [PARAMETER]  String  attributeKey  [CLASS]  Node    [TYPE]  Attributes  attributes  [TYPE]  List  childNodes  [TYPE]  String  attributeKey  attributeValue  baseUri  [TYPE]  boolean  false  true  [TYPE]  Node  parentNode  
[REMOVE]  	[BUGGY]  return  siblings  .  get  (  index-1  )  ;  [CE]  cannot  find  symbol  index  [CONTEXT]  public  Node  removeAttr  (  String  attributeKey  )  {  Validate  .  notNull  (  attributeKey  )  ;  [ATTENTION]  attributes  .  remove  (  attributeKey  )  ;    return  siblings  .  get  (  index-1  )    ;  return  this  ;      [METHOD]  removeAttr  [TYPE]  Node  [PARAMETER]  String  attributeKey  [CLASS]  Node    [TYPE]  Attributes  attributes  [TYPE]  List  childNodes  [TYPE]  String  attributeKey  attributeValue  baseUri  [TYPE]  boolean  false  true  [TYPE]  Node  parentNode  
[REPLACE]  return  this;	[BUGGY]  return  null  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  Node  removeAttr  (  String  attributeKey  )  {  Validate  .  notNull  (  attributeKey  )  ;  attributes  .  remove  (  attributeKey  )  ;  [ATTENTION]  return  null  ;  }    [METHOD]  removeAttr  [TYPE]  Node  [PARAMETER]  String  attributeKey  [CLASS]  Node    [TYPE]  Attributes  attributes  [TYPE]  List  childNodes  [TYPE]  String  attributeKey  attributeValue  baseUri  [TYPE]  boolean  false  true  [TYPE]  Node  parentNode  
[REPLACE]  return  baseUri;	[BUGGY]  return  siblings  .  get  (  index-1  )  ;  [CE]  cannot  find  symbol  index  [CONTEXT]  public  String  baseUri  (  )  {  [ATTENTION]  return  siblings  .  get  (  index-1  )    ;  }    [METHOD]  baseUri  [TYPE]  String  [PARAMETER]  [CLASS]  Node    [TYPE]  Attributes  attributes  [TYPE]  List  childNodes  [TYPE]  String  attributeKey  attributeValue  baseUri  [TYPE]  boolean  false  true  [TYPE]  Node  parentNode  
[REPLACE]  Validate  .  notNull  (  baseUri  )  ;	[BUGGY]  Validate  .  notNull  (  attributeValue  )  ;  [CE]  cannot  find  symbol  attributeValue  [CONTEXT]  public  void  setBaseUri  (  String  baseUri  )  {  [ATTENTION]  Validate  .  notNull  (  attributeValue  )    ;  this  .  baseUri  =  baseUri  ;  }    [METHOD]  setBaseUri  [TYPE]  void  [PARAMETER]  String  baseUri  [CLASS]  Node    [TYPE]  Attributes  attributes  [TYPE]  List  childNodes  [TYPE]  String  attributeKey  attributeValue  baseUri  [TYPE]  boolean  false  true  [TYPE]  Node  parentNode  
[REPLACE]  this  .  baseUri  =  baseUri;	[BUGGY]  this  .  baseUri  =    attributeValue  ;  [CE]  cannot  find  symbol  attributeValue  [CONTEXT]  public  void  setBaseUri  (  String  baseUri  )  {  Validate  .  notNull  (  baseUri  )  ;  [ATTENTION]  this  .  baseUri  =  attributeValue  ;  }    [METHOD]  setBaseUri  [TYPE]  void  [PARAMETER]  String  baseUri  [CLASS]  Node    [TYPE]  Attributes  attributes  [TYPE]  List  childNodes  [TYPE]  String  attributeKey  attributeValue  baseUri  [TYPE]  boolean  false  true  [TYPE]  Node  parentNode  
[ADD]  this  .  baseUri  =  baseUri;	[BUGGY]  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  void  setBaseUri  (  String  baseUri  )  {  Validate  .  notNull  (  baseUri  )  ;  [ATTENTION]  }    [METHOD]  setBaseUri  [TYPE]  void  [PARAMETER]  String  baseUri  [CLASS]  Node    [TYPE]  Attributes  attributes  [TYPE]  List  childNodes  [TYPE]  String  attributeKey  attributeValue  baseUri  [TYPE]  boolean  false  true  [TYPE]  Node  parentNode  
[REPLACE]  Validate  .  notEmpty  (  attributeKey  )  ;	[BUGGY]  Validate  .  notEmpty  (  relUrl  )  ;  [CE]  cannot  find  symbol  relUrl  [CONTEXT]  public  String  absUrl  (  String  attributeKey  )  {  [ATTENTION]  Validate  .  notEmpty  (  relUrl  )    ;    String  relUrl  =  attr  (  attributeKey  )  ;  if  (  !hasAttr  (  attributeKey  )  )  {  return   " "  ;  //  nothing  to  make  absolute  with  }  else  {  URL  base  ;  try  {  try  {  base  =  new  URL  (  baseUri  )  ;  }  catch  (  MalformedURLException  e  )  {    URL  abs  =  new  URL  (  relUrl  )  ;  return  abs  .  toExternalForm  (  )  ;  }  URL  abs  =  new  URL  (  base  ,  relUrl  )  ;  return  abs  .  toExternalForm  (  )  ;  }  catch  (  MalformedURLException  e  )  {  return   " "  ;  }  }  }    [METHOD]  absUrl  [TYPE]  String  [PARAMETER]  String  attributeKey  [CLASS]  Node    [TYPE]  MalformedURLException  e  [TYPE]  boolean  false  true  [TYPE]  Node  parentNode  [TYPE]  Attributes  attributes  [TYPE]  List  childNodes  [TYPE]  String  attributeKey  attributeValue  baseUri  relUrl  [TYPE]  URL  abs  base  
[REPLACE]  String  relUrl  =  attr  (  attributeKey  )  ;	[BUGGY]  String  relUrl  =  attr  (  relUrl  )  ;  [CE]  variable  relUrl  might  not  have  been  initialized  [CONTEXT]  public  String  absUrl  (  String  attributeKey  )  {  Validate  .  notEmpty  (  attributeKey  )  ;    [ATTENTION]  String  relUrl  =  attr  (  relUrl  )    ;  if  (  !hasAttr  (  attributeKey  )  )  {  return   " "  ;  //  nothing  to  make  absolute  with  }  else  {  URL  base  ;  try  {  try  {  base  =  new  URL  (  baseUri  )  ;  }  catch  (  MalformedURLException  e  )  {    URL  abs  =  new  URL  (  relUrl  )  ;  return  abs  .  toExternalForm  (  )  ;  }  URL  abs  =  new  URL  (  base  ,  relUrl  )  ;  return  abs  .  toExternalForm  (  )  ;  }  catch  (  MalformedURLException  e  )  {  return   " "  ;  }  }  }    [METHOD]  absUrl  [TYPE]  String  [PARAMETER]  String  attributeKey  [CLASS]  Node    [TYPE]  MalformedURLException  e  [TYPE]  boolean  false  true  [TYPE]  Node  parentNode  [TYPE]  Attributes  attributes  [TYPE]  List  childNodes  [TYPE]  String  attributeKey  attributeValue  baseUri  relUrl  [TYPE]  URL  abs  base  
[REPLACE]  if  (  !hasAttr  (  attributeKey  )  )  {	[BUGGY]  if  (  siblings  .  size  (  )  >  index+1  )  return  siblings  .  get  (  index+1  )  ;  [CE]  illegal  start  of  type  [CONTEXT]  public  String  absUrl  (  String  attributeKey  )  {  Validate  .  notEmpty  (  attributeKey  )  ;    String  relUrl  =  attr  (  attributeKey  )  ;  [ATTENTION]  if  (  siblings  .  size  (  )  >  index+1  )  return  siblings  .  get  (  index+1  )    ;  return   " "  ;  //  nothing  to  make  absolute  with  }  else  {  URL  base  ;  try  {  try  {  base  =  new  URL  (  baseUri  )  ;  }  catch  (  MalformedURLException  e  )  {    URL  abs  =  new  URL  (  relUrl  )  ;  return  abs  .  toExternalForm  (  )  ;  }  URL  abs  =  new  URL  (  base  ,  relUrl  )  ;  return  abs  .  toExternalForm  (  )  ;  }  catch  (  MalformedURLException  e  )  {  return   " "  ;  }  }  }    [METHOD]  absUrl  [TYPE]  String  [PARAMETER]  String  attributeKey  [CLASS]  Node    [TYPE]  MalformedURLException  e  [TYPE]  boolean  false  true  [TYPE]  Node  parentNode  [TYPE]  Attributes  attributes  [TYPE]  List  childNodes  [TYPE]  String  attributeKey  attributeValue  baseUri  relUrl  [TYPE]  URL  abs  base  
[ADD]  try  {  try  {  base  =  new  URL  (  baseUri  )  ;  }  catch  (  MalformedURLException  e  )  {	[BUGGY]  base  =  new  URL  (  baseUri  )  ;  [CE]  illegal  start  of  type  [CONTEXT]  public  String  absUrl  (  String  attributeKey  )  {  Validate  .  notEmpty  (  attributeKey  )  ;    String  relUrl  =  attr  (  attributeKey  )  ;  if  (  !hasAttr  (  attributeKey  )  )  {  return   " "  ;  //  nothing  to  make  absolute  with  }  else  {  URL  base  ;  [ATTENTION]  base  =  new  URL  (  baseUri  )    ;      URL  abs  =  new  URL  (  relUrl  )  ;  return  abs  .  toExternalForm  (  )  ;  }  URL  abs  =  new  URL  (  base  ,  relUrl  )  ;  return  abs  .  toExternalForm  (  )  ;  }  catch  (  MalformedURLException  e  )  {  return   " "  ;  }  }  }    [METHOD]  absUrl  [TYPE]  String  [PARAMETER]  String  attributeKey  [CLASS]  Node    [TYPE]  MalformedURLException  e  [TYPE]  boolean  false  true  [TYPE]  Node  parentNode  [TYPE]  Attributes  attributes  [TYPE]  List  childNodes  [TYPE]  String  attributeKey  attributeValue  baseUri  relUrl  [TYPE]  URL  abs  base  
[ADD]  try  {  base  =  new  URL  (  baseUri  )  ;  }  catch  (  MalformedURLException  e  )  {  URL  abs  =  new  URL  (  relUrl  )  ;	[BUGGY]  base  =  new  URL  (  baseUri  )  ;  URL  abs  =  new  URL  (  relUrl  )  ;  [CE]  'try'  without  'catch'  or  'finally'  [CONTEXT]  public  String  absUrl  (  String  attributeKey  )  {  Validate  .  notEmpty  (  attributeKey  )  ;    String  relUrl  =  attr  (  attributeKey  )  ;  if  (  !hasAttr  (  attributeKey  )  )  {  return   " "  ;  //  nothing  to  make  absolute  with  }  else  {  URL  base  ;  try  {  [ATTENTION]  base  =  new  URL  (  baseUri  )    ;  URL  abs  =  new  URL  (  relUrl  )    ;        return  abs  .  toExternalForm  (  )  ;  }  URL  abs  =  new  URL  (  base  ,  relUrl  )  ;  return  abs  .  toExternalForm  (  )  ;  }  catch  (  MalformedURLException  e  )  {  return   " "  ;  }  }  }    [METHOD]  absUrl  [TYPE]  String  [PARAMETER]  String  attributeKey  [CLASS]  Node    [TYPE]  MalformedURLException  e  [TYPE]  boolean  false  true  [TYPE]  Node  parentNode  [TYPE]  Attributes  attributes  [TYPE]  List  childNodes  [TYPE]  String  attributeKey  attributeValue  baseUri  relUrl  [TYPE]  URL  abs  base  
[REPLACE]  base  =  new  URL  (  baseUri  )  ;	[BUGGY]  base  =    new  URL  (  relUrl  )    ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  String  absUrl  (  String  attributeKey  )  {  Validate  .  notEmpty  (  attributeKey  )  ;    String  relUrl  =  attr  (  attributeKey  )  ;  if  (  !hasAttr  (  attributeKey  )  )  {  return   " "  ;  //  nothing  to  make  absolute  with  }  else  {  URL  base  ;  try  {  try  {  [ATTENTION]  base  =  new  URL  (  relUrl  )  ;  }  catch  (  MalformedURLException  e  )  {    URL  abs  =  new  URL  (  relUrl  )  ;  return  abs  .  toExternalForm  (  )  ;  }  URL  abs  =  new  URL  (  base  ,  relUrl  )  ;  return  abs  .  toExternalForm  (  )  ;  }  catch  (  MalformedURLException  e  )  {  return   " "  ;  }  }  }    [METHOD]  absUrl  [TYPE]  String  [PARAMETER]  String  attributeKey  [CLASS]  Node    [TYPE]  MalformedURLException  e  [TYPE]  boolean  false  true  [TYPE]  Node  parentNode  [TYPE]  Attributes  attributes  [TYPE]  List  childNodes  [TYPE]  String  attributeKey  attributeValue  baseUri  relUrl  [TYPE]  URL  abs  base  
[ADD]  base  =  new  URL  (  baseUri  )  ;	[BUGGY]  [CE]  exception  MalformedURLException  is  never  thrown  in  body  of  corresponding  try  statement  [CONTEXT]  public  String  absUrl  (  String  attributeKey  )  {  Validate  .  notEmpty  (  attributeKey  )  ;    String  relUrl  =  attr  (  attributeKey  )  ;  if  (  !hasAttr  (  attributeKey  )  )  {  return   " "  ;  //  nothing  to  make  absolute  with  }  else  {  URL  base  ;  try  {  try  {  [ATTENTION]  }  catch  (  MalformedURLException  e  )  {    URL  abs  =  new  URL  (  relUrl  )  ;  return  abs  .  toExternalForm  (  )  ;  }  URL  abs  =  new  URL  (  base  ,  relUrl  )  ;  return  abs  .  toExternalForm  (  )  ;  }  catch  (  MalformedURLException  e  )  {  return   " "  ;  }  }  }    [METHOD]  absUrl  [TYPE]  String  [PARAMETER]  String  attributeKey  [CLASS]  Node    [TYPE]  MalformedURLException  e  [TYPE]  boolean  false  true  [TYPE]  Node  parentNode  [TYPE]  Attributes  attributes  [TYPE]  List  childNodes  [TYPE]  String  attributeKey  attributeValue  baseUri  relUrl  [TYPE]  URL  abs  base  
[REPLACE]  return  abs  .  toExternalForm  (  )  ;	[BUGGY]  return  base  .  toExternalForm  (  )  ;  [CE]  variable  base  might  not  have  been  initialized  [CONTEXT]  public  String  absUrl  (  String  attributeKey  )  {  Validate  .  notEmpty  (  attributeKey  )  ;    String  relUrl  =  attr  (  attributeKey  )  ;  if  (  !hasAttr  (  attributeKey  )  )  {  return   " "  ;  //  nothing  to  make  absolute  with  }  else  {  URL  base  ;  try  {  try  {  base  =  new  URL  (  baseUri  )  ;  }  catch  (  MalformedURLException  e  )  {    URL  abs  =  new  URL  (  relUrl  )  ;  [ATTENTION]  return  base  .  toExternalForm  (  )    ;  }  URL  abs  =  new  URL  (  base  ,  relUrl  )  ;  return  abs  .  toExternalForm  (  )  ;  }  catch  (  MalformedURLException  e  )  {  return   " "  ;  }  }  }    [METHOD]  absUrl  [TYPE]  String  [PARAMETER]  String  attributeKey  [CLASS]  Node    [TYPE]  MalformedURLException  e  [TYPE]  boolean  false  true  [TYPE]  Node  parentNode  [TYPE]  Attributes  attributes  [TYPE]  List  childNodes  [TYPE]  String  attributeKey  attributeValue  baseUri  relUrl  [TYPE]  URL  abs  base  
[REPLACE]  return  abs  .  toExternalForm  (  )  ;	[BUGGY]  return  base  .  URL  (  baseUri  )    ;  [CE]  cannot  find  symbol  [CONTEXT]  public  String  absUrl  (  String  attributeKey  )  {  Validate  .  notEmpty  (  attributeKey  )  ;    String  relUrl  =  attr  (  attributeKey  )  ;  if  (  !hasAttr  (  attributeKey  )  )  {  return   " "  ;  //  nothing  to  make  absolute  with  }  else  {  URL  base  ;  try  {  try  {  base  =  new  URL  (  baseUri  )  ;  }  catch  (  MalformedURLException  e  )  {    URL  abs  =  new  URL  (  relUrl  )  ;  return  abs  .  toExternalForm  (  )  ;  }  URL  abs  =  new  URL  (  base  ,  relUrl  )  ;  [ATTENTION]  return  base  .  URL  (  baseUri  )  ;  }  catch  (  MalformedURLException  e  )  {  return   " "  ;  }  }  }    [METHOD]  absUrl  [TYPE]  String  [PARAMETER]  String  attributeKey  [CLASS]  Node    [TYPE]  MalformedURLException  e  [TYPE]  boolean  false  true  [TYPE]  Node  parentNode  [TYPE]  Attributes  attributes  [TYPE]  List  childNodes  [TYPE]  String  attributeKey  attributeValue  baseUri  relUrl  [TYPE]  URL  abs  base  
[REPLACE]  URL  abs  =  new  URL  (  relUrl  )  ;	[BUGGY]  URL  abs  =  new  URL  (  baseUri  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  String  absUrl  (  String  attributeKey  )  {  Validate  .  notEmpty  (  attributeKey  )  ;    String  relUrl  =  attr  (  attributeKey  )  ;  if  (  !hasAttr  (  attributeKey  )  )  {  return   " "  ;  //  nothing  to  make  absolute  with  }  else  {  URL  base  ;  try  {  try  {  base  =  new  URL  (  baseUri  )  ;  }  catch  (  MalformedURLException  e  )  {    [ATTENTION]  URL  abs  =  new  URL  (  baseUri  )    ;  return  abs  .  toExternalForm  (  )  ;  }  URL  abs  =  new  URL  (  base  ,  relUrl  )  ;  return  abs  .  toExternalForm  (  )  ;  }  catch  (  MalformedURLException  e  )  {  return   " "  ;  }  }  }    [METHOD]  absUrl  [TYPE]  String  [PARAMETER]  String  attributeKey  [CLASS]  Node    [TYPE]  MalformedURLException  e  [TYPE]  boolean  false  true  [TYPE]  Node  parentNode  [TYPE]  Attributes  attributes  [TYPE]  List  childNodes  [TYPE]  String  attributeKey  attributeValue  baseUri  relUrl  [TYPE]  URL  abs  base  
[REPLACE]  URL  abs  =  new  URL  (  base,  relUrl  )  ;	[BUGGY]  URL  abs  =  new  URL  (  abs  ,  relUrl  )  ;  [CE]  variable  abs  might  not  have  been  initialized  [CONTEXT]  public  String  absUrl  (  String  attributeKey  )  {  Validate  .  notEmpty  (  attributeKey  )  ;    String  relUrl  =  attr  (  attributeKey  )  ;  if  (  !hasAttr  (  attributeKey  )  )  {  return   " "  ;  //  nothing  to  make  absolute  with  }  else  {  URL  base  ;  try  {  try  {  base  =  new  URL  (  baseUri  )  ;  }  catch  (  MalformedURLException  e  )  {    URL  abs  =  new  URL  (  relUrl  )  ;  return  abs  .  toExternalForm  (  )  ;  }  [ATTENTION]  URL  abs  =  new  URL  (  abs  ,  relUrl  )    ;  return  abs  .  toExternalForm  (  )  ;  }  catch  (  MalformedURLException  e  )  {  return   " "  ;  }  }  }    [METHOD]  absUrl  [TYPE]  String  [PARAMETER]  String  attributeKey  [CLASS]  Node    [TYPE]  MalformedURLException  e  [TYPE]  boolean  false  true  [TYPE]  Node  parentNode  [TYPE]  Attributes  attributes  [TYPE]  List  childNodes  [TYPE]  String  attributeKey  attributeValue  baseUri  relUrl  [TYPE]  URL  abs  base  
[ADD]  URL  abs  =  new  URL  (  base,  relUrl  )  ;  return  abs  .  toExternalForm  (  )  ;	[BUGGY]  [CE]  missing  return  statement  [CONTEXT]  public  String  absUrl  (  String  attributeKey  )  {  Validate  .  notEmpty  (  attributeKey  )  ;    String  relUrl  =  attr  (  attributeKey  )  ;  if  (  !hasAttr  (  attributeKey  )  )  {  return   " "  ;  //  nothing  to  make  absolute  with  }  else  {  URL  base  ;  try  {  try  {  base  =  new  URL  (  baseUri  )  ;  }  catch  (  MalformedURLException  e  )  {    URL  abs  =  new  URL  (  relUrl  )  ;  return  abs  .  toExternalForm  (  )  ;  }  [ATTENTION]    }  catch  (  MalformedURLException  e  )  {  return   " "  ;  }  }  }    [METHOD]  absUrl  [TYPE]  String  [PARAMETER]  String  attributeKey  [CLASS]  Node    [TYPE]  MalformedURLException  e  [TYPE]  boolean  false  true  [TYPE]  Node  parentNode  [TYPE]  Attributes  attributes  [TYPE]  List  childNodes  [TYPE]  String  attributeKey  attributeValue  baseUri  relUrl  [TYPE]  URL  abs  base  
[REPLACE]  return  abs  .  toExternalForm  (  )  ;	[BUGGY]  return  base  .  URL  (  relUrl  )    ;  [CE]  cannot  find  symbol  [CONTEXT]  public  String  absUrl  (  String  attributeKey  )  {  Validate  .  notEmpty  (  attributeKey  )  ;    String  relUrl  =  attr  (  attributeKey  )  ;  if  (  !hasAttr  (  attributeKey  )  )  {  return   " "  ;  //  nothing  to  make  absolute  with  }  else  {  URL  base  ;  try  {  try  {  base  =  new  URL  (  baseUri  )  ;  }  catch  (  MalformedURLException  e  )  {    URL  abs  =  new  URL  (  relUrl  )  ;  [ATTENTION]  return  base  .  URL  (  relUrl  )  ;  }  URL  abs  =  new  URL  (  base  ,  relUrl  )  ;  return  abs  .  toExternalForm  (  )  ;  }  catch  (  MalformedURLException  e  )  {  return   " "  ;  }  }  }    [METHOD]  absUrl  [TYPE]  String  [PARAMETER]  String  attributeKey  [CLASS]  Node    [TYPE]  MalformedURLException  e  [TYPE]  boolean  false  true  [TYPE]  Node  parentNode  [TYPE]  Attributes  attributes  [TYPE]  List  childNodes  [TYPE]  String  attributeKey  attributeValue  baseUri  relUrl  [TYPE]  URL  abs  base  
[REPLACE]  return  abs  .  toExternalForm  (  )  ;	[BUGGY]  return  base  .  toExternalForm  (  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  String  absUrl  (  String  attributeKey  )  {  Validate  .  notEmpty  (  attributeKey  )  ;    String  relUrl  =  attr  (  attributeKey  )  ;  if  (  !hasAttr  (  attributeKey  )  )  {  return   " "  ;  //  nothing  to  make  absolute  with  }  else  {  URL  base  ;  try  {  try  {  base  =  new  URL  (  baseUri  )  ;  }  catch  (  MalformedURLException  e  )  {    URL  abs  =  new  URL  (  relUrl  )  ;  return  abs  .  toExternalForm  (  )  ;  }  URL  abs  =  new  URL  (  base  ,  relUrl  )  ;  [ATTENTION]  return  base  .  toExternalForm  (  )    ;  }  catch  (  MalformedURLException  e  )  {  return   " "  ;  }  }  }    [METHOD]  absUrl  [TYPE]  String  [PARAMETER]  String  attributeKey  [CLASS]  Node    [TYPE]  MalformedURLException  e  [TYPE]  boolean  false  true  [TYPE]  Node  parentNode  [TYPE]  Attributes  attributes  [TYPE]  List  childNodes  [TYPE]  String  attributeKey  attributeValue  baseUri  relUrl  [TYPE]  URL  abs  base  
[REPLACE]  return   " ";	[BUGGY]  return  parentNode  ;  [CE]  incompatible  types  [CONTEXT]  public  String  absUrl  (  String  attributeKey  )  {  Validate  .  notEmpty  (  attributeKey  )  ;    String  relUrl  =  attr  (  attributeKey  )  ;  if  (  !hasAttr  (  attributeKey  )  )  {  return   " "  ;  //  nothing  to  make  absolute  with  }  else  {  URL  base  ;  try  {  try  {  base  =  new  URL  (  baseUri  )  ;  }  catch  (  MalformedURLException  e  )  {    URL  abs  =  new  URL  (  relUrl  )  ;  return  abs  .  toExternalForm  (  )  ;  }  URL  abs  =  new  URL  (  base  ,  relUrl  )  ;  return  abs  .  toExternalForm  (  )  ;  }  catch  (  MalformedURLException  e  )  {  [ATTENTION]  return  parentNode  ;  }  }  }    [METHOD]  absUrl  [TYPE]  String  [PARAMETER]  String  attributeKey  [CLASS]  Node    [TYPE]  MalformedURLException  e  [TYPE]  boolean  false  true  [TYPE]  Node  parentNode  [TYPE]  Attributes  attributes  [TYPE]  List  childNodes  [TYPE]  String  attributeKey  attributeValue  baseUri  relUrl  [TYPE]  URL  abs  base  
[REPLACE]  URL  base;	[BUGGY]  N  node  =  nodes  .  get  (  i  )  ;  [CE]  cannot  find  symbol  [CONTEXT]  public  String  absUrl  (  String  attributeKey  )  {  Validate  .  notEmpty  (  attributeKey  )  ;    String  relUrl  =  attr  (  attributeKey  )  ;  if  (  !hasAttr  (  attributeKey  )  )  {  return   " "  ;  //  nothing  to  make  absolute  with  }  else  {  [ATTENTION]  N  node  =  nodes  .  get  (  i  )    ;  try  {  try  {  base  =  new  URL  (  baseUri  )  ;  }  catch  (  MalformedURLException  e  )  {    URL  abs  =  new  URL  (  relUrl  )  ;  return  abs  .  toExternalForm  (  )  ;  }  URL  abs  =  new  URL  (  base  ,  relUrl  )  ;  return  abs  .  toExternalForm  (  )  ;  }  catch  (  MalformedURLException  e  )  {  return   " "  ;  }  }  }    [METHOD]  absUrl  [TYPE]  String  [PARAMETER]  String  attributeKey  [CLASS]  Node    [TYPE]  MalformedURLException  e  [TYPE]  boolean  false  true  [TYPE]  Node  parentNode  [TYPE]  Attributes  attributes  [TYPE]  List  childNodes  [TYPE]  String  attributeKey  attributeValue  baseUri  relUrl  [TYPE]  URL  abs  base  
[REPLACE]  return   " ";	[BUGGY]  return  parentNode  ;  [CE]  incompatible  types  [CONTEXT]  public  String  absUrl  (  String  attributeKey  )  {  Validate  .  notEmpty  (  attributeKey  )  ;    String  relUrl  =  attr  (  attributeKey  )  ;  if  (  !hasAttr  (  attributeKey  )  )  {  [ATTENTION]  return  parentNode  ;  }  else  {  URL  base  ;  try  {  try  {  base  =  new  URL  (  baseUri  )  ;  }  catch  (  MalformedURLException  e  )  {    URL  abs  =  new  URL  (  relUrl  )  ;  return  abs  .  toExternalForm  (  )  ;  }  URL  abs  =  new  URL  (  base  ,  relUrl  )  ;  return  abs  .  toExternalForm  (  )  ;  }  catch  (  MalformedURLException  e  )  {  return   " "  ;  }  }  }    [METHOD]  absUrl  [TYPE]  String  [PARAMETER]  String  attributeKey  [CLASS]  Node    [TYPE]  MalformedURLException  e  [TYPE]  boolean  false  true  [TYPE]  Node  parentNode  [TYPE]  Attributes  attributes  [TYPE]  List  childNodes  [TYPE]  String  attributeKey  attributeValue  baseUri  relUrl  [TYPE]  URL  abs  base  
[REPLACE]  return  abs  .  toExternalForm  (  )  ;	[BUGGY]  return  abs  .  URL  (  relUrl  )    ;  [CE]  cannot  find  symbol  [CONTEXT]  public  String  absUrl  (  String  attributeKey  )  {  Validate  .  notEmpty  (  attributeKey  )  ;    String  relUrl  =  attr  (  attributeKey  )  ;  if  (  !hasAttr  (  attributeKey  )  )  {  return   " "  ;  //  nothing  to  make  absolute  with  }  else  {  URL  base  ;  try  {  try  {  base  =  new  URL  (  baseUri  )  ;  }  catch  (  MalformedURLException  e  )  {    URL  abs  =  new  URL  (  relUrl  )  ;  [ATTENTION]  return  abs  .  URL  (  relUrl  )  ;  }  URL  abs  =  new  URL  (  base  ,  relUrl  )  ;  return  abs  .  toExternalForm  (  )  ;  }  catch  (  MalformedURLException  e  )  {  return   " "  ;  }  }  }    [METHOD]  absUrl  [TYPE]  String  [PARAMETER]  String  attributeKey  [CLASS]  Node    [TYPE]  MalformedURLException  e  [TYPE]  boolean  false  true  [TYPE]  Node  parentNode  [TYPE]  Attributes  attributes  [TYPE]  List  childNodes  [TYPE]  String  attributeKey  attributeValue  baseUri  relUrl  [TYPE]  URL  abs  base  
[REPLACE]  URL  abs  =  new  URL  (  base,  relUrl  )  ;	[BUGGY]  URL  abs  =  new  URL  (  base  ,  baseUri  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  String  absUrl  (  String  attributeKey  )  {  Validate  .  notEmpty  (  attributeKey  )  ;    String  relUrl  =  attr  (  attributeKey  )  ;  if  (  !hasAttr  (  attributeKey  )  )  {  return   " "  ;  //  nothing  to  make  absolute  with  }  else  {  URL  base  ;  try  {  try  {  base  =  new  URL  (  baseUri  )  ;  }  catch  (  MalformedURLException  e  )  {    URL  abs  =  new  URL  (  relUrl  )  ;  return  abs  .  toExternalForm  (  )  ;  }  [ATTENTION]  URL  abs  =  new  URL  (  base  ,  baseUri  )    ;  return  abs  .  toExternalForm  (  )  ;  }  catch  (  MalformedURLException  e  )  {  return   " "  ;  }  }  }    [METHOD]  absUrl  [TYPE]  String  [PARAMETER]  String  attributeKey  [CLASS]  Node    [TYPE]  MalformedURLException  e  [TYPE]  boolean  false  true  [TYPE]  Node  parentNode  [TYPE]  Attributes  attributes  [TYPE]  List  childNodes  [TYPE]  String  attributeKey  attributeValue  baseUri  relUrl  [TYPE]  URL  abs  base  
[ADD]  URL  abs  =  new  URL  (  relUrl  )  ;  return  abs  .  toExternalForm  (  )  ;	[BUGGY]  [CE]  variable  base  might  not  have  been  initialized  [CONTEXT]  public  String  absUrl  (  String  attributeKey  )  {  Validate  .  notEmpty  (  attributeKey  )  ;    String  relUrl  =  attr  (  attributeKey  )  ;  if  (  !hasAttr  (  attributeKey  )  )  {  return   " "  ;  //  nothing  to  make  absolute  with  }  else  {  URL  base  ;  try  {  try  {  base  =  new  URL  (  baseUri  )  ;  }  catch  (  MalformedURLException  e  )  {    [ATTENTION]    }  URL  abs  =  new  URL  (  base  ,  relUrl  )  ;  return  abs  .  toExternalForm  (  )  ;  }  catch  (  MalformedURLException  e  )  {  return   " "  ;  }  }  }    [METHOD]  absUrl  [TYPE]  String  [PARAMETER]  String  attributeKey  [CLASS]  Node    [TYPE]  MalformedURLException  e  [TYPE]  boolean  false  true  [TYPE]  Node  parentNode  [TYPE]  Attributes  attributes  [TYPE]  List  childNodes  [TYPE]  String  attributeKey  attributeValue  baseUri  relUrl  [TYPE]  URL  abs  base  
[REPLACE]  return  childNodes  .  get  (  index  )  ;	[BUGGY]  return  childNodes  .  remove  (  index  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  Node  childNode  (  int  index  )  {  [ATTENTION]  return  childNodes  .  remove  (  index  )    ;  }    [METHOD]  childNode  [TYPE]  Node  [PARAMETER]  int  index  [CLASS]  Node    [TYPE]  Attributes  attributes  [TYPE]  List  childNodes  [TYPE]  String  attributeKey  attributeValue  baseUri  relUrl  [TYPE]  boolean  false  true  [TYPE]  int  index  [TYPE]  Node  parentNode  
[REPLACE]  return  Collections  .  unmodifiableList  (  childNodes  )  ;	[BUGGY]  return    childNodes    ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  List<Node>  childNodes  (  )  {  [ATTENTION]  return  childNodes  ;  }    [METHOD]  childNodes  [TYPE]  List  [PARAMETER]  [CLASS]  Node    [TYPE]  Attributes  attributes  [TYPE]  List  childNodes  [TYPE]  String  attributeKey  attributeValue  baseUri  relUrl  [TYPE]  boolean  false  true  [TYPE]  Node  parentNode  
[REPLACE]  return  parentNode;	[BUGGY]  return  siblings  .  get  (  index-1  )  ;  [CE]  cannot  find  symbol  index  [CONTEXT]  public  Node  parent  (  )  {  [ATTENTION]  return  siblings  .  get  (  index-1  )    ;  }    [METHOD]  parent  [TYPE]  Node  [PARAMETER]  [CLASS]  Node    [TYPE]  Attributes  attributes  [TYPE]  List  childNodes  [TYPE]  String  attributeKey  attributeValue  baseUri  relUrl  [TYPE]  boolean  false  true  [TYPE]  Node  parentNode  
[REPLACE]  Validate  .  notNull  (  parentNode  )  ;	[BUGGY]  Validate  .  notNull  (  baseUri  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  void  remove  (  )  {  [ATTENTION]  Validate  .  notNull  (  baseUri  )    ;  parentNode  .  removeChild  (  this  )  ;  }    [METHOD]  remove  [TYPE]  void  [PARAMETER]  [CLASS]  Node    [TYPE]  Attributes  attributes  [TYPE]  List  childNodes  [TYPE]  String  attributeKey  attributeValue  baseUri  relUrl  [TYPE]  boolean  false  true  [TYPE]  Node  parentNode  
[REPLACE]  parentNode  .  removeChild  (  this  )  ;	[BUGGY]  parentNode  .  addChild  (  this  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  void  remove  (  )  {  Validate  .  notNull  (  parentNode  )  ;  [ATTENTION]  parentNode  .  addChild  (  this  )    ;  }    [METHOD]  remove  [TYPE]  void  [PARAMETER]  [CLASS]  Node    [TYPE]  Attributes  attributes  [TYPE]  List  childNodes  [TYPE]  String  attributeKey  attributeValue  baseUri  relUrl  [TYPE]  boolean  false  true  [TYPE]  Node  parentNode  
[ADD]  parentNode  .  removeChild  (  this  )  ;	[BUGGY]  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  void  remove  (  )  {  Validate  .  notNull  (  parentNode  )  ;  [ATTENTION]  }    [METHOD]  remove  [TYPE]  void  [PARAMETER]  [CLASS]  Node    [TYPE]  Attributes  attributes  [TYPE]  List  childNodes  [TYPE]  String  attributeKey  attributeValue  baseUri  relUrl  [TYPE]  boolean  false  true  [TYPE]  Node  parentNode  
[REPLACE]  Validate  .  notNull  (  in  )  ;	[BUGGY]  Validate  .  notNull  (  parentNode  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  void  replaceWith  (  Node  in  )  {  [ATTENTION]  Validate  .  notNull  (  parentNode  )    ;  Validate  .  notNull  (  parentNode  )  ;  parentNode  .  replaceChild  (  this  ,  in  )  ;  }    [METHOD]  replaceWith  [TYPE]  void  [PARAMETER]  Node  in  [CLASS]  Node    [TYPE]  Attributes  attributes  [TYPE]  List  childNodes  [TYPE]  String  attributeKey  attributeValue  baseUri  relUrl  [TYPE]  boolean  false  true  [TYPE]  Node  in  parentNode  
[REPLACE]  Validate  .  notNull  (  parentNode  )  ;	[BUGGY]  Validate  .  notNull  (  baseUri  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  void  replaceWith  (  Node  in  )  {  Validate  .  notNull  (  in  )  ;  [ATTENTION]  Validate  .  notNull  (  baseUri  )    ;  parentNode  .  replaceChild  (  this  ,  in  )  ;  }    [METHOD]  replaceWith  [TYPE]  void  [PARAMETER]  Node  in  [CLASS]  Node    [TYPE]  Attributes  attributes  [TYPE]  List  childNodes  [TYPE]  String  attributeKey  attributeValue  baseUri  relUrl  [TYPE]  boolean  false  true  [TYPE]  Node  in  parentNode  
[REPLACE]  parentNode  .  replaceChild  (  this,  in  )  ;	[BUGGY]  parentNode  .  replaceChild  (  this  ,  parentNode  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  void  replaceWith  (  Node  in  )  {  Validate  .  notNull  (  in  )  ;  Validate  .  notNull  (  parentNode  )  ;  [ATTENTION]  parentNode  .  replaceChild  (  this  ,  parentNode  )    ;  }    [METHOD]  replaceWith  [TYPE]  void  [PARAMETER]  Node  in  [CLASS]  Node    [TYPE]  Attributes  attributes  [TYPE]  List  childNodes  [TYPE]  String  attributeKey  attributeValue  baseUri  relUrl  [TYPE]  boolean  false  true  [TYPE]  Node  in  parentNode  
[ADD]  parentNode  .  replaceChild  (  this,  in  )  ;	[BUGGY]  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  void  replaceWith  (  Node  in  )  {  Validate  .  notNull  (  in  )  ;  Validate  .  notNull  (  parentNode  )  ;  [ATTENTION]  }    [METHOD]  replaceWith  [TYPE]  void  [PARAMETER]  Node  in  [CLASS]  Node    [TYPE]  Attributes  attributes  [TYPE]  List  childNodes  [TYPE]  String  attributeKey  attributeValue  baseUri  relUrl  [TYPE]  boolean  false  true  [TYPE]  Node  in  parentNode  
[REPLACE]  if  (  this  .  parentNode  !=  null  )  throw  new  NotImplementedException  ( "   ")  ;	[BUGGY]  if  (parentNode  =  =  null  )  throw  new  NotImplementedException  ( "   ")    ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  protected  void  setParentNode  (  Node  parentNode  )  {  [ATTENTION]  if  (  parentNode  =  =  null  )  throw  new  NotImplementedException  (   "   "  )  ;    this  .  parentNode  =  parentNode  ;  }    [METHOD]  setParentNode  [TYPE]  void  [PARAMETER]  Node  parentNode  [CLASS]  Node    [TYPE]  Attributes  attributes  [TYPE]  List  childNodes  [TYPE]  String  attributeKey  attributeValue  baseUri  relUrl  [TYPE]  boolean  false  true  [TYPE]  Node  in  parentNode  
[REPLACE]  throw  new  NotImplementedException  ( "   ")  ;	[BUGGY]  return  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  protected  void  setParentNode  (  Node  parentNode  )  {  if  (  this  .  parentNode  !  =  null  )  [ATTENTION]  return  ;  this  .  parentNode  =  parentNode  ;  }    [METHOD]  setParentNode  [TYPE]  void  [PARAMETER]  Node  parentNode  [CLASS]  Node    [TYPE]  Attributes  attributes  [TYPE]  List  childNodes  [TYPE]  String  attributeKey  attributeValue  baseUri  relUrl  [TYPE]  boolean  false  true  [TYPE]  Node  in  parentNode  
[REPLACE]  this  .  parentNode  =  parentNode;	[BUGGY]  this  .  parentNode  =    in  ;  [CE]  cannot  find  symbol  in  [CONTEXT]  protected  void  setParentNode  (  Node  parentNode  )  {  if  (  this  .  parentNode  !  =  null  )  throw  new  NotImplementedException  (   "Cannot  (  yet  )  move  nodes  in  tree "  )  ;  //  TODO:  remove  from  prev  node  children  [ATTENTION]  this  .  parentNode  =  in  ;  }    [METHOD]  setParentNode  [TYPE]  void  [PARAMETER]  Node  parentNode  [CLASS]  Node    [TYPE]  Attributes  attributes  [TYPE]  List  childNodes  [TYPE]  String  attributeKey  attributeValue  baseUri  relUrl  [TYPE]  boolean  false  true  [TYPE]  Node  in  parentNode  
[REPLACE]  Validate  .  isTrue  (  out  .  parentNode  ==  this  )  ;	[BUGGY]  Validate  .  isTrue  (  out  .  parentNode  !  =    this  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  protected  void  replaceChild  (  Node  out  ,  Node  in  )  {  [ATTENTION]  Validate  .  isTrue  (  out  .  parentNode!  =  this  )    ;  Validate  .  notNull  (  in  )  ;  if  (  in  .  parentNode  !  =  null  )  in  .  parentNode  .  removeChild  (  in  )  ;    Integer  index  =  indexInList  (  out  ,  childNodes  )  ;  childNodes  .  set  (  index  ,  in  )  ;  in  .  parentNode  =  this  ;  out  .  parentNode  =  null  ;  }    [METHOD]  replaceChild  [TYPE]  void  [PARAMETER]  Node  out  Node  in  [CLASS]  Node    [TYPE]  Attributes  attributes  [TYPE]  Integer  index  [TYPE]  List  childNodes  [TYPE]  String  attributeKey  attributeValue  baseUri  relUrl  [TYPE]  boolean  false  true  [TYPE]  Node  in  out  parentNode  
[ADD]  Validate  .  isTrue  (  out  .  parentNode  ==  this  )  ;  Validate  .  notNull  (  in  )  ;	[BUGGY]  Validate  .  notNull  (  in  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  protected  void  replaceChild  (  Node  out  ,  Node  in  )  {  [ATTENTION]  Validate  .  notNull  (  in  )    ;    if  (  in  .  parentNode  !  =  null  )  in  .  parentNode  .  removeChild  (  in  )  ;    Integer  index  =  indexInList  (  out  ,  childNodes  )  ;  childNodes  .  set  (  index  ,  in  )  ;  in  .  parentNode  =  this  ;  out  .  parentNode  =  null  ;  }    [METHOD]  replaceChild  [TYPE]  void  [PARAMETER]  Node  out  Node  in  [CLASS]  Node    [TYPE]  Attributes  attributes  [TYPE]  Integer  index  [TYPE]  List  childNodes  [TYPE]  String  attributeKey  attributeValue  baseUri  relUrl  [TYPE]  boolean  false  true  [TYPE]  Node  in  out  parentNode  
[REPLACE]  Validate  .  notNull  (  in  )  ;	[BUGGY]  Validate  .  notNull  (  index  )  ;  [CE]  cannot  find  symbol  index  [CONTEXT]  protected  void  replaceChild  (  Node  out  ,  Node  in  )  {  Validate  .  isTrue  (  out  .  parentNode  =  =  this  )  ;  [ATTENTION]  Validate  .  notNull  (  index  )    ;  if  (  in  .  parentNode  !  =  null  )  in  .  parentNode  .  removeChild  (  in  )  ;    Integer  index  =  indexInList  (  out  ,  childNodes  )  ;  childNodes  .  set  (  index  ,  in  )  ;  in  .  parentNode  =  this  ;  out  .  parentNode  =  null  ;  }    [METHOD]  replaceChild  [TYPE]  void  [PARAMETER]  Node  out  Node  in  [CLASS]  Node    [TYPE]  Attributes  attributes  [TYPE]  Integer  index  [TYPE]  List  childNodes  [TYPE]  String  attributeKey  attributeValue  baseUri  relUrl  [TYPE]  boolean  false  true  [TYPE]  Node  in  out  parentNode  
[REPLACE]  if  (  in  .  parentNode  !=  null  )  in  .  parentNode  .  removeChild  (  in  )  ;	[BUGGY]  if  (  in  .  parentNode  =  =  this  )  in  .  parentNode  .  removeChild  (  in  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  protected  void  replaceChild  (  Node  out  ,  Node  in  )  {  Validate  .  isTrue  (  out  .  parentNode  =  =  this  )  ;  Validate  .  notNull  (  in  )  ;  [ATTENTION]  if  (  in  .  parentNode  =  =  this  )  in  .  parentNode  .  removeChild  (  in  )    ;    Integer  index  =  indexInList  (  out  ,  childNodes  )  ;  childNodes  .  set  (  index  ,  in  )  ;  in  .  parentNode  =  this  ;  out  .  parentNode  =  null  ;  }    [METHOD]  replaceChild  [TYPE]  void  [PARAMETER]  Node  out  Node  in  [CLASS]  Node    [TYPE]  Attributes  attributes  [TYPE]  Integer  index  [TYPE]  List  childNodes  [TYPE]  String  attributeKey  attributeValue  baseUri  relUrl  [TYPE]  boolean  false  true  [TYPE]  Node  in  out  parentNode  
[REPLACE]  in  .  parentNode  .  removeChild  (  in  )  ;	[BUGGY]  in  .  parentNode  .  removeChild  (  parentNode  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  protected  void  replaceChild  (  Node  out  ,  Node  in  )  {  Validate  .  isTrue  (  out  .  parentNode  =  =  this  )  ;  Validate  .  notNull  (  in  )  ;  if  (  in  .  parentNode  !  =  null  )  [ATTENTION]  in  .  parentNode  .  removeChild  (  parentNode  )    ;    Integer  index  =  indexInList  (  out  ,  childNodes  )  ;  childNodes  .  set  (  index  ,  in  )  ;  in  .  parentNode  =  this  ;  out  .  parentNode  =  null  ;  }    [METHOD]  replaceChild  [TYPE]  void  [PARAMETER]  Node  out  Node  in  [CLASS]  Node    [TYPE]  Attributes  attributes  [TYPE]  Integer  index  [TYPE]  List  childNodes  [TYPE]  String  attributeKey  attributeValue  baseUri  relUrl  [TYPE]  boolean  false  true  [TYPE]  Node  in  out  parentNode  
[ADD]  in  .  parentNode  .  removeChild  (  in  )  ;	[BUGGY]  [CE]  not  a  statement  [CONTEXT]  protected  void  replaceChild  (  Node  out  ,  Node  in  )  {  Validate  .  isTrue  (  out  .  parentNode  =  =  this  )  ;  Validate  .  notNull  (  in  )  ;  if  (  in  .  parentNode  !  =  null  )  [ATTENTION]    Integer  index  =  indexInList  (  out  ,  childNodes  )  ;  childNodes  .  set  (  index  ,  in  )  ;  in  .  parentNode  =  this  ;  out  .  parentNode  =  null  ;  }    [METHOD]  replaceChild  [TYPE]  void  [PARAMETER]  Node  out  Node  in  [CLASS]  Node    [TYPE]  Attributes  attributes  [TYPE]  Integer  index  [TYPE]  List  childNodes  [TYPE]  String  attributeKey  attributeValue  baseUri  relUrl  [TYPE]  boolean  false  true  [TYPE]  Node  in  out  parentNode  
[REPLACE]  Integer  index  =  indexInList  (  out,  childNodes  )  ;	[BUGGY]  Integer  index  =  indexInList  (  parentNode  ,  childNodes  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  protected  void  replaceChild  (  Node  out  ,  Node  in  )  {  Validate  .  isTrue  (  out  .  parentNode  =  =  this  )  ;  Validate  .  notNull  (  in  )  ;  if  (  in  .  parentNode  !  =  null  )  in  .  parentNode  .  removeChild  (  in  )  ;    [ATTENTION]  Integer  index  =  indexInList  (  parentNode  ,  childNodes  )    ;  childNodes  .  set  (  index  ,  in  )  ;  in  .  parentNode  =  this  ;  out  .  parentNode  =  null  ;  }    [METHOD]  replaceChild  [TYPE]  void  [PARAMETER]  Node  out  Node  in  [CLASS]  Node    [TYPE]  Attributes  attributes  [TYPE]  Integer  index  [TYPE]  List  childNodes  [TYPE]  String  attributeKey  attributeValue  baseUri  relUrl  [TYPE]  boolean  false  true  [TYPE]  Node  in  out  parentNode  
[REPLACE]  childNodes  .  set  (  index,  in  )  ;	[BUGGY]  childNodes  .  set  (  parentNodedex  ,  in  )  ;  [CE]  cannot  find  symbol  parentNodedex  [CONTEXT]  protected  void  replaceChild  (  Node  out  ,  Node  in  )  {  Validate  .  isTrue  (  out  .  parentNode  =  =  this  )  ;  Validate  .  notNull  (  in  )  ;  if  (  in  .  parentNode  !  =  null  )  in  .  parentNode  .  removeChild  (  in  )  ;    Integer  index  =  indexInList  (  out  ,  childNodes  )  ;  [ATTENTION]  childNodes  .  set  (  parentNodedex  ,  in  )    ;  in  .  parentNode  =  this  ;  out  .  parentNode  =  null  ;  }    [METHOD]  replaceChild  [TYPE]  void  [PARAMETER]  Node  out  Node  in  [CLASS]  Node    [TYPE]  Attributes  attributes  [TYPE]  Integer  index  [TYPE]  List  childNodes  [TYPE]  String  attributeKey  attributeValue  baseUri  relUrl  [TYPE]  boolean  false  true  [TYPE]  Node  in  out  parentNode  
[REMOVE]  	[BUGGY]  return  siblings  .  get  (  index-1  )  ;  [CE]  cannot  return  a  value  from  method  whose  result  type  is  void  [CONTEXT]  protected  void  replaceChild  (  Node  out  ,  Node  in  )  {  Validate  .  isTrue  (  out  .  parentNode  =  =  this  )  ;  Validate  .  notNull  (  in  )  ;  if  (  in  .  parentNode  !  =  null  )  in  .  parentNode  .  removeChild  (  in  )  ;    Integer  index  =  indexInList  (  out  ,  childNodes  )  ;  [ATTENTION]  childNodes  .  set  (  index  ,  in  )  ;    return  siblings  .  get  (  index-1  )    ;  in  .  parentNode  =  this  ;  out  .  parentNode  =  null  ;      [METHOD]  replaceChild  [TYPE]  void  [PARAMETER]  Node  out  Node  in  [CLASS]  Node    [TYPE]  Attributes  attributes  [TYPE]  Integer  index  [TYPE]  List  childNodes  [TYPE]  String  attributeKey  attributeValue  baseUri  relUrl  [TYPE]  boolean  false  true  [TYPE]  Node  in  out  parentNode  
[REPLACE]  in  .  parentNode  =  this;	[BUGGY]  in  .  parentNode  =    this  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  protected  void  replaceChild  (  Node  out  ,  Node  in  )  {  Validate  .  isTrue  (  out  .  parentNode  =  =  this  )  ;  Validate  .  notNull  (  in  )  ;  if  (  in  .  parentNode  !  =  null  )  in  .  parentNode  .  removeChild  (  in  )  ;    Integer  index  =  indexInList  (  out  ,  childNodes  )  ;  childNodes  .  set  (  index  ,  in  )  ;  [ATTENTION]  in  .  parentNode  =  this  ;  out  .  parentNode  =  null  ;  }    [METHOD]  replaceChild  [TYPE]  void  [PARAMETER]  Node  out  Node  in  [CLASS]  Node    [TYPE]  Attributes  attributes  [TYPE]  Integer  index  [TYPE]  List  childNodes  [TYPE]  String  attributeKey  attributeValue  baseUri  relUrl  [TYPE]  boolean  false  true  [TYPE]  Node  in  out  parentNode  
[ADD]  in  .  parentNode  =  this;  out  .  parentNode  =  null;	[BUGGY]  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  protected  void  replaceChild  (  Node  out  ,  Node  in  )  {  Validate  .  isTrue  (  out  .  parentNode  =  =  this  )  ;  Validate  .  notNull  (  in  )  ;  if  (  in  .  parentNode  !  =  null  )  in  .  parentNode  .  removeChild  (  in  )  ;    Integer  index  =  indexInList  (  out  ,  childNodes  )  ;  childNodes  .  set  (  index  ,  in  )  ;  [ATTENTION]    }    [METHOD]  replaceChild  [TYPE]  void  [PARAMETER]  Node  out  Node  in  [CLASS]  Node    [TYPE]  Attributes  attributes  [TYPE]  Integer  index  [TYPE]  List  childNodes  [TYPE]  String  attributeKey  attributeValue  baseUri  relUrl  [TYPE]  boolean  false  true  [TYPE]  Node  in  out  parentNode  
[REPLACE]  out  .  parentNode  =  null;	[BUGGY]  out  .  parentNode  =  this  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  protected  void  replaceChild  (  Node  out  ,  Node  in  )  {  Validate  .  isTrue  (  out  .  parentNode  =  =  this  )  ;  Validate  .  notNull  (  in  )  ;  if  (  in  .  parentNode  !  =  null  )  in  .  parentNode  .  removeChild  (  in  )  ;    Integer  index  =  indexInList  (  out  ,  childNodes  )  ;  childNodes  .  set  (  index  ,  in  )  ;  in  .  parentNode  =  this  ;  [ATTENTION]  out  .  parentNode  =  this  ;  }    [METHOD]  replaceChild  [TYPE]  void  [PARAMETER]  Node  out  Node  in  [CLASS]  Node    [TYPE]  Attributes  attributes  [TYPE]  Integer  index  [TYPE]  List  childNodes  [TYPE]  String  attributeKey  attributeValue  baseUri  relUrl  [TYPE]  boolean  false  true  [TYPE]  Node  in  out  parentNode  
[REPLACE]  Validate  .  isTrue  (  out  .  parentNode  ==  this  )  ;	[BUGGY]  Validate  .  isTrue  (  out  .  parentNode  &&  this  )  ;  [CE]  bad  operand  types  for  binary  operator  '&&'  [CONTEXT]  protected  void  removeChild  (  Node  out  )  {  [ATTENTION]  Validate  .  isTrue  (  out  .  parentNode&&this  )    ;  int  index  =  indexInList  (  out  ,  childNodes  )  ;  childNodes  .  remove  (  index  )  ;  out  .  parentNode  =  null  ;  }    [METHOD]  removeChild  [TYPE]  void  [PARAMETER]  Node  out  [CLASS]  Node    [TYPE]  Attributes  attributes  [TYPE]  List  childNodes  [TYPE]  String  attributeKey  attributeValue  baseUri  relUrl  [TYPE]  boolean  false  true  [TYPE]  int  index  [TYPE]  Node  in  out  parentNode  
[ADD]  Validate  .  isTrue  (  out  .  parentNode  ==  this  )  ;	[BUGGY]  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  protected  void  removeChild  (  Node  out  )  {  [ATTENTION]  int  index  =  indexInList  (  out  ,  childNodes  )  ;  childNodes  .  remove  (  index  )  ;  out  .  parentNode  =  null  ;  }    [METHOD]  removeChild  [TYPE]  void  [PARAMETER]  Node  out  [CLASS]  Node    [TYPE]  Attributes  attributes  [TYPE]  List  childNodes  [TYPE]  String  attributeKey  attributeValue  baseUri  relUrl  [TYPE]  boolean  false  true  [TYPE]  int  index  [TYPE]  Node  in  out  parentNode  
[REPLACE]  int  index  =  indexInList  (  out,  childNodes  )  ;	[BUGGY]  int  index  =  indexInList  (  parentNode  ,  childNodes  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  protected  void  removeChild  (  Node  out  )  {  Validate  .  isTrue  (  out  .  parentNode  =  =  this  )  ;  [ATTENTION]  int  index  =  indexInList  (  parentNode  ,  childNodes  )    ;  childNodes  .  remove  (  index  )  ;  out  .  parentNode  =  null  ;  }    [METHOD]  removeChild  [TYPE]  void  [PARAMETER]  Node  out  [CLASS]  Node    [TYPE]  Attributes  attributes  [TYPE]  List  childNodes  [TYPE]  String  attributeKey  attributeValue  baseUri  relUrl  [TYPE]  boolean  false  true  [TYPE]  int  index  [TYPE]  Node  in  out  parentNode  
[REPLACE]  childNodes  .  remove  (  index  )  ;	[BUGGY]  childNodes  .  hashCode  (  )    ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  protected  void  removeChild  (  Node  out  )  {  Validate  .  isTrue  (  out  .  parentNode  =  =  this  )  ;  int  index  =  indexInList  (  out  ,  childNodes  )  ;  [ATTENTION]  childNodes  .  hashCode  (  )  ;  out  .  parentNode  =  null  ;  }    [METHOD]  removeChild  [TYPE]  void  [PARAMETER]  Node  out  [CLASS]  Node    [TYPE]  Attributes  attributes  [TYPE]  List  childNodes  [TYPE]  String  attributeKey  attributeValue  baseUri  relUrl  [TYPE]  boolean  false  true  [TYPE]  int  index  [TYPE]  Node  in  out  parentNode  
[REPLACE]  out  .  parentNode  =  null;	[BUGGY]  out  .  parentNode  =  this  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  protected  void  removeChild  (  Node  out  )  {  Validate  .  isTrue  (  out  .  parentNode  =  =  this  )  ;  int  index  =  indexInList  (  out  ,  childNodes  )  ;  childNodes  .  remove  (  index  )  ;  [ATTENTION]  out  .  parentNode  =  this  ;  }    [METHOD]  removeChild  [TYPE]  void  [PARAMETER]  Node  out  [CLASS]  Node    [TYPE]  Attributes  attributes  [TYPE]  List  childNodes  [TYPE]  String  attributeKey  attributeValue  baseUri  relUrl  [TYPE]  boolean  false  true  [TYPE]  int  index  [TYPE]  Node  in  out  parentNode  
[ADD]  out  .  parentNode  =  null;	[BUGGY]  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  protected  void  removeChild  (  Node  out  )  {  Validate  .  isTrue  (  out  .  parentNode  =  =  this  )  ;  int  index  =  indexInList  (  out  ,  childNodes  )  ;  childNodes  .  remove  (  index  )  ;  [ATTENTION]  }    [METHOD]  removeChild  [TYPE]  void  [PARAMETER]  Node  out  [CLASS]  Node    [TYPE]  Attributes  attributes  [TYPE]  List  childNodes  [TYPE]  String  attributeKey  attributeValue  baseUri  relUrl  [TYPE]  boolean  false  true  [TYPE]  int  index  [TYPE]  Node  in  out  parentNode  
[REPLACE]  Validate  .  notNull  (  in  )  ;	[BUGGY]  Validate  .  notNull  (  parentNode  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  protected  void  addChild  (  Node  in  )  {  [ATTENTION]  Validate  .  notNull  (  parentNode  )    ;  if  (  in  .  parentNode  !  =  null  )  in  .  parentNode  .  removeChild  (  in  )  ;    childNodes  .  add  (  in  )  ;  in  .  parentNode  =  this  ;  }    [METHOD]  addChild  [TYPE]  void  [PARAMETER]  Node  in  [CLASS]  Node    [TYPE]  Attributes  attributes  [TYPE]  List  childNodes  [TYPE]  String  attributeKey  attributeValue  baseUri  relUrl  [TYPE]  boolean  false  true  [TYPE]  Node  in  out  parentNode  
[REPLACE]  if  (  in  .  parentNode  !=  null  )  in  .  parentNode  .  removeChild  (  in  )  ;	[BUGGY]  if  (  in  .  parentNode  =  =  null  )  in  .  parentNode  .  removeChild  (  in  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  protected  void  addChild  (  Node  in  )  {  Validate  .  notNull  (  in  )  ;  [ATTENTION]  if  (  in  .  parentNode  =  =  null  )  in  .  parentNode  .  removeChild  (  in  )    ;    childNodes  .  add  (  in  )  ;  in  .  parentNode  =  this  ;  }    [METHOD]  addChild  [TYPE]  void  [PARAMETER]  Node  in  [CLASS]  Node    [TYPE]  Attributes  attributes  [TYPE]  List  childNodes  [TYPE]  String  attributeKey  attributeValue  baseUri  relUrl  [TYPE]  boolean  false  true  [TYPE]  Node  in  out  parentNode  
[ADD]  if  (  in  .  parentNode  !=  null  )  in  .  parentNode  .  removeChild  (  in  )  ;  childNodes  .  add  (  in  )  ;  in  .  parentNode  =  this;	[BUGGY]  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  protected  void  addChild  (  Node  in  )  {  Validate  .  notNull  (  in  )  ;  [ATTENTION]      }    [METHOD]  addChild  [TYPE]  void  [PARAMETER]  Node  in  [CLASS]  Node    [TYPE]  Attributes  attributes  [TYPE]  List  childNodes  [TYPE]  String  attributeKey  attributeValue  baseUri  relUrl  [TYPE]  boolean  false  true  [TYPE]  Node  in  out  parentNode  
[REPLACE]  in  .  parentNode  .  removeChild  (  in  )  ;	[BUGGY]  in  .  parentNode  .  addChild  (  parentNode  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  protected  void  addChild  (  Node  in  )  {  Validate  .  notNull  (  in  )  ;  if  (  in  .  parentNode  !  =  null  )  [ATTENTION]  in  .  parentNode  .  addChild  (  parentNode  )    ;    childNodes  .  add  (  in  )  ;  in  .  parentNode  =  this  ;  }    [METHOD]  addChild  [TYPE]  void  [PARAMETER]  Node  in  [CLASS]  Node    [TYPE]  Attributes  attributes  [TYPE]  List  childNodes  [TYPE]  String  attributeKey  attributeValue  baseUri  relUrl  [TYPE]  boolean  false  true  [TYPE]  Node  in  out  parentNode  
[REMOVE]  	[BUGGY]  N  node  =  nodes  .  get  (  i  )  ;  [CE]  cannot  find  symbol  [CONTEXT]  protected  void  addChild  (  Node  in  )  {  Validate  .  notNull  (  in  )  ;  if  (  in  .  parentNode  !  =  null  )  [ATTENTION]  in  .  parentNode  .  removeChild  (  in  )  ;    N  node  =  nodes  .  get  (  i  )    ;  childNodes  .  add  (  in  )  ;  in  .  parentNode  =  this  ;      [METHOD]  addChild  [TYPE]  void  [PARAMETER]  Node  in  [CLASS]  Node    [TYPE]  Attributes  attributes  [TYPE]  List  childNodes  [TYPE]  String  attributeKey  attributeValue  baseUri  relUrl  [TYPE]  boolean  false  true  [TYPE]  Node  in  out  parentNode  
[REPLACE]  childNodes  .  add  (  in  )  ;	[BUGGY]  childNodes  .  add  (  parentNode  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  protected  void  addChild  (  Node  in  )  {  Validate  .  notNull  (  in  )  ;  if  (  in  .  parentNode  !  =  null  )  in  .  parentNode  .  removeChild  (  in  )  ;    [ATTENTION]  childNodes  .  add  (  parentNode  )    ;  in  .  parentNode  =  this  ;  }    [METHOD]  addChild  [TYPE]  void  [PARAMETER]  Node  in  [CLASS]  Node    [TYPE]  Attributes  attributes  [TYPE]  List  childNodes  [TYPE]  String  attributeKey  attributeValue  baseUri  relUrl  [TYPE]  boolean  false  true  [TYPE]  Node  in  out  parentNode  
[REMOVE]  	[BUGGY]  return  siblings  .  get  (  index-1  )  ;  [CE]  cannot  return  a  value  from  method  whose  result  type  is  void  [CONTEXT]  protected  void  addChild  (  Node  in  )  {  Validate  .  notNull  (  in  )  ;  if  (  in  .  parentNode  !  =  null  )  in  .  parentNode  .  removeChild  (  in  )  ;    [ATTENTION]  childNodes  .  add  (  in  )  ;    return  siblings  .  get  (  index-1  )    ;  in  .  parentNode  =  this  ;      [METHOD]  addChild  [TYPE]  void  [PARAMETER]  Node  in  [CLASS]  Node    [TYPE]  Attributes  attributes  [TYPE]  List  childNodes  [TYPE]  String  attributeKey  attributeValue  baseUri  relUrl  [TYPE]  boolean  false  true  [TYPE]  Node  in  out  parentNode  
[REPLACE]  in  .  parentNode  =  this;	[BUGGY]  in  .  parentNode  =    this  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  protected  void  addChild  (  Node  in  )  {  Validate  .  notNull  (  in  )  ;  if  (  in  .  parentNode  !  =  null  )  in  .  parentNode  .  removeChild  (  in  )  ;    childNodes  .  add  (  in  )  ;  [ATTENTION]  in  .  parentNode  =  this  ;  }    [METHOD]  addChild  [TYPE]  void  [PARAMETER]  Node  in  [CLASS]  Node    [TYPE]  Attributes  attributes  [TYPE]  List  childNodes  [TYPE]  String  attributeKey  attributeValue  baseUri  relUrl  [TYPE]  boolean  false  true  [TYPE]  Node  in  out  parentNode  
[ADD]  in  .  parentNode  =  this;	[BUGGY]  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  protected  void  addChild  (  Node  in  )  {  Validate  .  notNull  (  in  )  ;  if  (  in  .  parentNode  !  =  null  )  in  .  parentNode  .  removeChild  (  in  )  ;    childNodes  .  add  (  in  )  ;  [ATTENTION]  }    [METHOD]  addChild  [TYPE]  void  [PARAMETER]  Node  in  [CLASS]  Node    [TYPE]  Attributes  attributes  [TYPE]  List  childNodes  [TYPE]  String  attributeKey  attributeValue  baseUri  relUrl  [TYPE]  boolean  false  true  [TYPE]  Node  in  out  parentNode  
[REPLACE]  if  (  parentNode  ==  null  )  return  0;	[BUGGY]  if  (  parentNode  !  =  null  )  return  0  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  protected  int  nodeDepth  (  )  {  [ATTENTION]  if  (  parentNode  !  =  null  )  return  0  ;    else  return  parentNode  .  nodeDepth  (  )  +  1  ;  }    [METHOD]  nodeDepth  [TYPE]  int  [PARAMETER]  [CLASS]  Node    [TYPE]  Attributes  attributes  [TYPE]  List  childNodes  [TYPE]  String  attributeKey  attributeValue  baseUri  relUrl  [TYPE]  boolean  false  true  [TYPE]  Node  in  out  parentNode  
[REPLACE]  return  parentNode  .  nodeDepth  (  )  +  1;	[BUGGY]  return  parentNode  .  childNode  (  )  +this  ;  [CE]  method  childNode  in  class  Node  cannot  be  applied  to  given  types  ;  [CONTEXT]  protected  int  nodeDepth  (  )  {  if  (  parentNode  =  =  null  )  return  0  ;  else  [ATTENTION]  return  parentNode  .  childNode  (  )  +this  ;  }    [METHOD]  nodeDepth  [TYPE]  int  [PARAMETER]  [CLASS]  Node    [TYPE]  Attributes  attributes  [TYPE]  List  childNodes  [TYPE]  String  attributeKey  attributeValue  baseUri  relUrl  [TYPE]  boolean  false  true  [TYPE]  Node  in  out  parentNode  
[REPLACE]  return  0;	[BUGGY]  return  i  ;  [CE]  cannot  find  symbol  i  [CONTEXT]  protected  int  nodeDepth  (  )  {  if  (  parentNode  =  =  null  )  [ATTENTION]  return  i  ;  else  return  parentNode  .  nodeDepth  (  )  +  1  ;  }    [METHOD]  nodeDepth  [TYPE]  int  [PARAMETER]  [CLASS]  Node    [TYPE]  Attributes  attributes  [TYPE]  List  childNodes  [TYPE]  String  attributeKey  attributeValue  baseUri  relUrl  [TYPE]  boolean  false  true  [TYPE]  Node  in  out  parentNode  
[REPLACE]  return  0;	[BUGGY]  return  0  /  3  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  protected  int  nodeDepth  (  )  {  if  (  parentNode  =  =  null  )  [ATTENTION]  return  0  /  3  ;  else  return  parentNode  .  nodeDepth  (  )  +  1  ;  }    [METHOD]  nodeDepth  [TYPE]  int  [PARAMETER]  [CLASS]  Node    [TYPE]  Attributes  attributes  [TYPE]  List  childNodes  [TYPE]  String  attributeKey  attributeValue  baseUri  relUrl  [TYPE]  boolean  false  true  [TYPE]  Node  in  out  parentNode  
[REPLACE]  return  parentNode  .  nodeDepth  (  )  +  1;	[BUGGY]  return  parentNode  .  childNode  (  )  +  1  ;  [CE]  method  childNode  in  class  Node  cannot  be  applied  to  given  types  ;  [CONTEXT]  protected  int  nodeDepth  (  )  {  if  (  parentNode  =  =  null  )  return  0  ;  else  [ATTENTION]  return  parentNode  .  childNode  (  )  +  1  ;  }    [METHOD]  nodeDepth  [TYPE]  int  [PARAMETER]  [CLASS]  Node    [TYPE]  Attributes  attributes  [TYPE]  List  childNodes  [TYPE]  String  attributeKey  attributeValue  baseUri  relUrl  [TYPE]  boolean  false  true  [TYPE]  Node  in  out  parentNode  
[REPLACE]  return  parent  (  )    .  childNodes  (  )  ;	[BUGGY]  return  siblings  .  get  (  index-1  )  ;  [CE]  cannot  find  symbol  index  [CONTEXT]  public  List<Node>  siblingNodes  (  )  {  [ATTENTION]  return  siblings  .  get  (  index-1  )    ;  }    [METHOD]  siblingNodes  [TYPE]  List  [PARAMETER]  [CLASS]  Node    [TYPE]  Attributes  attributes  [TYPE]  List  childNodes  [TYPE]  String  attributeKey  attributeValue  baseUri  relUrl  [TYPE]  boolean  false  true  [TYPE]  Node  in  out  parentNode  
[REPLACE]  List<Node>  siblings  =  parentNode  .  childNodes;	[BUGGY]  int  index  =  indexInList  (  out  ,  childNodes  )  ;  [CE]  cannot  find  symbol  out  [CONTEXT]  public  Node  nextSibling  (  )  {  [ATTENTION]  int  index  =  indexInList  (  out  ,  childNodes  )    ;  Integer  index  =  indexInList  (  this  ,  siblings  )  ;  Validate  .  notNull  (  index  )  ;  if  (  siblings  .  size  (  )  >  index+1  )  return  siblings  .  get  (  index+1  )  ;  else  return  null  ;  }    [METHOD]  nextSibling  [TYPE]  Node  [PARAMETER]  [CLASS]  Node    [TYPE]  Attributes  attributes  [TYPE]  Integer  index  [TYPE]  List  childNodes  siblings  [TYPE]  String  attributeKey  attributeValue  baseUri  relUrl  [TYPE]  boolean  false  true  [TYPE]  Node  in  out  parentNode  
[REPLACE]  Integer  index  =  indexInList  (  this,  siblings  )  ;	[BUGGY]  Integer  index  =  indexInList  (  this  ,  null  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  Node  nextSibling  (  )  {  List<Node>  siblings  =  parentNode  .  childNodes  ;  [ATTENTION]  Integer  index  =  indexInList  (  this  ,  null  )    ;  Validate  .  notNull  (  index  )  ;  if  (  siblings  .  size  (  )  >  index+1  )  return  siblings  .  get  (  index+1  )  ;  else  return  null  ;  }    [METHOD]  nextSibling  [TYPE]  Node  [PARAMETER]  [CLASS]  Node    [TYPE]  Attributes  attributes  [TYPE]  Integer  index  [TYPE]  List  childNodes  siblings  [TYPE]  String  attributeKey  attributeValue  baseUri  relUrl  [TYPE]  boolean  false  true  [TYPE]  Node  in  out  parentNode  
[ADD]  Integer  index  =  indexInList  (  this,  siblings  )  ;  Validate  .  notNull  (  index  )  ;	[BUGGY]  [CE]  cannot  find  symbol  index  [CONTEXT]  public  Node  nextSibling  (  )  {  List<Node>  siblings  =  parentNode  .  childNodes  ;  [ATTENTION]    if  (  siblings  .  size  (  )  >  index+1  )  return  siblings  .  get  (  index+1  )  ;  else  return  null  ;  }    [METHOD]  nextSibling  [TYPE]  Node  [PARAMETER]  [CLASS]  Node    [TYPE]  Attributes  attributes  [TYPE]  Integer  index  [TYPE]  List  childNodes  siblings  [TYPE]  String  attributeKey  attributeValue  baseUri  relUrl  [TYPE]  boolean  false  true  [TYPE]  Node  in  out  parentNode  
[REPLACE]  Validate  .  notNull  (  index  )  ;	[BUGGY]  Validate  .  notEmpty  (  relUrl  )    ;  [CE]  cannot  find  symbol  relUrl  [CONTEXT]  public  Node  nextSibling  (  )  {  List<Node>  siblings  =  parentNode  .  childNodes  ;  Integer  index  =  indexInList  (  this  ,  siblings  )  ;  [ATTENTION]  Validate  .  notEmpty  (  relUrl  )  ;  if  (  siblings  .  size  (  )  >  index+1  )  return  siblings  .  get  (  index+1  )  ;  else  return  null  ;  }    [METHOD]  nextSibling  [TYPE]  Node  [PARAMETER]  [CLASS]  Node    [TYPE]  Attributes  attributes  [TYPE]  Integer  index  [TYPE]  List  childNodes  siblings  [TYPE]  String  attributeKey  attributeValue  baseUri  relUrl  [TYPE]  boolean  false  true  [TYPE]  Node  in  out  parentNode  
[REPLACE]  if  (  siblings  .  size  (  )  >  index+1  )  return  siblings  .  get  (  index+1  )  ;	[BUGGY]  if  (  siblings  .  size  (  )  *  0  .  5  >  index+1  )  return  siblings  .  get  (  index+1  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  Node  nextSibling  (  )  {  List<Node>  siblings  =  parentNode  .  childNodes  ;  Integer  index  =  indexInList  (  this  ,  siblings  )  ;  Validate  .  notNull  (  index  )  ;  [ATTENTION]  if  (  siblings  .  size  (  )  *0  .  5>  index+1  )  return  siblings  .  get  (  index+1  )    ;    else  return  null  ;  }    [METHOD]  nextSibling  [TYPE]  Node  [PARAMETER]  [CLASS]  Node    [TYPE]  Attributes  attributes  [TYPE]  Integer  index  [TYPE]  List  childNodes  siblings  [TYPE]  String  attributeKey  attributeValue  baseUri  relUrl  [TYPE]  boolean  false  true  [TYPE]  Node  in  out  parentNode  
[REPLACE]  return  null;	[BUGGY]  return  true  ;  [CE]  incompatible  types  [CONTEXT]  public  Node  nextSibling  (  )  {  List<Node>  siblings  =  parentNode  .  childNodes  ;  Integer  index  =  indexInList  (  this  ,  siblings  )  ;  Validate  .  notNull  (  index  )  ;  if  (  siblings  .  size  (  )  >  index+1  )  return  siblings  .  get  (  index+1  )  ;  else  [ATTENTION]  return  true  ;  }    [METHOD]  nextSibling  [TYPE]  Node  [PARAMETER]  [CLASS]  Node    [TYPE]  Attributes  attributes  [TYPE]  Integer  index  [TYPE]  List  childNodes  siblings  [TYPE]  String  attributeKey  attributeValue  baseUri  relUrl  [TYPE]  boolean  false  true  [TYPE]  Node  in  out  parentNode  
[REPLACE]  return  siblings  .  get  (  index+1  )  ;	[BUGGY]  return  siblings  .  size  (  index+1  )  ;  [CE]  no  suitable  method  found  for  size(int)  [CONTEXT]  public  Node  nextSibling  (  )  {  List<Node>  siblings  =  parentNode  .  childNodes  ;  Integer  index  =  indexInList  (  this  ,  siblings  )  ;  Validate  .  notNull  (  index  )  ;  if  (  siblings  .  size  (  )  >  index+1  )  [ATTENTION]  return  siblings  .  size  (  index+1  )    ;  else  return  null  ;  }    [METHOD]  nextSibling  [TYPE]  Node  [PARAMETER]  [CLASS]  Node    [TYPE]  Attributes  attributes  [TYPE]  Integer  index  [TYPE]  List  childNodes  siblings  [TYPE]  String  attributeKey  attributeValue  baseUri  relUrl  [TYPE]  boolean  false  true  [TYPE]  Node  in  out  parentNode  
[REPLACE]  return  siblings  .  get  (  index+1  )  ;	[BUGGY]  return  siblings  .  get  (  baseUri  )    ;  [CE]  method  get  in  interface  List<E>  cannot  be  applied  to  given  types  ;  [CONTEXT]  public  Node  nextSibling  (  )  {  List<Node>  siblings  =  parentNode  .  childNodes  ;  Integer  index  =  indexInList  (  this  ,  siblings  )  ;  Validate  .  notNull  (  index  )  ;  if  (  siblings  .  size  (  )  >  index+1  )  [ATTENTION]  return  siblings  .  get  (  baseUri  )  ;  else  return  null  ;  }    [METHOD]  nextSibling  [TYPE]  Node  [PARAMETER]  [CLASS]  Node    [TYPE]  Attributes  attributes  [TYPE]  Integer  index  [TYPE]  List  childNodes  siblings  [TYPE]  String  attributeKey  attributeValue  baseUri  relUrl  [TYPE]  boolean  false  true  [TYPE]  Node  in  out  parentNode  
[REPLACE]  return  null;	[BUGGY]  return  this  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  Node  nextSibling  (  )  {  List<Node>  siblings  =  parentNode  .  childNodes  ;  Integer  index  =  indexInList  (  this  ,  siblings  )  ;  Validate  .  notNull  (  index  )  ;  if  (  siblings  .  size  (  )  >  index+1  )  return  siblings  .  get  (  index+1  )  ;  else  [ATTENTION]  return  this  ;  }    [METHOD]  nextSibling  [TYPE]  Node  [PARAMETER]  [CLASS]  Node    [TYPE]  Attributes  attributes  [TYPE]  Integer  index  [TYPE]  List  childNodes  siblings  [TYPE]  String  attributeKey  attributeValue  baseUri  relUrl  [TYPE]  boolean  false  true  [TYPE]  Node  in  out  parentNode  
[REPLACE]  List<Node>  siblings  =  parentNode  .  childNodes;	[BUGGY]  int  index  =  indexInList  (  out  ,  childNodes  )  ;  [CE]  cannot  find  symbol  out  [CONTEXT]  public  Node  previousSibling  (  )  {  [ATTENTION]  int  index  =  indexInList  (  out  ,  childNodes  )    ;  Integer  index  =  indexInList  (  this  ,  siblings  )  ;  Validate  .  notNull  (  index  )  ;  if  (  index  >  0  )  return  siblings  .  get  (  index-1  )  ;  else  return  null  ;  }    [METHOD]  previousSibling  [TYPE]  Node  [PARAMETER]  [CLASS]  Node    [TYPE]  Attributes  attributes  [TYPE]  Integer  index  [TYPE]  List  childNodes  siblings  [TYPE]  String  attributeKey  attributeValue  baseUri  relUrl  [TYPE]  boolean  false  true  [TYPE]  Node  in  out  parentNode  
[REPLACE]  Integer  index  =  indexInList  (  this,  siblings  )  ;	[BUGGY]  Integer  index  =  indexInList  (  this  ,  false  )  ;  [CE]  method  indexInList  in  class  Node  cannot  be  applied  to  given  types  ;  [CONTEXT]  public  Node  previousSibling  (  )  {  List<Node>  siblings  =  parentNode  .  childNodes  ;  [ATTENTION]  Integer  index  =  indexInList  (  this  ,  false  )    ;  Validate  .  notNull  (  index  )  ;  if  (  index  >  0  )  return  siblings  .  get  (  index-1  )  ;  else  return  null  ;  }    [METHOD]  previousSibling  [TYPE]  Node  [PARAMETER]  [CLASS]  Node    [TYPE]  Attributes  attributes  [TYPE]  Integer  index  [TYPE]  List  childNodes  siblings  [TYPE]  String  attributeKey  attributeValue  baseUri  relUrl  [TYPE]  boolean  false  true  [TYPE]  Node  in  out  parentNode  
[REPLACE]  Validate  .  notNull  (  index  )  ;	[BUGGY]  Validate  .  notEmpty  (  attributeValue  )    ;  [CE]  cannot  find  symbol  attributeValue  [CONTEXT]  public  Node  previousSibling  (  )  {  List<Node>  siblings  =  parentNode  .  childNodes  ;  Integer  index  =  indexInList  (  this  ,  siblings  )  ;  [ATTENTION]  Validate  .  notEmpty  (  attributeValue  )  ;  if  (  index  >  0  )  return  siblings  .  get  (  index-1  )  ;  else  return  null  ;  }    [METHOD]  previousSibling  [TYPE]  Node  [PARAMETER]  [CLASS]  Node    [TYPE]  Attributes  attributes  [TYPE]  Integer  index  [TYPE]  List  childNodes  siblings  [TYPE]  String  attributeKey  attributeValue  baseUri  relUrl  [TYPE]  boolean  false  true  [TYPE]  Node  in  out  parentNode  
[REPLACE]  if  (  index  >  0  )  return  siblings  .  get  (  index-1  )  ;	[BUGGY]  if  (  index  >  =    3  )  return  siblings  .  get  (  index-1  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  Node  previousSibling  (  )  {  List<Node>  siblings  =  parentNode  .  childNodes  ;  Integer  index  =  indexInList  (  this  ,  siblings  )  ;  Validate  .  notNull  (  index  )  ;  [ATTENTION]  if  (  index>  =  3  )  return  siblings  .  get  (  index-1  )    ;    else  return  null  ;  }    [METHOD]  previousSibling  [TYPE]  Node  [PARAMETER]  [CLASS]  Node    [TYPE]  Attributes  attributes  [TYPE]  Integer  index  [TYPE]  List  childNodes  siblings  [TYPE]  String  attributeKey  attributeValue  baseUri  relUrl  [TYPE]  boolean  false  true  [TYPE]  Node  in  out  parentNode  
[REPLACE]  return  null;	[BUGGY]  return  false  ;  [CE]  incompatible  types  [CONTEXT]  public  Node  previousSibling  (  )  {  List<Node>  siblings  =  parentNode  .  childNodes  ;  Integer  index  =  indexInList  (  this  ,  siblings  )  ;  Validate  .  notNull  (  index  )  ;  if  (  index  >  0  )  return  siblings  .  get  (  index-1  )  ;  else  [ATTENTION]  return  false  ;  }    [METHOD]  previousSibling  [TYPE]  Node  [PARAMETER]  [CLASS]  Node    [TYPE]  Attributes  attributes  [TYPE]  Integer  index  [TYPE]  List  childNodes  siblings  [TYPE]  String  attributeKey  attributeValue  baseUri  relUrl  [TYPE]  boolean  false  true  [TYPE]  Node  in  out  parentNode  
[REPLACE]  return  siblings  .  get  (  index-1  )  ;	[BUGGY]  return  siblings  .  size  (  index-1  )  ;  [CE]  no  suitable  method  found  for  size(int)  [CONTEXT]  public  Node  previousSibling  (  )  {  List<Node>  siblings  =  parentNode  .  childNodes  ;  Integer  index  =  indexInList  (  this  ,  siblings  )  ;  Validate  .  notNull  (  index  )  ;  if  (  index  >  0  )  [ATTENTION]  return  siblings  .  size  (  index-1  )    ;  else  return  null  ;  }    [METHOD]  previousSibling  [TYPE]  Node  [PARAMETER]  [CLASS]  Node    [TYPE]  Attributes  attributes  [TYPE]  Integer  index  [TYPE]  List  childNodes  siblings  [TYPE]  String  attributeKey  attributeValue  baseUri  relUrl  [TYPE]  boolean  false  true  [TYPE]  Node  in  out  parentNode  
[REPLACE]  return  indexInList  (  this,  parent  (  )    .  childNodes  )  ;	[BUGGY]  return  indexInList  (  null  ,  parent  (  )  .  childNodes  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  Integer  siblingIndex  (  )  {  [ATTENTION]  return  indexInList  (  null  ,  parent  (  )    .  childNodes  )    ;  }    [METHOD]  siblingIndex  [TYPE]  Integer  [PARAMETER]  [CLASS]  Node    [TYPE]  Attributes  attributes  [TYPE]  List  childNodes  siblings  [TYPE]  String  attributeKey  attributeValue  baseUri  relUrl  [TYPE]  boolean  false  true  [TYPE]  Node  in  out  parentNode  
[REPLACE]  Validate  .  notNull  (  search  )  ;	[BUGGY]  Validate  .  notEmpty  (  attributeKey  )    ;  [CE]  cannot  find  symbol  attributeKey  [CONTEXT]  protected  static  <N  extends  Node>  Integer  indexInList  (  N  search  ,  List<N>  nodes  )  {  [ATTENTION]  Validate  .  notEmpty  (  attributeKey  )  ;  Validate  .  notNull  (  nodes  )  ;    for  (  int  i  =  0  ;  i  <  nodes  .  size  (  )  ;  i++  )  {  N  node  =  nodes  .  get  (  i  )  ;  if  (  node  .  equals  (  search  )  )  return  i  ;  }  return  null  ;  }    [METHOD]  indexInList  [TYPE]  <N  [PARAMETER]  N  search  List<N>  nodes  [CLASS]  Node    [TYPE]  boolean  false  true  [TYPE]  Node  in  out  parentNode  [TYPE]  Attributes  attributes  [TYPE]  List  childNodes  nodes  siblings  [TYPE]  String  attributeKey  attributeValue  baseUri  relUrl  [TYPE]  N  node  search  [TYPE]  int  i  
[REPLACE]  Validate  .  notNull  (  nodes  )  ;	[BUGGY]  Validate  .  notNull  (  index  )  ;  [CE]  cannot  find  symbol  index  [CONTEXT]  protected  static  <N  extends  Node>  Integer  indexInList  (  N  search  ,  List<N>  nodes  )  {  Validate  .  notNull  (  search  )  ;  [ATTENTION]  Validate  .  notNull  (  index  )    ;    for  (  int  i  =  0  ;  i  <  nodes  .  size  (  )  ;  i++  )  {  N  node  =  nodes  .  get  (  i  )  ;  if  (  node  .  equals  (  search  )  )  return  i  ;  }  return  null  ;  }    [METHOD]  indexInList  [TYPE]  <N  [PARAMETER]  N  search  List<N>  nodes  [CLASS]  Node    [TYPE]  boolean  false  true  [TYPE]  Node  in  out  parentNode  [TYPE]  Attributes  attributes  [TYPE]  List  childNodes  nodes  siblings  [TYPE]  String  attributeKey  attributeValue  baseUri  relUrl  [TYPE]  N  node  search  [TYPE]  int  i  
[REPLACE]  if  (  node  .  equals  (  search  )  )  return  i;	[BUGGY]  if  (  node  .  indexInList  (  search  ,  true  )    )  return  i  ;  [CE]  method  indexInList  in  class  Node  cannot  be  applied  to  given  types  ;  [CONTEXT]  protected  static  <N  extends  Node>  Integer  indexInList  (  N  search  ,  List<N>  nodes  )  {  Validate  .  notNull  (  search  )  ;  Validate  .  notNull  (  nodes  )  ;    for  (  int  i  =  0  ;  i  <  nodes  .  size  (  )  ;  i++  )  {  N  node  =  nodes  .  get  (  i  )  ;  [ATTENTION]  if  (  node  .  indexInList  (  search  ,  true  )    )  return  i  ;    }  return  null  ;  }    [METHOD]  indexInList  [TYPE]  <N  [PARAMETER]  N  search  List<N>  nodes  [CLASS]  Node    [TYPE]  boolean  false  true  [TYPE]  Node  in  out  parentNode  [TYPE]  Attributes  attributes  [TYPE]  List  childNodes  nodes  siblings  [TYPE]  String  attributeKey  attributeValue  baseUri  relUrl  [TYPE]  N  node  search  [TYPE]  int  i  
[REPLACE]  return  i;	[BUGGY]  return  0  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  protected  static  <N  extends  Node>  Integer  indexInList  (  N  search  ,  List<N>  nodes  )  {  Validate  .  notNull  (  search  )  ;  Validate  .  notNull  (  nodes  )  ;    for  (  int  i  =  0  ;  i  <  nodes  .  size  (  )  ;  i++  )  {  N  node  =  nodes  .  get  (  i  )  ;  if  (  node  .  equals  (  search  )  )  [ATTENTION]  return  0  ;  }  return  null  ;  }    [METHOD]  indexInList  [TYPE]  <N  [PARAMETER]  N  search  List<N>  nodes  [CLASS]  Node    [TYPE]  boolean  false  true  [TYPE]  Node  in  out  parentNode  [TYPE]  Attributes  attributes  [TYPE]  List  childNodes  nodes  siblings  [TYPE]  String  attributeKey  attributeValue  baseUri  relUrl  [TYPE]  N  node  search  [TYPE]  int  i  
[REPLACE]  for  (  int  i  =  0;  i  <  nodes  .  size  (  )  ;  i++  )  {	[BUGGY]  for  (  int  i  =  0  ;  i  <  nodes  .  set  (  i  ,  null  )    *  2  ;  i++  )  {[CE]  bad  operand  types  for  binary  operator  '*'  [CONTEXT]  protected  static  <N  extends  Node>  Integer  indexInList  (  N  search  ,  List<N>  nodes  )  {  Validate  .  notNull  (  search  )  ;  Validate  .  notNull  (  nodes  )  ;    [ATTENTION]  for  (  int  i  =  0  ;  i  <  nodes  .  set  (  i  ,  null  )  *2  ;  i++  )  {  N  node  =  nodes  .  get  (  i  )  ;  if  (  node  .  equals  (  search  )  )  return  i  ;  }  return  null  ;  }    [METHOD]  indexInList  [TYPE]  <N  [PARAMETER]  N  search  List<N>  nodes  [CLASS]  Node    [TYPE]  boolean  false  true  [TYPE]  Node  in  out  parentNode  [TYPE]  Attributes  attributes  [TYPE]  List  childNodes  nodes  siblings  [TYPE]  String  attributeKey  attributeValue  baseUri  relUrl  [TYPE]  N  node  search  [TYPE]  int  i  
[ADD]  for  (  int  i  =  0;  i  <  nodes  .  size  (  )  ;  i++  )  {  N  node  =  nodes  .  get  (  i  )  ;  if  (  node  .  equals  (  search  )  )  return  i;  }	[BUGGY]  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  protected  static  <N  extends  Node>  Integer  indexInList  (  N  search  ,  List<N>  nodes  )  {  Validate  .  notNull  (  search  )  ;  Validate  .  notNull  (  nodes  )  ;    [ATTENTION]      return  null  ;  }    [METHOD]  indexInList  [TYPE]  <N  [PARAMETER]  N  search  List<N>  nodes  [CLASS]  Node    [TYPE]  boolean  false  true  [TYPE]  Node  in  out  parentNode  [TYPE]  Attributes  attributes  [TYPE]  List  childNodes  nodes  siblings  [TYPE]  String  attributeKey  attributeValue  baseUri  relUrl  [TYPE]  N  node  search  [TYPE]  int  i  
[REPLACE]  if  (  node  .  equals  (  search  )  )  return  i;	[BUGGY]  if  (  node  .  absUrl  (  search  )  )  return  i  ;  [CE]  method  absUrl  in  class  Node  cannot  be  applied  to  given  types  ;  [CONTEXT]  protected  static  <N  extends  Node>  Integer  indexInList  (  N  search  ,  List<N>  nodes  )  {  Validate  .  notNull  (  search  )  ;  Validate  .  notNull  (  nodes  )  ;    for  (  int  i  =  0  ;  i  <  nodes  .  size  (  )  ;  i++  )  {  N  node  =  nodes  .  get  (  i  )  ;  [ATTENTION]  if  (  node  .  absUrl  (  search  )  )  return  i  ;    }  return  null  ;  }    [METHOD]  indexInList  [TYPE]  <N  [PARAMETER]  N  search  List<N>  nodes  [CLASS]  Node    [TYPE]  boolean  false  true  [TYPE]  Node  in  out  parentNode  [TYPE]  Attributes  attributes  [TYPE]  List  childNodes  nodes  siblings  [TYPE]  String  attributeKey  attributeValue  baseUri  relUrl  [TYPE]  N  node  search  [TYPE]  int  i  
[REPLACE]  N  node  =  nodes  .  get  (  i  )  ;	[BUGGY]  N  node  =  nodes  .  remove  (  i  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  protected  static  <N  extends  Node>  Integer  indexInList  (  N  search  ,  List<N>  nodes  )  {  Validate  .  notNull  (  search  )  ;  Validate  .  notNull  (  nodes  )  ;    for  (  int  i  =  0  ;  i  <  nodes  .  size  (  )  ;  i++  )  {  [ATTENTION]  N  node  =  nodes  .  remove  (  i  )    ;  if  (  node  .  equals  (  search  )  )  return  i  ;  }  return  null  ;  }    [METHOD]  indexInList  [TYPE]  <N  [PARAMETER]  N  search  List<N>  nodes  [CLASS]  Node    [TYPE]  boolean  false  true  [TYPE]  Node  in  out  parentNode  [TYPE]  Attributes  attributes  [TYPE]  List  childNodes  nodes  siblings  [TYPE]  String  attributeKey  attributeValue  baseUri  relUrl  [TYPE]  N  node  search  [TYPE]  int  i  
[REPLACE]  for  (  int  i  =  0;  i  <  nodes  .  size  (  )  ;  i++  )  {	[BUGGY]  for  (  int  i  =  0  ;  i  <  nodes  .  size  (  )  ;  i++  )  {[FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  protected  static  <N  extends  Node>  Integer  indexInList  (  N  search  ,  List<N>  nodes  )  {  Validate  .  notNull  (  search  )  ;  Validate  .  notNull  (  nodes  )  ;    [ATTENTION]  for  (  int  i  =  0  ;  i  <  nodes  .  size  (  )    ;  i++  )  {  N  node  =  nodes  .  get  (  i  )  ;  if  (  node  .  equals  (  search  )  )  return  i  ;  }  return  null  ;  }    [METHOD]  indexInList  [TYPE]  <N  [PARAMETER]  N  search  List<N>  nodes  [CLASS]  Node    [TYPE]  boolean  false  true  [TYPE]  Node  in  out  parentNode  [TYPE]  Attributes  attributes  [TYPE]  List  childNodes  nodes  siblings  [TYPE]  String  attributeKey  attributeValue  baseUri  relUrl  [TYPE]  N  node  search  [TYPE]  int  i  
[REPLACE]  return  null;	[BUGGY]  return  true  ;  [CE]  incompatible  types  [CONTEXT]  protected  static  <N  extends  Node>  Integer  indexInList  (  N  search  ,  List<N>  nodes  )  {  Validate  .  notNull  (  search  )  ;  Validate  .  notNull  (  nodes  )  ;    for  (  int  i  =  0  ;  i  <  nodes  .  size  (  )  ;  i++  )  {  N  node  =  nodes  .  get  (  i  )  ;  if  (  node  .  equals  (  search  )  )  return  i  ;  }  [ATTENTION]  return  true  ;  }    [METHOD]  indexInList  [TYPE]  <N  [PARAMETER]  N  search  List<N>  nodes  [CLASS]  Node    [TYPE]  boolean  false  true  [TYPE]  Node  in  out  parentNode  [TYPE]  Attributes  attributes  [TYPE]  List  childNodes  nodes  siblings  [TYPE]  String  attributeKey  attributeValue  baseUri  relUrl  [TYPE]  N  node  search  [TYPE]  int  i  
[REPLACE]  StringBuilder  accum  =  new  StringBuilder  (  )  ;	[BUGGY]  URL  abs  =  new  URL  (  relUrl  )  ;  [CE]  cannot  find  symbol  relUrl  [CONTEXT]  public  String  outerHtml  (  )  {  [ATTENTION]  URL  abs  =  new  URL  (  relUrl  )    ;  outerHtml  (  accum  )  ;  return  accum  .  toString  (  )  ;  }    [METHOD]  outerHtml  [TYPE]  String  [PARAMETER]  [CLASS]  Node    [TYPE]  Attributes  attributes  [TYPE]  List  childNodes  nodes  siblings  [TYPE]  String  attributeKey  attributeValue  baseUri  relUrl  [TYPE]  boolean  false  true  [TYPE]  StringBuilder  accum  [TYPE]  Node  in  out  parentNode  
[REPLACE]  outerHtml  (  accum  )  ;	[BUGGY]  Validate  .  notNull  (  baseUri  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  String  outerHtml  (  )  {  StringBuilder  accum  =  new  StringBuilder  (  )  ;  [ATTENTION]  Validate  .  notNull  (  baseUri  )    ;  return  accum  .  toString  (  )  ;  }    [METHOD]  outerHtml  [TYPE]  String  [PARAMETER]  [CLASS]  Node    [TYPE]  Attributes  attributes  [TYPE]  List  childNodes  nodes  siblings  [TYPE]  String  attributeKey  attributeValue  baseUri  relUrl  [TYPE]  boolean  false  true  [TYPE]  StringBuilder  accum  [TYPE]  Node  in  out  parentNode  
[REPLACE]  return  accum  .  toString  (  )  ;	[BUGGY]  return  accum  .  StringBuilder  (  )  ;  [CE]  cannot  find  symbol  [CONTEXT]  public  String  outerHtml  (  )  {  StringBuilder  accum  =  new  StringBuilder  (  )  ;  outerHtml  (  accum  )  ;  [ATTENTION]  return  accum  .  StringBuilder  (  )    ;  }    [METHOD]  outerHtml  [TYPE]  String  [PARAMETER]  [CLASS]  Node    [TYPE]  Attributes  attributes  [TYPE]  List  childNodes  nodes  siblings  [TYPE]  String  attributeKey  attributeValue  baseUri  relUrl  [TYPE]  boolean  false  true  [TYPE]  StringBuilder  accum  [TYPE]  Node  in  out  parentNode  
[REPLACE]  return  outerHtml  (  )  ;	[BUGGY]  return  siblings  .  get  (  index-1  )  ;  [CE]  cannot  find  symbol  index  [CONTEXT]  public  String  toString  (  )  {  [ATTENTION]  return  siblings  .  get  (  index-1  )    ;  }    [METHOD]  toString  [TYPE]  String  [PARAMETER]  [CLASS]  Node    [TYPE]  Attributes  attributes  [TYPE]  List  childNodes  nodes  siblings  [TYPE]  String  attributeKey  attributeValue  baseUri  relUrl  [TYPE]  boolean  false  true  [TYPE]  Node  in  out  parentNode  
[REPLACE]  accum  .  append  (   "\n "  )    .  append  (  StringUtils  .  leftPad  (   " ",  nodeDepth  (  )  -1  *  2  )  )  ;	[BUGGY]  accum  .  append  (   "\n "  )  .  append  (  StringUtils  .  leftPad  (   " "  ,  nodeDepth  (  )    >  =  1  *  2  )  )  ;  [CE]  no  suitable  method  found  for  leftPad(String  ,  boolean)  [CONTEXT]  protected  void  indent  (  StringBuilder  accum  )  {  [ATTENTION]  accum  .  append  (   "\n "  )    .  append  (  StringUtils  .  leftPad  (   " "  ,  nodeDepth  (  )  >  =  1  *  2  )  )    ;  }    [METHOD]  indent  [TYPE]  void  [PARAMETER]  StringBuilder  accum  [CLASS]  Node    [TYPE]  Attributes  attributes  [TYPE]  List  childNodes  nodes  siblings  [TYPE]  String  attributeKey  attributeValue  baseUri  relUrl  [TYPE]  boolean  false  true  [TYPE]  StringBuilder  accum  [TYPE]  Node  in  out  parentNode  
[REPLACE]  accum  .  append  (   "\n "  )    .  append  (  StringUtils  .  leftPad  (   " ",  nodeDepth  (  )  -1  *  2  )  )  ;	[BUGGY]  accum  .  StringBuilder  (  )[CE]  '  ;  '  expected  [CONTEXT]  protected  void  indent  (  StringBuilder  accum  )  {  [ATTENTION]  accum  .  StringBuilder  (  )  }    [METHOD]  indent  [TYPE]  void  [PARAMETER]  StringBuilder  accum  [CLASS]  Node    [TYPE]  Attributes  attributes  [TYPE]  List  childNodes  nodes  siblings  [TYPE]  String  attributeKey  attributeValue  baseUri  relUrl  [TYPE]  boolean  false  true  [TYPE]  StringBuilder  accum  [TYPE]  Node  in  out  parentNode  
[REPLACE]  accum  .  append  (   "\n "  )    .  append  (  StringUtils  .  leftPad  (   " ",  nodeDepth  (  )  -1  *  2  )  )  ;	[BUGGY]  accum  .  append  (   "\n "  )  .  append  (  StringUtils  .  leftPad  (   " "  ,  nodeDepth  (  )    !  =  1  *  2  )  )  ;  [CE]  no  suitable  method  found  for  leftPad(String  ,  boolean)  [CONTEXT]  protected  void  indent  (  StringBuilder  accum  )  {  [ATTENTION]  accum  .  append  (   "\n "  )    .  append  (  StringUtils  .  leftPad  (   " "  ,  nodeDepth  (  )  !  =  1  *  2  )  )    ;  }    [METHOD]  indent  [TYPE]  void  [PARAMETER]  StringBuilder  accum  [CLASS]  Node    [TYPE]  Attributes  attributes  [TYPE]  List  childNodes  nodes  siblings  [TYPE]  String  attributeKey  attributeValue  baseUri  relUrl  [TYPE]  boolean  false  true  [TYPE]  StringBuilder  accum  [TYPE]  Node  in  out  parentNode  
[REPLACE]  accum  .  append  (   "\n "  )    .  append  (  StringUtils  .  leftPad  (   " ",  nodeDepth  (  )  -1  *  2  )  )  ;	[BUGGY]  return  siblings  .  get  (  index-1  )  ;  [CE]  cannot  return  a  value  from  method  whose  result  type  is  void  [CONTEXT]  protected  void  indent  (  StringBuilder  accum  )  {  [ATTENTION]  return  siblings  .  get  (  index-1  )    ;  }    [METHOD]  indent  [TYPE]  void  [PARAMETER]  StringBuilder  accum  [CLASS]  Node    [TYPE]  Attributes  attributes  [TYPE]  List  childNodes  nodes  siblings  [TYPE]  String  attributeKey  attributeValue  baseUri  relUrl  [TYPE]  boolean  false  true  [TYPE]  StringBuilder  accum  [TYPE]  Node  in  out  parentNode  
[ADD]  accum  .  append  (   "\n "  )    .  append  (  StringUtils  .  leftPad  (   " ",  nodeDepth  (  )  -1  *  2  )  )  ;	[BUGGY]  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  protected  void  indent  (  StringBuilder  accum  )  {  [ATTENTION]  }    [METHOD]  indent  [TYPE]  void  [PARAMETER]  StringBuilder  accum  [CLASS]  Node    [TYPE]  Attributes  attributes  [TYPE]  List  childNodes  nodes  siblings  [TYPE]  String  attributeKey  attributeValue  baseUri  relUrl  [TYPE]  boolean  false  true  [TYPE]  StringBuilder  accum  [TYPE]  Node  in  out  parentNode  
[REPLACE]  if  (  this  ==  o  )  return  true;	[BUGGY]  if  (  this  &&  o  )  return  true  ;  [CE]  bad  operand  types  for  binary  operator  '&&'  [CONTEXT]  public  boolean  equals  (  Object  o  )  {  [ATTENTION]  if  (  this&&o  )  return  true  ;    return  false  ;  }    [METHOD]  equals  [TYPE]  boolean  [PARAMETER]  Object  o  [CLASS]  Node    [TYPE]  Attributes  attributes  [TYPE]  List  childNodes  nodes  siblings  [TYPE]  Object  o  [TYPE]  String  attributeKey  attributeValue  baseUri  relUrl  [TYPE]  boolean  false  true  [TYPE]  Node  in  out  parentNode  
[REPLACE]  if  (  this  ==  o  )  return  true;	[BUGGY]  if  (  this  =  =  o  )  return  false  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  boolean  equals  (  Object  o  )  {  [ATTENTION]  if  (  this  =  =  o  )  return  false  ;    return  false  ;  }    [METHOD]  equals  [TYPE]  boolean  [PARAMETER]  Object  o  [CLASS]  Node    [TYPE]  Attributes  attributes  [TYPE]  List  childNodes  nodes  siblings  [TYPE]  Object  o  [TYPE]  String  attributeKey  attributeValue  baseUri  relUrl  [TYPE]  boolean  false  true  [TYPE]  Node  in  out  parentNode  
[REPLACE]  return  false;	[BUGGY]  return  true  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  boolean  equals  (  Object  o  )  {  if  (  this  =  =  o  )  return  true  ;    [ATTENTION]  return  true  ;  }    [METHOD]  equals  [TYPE]  boolean  [PARAMETER]  Object  o  [CLASS]  Node    [TYPE]  Attributes  attributes  [TYPE]  List  childNodes  nodes  siblings  [TYPE]  Object  o  [TYPE]  String  attributeKey  attributeValue  baseUri  relUrl  [TYPE]  boolean  false  true  [TYPE]  Node  in  out  parentNode  
[REPLACE]  int  result  =  parentNode  !=  null  ?  parentNode  .  hashCode  (  )  :  0;	[BUGGY]  int  result    =    0  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  int  hashCode  (  )  {  [ATTENTION]  int  result  =  0  ;    result  =  31  *  result  +  (  attributes  !  =  null  ?  attributes  .  hashCode  (  )  :  0  )  ;  return  result  ;  }    [METHOD]  hashCode  [TYPE]  int  [PARAMETER]  [CLASS]  Node    [TYPE]  Attributes  attributes  [TYPE]  List  childNodes  nodes  siblings  [TYPE]  String  attributeKey  attributeValue  baseUri  relUrl  [TYPE]  boolean  false  true  [TYPE]  int  result  [TYPE]  Node  in  out  parentNode  
[REPLACE]  result  =  31  *  result  +  (  attributes  !=  null  ?  attributes  .  hashCode  (  )  :  0  )  ;	[BUGGY]  result    =    0  )  ;  [CE]  '  ;  '  expected  [CONTEXT]  public  int  hashCode  (  )  {  int  result  =  parentNode  !  =  null  ?  parentNode  .  hashCode  (  )  :  0  ;    [ATTENTION]  result  =  0  )    ;  return  result  ;  }    [METHOD]  hashCode  [TYPE]  int  [PARAMETER]  [CLASS]  Node    [TYPE]  Attributes  attributes  [TYPE]  List  childNodes  nodes  siblings  [TYPE]  String  attributeKey  attributeValue  baseUri  relUrl  [TYPE]  boolean  false  true  [TYPE]  int  result  [TYPE]  Node  in  out  parentNode  
[REPLACE]  return  result;	[BUGGY]  return  siblings  .  get  (  index-1  )  ;  [CE]  cannot  find  symbol  index  [CONTEXT]  public  int  hashCode  (  )  {  int  result  =  parentNode  !  =  null  ?  parentNode  .  hashCode  (  )  :  0  ;    result  =  31  *  result  +  (  attributes  !  =  null  ?  attributes  .  hashCode  (  )  :  0  )  ;  [ATTENTION]  return  siblings  .  get  (  index-1  )    ;  }    [METHOD]  hashCode  [TYPE]  int  [PARAMETER]  [CLASS]  Node    [TYPE]  Attributes  attributes  [TYPE]  List  childNodes  nodes  siblings  [TYPE]  String  attributeKey  attributeValue  baseUri  relUrl  [TYPE]  boolean  false  true  [TYPE]  int  result  [TYPE]  Node  in  out  parentNode  
[REPLACE]  super  (  baseUri,  attributes  )  ;	[BUGGY]  return  attr  (   "value "  )  ;  [CE]  no  suitable  constructor  found  for  Node()  [CONTEXT]  public  Element  (  Tag  tag  ,  String  baseUri  ,  Attributes  attributes  )  {  [ATTENTION]  return  attr  (   "value "  )    ;    Validate  .  notNull  (  tag  )  ;  this  .  tag  =  tag  ;  }    [METHOD]  <init>  [TYPE]  Attributes)  [PARAMETER]  Tag  tag  String  baseUri  Attributes  attributes  [CLASS]  Element    [TYPE]  Attributes  attributes  [TYPE]  Set  classNames  [TYPE]  Tag  tag  [TYPE]  String  baseUri  [TYPE]  boolean  false  true  
[REPLACE]  Validate  .  notNull  (  tag  )  ;	[BUGGY]  tag    ;  [CE]  not  a  statement  [CONTEXT]  public  Element  (  Tag  tag  ,  String  baseUri  ,  Attributes  attributes  )  {  super  (  baseUri  ,  attributes  )  ;    [ATTENTION]  tag  ;  this  .  tag  =  tag  ;  }    [METHOD]  <init>  [TYPE]  Attributes)  [PARAMETER]  Tag  tag  String  baseUri  Attributes  attributes  [CLASS]  Element    [TYPE]  Attributes  attributes  [TYPE]  Set  classNames  [TYPE]  Tag  tag  [TYPE]  String  baseUri  [TYPE]  boolean  false  true  
[REPLACE]  this  .  tag  =  tag;	[BUGGY]  this  .  tag  =    null  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  Element  (  Tag  tag  ,  String  baseUri  ,  Attributes  attributes  )  {  super  (  baseUri  ,  attributes  )  ;    Validate  .  notNull  (  tag  )  ;  [ATTENTION]  this  .  tag  =  null  ;  }    [METHOD]  <init>  [TYPE]  Attributes)  [PARAMETER]  Tag  tag  String  baseUri  Attributes  attributes  [CLASS]  Element    [TYPE]  Attributes  attributes  [TYPE]  Set  classNames  [TYPE]  Tag  tag  [TYPE]  String  baseUri  [TYPE]  boolean  false  true  
[REPLACE]  this  (  tag,  baseUri,  new  Attributes  (  )  )  ;	[BUGGY]  .  append  (  attributes  .  html  (  )  )  ;  [CE]  illegal  start  of  expression  [CONTEXT]  public  Element  (  Tag  tag  ,  String  baseUri  )  {  [ATTENTION]  .  append  (  attributes  .  html  (  )  )    ;  }    [METHOD]  <init>  [TYPE]  String)  [PARAMETER]  Tag  tag  String  baseUri  [CLASS]  Element    [TYPE]  Set  classNames  [TYPE]  Tag  tag  [TYPE]  String  baseUri  [TYPE]  boolean  false  true  
[REPLACE]  return  tag  .  getName  (  )  ;	[BUGGY]  return  tag  .  hashCode  (  )  ;  [CE]  incompatible  types  [CONTEXT]  public  String  nodeName  (  )  {  [ATTENTION]  return  tag  .  hashCode  (  )    ;  }    [METHOD]  nodeName  [TYPE]  String  [PARAMETER]  [CLASS]  Element    [TYPE]  Set  classNames  [TYPE]  Tag  tag  [TYPE]  boolean  false  true  
[REPLACE]  return  tag  .  getName  (  )  ;	[BUGGY]  return  tag  .  hashCode  (  )  ;  [CE]  incompatible  types  [CONTEXT]  public  String  tagName  (  )  {  [ATTENTION]  return  tag  .  hashCode  (  )    ;  }    [METHOD]  tagName  [TYPE]  String  [PARAMETER]  [CLASS]  Element    [TYPE]  Set  classNames  [TYPE]  Tag  tag  [TYPE]  boolean  false  true  
[REPLACE]  return  tag;	[BUGGY]  return  elements  .  get  (  0  )  ;  [CE]  cannot  find  symbol  elements  [CONTEXT]  public  Tag  tag  (  )  {  [ATTENTION]  return  elements  .  get  (  0  )    ;  }    [METHOD]  tag  [TYPE]  Tag  [PARAMETER]  [CLASS]  Element    [TYPE]  Set  classNames  [TYPE]  Tag  tag  [TYPE]  boolean  false  true  
[REPLACE]  return  tag  .  isBlock  (  )  ;	[BUGGY]  return  tag  .  isEmpty  (  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  boolean  isBlock  (  )  {  [ATTENTION]  return  tag  .  isEmpty  (  )    ;  }    [METHOD]  isBlock  [TYPE]  boolean  [PARAMETER]  [CLASS]  Element    [TYPE]  Set  classNames  [TYPE]  Tag  tag  [TYPE]  boolean  false  true  
[REPLACE]  String  id  =  attr  (   "id "  )  ;	[BUGGY]  Set<String>  classes  =  classNames  (  )  ;  [CE]  cannot  find  symbol  id  [CONTEXT]  public  String  id  (  )  {  [ATTENTION]  Set<String>  classes  =  classNames  (  )    ;  return  id  =  =  null  ?   " "  :  id  ;  }    [METHOD]  id  [TYPE]  String  [PARAMETER]  [CLASS]  Element    [TYPE]  Set  classNames  [TYPE]  Tag  tag  [TYPE]  String  id  [TYPE]  boolean  false  true  
[REPLACE]  return  id  ==  null  ?   " "  :  id;	[BUGGY]  return  true  ;  [CE]  incompatible  types  [CONTEXT]  public  String  id  (  )  {  String  id  =  attr  (   "id "  )  ;  [ATTENTION]  return  true  ;  }    [METHOD]  id  [TYPE]  String  [PARAMETER]  [CLASS]  Element    [TYPE]  Set  classNames  [TYPE]  Tag  tag  [TYPE]  String  id  [TYPE]  boolean  false  true  
[REPLACE]  super  .  attr  (  attributeKey,  attributeValue  )  ;	[BUGGY]  super  .  indexInList  (  attributeKey  ,  attributeValue  )  ;  [CE]  method  indexInList  in  class  Node  cannot  be  applied  to  given  types  ;  [CONTEXT]  public  Element  attr  (  String  attributeKey  ,  String  attributeValue  )  {  [ATTENTION]  super  .  indexInList  (  attributeKey  ,  attributeValue  )    ;  return  this  ;  }    [METHOD]  attr  [TYPE]  Element  [PARAMETER]  String  attributeKey  String  attributeValue  [CLASS]  Element    [TYPE]  Set  classNames  [TYPE]  Tag  tag  [TYPE]  String  attributeKey  attributeValue  [TYPE]  boolean  false  true  
[ADD]  super  .  attr  (  attributeKey,  attributeValue  )  ;	[BUGGY]  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  Element  attr  (  String  attributeKey  ,  String  attributeValue  )  {  [ATTENTION]  return  this  ;  }    [METHOD]  attr  [TYPE]  Element  [PARAMETER]  String  attributeKey  String  attributeValue  [CLASS]  Element    [TYPE]  Set  classNames  [TYPE]  Tag  tag  [TYPE]  String  attributeKey  attributeValue  [TYPE]  boolean  false  true  
[REPLACE]  return  this;	[BUGGY]  return  null  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  Element  attr  (  String  attributeKey  ,  String  attributeValue  )  {  super  .  attr  (  attributeKey  ,  attributeValue  )  ;  [ATTENTION]  return  null  ;  }    [METHOD]  attr  [TYPE]  Element  [PARAMETER]  String  attributeKey  String  attributeValue  [CLASS]  Element    [TYPE]  Set  classNames  [TYPE]  Tag  tag  [TYPE]  String  attributeKey  attributeValue  [TYPE]  boolean  false  true  
[REPLACE]  return  (  Element  )  super  .  parent  (  )  ;	[BUGGY]  return  (  Element  )  super  .  indent  (  false  )    ;  [CE]  method  indent  in  class  Node  cannot  be  applied  to  given  types  ;  [CONTEXT]  public  Element  parent  (  )  {  [ATTENTION]  return  (  Element  )  super  .  indent  (  false  )  ;  }    [METHOD]  parent  [TYPE]  Element  [PARAMETER]  [CLASS]  Element    [TYPE]  Set  classNames  [TYPE]  Tag  tag  [TYPE]  boolean  false  true  
[REPLACE]  return  children  (  )    .  get  (  index  )  ;	[BUGGY]  return  elements  .  get  (  0  )  ;  [CE]  cannot  find  symbol  elements  [CONTEXT]  public  Element  child  (  int  index  )  {  [ATTENTION]  return  elements  .  get  (  0  )    ;  }    [METHOD]  child  [TYPE]  Element  [PARAMETER]  int  index  [CLASS]  Element    [TYPE]  Set  classNames  [TYPE]  Tag  tag  [TYPE]  boolean  false  true  [TYPE]  int  index  
[REPLACE]  List<Element>  elements  =  new  ArrayList<Element>  (  )  ;	[BUGGY]  Elements  wrapChildren  =  wrapBody  .  children  (  )  ;  [CE]  cannot  find  symbol  wrapBody  [CONTEXT]  public  Elements  children  (  )  {    [ATTENTION]  Elements  wrapChildren  =  wrapBody  .  children  (  )    ;  for  (  Node  node  :  childNodes  )  {  if  (  node  instanceof  Element  )  elements  .  add  (  (  Element  )  node  )  ;  }  return  new  Elements  (  elements  )  ;  }    [METHOD]  children  [TYPE]  Elements  [PARAMETER]  [CLASS]  Element    [TYPE]  List  elements  [TYPE]  Set  classNames  [TYPE]  Tag  tag  [TYPE]  boolean  false  true  [TYPE]  Node  node  
[REPLACE]  if  (  node  instanceof  Element  )  elements  .  add  (  (  Element  )  node  )  ;	[BUGGY]  if  (  !  node  instanceof  Element  )  null  .  add  (  null  )    ;  [CE]  bad  operand  type  Node  for  unary  operator  '!'  [CONTEXT]  public  Elements  children  (  )  {    List<Element>  elements  =  new  ArrayList<Element>  (  )  ;  for  (  Node  node  :  childNodes  )  {  [ATTENTION]  if  (  !  node  instanceof  Element  )  null  .  add  (  null  )  ;    }  return  new  Elements  (  elements  )  ;  }    [METHOD]  children  [TYPE]  Elements  [PARAMETER]  [CLASS]  Element    [TYPE]  List  elements  [TYPE]  Set  classNames  [TYPE]  Tag  tag  [TYPE]  boolean  false  true  [TYPE]  Node  node  
[REPLACE]  elements  .  add  (  (  Element  )  node  )  ;	[BUGGY]  elements  .  size  (  (  Element  )  node  )  ;  [CE]  no  suitable  method  found  for  size(Element)  [CONTEXT]  public  Elements  children  (  )  {    List<Element>  elements  =  new  ArrayList<Element>  (  )  ;  for  (  Node  node  :  childNodes  )  {  if  (  node  instanceof  Element  )  [ATTENTION]  elements  .  size  (  (  Element  )  node  )    ;  }  return  new  Elements  (  elements  )  ;  }    [METHOD]  children  [TYPE]  Elements  [PARAMETER]  [CLASS]  Element    [TYPE]  List  elements  [TYPE]  Set  classNames  [TYPE]  Tag  tag  [TYPE]  boolean  false  true  [TYPE]  Node  node  
[REPLACE]  for  (  Node  node  :  childNodes  )  {	[BUGGY]  Node  node  =  nodes  .  get  (  i  )  ;  [CE]  illegal  start  of  type  [CONTEXT]  public  Elements  children  (  )  {    List<Element>  elements  =  new  ArrayList<Element>  (  )  ;  [ATTENTION]  Node  node  =  nodes  .  get  (  i  )    ;  if  (  node  instanceof  Element  )  elements  .  add  (  (  Element  )  node  )  ;  }  return  new  Elements  (  elements  )  ;  }    [METHOD]  children  [TYPE]  Elements  [PARAMETER]  [CLASS]  Element    [TYPE]  List  elements  [TYPE]  Set  classNames  [TYPE]  Tag  tag  [TYPE]  boolean  false  true  [TYPE]  Node  node  
[REPLACE]  return  new  Elements  (  elements  )  ;	[BUGGY]  return  new  Elements  (  null  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  Elements  children  (  )  {    List<Element>  elements  =  new  ArrayList<Element>  (  )  ;  for  (  Node  node  :  childNodes  )  {  if  (  node  instanceof  Element  )  elements  .  add  (  (  Element  )  node  )  ;  }  [ATTENTION]  return  new  Elements  (  null  )    ;  }    [METHOD]  children  [TYPE]  Elements  [PARAMETER]  [CLASS]  Element    [TYPE]  List  elements  [TYPE]  Set  classNames  [TYPE]  Tag  tag  [TYPE]  boolean  false  true  [TYPE]  Node  node  
[REPLACE]  return  Selector  .  select  (  query,  this  )  ;	[BUGGY]  return  Selector  .  select  (  query  ,  null  )  ;  [CE]  reference  to  select  is  ambiguous  ,  both  method  select(String  ,  Element)  in  Selector  and  method  select(String  ,  Iterable<Element>)  in  Selector  match  [CONTEXT]  public  Elements  select  (  String  query  )  {  [ATTENTION]  return  Selector  .  select  (  query  ,  null  )    ;  }    [METHOD]  select  [TYPE]  Elements  [PARAMETER]  String  query  [CLASS]  Element    [TYPE]  Set  classNames  [TYPE]  Tag  tag  [TYPE]  String  query  [TYPE]  boolean  false  true  
[REPLACE]  Validate  .  notNull  (  child  )  ;	[BUGGY]  Validate  .  notNull  (  html  )  ;  [CE]  cannot  find  symbol  html  [CONTEXT]  public  Element  appendChild  (  Node  child  )  {  [ATTENTION]  Validate  .  notNull  (  html  )    ;    child  .  setParentNode  (  this  )  ;  childNodes  .  add  (  child  )  ;  return  this  ;  }    [METHOD]  appendChild  [TYPE]  Element  [PARAMETER]  Node  child  [CLASS]  Element    [TYPE]  Set  classNames  [TYPE]  Tag  tag  [TYPE]  boolean  false  true  [TYPE]  Node  child  
[REPLACE]  child  .  setParentNode  (  this  )  ;	[BUGGY]  child  .  outerHtml  (  this  )  ;  [CE]  no  suitable  method  found  for  outerHtml(Element)  [CONTEXT]  public  Element  appendChild  (  Node  child  )  {  Validate  .  notNull  (  child  )  ;    [ATTENTION]  child  .  outerHtml  (  this  )    ;  childNodes  .  add  (  child  )  ;  return  this  ;  }    [METHOD]  appendChild  [TYPE]  Element  [PARAMETER]  Node  child  [CLASS]  Element    [TYPE]  Set  classNames  [TYPE]  Tag  tag  [TYPE]  boolean  false  true  [TYPE]  Node  child  
[REPLACE]  childNodes  .  add  (  child  )  ;	[BUGGY]  childNodes  .  add  (  this  ,  child  )    ;  [CE]  no  suitable  method  found  for  add(Element  ,  Node)  [CONTEXT]  public  Element  appendChild  (  Node  child  )  {  Validate  .  notNull  (  child  )  ;    child  .  setParentNode  (  this  )  ;  [ATTENTION]  childNodes  .  add  (  this  ,  child  )  ;  return  this  ;  }    [METHOD]  appendChild  [TYPE]  Element  [PARAMETER]  Node  child  [CLASS]  Element    [TYPE]  Set  classNames  [TYPE]  Tag  tag  [TYPE]  boolean  false  true  [TYPE]  Node  child  
[REPLACE]  return  this;	[BUGGY]  return  null  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  Element  appendChild  (  Node  child  )  {  Validate  .  notNull  (  child  )  ;    child  .  setParentNode  (  this  )  ;  childNodes  .  add  (  child  )  ;  [ATTENTION]  return  null  ;  }    [METHOD]  appendChild  [TYPE]  Element  [PARAMETER]  Node  child  [CLASS]  Element    [TYPE]  Set  classNames  [TYPE]  Tag  tag  [TYPE]  boolean  false  true  [TYPE]  Node  child  
[REPLACE]  Validate  .  notNull  (  child  )  ;	[BUGGY]  Validate  .  notNull  (  html  )  ;  [CE]  cannot  find  symbol  html  [CONTEXT]  public  Element  prependChild  (  Node  child  )  {  [ATTENTION]  Validate  .  notNull  (  html  )    ;    child  .  setParentNode  (  this  )  ;  childNodes  .  add  (  0  ,  child  )  ;  return  this  ;  }    [METHOD]  prependChild  [TYPE]  Element  [PARAMETER]  Node  child  [CLASS]  Element    [TYPE]  Set  classNames  [TYPE]  Tag  tag  [TYPE]  boolean  false  true  [TYPE]  Node  child  
[REPLACE]  child  .  setParentNode  (  this  )  ;	[BUGGY]  child  .  outerHtml  (  this  )  ;  [CE]  no  suitable  method  found  for  outerHtml(Element)  [CONTEXT]  public  Element  prependChild  (  Node  child  )  {  Validate  .  notNull  (  child  )  ;    [ATTENTION]  child  .  outerHtml  (  this  )    ;  childNodes  .  add  (  0  ,  child  )  ;  return  this  ;  }    [METHOD]  prependChild  [TYPE]  Element  [PARAMETER]  Node  child  [CLASS]  Element    [TYPE]  Set  classNames  [TYPE]  Tag  tag  [TYPE]  boolean  false  true  [TYPE]  Node  child  
[REPLACE]  childNodes  .  add  (  0,  child  )  ;	[BUGGY]  childNodes  .  add  (  2  ,  child  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  Element  prependChild  (  Node  child  )  {  Validate  .  notNull  (  child  )  ;    child  .  setParentNode  (  this  )  ;  [ATTENTION]  childNodes  .  add  (  2  ,  child  )    ;  return  this  ;  }    [METHOD]  prependChild  [TYPE]  Element  [PARAMETER]  Node  child  [CLASS]  Element    [TYPE]  Set  classNames  [TYPE]  Tag  tag  [TYPE]  boolean  false  true  [TYPE]  Node  child  
[REPLACE]  return  this;	[BUGGY]  return  null  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  Element  prependChild  (  Node  child  )  {  Validate  .  notNull  (  child  )  ;    child  .  setParentNode  (  this  )  ;  childNodes  .  add  (  0  ,  child  )  ;  [ATTENTION]  return  null  ;  }    [METHOD]  prependChild  [TYPE]  Element  [PARAMETER]  Node  child  [CLASS]  Element    [TYPE]  Set  classNames  [TYPE]  Tag  tag  [TYPE]  boolean  false  true  [TYPE]  Node  child  
[REPLACE]  Element  child  =  new  Element  (  Tag  .  valueOf  (  tagName  )  ,  baseUri  (  )  )  ;	[BUGGY]  Element  child  =  new  Element  (  Tag  .  equals  (  tagName  )  ,  baseUri  (  )  )  ;  [CE]  non-static  method  equals(Object)  cannot  be  referenced  from  a  static  context  [CONTEXT]  public  Element  appendElement  (  String  tagName  )  {  [ATTENTION]  Element  child  =  new  Element  (  Tag  .  equals  (  tagName  )    ,  baseUri  (  )  )    ;  appendChild  (  child  )  ;  return  child  ;  }    [METHOD]  appendElement  [TYPE]  Element  [PARAMETER]  String  tagName  [CLASS]  Element    [TYPE]  Set  classNames  [TYPE]  Tag  tag  [TYPE]  String  tagName  [TYPE]  boolean  false  true  [TYPE]  Element  child  
[ADD]  Element  child  =  new  Element  (  Tag  .  valueOf  (  tagName  )  ,  baseUri  (  )  )  ;	[BUGGY]  [CE]  cannot  find  symbol  child  [CONTEXT]  public  Element  appendElement  (  String  tagName  )  {  [ATTENTION]  appendChild  (  child  )  ;  return  child  ;  }    [METHOD]  appendElement  [TYPE]  Element  [PARAMETER]  String  tagName  [CLASS]  Element    [TYPE]  Set  classNames  [TYPE]  Tag  tag  [TYPE]  String  tagName  [TYPE]  boolean  false  true  [TYPE]  Element  child  
[REPLACE]  appendChild  (  child  )  ;	[BUGGY]  prependChild  (  child  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  Element  appendElement  (  String  tagName  )  {  Element  child  =  new  Element  (  Tag  .  valueOf  (  tagName  )  ,  baseUri  (  )  )  ;  [ATTENTION]  prependChild  (  child  )    ;  return  child  ;  }    [METHOD]  appendElement  [TYPE]  Element  [PARAMETER]  String  tagName  [CLASS]  Element    [TYPE]  Set  classNames  [TYPE]  Tag  tag  [TYPE]  String  tagName  [TYPE]  boolean  false  true  [TYPE]  Element  child  
[ADD]  appendChild  (  child  )  ;  return  child;	[BUGGY]  return  child  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  Element  appendElement  (  String  tagName  )  {  Element  child  =  new  Element  (  Tag  .  valueOf  (  tagName  )  ,  baseUri  (  )  )  ;  [ATTENTION]  return  child  ;    }    [METHOD]  appendElement  [TYPE]  Element  [PARAMETER]  String  tagName  [CLASS]  Element    [TYPE]  Set  classNames  [TYPE]  Tag  tag  [TYPE]  String  tagName  [TYPE]  boolean  false  true  [TYPE]  Element  child  
[REPLACE]  return  child;	[BUGGY]  return  text  (  )  ;  [CE]  incompatible  types  [CONTEXT]  public  Element  appendElement  (  String  tagName  )  {  Element  child  =  new  Element  (  Tag  .  valueOf  (  tagName  )  ,  baseUri  (  )  )  ;  appendChild  (  child  )  ;  [ATTENTION]  return  text  (  )    ;  }    [METHOD]  appendElement  [TYPE]  Element  [PARAMETER]  String  tagName  [CLASS]  Element    [TYPE]  Set  classNames  [TYPE]  Tag  tag  [TYPE]  String  tagName  [TYPE]  boolean  false  true  [TYPE]  Element  child  
[REPLACE]  Element  child  =  new  Element  (  Tag  .  valueOf  (  tagName  )  ,  baseUri  (  )  )  ;	[BUGGY]  Element  child  =  new  Element  (  Tag  .  hashCode  (  )    ,  baseUri  (  )  )  ;  [CE]  non-static  method  hashCode()  cannot  be  referenced  from  a  static  context  [CONTEXT]  public  Element  prependElement  (  String  tagName  )  {  [ATTENTION]  Element  child  =  new  Element  (  Tag  .  hashCode  (  )  ,  baseUri  (  )  )    ;  prependChild  (  child  )  ;  return  child  ;  }    [METHOD]  prependElement  [TYPE]  Element  [PARAMETER]  String  tagName  [CLASS]  Element    [TYPE]  Set  classNames  [TYPE]  Tag  tag  [TYPE]  String  tagName  [TYPE]  boolean  false  true  [TYPE]  Element  child  
[ADD]  Element  child  =  new  Element  (  Tag  .  valueOf  (  tagName  )  ,  baseUri  (  )  )  ;	[BUGGY]  [CE]  cannot  find  symbol  child  [CONTEXT]  public  Element  prependElement  (  String  tagName  )  {  [ATTENTION]  prependChild  (  child  )  ;  return  child  ;  }    [METHOD]  prependElement  [TYPE]  Element  [PARAMETER]  String  tagName  [CLASS]  Element    [TYPE]  Set  classNames  [TYPE]  Tag  tag  [TYPE]  String  tagName  [TYPE]  boolean  false  true  [TYPE]  Element  child  
[REPLACE]  prependChild  (  child  )  ;	[BUGGY]  appendChild  (  child  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  Element  prependElement  (  String  tagName  )  {  Element  child  =  new  Element  (  Tag  .  valueOf  (  tagName  )  ,  baseUri  (  )  )  ;  [ATTENTION]  appendChild  (  child  )    ;  return  child  ;  }    [METHOD]  prependElement  [TYPE]  Element  [PARAMETER]  String  tagName  [CLASS]  Element    [TYPE]  Set  classNames  [TYPE]  Tag  tag  [TYPE]  String  tagName  [TYPE]  boolean  false  true  [TYPE]  Element  child  
[ADD]  prependChild  (  child  )  ;  return  child;	[BUGGY]  return  child  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  Element  prependElement  (  String  tagName  )  {  Element  child  =  new  Element  (  Tag  .  valueOf  (  tagName  )  ,  baseUri  (  )  )  ;  [ATTENTION]  return  child  ;    }    [METHOD]  prependElement  [TYPE]  Element  [PARAMETER]  String  tagName  [CLASS]  Element    [TYPE]  Set  classNames  [TYPE]  Tag  tag  [TYPE]  String  tagName  [TYPE]  boolean  false  true  [TYPE]  Element  child  
[REPLACE]  return  child;	[BUGGY]  return  text  (  )  ;  [CE]  incompatible  types  [CONTEXT]  public  Element  prependElement  (  String  tagName  )  {  Element  child  =  new  Element  (  Tag  .  valueOf  (  tagName  )  ,  baseUri  (  )  )  ;  prependChild  (  child  )  ;  [ATTENTION]  return  text  (  )    ;  }    [METHOD]  prependElement  [TYPE]  Element  [PARAMETER]  String  tagName  [CLASS]  Element    [TYPE]  Set  classNames  [TYPE]  Tag  tag  [TYPE]  String  tagName  [TYPE]  boolean  false  true  [TYPE]  Element  child  
[REPLACE]  TextNode  node  =  new  TextNode  (  text,  baseUri  (  )  )  ;	[BUGGY]  TextNode  textNode  =  new  TextNode  (  text  ,  baseUri  )  ;  [CE]  cannot  find  symbol  node  [CONTEXT]  public  Element  appendText  (  String  text  )  {  [ATTENTION]  TextNode  textNode  =  new  TextNode  (  text  ,  baseUri  )    ;  appendChild  (  node  )  ;  return  this  ;  }    [METHOD]  appendText  [TYPE]  Element  [PARAMETER]  String  text  [CLASS]  Element    [TYPE]  TextNode  node  [TYPE]  Set  classNames  [TYPE]  Tag  tag  [TYPE]  String  text  [TYPE]  boolean  false  true  
[ADD]  TextNode  node  =  new  TextNode  (  text,  baseUri  (  )  )  ;  appendChild  (  node  )  ;	[BUGGY]  appendChild  (  node  )  ;  [CE]  cannot  find  symbol  node  [CONTEXT]  public  Element  appendText  (  String  text  )  {  [ATTENTION]  appendChild  (  node  )    ;    return  this  ;  }    [METHOD]  appendText  [TYPE]  Element  [PARAMETER]  String  text  [CLASS]  Element    [TYPE]  TextNode  node  [TYPE]  Set  classNames  [TYPE]  Tag  tag  [TYPE]  String  text  [TYPE]  boolean  false  true  
[REPLACE]  appendChild  (  node  )  ;	[BUGGY]  prependChild  (  node  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  Element  appendText  (  String  text  )  {  TextNode  node  =  new  TextNode  (  text  ,  baseUri  (  )  )  ;  [ATTENTION]  prependChild  (  node  )    ;  return  this  ;  }    [METHOD]  appendText  [TYPE]  Element  [PARAMETER]  String  text  [CLASS]  Element    [TYPE]  TextNode  node  [TYPE]  Set  classNames  [TYPE]  Tag  tag  [TYPE]  String  text  [TYPE]  boolean  false  true  
[ADD]  appendChild  (  node  )  ;  return  this;	[BUGGY]  [CE]  missing  return  statement  [CONTEXT]  public  Element  appendText  (  String  text  )  {  TextNode  node  =  new  TextNode  (  text  ,  baseUri  (  )  )  ;  [ATTENTION]    }    [METHOD]  appendText  [TYPE]  Element  [PARAMETER]  String  text  [CLASS]  Element    [TYPE]  TextNode  node  [TYPE]  Set  classNames  [TYPE]  Tag  tag  [TYPE]  String  text  [TYPE]  boolean  false  true  
[REPLACE]  return  this;	[BUGGY]  return  null  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  Element  appendText  (  String  text  )  {  TextNode  node  =  new  TextNode  (  text  ,  baseUri  (  )  )  ;  appendChild  (  node  )  ;  [ATTENTION]  return  null  ;  }    [METHOD]  appendText  [TYPE]  Element  [PARAMETER]  String  text  [CLASS]  Element    [TYPE]  TextNode  node  [TYPE]  Set  classNames  [TYPE]  Tag  tag  [TYPE]  String  text  [TYPE]  boolean  false  true  
[REPLACE]  TextNode  node  =  new  TextNode  (  text,  baseUri  (  )  )  ;	[BUGGY]  TextNode  textNode  =  new  TextNode  (  text  ,  baseUri  )  ;  [CE]  cannot  find  symbol  node  [CONTEXT]  public  Element  prependText  (  String  text  )  {  [ATTENTION]  TextNode  textNode  =  new  TextNode  (  text  ,  baseUri  )    ;  prependChild  (  node  )  ;  return  this  ;  }    [METHOD]  prependText  [TYPE]  Element  [PARAMETER]  String  text  [CLASS]  Element    [TYPE]  TextNode  node  [TYPE]  Set  classNames  [TYPE]  Tag  tag  [TYPE]  String  text  [TYPE]  boolean  false  true  
[REPLACE]  prependChild  (  node  )  ;	[BUGGY]  appendChild  (  node  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  Element  prependText  (  String  text  )  {  TextNode  node  =  new  TextNode  (  text  ,  baseUri  (  )  )  ;  [ATTENTION]  appendChild  (  node  )    ;  return  this  ;  }    [METHOD]  prependText  [TYPE]  Element  [PARAMETER]  String  text  [CLASS]  Element    [TYPE]  TextNode  node  [TYPE]  Set  classNames  [TYPE]  Tag  tag  [TYPE]  String  text  [TYPE]  boolean  false  true  
[REPLACE]  return  this;	[BUGGY]  return  null  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  Element  prependText  (  String  text  )  {  TextNode  node  =  new  TextNode  (  text  ,  baseUri  (  )  )  ;  prependChild  (  node  )  ;  [ATTENTION]  return  null  ;  }    [METHOD]  prependText  [TYPE]  Element  [PARAMETER]  String  text  [CLASS]  Element    [TYPE]  TextNode  node  [TYPE]  Set  classNames  [TYPE]  Tag  tag  [TYPE]  String  text  [TYPE]  boolean  false  true  
[REPLACE]  Validate  .  notNull  (  html  )  ;	[BUGGY]  Validate  .  notEmpty  (  html  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  Element  append  (  String  html  )  {  [ATTENTION]  Validate  .  notEmpty  (  html  )    ;    Element  fragment  =  Parser  .  parseBodyFragment  (  html  ,  baseUri  )  .  body  (  )  ;    for  (  Node  node  :  fragment  .  childNodes  (  )  )  {  node  .  parentNode  =  null  ;  appendChild  (  node  )  ;  }  return  this  ;  }    [METHOD]  append  [TYPE]  Element  [PARAMETER]  String  html  [CLASS]  Element    [TYPE]  Set  classNames  [TYPE]  Tag  tag  [TYPE]  String  html  [TYPE]  boolean  false  true  [TYPE]  Element  fragment  [TYPE]  Node  node  
[REPLACE]  Element  fragment  =  Parser  .  parseBodyFragment  (  html,  baseUri  )    .  body  (  )  ;	[BUGGY]  Element  wrapBody  =  Parser  .  parseBodyFragment  (  html  ,  baseUri  )  .  body  (  )  ;  [CE]  cannot  find  symbol  fragment  [CONTEXT]  public  Element  append  (  String  html  )  {  Validate  .  notNull  (  html  )  ;    [ATTENTION]  Element  wrapBody  =  Parser  .  parseBodyFragment  (  html  ,  baseUri  )    .  body  (  )    ;    for  (  Node  node  :  fragment  .  childNodes  (  )  )  {  node  .  parentNode  =  null  ;  appendChild  (  node  )  ;  }  return  this  ;  }    [METHOD]  append  [TYPE]  Element  [PARAMETER]  String  html  [CLASS]  Element    [TYPE]  Set  classNames  [TYPE]  Tag  tag  [TYPE]  String  html  [TYPE]  boolean  false  true  [TYPE]  Element  fragment  [TYPE]  Node  node  
[REPLACE]  node  .  parentNode  =  null;	[BUGGY]  node  .  parentNode  =  this  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  Element  append  (  String  html  )  {  Validate  .  notNull  (  html  )  ;    Element  fragment  =  Parser  .  parseBodyFragment  (  html  ,  baseUri  )  .  body  (  )  ;    for  (  Node  node  :  fragment  .  childNodes  (  )  )  {  [ATTENTION]  node  .  parentNode  =  this  ;  appendChild  (  node  )  ;  }  return  this  ;  }    [METHOD]  append  [TYPE]  Element  [PARAMETER]  String  html  [CLASS]  Element    [TYPE]  Set  classNames  [TYPE]  Tag  tag  [TYPE]  String  html  [TYPE]  boolean  false  true  [TYPE]  Element  fragment  [TYPE]  Node  node  
[REPLACE]  for  (  Node  node  :  fragment  .  childNodes  (  )  )  {	[BUGGY]  Node  node  =  nodes  .  get  (  i  )  ;  [CE]  illegal  start  of  type  [CONTEXT]  public  Element  append  (  String  html  )  {  Validate  .  notNull  (  html  )  ;    Element  fragment  =  Parser  .  parseBodyFragment  (  html  ,  baseUri  )  .  body  (  )  ;    [ATTENTION]  Node  node  =  nodes  .  get  (  i  )    ;  node  .  parentNode  =  null  ;  appendChild  (  node  )  ;  }  return  this  ;  }    [METHOD]  append  [TYPE]  Element  [PARAMETER]  String  html  [CLASS]  Element    [TYPE]  Set  classNames  [TYPE]  Tag  tag  [TYPE]  String  html  [TYPE]  boolean  false  true  [TYPE]  Element  fragment  [TYPE]  Node  node  
[REPLACE]  return  this;	[BUGGY]  return  null  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  Element  append  (  String  html  )  {  Validate  .  notNull  (  html  )  ;    Element  fragment  =  Parser  .  parseBodyFragment  (  html  ,  baseUri  )  .  body  (  )  ;    for  (  Node  node  :  fragment  .  childNodes  (  )  )  {  node  .  parentNode  =  null  ;  appendChild  (  node  )  ;  }  [ATTENTION]  return  null  ;  }    [METHOD]  append  [TYPE]  Element  [PARAMETER]  String  html  [CLASS]  Element    [TYPE]  Set  classNames  [TYPE]  Tag  tag  [TYPE]  String  html  [TYPE]  boolean  false  true  [TYPE]  Element  fragment  [TYPE]  Node  node  
[REPLACE]  Validate  .  notNull  (  html  )  ;	[BUGGY]  Validate  .  notEmpty  (  html  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  Element  prepend  (  String  html  )  {  [ATTENTION]  Validate  .  notEmpty  (  html  )    ;    Element  fragment  =  Parser  .  parseBodyFragment  (  html  ,  baseUri  )  .  body  (  )  ;    List<Node>  nodes  =  fragment  .  childNodes  (  )  ;  for  (  int  i  =  nodes  .  size  (  )  -  1  ;  i  >  =  0  ;  i--  )  {  Node  node  =  nodes  .  get  (  i  )  ;  node  .  parentNode  =  null  ;  prependChild  (  node  )  ;  }  return  this  ;  }    [METHOD]  prepend  [TYPE]  Element  [PARAMETER]  String  html  [CLASS]  Element    [TYPE]  Set  classNames  [TYPE]  boolean  false  true  [TYPE]  Element  fragment  [TYPE]  Node  node  [TYPE]  List  nodes  [TYPE]  Tag  tag  [TYPE]  String  html  [TYPE]  int  i  
[REPLACE]  Element  fragment  =  Parser  .  parseBodyFragment  (  html,  baseUri  )    .  body  (  )  ;	[BUGGY]  Element  wrapBody  =  Parser  .  parseBodyFragment  (  html  ,  baseUri  )  .  body  (  )  ;  [CE]  cannot  find  symbol  fragment  [CONTEXT]  public  Element  prepend  (  String  html  )  {  Validate  .  notNull  (  html  )  ;    [ATTENTION]  Element  wrapBody  =  Parser  .  parseBodyFragment  (  html  ,  baseUri  )    .  body  (  )    ;    List<Node>  nodes  =  fragment  .  childNodes  (  )  ;  for  (  int  i  =  nodes  .  size  (  )  -  1  ;  i  >  =  0  ;  i--  )  {  Node  node  =  nodes  .  get  (  i  )  ;  node  .  parentNode  =  null  ;  prependChild  (  node  )  ;  }  return  this  ;  }    [METHOD]  prepend  [TYPE]  Element  [PARAMETER]  String  html  [CLASS]  Element    [TYPE]  Set  classNames  [TYPE]  boolean  false  true  [TYPE]  Element  fragment  [TYPE]  Node  node  [TYPE]  List  nodes  [TYPE]  Tag  tag  [TYPE]  String  html  [TYPE]  int  i  
[REPLACE]  List<Node>  nodes  =  fragment  .  childNodes  (  )  ;	[BUGGY]  List<Node>  nodes  =  fragment  .  siblingIndex  (  )  ;  [CE]  incompatible  types  [CONTEXT]  public  Element  prepend  (  String  html  )  {  Validate  .  notNull  (  html  )  ;    Element  fragment  =  Parser  .  parseBodyFragment  (  html  ,  baseUri  )  .  body  (  )  ;    [ATTENTION]  List<Node>  nodes  =  fragment  .  siblingIndex  (  )    ;  for  (  int  i  =  nodes  .  size  (  )  -  1  ;  i  >  =  0  ;  i--  )  {  Node  node  =  nodes  .  get  (  i  )  ;  node  .  parentNode  =  null  ;  prependChild  (  node  )  ;  }  return  this  ;  }    [METHOD]  prepend  [TYPE]  Element  [PARAMETER]  String  html  [CLASS]  Element    [TYPE]  Set  classNames  [TYPE]  boolean  false  true  [TYPE]  Element  fragment  [TYPE]  Node  node  [TYPE]  List  nodes  [TYPE]  Tag  tag  [TYPE]  String  html  [TYPE]  int  i  
[REPLACE]  for  (  int  i  =  nodes  .  size  (  )  -  1;  i  >=  0;  i--  )  {	[BUGGY]  for  (  int  i  =  nodes  .  size  (  )  /  0  .  5  -  1  ;  i  >  =  0  ;  i--  )  {[CE]  possible  loss  of  precision  [CONTEXT]  public  Element  prepend  (  String  html  )  {  Validate  .  notNull  (  html  )  ;    Element  fragment  =  Parser  .  parseBodyFragment  (  html  ,  baseUri  )  .  body  (  )  ;    List<Node>  nodes  =  fragment  .  childNodes  (  )  ;  [ATTENTION]  for  (  int  i  =  nodes  .  size  (  )  /0  .  5-  1  ;  i  >  =  0  ;  i--  )  {  Node  node  =  nodes  .  get  (  i  )  ;  node  .  parentNode  =  null  ;  prependChild  (  node  )  ;  }  return  this  ;  }    [METHOD]  prepend  [TYPE]  Element  [PARAMETER]  String  html  [CLASS]  Element    [TYPE]  Set  classNames  [TYPE]  boolean  false  true  [TYPE]  Element  fragment  [TYPE]  Node  node  [TYPE]  List  nodes  [TYPE]  Tag  tag  [TYPE]  String  html  [TYPE]  int  i  
[REPLACE]  node  .  parentNode  =  null;	[BUGGY]  node  .  parentNode  =  true  ;  [CE]  incompatible  types  [CONTEXT]  public  Element  prepend  (  String  html  )  {  Validate  .  notNull  (  html  )  ;    Element  fragment  =  Parser  .  parseBodyFragment  (  html  ,  baseUri  )  .  body  (  )  ;    List<Node>  nodes  =  fragment  .  childNodes  (  )  ;  for  (  int  i  =  nodes  .  size  (  )  -  1  ;  i  >  =  0  ;  i--  )  {  Node  node  =  nodes  .  get  (  i  )  ;  [ATTENTION]  node  .  parentNode  =  true  ;  prependChild  (  node  )  ;  }  return  this  ;  }    [METHOD]  prepend  [TYPE]  Element  [PARAMETER]  String  html  [CLASS]  Element    [TYPE]  Set  classNames  [TYPE]  boolean  false  true  [TYPE]  Element  fragment  [TYPE]  Node  node  [TYPE]  List  nodes  [TYPE]  Tag  tag  [TYPE]  String  html  [TYPE]  int  i  
[ADD]  node  .  parentNode  =  null;	[BUGGY]  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  Element  prepend  (  String  html  )  {  Validate  .  notNull  (  html  )  ;    Element  fragment  =  Parser  .  parseBodyFragment  (  html  ,  baseUri  )  .  body  (  )  ;    List<Node>  nodes  =  fragment  .  childNodes  (  )  ;  for  (  int  i  =  nodes  .  size  (  )  -  1  ;  i  >  =  0  ;  i--  )  {  Node  node  =  nodes  .  get  (  i  )  ;  [ATTENTION]  prependChild  (  node  )  ;  }  return  this  ;  }    [METHOD]  prepend  [TYPE]  Element  [PARAMETER]  String  html  [CLASS]  Element    [TYPE]  Set  classNames  [TYPE]  boolean  false  true  [TYPE]  Element  fragment  [TYPE]  Node  node  [TYPE]  List  nodes  [TYPE]  Tag  tag  [TYPE]  String  html  [TYPE]  int  i  
[REPLACE]  Node  node  =  nodes  .  get  (  i  )  ;	[BUGGY]  Node  node  =  true  .  get  (  i  )  ;  [CE]  boolean  cannot  be  dereferenced  [CONTEXT]  public  Element  prepend  (  String  html  )  {  Validate  .  notNull  (  html  )  ;    Element  fragment  =  Parser  .  parseBodyFragment  (  html  ,  baseUri  )  .  body  (  )  ;    List<Node>  nodes  =  fragment  .  childNodes  (  )  ;  for  (  int  i  =  nodes  .  size  (  )  -  1  ;  i  >  =  0  ;  i--  )  {  [ATTENTION]  Node  node  =  true  .  get  (  i  )    ;  node  .  parentNode  =  null  ;  prependChild  (  node  )  ;  }  return  this  ;  }    [METHOD]  prepend  [TYPE]  Element  [PARAMETER]  String  html  [CLASS]  Element    [TYPE]  Set  classNames  [TYPE]  boolean  false  true  [TYPE]  Element  fragment  [TYPE]  Node  node  [TYPE]  List  nodes  [TYPE]  Tag  tag  [TYPE]  String  html  [TYPE]  int  i  
[REPLACE]  for  (  int  i  =  nodes  .  size  (  )  -  1;  i  >=  0;  i--  )  {	[BUGGY]  for  (  int  i  =  nodes  .  size  (  )  %  0  .  5  -  1  ;  i  >  =  0  ;  i--  )  {[CE]  possible  loss  of  precision  [CONTEXT]  public  Element  prepend  (  String  html  )  {  Validate  .  notNull  (  html  )  ;    Element  fragment  =  Parser  .  parseBodyFragment  (  html  ,  baseUri  )  .  body  (  )  ;    List<Node>  nodes  =  fragment  .  childNodes  (  )  ;  [ATTENTION]  for  (  int  i  =  nodes  .  size  (  )  %0  .  5-  1  ;  i  >  =  0  ;  i--  )  {  Node  node  =  nodes  .  get  (  i  )  ;  node  .  parentNode  =  null  ;  prependChild  (  node  )  ;  }  return  this  ;  }    [METHOD]  prepend  [TYPE]  Element  [PARAMETER]  String  html  [CLASS]  Element    [TYPE]  Set  classNames  [TYPE]  boolean  false  true  [TYPE]  Element  fragment  [TYPE]  Node  node  [TYPE]  List  nodes  [TYPE]  Tag  tag  [TYPE]  String  html  [TYPE]  int  i  
[REPLACE]  Node  node  =  nodes  .  get  (  i  )  ;	[BUGGY]  Node  node  =  nodes  .  add  (  i  )  ;  [CE]  no  suitable  method  found  for  add(int)  [CONTEXT]  public  Element  prepend  (  String  html  )  {  Validate  .  notNull  (  html  )  ;    Element  fragment  =  Parser  .  parseBodyFragment  (  html  ,  baseUri  )  .  body  (  )  ;    List<Node>  nodes  =  fragment  .  childNodes  (  )  ;  for  (  int  i  =  nodes  .  size  (  )  -  1  ;  i  >  =  0  ;  i--  )  {  [ATTENTION]  Node  node  =  nodes  .  add  (  i  )    ;  node  .  parentNode  =  null  ;  prependChild  (  node  )  ;  }  return  this  ;  }    [METHOD]  prepend  [TYPE]  Element  [PARAMETER]  String  html  [CLASS]  Element    [TYPE]  Set  classNames  [TYPE]  boolean  false  true  [TYPE]  Element  fragment  [TYPE]  Node  node  [TYPE]  List  nodes  [TYPE]  Tag  tag  [TYPE]  String  html  [TYPE]  int  i  
[ADD]  Node  node  =  nodes  .  get  (  i  )  ;	[BUGGY]  [CE]  cannot  find  symbol  node  [CONTEXT]  public  Element  prepend  (  String  html  )  {  Validate  .  notNull  (  html  )  ;    Element  fragment  =  Parser  .  parseBodyFragment  (  html  ,  baseUri  )  .  body  (  )  ;    List<Node>  nodes  =  fragment  .  childNodes  (  )  ;  for  (  int  i  =  nodes  .  size  (  )  -  1  ;  i  >  =  0  ;  i--  )  {  [ATTENTION]  node  .  parentNode  =  null  ;  prependChild  (  node  )  ;  }  return  this  ;  }    [METHOD]  prepend  [TYPE]  Element  [PARAMETER]  String  html  [CLASS]  Element    [TYPE]  Set  classNames  [TYPE]  boolean  false  true  [TYPE]  Element  fragment  [TYPE]  Node  node  [TYPE]  List  nodes  [TYPE]  Tag  tag  [TYPE]  String  html  [TYPE]  int  i  
[REPLACE]  return  this;	[BUGGY]  return  null  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  Element  prepend  (  String  html  )  {  Validate  .  notNull  (  html  )  ;    Element  fragment  =  Parser  .  parseBodyFragment  (  html  ,  baseUri  )  .  body  (  )  ;    List<Node>  nodes  =  fragment  .  childNodes  (  )  ;  for  (  int  i  =  nodes  .  size  (  )  -  1  ;  i  >  =  0  ;  i--  )  {  Node  node  =  nodes  .  get  (  i  )  ;  node  .  parentNode  =  null  ;  prependChild  (  node  )  ;  }  [ATTENTION]  return  null  ;  }    [METHOD]  prepend  [TYPE]  Element  [PARAMETER]  String  html  [CLASS]  Element    [TYPE]  Set  classNames  [TYPE]  boolean  false  true  [TYPE]  Element  fragment  [TYPE]  Node  node  [TYPE]  List  nodes  [TYPE]  Tag  tag  [TYPE]  String  html  [TYPE]  int  i  
[REPLACE]  childNodes  .  clear  (  )  ;	[BUGGY]  childNodes  .  isEmpty  (  )    ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  Element  empty  (  )  {  [ATTENTION]  childNodes  .  isEmpty  (  )  ;  return  this  ;  }    [METHOD]  empty  [TYPE]  Element  [PARAMETER]  [CLASS]  Element    [TYPE]  Set  classNames  [TYPE]  Tag  tag  [TYPE]  boolean  false  true  
[REPLACE]  return  this;	[BUGGY]  return  null  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  Element  empty  (  )  {  childNodes  .  clear  (  )  ;  [ATTENTION]  return  null  ;  }    [METHOD]  empty  [TYPE]  Element  [PARAMETER]  [CLASS]  Element    [TYPE]  Set  classNames  [TYPE]  Tag  tag  [TYPE]  boolean  false  true  
[REPLACE]  Validate  .  notEmpty  (  html  )  ;	[BUGGY]  Validate  .  notNull  (  html  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  Element  wrap  (  String  html  )  {  [ATTENTION]  Validate  .  notNull  (  html  )    ;    Element  wrapBody  =  Parser  .  parseBodyFragment  (  html  ,  baseUri  )  .  body  (  )  ;  Elements  wrapChildren  =  wrapBody  .  children  (  )  ;  Element  wrap  =  wrapChildren  .  first  (  )  ;  if  (  wrap  =  =  null  )  //  nothing  to  wrap  with  ;  noop  return  null  ;    Element  deepest  =  getDeepChild  (  wrap  )  ;  parentNode  .  replaceChild  (  this  ,  wrap  )  ;  deepest  .  addChild  (  this  )  ;      if  (  wrapChildren  .  size  (  )  >  1  )  {  for  (  int  i  =  1  ;  i  <  wrapChildren  .  size  (  )  ;  i++  )  {  //  skip  first  Element  remainder  =  wrapChildren  .  get  (  i  )  ;  remainder  .  parentNode  .  removeChild  (  remainder  )  ;  wrap  .  appendChild  (  remainder  )  ;  }  }  return  this  ;  }    [METHOD]  wrap  [TYPE]  Element  [PARAMETER]  String  html  [CLASS]  Element    [TYPE]  Set  classNames  [TYPE]  boolean  false  true  [TYPE]  Element  deepest  remainder  wrap  wrapBody  [TYPE]  Tag  tag  [TYPE]  String  html  [TYPE]  Elements  wrapChildren  [TYPE]  int  i  
[REPLACE]  Element  wrapBody  =  Parser  .  parseBodyFragment  (  html,  baseUri  )    .  body  (  )  ;	[BUGGY]  Element  fragment  =  Parser  .  parseBodyFragment  (  html  ,  baseUri  )  .  body  (  )  ;  [CE]  cannot  find  symbol  wrapBody  [CONTEXT]  public  Element  wrap  (  String  html  )  {  Validate  .  notEmpty  (  html  )  ;    [ATTENTION]  Element  fragment  =  Parser  .  parseBodyFragment  (  html  ,  baseUri  )    .  body  (  )    ;  Elements  wrapChildren  =  wrapBody  .  children  (  )  ;  Element  wrap  =  wrapChildren  .  first  (  )  ;  if  (  wrap  =  =  null  )  //  nothing  to  wrap  with  ;  noop  return  null  ;    Element  deepest  =  getDeepChild  (  wrap  )  ;  parentNode  .  replaceChild  (  this  ,  wrap  )  ;  deepest  .  addChild  (  this  )  ;      if  (  wrapChildren  .  size  (  )  >  1  )  {  for  (  int  i  =  1  ;  i  <  wrapChildren  .  size  (  )  ;  i++  )  {  //  skip  first  Element  remainder  =  wrapChildren  .  get  (  i  )  ;  remainder  .  parentNode  .  removeChild  (  remainder  )  ;  wrap  .  appendChild  (  remainder  )  ;  }  }  return  this  ;  }    [METHOD]  wrap  [TYPE]  Element  [PARAMETER]  String  html  [CLASS]  Element    [TYPE]  Set  classNames  [TYPE]  boolean  false  true  [TYPE]  Element  deepest  remainder  wrap  wrapBody  [TYPE]  Tag  tag  [TYPE]  String  html  [TYPE]  Elements  wrapChildren  [TYPE]  int  i  
[REPLACE]  Elements  wrapChildren  =  wrapBody  .  children  (  )  ;	[BUGGY]  Elements  wrapChildren  =  wrap  .  children  (  )  ;  [CE]  cannot  find  symbol  wrap  [CONTEXT]  public  Element  wrap  (  String  html  )  {  Validate  .  notEmpty  (  html  )  ;    Element  wrapBody  =  Parser  .  parseBodyFragment  (  html  ,  baseUri  )  .  body  (  )  ;  [ATTENTION]  Elements  wrapChildren  =  wrap  .  children  (  )    ;  Element  wrap  =  wrapChildren  .  first  (  )  ;  if  (  wrap  =  =  null  )  //  nothing  to  wrap  with  ;  noop  return  null  ;    Element  deepest  =  getDeepChild  (  wrap  )  ;  parentNode  .  replaceChild  (  this  ,  wrap  )  ;  deepest  .  addChild  (  this  )  ;      if  (  wrapChildren  .  size  (  )  >  1  )  {  for  (  int  i  =  1  ;  i  <  wrapChildren  .  size  (  )  ;  i++  )  {  //  skip  first  Element  remainder  =  wrapChildren  .  get  (  i  )  ;  remainder  .  parentNode  .  removeChild  (  remainder  )  ;  wrap  .  appendChild  (  remainder  )  ;  }  }  return  this  ;  }    [METHOD]  wrap  [TYPE]  Element  [PARAMETER]  String  html  [CLASS]  Element    [TYPE]  Set  classNames  [TYPE]  boolean  false  true  [TYPE]  Element  deepest  remainder  wrap  wrapBody  [TYPE]  Tag  tag  [TYPE]  String  html  [TYPE]  Elements  wrapChildren  [TYPE]  int  i  
[ADD]  Elements  wrapChildren  =  wrapBody  .  children  (  )  ;  Element  wrap  =  wrapChildren  .  first  (  )  ;	[BUGGY]  [CE]  cannot  find  symbol  wrap  [CONTEXT]  public  Element  wrap  (  String  html  )  {  Validate  .  notEmpty  (  html  )  ;    Element  wrapBody  =  Parser  .  parseBodyFragment  (  html  ,  baseUri  )  .  body  (  )  ;  [ATTENTION]    if  (  wrap  =  =  null  )  //  nothing  to  wrap  with  ;  noop  return  null  ;    Element  deepest  =  getDeepChild  (  wrap  )  ;  parentNode  .  replaceChild  (  this  ,  wrap  )  ;  deepest  .  addChild  (  this  )  ;      if  (  wrapChildren  .  size  (  )  >  1  )  {  for  (  int  i  =  1  ;  i  <  wrapChildren  .  size  (  )  ;  i++  )  {  //  skip  first  Element  remainder  =  wrapChildren  .  get  (  i  )  ;  remainder  .  parentNode  .  removeChild  (  remainder  )  ;  wrap  .  appendChild  (  remainder  )  ;  }  }  return  this  ;  }    [METHOD]  wrap  [TYPE]  Element  [PARAMETER]  String  html  [CLASS]  Element    [TYPE]  Set  classNames  [TYPE]  boolean  false  true  [TYPE]  Element  deepest  remainder  wrap  wrapBody  [TYPE]  Tag  tag  [TYPE]  String  html  [TYPE]  Elements  wrapChildren  [TYPE]  int  i  
[REPLACE]  Element  wrap  =  wrapChildren  .  first  (  )  ;	[BUGGY]  Element  wrap  =  wrapChildren  .  size  (  )  ;  [CE]  incompatible  types  [CONTEXT]  public  Element  wrap  (  String  html  )  {  Validate  .  notEmpty  (  html  )  ;    Element  wrapBody  =  Parser  .  parseBodyFragment  (  html  ,  baseUri  )  .  body  (  )  ;  Elements  wrapChildren  =  wrapBody  .  children  (  )  ;  [ATTENTION]  Element  wrap  =  wrapChildren  .  size  (  )    ;  if  (  wrap  =  =  null  )  //  nothing  to  wrap  with  ;  noop  return  null  ;    Element  deepest  =  getDeepChild  (  wrap  )  ;  parentNode  .  replaceChild  (  this  ,  wrap  )  ;  deepest  .  addChild  (  this  )  ;      if  (  wrapChildren  .  size  (  )  >  1  )  {  for  (  int  i  =  1  ;  i  <  wrapChildren  .  size  (  )  ;  i++  )  {  //  skip  first  Element  remainder  =  wrapChildren  .  get  (  i  )  ;  remainder  .  parentNode  .  removeChild  (  remainder  )  ;  wrap  .  appendChild  (  remainder  )  ;  }  }  return  this  ;  }    [METHOD]  wrap  [TYPE]  Element  [PARAMETER]  String  html  [CLASS]  Element    [TYPE]  Set  classNames  [TYPE]  boolean  false  true  [TYPE]  Element  deepest  remainder  wrap  wrapBody  [TYPE]  Tag  tag  [TYPE]  String  html  [TYPE]  Elements  wrapChildren  [TYPE]  int  i  
[REPLACE]  if  (  wrap  ==  null  )  return  null;	[BUGGY]  if  (  wrap  !  =  null  )  return  null  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  Element  wrap  (  String  html  )  {  Validate  .  notEmpty  (  html  )  ;    Element  wrapBody  =  Parser  .  parseBodyFragment  (  html  ,  baseUri  )  .  body  (  )  ;  Elements  wrapChildren  =  wrapBody  .  children  (  )  ;  Element  wrap  =  wrapChildren  .  first  (  )  ;  [ATTENTION]  if  (  wrap  !  =  null  )  return  null  ;    Element  deepest  =  getDeepChild  (  wrap  )  ;  parentNode  .  replaceChild  (  this  ,  wrap  )  ;  deepest  .  addChild  (  this  )  ;      if  (  wrapChildren  .  size  (  )  >  1  )  {  for  (  int  i  =  1  ;  i  <  wrapChildren  .  size  (  )  ;  i++  )  {  //  skip  first  Element  remainder  =  wrapChildren  .  get  (  i  )  ;  remainder  .  parentNode  .  removeChild  (  remainder  )  ;  wrap  .  appendChild  (  remainder  )  ;  }  }  return  this  ;  }    [METHOD]  wrap  [TYPE]  Element  [PARAMETER]  String  html  [CLASS]  Element    [TYPE]  Set  classNames  [TYPE]  boolean  false  true  [TYPE]  Element  deepest  remainder  wrap  wrapBody  [TYPE]  Tag  tag  [TYPE]  String  html  [TYPE]  Elements  wrapChildren  [TYPE]  int  i  
[REMOVE]  	[BUGGY]  if  (  !  (  super  .  equals  (  o  )  )  )      return  false  ;  [CE]  cannot  find  symbol  o  [CONTEXT]  public  Element  wrap  (  String  html  )  {  Validate  .  notEmpty  (  html  )  ;    Element  wrapBody  =  Parser  .  parseBodyFragment  (  html  ,  baseUri  )  .  body  (  )  ;  Elements  wrapChildren  =  wrapBody  .  children  (  )  ;  Element  wrap  =  wrapChildren  .  first  (  )  ;  [ATTENTION]  if  (  wrap  =  =  null  )  //  nothing  to  wrap  with  ;  noop  if  (  !  (  super  .  equals  (  o  )  )  )  return  false  ;  return  null  ;    Element  deepest  =  getDeepChild  (  wrap  )  ;  parentNode  .  replaceChild  (  this  ,  wrap  )  ;  deepest  .  addChild  (  this  )  ;      if  (  wrapChildren  .  size  (  )  >  1  )  {  for  (  int  i  =  1  ;  i  <  wrapChildren  .  size  (  )  ;  i++  )  {  //  skip  first  Element  remainder  =  wrapChildren  .  get  (  i  )  ;  remainder  .  parentNode  .  removeChild  (  remainder  )  ;  wrap  .  appendChild  (  remainder  )  ;  }  }  return  this  ;      [METHOD]  wrap  [TYPE]  Element  [PARAMETER]  String  html  [CLASS]  Element    [TYPE]  Set  classNames  [TYPE]  boolean  false  true  [TYPE]  Element  deepest  remainder  wrap  wrapBody  [TYPE]  Tag  tag  [TYPE]  String  html  [TYPE]  Elements  wrapChildren  [TYPE]  int  i  
[REPLACE]  return  null;	[BUGGY]  return  this  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  Element  wrap  (  String  html  )  {  Validate  .  notEmpty  (  html  )  ;    Element  wrapBody  =  Parser  .  parseBodyFragment  (  html  ,  baseUri  )  .  body  (  )  ;  Elements  wrapChildren  =  wrapBody  .  children  (  )  ;  Element  wrap  =  wrapChildren  .  first  (  )  ;  if  (  wrap  =  =  null  )  //  nothing  to  wrap  with  ;  noop  [ATTENTION]  return  this  ;    Element  deepest  =  getDeepChild  (  wrap  )  ;  parentNode  .  replaceChild  (  this  ,  wrap  )  ;  deepest  .  addChild  (  this  )  ;      if  (  wrapChildren  .  size  (  )  >  1  )  {  for  (  int  i  =  1  ;  i  <  wrapChildren  .  size  (  )  ;  i++  )  {  //  skip  first  Element  remainder  =  wrapChildren  .  get  (  i  )  ;  remainder  .  parentNode  .  removeChild  (  remainder  )  ;  wrap  .  appendChild  (  remainder  )  ;  }  }  return  this  ;  }    [METHOD]  wrap  [TYPE]  Element  [PARAMETER]  String  html  [CLASS]  Element    [TYPE]  Set  classNames  [TYPE]  boolean  false  true  [TYPE]  Element  deepest  remainder  wrap  wrapBody  [TYPE]  Tag  tag  [TYPE]  String  html  [TYPE]  Elements  wrapChildren  [TYPE]  int  i  
[REPLACE]  return  null;	[BUGGY]  return  true  ;  [CE]  incompatible  types  [CONTEXT]  public  Element  wrap  (  String  html  )  {  Validate  .  notEmpty  (  html  )  ;    Element  wrapBody  =  Parser  .  parseBodyFragment  (  html  ,  baseUri  )  .  body  (  )  ;  Elements  wrapChildren  =  wrapBody  .  children  (  )  ;  Element  wrap  =  wrapChildren  .  first  (  )  ;  if  (  wrap  =  =  null  )  //  nothing  to  wrap  with  ;  noop  [ATTENTION]  return  true  ;    Element  deepest  =  getDeepChild  (  wrap  )  ;  parentNode  .  replaceChild  (  this  ,  wrap  )  ;  deepest  .  addChild  (  this  )  ;      if  (  wrapChildren  .  size  (  )  >  1  )  {  for  (  int  i  =  1  ;  i  <  wrapChildren  .  size  (  )  ;  i++  )  {  //  skip  first  Element  remainder  =  wrapChildren  .  get  (  i  )  ;  remainder  .  parentNode  .  removeChild  (  remainder  )  ;  wrap  .  appendChild  (  remainder  )  ;  }  }  return  this  ;  }    [METHOD]  wrap  [TYPE]  Element  [PARAMETER]  String  html  [CLASS]  Element    [TYPE]  Set  classNames  [TYPE]  boolean  false  true  [TYPE]  Element  deepest  remainder  wrap  wrapBody  [TYPE]  Tag  tag  [TYPE]  String  html  [TYPE]  Elements  wrapChildren  [TYPE]  int  i  
[REPLACE]  Element  deepest  =  getDeepChild  (  wrap  )  ;	[BUGGY]  Element  deepest  =  getDeepChild  (  wrapBody  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  Element  wrap  (  String  html  )  {  Validate  .  notEmpty  (  html  )  ;    Element  wrapBody  =  Parser  .  parseBodyFragment  (  html  ,  baseUri  )  .  body  (  )  ;  Elements  wrapChildren  =  wrapBody  .  children  (  )  ;  Element  wrap  =  wrapChildren  .  first  (  )  ;  if  (  wrap  =  =  null  )  //  nothing  to  wrap  with  ;  noop  return  null  ;    [ATTENTION]  Element  deepest  =  getDeepChild  (  wrapBody  )    ;  parentNode  .  replaceChild  (  this  ,  wrap  )  ;  deepest  .  addChild  (  this  )  ;      if  (  wrapChildren  .  size  (  )  >  1  )  {  for  (  int  i  =  1  ;  i  <  wrapChildren  .  size  (  )  ;  i++  )  {  //  skip  first  Element  remainder  =  wrapChildren  .  get  (  i  )  ;  remainder  .  parentNode  .  removeChild  (  remainder  )  ;  wrap  .  appendChild  (  remainder  )  ;  }  }  return  this  ;  }    [METHOD]  wrap  [TYPE]  Element  [PARAMETER]  String  html  [CLASS]  Element    [TYPE]  Set  classNames  [TYPE]  boolean  false  true  [TYPE]  Element  deepest  remainder  wrap  wrapBody  [TYPE]  Tag  tag  [TYPE]  String  html  [TYPE]  Elements  wrapChildren  [TYPE]  int  i  
[ADD]  Element  deepest  =  getDeepChild  (  wrap  )  ;	[BUGGY]  [CE]  cannot  find  symbol  deepest  [CONTEXT]  public  Element  wrap  (  String  html  )  {  Validate  .  notEmpty  (  html  )  ;    Element  wrapBody  =  Parser  .  parseBodyFragment  (  html  ,  baseUri  )  .  body  (  )  ;  Elements  wrapChildren  =  wrapBody  .  children  (  )  ;  Element  wrap  =  wrapChildren  .  first  (  )  ;  if  (  wrap  =  =  null  )  //  nothing  to  wrap  with  ;  noop  return  null  ;    [ATTENTION]  parentNode  .  replaceChild  (  this  ,  wrap  )  ;  deepest  .  addChild  (  this  )  ;      if  (  wrapChildren  .  size  (  )  >  1  )  {  for  (  int  i  =  1  ;  i  <  wrapChildren  .  size  (  )  ;  i++  )  {  //  skip  first  Element  remainder  =  wrapChildren  .  get  (  i  )  ;  remainder  .  parentNode  .  removeChild  (  remainder  )  ;  wrap  .  appendChild  (  remainder  )  ;  }  }  return  this  ;  }    [METHOD]  wrap  [TYPE]  Element  [PARAMETER]  String  html  [CLASS]  Element    [TYPE]  Set  classNames  [TYPE]  boolean  false  true  [TYPE]  Element  deepest  remainder  wrap  wrapBody  [TYPE]  Tag  tag  [TYPE]  String  html  [TYPE]  Elements  wrapChildren  [TYPE]  int  i  
[REPLACE]  parentNode  .  replaceChild  (  this,  wrap  )  ;	[BUGGY]  parentNode  .  replaceChild  (  this  ,  wrapBody  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  Element  wrap  (  String  html  )  {  Validate  .  notEmpty  (  html  )  ;    Element  wrapBody  =  Parser  .  parseBodyFragment  (  html  ,  baseUri  )  .  body  (  )  ;  Elements  wrapChildren  =  wrapBody  .  children  (  )  ;  Element  wrap  =  wrapChildren  .  first  (  )  ;  if  (  wrap  =  =  null  )  //  nothing  to  wrap  with  ;  noop  return  null  ;    Element  deepest  =  getDeepChild  (  wrap  )  ;  [ATTENTION]  parentNode  .  replaceChild  (  this  ,  wrapBody  )    ;  deepest  .  addChild  (  this  )  ;      if  (  wrapChildren  .  size  (  )  >  1  )  {  for  (  int  i  =  1  ;  i  <  wrapChildren  .  size  (  )  ;  i++  )  {  //  skip  first  Element  remainder  =  wrapChildren  .  get  (  i  )  ;  remainder  .  parentNode  .  removeChild  (  remainder  )  ;  wrap  .  appendChild  (  remainder  )  ;  }  }  return  this  ;  }    [METHOD]  wrap  [TYPE]  Element  [PARAMETER]  String  html  [CLASS]  Element    [TYPE]  Set  classNames  [TYPE]  boolean  false  true  [TYPE]  Element  deepest  remainder  wrap  wrapBody  [TYPE]  Tag  tag  [TYPE]  String  html  [TYPE]  Elements  wrapChildren  [TYPE]  int  i  
[REPLACE]  deepest  .  addChild  (  this  )  ;	[BUGGY]  deepest  .  indent  (  this  )  ;  [CE]  method  indent  in  class  Node  cannot  be  applied  to  given  types  ;  [CONTEXT]  public  Element  wrap  (  String  html  )  {  Validate  .  notEmpty  (  html  )  ;    Element  wrapBody  =  Parser  .  parseBodyFragment  (  html  ,  baseUri  )  .  body  (  )  ;  Elements  wrapChildren  =  wrapBody  .  children  (  )  ;  Element  wrap  =  wrapChildren  .  first  (  )  ;  if  (  wrap  =  =  null  )  //  nothing  to  wrap  with  ;  noop  return  null  ;    Element  deepest  =  getDeepChild  (  wrap  )  ;  parentNode  .  replaceChild  (  this  ,  wrap  )  ;  [ATTENTION]  deepest  .  indent  (  this  )    ;      if  (  wrapChildren  .  size  (  )  >  1  )  {  for  (  int  i  =  1  ;  i  <  wrapChildren  .  size  (  )  ;  i++  )  {  //  skip  first  Element  remainder  =  wrapChildren  .  get  (  i  )  ;  remainder  .  parentNode  .  removeChild  (  remainder  )  ;  wrap  .  appendChild  (  remainder  )  ;  }  }  return  this  ;  }    [METHOD]  wrap  [TYPE]  Element  [PARAMETER]  String  html  [CLASS]  Element    [TYPE]  Set  classNames  [TYPE]  boolean  false  true  [TYPE]  Element  deepest  remainder  wrap  wrapBody  [TYPE]  Tag  tag  [TYPE]  String  html  [TYPE]  Elements  wrapChildren  [TYPE]  int  i  
[REPLACE]  if  (  wrapChildren  .  size  (  )  >  1  )  {	[BUGGY]  if  (  wrapChildren  .  size  (  )  /  0  .  5  >  1  )  {[FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  Element  wrap  (  String  html  )  {  Validate  .  notEmpty  (  html  )  ;    Element  wrapBody  =  Parser  .  parseBodyFragment  (  html  ,  baseUri  )  .  body  (  )  ;  Elements  wrapChildren  =  wrapBody  .  children  (  )  ;  Element  wrap  =  wrapChildren  .  first  (  )  ;  if  (  wrap  =  =  null  )  //  nothing  to  wrap  with  ;  noop  return  null  ;    Element  deepest  =  getDeepChild  (  wrap  )  ;  parentNode  .  replaceChild  (  this  ,  wrap  )  ;  deepest  .  addChild  (  this  )  ;      [ATTENTION]  if  (  wrapChildren  .  size  (  )  /0  .  5>  1  )  {  for  (  int  i  =  1  ;  i  <  wrapChildren  .  size  (  )  ;  i++  )  {  //  skip  first  Element  remainder  =  wrapChildren  .  get  (  i  )  ;  remainder  .  parentNode  .  removeChild  (  remainder  )  ;  wrap  .  appendChild  (  remainder  )  ;  }  }  return  this  ;  }    [METHOD]  wrap  [TYPE]  Element  [PARAMETER]  String  html  [CLASS]  Element    [TYPE]  Set  classNames  [TYPE]  boolean  false  true  [TYPE]  Element  deepest  remainder  wrap  wrapBody  [TYPE]  Tag  tag  [TYPE]  String  html  [TYPE]  Elements  wrapChildren  [TYPE]  int  i  
[ADD]  if  (  wrapChildren  .  size  (  )  >  1  )  {  for  (  int  i  =  1;  i  <  wrapChildren  .  size  (  )  ;  i++  )  {  Element  remainder  =  wrapChildren  .  get  (  i  )  ;  remainder  .  parentNode  .  removeChild  (  remainder  )  ;  wrap  .  appendChild  (  remainder  )  ;	[BUGGY]  [CE]  class  ,  interface  ,  or  enum  expected  [CONTEXT]  public  Element  wrap  (  String  html  )  {  Validate  .  notEmpty  (  html  )  ;    Element  wrapBody  =  Parser  .  parseBodyFragment  (  html  ,  baseUri  )  .  body  (  )  ;  Elements  wrapChildren  =  wrapBody  .  children  (  )  ;  Element  wrap  =  wrapChildren  .  first  (  )  ;  if  (  wrap  =  =  null  )  //  nothing  to  wrap  with  ;  noop  return  null  ;    Element  deepest  =  getDeepChild  (  wrap  )  ;  parentNode  .  replaceChild  (  this  ,  wrap  )  ;  deepest  .  addChild  (  this  )  ;      [ATTENTION]      }  }  return  this  ;  }    [METHOD]  wrap  [TYPE]  Element  [PARAMETER]  String  html  [CLASS]  Element    [TYPE]  Set  classNames  [TYPE]  boolean  false  true  [TYPE]  Element  deepest  remainder  wrap  wrapBody  [TYPE]  Tag  tag  [TYPE]  String  html  [TYPE]  Elements  wrapChildren  [TYPE]  int  i  
[REPLACE]  for  (  int  i  =  1;  i  <  wrapChildren  .  size  (  )  ;  i++  )  {	[BUGGY]  for  (  int  i  =  1  ;  i  <  wrapChildren  .  size  (  )  +  1  ;  i++  )  {[FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  Element  wrap  (  String  html  )  {  Validate  .  notEmpty  (  html  )  ;    Element  wrapBody  =  Parser  .  parseBodyFragment  (  html  ,  baseUri  )  .  body  (  )  ;  Elements  wrapChildren  =  wrapBody  .  children  (  )  ;  Element  wrap  =  wrapChildren  .  first  (  )  ;  if  (  wrap  =  =  null  )  //  nothing  to  wrap  with  ;  noop  return  null  ;    Element  deepest  =  getDeepChild  (  wrap  )  ;  parentNode  .  replaceChild  (  this  ,  wrap  )  ;  deepest  .  addChild  (  this  )  ;      if  (  wrapChildren  .  size  (  )  >  1  )  {  [ATTENTION]  for  (  int  i  =  1  ;  i  <  wrapChildren  .  size  (  )  +  1  ;  i++  )  {  Element  remainder  =  wrapChildren  .  get  (  i  )  ;  remainder  .  parentNode  .  removeChild  (  remainder  )  ;  wrap  .  appendChild  (  remainder  )  ;  }  }  return  this  ;  }    [METHOD]  wrap  [TYPE]  Element  [PARAMETER]  String  html  [CLASS]  Element    [TYPE]  Set  classNames  [TYPE]  boolean  false  true  [TYPE]  Element  deepest  remainder  wrap  wrapBody  [TYPE]  Tag  tag  [TYPE]  String  html  [TYPE]  Elements  wrapChildren  [TYPE]  int  i  
[REPLACE]  Element  remainder  =  wrapChildren  .  get  (  i  )  ;	[BUGGY]  Element  remainder  =  wrapChildren  .  Elements  (  i  )  ;  [CE]  cannot  find  symbol  [CONTEXT]  public  Element  wrap  (  String  html  )  {  Validate  .  notEmpty  (  html  )  ;    Element  wrapBody  =  Parser  .  parseBodyFragment  (  html  ,  baseUri  )  .  body  (  )  ;  Elements  wrapChildren  =  wrapBody  .  children  (  )  ;  Element  wrap  =  wrapChildren  .  first  (  )  ;  if  (  wrap  =  =  null  )  //  nothing  to  wrap  with  ;  noop  return  null  ;    Element  deepest  =  getDeepChild  (  wrap  )  ;  parentNode  .  replaceChild  (  this  ,  wrap  )  ;  deepest  .  addChild  (  this  )  ;      if  (  wrapChildren  .  size  (  )  >  1  )  {  for  (  int  i  =  1  ;  i  <  wrapChildren  .  size  (  )  ;  i++  )  {  //  skip  first  [ATTENTION]  Element  remainder  =  wrapChildren  .  Elements  (  i  )    ;  remainder  .  parentNode  .  removeChild  (  remainder  )  ;  wrap  .  appendChild  (  remainder  )  ;  }  }  return  this  ;  }    [METHOD]  wrap  [TYPE]  Element  [PARAMETER]  String  html  [CLASS]  Element    [TYPE]  Set  classNames  [TYPE]  boolean  false  true  [TYPE]  Element  deepest  remainder  wrap  wrapBody  [TYPE]  Tag  tag  [TYPE]  String  html  [TYPE]  Elements  wrapChildren  [TYPE]  int  i  
[REPLACE]  for  (  int  i  =  1;  i  <  wrapChildren  .  size  (  )  ;  i++  )  {	[BUGGY]  for  (  int  i  =  0  ;  i  <  wrapChildren  .  size  (  )  ;  i++  )  {[FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  Element  wrap  (  String  html  )  {  Validate  .  notEmpty  (  html  )  ;    Element  wrapBody  =  Parser  .  parseBodyFragment  (  html  ,  baseUri  )  .  body  (  )  ;  Elements  wrapChildren  =  wrapBody  .  children  (  )  ;  Element  wrap  =  wrapChildren  .  first  (  )  ;  if  (  wrap  =  =  null  )  //  nothing  to  wrap  with  ;  noop  return  null  ;    Element  deepest  =  getDeepChild  (  wrap  )  ;  parentNode  .  replaceChild  (  this  ,  wrap  )  ;  deepest  .  addChild  (  this  )  ;      if  (  wrapChildren  .  size  (  )  >  1  )  {  [ATTENTION]  for  (  int  i  =  0  ;  i  <  wrapChildren  .  size  (  )    ;  i++  )  {  Element  remainder  =  wrapChildren  .  get  (  i  )  ;  remainder  .  parentNode  .  removeChild  (  remainder  )  ;  wrap  .  appendChild  (  remainder  )  ;  }  }  return  this  ;  }    [METHOD]  wrap  [TYPE]  Element  [PARAMETER]  String  html  [CLASS]  Element    [TYPE]  Set  classNames  [TYPE]  boolean  false  true  [TYPE]  Element  deepest  remainder  wrap  wrapBody  [TYPE]  Tag  tag  [TYPE]  String  html  [TYPE]  Elements  wrapChildren  [TYPE]  int  i  
[REPLACE]  for  (  int  i  =  1;  i  <  wrapChildren  .  size  (  )  ;  i++  )  {	[BUGGY]  for  (  int  i  =  1  ;  i  <  wrapChildren  .  size  (  )  %  2  ;  i++  )  {[FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  Element  wrap  (  String  html  )  {  Validate  .  notEmpty  (  html  )  ;    Element  wrapBody  =  Parser  .  parseBodyFragment  (  html  ,  baseUri  )  .  body  (  )  ;  Elements  wrapChildren  =  wrapBody  .  children  (  )  ;  Element  wrap  =  wrapChildren  .  first  (  )  ;  if  (  wrap  =  =  null  )  //  nothing  to  wrap  with  ;  noop  return  null  ;    Element  deepest  =  getDeepChild  (  wrap  )  ;  parentNode  .  replaceChild  (  this  ,  wrap  )  ;  deepest  .  addChild  (  this  )  ;      if  (  wrapChildren  .  size  (  )  >  1  )  {  [ATTENTION]  for  (  int  i  =  1  ;  i  <  wrapChildren  .  size  (  )  %2  ;  i++  )  {  Element  remainder  =  wrapChildren  .  get  (  i  )  ;  remainder  .  parentNode  .  removeChild  (  remainder  )  ;  wrap  .  appendChild  (  remainder  )  ;  }  }  return  this  ;  }    [METHOD]  wrap  [TYPE]  Element  [PARAMETER]  String  html  [CLASS]  Element    [TYPE]  Set  classNames  [TYPE]  boolean  false  true  [TYPE]  Element  deepest  remainder  wrap  wrapBody  [TYPE]  Tag  tag  [TYPE]  String  html  [TYPE]  Elements  wrapChildren  [TYPE]  int  i  
[ADD]  Element  remainder  =  wrapChildren  .  get  (  i  )  ;  remainder  .  parentNode  .  removeChild  (  remainder  )  ;	[BUGGY]  [CE]  cannot  find  symbol  remainder  [CONTEXT]  public  Element  wrap  (  String  html  )  {  Validate  .  notEmpty  (  html  )  ;    Element  wrapBody  =  Parser  .  parseBodyFragment  (  html  ,  baseUri  )  .  body  (  )  ;  Elements  wrapChildren  =  wrapBody  .  children  (  )  ;  Element  wrap  =  wrapChildren  .  first  (  )  ;  if  (  wrap  =  =  null  )  //  nothing  to  wrap  with  ;  noop  return  null  ;    Element  deepest  =  getDeepChild  (  wrap  )  ;  parentNode  .  replaceChild  (  this  ,  wrap  )  ;  deepest  .  addChild  (  this  )  ;      if  (  wrapChildren  .  size  (  )  >  1  )  {  for  (  int  i  =  1  ;  i  <  wrapChildren  .  size  (  )  ;  i++  )  {  //  skip  first  [ATTENTION]    wrap  .  appendChild  (  remainder  )  ;  }  }  return  this  ;  }    [METHOD]  wrap  [TYPE]  Element  [PARAMETER]  String  html  [CLASS]  Element    [TYPE]  Set  classNames  [TYPE]  boolean  false  true  [TYPE]  Element  deepest  remainder  wrap  wrapBody  [TYPE]  Tag  tag  [TYPE]  String  html  [TYPE]  Elements  wrapChildren  [TYPE]  int  i  
[REPLACE]  return  this;	[BUGGY]  return  null  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  Element  wrap  (  String  html  )  {  Validate  .  notEmpty  (  html  )  ;    Element  wrapBody  =  Parser  .  parseBodyFragment  (  html  ,  baseUri  )  .  body  (  )  ;  Elements  wrapChildren  =  wrapBody  .  children  (  )  ;  Element  wrap  =  wrapChildren  .  first  (  )  ;  if  (  wrap  =  =  null  )  //  nothing  to  wrap  with  ;  noop  return  null  ;    Element  deepest  =  getDeepChild  (  wrap  )  ;  parentNode  .  replaceChild  (  this  ,  wrap  )  ;  deepest  .  addChild  (  this  )  ;      if  (  wrapChildren  .  size  (  )  >  1  )  {  for  (  int  i  =  1  ;  i  <  wrapChildren  .  size  (  )  ;  i++  )  {  //  skip  first  Element  remainder  =  wrapChildren  .  get  (  i  )  ;  remainder  .  parentNode  .  removeChild  (  remainder  )  ;  wrap  .  appendChild  (  remainder  )  ;  }  }  [ATTENTION]  return  null  ;  }    [METHOD]  wrap  [TYPE]  Element  [PARAMETER]  String  html  [CLASS]  Element    [TYPE]  Set  classNames  [TYPE]  boolean  false  true  [TYPE]  Element  deepest  remainder  wrap  wrapBody  [TYPE]  Tag  tag  [TYPE]  String  html  [TYPE]  Elements  wrapChildren  [TYPE]  int  i  
[REPLACE]  List<Element>  children  =  el  .  children  (  )  ;	[BUGGY]  List<Element>  children  =  el  .  child  (  null  )    ;  [CE]  method  child  in  class  Element  cannot  be  applied  to  given  types  ;  [CONTEXT]  private  Element  getDeepChild  (  Element  el  )  {  [ATTENTION]  List<Element>  children  =  el  .  child  (  null  )  ;  if  (  children  .  size  (  )  >  0  )  return  getDeepChild  (  children  .  get  (  0  )  )  ;  else  return  el  ;  }    [METHOD]  getDeepChild  [TYPE]  Element  [PARAMETER]  Element  el  [CLASS]  Element    [TYPE]  List  children  [TYPE]  Set  classNames  [TYPE]  Tag  tag  [TYPE]  boolean  false  true  [TYPE]  Element  el  
[ADD]  List<Element>  children  =  el  .  children  (  )  ;	[BUGGY]  [CE]  cannot  find  symbol  children  [CONTEXT]  private  Element  getDeepChild  (  Element  el  )  {  [ATTENTION]  if  (  children  .  size  (  )  >  0  )  return  getDeepChild  (  children  .  get  (  0  )  )  ;  else  return  el  ;  }    [METHOD]  getDeepChild  [TYPE]  Element  [PARAMETER]  Element  el  [CLASS]  Element    [TYPE]  List  children  [TYPE]  Set  classNames  [TYPE]  Tag  tag  [TYPE]  boolean  false  true  [TYPE]  Element  el  
[REPLACE]  if  (  children  .  size  (  )  >  0  )  return  getDeepChild  (  children  .  get  (  0  )  )  ;	[BUGGY]  if  (  children  .  size  (  )  %  2  >  0  )  return  getDeepChild  (  children  .  get  (  0  )  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  private  Element  getDeepChild  (  Element  el  )  {  List<Element>  children  =  el  .  children  (  )  ;  [ATTENTION]  if  (  children  .  size  (  )  %2  >  0  )  return  getDeepChild  (  children  .  get  (  0  )  )    ;    else  return  el  ;  }    [METHOD]  getDeepChild  [TYPE]  Element  [PARAMETER]  Element  el  [CLASS]  Element    [TYPE]  List  children  [TYPE]  Set  classNames  [TYPE]  Tag  tag  [TYPE]  boolean  false  true  [TYPE]  Element  el  
[REPLACE]  return  el;	[BUGGY]  return  elements  .  get  (  0  )  ;  [CE]  cannot  find  symbol  elements  [CONTEXT]  private  Element  getDeepChild  (  Element  el  )  {  List<Element>  children  =  el  .  children  (  )  ;  if  (  children  .  size  (  )  >  0  )  return  getDeepChild  (  children  .  get  (  0  )  )  ;  else  [ATTENTION]  return  elements  .  get  (  0  )    ;  }    [METHOD]  getDeepChild  [TYPE]  Element  [PARAMETER]  Element  el  [CLASS]  Element    [TYPE]  List  children  [TYPE]  Set  classNames  [TYPE]  Tag  tag  [TYPE]  boolean  false  true  [TYPE]  Element  el  
[REPLACE]  return  getDeepChild  (  children  .  get  (  0  )  )  ;	[BUGGY]  return  getDeepChild  (  children  .  Elements  (  null  )    )  ;  [CE]  cannot  find  symbol  [CONTEXT]  private  Element  getDeepChild  (  Element  el  )  {  List<Element>  children  =  el  .  children  (  )  ;  if  (  children  .  size  (  )  >  0  )  [ATTENTION]  return  getDeepChild  (  children  .  Elements  (  null  )    )    ;  else  return  el  ;  }    [METHOD]  getDeepChild  [TYPE]  Element  [PARAMETER]  Element  el  [CLASS]  Element    [TYPE]  List  children  [TYPE]  Set  classNames  [TYPE]  Tag  tag  [TYPE]  boolean  false  true  [TYPE]  Element  el  
[REPLACE]  return  getDeepChild  (  children  .  get  (  0  )  )  ;	[BUGGY]  return  getDeepChild  (  children  .  get  (  3  )  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  private  Element  getDeepChild  (  Element  el  )  {  List<Element>  children  =  el  .  children  (  )  ;  if  (  children  .  size  (  )  >  0  )  [ATTENTION]  return  getDeepChild  (  children  .  get  (  3  )  )    ;  else  return  el  ;  }    [METHOD]  getDeepChild  [TYPE]  Element  [PARAMETER]  Element  el  [CLASS]  Element    [TYPE]  List  children  [TYPE]  Set  classNames  [TYPE]  Tag  tag  [TYPE]  boolean  false  true  [TYPE]  Element  el  
[REPLACE]  return  parent  (  )    .  children  (  )  ;	[BUGGY]  return  parent  (  )  .  child  (  )  ;  [CE]  method  child  in  class  Element  cannot  be  applied  to  given  types  ;  [CONTEXT]  public  Elements  siblingElements  (  )  {  [ATTENTION]  return  parent  (  )    .  child  (  )    ;  }    [METHOD]  siblingElements  [TYPE]  Elements  [PARAMETER]  [CLASS]  Element    [TYPE]  Set  classNames  [TYPE]  Tag  tag  [TYPE]  boolean  false  true  
[REPLACE]  List<Element>  siblings  =  parent  (  )    .  children  (  )  ;	[BUGGY]  Elements  wrapChildren  =  wrapBody  .  children  (  )  ;  [CE]  cannot  find  symbol  wrapBody  [CONTEXT]  public  Element  nextElementSibling  (  )  {  [ATTENTION]  Elements  wrapChildren  =  wrapBody  .  children  (  )    ;  Integer  index  =  indexInList  (  this  ,  siblings  )  ;  Validate  .  notNull  (  index  )  ;  if  (  siblings  .  size  (  )  >  index+1  )  return  siblings  .  get  (  index+1  )  ;  else  return  null  ;  }    [METHOD]  nextElementSibling  [TYPE]  Element  [PARAMETER]  [CLASS]  Element    [TYPE]  Integer  index  [TYPE]  List  siblings  [TYPE]  Set  classNames  [TYPE]  Tag  tag  [TYPE]  boolean  false  true  
[ADD]  List<Element>  siblings  =  parent  (  )    .  children  (  )  ;	[BUGGY]  [CE]  cannot  find  symbol  siblings  [CONTEXT]  public  Element  nextElementSibling  (  )  {  [ATTENTION]  Integer  index  =  indexInList  (  this  ,  siblings  )  ;  Validate  .  notNull  (  index  )  ;  if  (  siblings  .  size  (  )  >  index+1  )  return  siblings  .  get  (  index+1  )  ;  else  return  null  ;  }    [METHOD]  nextElementSibling  [TYPE]  Element  [PARAMETER]  [CLASS]  Element    [TYPE]  Integer  index  [TYPE]  List  siblings  [TYPE]  Set  classNames  [TYPE]  Tag  tag  [TYPE]  boolean  false  true  
[REPLACE]  Integer  index  =  indexInList  (  this,  siblings  )  ;	[BUGGY]  Integer  index  =  indexInList  (  this  ,  true  )  ;  [CE]  method  indexInList  in  class  Node  cannot  be  applied  to  given  types  ;  [CONTEXT]  public  Element  nextElementSibling  (  )  {  List<Element>  siblings  =  parent  (  )  .  children  (  )  ;  [ATTENTION]  Integer  index  =  indexInList  (  this  ,  true  )    ;  Validate  .  notNull  (  index  )  ;  if  (  siblings  .  size  (  )  >  index+1  )  return  siblings  .  get  (  index+1  )  ;  else  return  null  ;  }    [METHOD]  nextElementSibling  [TYPE]  Element  [PARAMETER]  [CLASS]  Element    [TYPE]  Integer  index  [TYPE]  List  siblings  [TYPE]  Set  classNames  [TYPE]  Tag  tag  [TYPE]  boolean  false  true  
[REPLACE]  Validate  .  notNull  (  index  )  ;	[BUGGY]  Validate  .  notNull  (  text  )  ;  [CE]  cannot  find  symbol  text  [CONTEXT]  public  Element  nextElementSibling  (  )  {  List<Element>  siblings  =  parent  (  )  .  children  (  )  ;  Integer  index  =  indexInList  (  this  ,  siblings  )  ;  [ATTENTION]  Validate  .  notNull  (  text  )    ;  if  (  siblings  .  size  (  )  >  index+1  )  return  siblings  .  get  (  index+1  )  ;  else  return  null  ;  }    [METHOD]  nextElementSibling  [TYPE]  Element  [PARAMETER]  [CLASS]  Element    [TYPE]  Integer  index  [TYPE]  List  siblings  [TYPE]  Set  classNames  [TYPE]  Tag  tag  [TYPE]  boolean  false  true  
[ADD]  Validate  .  notNull  (  index  )  ;	[BUGGY]  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  Element  nextElementSibling  (  )  {  List<Element>  siblings  =  parent  (  )  .  children  (  )  ;  Integer  index  =  indexInList  (  this  ,  siblings  )  ;  [ATTENTION]  if  (  siblings  .  size  (  )  >  index+1  )  return  siblings  .  get  (  index+1  )  ;  else  return  null  ;  }    [METHOD]  nextElementSibling  [TYPE]  Element  [PARAMETER]  [CLASS]  Element    [TYPE]  Integer  index  [TYPE]  List  siblings  [TYPE]  Set  classNames  [TYPE]  Tag  tag  [TYPE]  boolean  false  true  
[REPLACE]  if  (  siblings  .  size  (  )  >  index+1  )  return  siblings  .  get  (  index+1  )  ;	[BUGGY]  if  (  siblings  .  size  (  )  +  5  >  index+1  )  return  siblings  .  size  (  index+1  )  ;  [CE]  no  suitable  method  found  for  size(int)  [CONTEXT]  public  Element  nextElementSibling  (  )  {  List<Element>  siblings  =  parent  (  )  .  children  (  )  ;  Integer  index  =  indexInList  (  this  ,  siblings  )  ;  Validate  .  notNull  (  index  )  ;  [ATTENTION]  if  (  siblings  .  size  (  )  +  5  >  index+1  )  return  siblings  .  size  (  index+1  )    ;    else  return  null  ;  }    [METHOD]  nextElementSibling  [TYPE]  Element  [PARAMETER]  [CLASS]  Element    [TYPE]  Integer  index  [TYPE]  List  siblings  [TYPE]  Set  classNames  [TYPE]  Tag  tag  [TYPE]  boolean  false  true  
[REPLACE]  return  null;	[BUGGY]  return  true  ;  [CE]  incompatible  types  [CONTEXT]  public  Element  nextElementSibling  (  )  {  List<Element>  siblings  =  parent  (  )  .  children  (  )  ;  Integer  index  =  indexInList  (  this  ,  siblings  )  ;  Validate  .  notNull  (  index  )  ;  if  (  siblings  .  size  (  )  >  index+1  )  return  siblings  .  get  (  index+1  )  ;  else  [ATTENTION]  return  true  ;  }    [METHOD]  nextElementSibling  [TYPE]  Element  [PARAMETER]  [CLASS]  Element    [TYPE]  Integer  index  [TYPE]  List  siblings  [TYPE]  Set  classNames  [TYPE]  Tag  tag  [TYPE]  boolean  false  true  
[REPLACE]  return  siblings  .  get  (  index+1  )  ;	[BUGGY]  return  siblings  .  get  (  this  )    ;  [CE]  method  get  in  interface  List<E>  cannot  be  applied  to  given  types  ;  [CONTEXT]  public  Element  nextElementSibling  (  )  {  List<Element>  siblings  =  parent  (  )  .  children  (  )  ;  Integer  index  =  indexInList  (  this  ,  siblings  )  ;  Validate  .  notNull  (  index  )  ;  if  (  siblings  .  size  (  )  >  index+1  )  [ATTENTION]  return  siblings  .  get  (  this  )  ;  else  return  null  ;  }    [METHOD]  nextElementSibling  [TYPE]  Element  [PARAMETER]  [CLASS]  Element    [TYPE]  Integer  index  [TYPE]  List  siblings  [TYPE]  Set  classNames  [TYPE]  Tag  tag  [TYPE]  boolean  false  true  
[REPLACE]  return  siblings  .  get  (  index+1  )  ;	[BUGGY]  return  siblings  .  size(index  ;  [CE]  ')'  expected  [CONTEXT]  public  Element  nextElementSibling  (  )  {  List<Element>  siblings  =  parent  (  )  .  children  (  )  ;  Integer  index  =  indexInList  (  this  ,  siblings  )  ;  Validate  .  notNull  (  index  )  ;  if  (  siblings  .  size  (  )  >  index+1  )  [ATTENTION]  return  siblings  .  size  (  index  ;  else  return  null  ;  }    [METHOD]  nextElementSibling  [TYPE]  Element  [PARAMETER]  [CLASS]  Element    [TYPE]  Integer  index  [TYPE]  List  siblings  [TYPE]  Set  classNames  [TYPE]  Tag  tag  [TYPE]  boolean  false  true  
[REPLACE]  List<Element>  siblings  =  parent  (  )    .  children  (  )  ;	[BUGGY]  List<Element>  siblings  =  parent  (  )  .  child  (  )  ;  [CE]  method  child  in  class  Element  cannot  be  applied  to  given  types  ;  [CONTEXT]  public  Element  previousElementSibling  (  )  {  [ATTENTION]  List<Element>  siblings  =  parent  (  )    .  child  (  )    ;  Integer  index  =  indexInList  (  this  ,  siblings  )  ;  Validate  .  notNull  (  index  )  ;  if  (  index  >  0  )  return  siblings  .  get  (  index-1  )  ;  else  return  null  ;  }    [METHOD]  previousElementSibling  [TYPE]  Element  [PARAMETER]  [CLASS]  Element    [TYPE]  Integer  index  [TYPE]  List  siblings  [TYPE]  Set  classNames  [TYPE]  Tag  tag  [TYPE]  boolean  false  true  
[ADD]  List<Element>  siblings  =  parent  (  )    .  children  (  )  ;	[BUGGY]  [CE]  cannot  find  symbol  siblings  [CONTEXT]  public  Element  previousElementSibling  (  )  {  [ATTENTION]  Integer  index  =  indexInList  (  this  ,  siblings  )  ;  Validate  .  notNull  (  index  )  ;  if  (  index  >  0  )  return  siblings  .  get  (  index-1  )  ;  else  return  null  ;  }    [METHOD]  previousElementSibling  [TYPE]  Element  [PARAMETER]  [CLASS]  Element    [TYPE]  Integer  index  [TYPE]  List  siblings  [TYPE]  Set  classNames  [TYPE]  Tag  tag  [TYPE]  boolean  false  true  
[REPLACE]  Integer  index  =  indexInList  (  this,  siblings  )  ;	[BUGGY]  Integer  index  =  indexInList  (  this  ,  null  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  Element  previousElementSibling  (  )  {  List<Element>  siblings  =  parent  (  )  .  children  (  )  ;  [ATTENTION]  Integer  index  =  indexInList  (  this  ,  null  )    ;  Validate  .  notNull  (  index  )  ;  if  (  index  >  0  )  return  siblings  .  get  (  index-1  )  ;  else  return  null  ;  }    [METHOD]  previousElementSibling  [TYPE]  Element  [PARAMETER]  [CLASS]  Element    [TYPE]  Integer  index  [TYPE]  List  siblings  [TYPE]  Set  classNames  [TYPE]  Tag  tag  [TYPE]  boolean  false  true  
[REPLACE]  Validate  .  notNull  (  index  )  ;	[BUGGY]  Validate  .  notNull  (  text  )  ;  [CE]  cannot  find  symbol  text  [CONTEXT]  public  Element  previousElementSibling  (  )  {  List<Element>  siblings  =  parent  (  )  .  children  (  )  ;  Integer  index  =  indexInList  (  this  ,  siblings  )  ;  [ATTENTION]  Validate  .  notNull  (  text  )    ;  if  (  index  >  0  )  return  siblings  .  get  (  index-1  )  ;  else  return  null  ;  }    [METHOD]  previousElementSibling  [TYPE]  Element  [PARAMETER]  [CLASS]  Element    [TYPE]  Integer  index  [TYPE]  List  siblings  [TYPE]  Set  classNames  [TYPE]  Tag  tag  [TYPE]  boolean  false  true  
[REPLACE]  if  (  index  >  0  )  return  siblings  .  get  (  index-1  )  ;	[BUGGY]  if  (  index  >  =    0  )  return  siblings  .  get  (  index-1  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  Element  previousElementSibling  (  )  {  List<Element>  siblings  =  parent  (  )  .  children  (  )  ;  Integer  index  =  indexInList  (  this  ,  siblings  )  ;  Validate  .  notNull  (  index  )  ;  [ATTENTION]  if  (  index>  =  0  )  return  siblings  .  get  (  index-1  )    ;    else  return  null  ;  }    [METHOD]  previousElementSibling  [TYPE]  Element  [PARAMETER]  [CLASS]  Element    [TYPE]  Integer  index  [TYPE]  List  siblings  [TYPE]  Set  classNames  [TYPE]  Tag  tag  [TYPE]  boolean  false  true  
[REPLACE]  return  null;	[BUGGY]  return  this  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  Element  previousElementSibling  (  )  {  List<Element>  siblings  =  parent  (  )  .  children  (  )  ;  Integer  index  =  indexInList  (  this  ,  siblings  )  ;  Validate  .  notNull  (  index  )  ;  if  (  index  >  0  )  return  siblings  .  get  (  index-1  )  ;  else  [ATTENTION]  return  this  ;  }    [METHOD]  previousElementSibling  [TYPE]  Element  [PARAMETER]  [CLASS]  Element    [TYPE]  Integer  index  [TYPE]  List  siblings  [TYPE]  Set  classNames  [TYPE]  Tag  tag  [TYPE]  boolean  false  true  
[REPLACE]  return  siblings  .  get  (  index-1  )  ;	[BUGGY]  return  siblings  .  size  (  index-0  )  ;  [CE]  no  suitable  method  found  for  size(int)  [CONTEXT]  public  Element  previousElementSibling  (  )  {  List<Element>  siblings  =  parent  (  )  .  children  (  )  ;  Integer  index  =  indexInList  (  this  ,  siblings  )  ;  Validate  .  notNull  (  index  )  ;  if  (  index  >  0  )  [ATTENTION]  return  siblings  .  size  (  index-0  )    ;  else  return  null  ;  }    [METHOD]  previousElementSibling  [TYPE]  Element  [PARAMETER]  [CLASS]  Element    [TYPE]  Integer  index  [TYPE]  List  siblings  [TYPE]  Set  classNames  [TYPE]  Tag  tag  [TYPE]  boolean  false  true  
[REPLACE]  return  siblings  .  get  (  index-1  )  ;	[BUGGY]  return  siblings  .  size(index  ;  [CE]  ')'  expected  [CONTEXT]  public  Element  previousElementSibling  (  )  {  List<Element>  siblings  =  parent  (  )  .  children  (  )  ;  Integer  index  =  indexInList  (  this  ,  siblings  )  ;  Validate  .  notNull  (  index  )  ;  if  (  index  >  0  )  [ATTENTION]  return  siblings  .  size  (  index  ;  else  return  null  ;  }    [METHOD]  previousElementSibling  [TYPE]  Element  [PARAMETER]  [CLASS]  Element    [TYPE]  Integer  index  [TYPE]  List  siblings  [TYPE]  Set  classNames  [TYPE]  Tag  tag  [TYPE]  boolean  false  true  
[REPLACE]  List<Element>  siblings  =  parent  (  )    .  children  (  )  ;	[BUGGY]  List<Element>  siblings  =  parent  (  )  .  child  (  )  ;  [CE]  method  child  in  class  Element  cannot  be  applied  to  given  types  ;  [CONTEXT]  public  Element  firstElementSibling  (  )  {    [ATTENTION]  List<Element>  siblings  =  parent  (  )    .  child  (  )    ;  return  siblings  .  size  (  )  >  1  ?  siblings  .  get  (  0  )  :  null  ;  }    [METHOD]  firstElementSibling  [TYPE]  Element  [PARAMETER]  [CLASS]  Element    [TYPE]  List  siblings  [TYPE]  Set  classNames  [TYPE]  Tag  tag  [TYPE]  boolean  false  true  
[REPLACE]  return  siblings  .  size  (  )  >  1  ?  siblings  .  get  (  0  )  :  null;	[BUGGY]  return  siblings  .  size  (  )  +  4  >  1  ?  siblings  .  get  (  0  )  :  null  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  Element  firstElementSibling  (  )  {    List<Element>  siblings  =  parent  (  )  .  children  (  )  ;  [ATTENTION]  return  siblings  .  size  (  )  +  4  >  1  ?  siblings  .  get  (  0  )  :  null  ;  }    [METHOD]  firstElementSibling  [TYPE]  Element  [PARAMETER]  [CLASS]  Element    [TYPE]  List  siblings  [TYPE]  Set  classNames  [TYPE]  Tag  tag  [TYPE]  boolean  false  true  
[REPLACE]  if  (  parent  (  )  ==  null  )  return  0;	[BUGGY]  if  (  parent  (  )  !  =  null  )  return  0  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  Integer  elementSiblingIndex  (  )  {  [ATTENTION]  if  (  parent  (  )  !  =  null  )  return  0  ;  return  indexInList  (  this  ,  parent  (  )  .  children  (  )  )  ;  }    [METHOD]  elementSiblingIndex  [TYPE]  Integer  [PARAMETER]  [CLASS]  Element    [TYPE]  Set  classNames  [TYPE]  Tag  tag  [TYPE]  boolean  false  true  
[REPLACE]  if  (  parent  (  )  ==  null  )  return  0;	[BUGGY]  if  (  parent  (  )    =  =  null  )  return  0  +  2  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  Integer  elementSiblingIndex  (  )  {  [ATTENTION]  if  (  parent  (  )  =  =  null  )  return  0  +  2  ;  return  indexInList  (  this  ,  parent  (  )  .  children  (  )  )  ;  }    [METHOD]  elementSiblingIndex  [TYPE]  Integer  [PARAMETER]  [CLASS]  Element    [TYPE]  Set  classNames  [TYPE]  Tag  tag  [TYPE]  boolean  false  true  
[REPLACE]  if  (  parent  (  )  ==  null  )  return  0;	[BUGGY]  if  (  parent  (  )    =  =  null  )  return  4  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  Integer  elementSiblingIndex  (  )  {  [ATTENTION]  if  (  parent  (  )  =  =  null  )  return  4  ;  return  indexInList  (  this  ,  parent  (  )  .  children  (  )  )  ;  }    [METHOD]  elementSiblingIndex  [TYPE]  Integer  [PARAMETER]  [CLASS]  Element    [TYPE]  Set  classNames  [TYPE]  Tag  tag  [TYPE]  boolean  false  true  
[REPLACE]  return  indexInList  (  this,  parent  (  )    .  children  (  )  )  ;	[BUGGY]  return  indexInList  (  this  ,  parent  (  )  .  child  (  )  )  ;  [CE]  method  child  in  class  Element  cannot  be  applied  to  given  types  ;  [CONTEXT]  public  Integer  elementSiblingIndex  (  )  {  if  (  parent  (  )    =  =  null  )  return  0  ;  [ATTENTION]  return  indexInList  (  this  ,  parent  (  )    .  child  (  )  )    ;  }    [METHOD]  elementSiblingIndex  [TYPE]  Integer  [PARAMETER]  [CLASS]  Element    [TYPE]  Set  classNames  [TYPE]  Tag  tag  [TYPE]  boolean  false  true  
[REPLACE]  List<Element>  siblings  =  parent  (  )    .  children  (  )  ;	[BUGGY]  Elements  wrapChildren  =  wrapBody  .  children  (  )  ;  [CE]  cannot  find  symbol  wrapBody  [CONTEXT]  public  Element  lastElementSibling  (  )  {  [ATTENTION]  Elements  wrapChildren  =  wrapBody  .  children  (  )    ;  return  siblings  .  size  (  )  >  1  ?  siblings  .  get  (  siblings  .  size  (  )  -  1  )  :  null  ;  }    [METHOD]  lastElementSibling  [TYPE]  Element  [PARAMETER]  [CLASS]  Element    [TYPE]  List  siblings  [TYPE]  Set  classNames  [TYPE]  Tag  tag  [TYPE]  boolean  false  true  
[REPLACE]  return  siblings  .  size  (  )  >  1  ?  siblings  .  get  (  siblings  .  size  (  )  -  1  )  :  null;	[BUGGY]  return  siblings  .  size  (  )  %  0  .  5  >  1  ?  siblings  .  get  (  siblings  .  size  (  )  %  0  .  5  -  1  )  :  null  ;  [CE]  method  get  in  interface  List<E>  cannot  be  applied  to  given  types  ;  [CONTEXT]  public  Element  lastElementSibling  (  )  {  List<Element>  siblings  =  parent  (  )  .  children  (  )  ;  [ATTENTION]  return  siblings  .  size  (  )  %0  .  5>  1  ?  siblings  .  get  (  siblings  .  size  (  )  %0  .  5-  1  )  :  null  ;  }    [METHOD]  lastElementSibling  [TYPE]  Element  [PARAMETER]  [CLASS]  Element    [TYPE]  List  siblings  [TYPE]  Set  classNames  [TYPE]  Tag  tag  [TYPE]  boolean  false  true  
[REPLACE]  Validate  .  notEmpty  (  tagName  )  ;	[BUGGY]  Validate  .  notNull  (  tagName  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  Elements  getElementsByTag  (  String  tagName  )  {  [ATTENTION]  Validate  .  notNull  (  tagName  )    ;  tagName  =  tagName  .  toLowerCase  (  )  .  trim  (  )  ;    return  Collector  .  collect  (  new  Evaluator  .  Tag  (  tagName  )  ,  this  )  ;  }    [METHOD]  getElementsByTag  [TYPE]  Elements  [PARAMETER]  String  tagName  [CLASS]  Element    [TYPE]  Set  classNames  [TYPE]  Tag  tag  [TYPE]  String  tagName  [TYPE]  boolean  false  true  
[REPLACE]  tagName  =  tagName  .  toLowerCase  (  )    .  trim  (  )  ;	[BUGGY]  tagName  =    null  .  toLowerCase  (  )  .  trim  (  )  ;  [CE]  <null>  cannot  be  dereferenced  [CONTEXT]  public  Elements  getElementsByTag  (  String  tagName  )  {  Validate  .  notEmpty  (  tagName  )  ;  [ATTENTION]  tagName  =  null  .  toLowerCase  (  )    .  trim  (  )    ;    return  Collector  .  collect  (  new  Evaluator  .  Tag  (  tagName  )  ,  this  )  ;  }    [METHOD]  getElementsByTag  [TYPE]  Elements  [PARAMETER]  String  tagName  [CLASS]  Element    [TYPE]  Set  classNames  [TYPE]  Tag  tag  [TYPE]  String  tagName  [TYPE]  boolean  false  true  
[REPLACE]  return  Collector  .  collect  (  new  Evaluator  .  Tag  (  tagName  )  ,  this  )  ;	[BUGGY]  return    new  Evaluator  .  Tag  (  tagName  )    ;  [CE]  incompatible  types  [CONTEXT]  public  Elements  getElementsByTag  (  String  tagName  )  {  Validate  .  notEmpty  (  tagName  )  ;  tagName  =  tagName  .  toLowerCase  (  )  .  trim  (  )  ;    [ATTENTION]  return  new  Evaluator  .  Tag  (  tagName  )  ;  }    [METHOD]  getElementsByTag  [TYPE]  Elements  [PARAMETER]  String  tagName  [CLASS]  Element    [TYPE]  Set  classNames  [TYPE]  Tag  tag  [TYPE]  String  tagName  [TYPE]  boolean  false  true  
[REPLACE]  Validate  .  notEmpty  (  id  )  ;	[BUGGY]  Validate  .  notNull  (  id  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  Element  getElementById  (  String  id  )  {  [ATTENTION]  Validate  .  notNull  (  id  )    ;    Elements  elements  =  Collector  .  collect  (  new  Evaluator  .  Id  (  id  )  ,  this  )  ;  if  (  elements  .  size  (  )  >  0  )  return  elements  .  get  (  0  )  ;  else  return  null  ;  }    [METHOD]  getElementById  [TYPE]  Element  [PARAMETER]  String  id  [CLASS]  Element    [TYPE]  Set  classNames  [TYPE]  Tag  tag  [TYPE]  String  id  [TYPE]  boolean  false  true  [TYPE]  Elements  elements  
[REPLACE]  Elements  elements  =  Collector  .  collect  (  new  Evaluator  .  Id  (  id  )  ,  this  )  ;	[BUGGY]  Elements  elements  =  Collector  .  collect  (  tag  ,  this  )    ;  [CE]  method  collect  in  class  Collector  cannot  be  applied  to  given  types  ;  [CONTEXT]  public  Element  getElementById  (  String  id  )  {  Validate  .  notEmpty  (  id  )  ;    [ATTENTION]  Elements  elements  =  Collector  .  collect  (  tag  ,  this  )  ;  if  (  elements  .  size  (  )  >  0  )  return  elements  .  get  (  0  )  ;  else  return  null  ;  }    [METHOD]  getElementById  [TYPE]  Element  [PARAMETER]  String  id  [CLASS]  Element    [TYPE]  Set  classNames  [TYPE]  Tag  tag  [TYPE]  String  id  [TYPE]  boolean  false  true  [TYPE]  Elements  elements  
[REPLACE]  if  (  elements  .  size  (  )  >  0  )  return  elements  .  get  (  0  )  ;	[BUGGY]  if  (  elements  .  size  (  )  *  2  >  0  )  return  elements  .  get  (  0  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  Element  getElementById  (  String  id  )  {  Validate  .  notEmpty  (  id  )  ;    Elements  elements  =  Collector  .  collect  (  new  Evaluator  .  Id  (  id  )  ,  this  )  ;  [ATTENTION]  if  (  elements  .  size  (  )  *2  >  0  )  return  elements  .  get  (  0  )    ;    else  return  null  ;  }    [METHOD]  getElementById  [TYPE]  Element  [PARAMETER]  String  id  [CLASS]  Element    [TYPE]  Set  classNames  [TYPE]  Tag  tag  [TYPE]  String  id  [TYPE]  boolean  false  true  [TYPE]  Elements  elements  
[ADD]  if  (  elements  .  size  (  )  >  0  )  return  elements  .  get  (  0  )  ;  else  return  null;  }	[BUGGY]  return  elements  .  get  (  0  )  ;  return  null  ;  [CE]  illegal  start  of  expression  [CONTEXT]  public  Element  getElementById  (  String  id  )  {  Validate  .  notEmpty  (  id  )  ;    Elements  elements  =  Collector  .  collect  (  new  Evaluator  .  Id  (  id  )  ,  this  )  ;  [ATTENTION]  return  elements  .  get  (  0  )    ;  return  null  ;          [METHOD]  getElementById  [TYPE]  Element  [PARAMETER]  String  id  [CLASS]  Element    [TYPE]  Set  classNames  [TYPE]  Tag  tag  [TYPE]  String  id  [TYPE]  boolean  false  true  [TYPE]  Elements  elements  
[REPLACE]  return  null;	[BUGGY]  return  this  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  Element  getElementById  (  String  id  )  {  Validate  .  notEmpty  (  id  )  ;    Elements  elements  =  Collector  .  collect  (  new  Evaluator  .  Id  (  id  )  ,  this  )  ;  if  (  elements  .  size  (  )  >  0  )  return  elements  .  get  (  0  )  ;  else  [ATTENTION]  return  this  ;  }    [METHOD]  getElementById  [TYPE]  Element  [PARAMETER]  String  id  [CLASS]  Element    [TYPE]  Set  classNames  [TYPE]  Tag  tag  [TYPE]  String  id  [TYPE]  boolean  false  true  [TYPE]  Elements  elements  
[REPLACE]  return  elements  .  get  (  0  )  ;	[BUGGY]  return  elements  .  Elements  (  0  )  ;  [CE]  cannot  find  symbol  [CONTEXT]  public  Element  getElementById  (  String  id  )  {  Validate  .  notEmpty  (  id  )  ;    Elements  elements  =  Collector  .  collect  (  new  Evaluator  .  Id  (  id  )  ,  this  )  ;  if  (  elements  .  size  (  )  >  0  )  [ATTENTION]  return  elements  .  Elements  (  0  )    ;  else  return  null  ;  }    [METHOD]  getElementById  [TYPE]  Element  [PARAMETER]  String  id  [CLASS]  Element    [TYPE]  Set  classNames  [TYPE]  Tag  tag  [TYPE]  String  id  [TYPE]  boolean  false  true  [TYPE]  Elements  elements  
[REPLACE]  return  elements  .  get  (  0  )  ;	[BUGGY]  return  elements  .  Elements  (  null  )    ;  [CE]  cannot  find  symbol  [CONTEXT]  public  Element  getElementById  (  String  id  )  {  Validate  .  notEmpty  (  id  )  ;    Elements  elements  =  Collector  .  collect  (  new  Evaluator  .  Id  (  id  )  ,  this  )  ;  if  (  elements  .  size  (  )  >  0  )  [ATTENTION]  return  elements  .  Elements  (  null  )  ;  else  return  null  ;  }    [METHOD]  getElementById  [TYPE]  Element  [PARAMETER]  String  id  [CLASS]  Element    [TYPE]  Set  classNames  [TYPE]  Tag  tag  [TYPE]  String  id  [TYPE]  boolean  false  true  [TYPE]  Elements  elements  
[REPLACE]  return  null;	[BUGGY]  return  true  ;  [CE]  incompatible  types  [CONTEXT]  public  Element  getElementById  (  String  id  )  {  Validate  .  notEmpty  (  id  )  ;    Elements  elements  =  Collector  .  collect  (  new  Evaluator  .  Id  (  id  )  ,  this  )  ;  if  (  elements  .  size  (  )  >  0  )  return  elements  .  get  (  0  )  ;  else  [ATTENTION]  return  true  ;  }    [METHOD]  getElementById  [TYPE]  Element  [PARAMETER]  String  id  [CLASS]  Element    [TYPE]  Set  classNames  [TYPE]  Tag  tag  [TYPE]  String  id  [TYPE]  boolean  false  true  [TYPE]  Elements  elements  
[REPLACE]  Validate  .  notEmpty  (  className  )  ;	[BUGGY]  Validate  .  notNull  (  className  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  Elements  getElementsByClass  (  String  className  )  {  [ATTENTION]  Validate  .  notNull  (  className  )    ;    return  Collector  .  collect  (  new  Evaluator  .  Class  (  className  )  ,  this  )  ;  }    [METHOD]  getElementsByClass  [TYPE]  Elements  [PARAMETER]  String  className  [CLASS]  Element    [TYPE]  Set  classNames  [TYPE]  Tag  tag  [TYPE]  String  className  [TYPE]  boolean  false  true  
[ADD]  Validate  .  notEmpty  (  className  )  ;	[BUGGY]  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  Elements  getElementsByClass  (  String  className  )  {  [ATTENTION]    return  Collector  .  collect  (  new  Evaluator  .  Class  (  className  )  ,  this  )  ;  }    [METHOD]  getElementsByClass  [TYPE]  Elements  [PARAMETER]  String  className  [CLASS]  Element    [TYPE]  Set  classNames  [TYPE]  Tag  tag  [TYPE]  String  className  [TYPE]  boolean  false  true  
[REPLACE]  return  Collector  .  collect  (  new  Evaluator  .  Class  (  className  )  ,  this  )  ;	[BUGGY]  return    new  Evaluator  .  Class  (  className  )    ;  [CE]  incompatible  types  [CONTEXT]  public  Elements  getElementsByClass  (  String  className  )  {  Validate  .  notEmpty  (  className  )  ;    [ATTENTION]  return  new  Evaluator  .  Class  (  className  )  ;  }    [METHOD]  getElementsByClass  [TYPE]  Elements  [PARAMETER]  String  className  [CLASS]  Element    [TYPE]  Set  classNames  [TYPE]  Tag  tag  [TYPE]  String  className  [TYPE]  boolean  false  true  
[REPLACE]  Validate  .  notEmpty  (  key  )  ;	[BUGGY]  Validate  .  notNull  (  key  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  Elements  getElementsByAttribute  (  String  key  )  {  [ATTENTION]  Validate  .  notNull  (  key  )    ;  key  =  key  .  trim  (  )  .  toLowerCase  (  )  ;    return  Collector  .  collect  (  new  Evaluator  .  Attribute  (  key  )  ,  this  )  ;  }    [METHOD]  getElementsByAttribute  [TYPE]  Elements  [PARAMETER]  String  key  [CLASS]  Element    [TYPE]  Set  classNames  [TYPE]  Tag  tag  [TYPE]  String  key  [TYPE]  boolean  false  true  
[REPLACE]  key  =  key  .  trim  (  )    .  toLowerCase  (  )  ;	[BUGGY]  key  =    null  .  trim  (  )  .  toLowerCase  (  )  ;  [CE]  <null>  cannot  be  dereferenced  [CONTEXT]  public  Elements  getElementsByAttribute  (  String  key  )  {  Validate  .  notEmpty  (  key  )  ;  [ATTENTION]  key  =  null  .  trim  (  )    .  toLowerCase  (  )    ;    return  Collector  .  collect  (  new  Evaluator  .  Attribute  (  key  )  ,  this  )  ;  }    [METHOD]  getElementsByAttribute  [TYPE]  Elements  [PARAMETER]  String  key  [CLASS]  Element    [TYPE]  Set  classNames  [TYPE]  Tag  tag  [TYPE]  String  key  [TYPE]  boolean  false  true  
[REPLACE]  return  Collector  .  collect  (  new  Evaluator  .  Attribute  (  key  )  ,  this  )  ;	[BUGGY]  return  Collector  .  collect  (  tag  ,  this  )    ;  [CE]  method  collect  in  class  Collector  cannot  be  applied  to  given  types  ;  [CONTEXT]  public  Elements  getElementsByAttribute  (  String  key  )  {  Validate  .  notEmpty  (  key  )  ;  key  =  key  .  trim  (  )  .  toLowerCase  (  )  ;    [ATTENTION]  return  Collector  .  collect  (  tag  ,  this  )  ;  }    [METHOD]  getElementsByAttribute  [TYPE]  Elements  [PARAMETER]  String  key  [CLASS]  Element    [TYPE]  Set  classNames  [TYPE]  Tag  tag  [TYPE]  String  key  [TYPE]  boolean  false  true  
[REPLACE]  return  Collector  .  collect  (  new  Evaluator  .  AttributeWithValue  (  key,  value  )  ,  this  )  ;	[BUGGY]  return  Collector  .  collect  (  new  Evaluator  .  AttributeWithValueEnding  (  key  ,  valueSuffix  )  ,  this  )  ;  [CE]  cannot  find  symbol  valueSuffix  [CONTEXT]  public  Elements  getElementsByAttributeValue  (  String  key  ,  String  value  )  {  [ATTENTION]  return  Collector  .  collect  (  new  Evaluator  .  AttributeWithValueEnding  (  key  ,  valueSuffix  )    ,  this  )    ;  }    [METHOD]  getElementsByAttributeValue  [TYPE]  Elements  [PARAMETER]  String  key  String  value  [CLASS]  Element    [TYPE]  Set  classNames  [TYPE]  Tag  tag  [TYPE]  String  key  value  [TYPE]  boolean  false  true  
[REPLACE]  return  Collector  .  collect  (  new  Evaluator  .  AttributeWithValueNot  (  key,  value  )  ,  this  )  ;	[BUGGY]  return    new  Evaluator  .  AttributeWithValueNot  (  key  ,  value  )    ;  [CE]  incompatible  types  [CONTEXT]  public  Elements  getElementsByAttributeValueNot  (  String  key  ,  String  value  )  {  [ATTENTION]  return  new  Evaluator  .  AttributeWithValueNot  (  key  ,  value  )  ;  }    [METHOD]  getElementsByAttributeValueNot  [TYPE]  Elements  [PARAMETER]  String  key  String  value  [CLASS]  Element    [TYPE]  Set  classNames  [TYPE]  Tag  tag  [TYPE]  String  key  value  [TYPE]  boolean  false  true  
[REPLACE]  return  Collector  .  collect  (  new  Evaluator  .  AttributeWithValueStarting  (  key,  valuePrefix  )  ,  this  )  ;	[BUGGY]  return    Evaluator  .  new  AttributeWithValue  (  key  ,  value  )    ;  [CE]  cannot  find  symbol  Evaluator  [CONTEXT]  public  Elements  getElementsByAttributeValueStarting  (  String  key  ,  String  valuePrefix  )  {  [ATTENTION]  returnEvaluator  .  new  AttributeWithValue  (  key  ,  value  )    ;  }    [METHOD]  getElementsByAttributeValueStarting  [TYPE]  Elements  [PARAMETER]  String  key  String  valuePrefix  [CLASS]  Element    [TYPE]  Set  classNames  [TYPE]  Tag  tag  [TYPE]  String  key  valuePrefix  [TYPE]  boolean  false  true  
[REPLACE]  return  Collector  .  collect  (  new  Evaluator  .  AttributeWithValueEnding  (  key,  valueSuffix  )  ,  this  )  ;	[BUGGY]  return    new  Evaluator  .  AttributeWithValueEnding  (  key  ,  valueSuffix  )    ;  [CE]  incompatible  types  [CONTEXT]  public  Elements  getElementsByAttributeValueEnding  (  String  key  ,  String  valueSuffix  )  {  [ATTENTION]  return  new  Evaluator  .  AttributeWithValueEnding  (  key  ,  valueSuffix  )  ;  }    [METHOD]  getElementsByAttributeValueEnding  [TYPE]  Elements  [PARAMETER]  String  key  String  valueSuffix  [CLASS]  Element    [TYPE]  Set  classNames  [TYPE]  Tag  tag  [TYPE]  String  key  valueSuffix  [TYPE]  boolean  false  true  
[REPLACE]  return  Collector  .  collect  (  new  Evaluator  .  AttributeWithValueContaining  (  key,  match  )  ,  this  )  ;	[BUGGY]  return    new  Evaluator  .  AttributeWithValueContaining  (  key  ,  match  )    ;  [CE]  incompatible  types  [CONTEXT]  public  Elements  getElementsByAttributeValueContaining  (  String  key  ,  String  match  )  {  [ATTENTION]  return  new  Evaluator  .  AttributeWithValueContaining  (  key  ,  match  )  ;  }    [METHOD]  getElementsByAttributeValueContaining  [TYPE]  Elements  [PARAMETER]  String  key  String  match  [CLASS]  Element    [TYPE]  Set  classNames  [TYPE]  Tag  tag  [TYPE]  String  key  match  [TYPE]  boolean  false  true  
[REPLACE]  return  Collector  .  collect  (  new  Evaluator  .  IndexLessThan  (  index  )  ,  this  )  ;	[BUGGY]  return  Collector  .  collect  (  tag  ,  1  )    ;  [CE]  method  collect  in  class  Collector  cannot  be  applied  to  given  types  ;  [CONTEXT]  public  Elements  getElementsByIndexLessThan  (  int  index  )  {  [ATTENTION]  return  Collector  .  collect  (  tag  ,  1  )  ;  }    [METHOD]  getElementsByIndexLessThan  [TYPE]  Elements  [PARAMETER]  int  index  [CLASS]  Element    [TYPE]  Set  classNames  [TYPE]  Tag  tag  [TYPE]  boolean  false  true  [TYPE]  int  index  
[REPLACE]  return  Collector  .  collect  (  new  Evaluator  .  IndexGreaterThan  (  index  )  ,  this  )  ;	[BUGGY]  return    new  Evaluator  .  IndexGreaterThan  (  index  )    ;  [CE]  incompatible  types  [CONTEXT]  public  Elements  getElementsByIndexGreaterThan  (  int  index  )  {  [ATTENTION]  return  new  Evaluator  .  IndexGreaterThan  (  index  )  ;  }    [METHOD]  getElementsByIndexGreaterThan  [TYPE]  Elements  [PARAMETER]  int  index  [CLASS]  Element    [TYPE]  Set  classNames  [TYPE]  Tag  tag  [TYPE]  boolean  false  true  [TYPE]  int  index  
[REPLACE]  return  Collector  .  collect  (  new  Evaluator  .  IndexEquals  (  index  )  ,  this  )  ;	[BUGGY]  return    new  Evaluator  .  IndexEquals  (  index  )    ;  [CE]  incompatible  types  [CONTEXT]  public  Elements  getElementsByIndexEquals  (  int  index  )  {  [ATTENTION]  return  new  Evaluator  .  IndexEquals  (  index  )  ;  }    [METHOD]  getElementsByIndexEquals  [TYPE]  Elements  [PARAMETER]  int  index  [CLASS]  Element    [TYPE]  Set  classNames  [TYPE]  Tag  tag  [TYPE]  boolean  false  true  [TYPE]  int  index  
[REPLACE]  return  Collector  .  collect  (  new  Evaluator  .  AllElements  (  )  ,  this  )  ;	[BUGGY]  return    new  Evaluator  .  AllElements  (  )    ;  [CE]  incompatible  types  [CONTEXT]  public  Elements  getAllElements  (  )  {  [ATTENTION]  return  new  Evaluator  .  AllElements  (  )  ;  }    [METHOD]  getAllElements  [TYPE]  Elements  [PARAMETER]  [CLASS]  Element    [TYPE]  Set  classNames  [TYPE]  Tag  tag  [TYPE]  boolean  false  true  
[REPLACE]  StringBuilder  sb  =  new  StringBuilder  (  )  ;	[BUGGY]  StringBuilder  accum  =  new  StringBuilder  (  )  ;  [CE]  cannot  find  symbol  sb  [CONTEXT]  public  String  text  (  )  {  [ATTENTION]  StringBuilder  accum  =  new  StringBuilder  (  )    ;  text  (  sb  )  ;  return  sb  .  toString  (  )  .  trim  (  )  ;  }    [METHOD]  text  [TYPE]  String  [PARAMETER]  [CLASS]  Element    [TYPE]  Set  classNames  [TYPE]  Tag  tag  [TYPE]  boolean  false  true  [TYPE]  StringBuilder  sb  
[REPLACE]  text  (  sb  )  ;	[BUGGY]  append  (  html  )  ;  [CE]  cannot  find  symbol  html  [CONTEXT]  public  String  text  (  )  {  StringBuilder  sb  =  new  StringBuilder  (  )  ;  [ATTENTION]  append  (  html  )    ;  return  sb  .  toString  (  )  .  trim  (  )  ;  }    [METHOD]  text  [TYPE]  String  [PARAMETER]  [CLASS]  Element    [TYPE]  Set  classNames  [TYPE]  Tag  tag  [TYPE]  boolean  false  true  [TYPE]  StringBuilder  sb  
[ADD]  text  (  sb  )  ;  return  sb  .  toString  (  )    .  trim  (  )  ;	[BUGGY]  [CE]  missing  return  statement  [CONTEXT]  public  String  text  (  )  {  StringBuilder  sb  =  new  StringBuilder  (  )  ;  [ATTENTION]    }    [METHOD]  text  [TYPE]  String  [PARAMETER]  [CLASS]  Element    [TYPE]  Set  classNames  [TYPE]  Tag  tag  [TYPE]  boolean  false  true  [TYPE]  StringBuilder  sb  
[REPLACE]  return  sb  .  toString  (  )    .  trim  (  )  ;	[BUGGY]  return  accum  .  toString  (  )  .  trim  (  )  ;  [CE]  cannot  find  symbol  accum  [CONTEXT]  public  String  text  (  )  {  StringBuilder  sb  =  new  StringBuilder  (  )  ;  text  (  sb  )  ;  [ATTENTION]  return  accum  .  toString  (  )    .  trim  (  )    ;  }    [METHOD]  text  [TYPE]  String  [PARAMETER]  [CLASS]  Element    [TYPE]  Set  classNames  [TYPE]  Tag  tag  [TYPE]  boolean  false  true  [TYPE]  StringBuilder  sb  
[REPLACE]  if  (  child  instanceof  TextNode  )  {	[BUGGY]  if  (  !  child  instanceof  TextNode  )  {[CE]  bad  operand  type  Node  for  unary  operator  '!'  [CONTEXT]  private  void  text  (  StringBuilder  accum  )  {  for  (  Node  child  :  childNodes  )  {  [ATTENTION]  if  (  !  child  instanceof  TextNode  )  {  TextNode  textNode  =    (  TextNode  )  child  ;  String  text  =  textNode  .  getWholeText  (  )  ;    if  (  !preserveWhitespace  (  )  )  {  text  =  TextNode  .  normaliseWhitespace  (  text  )  ;  if  (  TextNode  .  lastCharIsWhitespace  (  accum  )  )  text  =  TextNode  .  stripLeadingWhitespace  (  text  )  ;  }  accum  .  append  (  text  )  ;    }  else  if  (  child  instanceof  Element  )  {  Element  element  =    (  Element  )  child  ;  if  (  accum  .  length  (  )  >  0  &&  element  .  isBlock  (  )  &&  !TextNode  .  lastCharIsWhitespace  (  accum  )  )  accum  .  append  (   "   "  )  ;  element  .  text  (  accum  )  ;  }  }  }    [METHOD]  text  [TYPE]  void  [PARAMETER]  StringBuilder  accum  [CLASS]  Element    [TYPE]  Set  classNames  [TYPE]  boolean  false  true  [TYPE]  StringBuilder  accum  [TYPE]  Node  child  [TYPE]  Element  element  [TYPE]  TextNode  textNode  [TYPE]  Tag  tag  [TYPE]  String  text  
[ADD]  if  (  child  instanceof  TextNode  )  {  TextNode  textNode  =  (  TextNode  )  child;  String  text  =  textNode  .  getWholeText  (  )  ;	[BUGGY]  TextNode  textNode  =    (  TextNode  )  child  ;  String  text  =  textNode  .  getWholeText  (  )  ;  [CE]  [CONTEXT]  private  void  text  (  StringBuilder  accum  )  {  for  (  Node  child  :  childNodes  )  {  [ATTENTION]  TextNode  textNode  =  (  TextNode  )  child  ;  String  text  =  textNode  .  getWholeText  (  )    ;      if  (  !preserveWhitespace  (  )  )  {  text  =  TextNode  .  normaliseWhitespace  (  text  )  ;  if  (  TextNode  .  lastCharIsWhitespace  (  accum  )  )  text  =  TextNode  .  stripLeadingWhitespace  (  text  )  ;  }  accum  .  append  (  text  )  ;    }  else  if  (  child  instanceof  Element  )  {  Element  element  =    (  Element  )  child  ;  if  (  accum  .  length  (  )  >  0  &&  element  .  isBlock  (  )  &&  !TextNode  .  lastCharIsWhitespace  (  accum  )  )  accum  .  append  (   "   "  )  ;  element  .  text  (  accum  )  ;  }  }  }    [METHOD]  text  [TYPE]  void  [PARAMETER]  StringBuilder  accum  [CLASS]  Element    [TYPE]  Set  classNames  [TYPE]  boolean  false  true  [TYPE]  StringBuilder  accum  [TYPE]  Node  child  [TYPE]  Element  element  [TYPE]  TextNode  textNode  [TYPE]  Tag  tag  [TYPE]  String  text  
[REPLACE]  }  else  if  (  child  instanceof  Element  )  {	[BUGGY]  else  if  (  !  child  instanceof  Element  )  {[CE]  bad  operand  type  Node  for  unary  operator  '!'  [CONTEXT]  private  void  text  (  StringBuilder  accum  )  {  for  (  Node  child  :  childNodes  )  {  if  (  child  instanceof  TextNode  )  {  TextNode  textNode  =    (  TextNode  )  child  ;  String  text  =  textNode  .  getWholeText  (  )  ;    if  (  !preserveWhitespace  (  )  )  {  text  =  TextNode  .  normaliseWhitespace  (  text  )  ;  if  (  TextNode  .  lastCharIsWhitespace  (  accum  )  )  text  =  TextNode  .  stripLeadingWhitespace  (  text  )  ;  }  accum  .  append  (  text  )  ;    [ATTENTION]  }  else  if  (  !  child  instanceof  Element  )  {  Element  element  =    (  Element  )  child  ;  if  (  accum  .  length  (  )  >  0  &&  element  .  isBlock  (  )  &&  !TextNode  .  lastCharIsWhitespace  (  accum  )  )  accum  .  append  (   "   "  )  ;  element  .  text  (  accum  )  ;  }  }  }    [METHOD]  text  [TYPE]  void  [PARAMETER]  StringBuilder  accum  [CLASS]  Element    [TYPE]  Set  classNames  [TYPE]  boolean  false  true  [TYPE]  StringBuilder  accum  [TYPE]  Node  child  [TYPE]  Element  element  [TYPE]  TextNode  textNode  [TYPE]  Tag  tag  [TYPE]  String  text  
[REMOVE]  	[BUGGY]  if  (  childNode  instanceof  DataNode  )  {      DataNode  data  =    (  (  DataNode  )    (  childNode  )  )  ;      sb  .  append  (  data  .  getWholeData  (  )  )  ;  }else      if  (  childNode  instanceof  Element  )  {          Element  element  =    (  (  Element  )    (  childNode  )  )  ;          String  elementData  =  element  .  data  (  )  ;          sb  .  append  (  elementData  )  ;      }[CE]  cannot  find  symbol  childNode  [CONTEXT]  private  void  text  (  StringBuilder  accum  )  {  for  (  Node  child  :  childNodes  )  {  if  (  child  instanceof  TextNode  )  {  TextNode  textNode  =    (  TextNode  )  child  ;  String  text  =  textNode  .  getWholeText  (  )  ;    if  (  !preserveWhitespace  (  )  )  {  text  =  TextNode  .  normaliseWhitespace  (  text  )  ;  if  (  TextNode  .  lastCharIsWhitespace  (  accum  )  )  text  =  TextNode  .  stripLeadingWhitespace  (  text  )  ;  }  accum  .  append  (  text  )  ;    [ATTENTION]  }  else  if  (  child  instanceof  Element  )  {  if  (  childNode  instanceof  DataNode  )  {  DataNode  data  =  (  (  DataNode  )    (  childNode  )  )    ;  sb  .  append  (  data  .  getWholeData  (  )  )    ;  }else  if  (  childNode  instanceof  Element  )  {  Element  element  =  (  (  Element  )    (  childNode  )  )    ;  String  elementData  =  element  .  data  (  )    ;  sb  .  append  (  elementData  )    ;  }Element  element  =    (  Element  )  child  ;  if  (  accum  .  length  (  )  >  0  &&  element  .  isBlock  (  )  &&  !TextNode  .  lastCharIsWhitespace  (  accum  )  )  accum  .  append  (   "   "  )  ;  element  .  text  (  accum  )  ;  }  }    [METHOD]  text  [TYPE]  void  [PARAMETER]  StringBuilder  accum  [CLASS]  Element    [TYPE]  Set  classNames  [TYPE]  boolean  false  true  [TYPE]  StringBuilder  accum  [TYPE]  Node  child  [TYPE]  Element  element  [TYPE]  TextNode  textNode  [TYPE]  Tag  tag  [TYPE]  String  text  
[REPLACE]  if  (  accum  .  length  (  )  >  0  &&  element  .  isBlock  (  )  &&  !TextNode  .  lastCharIsWhitespace  (  accum  )  )  accum  .  append  (   "   "  )  ;	[BUGGY]  if  (  accum  .  length  (  )  +  1  >  0  &&  element  .  isBlock  (  )  &&  !TextNode  .  normaliseWhitespace  (  text  )    )  accum  .  append  (   "   "  )  ;  [CE]  cannot  find  symbol  text  [CONTEXT]  private  void  text  (  StringBuilder  accum  )  {  for  (  Node  child  :  childNodes  )  {  if  (  child  instanceof  TextNode  )  {  TextNode  textNode  =    (  TextNode  )  child  ;  String  text  =  textNode  .  getWholeText  (  )  ;    if  (  !preserveWhitespace  (  )  )  {  text  =  TextNode  .  normaliseWhitespace  (  text  )  ;  if  (  TextNode  .  lastCharIsWhitespace  (  accum  )  )  text  =  TextNode  .  stripLeadingWhitespace  (  text  )  ;  }  accum  .  append  (  text  )  ;    }  else  if  (  child  instanceof  Element  )  {  Element  element  =    (  Element  )  child  ;  [ATTENTION]  if  (  accum  .  length  (  )  +  1  >  0  &&  element  .  isBlock  (  )  &&  !TextNode  .  normaliseWhitespace  (  text  )    )  accum  .  append  (   "   "  )    ;    element  .  text  (  accum  )  ;  }  }  }    [METHOD]  text  [TYPE]  void  [PARAMETER]  StringBuilder  accum  [CLASS]  Element    [TYPE]  Set  classNames  [TYPE]  boolean  false  true  [TYPE]  StringBuilder  accum  [TYPE]  Node  child  [TYPE]  Element  element  [TYPE]  TextNode  textNode  [TYPE]  Tag  tag  [TYPE]  String  text  
[ADD]  if  (  accum  .  length  (  )  >  0  &&  element  .  isBlock  (  )  &&  !TextNode  .  lastCharIsWhitespace  (  accum  )  )  accum  .  append  (   "   "  )  ;  element  .  text  (  accum  )  ;  }	[BUGGY]  [CE]  '  ;  '  expected  [CONTEXT]  private  void  text  (  StringBuilder  accum  )  {  for  (  Node  child  :  childNodes  )  {  if  (  child  instanceof  TextNode  )  {  TextNode  textNode  =    (  TextNode  )  child  ;  String  text  =  textNode  .  getWholeText  (  )  ;    if  (  !preserveWhitespace  (  )  )  {  text  =  TextNode  .  normaliseWhitespace  (  text  )  ;  if  (  TextNode  .  lastCharIsWhitespace  (  accum  )  )  text  =  TextNode  .  stripLeadingWhitespace  (  text  )  ;  }  accum  .  append  (  text  )  ;    }  else  if  (  child  instanceof  Element  )  {  Element  element  =    (  Element  )  child  ;  [ATTENTION]      }  }    [METHOD]  text  [TYPE]  void  [PARAMETER]  StringBuilder  accum  [CLASS]  Element    [TYPE]  Set  classNames  [TYPE]  boolean  false  true  [TYPE]  StringBuilder  accum  [TYPE]  Node  child  [TYPE]  Element  element  [TYPE]  TextNode  textNode  [TYPE]  Tag  tag  [TYPE]  String  text  
[REPLACE]  accum  .  append  (   "   "  )  ;	[BUGGY]  accum  .  append  (   "  /> "  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  private  void  text  (  StringBuilder  accum  )  {  for  (  Node  child  :  childNodes  )  {  if  (  child  instanceof  TextNode  )  {  TextNode  textNode  =    (  TextNode  )  child  ;  String  text  =  textNode  .  getWholeText  (  )  ;    if  (  !preserveWhitespace  (  )  )  {  text  =  TextNode  .  normaliseWhitespace  (  text  )  ;  if  (  TextNode  .  lastCharIsWhitespace  (  accum  )  )  text  =  TextNode  .  stripLeadingWhitespace  (  text  )  ;  }  accum  .  append  (  text  )  ;    }  else  if  (  child  instanceof  Element  )  {  Element  element  =    (  Element  )  child  ;  if  (  accum  .  length  (  )  >  0  &&  element  .  isBlock  (  )  &&  !TextNode  .  lastCharIsWhitespace  (  accum  )  )  [ATTENTION]  accum  .  append  (   "  /> "  )    ;  element  .  text  (  accum  )  ;  }  }  }    [METHOD]  text  [TYPE]  void  [PARAMETER]  StringBuilder  accum  [CLASS]  Element    [TYPE]  Set  classNames  [TYPE]  boolean  false  true  [TYPE]  StringBuilder  accum  [TYPE]  Node  child  [TYPE]  Element  element  [TYPE]  TextNode  textNode  [TYPE]  Tag  tag  [TYPE]  String  text  
[REPLACE]  Element  element  =  (  Element  )  child;	[BUGGY]  Element  element  =    (  Element  )  o  ;  [CE]  cannot  find  symbol  o  [CONTEXT]  private  void  text  (  StringBuilder  accum  )  {  for  (  Node  child  :  childNodes  )  {  if  (  child  instanceof  TextNode  )  {  TextNode  textNode  =    (  TextNode  )  child  ;  String  text  =  textNode  .  getWholeText  (  )  ;    if  (  !preserveWhitespace  (  )  )  {  text  =  TextNode  .  normaliseWhitespace  (  text  )  ;  if  (  TextNode  .  lastCharIsWhitespace  (  accum  )  )  text  =  TextNode  .  stripLeadingWhitespace  (  text  )  ;  }  accum  .  append  (  text  )  ;    }  else  if  (  child  instanceof  Element  )  {  [ATTENTION]  Element  element  =  (  Element  )  o  ;  if  (  accum  .  length  (  )  >  0  &&  element  .  isBlock  (  )  &&  !TextNode  .  lastCharIsWhitespace  (  accum  )  )  accum  .  append  (   "   "  )  ;  element  .  text  (  accum  )  ;  }  }  }    [METHOD]  text  [TYPE]  void  [PARAMETER]  StringBuilder  accum  [CLASS]  Element    [TYPE]  Set  classNames  [TYPE]  boolean  false  true  [TYPE]  StringBuilder  accum  [TYPE]  Node  child  [TYPE]  Element  element  [TYPE]  TextNode  textNode  [TYPE]  Tag  tag  [TYPE]  String  text  
[ADD]  Element  element  =  (  Element  )  child;	[BUGGY]  [CE]  cannot  find  symbol  element  [CONTEXT]  private  void  text  (  StringBuilder  accum  )  {  for  (  Node  child  :  childNodes  )  {  if  (  child  instanceof  TextNode  )  {  TextNode  textNode  =    (  TextNode  )  child  ;  String  text  =  textNode  .  getWholeText  (  )  ;    if  (  !preserveWhitespace  (  )  )  {  text  =  TextNode  .  normaliseWhitespace  (  text  )  ;  if  (  TextNode  .  lastCharIsWhitespace  (  accum  )  )  text  =  TextNode  .  stripLeadingWhitespace  (  text  )  ;  }  accum  .  append  (  text  )  ;    }  else  if  (  child  instanceof  Element  )  {  [ATTENTION]  if  (  accum  .  length  (  )  >  0  &&  element  .  isBlock  (  )  &&  !TextNode  .  lastCharIsWhitespace  (  accum  )  )  accum  .  append  (   "   "  )  ;  element  .  text  (  accum  )  ;  }  }  }    [METHOD]  text  [TYPE]  void  [PARAMETER]  StringBuilder  accum  [CLASS]  Element    [TYPE]  Set  classNames  [TYPE]  boolean  false  true  [TYPE]  StringBuilder  accum  [TYPE]  Node  child  [TYPE]  Element  element  [TYPE]  TextNode  textNode  [TYPE]  Tag  tag  [TYPE]  String  text  
[REPLACE]  if  (  accum  .  length  (  )  >  0  &&  element  .  isBlock  (  )  &&  !TextNode  .  lastCharIsWhitespace  (  accum  )  )  accum  .  append  (   "   "  )  ;	[BUGGY]  if  (  accum  .  size  (  )  >  0  &&  element  .  child  (  )  &&  !TextNode  .  lastCharIsWhitespace  (  accum  )  )  accum  .  append  (   "   "  )  ;  [CE]  cannot  find  symbol  [CONTEXT]  private  void  text  (  StringBuilder  accum  )  {  for  (  Node  child  :  childNodes  )  {  if  (  child  instanceof  TextNode  )  {  TextNode  textNode  =    (  TextNode  )  child  ;  String  text  =  textNode  .  getWholeText  (  )  ;    if  (  !preserveWhitespace  (  )  )  {  text  =  TextNode  .  normaliseWhitespace  (  text  )  ;  if  (  TextNode  .  lastCharIsWhitespace  (  accum  )  )  text  =  TextNode  .  stripLeadingWhitespace  (  text  )  ;  }  accum  .  append  (  text  )  ;    }  else  if  (  child  instanceof  Element  )  {  Element  element  =    (  Element  )  child  ;  [ATTENTION]  if  (  accum  .  size  (  )  >  0  &&  element  .  child  (  )  &&  !TextNode  .  lastCharIsWhitespace  (  accum  )  )  accum  .  append  (   "   "  )    ;    element  .  text  (  accum  )  ;  }  }  }    [METHOD]  text  [TYPE]  void  [PARAMETER]  StringBuilder  accum  [CLASS]  Element    [TYPE]  Set  classNames  [TYPE]  boolean  false  true  [TYPE]  StringBuilder  accum  [TYPE]  Node  child  [TYPE]  Element  element  [TYPE]  TextNode  textNode  [TYPE]  Tag  tag  [TYPE]  String  text  
[REPLACE]  if  (  !preserveWhitespace  (  )  )  {	[BUGGY]  if  (  preserveWhitespace  (  )  )  {[FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  private  void  text  (  StringBuilder  accum  )  {  for  (  Node  child  :  childNodes  )  {  if  (  child  instanceof  TextNode  )  {  TextNode  textNode  =    (  TextNode  )  child  ;  String  text  =  textNode  .  getWholeText  (  )  ;    [ATTENTION]  if  (  preserveWhitespace  (  )  )  {  text  =  TextNode  .  normaliseWhitespace  (  text  )  ;  if  (  TextNode  .  lastCharIsWhitespace  (  accum  )  )  text  =  TextNode  .  stripLeadingWhitespace  (  text  )  ;  }  accum  .  append  (  text  )  ;    }  else  if  (  child  instanceof  Element  )  {  Element  element  =    (  Element  )  child  ;  if  (  accum  .  length  (  )  >  0  &&  element  .  isBlock  (  )  &&  !TextNode  .  lastCharIsWhitespace  (  accum  )  )  accum  .  append  (   "   "  )  ;  element  .  text  (  accum  )  ;  }  }  }    [METHOD]  text  [TYPE]  void  [PARAMETER]  StringBuilder  accum  [CLASS]  Element    [TYPE]  Set  classNames  [TYPE]  boolean  false  true  [TYPE]  StringBuilder  accum  [TYPE]  Node  child  [TYPE]  Element  element  [TYPE]  TextNode  textNode  [TYPE]  Tag  tag  [TYPE]  String  text  
[REPLACE]  if  (  TextNode  .  lastCharIsWhitespace  (  accum  )  )  text  =  TextNode  .  stripLeadingWhitespace  (  text  )  ;	[BUGGY]  if  (  TextNode  .  normaliseWhitespace  (  accum  )  )  text  =  TextNode  .  stripLeadingWhitespace  (  text  )  ;  [CE]  method  normaliseWhitespace  in  class  TextNode  cannot  be  applied  to  given  types  ;  [CONTEXT]  private  void  text  (  StringBuilder  accum  )  {  for  (  Node  child  :  childNodes  )  {  if  (  child  instanceof  TextNode  )  {  TextNode  textNode  =    (  TextNode  )  child  ;  String  text  =  textNode  .  getWholeText  (  )  ;    if  (  !preserveWhitespace  (  )  )  {  text  =  TextNode  .  normaliseWhitespace  (  text  )  ;  [ATTENTION]  if  (  TextNode  .  normaliseWhitespace  (  accum  )  )  text  =  TextNode  .  stripLeadingWhitespace  (  text  )    ;    }  accum  .  append  (  text  )  ;    }  else  if  (  child  instanceof  Element  )  {  Element  element  =    (  Element  )  child  ;  if  (  accum  .  length  (  )  >  0  &&  element  .  isBlock  (  )  &&  !TextNode  .  lastCharIsWhitespace  (  accum  )  )  accum  .  append  (   "   "  )  ;  element  .  text  (  accum  )  ;  }  }  }    [METHOD]  text  [TYPE]  void  [PARAMETER]  StringBuilder  accum  [CLASS]  Element    [TYPE]  Set  classNames  [TYPE]  boolean  false  true  [TYPE]  StringBuilder  accum  [TYPE]  Node  child  [TYPE]  Element  element  [TYPE]  TextNode  textNode  [TYPE]  Tag  tag  [TYPE]  String  text  
[REPLACE]  text  =  TextNode  .  stripLeadingWhitespace  (  text  )  ;	[BUGGY]  text  =  TextNode  .  normaliseWhitespace  (  text  )  ;    ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  private  void  text  (  StringBuilder  accum  )  {  for  (  Node  child  :  childNodes  )  {  if  (  child  instanceof  TextNode  )  {  TextNode  textNode  =    (  TextNode  )  child  ;  String  text  =  textNode  .  getWholeText  (  )  ;    if  (  !preserveWhitespace  (  )  )  {  text  =  TextNode  .  normaliseWhitespace  (  text  )  ;  if  (  TextNode  .  lastCharIsWhitespace  (  accum  )  )  [ATTENTION]  text  =  TextNode  .  normaliseWhitespace  (  text  )    ;    ;  }  accum  .  append  (  text  )  ;    }  else  if  (  child  instanceof  Element  )  {  Element  element  =    (  Element  )  child  ;  if  (  accum  .  length  (  )  >  0  &&  element  .  isBlock  (  )  &&  !TextNode  .  lastCharIsWhitespace  (  accum  )  )  accum  .  append  (   "   "  )  ;  element  .  text  (  accum  )  ;  }  }  }    [METHOD]  text  [TYPE]  void  [PARAMETER]  StringBuilder  accum  [CLASS]  Element    [TYPE]  Set  classNames  [TYPE]  boolean  false  true  [TYPE]  StringBuilder  accum  [TYPE]  Node  child  [TYPE]  Element  element  [TYPE]  TextNode  textNode  [TYPE]  Tag  tag  [TYPE]  String  text  
[ADD]  text  =  TextNode  .  stripLeadingWhitespace  (  text  )  ;	[BUGGY]  [CE]  illegal  start  of  expression  [CONTEXT]  private  void  text  (  StringBuilder  accum  )  {  for  (  Node  child  :  childNodes  )  {  if  (  child  instanceof  TextNode  )  {  TextNode  textNode  =    (  TextNode  )  child  ;  String  text  =  textNode  .  getWholeText  (  )  ;    if  (  !preserveWhitespace  (  )  )  {  text  =  TextNode  .  normaliseWhitespace  (  text  )  ;  if  (  TextNode  .  lastCharIsWhitespace  (  accum  )  )  [ATTENTION]  }  accum  .  append  (  text  )  ;    }  else  if  (  child  instanceof  Element  )  {  Element  element  =    (  Element  )  child  ;  if  (  accum  .  length  (  )  >  0  &&  element  .  isBlock  (  )  &&  !TextNode  .  lastCharIsWhitespace  (  accum  )  )  accum  .  append  (   "   "  )  ;  element  .  text  (  accum  )  ;  }  }  }    [METHOD]  text  [TYPE]  void  [PARAMETER]  StringBuilder  accum  [CLASS]  Element    [TYPE]  Set  classNames  [TYPE]  boolean  false  true  [TYPE]  StringBuilder  accum  [TYPE]  Node  child  [TYPE]  Element  element  [TYPE]  TextNode  textNode  [TYPE]  Tag  tag  [TYPE]  String  text  
[REPLACE]  text  =  TextNode  .  normaliseWhitespace  (  text  )  ;	[BUGGY]  text  =  TextNode  .  stripLeadingWhitespace  (  text  )  ;    ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  private  void  text  (  StringBuilder  accum  )  {  for  (  Node  child  :  childNodes  )  {  if  (  child  instanceof  TextNode  )  {  TextNode  textNode  =    (  TextNode  )  child  ;  String  text  =  textNode  .  getWholeText  (  )  ;    if  (  !preserveWhitespace  (  )  )  {  [ATTENTION]  text  =  TextNode  .  stripLeadingWhitespace  (  text  )    ;    ;  if  (  TextNode  .  lastCharIsWhitespace  (  accum  )  )  text  =  TextNode  .  stripLeadingWhitespace  (  text  )  ;  }  accum  .  append  (  text  )  ;    }  else  if  (  child  instanceof  Element  )  {  Element  element  =    (  Element  )  child  ;  if  (  accum  .  length  (  )  >  0  &&  element  .  isBlock  (  )  &&  !TextNode  .  lastCharIsWhitespace  (  accum  )  )  accum  .  append  (   "   "  )  ;  element  .  text  (  accum  )  ;  }  }  }    [METHOD]  text  [TYPE]  void  [PARAMETER]  StringBuilder  accum  [CLASS]  Element    [TYPE]  Set  classNames  [TYPE]  boolean  false  true  [TYPE]  StringBuilder  accum  [TYPE]  Node  child  [TYPE]  Element  element  [TYPE]  TextNode  textNode  [TYPE]  Tag  tag  [TYPE]  String  text  
[ADD]  text  =  TextNode  .  normaliseWhitespace  (  text  )  ;	[BUGGY]  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  private  void  text  (  StringBuilder  accum  )  {  for  (  Node  child  :  childNodes  )  {  if  (  child  instanceof  TextNode  )  {  TextNode  textNode  =    (  TextNode  )  child  ;  String  text  =  textNode  .  getWholeText  (  )  ;    if  (  !preserveWhitespace  (  )  )  {  [ATTENTION]  if  (  TextNode  .  lastCharIsWhitespace  (  accum  )  )  text  =  TextNode  .  stripLeadingWhitespace  (  text  )  ;  }  accum  .  append  (  text  )  ;    }  else  if  (  child  instanceof  Element  )  {  Element  element  =    (  Element  )  child  ;  if  (  accum  .  length  (  )  >  0  &&  element  .  isBlock  (  )  &&  !TextNode  .  lastCharIsWhitespace  (  accum  )  )  accum  .  append  (   "   "  )  ;  element  .  text  (  accum  )  ;  }  }  }    [METHOD]  text  [TYPE]  void  [PARAMETER]  StringBuilder  accum  [CLASS]  Element    [TYPE]  Set  classNames  [TYPE]  boolean  false  true  [TYPE]  StringBuilder  accum  [TYPE]  Node  child  [TYPE]  Element  element  [TYPE]  TextNode  textNode  [TYPE]  Tag  tag  [TYPE]  String  text  
[REPLACE]  if  (  TextNode  .  lastCharIsWhitespace  (  accum  )  )  text  =  TextNode  .  stripLeadingWhitespace  (  text  )  ;	[BUGGY]  if  (  TextNode  .  lastCharIsWhitespace  (  accum  )  )  text  =  TextNode  .  normaliseWhitespace  (  text  )    ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  private  void  text  (  StringBuilder  accum  )  {  for  (  Node  child  :  childNodes  )  {  if  (  child  instanceof  TextNode  )  {  TextNode  textNode  =    (  TextNode  )  child  ;  String  text  =  textNode  .  getWholeText  (  )  ;    if  (  !preserveWhitespace  (  )  )  {  text  =  TextNode  .  normaliseWhitespace  (  text  )  ;  [ATTENTION]  if  (  TextNode  .  lastCharIsWhitespace  (  accum  )  )  text  =  TextNode  .  normaliseWhitespace  (  text  )  ;    }  accum  .  append  (  text  )  ;    }  else  if  (  child  instanceof  Element  )  {  Element  element  =    (  Element  )  child  ;  if  (  accum  .  length  (  )  >  0  &&  element  .  isBlock  (  )  &&  !TextNode  .  lastCharIsWhitespace  (  accum  )  )  accum  .  append  (   "   "  )  ;  element  .  text  (  accum  )  ;  }  }  }    [METHOD]  text  [TYPE]  void  [PARAMETER]  StringBuilder  accum  [CLASS]  Element    [TYPE]  Set  classNames  [TYPE]  boolean  false  true  [TYPE]  StringBuilder  accum  [TYPE]  Node  child  [TYPE]  Element  element  [TYPE]  TextNode  textNode  [TYPE]  Tag  tag  [TYPE]  String  text  
[REPLACE]  TextNode  textNode  =  (  TextNode  )  child;	[BUGGY]  TextNode  textNode  =  new  TextNode  (  text  ,  baseUri  )  ;  [CE]  cannot  find  symbol  text  [CONTEXT]  private  void  text  (  StringBuilder  accum  )  {  for  (  Node  child  :  childNodes  )  {  if  (  child  instanceof  TextNode  )  {  [ATTENTION]  TextNode  textNode  =  new  TextNode  (  text  ,  baseUri  )    ;  String  text  =  textNode  .  getWholeText  (  )  ;    if  (  !preserveWhitespace  (  )  )  {  text  =  TextNode  .  normaliseWhitespace  (  text  )  ;  if  (  TextNode  .  lastCharIsWhitespace  (  accum  )  )  text  =  TextNode  .  stripLeadingWhitespace  (  text  )  ;  }  accum  .  append  (  text  )  ;    }  else  if  (  child  instanceof  Element  )  {  Element  element  =    (  Element  )  child  ;  if  (  accum  .  length  (  )  >  0  &&  element  .  isBlock  (  )  &&  !TextNode  .  lastCharIsWhitespace  (  accum  )  )  accum  .  append  (   "   "  )  ;  element  .  text  (  accum  )  ;  }  }  }    [METHOD]  text  [TYPE]  void  [PARAMETER]  StringBuilder  accum  [CLASS]  Element    [TYPE]  Set  classNames  [TYPE]  boolean  false  true  [TYPE]  StringBuilder  accum  [TYPE]  Node  child  [TYPE]  Element  element  [TYPE]  TextNode  textNode  [TYPE]  Tag  tag  [TYPE]  String  text  
[REPLACE]  String  text  =  textNode  .  getWholeText  (  )  ;	[BUGGY]  String  text  =  textNode  .  isBlank  (  )  ;  [CE]  incompatible  types  [CONTEXT]  private  void  text  (  StringBuilder  accum  )  {  for  (  Node  child  :  childNodes  )  {  if  (  child  instanceof  TextNode  )  {  TextNode  textNode  =    (  TextNode  )  child  ;  [ATTENTION]  String  text  =  textNode  .  isBlank  (  )    ;    if  (  !preserveWhitespace  (  )  )  {  text  =  TextNode  .  normaliseWhitespace  (  text  )  ;  if  (  TextNode  .  lastCharIsWhitespace  (  accum  )  )  text  =  TextNode  .  stripLeadingWhitespace  (  text  )  ;  }  accum  .  append  (  text  )  ;    }  else  if  (  child  instanceof  Element  )  {  Element  element  =    (  Element  )  child  ;  if  (  accum  .  length  (  )  >  0  &&  element  .  isBlock  (  )  &&  !TextNode  .  lastCharIsWhitespace  (  accum  )  )  accum  .  append  (   "   "  )  ;  element  .  text  (  accum  )  ;  }  }  }    [METHOD]  text  [TYPE]  void  [PARAMETER]  StringBuilder  accum  [CLASS]  Element    [TYPE]  Set  classNames  [TYPE]  boolean  false  true  [TYPE]  StringBuilder  accum  [TYPE]  Node  child  [TYPE]  Element  element  [TYPE]  TextNode  textNode  [TYPE]  Tag  tag  [TYPE]  String  text  
[REPLACE]  if  (  TextNode  .  lastCharIsWhitespace  (  accum  )  )  text  =  TextNode  .  stripLeadingWhitespace  (  text  )  ;	[BUGGY]  if  (  TextNode  .  lastCharIsWhitespace  (  accum  )  )  text  =  TextNode  .  normaliseWhitespace  (  text  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  private  void  text  (  StringBuilder  accum  )  {  for  (  Node  child  :  childNodes  )  {  if  (  child  instanceof  TextNode  )  {  TextNode  textNode  =    (  TextNode  )  child  ;  String  text  =  textNode  .  getWholeText  (  )  ;    if  (  !preserveWhitespace  (  )  )  {  text  =  TextNode  .  normaliseWhitespace  (  text  )  ;  [ATTENTION]  if  (  TextNode  .  lastCharIsWhitespace  (  accum  )  )  text  =  TextNode  .  normaliseWhitespace  (  text  )    ;    }  accum  .  append  (  text  )  ;    }  else  if  (  child  instanceof  Element  )  {  Element  element  =    (  Element  )  child  ;  if  (  accum  .  length  (  )  >  0  &&  element  .  isBlock  (  )  &&  !TextNode  .  lastCharIsWhitespace  (  accum  )  )  accum  .  append  (   "   "  )  ;  element  .  text  (  accum  )  ;  }  }  }    [METHOD]  text  [TYPE]  void  [PARAMETER]  StringBuilder  accum  [CLASS]  Element    [TYPE]  Set  classNames  [TYPE]  boolean  false  true  [TYPE]  StringBuilder  accum  [TYPE]  Node  child  [TYPE]  Element  element  [TYPE]  TextNode  textNode  [TYPE]  Tag  tag  [TYPE]  String  text  
[REPLACE]  }  else  if  (  child  instanceof  Element  )  {	[BUGGY]    if  (  !  child  instanceof  Element  )  {[CE]  bad  operand  type  Node  for  unary  operator  '!'  [CONTEXT]  private  void  text  (  StringBuilder  accum  )  {  for  (  Node  child  :  childNodes  )  {  if  (  child  instanceof  TextNode  )  {  TextNode  textNode  =    (  TextNode  )  child  ;  String  text  =  textNode  .  getWholeText  (  )  ;    if  (  !preserveWhitespace  (  )  )  {  text  =  TextNode  .  normaliseWhitespace  (  text  )  ;  if  (  TextNode  .  lastCharIsWhitespace  (  accum  )  )  text  =  TextNode  .  stripLeadingWhitespace  (  text  )  ;  }  accum  .  append  (  text  )  ;    [ATTENTION]  }if  (  !  child  instanceof  Element  )  {  Element  element  =    (  Element  )  child  ;  if  (  accum  .  length  (  )  >  0  &&  element  .  isBlock  (  )  &&  !TextNode  .  lastCharIsWhitespace  (  accum  )  )  accum  .  append  (   "   "  )  ;  element  .  text  (  accum  )  ;  }  }  }    [METHOD]  text  [TYPE]  void  [PARAMETER]  StringBuilder  accum  [CLASS]  Element    [TYPE]  Set  classNames  [TYPE]  boolean  false  true  [TYPE]  StringBuilder  accum  [TYPE]  Node  child  [TYPE]  Element  element  [TYPE]  TextNode  textNode  [TYPE]  Tag  tag  [TYPE]  String  text  
[ADD]  else  if  (  child  instanceof  Element  )  {  Element  element  =  (  Element  )  child;  if  (  accum  .  length  (  )  >  0  &&  element  .  isBlock  (  )  &&  !TextNode  .  lastCharIsWhitespace  (  accum  )  )  accum  .  append  (   "   "  )  ;  element  .  text  (  accum  )  ;	[BUGGY]    Element  element  =    (  Element  )  child  ;  accum  .  append  (   "   "  )  ;  element  .  text  (  accum  )  ;  [CE]  class  ,  interface  ,  or  enum  expected  [CONTEXT]  private  void  text  (  StringBuilder  accum  )  {  for  (  Node  child  :  childNodes  )  {  if  (  child  instanceof  TextNode  )  {  TextNode  textNode  =    (  TextNode  )  child  ;  String  text  =  textNode  .  getWholeText  (  )  ;    if  (  !preserveWhitespace  (  )  )  {  text  =  TextNode  .  normaliseWhitespace  (  text  )  ;  if  (  TextNode  .  lastCharIsWhitespace  (  accum  )  )  text  =  TextNode  .  stripLeadingWhitespace  (  text  )  ;  }  accum  .  append  (  text  )  ;    [ATTENTION]  }  Element  element  =  (  Element  )  child  ;  accum  .  append  (   "   "  )    ;  element  .  text  (  accum  )    ;      }  }  }    [METHOD]  text  [TYPE]  void  [PARAMETER]  StringBuilder  accum  [CLASS]  Element    [TYPE]  Set  classNames  [TYPE]  boolean  false  true  [TYPE]  StringBuilder  accum  [TYPE]  Node  child  [TYPE]  Element  element  [TYPE]  TextNode  textNode  [TYPE]  Tag  tag  [TYPE]  String  text  
[REPLACE]  if  (  accum  .  length  (  )  >  0  &&  element  .  isBlock  (  )  &&  !TextNode  .  lastCharIsWhitespace  (  accum  )  )  accum  .  append  (   "   "  )  ;	[BUGGY]  if  (  accum  .  size  (  )  >  0  &&  element  .  isBlock  (  )  &&  !TextNode  .  lastCharIsWhitespace  (  accum  )  )  accum  .  append  (   "   "  )  ;  [CE]  cannot  find  symbol  [CONTEXT]  private  void  text  (  StringBuilder  accum  )  {  for  (  Node  child  :  childNodes  )  {  if  (  child  instanceof  TextNode  )  {  TextNode  textNode  =    (  TextNode  )  child  ;  String  text  =  textNode  .  getWholeText  (  )  ;    if  (  !preserveWhitespace  (  )  )  {  text  =  TextNode  .  normaliseWhitespace  (  text  )  ;  if  (  TextNode  .  lastCharIsWhitespace  (  accum  )  )  text  =  TextNode  .  stripLeadingWhitespace  (  text  )  ;  }  accum  .  append  (  text  )  ;    }  else  if  (  child  instanceof  Element  )  {  Element  element  =    (  Element  )  child  ;  [ATTENTION]  if  (  accum  .  size  (  )  >  0&&  element  .  isBlock  (  )  &&  !TextNode  .  lastCharIsWhitespace  (  accum  )  )  accum  .  append  (   "   "  )    ;    element  .  text  (  accum  )  ;  }  }  }    [METHOD]  text  [TYPE]  void  [PARAMETER]  StringBuilder  accum  [CLASS]  Element    [TYPE]  Set  classNames  [TYPE]  boolean  false  true  [TYPE]  StringBuilder  accum  [TYPE]  Node  child  [TYPE]  Element  element  [TYPE]  TextNode  textNode  [TYPE]  Tag  tag  [TYPE]  String  text  
[REPLACE]  if  (  accum  .  length  (  )  >  0  &&  element  .  isBlock  (  )  &&  !TextNode  .  lastCharIsWhitespace  (  accum  )  )  accum  .  append  (   "   "  )  ;	[BUGGY]  if  (  accum  .  length  (  )  /  2  >  0  &&  element  .  isBlock  (  )  &&  !TextNode  .  lastCharIsWhitespace  (  accum  )  )  accum  .  append  (   "   "  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  private  void  text  (  StringBuilder  accum  )  {  for  (  Node  child  :  childNodes  )  {  if  (  child  instanceof  TextNode  )  {  TextNode  textNode  =    (  TextNode  )  child  ;  String  text  =  textNode  .  getWholeText  (  )  ;    if  (  !preserveWhitespace  (  )  )  {  text  =  TextNode  .  normaliseWhitespace  (  text  )  ;  if  (  TextNode  .  lastCharIsWhitespace  (  accum  )  )  text  =  TextNode  .  stripLeadingWhitespace  (  text  )  ;  }  accum  .  append  (  text  )  ;    }  else  if  (  child  instanceof  Element  )  {  Element  element  =    (  Element  )  child  ;  [ATTENTION]  if  (  accum  .  length  (  )  /2  >  0  &&  element  .  isBlock  (  )  &&  !TextNode  .  lastCharIsWhitespace  (  accum  )  )  accum  .  append  (   "   "  )    ;    element  .  text  (  accum  )  ;  }  }  }    [METHOD]  text  [TYPE]  void  [PARAMETER]  StringBuilder  accum  [CLASS]  Element    [TYPE]  Set  classNames  [TYPE]  boolean  false  true  [TYPE]  StringBuilder  accum  [TYPE]  Node  child  [TYPE]  Element  element  [TYPE]  TextNode  textNode  [TYPE]  Tag  tag  [TYPE]  String  text  
[REPLACE]  for  (  Node  child  :  childNodes  )  {	[BUGGY]  List<Node>  nodes  =  fragment  .  childNodes  (  )  ;  [CE]  class  ,  interface  ,  or  enum  expected  [CONTEXT]  private  void  text  (  StringBuilder  accum  )  {  [ATTENTION]  List<Node>  nodes  =  fragment  .  childNodes  (  )    ;  if  (  child  instanceof  TextNode  )  {  TextNode  textNode  =    (  TextNode  )  child  ;  String  text  =  textNode  .  getWholeText  (  )  ;    if  (  !preserveWhitespace  (  )  )  {  text  =  TextNode  .  normaliseWhitespace  (  text  )  ;  if  (  TextNode  .  lastCharIsWhitespace  (  accum  )  )  text  =  TextNode  .  stripLeadingWhitespace  (  text  )  ;  }  accum  .  append  (  text  )  ;    }  else  if  (  child  instanceof  Element  )  {  Element  element  =    (  Element  )  child  ;  if  (  accum  .  length  (  )  >  0  &&  element  .  isBlock  (  )  &&  !TextNode  .  lastCharIsWhitespace  (  accum  )  )  accum  .  append  (   "   "  )  ;  element  .  text  (  accum  )  ;  }  }  }    [METHOD]  text  [TYPE]  void  [PARAMETER]  StringBuilder  accum  [CLASS]  Element    [TYPE]  Set  classNames  [TYPE]  boolean  false  true  [TYPE]  StringBuilder  accum  [TYPE]  Node  child  [TYPE]  Element  element  [TYPE]  TextNode  textNode  [TYPE]  Tag  tag  [TYPE]  String  text  
[REPLACE]  return  tag  .  preserveWhitespace  (  )  ||  parent  (  )  !=  null  &&  parent  (  )    .  preserveWhitespace  (  )  ;	[BUGGY]  return  tag  .  prepend  (  )  ||  parent  (  )  !  =  null  &&  parent  (  )  .  preserveWhitespace  (  )  ;  [CE]  cannot  find  symbol  [CONTEXT]  boolean  preserveWhitespace  (  )  {  [ATTENTION]  return  tag  .  prepend  (  )  ||  parent  (  )  !  =  null  &&  parent  (  )    .  preserveWhitespace  (  )    ;  }    [METHOD]  preserveWhitespace  [TYPE]  boolean  [PARAMETER]  [CLASS]  Element    [TYPE]  Set  classNames  [TYPE]  Tag  tag  [TYPE]  boolean  false  true  
[REPLACE]  Validate  .  notNull  (  text  )  ;	[BUGGY]  Validate  .  notEmpty  (  text  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  Element  text  (  String  text  )  {  [ATTENTION]  Validate  .  notEmpty  (  text  )    ;    empty  (  )  ;  TextNode  textNode  =  new  TextNode  (  text  ,  baseUri  )  ;  appendChild  (  textNode  )  ;    return  this  ;  }    [METHOD]  text  [TYPE]  Element  [PARAMETER]  String  text  [CLASS]  Element    [TYPE]  TextNode  textNode  [TYPE]  Set  classNames  [TYPE]  Tag  tag  [TYPE]  String  text  [TYPE]  boolean  false  true  
[REPLACE]  empty  (  )  ;	[BUGGY]  append  (  html  )  ;  [CE]  cannot  find  symbol  html  [CONTEXT]  public  Element  text  (  String  text  )  {  Validate  .  notNull  (  text  )  ;    [ATTENTION]  append  (  html  )    ;  TextNode  textNode  =  new  TextNode  (  text  ,  baseUri  )  ;  appendChild  (  textNode  )  ;    return  this  ;  }    [METHOD]  text  [TYPE]  Element  [PARAMETER]  String  text  [CLASS]  Element    [TYPE]  TextNode  textNode  [TYPE]  Set  classNames  [TYPE]  Tag  tag  [TYPE]  String  text  [TYPE]  boolean  false  true  
[REPLACE]  TextNode  textNode  =  new  TextNode  (  text,  baseUri  )  ;	[BUGGY]  Node  node  =  nodes  .  get  (  i  )  ;  [CE]  cannot  find  symbol  i  [CONTEXT]  public  Element  text  (  String  text  )  {  Validate  .  notNull  (  text  )  ;    empty  (  )  ;  [ATTENTION]  Node  node  =  nodes  .  get  (  i  )    ;  appendChild  (  textNode  )  ;    return  this  ;  }    [METHOD]  text  [TYPE]  Element  [PARAMETER]  String  text  [CLASS]  Element    [TYPE]  TextNode  textNode  [TYPE]  Set  classNames  [TYPE]  Tag  tag  [TYPE]  String  text  [TYPE]  boolean  false  true  
[REPLACE]  appendChild  (  textNode  )  ;	[BUGGY]  prependChild  (  node  )  ;  [CE]  cannot  find  symbol  node  [CONTEXT]  public  Element  text  (  String  text  )  {  Validate  .  notNull  (  text  )  ;    empty  (  )  ;  TextNode  textNode  =  new  TextNode  (  text  ,  baseUri  )  ;  [ATTENTION]  prependChild  (  node  )    ;    return  this  ;  }    [METHOD]  text  [TYPE]  Element  [PARAMETER]  String  text  [CLASS]  Element    [TYPE]  TextNode  textNode  [TYPE]  Set  classNames  [TYPE]  Tag  tag  [TYPE]  String  text  [TYPE]  boolean  false  true  
[REPLACE]  return  this;	[BUGGY]  return  null  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  Element  text  (  String  text  )  {  Validate  .  notNull  (  text  )  ;    empty  (  )  ;  TextNode  textNode  =  new  TextNode  (  text  ,  baseUri  )  ;  appendChild  (  textNode  )  ;    [ATTENTION]  return  null  ;  }    [METHOD]  text  [TYPE]  Element  [PARAMETER]  String  text  [CLASS]  Element    [TYPE]  TextNode  textNode  [TYPE]  Set  classNames  [TYPE]  Tag  tag  [TYPE]  String  text  [TYPE]  boolean  false  true  
[REPLACE]  if  (  child  instanceof  TextNode  )  {	[BUGGY]  if  (  !  child  instanceof  TextNode  )  {[CE]  bad  operand  type  Node  for  unary  operator  '!'  [CONTEXT]  public  boolean  hasText  (  )  {  for  (  Node  child:  childNodes  )  {  [ATTENTION]  if  (  !  child  instanceof  TextNode  )  {  TextNode  textNode  =    (  TextNode  )  child  ;  if  (  !textNode  .  isBlank  (  )  )  return  true  ;  }  else  if  (  child  instanceof  Element  )  {  Element  el  =    (  Element  )  child  ;  if  (  el  .  hasText  (  )  )  return  true  ;  }  }  return  false  ;  }    [METHOD]  hasText  [TYPE]  boolean  [PARAMETER]  [CLASS]  Element    [TYPE]  TextNode  textNode  [TYPE]  Set  classNames  [TYPE]  Tag  tag  [TYPE]  boolean  false  true  [TYPE]  Node  child  [TYPE]  Element  el  
[ADD]  if  (  child  instanceof  TextNode  )  {  TextNode  textNode  =  (  TextNode  )  child;  if  (  !textNode  .  isBlank  (  )  )  return  true;	[BUGGY]  [CE]  [CONTEXT]  public  boolean  hasText  (  )  {  for  (  Node  child:  childNodes  )  {  [ATTENTION]      }  else  if  (  child  instanceof  Element  )  {  Element  el  =    (  Element  )  child  ;  if  (  el  .  hasText  (  )  )  return  true  ;  }  }  return  false  ;  }    [METHOD]  hasText  [TYPE]  boolean  [PARAMETER]  [CLASS]  Element    [TYPE]  TextNode  textNode  [TYPE]  Set  classNames  [TYPE]  Tag  tag  [TYPE]  boolean  false  true  [TYPE]  Node  child  [TYPE]  Element  el  
[REPLACE]  }  else  if  (  child  instanceof  Element  )  {	[BUGGY]    else  {[FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  boolean  hasText  (  )  {  for  (  Node  child:  childNodes  )  {  if  (  child  instanceof  TextNode  )  {  TextNode  textNode  =    (  TextNode  )  child  ;  if  (  !textNode  .  isBlank  (  )  )  return  true  ;  [ATTENTION]  }else  {  Element  el  =    (  Element  )  child  ;  if  (  el  .  hasText  (  )  )  return  true  ;  }  }  return  false  ;  }    [METHOD]  hasText  [TYPE]  boolean  [PARAMETER]  [CLASS]  Element    [TYPE]  TextNode  textNode  [TYPE]  Set  classNames  [TYPE]  Tag  tag  [TYPE]  boolean  false  true  [TYPE]  Node  child  [TYPE]  Element  el  
[REPLACE]  if  (  el  .  hasText  (  )  )  return  true;	[BUGGY]  if  (  el  .  text  (  )  )  return  false  ;  [CE]  incompatible  types  [CONTEXT]  public  boolean  hasText  (  )  {  for  (  Node  child:  childNodes  )  {  if  (  child  instanceof  TextNode  )  {  TextNode  textNode  =    (  TextNode  )  child  ;  if  (  !textNode  .  isBlank  (  )  )  return  true  ;  }  else  if  (  child  instanceof  Element  )  {  Element  el  =    (  Element  )  child  ;  [ATTENTION]  if  (  el  .  text  (  )  )  return  false  ;    }  }  return  false  ;  }    [METHOD]  hasText  [TYPE]  boolean  [PARAMETER]  [CLASS]  Element    [TYPE]  TextNode  textNode  [TYPE]  Set  classNames  [TYPE]  Tag  tag  [TYPE]  boolean  false  true  [TYPE]  Node  child  [TYPE]  Element  el  
[REPLACE]  return  true;	[BUGGY]  return  false  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  boolean  hasText  (  )  {  for  (  Node  child:  childNodes  )  {  if  (  child  instanceof  TextNode  )  {  TextNode  textNode  =    (  TextNode  )  child  ;  if  (  !textNode  .  isBlank  (  )  )  return  true  ;  }  else  if  (  child  instanceof  Element  )  {  Element  el  =    (  Element  )  child  ;  if  (  el  .  hasText  (  )  )  [ATTENTION]  return  false  ;  }  }  return  false  ;  }    [METHOD]  hasText  [TYPE]  boolean  [PARAMETER]  [CLASS]  Element    [TYPE]  TextNode  textNode  [TYPE]  Set  classNames  [TYPE]  Tag  tag  [TYPE]  boolean  false  true  [TYPE]  Node  child  [TYPE]  Element  el  
[REPLACE]  Element  el  =  (  Element  )  child;	[BUGGY]  Element  element  =    (  Element  )  child  ;  [CE]  cannot  find  symbol  el  [CONTEXT]  public  boolean  hasText  (  )  {  for  (  Node  child:  childNodes  )  {  if  (  child  instanceof  TextNode  )  {  TextNode  textNode  =    (  TextNode  )  child  ;  if  (  !textNode  .  isBlank  (  )  )  return  true  ;  }  else  if  (  child  instanceof  Element  )  {  [ATTENTION]  Element  element  =  (  Element  )  child  ;  if  (  el  .  hasText  (  )  )  return  true  ;  }  }  return  false  ;  }    [METHOD]  hasText  [TYPE]  boolean  [PARAMETER]  [CLASS]  Element    [TYPE]  TextNode  textNode  [TYPE]  Set  classNames  [TYPE]  Tag  tag  [TYPE]  boolean  false  true  [TYPE]  Node  child  [TYPE]  Element  el  
[REPLACE]  if  (  el  .  hasText  (  )  )  return  true;	[BUGGY]  if  (  el  .  hasText  (  )  )  return  false  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  boolean  hasText  (  )  {  for  (  Node  child:  childNodes  )  {  if  (  child  instanceof  TextNode  )  {  TextNode  textNode  =    (  TextNode  )  child  ;  if  (  !textNode  .  isBlank  (  )  )  return  true  ;  }  else  if  (  child  instanceof  Element  )  {  Element  el  =    (  Element  )  child  ;  [ATTENTION]  if  (  el  .  hasText  (  )  )  return  false  ;    }  }  return  false  ;  }    [METHOD]  hasText  [TYPE]  boolean  [PARAMETER]  [CLASS]  Element    [TYPE]  TextNode  textNode  [TYPE]  Set  classNames  [TYPE]  Tag  tag  [TYPE]  boolean  false  true  [TYPE]  Node  child  [TYPE]  Element  el  
[REPLACE]  if  (  !textNode  .  isBlank  (  )  )  return  true;	[BUGGY]  if  (  !textNode  .  normaliseWhitespace  (  null  )    )  return  false  ;  [CE]  bad  operand  type  String  for  unary  operator  '!'  [CONTEXT]  public  boolean  hasText  (  )  {  for  (  Node  child:  childNodes  )  {  if  (  child  instanceof  TextNode  )  {  TextNode  textNode  =    (  TextNode  )  child  ;  [ATTENTION]  if  (  !textNode  .  normaliseWhitespace  (  null  )    )  return  false  ;    }  else  if  (  child  instanceof  Element  )  {  Element  el  =    (  Element  )  child  ;  if  (  el  .  hasText  (  )  )  return  true  ;  }  }  return  false  ;  }    [METHOD]  hasText  [TYPE]  boolean  [PARAMETER]  [CLASS]  Element    [TYPE]  TextNode  textNode  [TYPE]  Set  classNames  [TYPE]  Tag  tag  [TYPE]  boolean  false  true  [TYPE]  Node  child  [TYPE]  Element  el  
[REPLACE]  return  true;	[BUGGY]  return  false  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  boolean  hasText  (  )  {  for  (  Node  child:  childNodes  )  {  if  (  child  instanceof  TextNode  )  {  TextNode  textNode  =    (  TextNode  )  child  ;  if  (  !textNode  .  isBlank  (  )  )  [ATTENTION]  return  false  ;  }  else  if  (  child  instanceof  Element  )  {  Element  el  =    (  Element  )  child  ;  if  (  el  .  hasText  (  )  )  return  true  ;  }  }  return  false  ;  }    [METHOD]  hasText  [TYPE]  boolean  [PARAMETER]  [CLASS]  Element    [TYPE]  TextNode  textNode  [TYPE]  Set  classNames  [TYPE]  Tag  tag  [TYPE]  boolean  false  true  [TYPE]  Node  child  [TYPE]  Element  el  
[REPLACE]  TextNode  textNode  =  (  TextNode  )  child;	[BUGGY]  TextNode  textNode  =  new  TextNode  (  text  ,  baseUri  )  ;  [CE]  cannot  find  symbol  text  [CONTEXT]  public  boolean  hasText  (  )  {  for  (  Node  child:  childNodes  )  {  if  (  child  instanceof  TextNode  )  {  [ATTENTION]  TextNode  textNode  =  new  TextNode  (  text  ,  baseUri  )    ;  if  (  !textNode  .  isBlank  (  )  )  return  true  ;  }  else  if  (  child  instanceof  Element  )  {  Element  el  =    (  Element  )  child  ;  if  (  el  .  hasText  (  )  )  return  true  ;  }  }  return  false  ;  }    [METHOD]  hasText  [TYPE]  boolean  [PARAMETER]  [CLASS]  Element    [TYPE]  TextNode  textNode  [TYPE]  Set  classNames  [TYPE]  Tag  tag  [TYPE]  boolean  false  true  [TYPE]  Node  child  [TYPE]  Element  el  
[ADD]  TextNode  textNode  =  (  TextNode  )  child;	[BUGGY]  [CE]  cannot  find  symbol  textNode  [CONTEXT]  public  boolean  hasText  (  )  {  for  (  Node  child:  childNodes  )  {  if  (  child  instanceof  TextNode  )  {  [ATTENTION]  if  (  !textNode  .  isBlank  (  )  )  return  true  ;  }  else  if  (  child  instanceof  Element  )  {  Element  el  =    (  Element  )  child  ;  if  (  el  .  hasText  (  )  )  return  true  ;  }  }  return  false  ;  }    [METHOD]  hasText  [TYPE]  boolean  [PARAMETER]  [CLASS]  Element    [TYPE]  TextNode  textNode  [TYPE]  Set  classNames  [TYPE]  Tag  tag  [TYPE]  boolean  false  true  [TYPE]  Node  child  [TYPE]  Element  el  
[REPLACE]  if  (  !textNode  .  isBlank  (  )  )  return  true;	[BUGGY]  if  (  !textNode  .  isBlank  (  )  )  return  false  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  boolean  hasText  (  )  {  for  (  Node  child:  childNodes  )  {  if  (  child  instanceof  TextNode  )  {  TextNode  textNode  =    (  TextNode  )  child  ;  [ATTENTION]  if  (  !textNode  .  isBlank  (  )  )  return  false  ;    }  else  if  (  child  instanceof  Element  )  {  Element  el  =    (  Element  )  child  ;  if  (  el  .  hasText  (  )  )  return  true  ;  }  }  return  false  ;  }    [METHOD]  hasText  [TYPE]  boolean  [PARAMETER]  [CLASS]  Element    [TYPE]  TextNode  textNode  [TYPE]  Set  classNames  [TYPE]  Tag  tag  [TYPE]  boolean  false  true  [TYPE]  Node  child  [TYPE]  Element  el  
[ADD]  if  (  !textNode  .  isBlank  (  )  )  return  true;  }  else  if  (  child  instanceof  Element  )  {  Element  el  =  (  Element  )  child;  if  (  el  .  hasText  (  )  )	[BUGGY]  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  boolean  hasText  (  )  {  for  (  Node  child:  childNodes  )  {  if  (  child  instanceof  TextNode  )  {  TextNode  textNode  =    (  TextNode  )  child  ;  [ATTENTION]      return  true  ;  }  }  return  false  ;  }    [METHOD]  hasText  [TYPE]  boolean  [PARAMETER]  [CLASS]  Element    [TYPE]  TextNode  textNode  [TYPE]  Set  classNames  [TYPE]  Tag  tag  [TYPE]  boolean  false  true  [TYPE]  Node  child  [TYPE]  Element  el  
[ADD]  if  (  el  .  hasText  (  )  )  return  true;  }	[BUGGY]  return  true  ;  [CE]  illegal  start  of  expression  [CONTEXT]  public  boolean  hasText  (  )  {  for  (  Node  child:  childNodes  )  {  if  (  child  instanceof  TextNode  )  {  TextNode  textNode  =    (  TextNode  )  child  ;  if  (  !textNode  .  isBlank  (  )  )  return  true  ;  }  else  if  (  child  instanceof  Element  )  {  Element  el  =    (  Element  )  child  ;  [ATTENTION]  return  true  ;    }  return  false  ;  }    [METHOD]  hasText  [TYPE]  boolean  [PARAMETER]  [CLASS]  Element    [TYPE]  TextNode  textNode  [TYPE]  Set  classNames  [TYPE]  Tag  tag  [TYPE]  boolean  false  true  [TYPE]  Node  child  [TYPE]  Element  el  
[REPLACE]  for  (  Node  child:  childNodes  )  {	[BUGGY]  List<Node>  nodes  =  fragment  .  childNodes  (  )  ;  [CE]  illegal  start  of  type  [CONTEXT]  public  boolean  hasText  (  )  {  [ATTENTION]  List<Node>  nodes  =  fragment  .  childNodes  (  )    ;  if  (  child  instanceof  TextNode  )  {  TextNode  textNode  =    (  TextNode  )  child  ;  if  (  !textNode  .  isBlank  (  )  )  return  true  ;  }  else  if  (  child  instanceof  Element  )  {  Element  el  =    (  Element  )  child  ;  if  (  el  .  hasText  (  )  )  return  true  ;  }  }  return  false  ;  }    [METHOD]  hasText  [TYPE]  boolean  [PARAMETER]  [CLASS]  Element    [TYPE]  TextNode  textNode  [TYPE]  Set  classNames  [TYPE]  Tag  tag  [TYPE]  boolean  false  true  [TYPE]  Node  child  [TYPE]  Element  el  
[ADD]  Element  el  =  (  Element  )  child;	[BUGGY]  [CE]  cannot  find  symbol  el  [CONTEXT]  public  boolean  hasText  (  )  {  for  (  Node  child:  childNodes  )  {  if  (  child  instanceof  TextNode  )  {  TextNode  textNode  =    (  TextNode  )  child  ;  if  (  !textNode  .  isBlank  (  )  )  return  true  ;  }  else  if  (  child  instanceof  Element  )  {  [ATTENTION]  if  (  el  .  hasText  (  )  )  return  true  ;  }  }  return  false  ;  }    [METHOD]  hasText  [TYPE]  boolean  [PARAMETER]  [CLASS]  Element    [TYPE]  TextNode  textNode  [TYPE]  Set  classNames  [TYPE]  Tag  tag  [TYPE]  boolean  false  true  [TYPE]  Node  child  [TYPE]  Element  el  
[REPLACE]  return  false;	[BUGGY]  return  true  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  boolean  hasText  (  )  {  for  (  Node  child:  childNodes  )  {  if  (  child  instanceof  TextNode  )  {  TextNode  textNode  =    (  TextNode  )  child  ;  if  (  !textNode  .  isBlank  (  )  )  return  true  ;  }  else  if  (  child  instanceof  Element  )  {  Element  el  =    (  Element  )  child  ;  if  (  el  .  hasText  (  )  )  return  true  ;  }  }  [ATTENTION]  return  true  ;  }    [METHOD]  hasText  [TYPE]  boolean  [PARAMETER]  [CLASS]  Element    [TYPE]  TextNode  textNode  [TYPE]  Set  classNames  [TYPE]  Tag  tag  [TYPE]  boolean  false  true  [TYPE]  Node  child  [TYPE]  Element  el  
[REPLACE]  StringBuilder  sb  =  new  StringBuilder  (  )  ;	[BUGGY]  StringBuilder  accum  =  new  StringBuilder  (  )  ;  [CE]  cannot  find  symbol  sb  [CONTEXT]  public  String  data  (  )  {  [ATTENTION]  StringBuilder  accum  =  new  StringBuilder  (  )    ;    for  (  Node  childNode  :  childNodes  )  {  if  (  childNode  instanceof  DataNode  )  {  DataNode  data  =    (  DataNode  )  childNode  ;  sb  .  append  (  data  .  getWholeData  (  )  )  ;  }  else  if  (  childNode  instanceof  Element  )  {  Element  element  =    (  Element  )  childNode  ;  String  elementData  =  element  .  data  (  )  ;  sb  .  append  (  elementData  )  ;  }  }  return  sb  .  toString  (  )  ;  }    [METHOD]  data  [TYPE]  String  [PARAMETER]  [CLASS]  Element    [TYPE]  Set  classNames  [TYPE]  boolean  false  true  [TYPE]  StringBuilder  sb  [TYPE]  DataNode  data  [TYPE]  Node  childNode  [TYPE]  Element  element  [TYPE]  Tag  tag  [TYPE]  String  elementData  
[REPLACE]  if  (  childNode  instanceof  DataNode  )  {	[BUGGY]  if  (  !  childNode  instanceof  DataNode  )  {[CE]  bad  operand  type  Node  for  unary  operator  '!'  [CONTEXT]  public  String  data  (  )  {  StringBuilder  sb  =  new  StringBuilder  (  )  ;    for  (  Node  childNode  :  childNodes  )  {  [ATTENTION]  if  (  !  childNode  instanceof  DataNode  )  {  DataNode  data  =    (  DataNode  )  childNode  ;  sb  .  append  (  data  .  getWholeData  (  )  )  ;  }  else  if  (  childNode  instanceof  Element  )  {  Element  element  =    (  Element  )  childNode  ;  String  elementData  =  element  .  data  (  )  ;  sb  .  append  (  elementData  )  ;  }  }  return  sb  .  toString  (  )  ;  }    [METHOD]  data  [TYPE]  String  [PARAMETER]  [CLASS]  Element    [TYPE]  Set  classNames  [TYPE]  boolean  false  true  [TYPE]  StringBuilder  sb  [TYPE]  DataNode  data  [TYPE]  Node  childNode  [TYPE]  Element  element  [TYPE]  Tag  tag  [TYPE]  String  elementData  
[ADD]  if  (  childNode  instanceof  DataNode  )  {  DataNode  data  =  (  DataNode  )  childNode;  sb  .  append  (  data  .  getWholeData  (  )  )  ;  }  else  if  (  childNode  instanceof  Element  )  {  Element  element  =  (  Element  )  childNode;	[BUGGY]  DataNode  data  =    (  DataNode  )  childNode  ;  sb  .  append  (  data  .  getWholeData  (  )  )  ;  Element  element  =    (  Element  )  childNode  ;  [CE]  illegal  start  of  type  [CONTEXT]  public  String  data  (  )  {  StringBuilder  sb  =  new  StringBuilder  (  )  ;    for  (  Node  childNode  :  childNodes  )  {  [ATTENTION]  DataNode  data  =  (  DataNode  )  childNode  ;  sb  .  append  (  data  .  getWholeData  (  )  )    ;  Element  element  =  (  Element  )  childNode  ;      String  elementData  =  element  .  data  (  )  ;  sb  .  append  (  elementData  )  ;  }  }  return  sb  .  toString  (  )  ;  }    [METHOD]  data  [TYPE]  String  [PARAMETER]  [CLASS]  Element    [TYPE]  Set  classNames  [TYPE]  boolean  false  true  [TYPE]  StringBuilder  sb  [TYPE]  DataNode  data  [TYPE]  Node  childNode  [TYPE]  Element  element  [TYPE]  Tag  tag  [TYPE]  String  elementData  
[REPLACE]  }  else  if  (  childNode  instanceof  Element  )  {	[BUGGY]    else  {[FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  String  data  (  )  {  StringBuilder  sb  =  new  StringBuilder  (  )  ;    for  (  Node  childNode  :  childNodes  )  {  if  (  childNode  instanceof  DataNode  )  {  DataNode  data  =    (  DataNode  )  childNode  ;  sb  .  append  (  data  .  getWholeData  (  )  )  ;  [ATTENTION]  }else  {  Element  element  =    (  Element  )  childNode  ;  String  elementData  =  element  .  data  (  )  ;  sb  .  append  (  elementData  )  ;  }  }  return  sb  .  toString  (  )  ;  }    [METHOD]  data  [TYPE]  String  [PARAMETER]  [CLASS]  Element    [TYPE]  Set  classNames  [TYPE]  boolean  false  true  [TYPE]  StringBuilder  sb  [TYPE]  DataNode  data  [TYPE]  Node  childNode  [TYPE]  Element  element  [TYPE]  Tag  tag  [TYPE]  String  elementData  
[REPLACE]  Element  element  =  (  Element  )  childNode;	[BUGGY]  Element  element  =    (  Element  )  child  ;  [CE]  cannot  find  symbol  child  [CONTEXT]  public  String  data  (  )  {  StringBuilder  sb  =  new  StringBuilder  (  )  ;    for  (  Node  childNode  :  childNodes  )  {  if  (  childNode  instanceof  DataNode  )  {  DataNode  data  =    (  DataNode  )  childNode  ;  sb  .  append  (  data  .  getWholeData  (  )  )  ;  }  else  if  (  childNode  instanceof  Element  )  {  [ATTENTION]  Element  element  =  (  Element  )  child  ;  String  elementData  =  element  .  data  (  )  ;  sb  .  append  (  elementData  )  ;  }  }  return  sb  .  toString  (  )  ;  }    [METHOD]  data  [TYPE]  String  [PARAMETER]  [CLASS]  Element    [TYPE]  Set  classNames  [TYPE]  boolean  false  true  [TYPE]  StringBuilder  sb  [TYPE]  DataNode  data  [TYPE]  Node  childNode  [TYPE]  Element  element  [TYPE]  Tag  tag  [TYPE]  String  elementData  
[REPLACE]  String  elementData  =  element  .  data  (  )  ;	[BUGGY]  String  elementData  =  element  .  tag  (  )  ;  [CE]  incompatible  types  [CONTEXT]  public  String  data  (  )  {  StringBuilder  sb  =  new  StringBuilder  (  )  ;    for  (  Node  childNode  :  childNodes  )  {  if  (  childNode  instanceof  DataNode  )  {  DataNode  data  =    (  DataNode  )  childNode  ;  sb  .  append  (  data  .  getWholeData  (  )  )  ;  }  else  if  (  childNode  instanceof  Element  )  {  Element  element  =    (  Element  )  childNode  ;  [ATTENTION]  String  elementData  =  element  .  tag  (  )    ;  sb  .  append  (  elementData  )  ;  }  }  return  sb  .  toString  (  )  ;  }    [METHOD]  data  [TYPE]  String  [PARAMETER]  [CLASS]  Element    [TYPE]  Set  classNames  [TYPE]  boolean  false  true  [TYPE]  StringBuilder  sb  [TYPE]  DataNode  data  [TYPE]  Node  childNode  [TYPE]  Element  element  [TYPE]  Tag  tag  [TYPE]  String  elementData  
[REPLACE]  DataNode  data  =  (  DataNode  )  childNode;	[BUGGY]  TextNode  textNode  =    (  TextNode  )  child  ;  [CE]  cannot  find  symbol  child  [CONTEXT]  public  String  data  (  )  {  StringBuilder  sb  =  new  StringBuilder  (  )  ;    for  (  Node  childNode  :  childNodes  )  {  if  (  childNode  instanceof  DataNode  )  {  [ATTENTION]  TextNode  textNode  =  (  TextNode  )  child  ;  sb  .  append  (  data  .  getWholeData  (  )  )  ;  }  else  if  (  childNode  instanceof  Element  )  {  Element  element  =    (  Element  )  childNode  ;  String  elementData  =  element  .  data  (  )  ;  sb  .  append  (  elementData  )  ;  }  }  return  sb  .  toString  (  )  ;  }    [METHOD]  data  [TYPE]  String  [PARAMETER]  [CLASS]  Element    [TYPE]  Set  classNames  [TYPE]  boolean  false  true  [TYPE]  StringBuilder  sb  [TYPE]  DataNode  data  [TYPE]  Node  childNode  [TYPE]  Element  element  [TYPE]  Tag  tag  [TYPE]  String  elementData  
[ADD]  DataNode  data  =  (  DataNode  )  childNode;	[BUGGY]  [CE]  cannot  find  symbol  data  [CONTEXT]  public  String  data  (  )  {  StringBuilder  sb  =  new  StringBuilder  (  )  ;    for  (  Node  childNode  :  childNodes  )  {  if  (  childNode  instanceof  DataNode  )  {  [ATTENTION]  sb  .  append  (  data  .  getWholeData  (  )  )  ;  }  else  if  (  childNode  instanceof  Element  )  {  Element  element  =    (  Element  )  childNode  ;  String  elementData  =  element  .  data  (  )  ;  sb  .  append  (  elementData  )  ;  }  }  return  sb  .  toString  (  )  ;  }    [METHOD]  data  [TYPE]  String  [PARAMETER]  [CLASS]  Element    [TYPE]  Set  classNames  [TYPE]  boolean  false  true  [TYPE]  StringBuilder  sb  [TYPE]  DataNode  data  [TYPE]  Node  childNode  [TYPE]  Element  element  [TYPE]  Tag  tag  [TYPE]  String  elementData  
[REPLACE]  }  else  if  (  childNode  instanceof  Element  )  {	[BUGGY]    if  (  !  childNode  instanceof  Element  )  {[CE]  bad  operand  type  Node  for  unary  operator  '!'  [CONTEXT]  public  String  data  (  )  {  StringBuilder  sb  =  new  StringBuilder  (  )  ;    for  (  Node  childNode  :  childNodes  )  {  if  (  childNode  instanceof  DataNode  )  {  DataNode  data  =    (  DataNode  )  childNode  ;  sb  .  append  (  data  .  getWholeData  (  )  )  ;  [ATTENTION]  }if  (  !  childNode  instanceof  Element  )  {  Element  element  =    (  Element  )  childNode  ;  String  elementData  =  element  .  data  (  )  ;  sb  .  append  (  elementData  )  ;  }  }  return  sb  .  toString  (  )  ;  }    [METHOD]  data  [TYPE]  String  [PARAMETER]  [CLASS]  Element    [TYPE]  Set  classNames  [TYPE]  boolean  false  true  [TYPE]  StringBuilder  sb  [TYPE]  DataNode  data  [TYPE]  Node  childNode  [TYPE]  Element  element  [TYPE]  Tag  tag  [TYPE]  String  elementData  
[ADD]  else  if  (  childNode  instanceof  Element  )  {  Element  element  =  (  Element  )  childNode;  String  elementData  =  element  .  data  (  )  ;  sb  .  append  (  elementData  )  ;  }	[BUGGY]    Element  element  =    (  Element  )  childNode  ;  String  elementData  =  element  .  data  (  )  ;  sb  .  append  (  elementData  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  String  data  (  )  {  StringBuilder  sb  =  new  StringBuilder  (  )  ;    for  (  Node  childNode  :  childNodes  )  {  if  (  childNode  instanceof  DataNode  )  {  DataNode  data  =    (  DataNode  )  childNode  ;  sb  .  append  (  data  .  getWholeData  (  )  )  ;  [ATTENTION]  }  Element  element  =  (  Element  )  childNode  ;  String  elementData  =  element  .  data  (  )    ;  sb  .  append  (  elementData  )    ;      }  return  sb  .  toString  (  )  ;  }    [METHOD]  data  [TYPE]  String  [PARAMETER]  [CLASS]  Element    [TYPE]  Set  classNames  [TYPE]  boolean  false  true  [TYPE]  StringBuilder  sb  [TYPE]  DataNode  data  [TYPE]  Node  childNode  [TYPE]  Element  element  [TYPE]  Tag  tag  [TYPE]  String  elementData  
[ADD]  Element  element  =  (  Element  )  childNode;  String  elementData  =  element  .  data  (  )  ;	[BUGGY]  String  elementData  =  element  .  data  (  )  ;  [CE]  cannot  find  symbol  element  [CONTEXT]  public  String  data  (  )  {  StringBuilder  sb  =  new  StringBuilder  (  )  ;    for  (  Node  childNode  :  childNodes  )  {  if  (  childNode  instanceof  DataNode  )  {  DataNode  data  =    (  DataNode  )  childNode  ;  sb  .  append  (  data  .  getWholeData  (  )  )  ;  }  else  if  (  childNode  instanceof  Element  )  {  [ATTENTION]  String  elementData  =  element  .  data  (  )    ;    sb  .  append  (  elementData  )  ;  }  }  return  sb  .  toString  (  )  ;  }    [METHOD]  data  [TYPE]  String  [PARAMETER]  [CLASS]  Element    [TYPE]  Set  classNames  [TYPE]  boolean  false  true  [TYPE]  StringBuilder  sb  [TYPE]  DataNode  data  [TYPE]  Node  childNode  [TYPE]  Element  element  [TYPE]  Tag  tag  [TYPE]  String  elementData  
[REPLACE]  for  (  Node  childNode  :  childNodes  )  {	[BUGGY]  Node  node  =  nodes  .  get  (  i  )  ;  [CE]  illegal  start  of  type  [CONTEXT]  public  String  data  (  )  {  StringBuilder  sb  =  new  StringBuilder  (  )  ;    [ATTENTION]  Node  node  =  nodes  .  get  (  i  )    ;  if  (  childNode  instanceof  DataNode  )  {  DataNode  data  =    (  DataNode  )  childNode  ;  sb  .  append  (  data  .  getWholeData  (  )  )  ;  }  else  if  (  childNode  instanceof  Element  )  {  Element  element  =    (  Element  )  childNode  ;  String  elementData  =  element  .  data  (  )  ;  sb  .  append  (  elementData  )  ;  }  }  return  sb  .  toString  (  )  ;  }    [METHOD]  data  [TYPE]  String  [PARAMETER]  [CLASS]  Element    [TYPE]  Set  classNames  [TYPE]  boolean  false  true  [TYPE]  StringBuilder  sb  [TYPE]  DataNode  data  [TYPE]  Node  childNode  [TYPE]  Element  element  [TYPE]  Tag  tag  [TYPE]  String  elementData  
[REPLACE]  String  elementData  =  element  .  data  (  )  ;	[BUGGY]  String  elementData  =  element  .  hasText  (  )    ;  [CE]  incompatible  types  [CONTEXT]  public  String  data  (  )  {  StringBuilder  sb  =  new  StringBuilder  (  )  ;    for  (  Node  childNode  :  childNodes  )  {  if  (  childNode  instanceof  DataNode  )  {  DataNode  data  =    (  DataNode  )  childNode  ;  sb  .  append  (  data  .  getWholeData  (  )  )  ;  }  else  if  (  childNode  instanceof  Element  )  {  Element  element  =    (  Element  )  childNode  ;  [ATTENTION]  String  elementData  =  element  .  hasText  (  )  ;  sb  .  append  (  elementData  )  ;  }  }  return  sb  .  toString  (  )  ;  }    [METHOD]  data  [TYPE]  String  [PARAMETER]  [CLASS]  Element    [TYPE]  Set  classNames  [TYPE]  boolean  false  true  [TYPE]  StringBuilder  sb  [TYPE]  DataNode  data  [TYPE]  Node  childNode  [TYPE]  Element  element  [TYPE]  Tag  tag  [TYPE]  String  elementData  
[REPLACE]  return  sb  .  toString  (  )  ;	[BUGGY]  return  sb  .  StringBuilder  (  )    ;  [CE]  cannot  find  symbol  [CONTEXT]  public  String  data  (  )  {  StringBuilder  sb  =  new  StringBuilder  (  )  ;    for  (  Node  childNode  :  childNodes  )  {  if  (  childNode  instanceof  DataNode  )  {  DataNode  data  =    (  DataNode  )  childNode  ;  sb  .  append  (  data  .  getWholeData  (  )  )  ;  }  else  if  (  childNode  instanceof  Element  )  {  Element  element  =    (  Element  )  childNode  ;  String  elementData  =  element  .  data  (  )  ;  sb  .  append  (  elementData  )  ;  }  }  [ATTENTION]  return  sb  .  StringBuilder  (  )  ;  }    [METHOD]  data  [TYPE]  String  [PARAMETER]  [CLASS]  Element    [TYPE]  Set  classNames  [TYPE]  boolean  false  true  [TYPE]  StringBuilder  sb  [TYPE]  DataNode  data  [TYPE]  Node  childNode  [TYPE]  Element  element  [TYPE]  Tag  tag  [TYPE]  String  elementData  
[REPLACE]  return  attributes  .  hasKey  (   "class "  )  ?  attributes  .  get  (   "class "  )  :   " ";	[BUGGY]  return  attributes  .  hasKey  (   "class "  )  ?  attributes  .  put  (   "class "  )  :   " "  ;  [CE]  no  suitable  method  found  for  put(String)  [CONTEXT]  public  String  className  (  )  {  [ATTENTION]  return  attributes  .  hasKey  (   "class "  )  ?  attributes  .  put  (   "class "  )  :   " "  ;  }    [METHOD]  className  [TYPE]  String  [PARAMETER]  [CLASS]  Element    [TYPE]  Set  classNames  [TYPE]  Tag  tag  [TYPE]  boolean  false  true  
[REPLACE]  if  (  classNames  ==  null  )  {	[BUGGY]  if  (  classNames  !  =  null  )  {[FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  Set<String>  classNames  (  )  {  [ATTENTION]  if  (  classNames  !  =  null  )  {  String[]  names  =  className  (  )  .  split  (   "\\s+ "  )  ;  classNames  =  new  LinkedHashSet<String>  (  Arrays  .  asList  (  names  )  )  ;  }  return  classNames  ;  }    [METHOD]  classNames  [TYPE]  Set  [PARAMETER]  [CLASS]  Element    [TYPE]  Set  classNames  [TYPE]  Tag  tag  [TYPE]  String[]  names  [TYPE]  boolean  false  true  
[REPLACE]  classNames  =  new  LinkedHashSet<String>  (  Arrays  .  asList  (  names  )  )  ;	[BUGGY]  classNames  =    new  LinkedHashSet<String>  (  Arrays  .  asList  (  null  )  )  ;  [CE]  no  suitable  constructor  found  for  LinkedHashSet(List<Object>)  [CONTEXT]  public  Set<String>  classNames  (  )  {  if  (  classNames  =  =  null  )  {  String[]  names  =  className  (  )  .  split  (   "\\s+ "  )  ;  [ATTENTION]  classNames  =  new  LinkedHashSet<String>  (  Arrays  .  asList  (  null  )  )    ;  }  return  classNames  ;  }    [METHOD]  classNames  [TYPE]  Set  [PARAMETER]  [CLASS]  Element    [TYPE]  Set  classNames  [TYPE]  Tag  tag  [TYPE]  String[]  names  [TYPE]  boolean  false  true  
[ADD]  classNames  =  new  LinkedHashSet<String>  (  Arrays  .  asList  (  names  )  )  ;	[BUGGY]  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  Set<String>  classNames  (  )  {  if  (  classNames  =  =  null  )  {  String[]  names  =  className  (  )  .  split  (   "\\s+ "  )  ;  [ATTENTION]  }  return  classNames  ;  }    [METHOD]  classNames  [TYPE]  Set  [PARAMETER]  [CLASS]  Element    [TYPE]  Set  classNames  [TYPE]  Tag  tag  [TYPE]  String[]  names  [TYPE]  boolean  false  true  
[REPLACE]  String[]  names  =  className  (  )    .  split  (   "\\s+ "  )  ;	[BUGGY]  String[]  names  =  className  (  )    .  trim  (  )    ;  [CE]  incompatible  types  [CONTEXT]  public  Set<String>  classNames  (  )  {  if  (  classNames  =  =  null  )  {  [ATTENTION]  String[]  names  =  className  (  )  .  trim  (  )  ;  classNames  =  new  LinkedHashSet<String>  (  Arrays  .  asList  (  names  )  )  ;  }  return  classNames  ;  }    [METHOD]  classNames  [TYPE]  Set  [PARAMETER]  [CLASS]  Element    [TYPE]  Set  classNames  [TYPE]  Tag  tag  [TYPE]  String[]  names  [TYPE]  boolean  false  true  
[ADD]  String[]  names  =  className  (  )    .  split  (   "\\s+ "  )  ;  classNames  =  new  LinkedHashSet<String>  (  Arrays  .  asList  (  names  )  )  ;	[BUGGY]  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  Set<String>  classNames  (  )  {  if  (  classNames  =  =  null  )  {  [ATTENTION]    }  return  classNames  ;  }    [METHOD]  classNames  [TYPE]  Set  [PARAMETER]  [CLASS]  Element    [TYPE]  Set  classNames  [TYPE]  Tag  tag  [TYPE]  String[]  names  [TYPE]  boolean  false  true  
[REPLACE]  return  classNames;	[BUGGY]  return  elements  .  get  (  0  )  ;  [CE]  cannot  find  symbol  elements  [CONTEXT]  public  Set<String>  classNames  (  )  {  if  (  classNames  =  =  null  )  {  String[]  names  =  className  (  )  .  split  (   "\\s+ "  )  ;  classNames  =  new  LinkedHashSet<String>  (  Arrays  .  asList  (  names  )  )  ;  }  [ATTENTION]  return  elements  .  get  (  0  )    ;  }    [METHOD]  classNames  [TYPE]  Set  [PARAMETER]  [CLASS]  Element    [TYPE]  Set  classNames  [TYPE]  Tag  tag  [TYPE]  String[]  names  [TYPE]  boolean  false  true  
[REPLACE]  Validate  .  notNull  (  classNames  )  ;	[BUGGY]  Validate  .  notNull  (  this  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  Element  classNames  (  Set<String>  classNames  )  {  [ATTENTION]  Validate  .  notNull  (  this  )    ;  attributes  .  put  (   "class "  ,  StringUtils  .  join  (  classNames  ,   "   "  )  )  ;  return  this  ;  }    [METHOD]  classNames  [TYPE]  Element  [PARAMETER]  String>  classNames  [CLASS]  Element    [TYPE]  Set  classNames  [TYPE]  Tag  tag  [TYPE]  boolean  false  true  
[REPLACE]  attributes  .  put  (   "class ",  StringUtils  .  join  (  classNames,   "   "  )  )  ;	[BUGGY]  attributes  .  put  (   "class "  ,  StringUtils  .  join  (  0  ,   "   "  )  )  ;  [CE]  no  suitable  method  found  for  join(int  ,  String)  [CONTEXT]  public  Element  classNames  (  Set<String>  classNames  )  {  Validate  .  notNull  (  classNames  )  ;  [ATTENTION]  attributes  .  put  (   "class "  ,  StringUtils  .  join  (  0  ,   "   "  )  )    ;  return  this  ;  }    [METHOD]  classNames  [TYPE]  Element  [PARAMETER]  String>  classNames  [CLASS]  Element    [TYPE]  Set  classNames  [TYPE]  Tag  tag  [TYPE]  boolean  false  true  
[REMOVE]  	[BUGGY]  .  append  (  attributes  .  html  (  )  )  ;  [CE]  illegal  start  of  expression  [CONTEXT]  public  Element  classNames  (  Set<String>  classNames  )  {  Validate  .  notNull  (  classNames  )  ;  [ATTENTION]  attributes  .  put  (   "class "  ,  StringUtils  .  join  (  classNames  ,   "   "  )  )  ;    .  append  (  attributes  .  html  (  )  )    ;  return  this  ;      [METHOD]  classNames  [TYPE]  Element  [PARAMETER]  String>  classNames  [CLASS]  Element    [TYPE]  Set  classNames  [TYPE]  Tag  tag  [TYPE]  boolean  false  true  
[REPLACE]  attributes  .  put  (   "class ",  StringUtils  .  join  (  classNames,   "   "  )  )  ;	[BUGGY]  attributes  .  put  (   "class "  ,  StringUtils  .  join  (  true  ,   "   "  )  )  ;  [CE]  no  suitable  method  found  for  join(boolean  ,  String)  [CONTEXT]  public  Element  classNames  (  Set<String>  classNames  )  {  Validate  .  notNull  (  classNames  )  ;  [ATTENTION]  attributes  .  put  (   "class "  ,  StringUtils  .  join  (  true  ,   "   "  )  )    ;  return  this  ;  }    [METHOD]  classNames  [TYPE]  Element  [PARAMETER]  String>  classNames  [CLASS]  Element    [TYPE]  Set  classNames  [TYPE]  Tag  tag  [TYPE]  boolean  false  true  
[REPLACE]  return  this;	[BUGGY]  return  null  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  Element  classNames  (  Set<String>  classNames  )  {  Validate  .  notNull  (  classNames  )  ;  attributes  .  put  (   "class "  ,  StringUtils  .  join  (  classNames  ,   "   "  )  )  ;  [ATTENTION]  return  null  ;  }    [METHOD]  classNames  [TYPE]  Element  [PARAMETER]  String>  classNames  [CLASS]  Element    [TYPE]  Set  classNames  [TYPE]  Tag  tag  [TYPE]  boolean  false  true  
[REPLACE]  return  classNames  (  )    .  contains  (  className  )  ;	[BUGGY]  return  elements  .  get  (  0  )  ;  [CE]  cannot  find  symbol  elements  [CONTEXT]  public  boolean  hasClass  (  String  className  )  {  [ATTENTION]  return  elements  .  get  (  0  )    ;  }    [METHOD]  hasClass  [TYPE]  boolean  [PARAMETER]  String  className  [CLASS]  Element    [TYPE]  Set  classNames  [TYPE]  Tag  tag  [TYPE]  String  className  [TYPE]  boolean  false  true  
[REPLACE]  Validate  .  notNull  (  className  )  ;	[BUGGY]  Validate  .  notEmpty  (  className  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  Element  addClass  (  String  className  )  {  [ATTENTION]  Validate  .  notEmpty  (  className  )    ;    Set<String>  classes  =  classNames  (  )  ;  classes  .  add  (  className  )  ;  classNames  (  classes  )  ;    return  this  ;  }    [METHOD]  addClass  [TYPE]  Element  [PARAMETER]  String  className  [CLASS]  Element    [TYPE]  Set  classNames  classes  [TYPE]  Tag  tag  [TYPE]  String  className  [TYPE]  boolean  false  true  
[REPLACE]  Set<String>  classes  =  classNames  (  )  ;	[BUGGY]  List<Element>  siblings  =  parent  (  )  .  children  (  )  ;  [CE]  cannot  find  symbol  classes  [CONTEXT]  public  Element  addClass  (  String  className  )  {  Validate  .  notNull  (  className  )  ;    [ATTENTION]  List<Element>  siblings  =  parent  (  )    .  children  (  )    ;  classes  .  add  (  className  )  ;  classNames  (  classes  )  ;    return  this  ;  }    [METHOD]  addClass  [TYPE]  Element  [PARAMETER]  String  className  [CLASS]  Element    [TYPE]  Set  classNames  classes  [TYPE]  Tag  tag  [TYPE]  String  className  [TYPE]  boolean  false  true  
[REPLACE]  classes  .  add  (  className  )  ;	[BUGGY]  classes  .  contains  (  className  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  Element  addClass  (  String  className  )  {  Validate  .  notNull  (  className  )  ;    Set<String>  classes  =  classNames  (  )  ;  [ATTENTION]  classes  .  contains  (  className  )    ;  classNames  (  classes  )  ;    return  this  ;  }    [METHOD]  addClass  [TYPE]  Element  [PARAMETER]  String  className  [CLASS]  Element    [TYPE]  Set  classNames  classes  [TYPE]  Tag  tag  [TYPE]  String  className  [TYPE]  boolean  false  true  
[REPLACE]  classNames  (  classes  )  ;	[BUGGY]  classNames  (  true  )  ;  [CE]  no  suitable  method  found  for  classNames(boolean)  [CONTEXT]  public  Element  addClass  (  String  className  )  {  Validate  .  notNull  (  className  )  ;    Set<String>  classes  =  classNames  (  )  ;  classes  .  add  (  className  )  ;  [ATTENTION]  classNames  (  true  )    ;    return  this  ;  }    [METHOD]  addClass  [TYPE]  Element  [PARAMETER]  String  className  [CLASS]  Element    [TYPE]  Set  classNames  classes  [TYPE]  Tag  tag  [TYPE]  String  className  [TYPE]  boolean  false  true  
[REPLACE]  return  this;	[BUGGY]  return  null  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  Element  addClass  (  String  className  )  {  Validate  .  notNull  (  className  )  ;    Set<String>  classes  =  classNames  (  )  ;  classes  .  add  (  className  )  ;  classNames  (  classes  )  ;    [ATTENTION]  return  null  ;  }    [METHOD]  addClass  [TYPE]  Element  [PARAMETER]  String  className  [CLASS]  Element    [TYPE]  Set  classNames  classes  [TYPE]  Tag  tag  [TYPE]  String  className  [TYPE]  boolean  false  true  
[REPLACE]  Validate  .  notNull  (  className  )  ;	[BUGGY]  Validate  .  notEmpty  (  className  )    ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  Element  removeClass  (  String  className  )  {  [ATTENTION]  Validate  .  notEmpty  (  className  )  ;    Set<String>  classes  =  classNames  (  )  ;  classes  .  remove  (  className  )  ;  classNames  (  classes  )  ;    return  this  ;  }    [METHOD]  removeClass  [TYPE]  Element  [PARAMETER]  String  className  [CLASS]  Element    [TYPE]  Set  classNames  classes  [TYPE]  Tag  tag  [TYPE]  String  className  [TYPE]  boolean  false  true  
[REPLACE]  Set<String>  classes  =  classNames  (  )  ;	[BUGGY]  List<Element>  siblings  =  parent  (  )  .  children  (  )  ;  [CE]  cannot  find  symbol  classes  [CONTEXT]  public  Element  removeClass  (  String  className  )  {  Validate  .  notNull  (  className  )  ;    [ATTENTION]  List<Element>  siblings  =  parent  (  )    .  children  (  )    ;  classes  .  remove  (  className  )  ;  classNames  (  classes  )  ;    return  this  ;  }    [METHOD]  removeClass  [TYPE]  Element  [PARAMETER]  String  className  [CLASS]  Element    [TYPE]  Set  classNames  classes  [TYPE]  Tag  tag  [TYPE]  String  className  [TYPE]  boolean  false  true  
[REPLACE]  classes  .  remove  (  className  )  ;	[BUGGY]  classes  .  contains  (  className  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  Element  removeClass  (  String  className  )  {  Validate  .  notNull  (  className  )  ;    Set<String>  classes  =  classNames  (  )  ;  [ATTENTION]  classes  .  contains  (  className  )    ;  classNames  (  classes  )  ;    return  this  ;  }    [METHOD]  removeClass  [TYPE]  Element  [PARAMETER]  String  className  [CLASS]  Element    [TYPE]  Set  classNames  classes  [TYPE]  Tag  tag  [TYPE]  String  className  [TYPE]  boolean  false  true  
[REPLACE]  classNames  (  classes  )  ;	[BUGGY]  classNames  (  false  )  ;  [CE]  no  suitable  method  found  for  classNames(boolean)  [CONTEXT]  public  Element  removeClass  (  String  className  )  {  Validate  .  notNull  (  className  )  ;    Set<String>  classes  =  classNames  (  )  ;  classes  .  remove  (  className  )  ;  [ATTENTION]  classNames  (  false  )    ;    return  this  ;  }    [METHOD]  removeClass  [TYPE]  Element  [PARAMETER]  String  className  [CLASS]  Element    [TYPE]  Set  classNames  classes  [TYPE]  Tag  tag  [TYPE]  String  className  [TYPE]  boolean  false  true  
[REPLACE]  return  this;	[BUGGY]  return  null  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  Element  removeClass  (  String  className  )  {  Validate  .  notNull  (  className  )  ;    Set<String>  classes  =  classNames  (  )  ;  classes  .  remove  (  className  )  ;  classNames  (  classes  )  ;    [ATTENTION]  return  null  ;  }    [METHOD]  removeClass  [TYPE]  Element  [PARAMETER]  String  className  [CLASS]  Element    [TYPE]  Set  classNames  classes  [TYPE]  Tag  tag  [TYPE]  String  className  [TYPE]  boolean  false  true  
[REPLACE]  Validate  .  notNull  (  className  )  ;	[BUGGY]  Validate  .  notEmpty  (  className  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  Element  toggleClass  (  String  className  )  {  [ATTENTION]  Validate  .  notEmpty  (  className  )    ;    Set<String>  classes  =  classNames  (  )  ;  if  (  classes  .  contains  (  className  )  )  classes  .  remove  (  className  )  ;  else  classes  .  add  (  className  )  ;  classNames  (  classes  )  ;    return  this  ;  }    [METHOD]  toggleClass  [TYPE]  Element  [PARAMETER]  String  className  [CLASS]  Element    [TYPE]  Set  classNames  classes  [TYPE]  Tag  tag  [TYPE]  String  className  [TYPE]  boolean  false  true  
[REPLACE]  Set<String>  classes  =  classNames  (  )  ;	[BUGGY]  List<Element>  siblings  =  parent  (  )  .  children  (  )  ;  [CE]  cannot  find  symbol  classes  [CONTEXT]  public  Element  toggleClass  (  String  className  )  {  Validate  .  notNull  (  className  )  ;    [ATTENTION]  List<Element>  siblings  =  parent  (  )    .  children  (  )    ;  if  (  classes  .  contains  (  className  )  )  classes  .  remove  (  className  )  ;  else  classes  .  add  (  className  )  ;  classNames  (  classes  )  ;    return  this  ;  }    [METHOD]  toggleClass  [TYPE]  Element  [PARAMETER]  String  className  [CLASS]  Element    [TYPE]  Set  classNames  classes  [TYPE]  Tag  tag  [TYPE]  String  className  [TYPE]  boolean  false  true  
[REPLACE]  if  (  classes  .  contains  (  className  )  )  classes  .  remove  (  className  )  ;	[BUGGY]  if  (  classes  .  contains  (  className  )  )  classes  .  contains  (  className  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  Element  toggleClass  (  String  className  )  {  Validate  .  notNull  (  className  )  ;    Set<String>  classes  =  classNames  (  )  ;  [ATTENTION]  if  (  classes  .  contains  (  className  )  )  classes  .  contains  (  className  )    ;    else  classes  .  add  (  className  )  ;  classNames  (  classes  )  ;    return  this  ;  }    [METHOD]  toggleClass  [TYPE]  Element  [PARAMETER]  String  className  [CLASS]  Element    [TYPE]  Set  classNames  classes  [TYPE]  Tag  tag  [TYPE]  String  className  [TYPE]  boolean  false  true  
[REPLACE]  classes  .  add  (  className  )  ;	[BUGGY]  classes  .  contains  (  className  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  Element  toggleClass  (  String  className  )  {  Validate  .  notNull  (  className  )  ;    Set<String>  classes  =  classNames  (  )  ;  if  (  classes  .  contains  (  className  )  )  classes  .  remove  (  className  )  ;  else  [ATTENTION]  classes  .  contains  (  className  )    ;  classNames  (  classes  )  ;    return  this  ;  }    [METHOD]  toggleClass  [TYPE]  Element  [PARAMETER]  String  className  [CLASS]  Element    [TYPE]  Set  classNames  classes  [TYPE]  Tag  tag  [TYPE]  String  className  [TYPE]  boolean  false  true  
[REPLACE]  classes  .  remove  (  className  )  ;	[BUGGY]  classes  .  contains  (  className  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  Element  toggleClass  (  String  className  )  {  Validate  .  notNull  (  className  )  ;    Set<String>  classes  =  classNames  (  )  ;  if  (  classes  .  contains  (  className  )  )  [ATTENTION]  classes  .  contains  (  className  )    ;  else  classes  .  add  (  className  )  ;  classNames  (  classes  )  ;    return  this  ;  }    [METHOD]  toggleClass  [TYPE]  Element  [PARAMETER]  String  className  [CLASS]  Element    [TYPE]  Set  classNames  classes  [TYPE]  Tag  tag  [TYPE]  String  className  [TYPE]  boolean  false  true  
[REPLACE]  classNames  (  classes  )  ;	[BUGGY]  classNames  (  null  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  Element  toggleClass  (  String  className  )  {  Validate  .  notNull  (  className  )  ;    Set<String>  classes  =  classNames  (  )  ;  if  (  classes  .  contains  (  className  )  )  classes  .  remove  (  className  )  ;  else  classes  .  add  (  className  )  ;  [ATTENTION]  classNames  (  null  )    ;    return  this  ;  }    [METHOD]  toggleClass  [TYPE]  Element  [PARAMETER]  String  className  [CLASS]  Element    [TYPE]  Set  classNames  classes  [TYPE]  Tag  tag  [TYPE]  String  className  [TYPE]  boolean  false  true  
[REPLACE]  return  this;	[BUGGY]  return  null  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  Element  toggleClass  (  String  className  )  {  Validate  .  notNull  (  className  )  ;    Set<String>  classes  =  classNames  (  )  ;  if  (  classes  .  contains  (  className  )  )  classes  .  remove  (  className  )  ;  else  classes  .  add  (  className  )  ;  classNames  (  classes  )  ;    [ATTENTION]  return  null  ;  }    [METHOD]  toggleClass  [TYPE]  Element  [PARAMETER]  String  className  [CLASS]  Element    [TYPE]  Set  classNames  classes  [TYPE]  Tag  tag  [TYPE]  String  className  [TYPE]  boolean  false  true  
[REPLACE]  if  (  tagName  (  )    .  equals  (   "textarea "  )  )  return  text  (  )  ;	[BUGGY]  if  (  tagName  (  )  .  split  (   "textarea "  )  )  return  text  (  )  ;  [CE]  incompatible  types  [CONTEXT]  public  String  val  (  )  {  [ATTENTION]  if  (  tagName  (  )    .  split  (   "textarea "  )  )  return  text  (  )    ;    else  return  attr  (   "value "  )  ;  }    [METHOD]  val  [TYPE]  String  [PARAMETER]  [CLASS]  Element    [TYPE]  Set  classNames  classes  [TYPE]  Tag  tag  [TYPE]  boolean  false  true  
[ADD]  if  (  tagName  (  )    .  equals  (   "textarea "  )  )  return  text  (  )  ;  else  return  attr  (   "value "  )  ;  }	[BUGGY]  return  text  (  )  ;  return  attr  (   "value "  )  ;  [CE]  illegal  start  of  expression  [CONTEXT]  public  String  val  (  )  {  [ATTENTION]  return  text  (  )    ;  return  attr  (   "value "  )    ;          [METHOD]  val  [TYPE]  String  [PARAMETER]  [CLASS]  Element    [TYPE]  Set  classNames  classes  [TYPE]  Tag  tag  [TYPE]  boolean  false  true  
[REPLACE]  return  attr  (   "value "  )  ;	[BUGGY]  return  elements  .  get  (  0  )  ;  [CE]  cannot  find  symbol  elements  [CONTEXT]  public  String  val  (  )  {  if  (  tagName  (  )  .  equals  (   "textarea "  )  )  return  text  (  )  ;  else  [ATTENTION]  return  elements  .  get  (  0  )    ;  }    [METHOD]  val  [TYPE]  String  [PARAMETER]  [CLASS]  Element    [TYPE]  Set  classNames  classes  [TYPE]  Tag  tag  [TYPE]  boolean  false  true  
[REPLACE]  return  text  (  )  ;	[BUGGY]  return  elements  .  get  (  0  )  ;  [CE]  cannot  find  symbol  elements  [CONTEXT]  public  String  val  (  )  {  if  (  tagName  (  )  .  equals  (   "textarea "  )  )  [ATTENTION]  return  elements  .  get  (  0  )    ;  else  return  attr  (   "value "  )  ;  }    [METHOD]  val  [TYPE]  String  [PARAMETER]  [CLASS]  Element    [TYPE]  Set  classNames  classes  [TYPE]  Tag  tag  [TYPE]  boolean  false  true  
[REPLACE]  if  (  tagName  (  )    .  equals  (   "textarea "  )  )  text  (  value  )  ;	[BUGGY]  if  (  tagName  (  )  .  equals  (   "textarea "  )  )  return  text  (  )  ;  [CE]  incompatible  types  [CONTEXT]  public  Element  val  (  String  value  )  {  [ATTENTION]  if  (  tagName  (  )    .  equals  (   "textarea "  )  )  return  text  (  )    ;    else  attr  (   "value "  ,  value  )  ;  return  this  ;  }    [METHOD]  val  [TYPE]  Element  [PARAMETER]  String  value  [CLASS]  Element    [TYPE]  Set  classNames  classes  [TYPE]  Tag  tag  [TYPE]  String  value  [TYPE]  boolean  false  true  
[ADD]  if  (  tagName  (  )    .  equals  (   "textarea "  )  )  text  (  value  )  ;  else  attr  (   "value ",  value  )  ;  return  this;	[BUGGY]  [CE]  missing  return  statement  [CONTEXT]  public  Element  val  (  String  value  )  {  [ATTENTION]      }    [METHOD]  val  [TYPE]  Element  [PARAMETER]  String  value  [CLASS]  Element    [TYPE]  Set  classNames  classes  [TYPE]  Tag  tag  [TYPE]  String  value  [TYPE]  boolean  false  true  
[REPLACE]  attr  (   "value ",  value  )  ;	[BUGGY]  text  (  value  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  Element  val  (  String  value  )  {  if  (  tagName  (  )  .  equals  (   "textarea "  )  )  text  (  value  )  ;  else  [ATTENTION]  text  (  value  )    ;  return  this  ;  }    [METHOD]  val  [TYPE]  Element  [PARAMETER]  String  value  [CLASS]  Element    [TYPE]  Set  classNames  classes  [TYPE]  Tag  tag  [TYPE]  String  value  [TYPE]  boolean  false  true  
[REPLACE]  text  (  value  )  ;	[BUGGY]  append  (  html  )  ;  [CE]  cannot  find  symbol  html  [CONTEXT]  public  Element  val  (  String  value  )  {  if  (  tagName  (  )  .  equals  (   "textarea "  )  )  [ATTENTION]  append  (  html  )    ;  else  attr  (   "value "  ,  value  )  ;  return  this  ;  }    [METHOD]  val  [TYPE]  Element  [PARAMETER]  String  value  [CLASS]  Element    [TYPE]  Set  classNames  classes  [TYPE]  Tag  tag  [TYPE]  String  value  [TYPE]  boolean  false  true  
[REPLACE]  return  this;	[BUGGY]  return  null  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  Element  val  (  String  value  )  {  if  (  tagName  (  )  .  equals  (   "textarea "  )  )  text  (  value  )  ;  else  attr  (   "value "  ,  value  )  ;  [ATTENTION]  return  null  ;  }    [METHOD]  val  [TYPE]  Element  [PARAMETER]  String  value  [CLASS]  Element    [TYPE]  Set  classNames  classes  [TYPE]  Tag  tag  [TYPE]  String  value  [TYPE]  boolean  false  true  
[REPLACE]  if  (  isBlock  (  )  ||  (  parent  (  )  !=  null  &&  parent  (  )    .  tag  (  )    .  canContainBlock  (  )  &&  siblingIndex  (  )  ==  0  )  )  indent  (  accum  )  ;	[BUGGY]  if  (false  (  )  ||  (  parent  (  )  !  =  null  &&  parent  (  )  .  tag  (  )  .  canContainBlock  (  )  &&  siblingIndex  (  )  !  =  0  )  )  indent  (  accum  )  ;  [CE]  ')'  expected  [CONTEXT]  void  outerHtml  (  StringBuilder  accum  )  {  [ATTENTION]  if  (  false  (  )  ||  (  parent  (  )  !  =  null  &&  parent  (  )    .  tag  (  )    .  canContainBlock  (  )  &&  siblingIndex  (  )  !  =  0  )  )  indent  (  accum  )    ;    accum  .  append  (   "< "  )    .  append  (  tagName  (  )  )    .  append  (  attributes  .  html  (  )  )  ;    if  (  childNodes  .  isEmpty  (  )  &&  tag  .  isEmpty  (  )  )  {  accum  .  append  (   "  /> "  )  ;  }  else  {  accum  .  append  (   "> "  )  ;  html  (  accum  )  ;  if  (  tag  .  canContainBlock  (  )  )  indent  (  accum  )  ;  accum  .  append  (   "</ "  )  .  append  (  tagName  (  )  )  .  append  (   "> "  )  ;  }  }    [METHOD]  outerHtml  [TYPE]  void  [PARAMETER]  StringBuilder  accum  [CLASS]  Element    [TYPE]  Set  classNames  classes  [TYPE]  Tag  tag  [TYPE]  boolean  false  true  [TYPE]  StringBuilder  accum  
[ADD]  if  (  isBlock  (  )  ||  (  parent  (  )  !=  null  &&  parent  (  )    .  tag  (  )    .  canContainBlock  (  )  &&  siblingIndex  (  )  ==  0  )  )  indent  (  accum  )  ;  accum    .  append  (   "< "  )    .  append  (  tagName  (  )  )	[BUGGY]  indent  (  accum  )  ;  [CE]  illegal  start  of  expression  [CONTEXT]  void  outerHtml  (  StringBuilder  accum  )  {  [ATTENTION]  indent  (  accum  )    ;        .  append  (  attributes  .  html  (  )  )  ;    if  (  childNodes  .  isEmpty  (  )  &&  tag  .  isEmpty  (  )  )  {  accum  .  append  (   "  /> "  )  ;  }  else  {  accum  .  append  (   "> "  )  ;  html  (  accum  )  ;  if  (  tag  .  canContainBlock  (  )  )  indent  (  accum  )  ;  accum  .  append  (   "</ "  )  .  append  (  tagName  (  )  )  .  append  (   "> "  )  ;  }  }    [METHOD]  outerHtml  [TYPE]  void  [PARAMETER]  StringBuilder  accum  [CLASS]  Element    [TYPE]  Set  classNames  classes  [TYPE]  Tag  tag  [TYPE]  boolean  false  true  [TYPE]  StringBuilder  accum  
[REPLACE]  indent  (  accum  )  ;	[BUGGY]  append  (  html  )  ;  [CE]  cannot  find  symbol  html  [CONTEXT]  void  outerHtml  (  StringBuilder  accum  )  {  if  (  isBlock  (  )  ||  (  parent  (  )  !  =  null  &&  parent  (  )  .  tag  (  )  .  canContainBlock  (  )  &&  siblingIndex  (  )    =  =  0  )  )  [ATTENTION]  append  (  html  )    ;  accum  .  append  (   "< "  )    .  append  (  tagName  (  )  )    .  append  (  attributes  .  html  (  )  )  ;    if  (  childNodes  .  isEmpty  (  )  &&  tag  .  isEmpty  (  )  )  {  accum  .  append  (   "  /> "  )  ;  }  else  {  accum  .  append  (   "> "  )  ;  html  (  accum  )  ;  if  (  tag  .  canContainBlock  (  )  )  indent  (  accum  )  ;  accum  .  append  (   "</ "  )  .  append  (  tagName  (  )  )  .  append  (   "> "  )  ;  }  }    [METHOD]  outerHtml  [TYPE]  void  [PARAMETER]  StringBuilder  accum  [CLASS]  Element    [TYPE]  Set  classNames  classes  [TYPE]  Tag  tag  [TYPE]  boolean  false  true  [TYPE]  StringBuilder  accum  
[REPLACE]  accum    .  append  (   "< "  )    .  append  (  tagName  (  )  )    .  append  (  attributes  .  html  (  )  )  ;	[BUGGY]  accum  .  append  (   "< "  )  .  append  (  tagName  (  )  )  .  append  (  attributes  .  html  (  )    )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  void  outerHtml  (  StringBuilder  accum  )  {  if  (  isBlock  (  )  ||  (  parent  (  )  !  =  null  &&  parent  (  )  .  tag  (  )  .  canContainBlock  (  )  &&  siblingIndex  (  )    =  =  0  )  )  indent  (  accum  )  ;  [ATTENTION]  accum  .  append  (   "< "  )    .  append  (  tagName  (  )  )    .  append  (  attributes  .  html  (  )    )    ;      if  (  childNodes  .  isEmpty  (  )  &&  tag  .  isEmpty  (  )  )  {  accum  .  append  (   "  /> "  )  ;  }  else  {  accum  .  append  (   "> "  )  ;  html  (  accum  )  ;  if  (  tag  .  canContainBlock  (  )  )  indent  (  accum  )  ;  accum  .  append  (   "</ "  )  .  append  (  tagName  (  )  )  .  append  (   "> "  )  ;  }  }    [METHOD]  outerHtml  [TYPE]  void  [PARAMETER]  StringBuilder  accum  [CLASS]  Element    [TYPE]  Set  classNames  classes  [TYPE]  Tag  tag  [TYPE]  boolean  false  true  [TYPE]  StringBuilder  accum  
[ADD]  accum    .  append  (   "< "  )    .  append  (  tagName  (  )  )	[BUGGY]  [CE]  illegal  start  of  expression  [CONTEXT]  void  outerHtml  (  StringBuilder  accum  )  {  if  (  isBlock  (  )  ||  (  parent  (  )  !  =  null  &&  parent  (  )  .  tag  (  )  .  canContainBlock  (  )  &&  siblingIndex  (  )    =  =  0  )  )  indent  (  accum  )  ;  [ATTENTION]      .  append  (  attributes  .  html  (  )  )  ;    if  (  childNodes  .  isEmpty  (  )  &&  tag  .  isEmpty  (  )  )  {  accum  .  append  (   "  /> "  )  ;  }  else  {  accum  .  append  (   "> "  )  ;  html  (  accum  )  ;  if  (  tag  .  canContainBlock  (  )  )  indent  (  accum  )  ;  accum  .  append  (   "</ "  )  .  append  (  tagName  (  )  )  .  append  (   "> "  )  ;  }  }    [METHOD]  outerHtml  [TYPE]  void  [PARAMETER]  StringBuilder  accum  [CLASS]  Element    [TYPE]  Set  classNames  classes  [TYPE]  Tag  tag  [TYPE]  boolean  false  true  [TYPE]  StringBuilder  accum  
[REPLACE]    .  append  (  attributes  .  html  (  )  )  ;	[BUGGY]  .  append  (  attributes  .  html  (  )    )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  void  outerHtml  (  StringBuilder  accum  )  {  if  (  isBlock  (  )  ||  (  parent  (  )  !  =  null  &&  parent  (  )  .  tag  (  )  .  canContainBlock  (  )  &&  siblingIndex  (  )    =  =  0  )  )  indent  (  accum  )  ;  accum  .  append  (   "< "  )    .  append  (  tagName  (  )  )  [ATTENTION]  .  append  (  attributes  .  html  (  )    )    ;    if  (  childNodes  .  isEmpty  (  )  &&  tag  .  isEmpty  (  )  )  {  accum  .  append  (   "  /> "  )  ;  }  else  {  accum  .  append  (   "> "  )  ;  html  (  accum  )  ;  if  (  tag  .  canContainBlock  (  )  )  indent  (  accum  )  ;  accum  .  append  (   "</ "  )  .  append  (  tagName  (  )  )  .  append  (   "> "  )  ;  }  }    [METHOD]  outerHtml  [TYPE]  void  [PARAMETER]  StringBuilder  accum  [CLASS]  Element    [TYPE]  Set  classNames  classes  [TYPE]  Tag  tag  [TYPE]  boolean  false  true  [TYPE]  StringBuilder  accum  
[REPLACE]  if  (  childNodes  .  isEmpty  (  )  &&  tag  .  isEmpty  (  )  )  {	[BUGGY]  if  (  childNodes  .  isEmpty  (  )  )  {[FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  void  outerHtml  (  StringBuilder  accum  )  {  if  (  isBlock  (  )  ||  (  parent  (  )  !  =  null  &&  parent  (  )  .  tag  (  )  .  canContainBlock  (  )  &&  siblingIndex  (  )    =  =  0  )  )  indent  (  accum  )  ;  accum  .  append  (   "< "  )    .  append  (  tagName  (  )  )    .  append  (  attributes  .  html  (  )  )  ;    [ATTENTION]  if  (  childNodes  .  isEmpty  (  )  )  {  accum  .  append  (   "  /> "  )  ;  }  else  {  accum  .  append  (   "> "  )  ;  html  (  accum  )  ;  if  (  tag  .  canContainBlock  (  )  )  indent  (  accum  )  ;  accum  .  append  (   "</ "  )  .  append  (  tagName  (  )  )  .  append  (   "> "  )  ;  }  }    [METHOD]  outerHtml  [TYPE]  void  [PARAMETER]  StringBuilder  accum  [CLASS]  Element    [TYPE]  Set  classNames  classes  [TYPE]  Tag  tag  [TYPE]  boolean  false  true  [TYPE]  StringBuilder  accum  
[ADD]  if  (  childNodes  .  isEmpty  (  )  &&  tag  .  isEmpty  (  )  )  {  accum  .  append  (   "  /> "  )  ;  }  else  {  accum  .  append  (   "> "  )  ;  html  (  accum  )  ;	[BUGGY]  accum  .  append  (   "  /> "  )  ;  accum  .  append  (   "> "  )  ;  html  (  accum  )  ;  [CE]  class  ,  interface  ,  or  enum  expected  [CONTEXT]  void  outerHtml  (  StringBuilder  accum  )  {  if  (  isBlock  (  )  ||  (  parent  (  )  !  =  null  &&  parent  (  )  .  tag  (  )  .  canContainBlock  (  )  &&  siblingIndex  (  )    =  =  0  )  )  indent  (  accum  )  ;  accum  .  append  (   "< "  )    .  append  (  tagName  (  )  )    .  append  (  attributes  .  html  (  )  )  ;    [ATTENTION]  accum  .  append  (   "  /> "  )    ;  accum  .  append  (   "> "  )    ;  html  (  accum  )    ;      if  (  tag  .  canContainBlock  (  )  )  indent  (  accum  )  ;  accum  .  append  (   "</ "  )  .  append  (  tagName  (  )  )  .  append  (   "> "  )  ;  }  }    [METHOD]  outerHtml  [TYPE]  void  [PARAMETER]  StringBuilder  accum  [CLASS]  Element    [TYPE]  Set  classNames  classes  [TYPE]  Tag  tag  [TYPE]  boolean  false  true  [TYPE]  StringBuilder  accum  
[REPLACE]  if  (  tag  .  canContainBlock  (  )  )  indent  (  accum  )  ;	[BUGGY]  if  (  parent  (  )    =  =  null  )  return  0  ;  return  indexInList  (  this  ,  parent  (  )  .  children  (  )  )  ;  [CE]  cannot  return  a  value  from  method  whose  result  type  is  void  [CONTEXT]  void  outerHtml  (  StringBuilder  accum  )  {  if  (  isBlock  (  )  ||  (  parent  (  )  !  =  null  &&  parent  (  )  .  tag  (  )  .  canContainBlock  (  )  &&  siblingIndex  (  )    =  =  0  )  )  indent  (  accum  )  ;  accum  .  append  (   "< "  )    .  append  (  tagName  (  )  )    .  append  (  attributes  .  html  (  )  )  ;    if  (  childNodes  .  isEmpty  (  )  &&  tag  .  isEmpty  (  )  )  {  accum  .  append  (   "  /> "  )  ;  }  else  {  accum  .  append  (   "> "  )  ;  html  (  accum  )  ;  [ATTENTION]  if  (  parent  (  )  =  =  null  )  return  0  ;  return  indexInList  (  this  ,  parent  (  )    .  children  (  )  )    ;  accum  .  append  (   "</ "  )  .  append  (  tagName  (  )  )  .  append  (   "> "  )  ;  }  }    [METHOD]  outerHtml  [TYPE]  void  [PARAMETER]  StringBuilder  accum  [CLASS]  Element    [TYPE]  Set  classNames  classes  [TYPE]  Tag  tag  [TYPE]  boolean  false  true  [TYPE]  StringBuilder  accum  
[ADD]  if  (  tag  .  canContainBlock  (  )  )  indent  (  accum  )  ;  accum  .  append  (   "</ "  )    .  append  (  tagName  (  )  )    .  append  (   "> "  )  ;  }	[BUGGY]  [CE]  illegal  start  of  expression  [CONTEXT]  void  outerHtml  (  StringBuilder  accum  )  {  if  (  isBlock  (  )  ||  (  parent  (  )  !  =  null  &&  parent  (  )  .  tag  (  )  .  canContainBlock  (  )  &&  siblingIndex  (  )    =  =  0  )  )  indent  (  accum  )  ;  accum  .  append  (   "< "  )    .  append  (  tagName  (  )  )    .  append  (  attributes  .  html  (  )  )  ;    if  (  childNodes  .  isEmpty  (  )  &&  tag  .  isEmpty  (  )  )  {  accum  .  append  (   "  /> "  )  ;  }  else  {  accum  .  append  (   "> "  )  ;  html  (  accum  )  ;  [ATTENTION]    }    [METHOD]  outerHtml  [TYPE]  void  [PARAMETER]  StringBuilder  accum  [CLASS]  Element    [TYPE]  Set  classNames  classes  [TYPE]  Tag  tag  [TYPE]  boolean  false  true  [TYPE]  StringBuilder  accum  
[ADD]  if  (  tag  .  canContainBlock  (  )  )  indent  (  accum  )  ;  accum  .  append  (   "</ "  )    .  append  (  tagName  (  )  )    .  append  (   "> "  )  ;  }	[BUGGY]  accum  .  append  (   "</ "  )  .  append  (  tagName  (  )  )  .  append  (   "> "  )  ;  [CE]  illegal  start  of  expression  [CONTEXT]  void  outerHtml  (  StringBuilder  accum  )  {  if  (  isBlock  (  )  ||  (  parent  (  )  !  =  null  &&  parent  (  )  .  tag  (  )  .  canContainBlock  (  )  &&  siblingIndex  (  )    =  =  0  )  )  indent  (  accum  )  ;  accum  .  append  (   "< "  )    .  append  (  tagName  (  )  )    .  append  (  attributes  .  html  (  )  )  ;    if  (  childNodes  .  isEmpty  (  )  &&  tag  .  isEmpty  (  )  )  {  accum  .  append  (   "  /> "  )  ;  }  else  {  accum  .  append  (   "> "  )  ;  html  (  accum  )  ;  [ATTENTION]  accum  .  append  (   "</ "  )    .  append  (  tagName  (  )  )    .  append  (   "> "  )    ;    }    [METHOD]  outerHtml  [TYPE]  void  [PARAMETER]  StringBuilder  accum  [CLASS]  Element    [TYPE]  Set  classNames  classes  [TYPE]  Tag  tag  [TYPE]  boolean  false  true  [TYPE]  StringBuilder  accum  
[REPLACE]  accum  .  append  (   "  /> "  )  ;	[BUGGY]  accum  .  append  (   "> "  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  void  outerHtml  (  StringBuilder  accum  )  {  if  (  isBlock  (  )  ||  (  parent  (  )  !  =  null  &&  parent  (  )  .  tag  (  )  .  canContainBlock  (  )  &&  siblingIndex  (  )    =  =  0  )  )  indent  (  accum  )  ;  accum  .  append  (   "< "  )    .  append  (  tagName  (  )  )    .  append  (  attributes  .  html  (  )  )  ;    if  (  childNodes  .  isEmpty  (  )  &&  tag  .  isEmpty  (  )  )  {  [ATTENTION]  accum  .  append  (   "> "  )    ;  }  else  {  accum  .  append  (   "> "  )  ;  html  (  accum  )  ;  if  (  tag  .  canContainBlock  (  )  )  indent  (  accum  )  ;  accum  .  append  (   "</ "  )  .  append  (  tagName  (  )  )  .  append  (   "> "  )  ;  }  }    [METHOD]  outerHtml  [TYPE]  void  [PARAMETER]  StringBuilder  accum  [CLASS]  Element    [TYPE]  Set  classNames  classes  [TYPE]  Tag  tag  [TYPE]  boolean  false  true  [TYPE]  StringBuilder  accum  
[REPLACE]  if  (  tag  .  canContainBlock  (  )  )  indent  (  accum  )  ;	[BUGGY]  if  (  tag  .  isBlock  (  )  )  indent  (  accum  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  void  outerHtml  (  StringBuilder  accum  )  {  if  (  isBlock  (  )  ||  (  parent  (  )  !  =  null  &&  parent  (  )  .  tag  (  )  .  canContainBlock  (  )  &&  siblingIndex  (  )    =  =  0  )  )  indent  (  accum  )  ;  accum  .  append  (   "< "  )    .  append  (  tagName  (  )  )    .  append  (  attributes  .  html  (  )  )  ;    if  (  childNodes  .  isEmpty  (  )  &&  tag  .  isEmpty  (  )  )  {  accum  .  append  (   "  /> "  )  ;  }  else  {  accum  .  append  (   "> "  )  ;  html  (  accum  )  ;  [ATTENTION]  if  (  tag  .  isBlock  (  )  )  indent  (  accum  )    ;  accum  .  append  (   "</ "  )  .  append  (  tagName  (  )  )  .  append  (   "> "  )  ;  }  }    [METHOD]  outerHtml  [TYPE]  void  [PARAMETER]  StringBuilder  accum  [CLASS]  Element    [TYPE]  Set  classNames  classes  [TYPE]  Tag  tag  [TYPE]  boolean  false  true  [TYPE]  StringBuilder  accum  
[REPLACE]  StringBuilder  accum  =  new  StringBuilder  (  )  ;	[BUGGY]  StringBuilder  sb  =  new  StringBuilder  (  )  ;  [CE]  cannot  find  symbol  accum  [CONTEXT]  public  String  html  (  )  {  [ATTENTION]  StringBuilder  sb  =  new  StringBuilder  (  )    ;  html  (  accum  )  ;  return  accum  .  toString  (  )  .  trim  (  )  ;  }    [METHOD]  html  [TYPE]  String  [PARAMETER]  [CLASS]  Element    [TYPE]  Set  classNames  classes  [TYPE]  Tag  tag  [TYPE]  boolean  false  true  [TYPE]  StringBuilder  accum  
[REPLACE]  html  (  accum  )  ;	[BUGGY]  append  (  html  )  ;  [CE]  cannot  find  symbol  html  [CONTEXT]  public  String  html  (  )  {  StringBuilder  accum  =  new  StringBuilder  (  )  ;  [ATTENTION]  append  (  html  )    ;  return  accum  .  toString  (  )  .  trim  (  )  ;  }    [METHOD]  html  [TYPE]  String  [PARAMETER]  [CLASS]  Element    [TYPE]  Set  classNames  classes  [TYPE]  Tag  tag  [TYPE]  boolean  false  true  [TYPE]  StringBuilder  accum  
[REPLACE]  return  accum  .  toString  (  )    .  trim  (  )  ;	[BUGGY]  return  accum  .  StringBuilder  (  )    .  trim  (  )  ;  [CE]  cannot  find  symbol  [CONTEXT]  public  String  html  (  )  {  StringBuilder  accum  =  new  StringBuilder  (  )  ;  html  (  accum  )  ;  [ATTENTION]  return  accum  .  StringBuilder  (  )  .  trim  (  )    ;  }    [METHOD]  html  [TYPE]  String  [PARAMETER]  [CLASS]  Element    [TYPE]  Set  classNames  classes  [TYPE]  Tag  tag  [TYPE]  boolean  false  true  [TYPE]  StringBuilder  accum  
[ADD]  for  (  Node  node  :  childNodes  )  node  .  outerHtml  (  accum  )  ;  }	[BUGGY]  [CE]  illegal  start  of  expression  [CONTEXT]  private  void  html  (  StringBuilder  accum  )  {  [ATTENTION]        [METHOD]  html  [TYPE]  void  [PARAMETER]  StringBuilder  accum  [CLASS]  Element    [TYPE]  Set  classNames  classes  [TYPE]  Tag  tag  [TYPE]  boolean  false  true  [TYPE]  StringBuilder  accum  [TYPE]  Node  node  
[REPLACE]  empty  (  )  ;	[BUGGY]  append  (  html  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  Element  html  (  String  html  )  {  [ATTENTION]  append  (  html  )    ;  append  (  html  )  ;  return  this  ;  }    [METHOD]  html  [TYPE]  Element  [PARAMETER]  String  html  [CLASS]  Element    [TYPE]  Set  classNames  classes  [TYPE]  Tag  tag  [TYPE]  String  html  [TYPE]  boolean  false  true  
[REPLACE]  append  (  html  )  ;	[BUGGY]  prependChild  (  node  )  ;  [CE]  cannot  find  symbol  node  [CONTEXT]  public  Element  html  (  String  html  )  {  empty  (  )  ;  [ATTENTION]  prependChild  (  node  )    ;  return  this  ;  }    [METHOD]  html  [TYPE]  Element  [PARAMETER]  String  html  [CLASS]  Element    [TYPE]  Set  classNames  classes  [TYPE]  Tag  tag  [TYPE]  String  html  [TYPE]  boolean  false  true  
[REPLACE]  return  this;	[BUGGY]  return  null  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  Element  html  (  String  html  )  {  empty  (  )  ;  append  (  html  )  ;  [ATTENTION]  return  null  ;  }    [METHOD]  html  [TYPE]  Element  [PARAMETER]  String  html  [CLASS]  Element    [TYPE]  Set  classNames  classes  [TYPE]  Tag  tag  [TYPE]  String  html  [TYPE]  boolean  false  true  
[REPLACE]  return  outerHtml  (  )  ;	[BUGGY]  return  elements  .  get  (  0  )  ;  [CE]  cannot  find  symbol  elements  [CONTEXT]  public  String  toString  (  )  {  [ATTENTION]  return  elements  .  get  (  0  )    ;  }    [METHOD]  toString  [TYPE]  String  [PARAMETER]  [CLASS]  Element    [TYPE]  Set  classNames  classes  [TYPE]  Tag  tag  [TYPE]  boolean  false  true  
[REPLACE]  if  (  this  ==  o  )  return  true;	[BUGGY]  if  (  this  !  =    o  )  return  true  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  boolean  equals  (  Object  o  )  {  [ATTENTION]  if  (  this!  =  o  )  return  true  ;  if  (  !  (  o  instanceof  Element  )  )  return  false  ;  if  (  !super  .  equals  (  o  )  )  return  false  ;    Element  element  =    (  Element  )  o  ;    if  (  tag  !  =  null  ?  !tag  .  equals  (  element  .  tag  )  :  element  .  tag  !  =  null  )  return  false  ;    return  true  ;  }    [METHOD]  equals  [TYPE]  boolean  [PARAMETER]  Object  o  [CLASS]  Element    [TYPE]  Object  o  [TYPE]  Set  classNames  classes  [TYPE]  Tag  tag  [TYPE]  boolean  false  true  [TYPE]  Element  element  
[ADD]  if  (  this  ==  o  )  return  true;  if  (  !  (  o  instanceof  Element  )  )  return  false;  if  (  !super  .  equals  (  o  )  )  return  false;  Element  element  =  (  Element  )  o;	[BUGGY]  [CE]  cannot  find  symbol  element  [CONTEXT]  public  boolean  equals  (  Object  o  )  {  [ATTENTION]        if  (  tag  !  =  null  ?  !tag  .  equals  (  element  .  tag  )  :  element  .  tag  !  =  null  )  return  false  ;    return  true  ;  }    [METHOD]  equals  [TYPE]  boolean  [PARAMETER]  Object  o  [CLASS]  Element    [TYPE]  Object  o  [TYPE]  Set  classNames  classes  [TYPE]  Tag  tag  [TYPE]  boolean  false  true  [TYPE]  Element  element  
[REPLACE]  if  (  this  ==  o  )  return  true;	[BUGGY]  if  (  this  =  =  o  )  return  false  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  boolean  equals  (  Object  o  )  {  [ATTENTION]  if  (  this  =  =  o  )  return  false  ;  if  (  !  (  o  instanceof  Element  )  )  return  false  ;  if  (  !super  .  equals  (  o  )  )  return  false  ;    Element  element  =    (  Element  )  o  ;    if  (  tag  !  =  null  ?  !tag  .  equals  (  element  .  tag  )  :  element  .  tag  !  =  null  )  return  false  ;    return  true  ;  }    [METHOD]  equals  [TYPE]  boolean  [PARAMETER]  Object  o  [CLASS]  Element    [TYPE]  Object  o  [TYPE]  Set  classNames  classes  [TYPE]  Tag  tag  [TYPE]  boolean  false  true  [TYPE]  Element  element  
[REPLACE]  if  (  !  (  o  instanceof  Element  )  )  return  false;	[BUGGY]  if  (  !  !  (  o  instanceof  Element  )  )  return  false  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  boolean  equals  (  Object  o  )  {  if  (  this  =  =  o  )  return  true  ;  [ATTENTION]  if  (  !  !  (  o  instanceof  Element  )  )  return  false  ;  if  (  !super  .  equals  (  o  )  )  return  false  ;    Element  element  =    (  Element  )  o  ;    if  (  tag  !  =  null  ?  !tag  .  equals  (  element  .  tag  )  :  element  .  tag  !  =  null  )  return  false  ;    return  true  ;  }    [METHOD]  equals  [TYPE]  boolean  [PARAMETER]  Object  o  [CLASS]  Element    [TYPE]  Object  o  [TYPE]  Set  classNames  classes  [TYPE]  Tag  tag  [TYPE]  boolean  false  true  [TYPE]  Element  element  
[ADD]  if  (  !  (  o  instanceof  Element  )  )  return  false;  if  (  !super  .  equals  (  o  )  )  return  false;  Element  element  =  (  Element  )  o;	[BUGGY]  if  (  !super  .  equals  (  o  )  )  return  false  ;  Element  element  =    (  Element  )  o  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  boolean  equals  (  Object  o  )  {  if  (  this  =  =  o  )  return  true  ;  [ATTENTION]  if  (  !super  .  equals  (  o  )  )  return  false  ;  Element  element  =  (  Element  )  o  ;      if  (  tag  !  =  null  ?  !tag  .  equals  (  element  .  tag  )  :  element  .  tag  !  =  null  )  return  false  ;    return  true  ;  }    [METHOD]  equals  [TYPE]  boolean  [PARAMETER]  Object  o  [CLASS]  Element    [TYPE]  Object  o  [TYPE]  Set  classNames  classes  [TYPE]  Tag  tag  [TYPE]  boolean  false  true  [TYPE]  Element  element  
[REPLACE]  if  (  !  (  o  instanceof  Element  )  )  return  false;	[BUGGY]  if  (  !  (  o  instanceof  Element  )  )  return  true  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  boolean  equals  (  Object  o  )  {  if  (  this  =  =  o  )  return  true  ;  [ATTENTION]  if  (  !  (  o  instanceof  Element  )  )  return  true  ;  if  (  !super  .  equals  (  o  )  )  return  false  ;    Element  element  =    (  Element  )  o  ;    if  (  tag  !  =  null  ?  !tag  .  equals  (  element  .  tag  )  :  element  .  tag  !  =  null  )  return  false  ;    return  true  ;  }    [METHOD]  equals  [TYPE]  boolean  [PARAMETER]  Object  o  [CLASS]  Element    [TYPE]  Object  o  [TYPE]  Set  classNames  classes  [TYPE]  Tag  tag  [TYPE]  boolean  false  true  [TYPE]  Element  element  
[REPLACE]  if  (  !super  .  equals  (  o  )  )  return  false;	[BUGGY]  if  (  !super  .  equals  (  o  )  )  return  true  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  boolean  equals  (  Object  o  )  {  if  (  this  =  =  o  )  return  true  ;  if  (  !  (  o  instanceof  Element  )  )  return  false  ;  [ATTENTION]  if  (  !super  .  equals  (  o  )  )  return  true  ;    Element  element  =    (  Element  )  o  ;    if  (  tag  !  =  null  ?  !tag  .  equals  (  element  .  tag  )  :  element  .  tag  !  =  null  )  return  false  ;    return  true  ;  }    [METHOD]  equals  [TYPE]  boolean  [PARAMETER]  Object  o  [CLASS]  Element    [TYPE]  Object  o  [TYPE]  Set  classNames  classes  [TYPE]  Tag  tag  [TYPE]  boolean  false  true  [TYPE]  Element  element  
[REPLACE]  Element  element  =  (  Element  )  o;	[BUGGY]  Element  element  =    (  Element  )  child  ;  [CE]  cannot  find  symbol  child  [CONTEXT]  public  boolean  equals  (  Object  o  )  {  if  (  this  =  =  o  )  return  true  ;  if  (  !  (  o  instanceof  Element  )  )  return  false  ;  if  (  !super  .  equals  (  o  )  )  return  false  ;    [ATTENTION]  Element  element  =  (  Element  )  child  ;    if  (  tag  !  =  null  ?  !tag  .  equals  (  element  .  tag  )  :  element  .  tag  !  =  null  )  return  false  ;    return  true  ;  }    [METHOD]  equals  [TYPE]  boolean  [PARAMETER]  Object  o  [CLASS]  Element    [TYPE]  Object  o  [TYPE]  Set  classNames  classes  [TYPE]  Tag  tag  [TYPE]  boolean  false  true  [TYPE]  Element  element  
[REPLACE]  if  (  tag  !=  null  ?  !tag  .  equals  (  element  .  tag  )  :  element  .  tag  !=  null  )  return  false;	[BUGGY]  if  (  tag  !  =    element  .  tag  !  =  null  )  return  false  ;  [CE]  ')'  expected  [CONTEXT]  public  boolean  equals  (  Object  o  )  {  if  (  this  =  =  o  )  return  true  ;  if  (  !  (  o  instanceof  Element  )  )  return  false  ;  if  (  !super  .  equals  (  o  )  )  return  false  ;    Element  element  =    (  Element  )  o  ;    [ATTENTION]  if  (  tag  !  =  element  .  tag  !  =  null  )  return  false  ;    return  true  ;  }    [METHOD]  equals  [TYPE]  boolean  [PARAMETER]  Object  o  [CLASS]  Element    [TYPE]  Object  o  [TYPE]  Set  classNames  classes  [TYPE]  Tag  tag  [TYPE]  boolean  false  true  [TYPE]  Element  element  
[ADD]  if  (  tag  !=  null  ?  !tag  .  equals  (  element  .  tag  )  :  element  .  tag  !=  null  )  return  false;  return  true;  }	[BUGGY]  [CE]  '  ;  '  expected  [CONTEXT]  public  boolean  equals  (  Object  o  )  {  if  (  this  =  =  o  )  return  true  ;  if  (  !  (  o  instanceof  Element  )  )  return  false  ;  if  (  !super  .  equals  (  o  )  )  return  false  ;    Element  element  =    (  Element  )  o  ;    [ATTENTION]        [METHOD]  equals  [TYPE]  boolean  [PARAMETER]  Object  o  [CLASS]  Element    [TYPE]  Object  o  [TYPE]  Set  classNames  classes  [TYPE]  Tag  tag  [TYPE]  boolean  false  true  [TYPE]  Element  element  
[REPLACE]  if  (  tag  !=  null  ?  !tag  .  equals  (  element  .  tag  )  :  element  .  tag  !=  null  )  return  false;	[BUGGY]  if  (  tag  !  =  null  ?  !tag  .  equals  (  element  .  tag  )  :  element  .  tag  !  =  null  )  return  true  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  boolean  equals  (  Object  o  )  {  if  (  this  =  =  o  )  return  true  ;  if  (  !  (  o  instanceof  Element  )  )  return  false  ;  if  (  !super  .  equals  (  o  )  )  return  false  ;    Element  element  =    (  Element  )  o  ;    [ATTENTION]  if  (  tag  !  =  null  ?  !tag  .  equals  (  element  .  tag  )  :  element  .  tag  !  =  null  )  return  true  ;    return  true  ;  }    [METHOD]  equals  [TYPE]  boolean  [PARAMETER]  Object  o  [CLASS]  Element    [TYPE]  Object  o  [TYPE]  Set  classNames  classes  [TYPE]  Tag  tag  [TYPE]  boolean  false  true  [TYPE]  Element  element  
[REPLACE]  return  true;	[BUGGY]  return  false  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  boolean  equals  (  Object  o  )  {  if  (  this  =  =  o  )  return  true  ;  if  (  !  (  o  instanceof  Element  )  )  return  false  ;  if  (  !super  .  equals  (  o  )  )  return  false  ;    Element  element  =    (  Element  )  o  ;    if  (  tag  !  =  null  ?  !tag  .  equals  (  element  .  tag  )  :  element  .  tag  !  =  null  )  return  false  ;    [ATTENTION]  return  false  ;  }    [METHOD]  equals  [TYPE]  boolean  [PARAMETER]  Object  o  [CLASS]  Element    [TYPE]  Object  o  [TYPE]  Set  classNames  classes  [TYPE]  Tag  tag  [TYPE]  boolean  false  true  [TYPE]  Element  element  
[REPLACE]  int  result  =  super  .  hashCode  (  )  ;	[BUGGY]  int  result  =  super  .  Object  (  )  ;  [CE]  cannot  find  symbol  [CONTEXT]  public  int  hashCode  (  )  {  [ATTENTION]  int  result  =  super  .  Object  (  )    ;  result  =  31  *  result  +  (  tag  !  =  null  ?  tag  .  hashCode  (  )  :  0  )  ;  return  result  ;  }    [METHOD]  hashCode  [TYPE]  int  [PARAMETER]  [CLASS]  Element    [TYPE]  Set  classNames  classes  [TYPE]  Tag  tag  [TYPE]  boolean  false  true  [TYPE]  int  result  
[ADD]  int  result  =  super  .  hashCode  (  )  ;  result  =  31  *  result  +  (  tag  !=  null  ?  tag  .  hashCode  (  )  :  0  )  ;	[BUGGY]  result  =  31  *  result  +  (  tag  !  =  null  ?  tag  .  hashCode  (  )  :  0  )  ;  [CE]  cannot  find  symbol  result  [CONTEXT]  public  int  hashCode  (  )  {  [ATTENTION]  result  =  31  *  result  +  (  tag  !  =  null  ?  tag  .  hashCode  (  )  :  0  )    ;    return  result  ;  }    [METHOD]  hashCode  [TYPE]  int  [PARAMETER]  [CLASS]  Element    [TYPE]  Set  classNames  classes  [TYPE]  Tag  tag  [TYPE]  boolean  false  true  [TYPE]  int  result  
[REPLACE]  result  =  31  *  result  +  (  tag  !=  null  ?  tag  .  hashCode  (  )  :  0  )  ;	[BUGGY]  result    =    0  )  ;  [CE]  '  ;  '  expected  [CONTEXT]  public  int  hashCode  (  )  {  int  result  =  super  .  hashCode  (  )  ;  [ATTENTION]  result  =  0  )    ;  return  result  ;  }    [METHOD]  hashCode  [TYPE]  int  [PARAMETER]  [CLASS]  Element    [TYPE]  Set  classNames  classes  [TYPE]  Tag  tag  [TYPE]  boolean  false  true  [TYPE]  int  result  
[REPLACE]  return  result;	[BUGGY]  return  elements  .  get  (  0  )  ;  [CE]  cannot  find  symbol  elements  [CONTEXT]  public  int  hashCode  (  )  {  int  result  =  super  .  hashCode  (  )  ;  result  =  31  *  result  +  (  tag  !  =  null  ?  tag  .  hashCode  (  )  :  0  )  ;  [ATTENTION]  return  elements  .  get  (  0  )    ;  }    [METHOD]  hashCode  [TYPE]  int  [PARAMETER]  [CLASS]  Element    [TYPE]  Set  classNames  classes  [TYPE]  Tag  tag  [TYPE]  boolean  false  true  [TYPE]  int  result  
[REPLACE]  private  static  final  String  DATA_KEY  =   "data ";	[BUGGY]  private  static  final  String  DATA_KEY  ;  [CE]  variable  DATA_KEY  might  not  have  been  initialized  [CONTEXT]      [CLASS]  DataNode  
[REPLACE]  super  (  baseUri  )  ;	[BUGGY]  super  (  data  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  DataNode  (  String  data  ,  String  baseUri  )  {  [ATTENTION]  super  (  data  )    ;  attributes  .  put  (  DATA_KEY  ,  data  )  ;  }    [METHOD]  <init>  [TYPE]  String)  [PARAMETER]  String  data  String  baseUri  [CLASS]  DataNode    [TYPE]  String  DATA_KEY  baseUri  data  [TYPE]  boolean  false  true  
[ADD]  super  (  baseUri  )  ;  attributes  .  put  (  DATA_KEY,  data  )  ;	[BUGGY]  [CE]  no  suitable  constructor  found  for  Node()  [CONTEXT]  public  DataNode  (  String  data  ,  String  baseUri  )  {  [ATTENTION]    }    [METHOD]  <init>  [TYPE]  String)  [PARAMETER]  String  data  String  baseUri  [CLASS]  DataNode    [TYPE]  String  DATA_KEY  baseUri  data  [TYPE]  boolean  false  true  
[REPLACE]  attributes  .  put  (  DATA_KEY,  data  )  ;	[BUGGY]  attributes  .  put  (  DATA_KEY  ,  baseUri  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  DataNode  (  String  data  ,  String  baseUri  )  {  super  (  baseUri  )  ;  [ATTENTION]  attributes  .  put  (  DATA_KEY  ,  baseUri  )    ;  }    [METHOD]  <init>  [TYPE]  String)  [PARAMETER]  String  data  String  baseUri  [CLASS]  DataNode    [TYPE]  String  DATA_KEY  baseUri  data  [TYPE]  boolean  false  true  
[REPLACE]  return   "#data ";	[BUGGY]  return  outerHtml  (  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  String  nodeName  (  )  {  [ATTENTION]  return  outerHtml  (  )    ;  }    [METHOD]  nodeName  [TYPE]  String  [PARAMETER]  [CLASS]  DataNode    [TYPE]  String  DATA_KEY  baseUri  data  [TYPE]  boolean  false  true  
[REPLACE]  return  attributes  .  get  (  DATA_KEY  )  ;	[BUGGY]  return    DATA_KEY    ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  String  getWholeData  (  )  {  [ATTENTION]  return  DATA_KEY  ;  }    [METHOD]  getWholeData  [TYPE]  String  [PARAMETER]  [CLASS]  DataNode    [TYPE]  String  DATA_KEY  baseUri  data  [TYPE]  boolean  false  true  
[REPLACE]  accum  .  append  (  getWholeData  (  )  )  ;	[BUGGY]  return  outerHtml  (  )  ;  [CE]  cannot  return  a  value  from  method  whose  result  type  is  void  [CONTEXT]  void  outerHtml  (  StringBuilder  accum  )  {  [ATTENTION]  return  outerHtml  (  )    ;  }    [METHOD]  outerHtml  [TYPE]  void  [PARAMETER]  StringBuilder  accum  [CLASS]  DataNode    [TYPE]  StringBuilder  accum  [TYPE]  String  DATA_KEY  baseUri  data  [TYPE]  boolean  false  true  
[REPLACE]  return  outerHtml  (  )  ;	[BUGGY]  return   "#data "  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  String  toString  (  )  {  [ATTENTION]  return   "#data "  ;  }    [METHOD]  toString  [TYPE]  String  [PARAMETER]  [CLASS]  DataNode    [TYPE]  String  DATA_KEY  baseUri  data  [TYPE]  boolean  false  true  
[REPLACE]  String  data  =  StringEscapeUtils  .  unescapeHtml  (  encodedData  )  ;	[BUGGY]  String  data  =  StringEscapeUtils  .  unescapeHtml  (  data  )  ;  [CE]  variable  data  might  not  have  been  initialized  [CONTEXT]  public  static  DataNode  createFromEncoded  (  String  encodedData  ,  String  baseUri  )  {  [ATTENTION]  String  data  =  StringEscapeUtils  .  unescapeHtml  (  data  )    ;  return  new  DataNode  (  data  ,  baseUri  )  ;  }    [METHOD]  createFromEncoded  [TYPE]  DataNode  [PARAMETER]  String  encodedData  String  baseUri  [CLASS]  DataNode    [TYPE]  String  DATA_KEY  baseUri  data  encodedData  [TYPE]  boolean  false  true  
[ADD]  String  data  =  StringEscapeUtils  .  unescapeHtml  (  encodedData  )  ;	[BUGGY]  [CE]  cannot  find  symbol  data  [CONTEXT]  public  static  DataNode  createFromEncoded  (  String  encodedData  ,  String  baseUri  )  {  [ATTENTION]  return  new  DataNode  (  data  ,  baseUri  )  ;  }    [METHOD]  createFromEncoded  [TYPE]  DataNode  [PARAMETER]  String  encodedData  String  baseUri  [CLASS]  DataNode    [TYPE]  String  DATA_KEY  baseUri  data  encodedData  [TYPE]  boolean  false  true  
[REPLACE]  return  new  DataNode  (  data,  baseUri  )  ;	[BUGGY]  return  new  DataNode  (  encodedData  ,  baseUri  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  static  DataNode  createFromEncoded  (  String  encodedData  ,  String  baseUri  )  {  String  data  =  StringEscapeUtils  .  unescapeHtml  (  encodedData  )  ;  [ATTENTION]  return  new  DataNode  (  encodedData  ,  baseUri  )    ;  }    [METHOD]  createFromEncoded  [TYPE]  DataNode  [PARAMETER]  String  encodedData  String  baseUri  [CLASS]  DataNode    [TYPE]  String  DATA_KEY  baseUri  data  encodedData  [TYPE]  boolean  false  true  
[REPLACE]  private  static  final  String  COMMENT_KEY  =   "comment ";	[BUGGY]  private  static  final  String  COMMENT_KEY  ;  [CE]  variable  COMMENT_KEY  might  not  have  been  initialized  [CONTEXT]      [CLASS]  Comment  
[REPLACE]  super  (  baseUri  )  ;	[BUGGY]  super  (  data  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  Comment  (  String  data  ,  String  baseUri  )  {  [ATTENTION]  super  (  data  )    ;  attributes  .  put  (  COMMENT_KEY  ,  data  )  ;  }    [METHOD]  <init>  [TYPE]  String)  [PARAMETER]  String  data  String  baseUri  [CLASS]  Comment    [TYPE]  String  COMMENT_KEY  baseUri  data  [TYPE]  boolean  false  true  
[REPLACE]  attributes  .  put  (  COMMENT_KEY,  data  )  ;	[BUGGY]  attributes  .  put  (  COMMENT_KEY  ,  baseUri  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  Comment  (  String  data  ,  String  baseUri  )  {  super  (  baseUri  )  ;  [ATTENTION]  attributes  .  put  (  COMMENT_KEY  ,  baseUri  )    ;  }    [METHOD]  <init>  [TYPE]  String)  [PARAMETER]  String  data  String  baseUri  [CLASS]  Comment    [TYPE]  String  COMMENT_KEY  baseUri  data  [TYPE]  boolean  false  true  
[REPLACE]  return   "#comment ";	[BUGGY]  return  outerHtml  (  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  String  nodeName  (  )  {  [ATTENTION]  return  outerHtml  (  )    ;  }    [METHOD]  nodeName  [TYPE]  String  [PARAMETER]  [CLASS]  Comment    [TYPE]  String  COMMENT_KEY  baseUri  data  [TYPE]  boolean  false  true  
[REPLACE]  return  attributes  .  get  (  COMMENT_KEY  )  ;	[BUGGY]  return  attributes  .  put  (  baseUri  ,  COMMENT_KEY  )    ;  [CE]  incompatible  types  [CONTEXT]  public  String  getData  (  )  {  [ATTENTION]  return  attributes  .  put  (  baseUri  ,  COMMENT_KEY  )  ;  }    [METHOD]  getData  [TYPE]  String  [PARAMETER]  [CLASS]  Comment    [TYPE]  String  COMMENT_KEY  baseUri  data  [TYPE]  boolean  false  true  
[REPLACE]  indent  (  accum  )  ;	[BUGGY]  super  (  baseUri  )  ;  [CE]  call  to  super  must  be  first  statement  in  constructor  [CONTEXT]  void  outerHtml  (  StringBuilder  accum  )  {  [ATTENTION]  super  (  baseUri  )    ;  accum  .  append  (  String  .  format  (   "<!--%s--> "  ,  getData  (  )  )  )  ;  }    [METHOD]  outerHtml  [TYPE]  void  [PARAMETER]  StringBuilder  accum  [CLASS]  Comment    [TYPE]  StringBuilder  accum  [TYPE]  String  COMMENT_KEY  baseUri  data  [TYPE]  boolean  false  true  
[REPLACE]  accum  .  append  (  String  .  format  (   "<!--%s--> ",  getData  (  )  )  )  ;	[BUGGY]  attributes  .  put  (  COMMENT_KEY  ,  data  )  ;  [CE]  cannot  find  symbol  data  [CONTEXT]  void  outerHtml  (  StringBuilder  accum  )  {  indent  (  accum  )  ;  [ATTENTION]  attributes  .  put  (  COMMENT_KEY  ,  data  )    ;  }    [METHOD]  outerHtml  [TYPE]  void  [PARAMETER]  StringBuilder  accum  [CLASS]  Comment    [TYPE]  StringBuilder  accum  [TYPE]  String  COMMENT_KEY  baseUri  data  [TYPE]  boolean  false  true  
[REPLACE]  return  outerHtml  (  )  ;	[BUGGY]  return   "#comment "  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  String  toString  (  )  {  [ATTENTION]  return   "#comment "  ;  }    [METHOD]  toString  [TYPE]  String  [PARAMETER]  [CLASS]  Comment    [TYPE]  String  COMMENT_KEY  baseUri  data  [TYPE]  boolean  false  true  
[REPLACE]  private  static  final  String  TEXT_KEY  =   "text ";	[BUGGY]  private  static  final  String  TEXT_KEY  ;  [CE]  variable  TEXT_KEY  might  not  have  been  initialized  [CONTEXT]      [CLASS]  TextNode  
[REPLACE]  super  (  baseUri  )  ;	[BUGGY]  super  (  text  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  TextNode  (  String  text  ,  String  baseUri  )  {  [ATTENTION]  super  (  text  )    ;  attributes  .  put  (  TEXT_KEY  ,  text  )  ;  }    [METHOD]  <init>  [TYPE]  String)  [PARAMETER]  String  text  String  baseUri  [CLASS]  TextNode    [TYPE]  String  TEXT_KEY  baseUri  text  [TYPE]  boolean  false  true  
[REPLACE]  attributes  .  put  (  TEXT_KEY,  text  )  ;	[BUGGY]  attributes  .  get  (  TEXT_KEY  )    ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  TextNode  (  String  text  ,  String  baseUri  )  {  super  (  baseUri  )  ;  [ATTENTION]  attributes  .  get  (  TEXT_KEY  )  ;  }    [METHOD]  <init>  [TYPE]  String)  [PARAMETER]  String  text  String  baseUri  [CLASS]  TextNode    [TYPE]  String  TEXT_KEY  baseUri  text  [TYPE]  boolean  false  true  
[REPLACE]  return   "#text ";	[BUGGY]  return  new  TextNode  (  text  ,  baseUri  )  ;  [CE]  cannot  find  symbol  text  [CONTEXT]  public  String  nodeName  (  )  {  [ATTENTION]  return  new  TextNode  (  text  ,  baseUri  )    ;  }    [METHOD]  nodeName  [TYPE]  String  [PARAMETER]  [CLASS]  TextNode    [TYPE]  String  TEXT_KEY  baseUri  text  [TYPE]  boolean  false  true  
[REPLACE]  return  outerHtml  (  )  ;	[BUGGY]  return  new  TextNode  (  text  ,  baseUri  )  ;  [CE]  cannot  find  symbol  text  [CONTEXT]  public  String  text  (  )  {  [ATTENTION]  return  new  TextNode  (  text  ,  baseUri  )    ;  }    [METHOD]  text  [TYPE]  String  [PARAMETER]  [CLASS]  TextNode    [TYPE]  String  TEXT_KEY  baseUri  text  [TYPE]  boolean  false  true  
[REPLACE]  attributes  .  put  (  TEXT_KEY,  text  )  ;	[BUGGY]  attributes  .  put  (  TEXT_KEY  ,  baseUri  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  TextNode  text  (  String  text  )  {  [ATTENTION]  attributes  .  put  (  TEXT_KEY  ,  baseUri  )    ;  return  this  ;  }    [METHOD]  text  [TYPE]  TextNode  [PARAMETER]  String  text  [CLASS]  TextNode    [TYPE]  String  TEXT_KEY  baseUri  text  [TYPE]  boolean  false  true  
[REPLACE]  return  this;	[BUGGY]  return  null  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  TextNode  text  (  String  text  )  {  attributes  .  put  (  TEXT_KEY  ,  text  )  ;  [ATTENTION]  return  null  ;  }    [METHOD]  text  [TYPE]  TextNode  [PARAMETER]  String  text  [CLASS]  TextNode    [TYPE]  String  TEXT_KEY  baseUri  text  [TYPE]  boolean  false  true  
[REPLACE]  return  attributes  .  get  (  TEXT_KEY  )  ;	[BUGGY]  return    TEXT_KEY    ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  String  getWholeText  (  )  {  [ATTENTION]  return  TEXT_KEY  ;  }    [METHOD]  getWholeText  [TYPE]  String  [PARAMETER]  [CLASS]  TextNode    [TYPE]  String  TEXT_KEY  baseUri  text  [TYPE]  boolean  false  true  
[REPLACE]  return  StringUtils  .  isBlank  (  normaliseWhitespace  (  getWholeText  (  )  )  )  ;	[BUGGY]  return    normaliseWhitespace  (  getWholeText  (  )    )  ;  [CE]  incompatible  types  [CONTEXT]  public  boolean  isBlank  (  )  {  [ATTENTION]  return  normaliseWhitespace  (  getWholeText  (  )    )    ;  }    [METHOD]  isBlank  [TYPE]  boolean  [PARAMETER]  [CLASS]  TextNode    [TYPE]  String  TEXT_KEY  baseUri  text  [TYPE]  boolean  false  true  
[REPLACE]  String  html  =  StringEscapeUtils  .  escapeHtml  (  getWholeText  (  )  )  ;	[BUGGY]  String  html  =  StringEscapeUtils  .  unescapeHtml  (  getWholeText  (  )  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  void  outerHtml  (  StringBuilder  accum  )  {  [ATTENTION]  String  html  =  StringEscapeUtils  .  unescapeHtml  (  getWholeText  (  )  )    ;  if  (  parent  (  )  instanceof  Element  &&  !  (  (  Element  )  parent  (  )  )  .  preserveWhitespace  (  )  )  {  html  =  normaliseWhitespace  (  html  )  ;  }  if  (  !isBlank  (  )  &&  parentNode  instanceof  Element  &&  (  (  Element  )  parentNode  )  .  tag  (  )  .  canContainBlock  (  )  &&  siblingIndex  (  )    =  =  0  )  indent  (  accum  )  ;  accum  .  append  (  html  )  ;  }    [METHOD]  outerHtml  [TYPE]  void  [PARAMETER]  StringBuilder  accum  [CLASS]  TextNode    [TYPE]  StringBuilder  accum  [TYPE]  String  TEXT_KEY  baseUri  html  text  [TYPE]  boolean  false  true  
[ADD]  String  html  =  StringEscapeUtils  .  escapeHtml  (  getWholeText  (  )  )  ;	[BUGGY]  [CE]  cannot  find  symbol  html  [CONTEXT]  void  outerHtml  (  StringBuilder  accum  )  {  [ATTENTION]  if  (  parent  (  )  instanceof  Element  &&  !  (  (  Element  )  parent  (  )  )  .  preserveWhitespace  (  )  )  {  html  =  normaliseWhitespace  (  html  )  ;  }  if  (  !isBlank  (  )  &&  parentNode  instanceof  Element  &&  (  (  Element  )  parentNode  )  .  tag  (  )  .  canContainBlock  (  )  &&  siblingIndex  (  )    =  =  0  )  indent  (  accum  )  ;  accum  .  append  (  html  )  ;  }    [METHOD]  outerHtml  [TYPE]  void  [PARAMETER]  StringBuilder  accum  [CLASS]  TextNode    [TYPE]  StringBuilder  accum  [TYPE]  String  TEXT_KEY  baseUri  html  text  [TYPE]  boolean  false  true  
[REPLACE]  if  (  parent  (  )  instanceof  Element  &&  !  (  (  Element  )  parent  (  )  )    .  preserveWhitespace  (  )  )  {	[BUGGY]  if  (  !  parent  (  )  instanceof  Element  )  {[CE]  bad  operand  type  Node  for  unary  operator  '!'  [CONTEXT]  void  outerHtml  (  StringBuilder  accum  )  {  String  html  =  StringEscapeUtils  .  escapeHtml  (  getWholeText  (  )  )  ;  [ATTENTION]  if  (  !  parent  (  )  instanceof  Element  )  {  html  =  normaliseWhitespace  (  html  )  ;  }  if  (  !isBlank  (  )  &&  parentNode  instanceof  Element  &&  (  (  Element  )  parentNode  )  .  tag  (  )  .  canContainBlock  (  )  &&  siblingIndex  (  )    =  =  0  )  indent  (  accum  )  ;  accum  .  append  (  html  )  ;  }    [METHOD]  outerHtml  [TYPE]  void  [PARAMETER]  StringBuilder  accum  [CLASS]  TextNode    [TYPE]  StringBuilder  accum  [TYPE]  String  TEXT_KEY  baseUri  html  text  [TYPE]  boolean  false  true  
[REPLACE]  html  =  normaliseWhitespace  (  html  )  ;	[BUGGY]  html  =    normaliseWhitespace  (  TEXT_KEY  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  void  outerHtml  (  StringBuilder  accum  )  {  String  html  =  StringEscapeUtils  .  escapeHtml  (  getWholeText  (  )  )  ;  if  (  parent  (  )  instanceof  Element  &&  !  (  (  Element  )  parent  (  )  )  .  preserveWhitespace  (  )  )  {  [ATTENTION]  html  =  normaliseWhitespace  (  TEXT_KEY  )    ;  }  if  (  !isBlank  (  )  &&  parentNode  instanceof  Element  &&  (  (  Element  )  parentNode  )  .  tag  (  )  .  canContainBlock  (  )  &&  siblingIndex  (  )    =  =  0  )  indent  (  accum  )  ;  accum  .  append  (  html  )  ;  }    [METHOD]  outerHtml  [TYPE]  void  [PARAMETER]  StringBuilder  accum  [CLASS]  TextNode    [TYPE]  StringBuilder  accum  [TYPE]  String  TEXT_KEY  baseUri  html  text  [TYPE]  boolean  false  true  
[ADD]  html  =  normaliseWhitespace  (  html  )  ;	[BUGGY]  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  void  outerHtml  (  StringBuilder  accum  )  {  String  html  =  StringEscapeUtils  .  escapeHtml  (  getWholeText  (  )  )  ;  if  (  parent  (  )  instanceof  Element  &&  !  (  (  Element  )  parent  (  )  )  .  preserveWhitespace  (  )  )  {  [ATTENTION]  }  if  (  !isBlank  (  )  &&  parentNode  instanceof  Element  &&  (  (  Element  )  parentNode  )  .  tag  (  )  .  canContainBlock  (  )  &&  siblingIndex  (  )    =  =  0  )  indent  (  accum  )  ;  accum  .  append  (  html  )  ;  }    [METHOD]  outerHtml  [TYPE]  void  [PARAMETER]  StringBuilder  accum  [CLASS]  TextNode    [TYPE]  StringBuilder  accum  [TYPE]  String  TEXT_KEY  baseUri  html  text  [TYPE]  boolean  false  true  
[REPLACE]  if  (  !isBlank  (  )  &&  parentNode  instanceof  Element  &&  (  (  Element  )  parentNode  )    .  tag  (  )    .  canContainBlock  (  )    &&  siblingIndex  (  )  ==  0  )  indent  (  accum  )  ;	[BUGGY]  if  (  !  !isBlank  (  )  &&  parentNode  instanceof  Element  &&  (  (  Element  )  parentNode  )  .  tag  (  )  .  canContainBlock  (  )    &&  siblingIndex  (  )    =  =  3  )  indent  (  accum  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  void  outerHtml  (  StringBuilder  accum  )  {  String  html  =  StringEscapeUtils  .  escapeHtml  (  getWholeText  (  )  )  ;  if  (  parent  (  )  instanceof  Element  &&  !  (  (  Element  )  parent  (  )  )  .  preserveWhitespace  (  )  )  {  html  =  normaliseWhitespace  (  html  )  ;  }  [ATTENTION]  if  (  !  !isBlank  (  )  &&  parentNode  instanceof  Element  &&  (  (  Element  )  parentNode  )    .  tag  (  )    .  canContainBlock  (  )  &&  siblingIndex  (  )  =  =  3  )  indent  (  accum  )    ;    accum  .  append  (  html  )  ;  }    [METHOD]  outerHtml  [TYPE]  void  [PARAMETER]  StringBuilder  accum  [CLASS]  TextNode    [TYPE]  StringBuilder  accum  [TYPE]  String  TEXT_KEY  baseUri  html  text  [TYPE]  boolean  false  true  
[ADD]  if  (  !isBlank  (  )  &&  parentNode  instanceof  Element  &&  (  (  Element  )  parentNode  )    .  tag  (  )    .  canContainBlock  (  )    &&  siblingIndex  (  )  ==  0  )  indent  (  accum  )  ;  accum  .  append  (  html  )  ;  }	[BUGGY]  [CE]  illegal  start  of  expression  [CONTEXT]  void  outerHtml  (  StringBuilder  accum  )  {  String  html  =  StringEscapeUtils  .  escapeHtml  (  getWholeText  (  )  )  ;  if  (  parent  (  )  instanceof  Element  &&  !  (  (  Element  )  parent  (  )  )  .  preserveWhitespace  (  )  )  {  html  =  normaliseWhitespace  (  html  )  ;  }  [ATTENTION]        [METHOD]  outerHtml  [TYPE]  void  [PARAMETER]  StringBuilder  accum  [CLASS]  TextNode    [TYPE]  StringBuilder  accum  [TYPE]  String  TEXT_KEY  baseUri  html  text  [TYPE]  boolean  false  true  
[REPLACE]  indent  (  accum  )  ;	[BUGGY]  super  (  baseUri  )  ;  [CE]  call  to  super  must  be  first  statement  in  constructor  [CONTEXT]  void  outerHtml  (  StringBuilder  accum  )  {  String  html  =  StringEscapeUtils  .  escapeHtml  (  getWholeText  (  )  )  ;  if  (  parent  (  )  instanceof  Element  &&  !  (  (  Element  )  parent  (  )  )  .  preserveWhitespace  (  )  )  {  html  =  normaliseWhitespace  (  html  )  ;  }  if  (  !isBlank  (  )  &&  parentNode  instanceof  Element  &&  (  (  Element  )  parentNode  )  .  tag  (  )  .  canContainBlock  (  )  &&  siblingIndex  (  )    =  =  0  )  [ATTENTION]  super  (  baseUri  )    ;  accum  .  append  (  html  )  ;  }    [METHOD]  outerHtml  [TYPE]  void  [PARAMETER]  StringBuilder  accum  [CLASS]  TextNode    [TYPE]  StringBuilder  accum  [TYPE]  String  TEXT_KEY  baseUri  html  text  [TYPE]  boolean  false  true  
[REPLACE]  accum  .  append  (  html  )  ;	[BUGGY]  accum  .  append  (  TEXT_KEY  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  void  outerHtml  (  StringBuilder  accum  )  {  String  html  =  StringEscapeUtils  .  escapeHtml  (  getWholeText  (  )  )  ;  if  (  parent  (  )  instanceof  Element  &&  !  (  (  Element  )  parent  (  )  )  .  preserveWhitespace  (  )  )  {  html  =  normaliseWhitespace  (  html  )  ;  }  if  (  !isBlank  (  )  &&  parentNode  instanceof  Element  &&  (  (  Element  )  parentNode  )  .  tag  (  )  .  canContainBlock  (  )  &&  siblingIndex  (  )    =  =  0  )  indent  (  accum  )  ;  [ATTENTION]  accum  .  append  (  TEXT_KEY  )    ;  }    [METHOD]  outerHtml  [TYPE]  void  [PARAMETER]  StringBuilder  accum  [CLASS]  TextNode    [TYPE]  StringBuilder  accum  [TYPE]  String  TEXT_KEY  baseUri  html  text  [TYPE]  boolean  false  true  
[ADD]  accum  .  append  (  html  )  ;	[BUGGY]  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  void  outerHtml  (  StringBuilder  accum  )  {  String  html  =  StringEscapeUtils  .  escapeHtml  (  getWholeText  (  )  )  ;  if  (  parent  (  )  instanceof  Element  &&  !  (  (  Element  )  parent  (  )  )  .  preserveWhitespace  (  )  )  {  html  =  normaliseWhitespace  (  html  )  ;  }  if  (  !isBlank  (  )  &&  parentNode  instanceof  Element  &&  (  (  Element  )  parentNode  )  .  tag  (  )  .  canContainBlock  (  )  &&  siblingIndex  (  )    =  =  0  )  indent  (  accum  )  ;  [ATTENTION]  }    [METHOD]  outerHtml  [TYPE]  void  [PARAMETER]  StringBuilder  accum  [CLASS]  TextNode    [TYPE]  StringBuilder  accum  [TYPE]  String  TEXT_KEY  baseUri  html  text  [TYPE]  boolean  false  true  
[REPLACE]  return  outerHtml  (  )  ;	[BUGGY]  return  new  TextNode  (  text  ,  baseUri  )  ;  [CE]  cannot  find  symbol  text  [CONTEXT]  public  String  toString  (  )  {  [ATTENTION]  return  new  TextNode  (  text  ,  baseUri  )    ;  }    [METHOD]  toString  [TYPE]  String  [PARAMETER]  [CLASS]  TextNode    [TYPE]  String  TEXT_KEY  baseUri  html  text  [TYPE]  boolean  false  true  
[REPLACE]  String  text  =  StringEscapeUtils  .  unescapeHtml  (  encodedText  )  ;	[BUGGY]  String  text  =  StringEscapeUtils  .  escapeHtml  (  baseUri  )    ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  static  TextNode  createFromEncoded  (  String  encodedText  ,  String  baseUri  )  {  [ATTENTION]  String  text  =  StringEscapeUtils  .  escapeHtml  (  baseUri  )  ;  return  new  TextNode  (  text  ,  baseUri  )  ;  }    [METHOD]  createFromEncoded  [TYPE]  TextNode  [PARAMETER]  String  encodedText  String  baseUri  [CLASS]  TextNode    [TYPE]  String  TEXT_KEY  baseUri  encodedText  html  text  [TYPE]  boolean  false  true  
[REPLACE]  return  new  TextNode  (  text,  baseUri  )  ;	[BUGGY]  return  new  TextNode  (  encodedText  ,  baseUri  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  static  TextNode  createFromEncoded  (  String  encodedText  ,  String  baseUri  )  {  String  text  =  StringEscapeUtils  .  unescapeHtml  (  encodedText  )  ;  [ATTENTION]  return  new  TextNode  (  encodedText  ,  baseUri  )    ;  }    [METHOD]  createFromEncoded  [TYPE]  TextNode  [PARAMETER]  String  encodedText  String  baseUri  [CLASS]  TextNode    [TYPE]  String  TEXT_KEY  baseUri  encodedText  html  text  [TYPE]  boolean  false  true  
[REPLACE]  text  =  text  .  replaceAll  (   "\\s{2,}|  (  \\r\\n|\\r|\\n  )   ",   "   "  )  ;	[BUGGY]  text  =    encodedText  .  replaceAll  (   "\\s{2  ,  }|  (  \\r\\n|\\r|\\n  )   "  ,   "   "  )  ;  [CE]  cannot  find  symbol  encodedText  [CONTEXT]  static  String  normaliseWhitespace  (  String  text  )  {  [ATTENTION]  text  =  encodedText  .  replaceAll  (   "\\s{2  ,  }|  (  \\r\\n|\\r|\\n  )   "  ,   "   "  )    ;  return  text  ;  }    [METHOD]  normaliseWhitespace  [TYPE]  String  [PARAMETER]  String  text  [CLASS]  TextNode    [TYPE]  String  TEXT_KEY  baseUri  encodedText  html  text  [TYPE]  boolean  false  true  
[REPLACE]  return  text;	[BUGGY]  return  encodedText  ;  [CE]  cannot  find  symbol  encodedText  [CONTEXT]  static  String  normaliseWhitespace  (  String  text  )  {  text  =  text  .  replaceAll  (   "\\s{2  ,  }|  (  \\r\\n|\\r|\\n  )   "  ,   "   "  )  ;  //  more  than  one  space  ,  and  newlines  to   "   "  [ATTENTION]  return  encodedText  ;  }    [METHOD]  normaliseWhitespace  [TYPE]  String  [PARAMETER]  String  text  [CLASS]  TextNode    [TYPE]  String  TEXT_KEY  baseUri  encodedText  html  text  [TYPE]  boolean  false  true  
[REPLACE]  if  (  sb  .  length  (  )  ==  0  )  return  false;	[BUGGY]  if  (  sb  .  length  (  )  -  3  =  =  0  )  return  false  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  static  boolean  lastCharIsWhitespace  (  StringBuilder  sb  )  {  [ATTENTION]  if  (  sb  .  length  (  )  -  3  =  =  0  )  return  false  ;    String  lastChar  =  sb  .  substring  (  sb  .  length  (  )  -1  ,  sb  .  length  (  )  )  ;  Validate  .  isTrue  (  lastChar  .  length  (  )    =  =  1  )  ;  //  todo:  remove  check  return  lastChar  .  equals  (   "   "  )  ;  }    [METHOD]  lastCharIsWhitespace  [TYPE]  boolean  [PARAMETER]  StringBuilder  sb  [CLASS]  TextNode    [TYPE]  StringBuilder  sb  [TYPE]  String  TEXT_KEY  baseUri  encodedText  html  lastChar  text  [TYPE]  boolean  false  true  
[REPLACE]  return  false;	[BUGGY]  return  true  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  static  boolean  lastCharIsWhitespace  (  StringBuilder  sb  )  {  if  (  sb  .  length  (  )    =  =  0  )  [ATTENTION]  return  true  ;  String  lastChar  =  sb  .  substring  (  sb  .  length  (  )  -1  ,  sb  .  length  (  )  )  ;  Validate  .  isTrue  (  lastChar  .  length  (  )    =  =  1  )  ;  //  todo:  remove  check  return  lastChar  .  equals  (   "   "  )  ;  }    [METHOD]  lastCharIsWhitespace  [TYPE]  boolean  [PARAMETER]  StringBuilder  sb  [CLASS]  TextNode    [TYPE]  StringBuilder  sb  [TYPE]  String  TEXT_KEY  baseUri  encodedText  html  lastChar  text  [TYPE]  boolean  false  true  
[REPLACE]  String  lastChar  =  sb  .  substring  (  sb  .  length  (  )  -1,  sb  .  length  (  )  )  ;	[BUGGY]  String  lastChar  =  sb  .  substring  (  sb  .  size  (  )  -1  ,  sb  .  size  (  )  )  ;  [CE]  cannot  find  symbol  [CONTEXT]  static  boolean  lastCharIsWhitespace  (  StringBuilder  sb  )  {  if  (  sb  .  length  (  )    =  =  0  )  return  false  ;  [ATTENTION]  String  lastChar  =  sb  .  substring  (  sb  .  size  (  )  -1  ,  sb  .  size  (  )  )    ;  Validate  .  isTrue  (  lastChar  .  length  (  )    =  =  1  )  ;  //  todo:  remove  check  return  lastChar  .  equals  (   "   "  )  ;  }    [METHOD]  lastCharIsWhitespace  [TYPE]  boolean  [PARAMETER]  StringBuilder  sb  [CLASS]  TextNode    [TYPE]  StringBuilder  sb  [TYPE]  String  TEXT_KEY  baseUri  encodedText  html  lastChar  text  [TYPE]  boolean  false  true  
[REPLACE]  Validate  .  isTrue  (  lastChar  .  length  (  )  ==  1  )  ;	[BUGGY]  Validate  .  isTrue  (  lastChar  .  substring  (  null  ,  null  )    +  4  =  =  1  )  ;  [CE]  no  suitable  method  found  for  substring(<null>  ,  <null>)  [CONTEXT]  static  boolean  lastCharIsWhitespace  (  StringBuilder  sb  )  {  if  (  sb  .  length  (  )    =  =  0  )  return  false  ;  String  lastChar  =  sb  .  substring  (  sb  .  length  (  )  -1  ,  sb  .  length  (  )  )  ;  [ATTENTION]  Validate  .  isTrue  (  lastChar  .  substring  (  null  ,  null  )  +  4  =  =  1  )    ;  return  lastChar  .  equals  (   "   "  )  ;  }    [METHOD]  lastCharIsWhitespace  [TYPE]  boolean  [PARAMETER]  StringBuilder  sb  [CLASS]  TextNode    [TYPE]  StringBuilder  sb  [TYPE]  String  TEXT_KEY  baseUri  encodedText  html  lastChar  text  [TYPE]  boolean  false  true  
[REPLACE]  Validate  .  isTrue  (  lastChar  .  length  (  )  ==  1  )  ;	[BUGGY]  Validate  .  isTrue  (  text  .  length  (  )    =  =  1  )  ;  [CE]  cannot  find  symbol  text  [CONTEXT]  static  boolean  lastCharIsWhitespace  (  StringBuilder  sb  )  {  if  (  sb  .  length  (  )    =  =  0  )  return  false  ;  String  lastChar  =  sb  .  substring  (  sb  .  length  (  )  -1  ,  sb  .  length  (  )  )  ;  [ATTENTION]  Validate  .  isTrue  (  text  .  length  (  )  =  =  1  )    ;  return  lastChar  .  equals  (   "   "  )  ;  }    [METHOD]  lastCharIsWhitespace  [TYPE]  boolean  [PARAMETER]  StringBuilder  sb  [CLASS]  TextNode    [TYPE]  StringBuilder  sb  [TYPE]  String  TEXT_KEY  baseUri  encodedText  html  lastChar  text  [TYPE]  boolean  false  true  
[ADD]  Validate  .  isTrue  (  lastChar  .  length  (  )  ==  1  )  ;	[BUGGY]  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  static  boolean  lastCharIsWhitespace  (  StringBuilder  sb  )  {  if  (  sb  .  length  (  )    =  =  0  )  return  false  ;  String  lastChar  =  sb  .  substring  (  sb  .  length  (  )  -1  ,  sb  .  length  (  )  )  ;  [ATTENTION]  return  lastChar  .  equals  (   "   "  )  ;  }    [METHOD]  lastCharIsWhitespace  [TYPE]  boolean  [PARAMETER]  StringBuilder  sb  [CLASS]  TextNode    [TYPE]  StringBuilder  sb  [TYPE]  String  TEXT_KEY  baseUri  encodedText  html  lastChar  text  [TYPE]  boolean  false  true  
[REPLACE]  return  lastChar  .  equals  (   "   "  )  ;	[BUGGY]  return  text  .  equals  (   "   "  )  ;  [CE]  cannot  find  symbol  text  [CONTEXT]  static  boolean  lastCharIsWhitespace  (  StringBuilder  sb  )  {  if  (  sb  .  length  (  )    =  =  0  )  return  false  ;  String  lastChar  =  sb  .  substring  (  sb  .  length  (  )  -1  ,  sb  .  length  (  )  )  ;  Validate  .  isTrue  (  lastChar  .  length  (  )    =  =  1  )  ;  //  todo:  remove  check  [ATTENTION]  return  text  .  equals  (   "   "  )    ;  }    [METHOD]  lastCharIsWhitespace  [TYPE]  boolean  [PARAMETER]  StringBuilder  sb  [CLASS]  TextNode    [TYPE]  StringBuilder  sb  [TYPE]  String  TEXT_KEY  baseUri  encodedText  html  lastChar  text  [TYPE]  boolean  false  true  
[REPLACE]  private  String  key;	[BUGGY]  private  boolean  key  ;  [CE]  incompatible  types  [CONTEXT]      [CLASS]  Attribute  
[REPLACE]  Validate  .  notEmpty  (  key  )  ;	[BUGGY]  Validate  .  notNull  (  key  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  Attribute  (  String  key  ,  String  value  )  {  [ATTENTION]  Validate  .  notNull  (  key  )    ;  Validate  .  notNull  (  value  )  ;  this  .  key  =  key  .  trim  (  )  .  toLowerCase  (  )  ;  this  .  value  =  value  ;  }    [METHOD]  <init>  [TYPE]  String)  [PARAMETER]  String  key  String  value  [CLASS]  Attribute    [TYPE]  String  key  value  [TYPE]  boolean  false  true  
[ADD]  Validate  .  notEmpty  (  key  )  ;	[BUGGY]  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  Attribute  (  String  key  ,  String  value  )  {  [ATTENTION]  Validate  .  notNull  (  value  )  ;  this  .  key  =  key  .  trim  (  )  .  toLowerCase  (  )  ;  this  .  value  =  value  ;  }    [METHOD]  <init>  [TYPE]  String)  [PARAMETER]  String  key  String  value  [CLASS]  Attribute    [TYPE]  String  key  value  [TYPE]  boolean  false  true  
[REPLACE]  Validate  .  notNull  (  value  )  ;	[BUGGY]  Validate  .  notEmpty  (  value  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  Attribute  (  String  key  ,  String  value  )  {  Validate  .  notEmpty  (  key  )  ;  [ATTENTION]  Validate  .  notEmpty  (  value  )    ;  this  .  key  =  key  .  trim  (  )  .  toLowerCase  (  )  ;  this  .  value  =  value  ;  }    [METHOD]  <init>  [TYPE]  String)  [PARAMETER]  String  key  String  value  [CLASS]  Attribute    [TYPE]  String  key  value  [TYPE]  boolean  false  true  
[ADD]  Validate  .  notNull  (  value  )  ;  this  .  key  =  key  .  trim  (  )    .  toLowerCase  (  )  ;	[BUGGY]  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  Attribute  (  String  key  ,  String  value  )  {  Validate  .  notEmpty  (  key  )  ;  [ATTENTION]    this  .  value  =  value  ;  }    [METHOD]  <init>  [TYPE]  String)  [PARAMETER]  String  key  String  value  [CLASS]  Attribute    [TYPE]  String  key  value  [TYPE]  boolean  false  true  
[REPLACE]  this  .  key  =  key  .  trim  (  )    .  toLowerCase  (  )  ;	[BUGGY]  this  .  key  =    null  .  trim  (  )  .  toLowerCase  (  )  ;  [CE]  <null>  cannot  be  dereferenced  [CONTEXT]  public  Attribute  (  String  key  ,  String  value  )  {  Validate  .  notEmpty  (  key  )  ;  Validate  .  notNull  (  value  )  ;  [ATTENTION]  this  .  key  =  null  .  trim  (  )    .  toLowerCase  (  )    ;  this  .  value  =  value  ;  }    [METHOD]  <init>  [TYPE]  String)  [PARAMETER]  String  key  String  value  [CLASS]  Attribute    [TYPE]  String  key  value  [TYPE]  boolean  false  true  
[REPLACE]  this  .  value  =  value;	[BUGGY]  this  .  value  =    null  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  Attribute  (  String  key  ,  String  value  )  {  Validate  .  notEmpty  (  key  )  ;  Validate  .  notNull  (  value  )  ;  this  .  key  =  key  .  trim  (  )  .  toLowerCase  (  )  ;  [ATTENTION]  this  .  value  =  null  ;  }    [METHOD]  <init>  [TYPE]  String)  [PARAMETER]  String  key  String  value  [CLASS]  Attribute    [TYPE]  String  key  value  [TYPE]  boolean  false  true  
[REPLACE]  return  key;	[BUGGY]  return  value  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  String  getKey  (  )  {  [ATTENTION]  return  value  ;  }    [METHOD]  getKey  [TYPE]  String  [PARAMETER]  [CLASS]  Attribute    [TYPE]  String  key  value  [TYPE]  boolean  false  true  
[REPLACE]  Validate  .  notEmpty  (  key  )  ;	[BUGGY]  key    ;  [CE]  not  a  statement  [CONTEXT]  public  void  setKey  (  String  key  )  {  [ATTENTION]  key  ;  this  .  key  =  key  .  trim  (  )  .  toLowerCase  (  )  ;  }    [METHOD]  setKey  [TYPE]  void  [PARAMETER]  String  key  [CLASS]  Attribute    [TYPE]  String  key  value  [TYPE]  boolean  false  true  
[REPLACE]  this  .  key  =  key  .  trim  (  )    .  toLowerCase  (  )  ;	[BUGGY]  this  .  key  =    null  .  trim  (  )  .  toLowerCase  (  )  ;  [CE]  <null>  cannot  be  dereferenced  [CONTEXT]  public  void  setKey  (  String  key  )  {  Validate  .  notEmpty  (  key  )  ;  [ATTENTION]  this  .  key  =  null  .  trim  (  )    .  toLowerCase  (  )    ;  }    [METHOD]  setKey  [TYPE]  void  [PARAMETER]  String  key  [CLASS]  Attribute    [TYPE]  String  key  value  [TYPE]  boolean  false  true  
[ADD]  this  .  key  =  key  .  trim  (  )    .  toLowerCase  (  )  ;	[BUGGY]  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  void  setKey  (  String  key  )  {  Validate  .  notEmpty  (  key  )  ;  [ATTENTION]  }    [METHOD]  setKey  [TYPE]  void  [PARAMETER]  String  key  [CLASS]  Attribute    [TYPE]  String  key  value  [TYPE]  boolean  false  true  
[REPLACE]  return  value;	[BUGGY]  return  key  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  String  getValue  (  )  {  [ATTENTION]  return  key  ;  }    [METHOD]  getValue  [TYPE]  String  [PARAMETER]  [CLASS]  Attribute    [TYPE]  String  key  value  [TYPE]  boolean  false  true  
[REPLACE]  Validate  .  notNull  (  value  )  ;	[BUGGY]  Validate  .  notEmpty  (  value  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  void  setValue  (  String  value  )  {  [ATTENTION]  Validate  .  notEmpty  (  value  )    ;  this  .  value  =  value  ;  }    [METHOD]  setValue  [TYPE]  void  [PARAMETER]  String  value  [CLASS]  Attribute    [TYPE]  String  key  value  [TYPE]  boolean  false  true  
[ADD]  Validate  .  notNull  (  value  )  ;	[BUGGY]  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  void  setValue  (  String  value  )  {  [ATTENTION]  this  .  value  =  value  ;  }    [METHOD]  setValue  [TYPE]  void  [PARAMETER]  String  value  [CLASS]  Attribute    [TYPE]  String  key  value  [TYPE]  boolean  false  true  
[REPLACE]  this  .  value  =  value;	[BUGGY]  this  .  value  =    null  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  void  setValue  (  String  value  )  {  Validate  .  notNull  (  value  )  ;  [ATTENTION]  this  .  value  =  null  ;  }    [METHOD]  setValue  [TYPE]  void  [PARAMETER]  String  value  [CLASS]  Attribute    [TYPE]  String  key  value  [TYPE]  boolean  false  true  
[REPLACE]  return  String  .  format  (   "%s=\ "%s\ " ",  key,  StringEscapeUtils  .  escapeHtml  (  value  )  )  ;	[BUGGY]  return  String  .  format  (   "%s  =  \ "%s\ " "  ,  key  ,  StringEscapeUtils  .  unescapeHtml  (  value  )  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  String  html  (  )  {  [ATTENTION]  return  String  .  format  (   "%s  =  \ "%s\ " "  ,  key  ,  StringEscapeUtils  .  unescapeHtml  (  value  )  )    ;  }    [METHOD]  html  [TYPE]  String  [PARAMETER]  [CLASS]  Attribute    [TYPE]  String  key  value  [TYPE]  boolean  false  true  
[REPLACE]  return  html  (  )  ;	[BUGGY]  return  key  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  String  toString  (  )  {  [ATTENTION]  return  key  ;  }    [METHOD]  toString  [TYPE]  String  [PARAMETER]  [CLASS]  Attribute    [TYPE]  String  key  value  [TYPE]  boolean  false  true  
[REPLACE]  String  value  =  StringEscapeUtils  .  unescapeHtml  (  encodedValue  )  ;	[BUGGY]  String  value  =  StringEscapeUtils  .  escapeHtml  (  value  )  ;  [CE]  variable  value  might  not  have  been  initialized  [CONTEXT]  public  static  Attribute  createFromEncoded  (  String  unencodedKey  ,  String  encodedValue  )  {  [ATTENTION]  String  value  =  StringEscapeUtils  .  escapeHtml  (  value  )    ;  return  new  Attribute  (  unencodedKey  ,  value  )  ;  }    [METHOD]  createFromEncoded  [TYPE]  Attribute  [PARAMETER]  String  unencodedKey  String  encodedValue  [CLASS]  Attribute    [TYPE]  String  encodedValue  key  unencodedKey  value  [TYPE]  boolean  false  true  
[REPLACE]  return  new  Attribute  (  unencodedKey,  value  )  ;	[BUGGY]  return  new  Attribute  (  unencodedKey  ,  encodedValue  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  static  Attribute  createFromEncoded  (  String  unencodedKey  ,  String  encodedValue  )  {  String  value  =  StringEscapeUtils  .  unescapeHtml  (  encodedValue  )  ;  [ATTENTION]  return  new  Attribute  (  unencodedKey  ,  encodedValue  )    ;  }    [METHOD]  createFromEncoded  [TYPE]  Attribute  [PARAMETER]  String  unencodedKey  String  encodedValue  [CLASS]  Attribute    [TYPE]  String  encodedValue  key  unencodedKey  value  [TYPE]  boolean  false  true  
[REPLACE]  if  (  this  ==  o  )  return  true;	[BUGGY]  if  (  this  ||  o  )  return  true  ;  [CE]  bad  operand  types  for  binary  operator  '||'  [CONTEXT]  public  boolean  equals  (  Object  o  )  {  [ATTENTION]  if  (  this||o  )  return  true  ;  if  (  !  (  o  instanceof  Attribute  )  )  return  false  ;    Attribute  attribute  =    (  Attribute  )  o  ;    if  (  key  !  =  null  ?  !key  .  equals  (  attribute  .  key  )  :  attribute  .  key  !  =  null  )  return  false  ;  if  (  value  !  =  null  ?  !value  .  equals  (  attribute  .  value  )  :  attribute  .  value  !  =  null  )  return  false  ;    return  true  ;  }    [METHOD]  equals  [TYPE]  boolean  [PARAMETER]  Object  o  [CLASS]  Attribute    [TYPE]  Object  o  [TYPE]  String  encodedValue  key  unencodedKey  value  [TYPE]  boolean  false  true  [TYPE]  Attribute  attribute  
[REPLACE]  if  (  this  ==  o  )  return  true;	[BUGGY]  if  (  this  =  =  o  )  return  false  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  boolean  equals  (  Object  o  )  {  [ATTENTION]  if  (  this  =  =  o  )  return  false  ;  if  (  !  (  o  instanceof  Attribute  )  )  return  false  ;    Attribute  attribute  =    (  Attribute  )  o  ;    if  (  key  !  =  null  ?  !key  .  equals  (  attribute  .  key  )  :  attribute  .  key  !  =  null  )  return  false  ;  if  (  value  !  =  null  ?  !value  .  equals  (  attribute  .  value  )  :  attribute  .  value  !  =  null  )  return  false  ;    return  true  ;  }    [METHOD]  equals  [TYPE]  boolean  [PARAMETER]  Object  o  [CLASS]  Attribute    [TYPE]  Object  o  [TYPE]  String  encodedValue  key  unencodedKey  value  [TYPE]  boolean  false  true  [TYPE]  Attribute  attribute  
[REPLACE]  if  (  !  (  o  instanceof  Attribute  )  )  return  false;	[BUGGY]  if  (  !  !  (  o  instanceof  Attribute  )  )  return  false  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  boolean  equals  (  Object  o  )  {  if  (  this  =  =  o  )  return  true  ;  [ATTENTION]  if  (  !  !  (  o  instanceof  Attribute  )  )  return  false  ;    Attribute  attribute  =    (  Attribute  )  o  ;    if  (  key  !  =  null  ?  !key  .  equals  (  attribute  .  key  )  :  attribute  .  key  !  =  null  )  return  false  ;  if  (  value  !  =  null  ?  !value  .  equals  (  attribute  .  value  )  :  attribute  .  value  !  =  null  )  return  false  ;    return  true  ;  }    [METHOD]  equals  [TYPE]  boolean  [PARAMETER]  Object  o  [CLASS]  Attribute    [TYPE]  Object  o  [TYPE]  String  encodedValue  key  unencodedKey  value  [TYPE]  boolean  false  true  [TYPE]  Attribute  attribute  
[REPLACE]  if  (  !  (  o  instanceof  Attribute  )  )  return  false;	[BUGGY]  if  (  !  (  o  instanceof  Attribute  )  )  return  true  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  boolean  equals  (  Object  o  )  {  if  (  this  =  =  o  )  return  true  ;  [ATTENTION]  if  (  !  (  o  instanceof  Attribute  )  )  return  true  ;    Attribute  attribute  =    (  Attribute  )  o  ;    if  (  key  !  =  null  ?  !key  .  equals  (  attribute  .  key  )  :  attribute  .  key  !  =  null  )  return  false  ;  if  (  value  !  =  null  ?  !value  .  equals  (  attribute  .  value  )  :  attribute  .  value  !  =  null  )  return  false  ;    return  true  ;  }    [METHOD]  equals  [TYPE]  boolean  [PARAMETER]  Object  o  [CLASS]  Attribute    [TYPE]  Object  o  [TYPE]  String  encodedValue  key  unencodedKey  value  [TYPE]  boolean  false  true  [TYPE]  Attribute  attribute  
[REPLACE]  Attribute  attribute  =  (  Attribute  )  o;	[BUGGY]  String  value  =  StringEscapeUtils  .  unescapeHtml  (  encodedValue  )  ;  [CE]  cannot  find  symbol  encodedValue  [CONTEXT]  public  boolean  equals  (  Object  o  )  {  if  (  this  =  =  o  )  return  true  ;  if  (  !  (  o  instanceof  Attribute  )  )  return  false  ;    [ATTENTION]  String  value  =  StringEscapeUtils  .  unescapeHtml  (  encodedValue  )    ;    if  (  key  !  =  null  ?  !key  .  equals  (  attribute  .  key  )  :  attribute  .  key  !  =  null  )  return  false  ;  if  (  value  !  =  null  ?  !value  .  equals  (  attribute  .  value  )  :  attribute  .  value  !  =  null  )  return  false  ;    return  true  ;  }    [METHOD]  equals  [TYPE]  boolean  [PARAMETER]  Object  o  [CLASS]  Attribute    [TYPE]  Object  o  [TYPE]  String  encodedValue  key  unencodedKey  value  [TYPE]  boolean  false  true  [TYPE]  Attribute  attribute  
[REPLACE]  if  (  key  !=  null  ?  !key  .  equals  (  attribute  .  key  )  :  attribute  .  key  !=  null  )  return  false;	[BUGGY]  if  (  key  !  =    !key  .  equals  (  attribute  .  key  )    ;  [CE]  ')'  expected  [CONTEXT]  public  boolean  equals  (  Object  o  )  {  if  (  this  =  =  o  )  return  true  ;  if  (  !  (  o  instanceof  Attribute  )  )  return  false  ;    Attribute  attribute  =    (  Attribute  )  o  ;    [ATTENTION]  if  (  key  !  =  !key  .  equals  (  attribute  .  key  )  ;  if  (  value  !  =  null  ?  !value  .  equals  (  attribute  .  value  )  :  attribute  .  value  !  =  null  )  return  false  ;    return  true  ;  }    [METHOD]  equals  [TYPE]  boolean  [PARAMETER]  Object  o  [CLASS]  Attribute    [TYPE]  Object  o  [TYPE]  String  encodedValue  key  unencodedKey  value  [TYPE]  boolean  false  true  [TYPE]  Attribute  attribute  
[ADD]  if  (  key  !=  null  ?  !key  .  equals  (  attribute  .  key  )  :  attribute  .  key  !=  null  )  return  false;  if  (  value  !=  null  ?  !value  .  equals  (  attribute  .  value  )  :  attribute  .  value  !=  null  )  return  false;  return  true;  }	[BUGGY]  if  (  value  !  =  null  ?  !value  .  equals  (  attribute  .  value  )  :  attribute  .  value  !  =  null  )  return  false  ;  return  true  ;  [CE]  '  ;  '  expected  [CONTEXT]  public  boolean  equals  (  Object  o  )  {  if  (  this  =  =  o  )  return  true  ;  if  (  !  (  o  instanceof  Attribute  )  )  return  false  ;    Attribute  attribute  =    (  Attribute  )  o  ;    [ATTENTION]  if  (  value  !  =  null  ?  !value  .  equals  (  attribute  .  value  )  :  attribute  .  value  !  =  null  )  return  false  ;  return  true  ;          [METHOD]  equals  [TYPE]  boolean  [PARAMETER]  Object  o  [CLASS]  Attribute    [TYPE]  Object  o  [TYPE]  String  encodedValue  key  unencodedKey  value  [TYPE]  boolean  false  true  [TYPE]  Attribute  attribute  
[REPLACE]  if  (  key  !=  null  ?  !key  .  equals  (  attribute  .  key  )  :  attribute  .  key  !=  null  )  return  false;	[BUGGY]  if  (  key  !  =  null  ?  !key  .  equals  (  attribute  .  key  )  :  attribute  .  key  !  =  null  )  return  true  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  boolean  equals  (  Object  o  )  {  if  (  this  =  =  o  )  return  true  ;  if  (  !  (  o  instanceof  Attribute  )  )  return  false  ;    Attribute  attribute  =    (  Attribute  )  o  ;    [ATTENTION]  if  (  key  !  =  null  ?  !key  .  equals  (  attribute  .  key  )  :  attribute  .  key  !  =  null  )  return  true  ;  if  (  value  !  =  null  ?  !value  .  equals  (  attribute  .  value  )  :  attribute  .  value  !  =  null  )  return  false  ;    return  true  ;  }    [METHOD]  equals  [TYPE]  boolean  [PARAMETER]  Object  o  [CLASS]  Attribute    [TYPE]  Object  o  [TYPE]  String  encodedValue  key  unencodedKey  value  [TYPE]  boolean  false  true  [TYPE]  Attribute  attribute  
[REPLACE]  if  (  value  !=  null  ?  !value  .  equals  (  attribute  .  value  )  :  attribute  .  value  !=  null  )  return  false;	[BUGGY]  if  (  value  !  =    attribute  .  value  =  =  this  )  return  false  ;  [CE]  ')'  expected  [CONTEXT]  public  boolean  equals  (  Object  o  )  {  if  (  this  =  =  o  )  return  true  ;  if  (  !  (  o  instanceof  Attribute  )  )  return  false  ;    Attribute  attribute  =    (  Attribute  )  o  ;    if  (  key  !  =  null  ?  !key  .  equals  (  attribute  .  key  )  :  attribute  .  key  !  =  null  )  return  false  ;  [ATTENTION]  if  (  value  !  =  attribute  .  value  =  =  this  )  return  false  ;    return  true  ;  }    [METHOD]  equals  [TYPE]  boolean  [PARAMETER]  Object  o  [CLASS]  Attribute    [TYPE]  Object  o  [TYPE]  String  encodedValue  key  unencodedKey  value  [TYPE]  boolean  false  true  [TYPE]  Attribute  attribute  
[REPLACE]  if  (  value  !=  null  ?  !value  .  equals  (  attribute  .  value  )  :  attribute  .  value  !=  null  )  return  false;	[BUGGY]  if  (  value  !  =  null  ?  !value  .  equals  (  attribute  .  value  )  :  attribute  .  value  !  =  null  )  return  true  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  boolean  equals  (  Object  o  )  {  if  (  this  =  =  o  )  return  true  ;  if  (  !  (  o  instanceof  Attribute  )  )  return  false  ;    Attribute  attribute  =    (  Attribute  )  o  ;    if  (  key  !  =  null  ?  !key  .  equals  (  attribute  .  key  )  :  attribute  .  key  !  =  null  )  return  false  ;  [ATTENTION]  if  (  value  !  =  null  ?  !value  .  equals  (  attribute  .  value  )  :  attribute  .  value  !  =  null  )  return  true  ;    return  true  ;  }    [METHOD]  equals  [TYPE]  boolean  [PARAMETER]  Object  o  [CLASS]  Attribute    [TYPE]  Object  o  [TYPE]  String  encodedValue  key  unencodedKey  value  [TYPE]  boolean  false  true  [TYPE]  Attribute  attribute  
[REPLACE]  return  true;	[BUGGY]  return  false  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  boolean  equals  (  Object  o  )  {  if  (  this  =  =  o  )  return  true  ;  if  (  !  (  o  instanceof  Attribute  )  )  return  false  ;    Attribute  attribute  =    (  Attribute  )  o  ;    if  (  key  !  =  null  ?  !key  .  equals  (  attribute  .  key  )  :  attribute  .  key  !  =  null  )  return  false  ;  if  (  value  !  =  null  ?  !value  .  equals  (  attribute  .  value  )  :  attribute  .  value  !  =  null  )  return  false  ;    [ATTENTION]  return  false  ;  }    [METHOD]  equals  [TYPE]  boolean  [PARAMETER]  Object  o  [CLASS]  Attribute    [TYPE]  Object  o  [TYPE]  String  encodedValue  key  unencodedKey  value  [TYPE]  boolean  false  true  [TYPE]  Attribute  attribute  
[REPLACE]  int  result  =  key  !=  null  ?  key  .  hashCode  (  )  :  0;	[BUGGY]  int  result    =    key  .  hashCode  (  )    ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  int  hashCode  (  )  {  [ATTENTION]  int  result  =  key  .  hashCode  (  )  ;  result  =  31  *  result  +  (  value  !  =  null  ?  value  .  hashCode  (  )  :  0  )  ;  return  result  ;  }    [METHOD]  hashCode  [TYPE]  int  [PARAMETER]  [CLASS]  Attribute    [TYPE]  int  result  [TYPE]  String  encodedValue  key  unencodedKey  value  [TYPE]  boolean  false  true  
[REPLACE]  result  =  31  *  result  +  (  value  !=  null  ?  value  .  hashCode  (  )  :  0  )  ;	[BUGGY]  result    =    0  )  ;  [CE]  '  ;  '  expected  [CONTEXT]  public  int  hashCode  (  )  {  int  result  =  key  !  =  null  ?  key  .  hashCode  (  )  :  0  ;  [ATTENTION]  result  =  0  )    ;  return  result  ;  }    [METHOD]  hashCode  [TYPE]  int  [PARAMETER]  [CLASS]  Attribute    [TYPE]  int  result  [TYPE]  String  encodedValue  key  unencodedKey  value  [TYPE]  boolean  false  true  
[REPLACE]  return  result;	[BUGGY]  return  key  ;  [CE]  incompatible  types  [CONTEXT]  public  int  hashCode  (  )  {  int  result  =  key  !  =  null  ?  key  .  hashCode  (  )  :  0  ;  result  =  31  *  result  +  (  value  !  =  null  ?  value  .  hashCode  (  )  :  0  )  ;  [ATTENTION]  return  key  ;  }    [METHOD]  hashCode  [TYPE]  int  [PARAMETER]  [CLASS]  Attribute    [TYPE]  int  result  [TYPE]  String  encodedValue  key  unencodedKey  value  [TYPE]  boolean  false  true  
[REPLACE]  return  Parser  .  parse  (  html,  baseUri  )  ;	[BUGGY]  return  Parser  .  parse  (  baseUri  )    ;  [CE]  no  suitable  method  found  for  parse(String)  [CONTEXT]  public  static  Document  parse  (  String  html  ,  String  baseUri  )  {  [ATTENTION]  return  Parser  .  parse  (  baseUri  )  ;  }    [METHOD]  parse  [TYPE]  Document  [PARAMETER]  String  html  String  baseUri  [CLASS]  Jsoup    [TYPE]  boolean  false  true  [TYPE]  String  baseUri  html  
[REPLACE]  return  Parser  .  parse  (  html,   " "  )  ;	[BUGGY]  return  Parser  .  parse  (  html  ,  baseUri  )  ;  [CE]  cannot  find  symbol  baseUri  [CONTEXT]  public  static  Document  parse  (  String  html  )  {  [ATTENTION]  return  Parser  .  parse  (  html  ,  baseUri  )    ;  }    [METHOD]  parse  [TYPE]  Document  [PARAMETER]  String  html  [CLASS]  Jsoup    [TYPE]  boolean  false  true  [TYPE]  String  html  
[REPLACE]  String  html  =  DataUtil  .  load  (  url,  timeoutMillis  )  ;	[BUGGY]  String  html  =  DataUtil  .  load  (  in  ,  charsetName  )  ;  [CE]  cannot  find  symbol  in  [CONTEXT]  public  static  Document  parse  (  URL  url  ,  int  timeoutMillis  )  throws  IOException  {  [ATTENTION]  String  html  =  DataUtil  .  load  (  in  ,  charsetName  )    ;  return  parse  (  html  ,  url  .  toExternalForm  (  )  )  ;  }    [METHOD]  parse  [TYPE]  Document  [PARAMETER]  URL  url  int  timeoutMillis  [CLASS]  Jsoup    [TYPE]  boolean  false  true  [TYPE]  String  html  [TYPE]  URL  url  [TYPE]  int  timeoutMillis  
[ADD]  String  html  =  DataUtil  .  load  (  url,  timeoutMillis  )  ;  return  parse  (  html,  url  .  toExternalForm  (  )  )  ;	[BUGGY]  [CE]  missing  return  statement  [CONTEXT]  public  static  Document  parse  (  URL  url  ,  int  timeoutMillis  )  throws  IOException  {  [ATTENTION]    }    [METHOD]  parse  [TYPE]  Document  [PARAMETER]  URL  url  int  timeoutMillis  [CLASS]  Jsoup    [TYPE]  boolean  false  true  [TYPE]  String  html  [TYPE]  URL  url  [TYPE]  int  timeoutMillis  
[REPLACE]  return  parse  (  html,  url  .  toExternalForm  (  )  )  ;	[BUGGY]  return  cleaner  .  isValid  (  dirty  )  ;  [CE]  cannot  find  symbol  dirty  [CONTEXT]  public  static  Document  parse  (  URL  url  ,  int  timeoutMillis  )  throws  IOException  {  String  html  =  DataUtil  .  load  (  url  ,  timeoutMillis  )  ;  [ATTENTION]  return  cleaner  .  isValid  (  dirty  )    ;  }    [METHOD]  parse  [TYPE]  Document  [PARAMETER]  URL  url  int  timeoutMillis  [CLASS]  Jsoup    [TYPE]  boolean  false  true  [TYPE]  String  html  [TYPE]  URL  url  [TYPE]  int  timeoutMillis  
[REPLACE]  String  html  =  DataUtil  .  load  (  in,  charsetName  )  ;	[BUGGY]  String  html  =  DataUtil  .  load  (  in  ,  html  )  ;  [CE]  variable  html  might  not  have  been  initialized  [CONTEXT]  public  static  Document  parse  (  File  in  ,  String  charsetName  ,  String  baseUri  )  throws  IOException  {  [ATTENTION]  String  html  =  DataUtil  .  load  (  in  ,  html  )    ;  return  parse  (  html  ,  baseUri  )  ;  }    [METHOD]  parse  [TYPE]  Document  [PARAMETER]  File  in  String  charsetName  String  baseUri  [CLASS]  Jsoup    [TYPE]  boolean  false  true  [TYPE]  String  baseUri  charsetName  html  [TYPE]  File  in  
[REPLACE]  return  parse  (  html,  baseUri  )  ;	[BUGGY]  return  parse  (  charsetName  ,  baseUri  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  static  Document  parse  (  File  in  ,  String  charsetName  ,  String  baseUri  )  throws  IOException  {  String  html  =  DataUtil  .  load  (  in  ,  charsetName  )  ;  [ATTENTION]  return  parse  (  charsetName  ,  baseUri  )    ;  }    [METHOD]  parse  [TYPE]  Document  [PARAMETER]  File  in  String  charsetName  String  baseUri  [CLASS]  Jsoup    [TYPE]  boolean  false  true  [TYPE]  String  baseUri  charsetName  html  [TYPE]  File  in  
[REPLACE]  String  html  =  DataUtil  .  load  (  in,  charsetName  )  ;	[BUGGY]  String  html  =  DataUtil  .  load  (  url  ,  timeoutMillis  )  ;  [CE]  cannot  find  symbol  url  [CONTEXT]  public  static  Document  parse  (  File  in  ,  String  charsetName  )  throws  IOException  {  [ATTENTION]  String  html  =  DataUtil  .  load  (  url  ,  timeoutMillis  )    ;  return  parse  (  html  ,  in  .  getAbsolutePath  (  )  )  ;  }    [METHOD]  parse  [TYPE]  Document  [PARAMETER]  File  in  String  charsetName  [CLASS]  Jsoup    [TYPE]  boolean  false  true  [TYPE]  String  charsetName  html  [TYPE]  File  in  
[REPLACE]  return  parse  (  html,  in  .  getAbsolutePath  (  )  )  ;	[BUGGY]  return  cleaner  .  isValid  (  dirty  )  ;  [CE]  cannot  find  symbol  dirty  [CONTEXT]  public  static  Document  parse  (  File  in  ,  String  charsetName  )  throws  IOException  {  String  html  =  DataUtil  .  load  (  in  ,  charsetName  )  ;  [ATTENTION]  return  cleaner  .  isValid  (  dirty  )    ;  }    [METHOD]  parse  [TYPE]  Document  [PARAMETER]  File  in  String  charsetName  [CLASS]  Jsoup    [TYPE]  boolean  false  true  [TYPE]  String  charsetName  html  [TYPE]  File  in  
[REPLACE]  return  Parser  .  parseBodyFragment  (  bodyHtml,  baseUri  )  ;	[BUGGY]  return  Parser  .  parse  (  bodyHtml  ,  baseUri  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  static  Document  parseBodyFragment  (  String  bodyHtml  ,  String  baseUri  )  {  [ATTENTION]  return  Parser  .  parse  (  bodyHtml  ,  baseUri  )    ;  }    [METHOD]  parseBodyFragment  [TYPE]  Document  [PARAMETER]  String  bodyHtml  String  baseUri  [CLASS]  Jsoup    [TYPE]  boolean  false  true  [TYPE]  String  baseUri  bodyHtml  
[REPLACE]  return  Parser  .  parseBodyFragment  (  bodyHtml,   " "  )  ;	[BUGGY]  return  Parser  .  parseBodyFragment  (  bodyHtml  )    ;  [CE]  method  parseBodyFragment  in  class  Parser  cannot  be  applied  to  given  types  ;  [CONTEXT]  public  static  Document  parseBodyFragment  (  String  bodyHtml  )  {  [ATTENTION]  return  Parser  .  parseBodyFragment  (  bodyHtml  )  ;  }    [METHOD]  parseBodyFragment  [TYPE]  Document  [PARAMETER]  String  bodyHtml  [CLASS]  Jsoup    [TYPE]  boolean  false  true  [TYPE]  String  bodyHtml  
[REPLACE]  Document  dirty  =  parseBodyFragment  (  bodyHtml,  baseUri  )  ;	[BUGGY]  Document  dirty  =  parseBodyFragment  (  bodyHtml  ,   " "  )  ;  [FE]  null  assertEquals( "Yahoo!  JAPAN "  ,  doc.title())  ;  assertEquals( "http://www.yahoo.co.jp/_ylh  =  X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/t/2322m2 "  ,  assertEquals( " "  ,  a.text())  ;  [CONTEXT]  public  static  String  clean  (  String  bodyHtml  ,  String  baseUri  ,  Whitelist  whitelist  )  {  [ATTENTION]  Document  dirty  =  parseBodyFragment  (  bodyHtml  ,   " "  )    ;  Cleaner  cleaner  =  new  Cleaner  (  whitelist  )  ;  Document  clean  =  cleaner  .  clean  (  dirty  )  ;  return  clean  .  body  (  )  .  html  (  )  ;  }    [METHOD]  clean  [TYPE]  String  [PARAMETER]  String  bodyHtml  String  baseUri  Whitelist  whitelist  [CLASS]  Jsoup    [TYPE]  boolean  false  true  [TYPE]  Whitelist  whitelist  [TYPE]  String  baseUri  bodyHtml  [TYPE]  Document  clean  dirty  [TYPE]  Cleaner  cleaner  
[REPLACE]  Cleaner  cleaner  =  new  Cleaner  (  whitelist  )  ;	[BUGGY]  Document  clean  =  cleaner  .  clean  (  dirty  )  ;  [CE]  cannot  find  symbol  cleaner  [CONTEXT]  public  static  String  clean  (  String  bodyHtml  ,  String  baseUri  ,  Whitelist  whitelist  )  {  Document  dirty  =  parseBodyFragment  (  bodyHtml  ,  baseUri  )  ;  [ATTENTION]  Document  clean  =  cleaner  .  clean  (  dirty  )    ;  Document  clean  =  cleaner  .  clean  (  dirty  )  ;  return  clean  .  body  (  )  .  html  (  )  ;  }    [METHOD]  clean  [TYPE]  String  [PARAMETER]  String  bodyHtml  String  baseUri  Whitelist  whitelist  [CLASS]  Jsoup    [TYPE]  boolean  false  true  [TYPE]  Whitelist  whitelist  [TYPE]  String  baseUri  bodyHtml  [TYPE]  Document  clean  dirty  [TYPE]  Cleaner  cleaner  
[REPLACE]  Document  clean  =  cleaner  .  clean  (  dirty  )  ;	[BUGGY]  Document  .  isValid  =  cleaner  .  clean  (  dirty  )  ;  [CE]  cannot  find  symbol  isValid  [CONTEXT]  public  static  String  clean  (  String  bodyHtml  ,  String  baseUri  ,  Whitelist  whitelist  )  {  Document  dirty  =  parseBodyFragment  (  bodyHtml  ,  baseUri  )  ;  Cleaner  cleaner  =  new  Cleaner  (  whitelist  )  ;  [ATTENTION]  Document  .  isValid  =  cleaner  .  clean  (  dirty  )    ;  return  clean  .  body  (  )  .  html  (  )  ;  }    [METHOD]  clean  [TYPE]  String  [PARAMETER]  String  bodyHtml  String  baseUri  Whitelist  whitelist  [CLASS]  Jsoup    [TYPE]  boolean  false  true  [TYPE]  Whitelist  whitelist  [TYPE]  String  baseUri  bodyHtml  [TYPE]  Document  clean  dirty  [TYPE]  Cleaner  cleaner  
[ADD]  Document  clean  =  cleaner  .  clean  (  dirty  )  ;	[BUGGY]  [CE]  cannot  find  symbol  clean  [CONTEXT]  public  static  String  clean  (  String  bodyHtml  ,  String  baseUri  ,  Whitelist  whitelist  )  {  Document  dirty  =  parseBodyFragment  (  bodyHtml  ,  baseUri  )  ;  Cleaner  cleaner  =  new  Cleaner  (  whitelist  )  ;  [ATTENTION]  return  clean  .  body  (  )  .  html  (  )  ;  }    [METHOD]  clean  [TYPE]  String  [PARAMETER]  String  bodyHtml  String  baseUri  Whitelist  whitelist  [CLASS]  Jsoup    [TYPE]  boolean  false  true  [TYPE]  Whitelist  whitelist  [TYPE]  String  baseUri  bodyHtml  [TYPE]  Document  clean  dirty  [TYPE]  Cleaner  cleaner  
[REPLACE]  return  clean  .  body  (  )    .  html  (  )  ;	[BUGGY]  return  cleaner  .  isValid  (  dirty  )  ;  [CE]  incompatible  types  [CONTEXT]  public  static  String  clean  (  String  bodyHtml  ,  String  baseUri  ,  Whitelist  whitelist  )  {  Document  dirty  =  parseBodyFragment  (  bodyHtml  ,  baseUri  )  ;  Cleaner  cleaner  =  new  Cleaner  (  whitelist  )  ;  Document  clean  =  cleaner  .  clean  (  dirty  )  ;  [ATTENTION]  return  cleaner  .  isValid  (  dirty  )    ;  }    [METHOD]  clean  [TYPE]  String  [PARAMETER]  String  bodyHtml  String  baseUri  Whitelist  whitelist  [CLASS]  Jsoup    [TYPE]  boolean  false  true  [TYPE]  Whitelist  whitelist  [TYPE]  String  baseUri  bodyHtml  [TYPE]  Document  clean  dirty  [TYPE]  Cleaner  cleaner  
[REPLACE]  return  clean  (  bodyHtml,   " ",  whitelist  )  ;	[BUGGY]  return  cleaner  .  isValid  (  dirty  )  ;  [CE]  cannot  find  symbol  dirty  [CONTEXT]  public  static  String  clean  (  String  bodyHtml  ,  Whitelist  whitelist  )  {  [ATTENTION]  return  cleaner  .  isValid  (  dirty  )    ;  }    [METHOD]  clean  [TYPE]  String  [PARAMETER]  String  bodyHtml  Whitelist  whitelist  [CLASS]  Jsoup    [TYPE]  boolean  false  true  [TYPE]  Whitelist  whitelist  [TYPE]  String  bodyHtml  
[REPLACE]  Document  dirty  =  parseBodyFragment  (  bodyHtml,   " "  )  ;	[BUGGY]  Document  dirty  =  parseBodyFragment  (  bodyHtml  ,  baseUri  )  ;  [CE]  cannot  find  symbol  baseUri  [CONTEXT]  public  static  boolean  isValid  (  String  bodyHtml  ,  Whitelist  whitelist  )  {  [ATTENTION]  Document  dirty  =  parseBodyFragment  (  bodyHtml  ,  baseUri  )    ;  Cleaner  cleaner  =  new  Cleaner  (  whitelist  )  ;  return  cleaner  .  isValid  (  dirty  )  ;  }    [METHOD]  isValid  [TYPE]  boolean  [PARAMETER]  String  bodyHtml  Whitelist  whitelist  [CLASS]  Jsoup    [TYPE]  boolean  false  true  [TYPE]  Whitelist  whitelist  [TYPE]  String  bodyHtml  [TYPE]  Document  dirty  [TYPE]  Cleaner  cleaner  
[ADD]  Document  dirty  =  parseBodyFragment  (  bodyHtml,   " "  )  ;	[BUGGY]  [CE]  cannot  find  symbol  dirty  [CONTEXT]  public  static  boolean  isValid  (  String  bodyHtml  ,  Whitelist  whitelist  )  {  [ATTENTION]  Cleaner  cleaner  =  new  Cleaner  (  whitelist  )  ;  return  cleaner  .  isValid  (  dirty  )  ;  }    [METHOD]  isValid  [TYPE]  boolean  [PARAMETER]  String  bodyHtml  Whitelist  whitelist  [CLASS]  Jsoup    [TYPE]  boolean  false  true  [TYPE]  Whitelist  whitelist  [TYPE]  String  bodyHtml  [TYPE]  Document  dirty  [TYPE]  Cleaner  cleaner  
[REPLACE]  Cleaner  cleaner  =  new  Cleaner  (  whitelist  )  ;	[BUGGY]  Document  clean  =  cleaner  .  clean  (  dirty  )  ;  [CE]  cannot  find  symbol  cleaner  [CONTEXT]  public  static  boolean  isValid  (  String  bodyHtml  ,  Whitelist  whitelist  )  {  Document  dirty  =  parseBodyFragment  (  bodyHtml  ,   " "  )  ;  [ATTENTION]  Document  clean  =  cleaner  .  clean  (  dirty  )    ;  return  cleaner  .  isValid  (  dirty  )  ;  }    [METHOD]  isValid  [TYPE]  boolean  [PARAMETER]  String  bodyHtml  Whitelist  whitelist  [CLASS]  Jsoup    [TYPE]  boolean  false  true  [TYPE]  Whitelist  whitelist  [TYPE]  String  bodyHtml  [TYPE]  Document  dirty  [TYPE]  Cleaner  cleaner  
[REPLACE]  return  cleaner  .  isValid  (  dirty  )  ;	[BUGGY]  return  cleaner  .  isValid  (  bodyHtml  ,  whitelist  )    ;  [CE]  method  isValid  in  class  Cleaner  cannot  be  applied  to  given  types  ;  [CONTEXT]  public  static  boolean  isValid  (  String  bodyHtml  ,  Whitelist  whitelist  )  {  Document  dirty  =  parseBodyFragment  (  bodyHtml  ,   " "  )  ;  Cleaner  cleaner  =  new  Cleaner  (  whitelist  )  ;  [ATTENTION]  return  cleaner  .  isValid  (  bodyHtml  ,  whitelist  )  ;  }    [METHOD]  isValid  [TYPE]  boolean  [PARAMETER]  String  bodyHtml  Whitelist  whitelist  [CLASS]  Jsoup    [TYPE]  boolean  false  true  [TYPE]  Whitelist  whitelist  [TYPE]  String  bodyHtml  [TYPE]  Document  dirty  [TYPE]  Cleaner  cleaner  
